diff --git a/include/tscore/ParseRules.h b/include/tscore/ParseRules.h
index d8fe31e51a7..847522e7d7e 100644
--- a/include/tscore/ParseRules.h
+++ b/include/tscore/ParseRules.h
@@ -33,7 +33,7 @@ typedef unsigned int CTypeResult;
 
 // Set this to 0 to disable SI
 // decimal multipliers
-#define USE_SI_MULTILIERS 1
+#define USE_SI_MULTIPLIERS 1
 
 #define is_char_BIT (1 << 0)
 #define is_upalpha_BIT (1 << 1)
diff --git a/src/traffic_cache_tool/CacheDefs.cc b/src/traffic_cache_tool/CacheDefs.cc
index a87e3c5aad3..e84fd23db8b 100644
--- a/src/traffic_cache_tool/CacheDefs.cc
+++ b/src/traffic_cache_tool/CacheDefs.cc
@@ -874,7 +874,7 @@ Errata
 Stripe::loadMeta()
 {
   // Read from disk in chunks of this size. This needs to be a multiple of both the
-  // store block size and the directory entry size so neither goes acrss read boundaries.
+  // store block size and the directory entry size so neither goes across read boundaries.
   // Beyond that the value should be in the ~10MB range for what I guess is best performance
   // vs. blocking production disk I/O on a live system.
   constexpr static int64_t N = (1 << 8) * CacheStoreBlocks::SCALE * sizeof(CacheDirEntry);
diff --git a/src/traffic_cache_tool/CacheDefs.h b/src/traffic_cache_tool/CacheDefs.h
index 1d42d481695..8b42a92ba40 100644
--- a/src/traffic_cache_tool/CacheDefs.h
+++ b/src/traffic_cache_tool/CacheDefs.h
@@ -467,7 +467,7 @@ struct Span {
   /// Local copy of serialized header data stored on in the span.
   std::unique_ptr<ts::SpanHeader> _header;
   /// Live information about stripes.
-  /// Seeded from @a _header and potentially agumented with direct probing.
+  /// Seeded from @a _header and potentially augmented with direct probing.
   std::list<Stripe *> _stripes;
 };
 /* --------------------------------------------------------------------------------------- */
diff --git a/src/traffic_cache_tool/CacheScan.cc b/src/traffic_cache_tool/CacheScan.cc
index e52b256db7d..d46572b6cb9 100644
--- a/src/traffic_cache_tool/CacheScan.cc
+++ b/src/traffic_cache_tool/CacheScan.cc
@@ -208,7 +208,7 @@ CacheScan::unmarshal(HdrHeap *hh, int buf_length, int obj_type, HdrHeapObjImpl *
   while (obj_data < hh->m_free_start) {
     HdrHeapObjImpl *obj = (HdrHeapObjImpl *)obj_data;
     if (!obj_is_aligned(obj)) {
-      std::cout << "Invalid alignmgnt of object of type HdrHeapObjImpl" << std::endl;
+      std::cout << "Invalid alignment of object of type HdrHeapObjImpl" << std::endl;
       return zret;
     }
 
@@ -259,7 +259,7 @@ CacheScan::unmarshal(char *buf, int len, RefCountObj *block_ref)
   int orig_len      = len;
 
   if (alt->m_magic == CACHE_ALT_MAGIC_ALIVE) {
-    // Already unmarshaled, must be a ram cache
+    // Already unmarshalled, must be a ram cache
     //  it
     ink_assert(alt->m_unmarshal_len > 0);
     ink_assert(alt->m_unmarshal_len <= len);
diff --git a/src/traffic_cache_tool/CacheTool.cc b/src/traffic_cache_tool/CacheTool.cc
index 094538228f9..4c60dd9730f 100644
--- a/src/traffic_cache_tool/CacheTool.cc
+++ b/src/traffic_cache_tool/CacheTool.cc
@@ -980,7 +980,7 @@ Cache::build_stripe_hash_table()
     ttable[i] = VOL_HASH_EMPTY;
   }
 
-  // generate random numbers proportaion to allocation
+  // generate random numbers proportional to allocation
   rtable_pair *rtable = (rtable_pair *)ats_malloc(sizeof(rtable_pair) * rtable_size);
   int rindex          = 0;
   for (int i = 0; i < num_stripes; i++) {
diff --git a/src/traffic_ctl/config.cc b/src/traffic_ctl/config.cc
index 22198d23a29..61af1998bc5 100644
--- a/src/traffic_ctl/config.cc
+++ b/src/traffic_ctl/config.cc
@@ -63,7 +63,7 @@ rec_typeof(int rec_type)
     return "FLOAT";
   case TS_REC_STRING:
     return "STRING";
-  case TS_REC_UNDEFINED: /* fallthru */
+  case TS_REC_UNDEFINED: /* fallthrough */
   default:
     return "UNDEFINED";
   }
@@ -98,7 +98,7 @@ rec_accessof(int rec_access)
     return "no access";
   case RECA_READ_ONLY:
     return "read only";
-  case RECA_NULL: /* fallthru */
+  case RECA_NULL: /* fallthrough */
   default:
     return "default";
   }
@@ -115,7 +115,7 @@ rec_updateof(int rec_updatetype)
     return "static, restart traffic_server";
   case RECU_RESTART_TM:
     return "static, restart traffic_manager";
-  case RECU_NULL: /* fallthru */
+  case RECU_NULL: /* fallthrough */
   default:
     return "none";
   }
@@ -132,7 +132,7 @@ rec_checkof(int rec_checktype)
     return "integer with a specified range";
   case RECC_IP:
     return "IP address";
-  case RECC_NULL: /* fallthru */
+  case RECC_NULL: /* fallthrough */
   default:
     return "none";
   }
diff --git a/src/traffic_ctl/traffic_ctl.h b/src/traffic_ctl/traffic_ctl.h
index f02fe27b51b..94073f6323e 100644
--- a/src/traffic_ctl/traffic_ctl.h
+++ b/src/traffic_ctl/traffic_ctl.h
@@ -175,7 +175,7 @@ struct CtrlEngine {
   int status_code = CTRL_EX_OK;
 
   // All traffic_ctl methods:
-  // umimplemented command
+  // unimplemented command
   void CtrlUnimplementedCommand(std::string_view command);
 
   // alarm methods
diff --git a/src/traffic_layout/engine.cc b/src/traffic_layout/engine.cc
index 3838d63acd8..fc994b9c74e 100644
--- a/src/traffic_layout/engine.cc
+++ b/src/traffic_layout/engine.cc
@@ -96,7 +96,7 @@ path_handler(const std::string &path, bool run_flag, const std::string &command)
   std::string cur_working_dir = "";
   char cwd[PATH_MAX];
   if (!getcwd(cwd, sizeof(cwd))) {
-    ink_warning("unexcepted failure from getcwd() - %s", strerror(errno));
+    ink_warning("unexpected failure from getcwd() - %s", strerror(errno));
   } else {
     cur_working_dir = cwd;
   }
@@ -378,7 +378,7 @@ LayoutEngine::remove_runroot()
     std::string cur_working_dir = "";
     char cwd[PATH_MAX];
     if (getcwd(cwd, sizeof(cwd)) == nullptr) {
-      ink_warning("unexcepted failure from getcwd() - %s", strerror(errno));
+      ink_warning("unexpected failure from getcwd() - %s", strerror(errno));
     } else {
       cur_working_dir = cwd;
     }
diff --git a/src/traffic_layout/engine.h b/src/traffic_layout/engine.h
index c79a186d648..91098e7d42e 100644
--- a/src/traffic_layout/engine.h
+++ b/src/traffic_layout/engine.h
@@ -43,7 +43,7 @@ struct PermissionEntry {
 // PermissionEntry contains the read/write/execute mode and the result of output
 using PermissionMapType = std::unordered_map<std::string, PermissionEntry>;
 
-// structure for informaiton of the runroot passing around
+// structure for information of the runroot passing around
 struct LayoutEngine {
   // default output of all layouts
   void info();
@@ -62,7 +62,7 @@ struct LayoutEngine {
   ts::ArgParser parser;
   // parsed arguments
   ts::Arguments arguments;
-  // mordern argv
+  // modern argv
   std::vector<std::string> _argv;
 
   int status_code = 0;
diff --git a/src/traffic_layout/file_system.cc b/src/traffic_layout/file_system.cc
index cbfa14bcd7b..f75fcebc0ed 100644
--- a/src/traffic_layout/file_system.cc
+++ b/src/traffic_layout/file_system.cc
@@ -247,7 +247,7 @@ ts_copy_function(const char *src_path, const struct stat *sb, int flag)
     // if the file already exist, overwrite it
     if (exists(dst_path)) {
       if (remove(dst_path.c_str())) {
-        ink_error("overwrite file falied during copy");
+        ink_error("overwrite file failed during copy");
       }
     }
     // hardlink bin executable
@@ -271,7 +271,7 @@ ts_copy_function(const char *src_path, const struct stat *sb, int flag)
     std::ofstream dst(dst_path, std::ios::binary);
     dst << src.rdbuf();
     if (chmod(dst_path.c_str(), sb->st_mode) == -1) {
-      ink_warning("failed chomd the destination path: %s", strerror(errno));
+      ink_warning("failed chmod the destination path: %s", strerror(errno));
     }
   }
   return 0;
diff --git a/src/traffic_layout/file_system.h b/src/traffic_layout/file_system.h
index 2d1210c4ff6..1f174c200cb 100644
--- a/src/traffic_layout/file_system.h
+++ b/src/traffic_layout/file_system.h
@@ -32,7 +32,7 @@
 // full copy, hardlink, softlink
 enum CopyStyle { FULL, HARD, SOFT };
 
-// append slash & remove slash of path for convinient use
+// append slash & remove slash of path for convenient use
 void append_slash(std::string &path);
 
 // for file system
diff --git a/src/traffic_logstats/logstats.cc b/src/traffic_logstats/logstats.cc
index 2cb72233b61..d396c4ed3c1 100644
--- a/src/traffic_logstats/logstats.cc
+++ b/src/traffic_logstats/logstats.cc
@@ -1107,7 +1107,7 @@ update_codes(OriginStats *stat, int code, int size)
 inline void
 update_methods(OriginStats *stat, int method, int size)
 {
-  // We're so loppsided on GETs, so makes most sense to test 'out of order'.
+  // We're so lopsided on GETs, so makes most sense to test 'out of order'.
   switch (method) {
   case METHOD_GET:
     update_counter(stat->methods.get, size);
@@ -2167,7 +2167,7 @@ print_detail_stats(const OriginStats *stat, bool json, bool concise)
   if (!json) {
     std::cout << std::endl << std::endl;
 
-    // Protocol familes
+    // Protocol families
     format_detail_header("Protocols");
   }
 
diff --git a/src/traffic_manager/AddConfigFilesHere.cc b/src/traffic_manager/AddConfigFilesHere.cc
index dc816b00903..0ace074e4ea 100644
--- a/src/traffic_manager/AddConfigFilesHere.cc
+++ b/src/traffic_manager/AddConfigFilesHere.cc
@@ -54,7 +54,7 @@ registerFile(const char *configName, const char *defaultName)
 //
 // initializeRegistry()
 //
-// Code to initialze of registry of objects that represent
+// Code to initialize of registry of objects that represent
 //   Web Editable configuration files
 //
 // thread-safe: NO!  - Should only be executed once from the main
diff --git a/src/traffic_manager/traffic_manager.cc b/src/traffic_manager/traffic_manager.cc
index b4b7aa96777..f7d3835afdc 100644
--- a/src/traffic_manager/traffic_manager.cc
+++ b/src/traffic_manager/traffic_manager.cc
@@ -309,7 +309,7 @@ initSignalHandlers()
 
   // Block the delivery of any signals we are not catching
   //
-  //  except for SIGALARM since we use it
+  //  except for SIGALRM since we use it
   //    to break out of deadlock on semaphore
   //    we share with the proxy
   //
diff --git a/src/traffic_server/FetchSM.cc b/src/traffic_server/FetchSM.cc
index 436405fa34e..fd953c01fab 100644
--- a/src/traffic_server/FetchSM.cc
+++ b/src/traffic_server/FetchSM.cc
@@ -376,7 +376,7 @@ FetchSM::get_info_from_buffer(IOBufferReader *reader)
   info            = (char *)ats_malloc(sizeof(char) * (read_avail + 1));
   client_response = info;
 
-  // To maintain backwards compatability we don't allow chunking when it's not streaming.
+  // To maintain backwards compatibility we don't allow chunking when it's not streaming.
   if (!(fetch_flags & TS_FETCH_FLAGS_STREAM) || !check_chunked()) {
     /* Read the data out of the reader */
     while (read_avail > 0) {
diff --git a/src/traffic_server/FetchSM.h b/src/traffic_server/FetchSM.h
index dc7f89bfc8c..0e57e4ce8b4 100644
--- a/src/traffic_server/FetchSM.h
+++ b/src/traffic_server/FetchSM.h
@@ -66,7 +66,7 @@ class FetchSM : public Continuation
     mutex = new_ProxyMutex();
 
     //
-    // We had dropped response_buffer/respone_reader to avoid unnecessary
+    // We had dropped response_buffer/response_reader to avoid unnecessary
     // memory copying. But for the original TSFetchURL() API, PluginVC may
     // stop adding data to resp_buffer when the pending data in resp_buffer
     // reach its water_mark.
@@ -130,7 +130,7 @@ class FetchSM : public Continuation
   {
     return req_reader->read_avail();
   }
-  /// Check if the comma supproting MIME field @a name has @a value in it.
+  /// Check if the comma supporting MIME field @a name has @a value in it.
   bool check_for_field_value(const char *name, size_t name_len, char const *value, size_t value_len);
 
   bool has_body();
diff --git a/src/traffic_server/HostStatus.cc b/src/traffic_server/HostStatus.cc
index fdbd6b9b08d..0facb4cc222 100644
--- a/src/traffic_server/HostStatus.cc
+++ b/src/traffic_server/HostStatus.cc
@@ -115,7 +115,7 @@ handle_record_read(const RecRecord *rec, void *edata)
 
     // if the data loaded from stats indicates that the host was down,
     // then update the state so that the host remains down until
-    // specificcaly marked up using traffic_ctl.
+    // specifically marked up using traffic_ctl.
     if (rec->data.rec_int == 0 && Reasons::validReason(reason.c_str())) {
       hs.setHostStatus(hostname.c_str(), HOST_STATUS_DOWN, 0, reason.c_str());
     }
diff --git a/src/traffic_server/InkAPI.cc b/src/traffic_server/InkAPI.cc
index 94b829fdda3..2111fa0c265 100644
--- a/src/traffic_server/InkAPI.cc
+++ b/src/traffic_server/InkAPI.cc
@@ -3510,7 +3510,7 @@ TSMimeHdrFieldValueDateInsert(TSMBuffer bufp, TSMLoc hdr, TSMLoc field, time_t v
 
   char tmp[33];
   int len = mime_format_date(tmp, value);
-  // idx ignored, overwrite all exisiting values
+  // idx ignored, overwrite all existing values
   // (void)TSMimeFieldValueInsert(bufp, field_obj, tmp, len, idx);
   (void)TSMimeFieldValueSet(bufp, field, -1, tmp, len);
   return TS_SUCCESS;
@@ -7507,7 +7507,7 @@ TSMgmtConfigIntSet(const char *var_name, TSMgmtInt value)
 
   // tell manager to set the configuration; note that this is not
   // transactional (e.g. we return control to the plugin before the
-  // value is commited to disk by the manager)
+  // value is committed to disk by the manager)
   RecSignalManager(MGMT_SIGNAL_PLUGIN_SET_CONFIG, buffer);
 
   return TS_SUCCESS;
diff --git a/src/traffic_server/InkAPITest.cc b/src/traffic_server/InkAPITest.cc
index 5e574991284..50e0c99364c 100644
--- a/src/traffic_server/InkAPITest.cc
+++ b/src/traffic_server/InkAPITest.cc
@@ -438,7 +438,7 @@ generate_response(const char *request)
       break;
     }
   } else {
-    /* Didin't recognize a testcase request. send the default response */
+    /* Didn't recognize a testcase request. send the default response */
     snprintf(response, RESPONSE_MAX_SIZE + 1, HTTP_RESPONSE_DEFAULT_FORMAT, test_case);
   }
 
@@ -1202,7 +1202,7 @@ SDK_RPRINT(RegressionTest *t, const char *api_name, const char *testcase_name, i
    REGRESSION_TEST_INPROGRESS
    REGRESSION_TEST_FAILED
    REGRESSION_TEST_NOT_RUN
-  Note: pstatus is polled and can be used for asynchroneous tests.
+  Note: pstatus is polled and can be used for asynchronous tests.
 
 */
 
@@ -1595,7 +1595,7 @@ REGRESSION_TEST(SDK_API_TSPortDescriptor)(RegressionTest *test, int /* atype ATS
 //    (OBJECT_SIZE/2, then OBJECT_SIZE-100 and finally OBJECT_SIZE)
 //  - read object from the cache
 //  - remove it from the cache
-//  - try to read it (should faild)
+//  - try to read it (should fail)
 
 #define OBJECT_SIZE 100000 // size of the object we'll write/read/remove in cache
 
@@ -2621,7 +2621,7 @@ REGRESSION_TEST(SDK_API_TSContMutexGet)(RegressionTest *test, int /* atype ATS_U
     SDK_RPRINT(test, "TSContMutexGet", "TestCase1", TC_PASS, "ok");
     test_passed = true;
   } else {
-    SDK_RPRINT(test, "TSContMutexGet", "TestCase1", TC_FAIL, "Continutation's mutex corrupted");
+    SDK_RPRINT(test, "TSContMutexGet", "TestCase1", TC_FAIL, "Continuation's mutex corrupted");
   }
 
   // Status of the whole test
@@ -3005,7 +3005,7 @@ REGRESSION_TEST(SDK_API_TSIOBufferBlockNext)(RegressionTest *test, int /* atype
   TSIOBufferReader readerp = TSIOBufferReaderAlloc(bufp);
   TSIOBufferBlock blockp   = TSIOBufferReaderStart(readerp);
 
-  // TODO: This is probaby not the best of regression tests right now ...
+  // TODO: This is probably not the best of regression tests right now ...
   // Note that this assumes block size is > sizeof(int) bytes.
   if (TSIOBufferBlockNext(blockp) == nullptr) {
     SDK_RPRINT(test, "TSIOBufferBlockNext", "TestCase1", TC_PASS, "ok");
@@ -6361,7 +6361,7 @@ log_test_handler(TSCont contp, TSEvent event, void * /* edata ATS_UNUSED */)
   *(data->pstatus) = REGRESSION_TEST_PASSED;
   SDK_RPRINT(data->test, "TSTextLogObject", "TestCase1", TC_PASS, "ok");
 
-  // figure out the matainfo file for cleanup.
+  // figure out the metainfo file for cleanup.
   // code from MetaInfo::_build_name(const char *filename)
   int i = -1, l = 0;
   char c;
@@ -8363,7 +8363,7 @@ EXCLUSIVE_REGRESSION_TEST(SDK_API_HttpAltInfo)(RegressionTest *test, int /* atyp
 //////////////////////////////////////////////
 
 // Important: we create servers listening on different port than the default one
-// to make sure our synthetix servers are called
+// to make sure our synthetic servers are called
 
 #define TEST_CASE_CONNECT_ID1 9  // TSHttpTxnIntercept
 #define TEST_CASE_CONNECT_ID2 10 // TSHttpTxnServerIntercept
@@ -8527,7 +8527,7 @@ EXCLUSIVE_REGRESSION_TEST(SDK_API_TSHttpConnectServerIntercept)(RegressionTest *
 {
   *pstatus = REGRESSION_TEST_INPROGRESS;
 
-  TSDebug(UTDBG_TAG, "Starting test TSHttpConnectServerintercept");
+  TSDebug(UTDBG_TAG, "Starting test TSHttpConnectServerIntercept");
 
   TSCont cont_test      = TSContCreate(cont_test_handler, TSMutexCreate());
   ConnectTestData *data = (ConnectTestData *)TSmalloc(sizeof(ConnectTestData));
@@ -9073,7 +9073,7 @@ REGRESSION_TEST(SDK_API_UUID)(RegressionTest *test, int /* atype ATS_UNUSED */,
 
   // Test TSUuidCreate
   if (!(uuid = TSUuidCreate())) {
-    SDK_RPRINT(test, "TSUuidCreate", "TestCase1", TC_FAIL, "Failed to crete a UUID object");
+    SDK_RPRINT(test, "TSUuidCreate", "TestCase1", TC_FAIL, "Failed to create a UUID object");
     *pstatus = REGRESSION_TEST_FAILED;
     return;
   } else {
diff --git a/src/traffic_server/SocksProxy.cc b/src/traffic_server/SocksProxy.cc
index 77208ee4669..824e395a75f 100644
--- a/src/traffic_server/SocksProxy.cc
+++ b/src/traffic_server/SocksProxy.cc
@@ -22,7 +22,7 @@
  */
 
 /*
-  This implements SOCKS server. We intecept the http traffic and send it
+  This implements SOCKS server. We intercept the http traffic and send it
   through HTTP. Others are tunneled through directly to the socks server.
 
 
@@ -403,7 +403,7 @@ SocksProxy::sendResp(bool granted)
   // In SOCKS 4, IP addr and Dest Port fields are ignored.
   // In SOCKS 5, IP addr and Dest Port are the ones we use to connect to the
   // real host. In our case, it does not make sense, since we may not
-  // connect at all. Set these feilds to zeros. Any socks client which uses
+  // connect at all. Set these fields to zeros. Any socks client which uses
   // these breaks caching.
 
   buf->reset();
@@ -446,7 +446,7 @@ SocksProxy::setupHttpRequest(unsigned char *p)
     break;
 
   case SOCKS_ATYPE_FQHN:
-    // This is stored as a zero terminicated string
+    // This is stored as a zero terminated string
     a->addr.buf = (unsigned char *)ats_malloc(p[4] + 1);
     memcpy(a->addr.buf, &p[5], p[4]);
     a->addr.buf[p[4]] = 0;
diff --git a/src/traffic_server/traffic_server.cc b/src/traffic_server/traffic_server.cc
index 9c3c4bcf452..40e23026287 100644
--- a/src/traffic_server/traffic_server.cc
+++ b/src/traffic_server/traffic_server.cc
@@ -640,7 +640,7 @@ initialize_process_manager()
                         RECP_NON_PERSISTENT);
 }
 
-#define CMD_ERROR -2      // serious error, exit maintaince mode
+#define CMD_ERROR -2      // serious error, exit maintenance mode
 #define CMD_FAILED -1     // error, but recoverable
 #define CMD_OK 0          // ok, or minor (user) error
 #define CMD_HELP 1        // ok, print help
diff --git a/src/traffic_top/traffic_top.cc b/src/traffic_top/traffic_top.cc
index e093636f065..ffb4b3dd3aa 100644
--- a/src/traffic_top/traffic_top.cc
+++ b/src/traffic_top/traffic_top.cc
@@ -247,7 +247,7 @@ help(const string &host, const string &version)
     attron(A_BOLD);
     mvprintw(7, 0, "Definitions:");
     attroff(A_BOLD);
-    mvprintw(8, 0, "Fresh      => Requests that were servered by fresh entries in cache");
+    mvprintw(8, 0, "Fresh      => Requests that were served by fresh entries in cache");
     mvprintw(9, 0, "Revalidate => Requests that contacted the origin to verify if still valid");
     mvprintw(10, 0, "Cold       => Requests that were not in cache at all");
     mvprintw(11, 0, "Changed    => Requests that required entries in cache to be updated");
diff --git a/src/traffic_wccp/wccp_client.cc b/src/traffic_wccp/wccp_client.cc
index 95a16b4c172..6f2c691b816 100644
--- a/src/traffic_wccp/wccp_client.cc
+++ b/src/traffic_wccp/wccp_client.cc
@@ -49,7 +49,7 @@ bool do_daemon = false;
 
 static const char USAGE_TEXT[] = "%s\n"
                                  "--address IP address to bind.\n"
-                                 "--router Booststrap IP address for routers.\n"
+                                 "--router Bootstrap IP address for routers.\n"
                                  "--service Path to service group definitions.\n"
                                  "--debug Print debugging information.\n"
                                  "--daemon Run as daemon.\n"
diff --git a/src/tscore/ArgParser.cc b/src/tscore/ArgParser.cc
index b411f4c1e71..b7cb4af0219 100644
--- a/src/tscore/ArgParser.cc
+++ b/src/tscore/ArgParser.cc
@@ -162,7 +162,7 @@ ArgParser::parse(const char **argv)
   parser_program_name      = _argv[0];
   Arguments ret; // the parsed arg object to return
   AP_StrVec args = _argv;
-  // call the recrusive parse method in Command
+  // call the recursive parse method in Command
   if (!_top_level_command.parse(ret, args)) {
     // deal with default command
     if (!default_command.empty()) {
@@ -310,9 +310,9 @@ void
 ArgParser::Command::output_command(std::ostream &out, std::string const &prefix) const
 {
   if (_name != parser_program_name) {
-    // a nicely formated way to output command usage
+    // a nicely formatted way to output command usage
     std::string msg = prefix + _name;
-    // nicely formated output
+    // nicely formatted output
     if (!_description.empty()) {
       if (INDENT_ONE - static_cast<int>(msg.size()) < 0) {
         // if the command msg is too long
@@ -433,7 +433,7 @@ ArgParser::Command::append_option_data(Arguments &ret, AP_StrVec &args, int inde
       // output help message
       if ((args[i] == "--help" || args[i] == "-h") && _option_list.find("--help") != _option_list.end()) {
         ArgParser::Command *command = this;
-        // find the correct level to output help messsage
+        // find the correct level to output help message
         for (unsigned i = 1; i < args.size(); i++) {
           auto it = command->_subcommand_list.find(args[i]);
           if (it == command->_subcommand_list.end()) {
@@ -627,7 +627,7 @@ std::string const &
 ArgumentData::at(unsigned index) const
 {
   if (index >= _values.size()) {
-    throw std::out_of_range("argument not fonud at index: " + std::to_string(index));
+    throw std::out_of_range("argument not found at index: " + std::to_string(index));
   }
   return _values.at(index);
 }
diff --git a/src/tscore/BaseLogFile.cc b/src/tscore/BaseLogFile.cc
index 921a1608c84..682c32a1a6a 100644
--- a/src/tscore/BaseLogFile.cc
+++ b/src/tscore/BaseLogFile.cc
@@ -24,7 +24,7 @@
 #include "tscore/BaseLogFile.h"
 
 /*
- * This consturctor creates a BaseLogFile based on a given name.
+ * This constructor creates a BaseLogFile based on a given name.
  * This is the most common way BaseLogFiles are created.
  */
 BaseLogFile::BaseLogFile(const char *name) : m_name(ats_strdup(name))
@@ -33,7 +33,7 @@ BaseLogFile::BaseLogFile(const char *name) : m_name(ats_strdup(name))
 }
 
 /*
- * This consturctor creates a BaseLogFile based on a given name.
+ * This constructor creates a BaseLogFile based on a given name.
  * Similar to above constructor, but is overloaded with the object signature
  */
 BaseLogFile::BaseLogFile(const char *name, uint64_t sig) : m_name(ats_strdup(name)), m_signature(sig), m_has_signature(true)
@@ -155,7 +155,7 @@ BaseLogFile::roll(long interval_start, long interval_end)
     // produce overlapping filenames (the problem is that we have
     // no easy way of keeping track of the timestamp of the first
     // transaction
-    log_log_trace("in BaseLogFile::roll(..), didn't use metadata starttime, used earlist available starttime\n");
+    log_log_trace("in BaseLogFile::roll(..), didn't use metadata starttime, used earliest available starttime\n");
     if (interval_start == 0) {
       start = m_start_time;
     } else {
@@ -204,7 +204,7 @@ BaseLogFile::roll(long interval_start, long interval_end)
 }
 
 /*
- * The more convienent rolling function. Intended use is for less
+ * The more convenient rolling function. Intended use is for less
  * critical logs such as diags.log or traffic.out, since _exact_
  * timestamps may be less important
  *
@@ -331,7 +331,7 @@ BaseLogFile::open_file(int perm)
     }
   }
 
-  // set m_bytes_written to force the rolling based on filesize.
+  // set m_bytes_written to force the rolling based on file size.
   m_bytes_written = fseek(m_fp, 0, SEEK_CUR);
 
   log_log_trace("BaseLogFile %s is now open (fd=%d)\n", m_name.get(), fileno(m_fp));
@@ -535,7 +535,7 @@ BaseMetaInfo::_write_to_file()
     // TODO modify this runtime check so that it is not an assertion
     ink_release_assert(n <= BUF_SIZE);
     if (write(fd, _buffer, n) == -1) {
-      log_log_error("Could not write object_signaure\n");
+      log_log_error("Could not write object_signature\n");
     }
     log_log_trace("BaseMetaInfo::_write_to_file\n"
                   "\tfilename = %s\n"
diff --git a/src/tscore/BufferWriterFormat.cc b/src/tscore/BufferWriterFormat.cc
index 05d821a07d3..54eafdf7a29 100644
--- a/src/tscore/BufferWriterFormat.cc
+++ b/src/tscore/BufferWriterFormat.cc
@@ -239,7 +239,7 @@ namespace bw_fmt
       size_t delta = min - extent;
       char *base   = w.auxBuffer();        // should be first byte of @a lw e.g. lw.data() - avoid const_cast.
       char *limit  = base + lw.capacity(); // first invalid byte.
-      char *dst;                           // used to track memory operation targest;
+      char *dst;                           // used to track memory operation target;
       char *last;                          // track limit of memory operation.
       size_t d2;
       switch (spec._align) {
@@ -452,7 +452,7 @@ namespace bw_fmt
     width -= static_cast<int>(n);
     std::string_view digits{buff + sizeof(buff) - n, n};
 
-    if (spec._align == BWFSpec::Align::SIGN) { // custom for signed case because prefix and digits are seperated.
+    if (spec._align == BWFSpec::Align::SIGN) { // custom for signed case because prefix and digits are separated.
       if (neg) {
         w.write(neg);
       }
@@ -482,9 +482,9 @@ namespace bw_fmt
     return w;
   }
 
-  /// Format for floating point values. Seperates floating point into a whole number and a
+  /// Format for floating point values. Separates floating point into a whole number and a
   /// fraction. The fraction is converted into an unsigned integer based on the specified
-  /// precision, spec._prec. ie. 3.1415 with precision two is seperated into two unsigned
+  /// precision, spec._prec. ie. 3.1415 with precision two is separated into two unsigned
   /// integers 3 and 14. The different pieces are assembled and placed into the BufferWriter.
   /// The default is two decimal places. ie. X.XX. The value is always written in base 10.
   ///
diff --git a/src/tscore/CryptoHash.cc b/src/tscore/CryptoHash.cc
index 926e5f2452b..b422c85493a 100644
--- a/src/tscore/CryptoHash.cc
+++ b/src/tscore/CryptoHash.cc
@@ -69,7 +69,7 @@ CryptoContext::CryptoContext()
   @brief Converts a hash to a null-terminated string
 
   Externalizes an hash as a null-terminated string into the first argument.
-  Does so without intenal procedure calls.
+  Does so without internal procedure calls.
   Side Effects: none.
   Reentrancy:     n/a.
   Thread Safety:  safe.
diff --git a/src/tscore/Diags.cc b/src/tscore/Diags.cc
index b34db02566c..6c85e578469 100644
--- a/src/tscore/Diags.cc
+++ b/src/tscore/Diags.cc
@@ -204,7 +204,7 @@ Diags::~Diags()
 //
 //      This routine outputs to all of the output targets enabled for this
 //      debugging level in config.outputs[diags_level].  Many higher level
-//      diagnosting printing routines are built upon print_va, including:
+//      diagnostics printing routines are built upon print_va, including:
 //
 //              void print(...)
 //              void log_va(...)
diff --git a/src/tscore/HostLookup.cc b/src/tscore/HostLookup.cc
index 0a47f38a44c..b2c7166baf6 100644
--- a/src/tscore/HostLookup.cc
+++ b/src/tscore/HostLookup.cc
@@ -49,7 +49,7 @@ namespace
 bool
 domaincmp(string_view hostname, string_view domain)
 {
-  // Check to see if were passed emtpy strings for either
+  // Check to see if were passed empty strings for either
   //  argument.  Empty strings do not match anything
   //
   if (domain.empty() || hostname.empty()) {
@@ -150,7 +150,7 @@ hostcmp(string_view lhs, string_view rhs)
 //   '_' is also included although it is not in the spec (RFC 883)
 //
 //   Uppercase and lowercase "a-z" both map to same indexes
-//     since hostnames are not case sensative
+//     since hostnames are not case sensitive
 //
 //   Illegal characters map to 255
 //
@@ -177,7 +177,7 @@ static const unsigned char asciiToTable[256] = {
   255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
   255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255};
 
-// Number of legal characters in the acssiToTable array
+// Number of legal characters in the asciiToTable array
 static const int numLegalChars = 38;
 
 // struct CharIndexBlock
@@ -193,7 +193,7 @@ struct CharIndexBlock {
 };
 
 // class CharIndex - A constant time string matcher intended for
-//    short strings in a sparsely populated DNS paritition
+//    short strings in a sparsely populated DNS partition
 //
 //    Creates a look up table for character in data string
 //
@@ -458,7 +458,7 @@ CharIndex::iterator::operator!=(const self_type &that) const
 
 // class HostArray
 //
-//   Is a fixed size array for holding HostBrach*
+//   Is a fixed size array for holding HostBranch*
 //   Allows only sequential access to data
 //
 
@@ -656,7 +656,7 @@ HostLookup::TableNewLevel(HostBranch *from, string_view level_data)
 // HostBranch* HostLookup::InsertBranch(HostBranch* insert_to, const char* level_data)
 //
 //
-//    Abstrction to place a new node for level_data below node
+//    Abstraction to place a new node for level_data below node
 //      insert to.  Inserts into any of the data types used by
 //      by class HostMatcher
 //
diff --git a/src/tscore/IntrusivePtrTest.cc b/src/tscore/IntrusivePtrTest.cc
index c7cb58c3f1c..85bd7e3f063 100644
--- a/src/tscore/IntrusivePtrTest.cc
+++ b/src/tscore/IntrusivePtrTest.cc
@@ -26,7 +26,7 @@
 #include "tscore/TestBox.h"
 
 namespace
-{ // Hide our local defintions
+{ // Hide our local definitions
 
 // Test class for pointers and lists.
 class A : public IntrusivePtrCounter
diff --git a/src/tscore/IpMap.cc b/src/tscore/IpMap.cc
index 4a51962ca68..2fd01f8c937 100644
--- a/src/tscore/IpMap.cc
+++ b/src/tscore/IpMap.cc
@@ -842,7 +842,7 @@ namespace detail
     {
       return this->setMin(min + 1);
     }
-    /** Decremement the maximum value in place.
+    /** decrement the maximum value in place.
         @return This object.
     */
     self_type &
@@ -921,7 +921,7 @@ namespace detail
     /** Construct from the argument type.
      *
      * @param min Minimum value in the range.
-     * @param max Maximum value in the range (inclusvie).
+     * @param max Maximum value in the range (inclusive).
      * @param data Data to attach to the range.
      */
 
@@ -936,7 +936,7 @@ namespace detail
     /** Construct from the underlying @c Metric type @a min to @a max
      *
      * @param min Minimum value in the range.
-     * @param max Maximum value in the range (inclusvie).
+     * @param max Maximum value in the range (inclusive).
      * @param data Data to attach to the range.
      */
     Ip6Node(Metric const &min, Metric const &max, void *data) : Node(data), Ip6Span(min, max) {}
@@ -1028,7 +1028,7 @@ namespace detail
       inc(_min);
       return *this;
     }
-    /** Decremement the maximum value in place.
+    /** Decrement the maximum value in place.
         @return This object.
     */
     self_type &
@@ -1037,7 +1037,7 @@ namespace detail
       dec(_max);
       return *this;
     }
-    /** Increment the mininimum value in place.
+    /** Increment the minimum value in place.
         @return This object.
     */
     self_type &
diff --git a/src/tscore/JeAllocator.cc b/src/tscore/JeAllocator.cc
index 214ffc0223e..fd1b418a8bf 100644
--- a/src/tscore/JeAllocator.cc
+++ b/src/tscore/JeAllocator.cc
@@ -92,7 +92,7 @@ JemallocNodumpAllocator::extend_and_setup_arena()
 }
 
 /**
- * This will retain the orignal functionality if
+ * This will retain the original functionality if
  * !defined(JEMALLOC_NODUMP_ALLOCATOR_SUPPORTED)
  */
 void *
@@ -121,7 +121,7 @@ JemallocNodumpAllocator::allocate(InkFreeList *f)
 }
 
 /**
- * This will retain the orignal functionality if
+ * This will retain the original functionality if
  * !defined(JEMALLOC_NODUMP_ALLOCATOR_SUPPORTED)
  */
 void
diff --git a/src/tscore/MatcherUtils.cc b/src/tscore/MatcherUtils.cc
index 7e7648c0275..cb9822a2d75 100644
--- a/src/tscore/MatcherUtils.cc
+++ b/src/tscore/MatcherUtils.cc
@@ -44,7 +44,7 @@
 //   off the heap (via ats_malloc() )  Returns a pointer to the buffer
 //   is successful and nullptr otherwise.
 //
-//  CALLEE is responsibled for deallocating the buffer via ats_free()
+//  CALLEE is responsible for deallocating the buffer via ats_free()
 //
 char *
 readIntoBuffer(const char *file_path, const char *module_name, int *read_size_ptr)
@@ -495,7 +495,7 @@ parseConfigLine(char *line, matcher_line *p_line, const matcher_tags *tags)
     case PARSE_VAL:
       if (inQuote == true) {
         if (*s == '\\') {
-          // The next character is esacped
+          // The next character is escaped
           //
           // To remove the escaped character
           // we need to copy
diff --git a/src/tscore/ParseRules.cc b/src/tscore/ParseRules.cc
index a3b0f78a568..8958d39443d 100644
--- a/src/tscore/ParseRules.cc
+++ b/src/tscore/ParseRules.cc
@@ -75,7 +75,7 @@ ink_atoi64(const char *str)
     while (*str && ParseRules::is_digit(*str)) {
       num = (num * 10) - (*str++ - '0');
     }
-#if USE_SI_MULTILIERS
+#if USE_SI_MULTIPLIERS
     if (*str) {
       if (*str == 'K') {
         num = num * (1LL << 10);
@@ -113,7 +113,7 @@ ink_atoui64(const char *str)
     while (*str && ParseRules::is_digit(*str)) {
       num = (num * 10) + (*str++ - '0');
     }
-#if USE_SI_MULTILIERS
+#if USE_SI_MULTIPLIERS
     if (*str) {
       if (*str == 'K') {
         num = num * (1LL << 10);
@@ -165,7 +165,7 @@ ink_atoi64(const char *str, int len)
       num = (num * 10) - (*str++ - '0');
       len--;
     }
-#if USE_SI_MULTILIERS
+#if USE_SI_MULTIPLIERS
     if (len > 0 && *str) {
       if (*str == 'K') {
         num = num * (1 << 10);
diff --git a/src/tscore/TextBuffer.cc b/src/tscore/TextBuffer.cc
index ec62ca40c46..ef2b0b1750f 100644
--- a/src/tscore/TextBuffer.cc
+++ b/src/tscore/TextBuffer.cc
@@ -28,7 +28,7 @@
 
 /****************************************************************************
  *
- *  TextBuffer.cc - A self-expanding buffer, primarly meant for strings
+ *  TextBuffer.cc - A self-expanding buffer, primarily meant for strings
  *
  *
  *
@@ -40,7 +40,7 @@ TextBuffer::TextBuffer(int size)
   nextAdd     = nullptr;
   currentSize = spaceLeft = 0;
   if (size > 0) {
-    // Insitute a minimum size
+    // Institute a minimum size
     if (size < 1024) {
       size = 1024;
     }
@@ -162,8 +162,8 @@ TextBuffer::rawReadFromFile(int fd)
 {
   int readSize;
 
-  // Check to see if we have got a resonable amount of space left in our
-  //   buffer, if not try to get somemore
+  // Check to see if we have got a reasonable amount of space left in our
+  //   buffer, if not try to get some more
   if (spaceLeft < 4096) {
     if (enlargeBuffer(4096) == -1) {
       return -1;
@@ -198,15 +198,15 @@ TextBuffer::slurp(int fd)
 // int TextBuffer::readFromFD(int fd)
 //
 // Issues a single read command on the file
-// descritor passed in.  Attempts to read a minimum of
+// descriptor passed in.  Attempts to read a minimum of
 // 512 bytes from file descriptor passed.
 int
 TextBuffer::readFromFD(int fd)
 {
   int readSize;
 
-  // Check to see if we have got a resonable amount of space left in our
-  //   buffer, if not try to get somemore
+  // Check to see if we have got a reasonable amount of space left in our
+  //   buffer, if not try to get some more
   if (spaceLeft < 512) {
     if (enlargeBuffer(512) == -1) {
       return -1;
diff --git a/src/tscore/Tokenizer.cc b/src/tscore/Tokenizer.cc
index b538facc9fd..b7c7f790f56 100644
--- a/src/tscore/Tokenizer.cc
+++ b/src/tscore/Tokenizer.cc
@@ -192,7 +192,7 @@ Tokenizer::Initialize(char *str, unsigned opt)
 
   quoteFound = false;
 
-  // Check to see if we stoped due to a maxToken limit
+  // Check to see if we stopped due to a maxToken limit
   if (max_limit_hit == true) {
     if (options & ALLOW_EMPTY_TOKS) {
       // Go till either we hit a delimiter or we've
diff --git a/src/tscore/ink_base64.cc b/src/tscore/ink_base64.cc
index 47f2e6a8745..92dfa132660 100644
--- a/src/tscore/ink_base64.cc
+++ b/src/tscore/ink_base64.cc
@@ -101,7 +101,7 @@ ats_base64_encode(const char *inBuffer, size_t inBufferSize, char *outBuffer, si
 }
 
 /*-------------------------------------------------------------------------
-  This is a reentrant, and malloc free implemetnation of ats_base64_decode.
+  This is a reentrant, and malloc free implementation of ats_base64_decode.
   -------------------------------------------------------------------------*/
 #ifdef DECODE
 #undef DECODE
diff --git a/src/tscore/ink_file.cc b/src/tscore/ink_file.cc
index d737ad8b2d1..c0003c867eb 100644
--- a/src/tscore/ink_file.cc
+++ b/src/tscore/ink_file.cc
@@ -174,7 +174,7 @@ ink_filepath_merge(char *path, int pathsz, const char *rootpath, const char *add
   } else {
     // If INK_FILEPATH_NOTABSOLUTE is specified, the caller
     // requires a relative result.  If the rootpath is
-    // ommitted, we do not retrieve the working path,
+    // omitted, we do not retrieve the working path,
     // if rootpath was supplied as absolute then fail.
     //
     if (flags & INK_FILEPATH_NOTABSOLUTE) {
@@ -490,7 +490,7 @@ ink_file_get_geometry(int fd ATS_UNUSED, ink_device_geometry &geometry)
 #if defined(BLKALIGNOFF)
   // BLKALIGNOFF gets the number of bytes needed to align the I/Os to the block device with
   // and underlying block devices. This might be non-zero when you are using a logical volume
-  // backed by JBOD or RAID device(s). BLKALIGNOFF was addeed in 2.6.32, so it's not present in
+  // backed by JBOD or RAID device(s). BLKALIGNOFF was added in 2.6.32, so it's not present in
   // RHEL 5.
   if (ioctl(fd, BLKALIGNOFF, &arg.u32) == 0) {
     geometry.alignsz = arg.u32;
diff --git a/src/tscore/ink_memory.cc b/src/tscore/ink_memory.cc
index 8ffb964935d..aca92b80142 100644
--- a/src/tscore/ink_memory.cc
+++ b/src/tscore/ink_memory.cc
@@ -33,7 +33,7 @@
 
 #include <cassert>
 #if defined(linux)
-// XXX: SHouldn't that be part of CPPFLAGS?
+// XXX: Shouldn't that be part of CPPFLAGS?
 #ifndef _XOPEN_SOURCE
 #define _XOPEN_SOURCE 600
 #endif
@@ -168,7 +168,7 @@ ats_msync(caddr_t addr, size_t len, caddr_t end, int flags)
 
   // align start back to page boundary
   caddr_t a = (caddr_t)(((uintptr_t)addr) & ~(pagesize - 1));
-  // align length to page boundry covering region
+  // align length to page boundary covering region
   size_t l = (len + (addr - a) + (pagesize - 1)) & ~(pagesize - 1);
   if ((a + l) > end) {
     l = end - a; // strict limit
@@ -271,7 +271,7 @@ _xstrdup(const char *str, int length, const char * /* path ATS_UNUSED */)
       *newstr = '\0';
     } else {
       strncpy(newstr, str, length); // we cannot do length + 1 because the string isn't
-      newstr[length] = '\0';        // guaranteeed to be null terminated!
+      newstr[length] = '\0';        // guaranteed to be null terminated!
     }
     return newstr;
   }
diff --git a/src/tscore/ink_queue_utils.cc b/src/tscore/ink_queue_utils.cc
index 4246a3b58df..36fcdae2c6f 100644
--- a/src/tscore/ink_queue_utils.cc
+++ b/src/tscore/ink_queue_utils.cc
@@ -34,10 +34,10 @@
  * problem resulted in the discovery that gcc was spitting out the
  * "ldd" (load double) instruction for loading of the 64 bit field "data"
  * while CC was spitting out two "ld" (load) instructions. The old code
- * was calling item.data = head.data on sparcs and not putting any restriction
+ * was calling item.data = head.data on Sparcs and not putting any restriction
  * on the order of loading of the fields.
  *
- * This is a problem on the sparcs because the "pointer" field was being loaded
+ * This is a problem on the Sparcs because the "pointer" field was being loaded
  * before the "version" field. This can result in a very subtle race condition
  * which subverts the addition of the "version" field.
  *
@@ -50,7 +50,7 @@
  * next.version = item.version ++;
  * cas64(head, item, next)
 
- * Note, that the cas64 call will be succesful and the next.ptr will probably
+ * Note, that the cas64 call will be successful and the next.ptr will probably
  * be a pointer into the vtable entry. The next alloc will result in a write into
  * the vtable area.
  *
diff --git a/src/tscore/ink_res_init.cc b/src/tscore/ink_res_init.cc
index 962fc6b6070..be4dccce24d 100644
--- a/src/tscore/ink_res_init.cc
+++ b/src/tscore/ink_res_init.cc
@@ -129,7 +129,7 @@ ink_res_setservers(ink_res_state statp, IpEndpoint const *set, int cnt)
 
   /* The goal here seems to be to compress the source list (@a set) by
      squeezing out invalid addresses. We handle the special case where
-     the destination and sourcea are the same.
+     the destination and source are the same.
   */
   int nserv = 0;
   for (IpEndpoint const *limit = set + cnt; nserv < INK_MAXNS && set < limit; ++set) {
@@ -275,7 +275,7 @@ ink_res_randomid()
  * there will have precedence.  Otherwise, the server address is set to
  * INADDR_ANY and the default domain name comes from the gethostname().
  *
- * An interrim version of this code (BIND 4.9, pre-4.4BSD) used 127.0.0.1
+ * An interim version of this code (BIND 4.9, pre-4.4BSD) used 127.0.0.1
  * rather than INADDR_ANY ("0.0.0.0") as the default name server address
  * since it was noted that INADDR_ANY actually meant ``the first interface
  * you "ifconfig"'d at boot time'' and if this was a SLIP or PPP interface,
@@ -382,7 +382,7 @@ ink_res_init(ink_res_state statp,         ///< State object to update.
   }
 
   /* ---------------------------------------------
-     Default domain name and doamin Search list:
+     Default domain name and domain Search list:
 
      if we are supplied a default domain name,
      and/or search list we will use it. Otherwise,
@@ -427,7 +427,7 @@ ink_res_init(ink_res_state statp,         ///< State object to update.
   }
 
   /* -------------------------------------------
-     we must be provided with atleast a named!
+     we must be provided with at least a named!
      ------------------------------------------- */
   if (pHostList) {
     if (pHostListSize > INK_MAXNS) {
diff --git a/src/tscore/ink_res_mkquery.cc b/src/tscore/ink_res_mkquery.cc
index 4ae16427763..fdd0aa1375e 100644
--- a/src/tscore/ink_res_mkquery.cc
+++ b/src/tscore/ink_res_mkquery.cc
@@ -217,7 +217,7 @@ labellen(const u_char *lp)
       }
       return ((bitlen + 7) / 8 + 1);
     }
-    return (-1); /*%< unknwon ELT */
+    return (-1); /*%< unknown ELT */
   }
   return (l);
 }
@@ -278,7 +278,7 @@ decode_bitstring(const unsigned char **cpp, char *dn, const char *eom)
 
 /*%
  *	Thinking in noninternationalized USASCII (per the DNS spec),
- *	is this characted special ("in need of quoting") ?
+ *	is this character special ("in need of quoting") ?
  *
  * return:
  *\li	boolean.
diff --git a/src/tscore/ink_sock.cc b/src/tscore/ink_sock.cc
index c9406205f9f..ccb5d9995aa 100644
--- a/src/tscore/ink_sock.cc
+++ b/src/tscore/ink_sock.cc
@@ -50,7 +50,7 @@ check_valid_sockaddr(sockaddr *sa, char *file, int line)
   if (port > 20000) {
     cerr << "[byteordering] In " << file << ", line " << line << " the IP port ";
     cerr << "was found to be " << port << "(in host byte order).\n";
-    cerr << "[byteordering] This seems inplausible, so check for byte order problems\n";
+    cerr << "[byteordering] This seems implausible, so check for byte order problems\n";
   }
 }
 #else
diff --git a/src/tscore/ink_string++.cc b/src/tscore/ink_string++.cc
index bc8db8ac0d9..eac0718bac6 100644
--- a/src/tscore/ink_string++.cc
+++ b/src/tscore/ink_string++.cc
@@ -177,7 +177,7 @@ StrListOverflow::create_heap(int user_size)
   //  matter since we are talking about strings but since this is a
   //  last minute emergency bug fix, I'm not take any changes.  If
   //  allocations are not of aligned values then subsequents allocations
-  //  aren't aligned, again mirroring the previous implemnetation
+  //  aren't aligned, again mirroring the previous implementation
   int total_size = overflow_head_hdr_size + user_size;
 
   StrListOverflow *o = (StrListOverflow *)ats_malloc(total_size);
diff --git a/src/tscore/ink_time.cc b/src/tscore/ink_time.cc
index c8145cd01e8..ba36a1238bc 100644
--- a/src/tscore/ink_time.cc
+++ b/src/tscore/ink_time.cc
@@ -107,7 +107,7 @@ struct dtconv {
 /*
  * The man page for cftime lies. It claims that it is thread safe.
  * Instead, it silently trashes the heap (by freeing things more than
- * once) when used in a mulithreaded program. Gack!
+ * once) when used in a multithreaded program. Gack!
  */
 int
 cftime_replacement(char *s, int maxsize, const char *format, const time_t *clock)
diff --git a/src/tscore/load_http_hdr.cc b/src/tscore/load_http_hdr.cc
index b565438acf8..c9d840f6cb1 100644
--- a/src/tscore/load_http_hdr.cc
+++ b/src/tscore/load_http_hdr.cc
@@ -128,7 +128,7 @@ load_buffer(int fd, hdr_type h_type)
       fprintf(stderr, "Failed to read data file : %s\n", strerror(errno));
       exit(1);
     } else if (done == 0) {
-      fprintf(stderr, "EOF encounted\n", strerror(errno));
+      fprintf(stderr, "EOF encountered\n", strerror(errno));
       exit(1);
     }
 
diff --git a/src/tscore/lockfile.cc b/src/tscore/lockfile.cc
index b3782682af8..a0c87cecaf5 100644
--- a/src/tscore/lockfile.cc
+++ b/src/tscore/lockfile.cc
@@ -24,7 +24,7 @@
 #include "tscore/ink_platform.h"
 #include "tscore/ink_lockfile.h"
 
-#define LOCKFILE_BUF_LEN 16 // 16 bytes should be enought for a pid
+#define LOCKFILE_BUF_LEN 16 // 16 bytes should be enough for a pid
 
 int
 Lockfile::Open(pid_t *holding_pid)
@@ -99,7 +99,7 @@ Lockfile::Open(pid_t *holding_pid)
     FAIL(0);
   }
   // If we did get the lock, then set the close on exec flag so that
-  // we don't accidently pass the file descriptor to a child process
+  // we don't accidentally pass the file descriptor to a child process
   // when we do a fork/exec.
   do {
     err = fcntl(fd, F_GETFD, 0);
diff --git a/src/tscore/unit_tests/test_AcidPtr.cc b/src/tscore/unit_tests/test_AcidPtr.cc
index c8994cfb692..4f7e98a4e56 100644
--- a/src/tscore/unit_tests/test_AcidPtr.cc
+++ b/src/tscore/unit_tests/test_AcidPtr.cc
@@ -85,7 +85,7 @@ TEST_CASE("AcidPtr Isolation")
   {
     AcidCommitPtr<int> w = p;
     *w += 1;
-    CHECK(*p.getPtr() == 40); // new value not commited until end of scope
+    CHECK(*p.getPtr() == 40); // new value not committed until end of scope
   }
   CHECK(*p.getPtr() == 41);
   {
diff --git a/src/tscore/unit_tests/test_IntrusivePtr.cc b/src/tscore/unit_tests/test_IntrusivePtr.cc
index ffacbc6a615..d4a130aaac7 100644
--- a/src/tscore/unit_tests/test_IntrusivePtr.cc
+++ b/src/tscore/unit_tests/test_IntrusivePtr.cc
@@ -96,7 +96,7 @@ TEST_CASE("IntrusivePtr", "[libts][IntrusivePtr]")
 // List test.
 TEST_CASE("IntrusivePtr List", "[libts][IntrusivePtr]")
 {
-  // The clang analyzer claims this type of list manipularion leads to use after free because of
+  // The clang analyzer claims this type of list manipulation leads to use after free because of
   // premature class destruction but these tests verify that is a false positive.
 
   using LP = ts::IntrusivePtr<Item>;
diff --git a/src/tscore/unit_tests/test_arena.cc b/src/tscore/unit_tests/test_arena.cc
index dbf97ad618b..01f4217f0ed 100644
--- a/src/tscore/unit_tests/test_arena.cc
+++ b/src/tscore/unit_tests/test_arena.cc
@@ -28,7 +28,7 @@
    Description:
 
    A short test program intended to be used with Purify to detect problems
-   with the arnea code
+   with the arena code
 
 
  ****************************************************************************/
diff --git a/src/tscpp/api/AsyncHttpFetch.cc b/src/tscpp/api/AsyncHttpFetch.cc
index 64239946912..add00c70b5a 100644
--- a/src/tscpp/api/AsyncHttpFetch.cc
+++ b/src/tscpp/api/AsyncHttpFetch.cc
@@ -222,7 +222,7 @@ AsyncHttpFetch::run()
     request_str += "\r\n";
     request_str += state_->request_body_;
 
-    LOG_DEBUG("Issing (non-streaming) TSFetchUrl with request\n[%s]", request_str.c_str());
+    LOG_DEBUG("Issuing (non-streaming) TSFetchUrl with request\n[%s]", request_str.c_str());
     TSFetchUrl(request_str.c_str(), request_str.size(), reinterpret_cast<struct sockaddr const *>(&addr), fetchCont, AFTER_BODY,
                event_ids);
   } else {
diff --git a/src/tscpp/api/GzipDeflateTransformation.cc b/src/tscpp/api/GzipDeflateTransformation.cc
index 9832ec1f8ca..d371e3076d1 100644
--- a/src/tscpp/api/GzipDeflateTransformation.cc
+++ b/src/tscpp/api/GzipDeflateTransformation.cc
@@ -134,7 +134,7 @@ GzipDeflateTransformation::handleInputComplete()
   // We will flush out anything that's remaining in the gzip buffer
   int status            = Z_OK;
   int iteration         = 0;
-  const int buffer_size = 1024; // 1024 bytes is usually more than enough for the epilouge
+  const int buffer_size = 1024; // 1024 bytes is usually more than enough for the epilogue
   unsigned char buffer[buffer_size];
 
   /* Deflate remaining data */
@@ -154,7 +154,7 @@ GzipDeflateTransformation::handleInputComplete()
                 bytes_to_write, status);
       produce(std::string_view(reinterpret_cast<char *>(buffer), static_cast<size_t>(bytes_to_write)));
     } else if (status != Z_STREAM_END) {
-      LOG_ERROR("Iteration %d: Gzip deflinate finalize produced an error '%d'", iteration, status);
+      LOG_ERROR("Iteration %d: Gzip deflate finalize produced an error '%d'", iteration, status);
     }
   } while (status == Z_OK);
 
diff --git a/src/tscpp/api/Transaction.cc b/src/tscpp/api/Transaction.cc
index 97e00dd6878..5beb03d7c31 100644
--- a/src/tscpp/api/Transaction.cc
+++ b/src/tscpp/api/Transaction.cc
@@ -413,7 +413,7 @@ namespace
  * @param constructor takes a function pointer of type GetterFunction
  * @param txn a TSHttpTxn
  * @param hdr_buf the address where the hdr buf will be stored
- * @param hdr_loc the address where the mem loc will be storeds
+ * @param hdr_loc the address where the mem loc will be stored
  * @param name name of the entity - used for logging
  */
 class initializeHandles
diff --git a/src/tscpp/api/TransformationPlugin.cc b/src/tscpp/api/TransformationPlugin.cc
index 524b07bae27..e578657fc81 100644
--- a/src/tscpp/api/TransformationPlugin.cc
+++ b/src/tscpp/api/TransformationPlugin.cc
@@ -69,7 +69,7 @@ struct TransformationPluginState : noncopyable, public detail::ResumeAfterPauseC
   // We can only send a single WRITE_COMPLETE even though
   // we may receive an immediate event after we've sent a
   // write complete, so we'll keep track of whether or not we've
-  // sent the input end our write complte.
+  // sent the input end our write complete.
   bool input_complete_dispatched_;
 
   std::string request_xform_output_; // in case of request xform, data produced is buffered here
@@ -263,7 +263,7 @@ handleTransformationPluginEvents(TSCont contp, TSEvent event, void *edata)
     return 0;
   }
 
-  // All other events includign WRITE_READY will just attempt to transform more data.
+  // All other events including WRITE_READY will just attempt to transform more data.
   return handleTransformationPluginRead(state->vconn_, state);
 }
 
@@ -426,7 +426,7 @@ TransformationPlugin::setOutputComplete()
               state_->txn_);
 
     // We're done without ever outputting anything, to correctly
-    // clean up we'll initiate a write then immeidately set it to 0 bytes done.
+    // clean up we'll initiate a write then immediately set it to 0 bytes done.
     state_->output_vio_ = TSVConnWrite(TSTransformOutputVConnGet(state_->vconn_), state_->vconn_, state_->output_buffer_reader_, 0);
 
     if (state_->output_vio_) {
diff --git a/src/tscpp/api/utils_internal.cc b/src/tscpp/api/utils_internal.cc
index f70f2c9855a..923c48d961a 100644
--- a/src/tscpp/api/utils_internal.cc
+++ b/src/tscpp/api/utils_internal.cc
@@ -79,7 +79,7 @@ handleTransactionEvents(TSCont cont, TSEvent event, void *edata)
     const std::list<TransactionPlugin *> &plugins = utils::internal::getTransactionPlugins(transaction);
     for (auto plugin : plugins) {
       std::shared_ptr<Mutex> trans_mutex = utils::internal::getTransactionPluginMutex(*plugin);
-      LOG_DEBUG("Locking TransacitonPlugin mutex to delete transaction plugin at %p", plugin);
+      LOG_DEBUG("Locking TransactionPlugin mutex to delete transaction plugin at %p", plugin);
       trans_mutex->lock();
       LOG_DEBUG("Locked Mutex...Deleting transaction plugin at %p", plugin);
       delete plugin;
diff --git a/src/tscpp/util/TextView.cc b/src/tscpp/util/TextView.cc
index 4532b027fa2..78d668db90d 100644
--- a/src/tscpp/util/TextView.cc
+++ b/src/tscpp/util/TextView.cc
@@ -65,7 +65,7 @@ strcasecmp(const std::string_view &lhs, const std::string_view &rhs)
 }
 
 const int8_t ts::svtoi_convert[256] = {
-  /* [can't do this nicely because clang format won't allow exdented comments]
+  /* [can't do this nicely because clang format won't allow extended comments]
    0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
   */
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00
@@ -153,7 +153,7 @@ ts::svtoi(TextView src, TextView *out, int base)
   return zret;
 }
 
-// Do the template instantions.
+// Do the template instantiations.
 template std::ostream &ts::TextView::stream_write(std::ostream &, const ts::TextView &) const;
 
 namespace std
diff --git a/src/wccp/WccpEndPoint.cc b/src/wccp/WccpEndPoint.cc
index bbd45f36295..16e6377b054 100644
--- a/src/wccp/WccpEndPoint.cc
+++ b/src/wccp/WccpEndPoint.cc
@@ -721,7 +721,7 @@ CacheImpl::handleISeeYou(IpHeader const & /* ip_hdr ATS_UNUSED */, ts::Buffer co
 
   logf(LVL_DEBUG, "Received WCCP2_I_SEE_YOU for group %d.", group.m_svc.getSvcId());
 
-  // Prefered address for router.
+  // Preferred address for router.
   uint32_t router_addr = msg.m_router_id.idElt().getAddr();
   // Where we sent our packet.
   uint32_t to_addr = msg.m_router_id.getToAddr();
diff --git a/src/wccp/WccpLocal.h b/src/wccp/WccpLocal.h
index dff8f6d9856..f73ce72aae9 100644
--- a/src/wccp/WccpLocal.h
+++ b/src/wccp/WccpLocal.h
@@ -180,7 +180,7 @@ struct RouterId {
   );
 
   uint32_t m_addr;    ///< Identifying router IP address.
-  uint32_t m_recv_id; ///< Recieve ID (sequence #).
+  uint32_t m_recv_id; ///< Receive ID (sequence #).
 };
 
 /** Sect 5.7.1: Router Identity Element.
@@ -486,7 +486,7 @@ class MaskValueSetElt
   ValueElt &operator[](int idx ///< Index of target element.
   );
   //@}
-  /// Calcuate the size of an element with @a n values.
+  /// Calculate the size of an element with @a n values.
   static size_t calcSize(uint32_t n ///< Number of values.
   );
   /// Get the size (length) of this element.
@@ -1030,7 +1030,7 @@ class SecurityComp : public CompWithHeader<SecurityComp>
   static void setDefaultOption(Option opt ///< Type of security.
   );
 
-  /// Set messsage local security key.
+  /// Set message local security key.
   self &setKey(const char *key ///< Shared key.
   );
 
@@ -1067,7 +1067,7 @@ class ServiceComp : public CompWithHeader<ServiceComp>
   struct raw_t : public super::raw_t, public ServiceGroup {
   };
 
-  ServiceComp(); ///< Default constructor, no member intialization.
+  ServiceComp(); ///< Default constructor, no member initialization.
 
   /// @name Accessors
   //@{
@@ -1636,7 +1636,7 @@ class AltAssignComp : public CompWithHeader<AltAssignComp>
     RouterAssignListElt m_routers; ///< Routers.
   };
 
-  /// Force virtual desctructor.
+  /// Force virtual destructor.
   virtual ~AltAssignComp() {}
   /// @name Accessors
   //@{
@@ -1691,7 +1691,7 @@ class AltHashAssignComp : public AltAssignComp
   uint32_t getCacheCount() const;
   //@}
 
-  /// Force virtual desctructor.
+  /// Force virtual destructor.
   virtual ~AltHashAssignComp() {}
   /// Fill out the component from an @c Assignment.
   virtual self &fill(MsgBuffer &buffer,               ///< Target storage.
@@ -1724,7 +1724,7 @@ class AltMaskAssignComp : public AltAssignComp
   typedef AltMaskAssignComp self; ///< Self reference type.
   typedef AltAssignComp super;    ///< Parent type.
 
-  /// Force virtual desctructor.
+  /// Force virtual destructor.
   virtual ~AltMaskAssignComp() {}
   /// Fill out the component from an @c Assignment.
   virtual self &fill(MsgBuffer &buffer,               ///< Target storage.
@@ -1775,7 +1775,7 @@ class CmdComp : public CompWithHeader<CmdComp>
   //@}
 
   /// Write basic serialization data.
-  /// Elements must be filled in seperately and after invoking this method.
+  /// Elements must be filled in separately and after invoking this method.
   self &fill(MsgBuffer &buffer, ///< Component storage.
              cmd_t cmd,         ///< Command type.
              uint32_t data      ///< Command data.
@@ -1861,7 +1861,7 @@ class QueryComp : public CompWithHeader<QueryComp>
              uint32_t routerAddr, ///< Router identifying address.
              uint32_t toAddr,     ///< Destination address.
              uint32_t cacheAddr,  ///< Cache identifying address.
-             uint32_t recvId      ///< Recieve ID.
+             uint32_t recvId      ///< Receive ID.
   );
 
   /// Validate an existing structure.
@@ -2021,7 +2021,7 @@ class BaseMsg
   size_t getCount() const;
 
   /// Validate security option.
-  /// @note This presumes a sublcass has already successfully parsed.
+  /// @note This presumes a subclass has already successfully parsed.
   bool validateSecurity() const;
 
   // Common starting components for all messages.
@@ -2073,7 +2073,7 @@ class ISeeYouMsg : public BaseMsg
   typedef ISeeYouMsg self; ///< Self reference type.
 
   /// Fill out message structure.
-  /// Router ID and view data must be filled in seperately.
+  /// Router ID and view data must be filled in separately.
   void fill(detail::router::GroupData const &group, ///< Service groupc context.
             SecurityOption sec_opt,                 ///< Security option.
             detail::Assignment &assign,             ///< Cache assignment data.
@@ -2213,7 +2213,7 @@ class Impl : public ts::IntrusivePtrCounter
   /// @return 0 for success, -errno on error.
   virtual int housekeeping() = 0;
 
-  /// Recieve and process a message.
+  /// Receive and process a message.
   /// @return 0 for success, -ERRNO on system error.
   virtual ts::Rv<int> handleMessage();
 
@@ -2382,7 +2382,7 @@ namespace detail
       RouterBag::iterator findRouter(uint32_t addr ///< IP address of cache.
       );
 
-      /// Set an intial router for a service group.
+      /// Set an initial router for a service group.
       self &seedRouter(uint32_t addr ///< IP address for router.
       );
       /// Remove a seed router.
@@ -2467,7 +2467,7 @@ class CacheImpl : public Impl
                                         ServiceGroup::Result *result = 0 ///< [out] Result for service creation.
   );
 
-  /** Set an intial router for a service group.
+  /** Set an initial router for a service group.
       This is needed to bootstrap the protocol.
       If the router is already seeded, this call is silently ignored.
   */
diff --git a/src/wccp/WccpMsg.cc b/src/wccp/WccpMsg.cc
index 0b64990481c..f054b862fe7 100644
--- a/src/wccp/WccpMsg.cc
+++ b/src/wccp/WccpMsg.cc
@@ -1796,7 +1796,7 @@ ISeeYouMsg::parse(ts::Buffer const &buffer)
   // Optional components.
 
   // Test for alternates here
-  // At most one of the asssignments but never both.
+  // At most one of the assignments but never both.
   // Can be omitted.
   m_assignment.parse(m_buffer);
   m_map.parse(m_buffer);
diff --git a/src/wccp/WccpUtil.h b/src/wccp/WccpUtil.h
index 3d986acda69..f8225257901 100644
--- a/src/wccp/WccpUtil.h
+++ b/src/wccp/WccpUtil.h
@@ -81,7 +81,7 @@ ts::Errata &logf(ts::Errata &err,       ///< Target errata.
 ts::Errata log(ts::Errata::Code code, ///< Severity level.
                char const *text       ///< Message text.
 );
-/// Return an Errata populated with a printf styleformatted string.
+/// Return an Errata populated with a printf style formatted string.
 /// Use message ID 0.
 /// @return @a err.
 ts::Errata logf(ts::Errata::Code code, ///< Severity level.
