diff --git a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/parser/AstBuilder.scala b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/parser/AstBuilder.scala
index d90c9901f96ac..823f10b195247 100644
--- a/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/parser/AstBuilder.scala
+++ b/sql/catalyst/src/main/scala/org/apache/spark/sql/catalyst/parser/AstBuilder.scala
@@ -1327,22 +1327,29 @@ class AstBuilder(conf: SQLConf) extends SqlBaseBaseVisitor[AnyRef] with Logging
   override def visitComparison(ctx: ComparisonContext): Expression = withOrigin(ctx) {
     val left = expression(ctx.left)
     val right = expression(ctx.right)
+    val isUnsupportedComparison = (left, right) match {
+      case (_: Attribute, _: Predicate) => true
+      case (_: Predicate, _: Attribute) => true
+      case _ => false
+    }
     val operator = ctx.comparisonOperator().getChild(0).asInstanceOf[TerminalNode]
     operator.getSymbol.getType match {
-      case SqlBaseParser.EQ =>
+      case SqlBaseParser.EQ if !isUnsupportedComparison =>
         EqualTo(left, right)
-      case SqlBaseParser.NSEQ =>
+      case SqlBaseParser.NSEQ if !isUnsupportedComparison =>
         EqualNullSafe(left, right)
-      case SqlBaseParser.NEQ | SqlBaseParser.NEQJ =>
+      case SqlBaseParser.NEQ | SqlBaseParser.NEQJ if !isUnsupportedComparison =>
         Not(EqualTo(left, right))
-      case SqlBaseParser.LT =>
+      case SqlBaseParser.LT if !isUnsupportedComparison =>
         LessThan(left, right)
-      case SqlBaseParser.LTE =>
+      case SqlBaseParser.LTE if !isUnsupportedComparison =>
         LessThanOrEqual(left, right)
-      case SqlBaseParser.GT =>
+      case SqlBaseParser.GT if !isUnsupportedComparison =>
         GreaterThan(left, right)
-      case SqlBaseParser.GTE =>
+      case SqlBaseParser.GTE if !isUnsupportedComparison =>
         GreaterThanOrEqual(left, right)
+      case _ =>
+        throw new ParseException("Syntax error at or near", ctx)
     }
   }
 
diff --git a/sql/core/src/test/scala/org/apache/spark/sql/execution/SparkSqlParserSuite.scala b/sql/core/src/test/scala/org/apache/spark/sql/execution/SparkSqlParserSuite.scala
index af9088003f3b0..3c93b83188b29 100644
--- a/sql/core/src/test/scala/org/apache/spark/sql/execution/SparkSqlParserSuite.scala
+++ b/sql/core/src/test/scala/org/apache/spark/sql/execution/SparkSqlParserSuite.scala
@@ -24,7 +24,7 @@ import org.apache.spark.sql.SaveMode
 import org.apache.spark.sql.catalyst.TableIdentifier
 import org.apache.spark.sql.catalyst.analysis.{AnalysisTest, UnresolvedAlias, UnresolvedAttribute, UnresolvedRelation, UnresolvedStar}
 import org.apache.spark.sql.catalyst.catalog.{BucketSpec, CatalogStorageFormat, CatalogTable, CatalogTableType}
-import org.apache.spark.sql.catalyst.expressions.{Ascending, AttributeReference, Concat, SortOrder}
+import org.apache.spark.sql.catalyst.expressions.{Ascending, AttributeReference, Concat, EqualTo, Literal, SortOrder}
 import org.apache.spark.sql.catalyst.plans.logical._
 import org.apache.spark.sql.execution.command._
 import org.apache.spark.sql.execution.datasources.{CreateTable, RefreshResource}
@@ -306,6 +306,26 @@ class SparkSqlParserSuite extends AnalysisTest {
       Project(UnresolvedAlias(concat) :: Nil, UnresolvedRelation(TableIdentifier("t"))))
   }
 
+  test("Prohibit binary comparisons chain") {
+    assertEqual("SELECT (a = b) = (b = c)",
+      Project(UnresolvedAlias(EqualTo(
+        EqualTo(UnresolvedAttribute("a"), UnresolvedAttribute("b")),
+        EqualTo(UnresolvedAttribute("b"), UnresolvedAttribute("c")))) :: Nil, OneRowRelation()))
+
+    assertEqual("SELECT (a = b) = true",
+      Project(UnresolvedAlias(EqualTo(
+        EqualTo(UnresolvedAttribute("a"), UnresolvedAttribute("b")),
+        Literal.TrueLiteral)) :: Nil, OneRowRelation()))
+
+    intercept("SELECT a = b = c", "Syntax error at or near")
+    intercept("SELECT a <=> b <=> c", "Syntax error at or near")
+    intercept("SELECT a <> b <> c", "Syntax error at or near")
+    intercept("SELECT a < b < c", "Syntax error at or near")
+    intercept("SELECT a <= b <= c", "Syntax error at or near")
+    intercept("SELECT a > b > c", "Syntax error at or near")
+    intercept("SELECT a >= b >= c", "Syntax error at or near")
+  }
+
   test("database and schema tokens are interchangeable") {
     assertEqual("CREATE DATABASE foo", parser.parsePlan("CREATE SCHEMA foo"))
     assertEqual("DROP DATABASE foo", parser.parsePlan("DROP SCHEMA foo"))
