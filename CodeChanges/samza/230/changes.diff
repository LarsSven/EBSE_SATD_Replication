diff --git a/samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorListener.java b/samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorListener.java
index 8e1703282b..11641d58ff 100644
--- a/samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorListener.java
+++ b/samza-core/src/main/java/org/apache/samza/coordinator/JobCoordinatorListener.java
@@ -47,6 +47,7 @@ public interface JobCoordinatorListener {
 
   /**
    * Method invoked by a {@link org.apache.samza.coordinator.JobCoordinator} when it is shutting without any errors
+   * Typically, this happens when the StreamProcessor invokes {@link JobCoordinator#stop()}.
    */
   void onCoordinatorStop();
 
diff --git a/samza-core/src/main/java/org/apache/samza/processor/StreamProcessor.java b/samza-core/src/main/java/org/apache/samza/processor/StreamProcessor.java
index c0a2163818..14a14a8d42 100644
--- a/samza-core/src/main/java/org/apache/samza/processor/StreamProcessor.java
+++ b/samza-core/src/main/java/org/apache/samza/processor/StreamProcessor.java
@@ -67,6 +67,8 @@ public class StreamProcessor {
   private ExecutorService executorService;
 
   private volatile SamzaContainer container = null;
+  private volatile Throwable containerException = null;
+  
   // Latch used to synchronize between the JobCoordinator thread and the container thread, when the container is
   // stopped due to re-balancing
   private volatile CountDownLatch jcContainerShutdownLatch = new CountDownLatch(1);
@@ -274,7 +276,8 @@ public void onContainerFailed(Throwable t) {
               } else {
                 LOGGER.warn("JobCoordinatorLatch was null. It is possible for some component to be waiting.");
               }
-              LOGGER.error("Container failed. Stopping the processor.", t);
+              containerException = t;
+              LOGGER.error("Container failed. Stopping the processor.", containerException);
               container = null;
               stop();
             }
@@ -298,7 +301,10 @@ public void onCoordinatorStop() {
           executorService.shutdownNow();
         }
         if (processorListener != null) {
-          processorListener.onShutdown();
+          if (containerException != null)
+            processorListener.onFailure(containerException);
+          else
+            processorListener.onShutdown();
         }
       }
 
diff --git a/samza-core/src/test/java/org/apache/samza/processor/TestStreamProcessor.java b/samza-core/src/test/java/org/apache/samza/processor/TestStreamProcessor.java
index 7aadd28c64..6a8d765d3c 100644
--- a/samza-core/src/test/java/org/apache/samza/processor/TestStreamProcessor.java
+++ b/samza-core/src/test/java/org/apache/samza/processor/TestStreamProcessor.java
@@ -19,6 +19,7 @@
 package org.apache.samza.processor;
 
 import org.apache.samza.SamzaContainerStatus;
+import org.apache.samza.SamzaException;
 import org.apache.samza.config.Config;
 import org.apache.samza.config.MapConfig;
 import org.apache.samza.container.RunLoop;
@@ -29,12 +30,18 @@
 import org.apache.samza.metrics.MetricsReporter;
 import org.apache.samza.task.StreamTask;
 import org.apache.samza.task.StreamTaskFactory;
+import org.junit.After;
 import org.junit.Assert;
+import org.junit.Before;
 import org.junit.Test;
 
 import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicReference;
 
 import static org.mockito.Matchers.anyString;
 import static org.mockito.Mockito.doAnswer;
@@ -43,53 +50,90 @@
 import static org.mockito.Mockito.when;
 
 public class TestStreamProcessor {
+  private ConcurrentMap<ListenerCallback, Boolean> processorListenerState;
+  private enum ListenerCallback {
+    ON_START, ON_SHUTDOWN, ON_FAILURE
+  }
+
+  @Before
+  public void before() {
+    processorListenerState = new ConcurrentHashMap<ListenerCallback, Boolean>() {
+      {
+        put(ListenerCallback.ON_START, false);
+        put(ListenerCallback.ON_FAILURE, false);
+        put(ListenerCallback.ON_SHUTDOWN, false);
+      }
+    };
+  }
+
+  @After
+  public void after() {
+    processorListenerState.clear();
+  }
 
   class TestableStreamProcessor extends StreamProcessor {
     private final CountDownLatch containerStop = new CountDownLatch(1);
     private final CountDownLatch runLoopStartForMain = new CountDownLatch(1);
-    private SamzaContainer containerReference = null;
+    public SamzaContainer container = null;
 
     public TestableStreamProcessor(
         Config config,
         Map<String, MetricsReporter> customMetricsReporters,
         StreamTaskFactory streamTaskFactory,
         StreamProcessorLifecycleListener processorListener,
-        JobCoordinator jobCoordinator) {
+        JobCoordinator jobCoordinator,
+        SamzaContainer container) {
       super(config, customMetricsReporters, streamTaskFactory, processorListener, jobCoordinator);
+      this.container = container;
     }
 
     @Override
     SamzaContainer createSamzaContainer(
         ContainerModel containerModel,
         int maxChangelogStreamPartitions) {
-      RunLoop mockRunLoop = mock(RunLoop.class);
-      doAnswer(invocation ->
-        {
-          try {
-            runLoopStartForMain.countDown();
-            containerStop.await();
-          } catch (InterruptedException e) {
-            System.out.println("In exception" + e);
-            e.printStackTrace();
-          }
-          return null;
-        }).when(mockRunLoop).run();
-
-      doAnswer(invocation ->
-        {
-          containerStop.countDown();
-          return null;
-        }).when(mockRunLoop).shutdown();
-      containerReference = StreamProcessorTestUtils.getDummyContainer(mockRunLoop, null, mock(StreamTask.class));
-      return containerReference;
+      if (container == null) {
+        RunLoop mockRunLoop = mock(RunLoop.class);
+        doAnswer(invocation ->
+          {
+            try {
+              runLoopStartForMain.countDown();
+              containerStop.await();
+            } catch (InterruptedException e) {
+              System.out.println("In exception" + e);
+              e.printStackTrace();
+            }
+            return null;
+          }).when(mockRunLoop).run();
+
+        doAnswer(invocation ->
+          {
+            containerStop.countDown();
+            return null;
+          }).when(mockRunLoop).shutdown();
+        container = StreamProcessorTestUtils.getDummyContainer(mockRunLoop, mock(StreamTask.class));
+      }
+      return container;
+    }
+
+    SamzaContainerStatus getContainerStatus() {
+      if (container != null)  return container.getStatus();
+      return null;
     }
   }
 
+  private JobModel getMockJobModel() {
+    Map containers = mock(Map.class);
+    doReturn(true).when(containers).containsKey(anyString());
+    when(containers.get(anyString())).thenReturn(mock(ContainerModel.class));
+    JobModel mockJobModel = mock(JobModel.class);
+    when(mockJobModel.getContainers()).thenReturn(containers);
+    return mockJobModel;
+  }
   /**
    * Tests stop() method when Container AND JobCoordinator are running
    */
   @Test
-  public void testStopByProcessor() {
+  public void testStopByProcessor() throws InterruptedException {
     JobCoordinator mockJobCoordinator = mock(JobCoordinator.class);
 
     final CountDownLatch processorListenerStop = new CountDownLatch(1);
@@ -102,32 +146,29 @@ public void testStopByProcessor() {
         new StreamProcessorLifecycleListener() {
           @Override
           public void onStart() {
+            processorListenerState.put(ListenerCallback.ON_START, true);
             processorListenerStart.countDown();
           }
 
           @Override
           public void onShutdown() {
+            processorListenerState.put(ListenerCallback.ON_SHUTDOWN, true);
             processorListenerStop.countDown();
           }
 
           @Override
           public void onFailure(Throwable t) {
-
+            processorListenerState.put(ListenerCallback.ON_FAILURE, true);
           }
         },
-        mockJobCoordinator);
-
-    Map containers = mock(Map.class);
-    doReturn(true).when(containers).containsKey(anyString());
-    when(containers.get(anyString())).thenReturn(mock(ContainerModel.class));
-    JobModel mockJobModel = mock(JobModel.class);
-    when(mockJobModel.getContainers()).thenReturn(containers);
+        mockJobCoordinator,
+        null);
 
     final CountDownLatch coordinatorStop = new CountDownLatch(1);
     final Thread jcThread = new Thread(() ->
       {
         try {
-          processor.jobCoordinatorListener.onNewJobModel("1", mockJobModel);
+          processor.jobCoordinatorListener.onNewJobModel("1", getMockJobModel());
           coordinatorStop.await();
           processor.jobCoordinatorListener.onCoordinatorStop();
         } catch (InterruptedException e) {
@@ -147,22 +188,114 @@ public void onFailure(Throwable t) {
         return null;
       }).when(mockJobCoordinator).start();
 
-    try {
-      processor.start();
-      processorListenerStart.await();
+    processor.start();
+    processorListenerStart.await();
 
-      Assert.assertEquals(SamzaContainerStatus.STARTED, processor.containerReference.getStatus());
+    Assert.assertEquals(SamzaContainerStatus.STARTED, processor.getContainerStatus());
 
-      // This block is required for the mockRunloop is actually start.
-      // Otherwise, processor.stop gets triggered before mockRunloop begins to block
-      processor.runLoopStartForMain.await();
+    // This block is required for the mockRunloop is actually start.
+    // Otherwise, processor.stop gets triggered before mockRunloop begins to block
+    processor.runLoopStartForMain.await();
 
-      processor.stop();
+    processor.stop();
 
-      processorListenerStop.await();
-    } catch (InterruptedException e) {
-      e.printStackTrace();
-    }
+    processorListenerStop.await();
+
+    // Assertions on which callbacks are expected to be invoked
+    Assert.assertTrue(processorListenerState.get(ListenerCallback.ON_START));
+    Assert.assertTrue(processorListenerState.get(ListenerCallback.ON_SHUTDOWN));
+    Assert.assertFalse(processorListenerState.get(ListenerCallback.ON_FAILURE));
+  }
+
+  /**
+   * Tests that a failure in container correctly stops a running JobCoordinator and propagates the exception
+   * through the StreamProcessor
+   *
+   * Assertions:
+   * - JobCoordinator has been stopped from the JobCoordinatorListener callback
+   * - StreamProcessorLifecycleListener#onFailure(Throwable) has been invoked
+   */
+  @Test
+  public void testContainerFailureCorrectlyStopsProcessor() throws InterruptedException {
+    JobCoordinator mockJobCoordinator = mock(JobCoordinator.class);
+    Throwable expectedThrowable =  new SamzaException("Failure in Container!");
+    AtomicReference<Throwable> actualThrowable = new AtomicReference<>();
+    final CountDownLatch runLoopStartedLatch = new CountDownLatch(1);
+    RunLoop failingRunLoop = mock(RunLoop.class);
+    doAnswer(invocation ->
+      {
+        try {
+          runLoopStartedLatch.countDown();
+          throw expectedThrowable;
+        } catch (InterruptedException ie) {
+          ie.printStackTrace();
+        }
+        return null;
+      }).when(failingRunLoop).run();
+
+    SamzaContainer mockContainer = StreamProcessorTestUtils.getDummyContainer(failingRunLoop, mock(StreamTask.class));
+    final CountDownLatch processorListenerFailed = new CountDownLatch(1);
+
+    TestableStreamProcessor processor = new TestableStreamProcessor(
+        new MapConfig(),
+        new HashMap<>(),
+        mock(StreamTaskFactory.class),
+        new StreamProcessorLifecycleListener() {
+          @Override
+          public void onStart() {
+            processorListenerState.put(ListenerCallback.ON_START, true);
+          }
+
+          @Override
+          public void onShutdown() {
+            processorListenerState.put(ListenerCallback.ON_SHUTDOWN, true);
+          }
+
+          @Override
+          public void onFailure(Throwable t) {
+            processorListenerState.put(ListenerCallback.ON_FAILURE, true);
+            actualThrowable.getAndSet(t);
+            processorListenerFailed.countDown();
+          }
+        },
+        mockJobCoordinator,
+        mockContainer);
+
+    final CountDownLatch coordinatorStop = new CountDownLatch(1);
+    doAnswer(invocation ->
+      {
+        coordinatorStop.countDown();
+        return null;
+      }).when(mockJobCoordinator).stop();
+
+    doAnswer(invocation ->
+      {
+        new Thread(() ->
+          {
+            try {
+              processor.jobCoordinatorListener.onNewJobModel("1", getMockJobModel());
+              coordinatorStop.await();
+              processor.jobCoordinatorListener.onCoordinatorStop();
+            } catch (InterruptedException e) {
+              e.printStackTrace();
+            }
+          }).start();
+        return null;
+      }).when(mockJobCoordinator).start();
+
+    processor.start();
+
+    // This block is required for the mockRunloop is actually started.
+    // Otherwise, processor.stop gets triggered before mockRunloop begins to block
+    runLoopStartedLatch.await();
+    Assert.assertTrue(
+        "Container failed and processor listener failed was not invoked within timeout!",
+        processorListenerFailed.await(30, TimeUnit.SECONDS));
+    Assert.assertEquals(expectedThrowable, actualThrowable.get());
+
+    Assert.assertFalse(processorListenerState.get(ListenerCallback.ON_SHUTDOWN));
+    Assert.assertTrue(processorListenerState.get(ListenerCallback.ON_START));
+    Assert.assertTrue(processorListenerState.get(ListenerCallback.ON_FAILURE));
   }
 
   // TODO:
@@ -170,5 +303,4 @@ public void onFailure(Throwable t) {
   // test onNewJobModel
   // test onJobModelExpiry
   // test Coordinator failure - correctly shutsdown the streamprocessor
-  // test Container failure
 }
diff --git a/samza-core/src/test/scala/org/apache/samza/processor/StreamProcessorTestUtils.scala b/samza-core/src/test/scala/org/apache/samza/processor/StreamProcessorTestUtils.scala
index f437bfcc7c..f574cc3e61 100644
--- a/samza-core/src/test/scala/org/apache/samza/processor/StreamProcessorTestUtils.scala
+++ b/samza-core/src/test/scala/org/apache/samza/processor/StreamProcessorTestUtils.scala
@@ -29,7 +29,7 @@ import org.apache.samza.task.{StreamTask, TaskInstanceCollector}
 
 
 object StreamProcessorTestUtils {
-  def getDummyContainer(mockRunloop: RunLoop, containerListener: SamzaContainerListener, streamTask: StreamTask) = {
+  def getDummyContainer(mockRunloop: RunLoop, streamTask: StreamTask) = {
     val config = new MapConfig
     val taskName = new TaskName("taskName")
     val consumerMultiplexer = new SystemConsumers(
@@ -58,9 +58,6 @@ object StreamProcessorTestUtils {
       consumerMultiplexer = consumerMultiplexer,
       producerMultiplexer = producerMultiplexer,
       metrics = new SamzaContainerMetrics)
-    if (containerListener != null) {
-      container.setContainerListener(containerListener)
-    }
     container
   }
 }
\ No newline at end of file
