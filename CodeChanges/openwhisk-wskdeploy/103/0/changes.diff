diff --git a/.gitignore b/.gitignore
index fd27bf656..dbae22ca8 100644
--- a/.gitignore
+++ b/.gitignore
@@ -26,7 +26,9 @@ _testmain.go
 wskdeploy
 
 #OS X things
-*/.DS_Store
+*.DS_Store
 
 #emacs
-*~
\ No newline at end of file
+*~
+
+openwhisk-wskdeploy
\ No newline at end of file
diff --git a/cmd/init.go b/cmd/init.go
deleted file mode 100644
index aacda0b2f..000000000
--- a/cmd/init.go
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package cmd
-
-import (
-	"fmt"
-
-	"github.com/spf13/cobra"
-)
-
-// initCmd represents the init command
-var initCmd = &cobra.Command{
-	Use:   "init",
-	Short: "A brief description of your command",
-	Long: `A longer description that spans multiple lines and likely contains examples
-and usage of using your command. For example:
-
-Cobra is a CLI library for Go that empowers applications.
-This application is a tool to generate the needed files
-to quickly create a Cobra application.`,
-	Run: func(cmd *cobra.Command, args []string) {
-		// TODO: Work your own magic here
-		fmt.Println("init called")
-	},
-}
-
-func init() {
-	RootCmd.AddCommand(initCmd)
-
-	// Here you will define your flags and configuration settings.
-
-	// Cobra supports Persistent Flags which will work for this command
-	// and all subcommands, e.g.:
-	// initCmd.PersistentFlags().String("foo", "", "A help for foo")
-
-	// Cobra supports local flags which will only run when this command
-	// is called directly, e.g.:
-	// initCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
-
-}
diff --git a/cmd/remove.go b/cmd/remove.go
deleted file mode 100644
index e1a33377e..000000000
--- a/cmd/remove.go
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package cmd
-
-import (
-	"fmt"
-
-	"github.com/spf13/cobra"
-)
-
-// removeCmd represents the remove command
-var removeCmd = &cobra.Command{
-	Use:   "remove",
-	Short: "A brief description of your command",
-	Long: `A longer description that spans multiple lines and likely contains examples
-and usage of using your command. For example:
-
-Cobra is a CLI library for Go that empowers applications.
-This application is a tool to generate the needed files
-to quickly create a Cobra application.`,
-	Run: func(cmd *cobra.Command, args []string) {
-		// TODO: Work your own magic here
-		fmt.Println("remove called")
-	},
-}
-
-func init() {
-	RootCmd.AddCommand(removeCmd)
-
-	// Here you will define your flags and configuration settings.
-
-	// Cobra supports Persistent Flags which will work for this command
-	// and all subcommands, e.g.:
-	// removeCmd.PersistentFlags().String("foo", "", "A help for foo")
-
-	// Cobra supports local flags which will only run when this command
-	// is called directly, e.g.:
-	// removeCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
-
-}
diff --git a/cmd/report.go b/cmd/report.go
index a65ac9686..a582858af 100644
--- a/cmd/report.go
+++ b/cmd/report.go
@@ -17,13 +17,15 @@ package cmd
 import (
 	"fmt"
 
+	"path"
+	"sync"
+
 	"github.com/fatih/color"
 	"github.com/openwhisk/openwhisk-client-go/whisk"
+	"github.com/openwhisk/openwhisk-wskdeploy/deployers"
 	"github.com/openwhisk/openwhisk-wskdeploy/utils"
 	"github.com/openwhisk/openwhisk-wskdeploy/wski18n"
 	"github.com/spf13/cobra"
-	"path"
-	"sync"
 )
 
 var wskpropsPath string
@@ -42,12 +44,12 @@ located under current user home.`,
 	Run: func(cmd *cobra.Command, args []string) {
 		// TODO: Work your own magic here
 		if wskpropsPath != "" {
-			client, _ = utils.NewClient(wskpropsPath, deploymentPath)
+			client, _ = deployers.NewWhiskClient(wskpropsPath, deploymentPath)
 		}
 		userHome := utils.GetHomeDirectory()
 		//default to ~/.wskprops
 		propPath := path.Join(userHome, ".wskprops")
-		client, _ = utils.NewClient(propPath, deploymentPath)
+		client, _ = deployers.NewWhiskClient(propPath, deploymentPath)
 		printDeploymentInfo(client)
 	},
 }
diff --git a/cmd/root.go b/cmd/root.go
index 036c32eb3..ae112acfb 100644
--- a/cmd/root.go
+++ b/cmd/root.go
@@ -1,50 +1,47 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+// Copyright Â© 2017 NAME HERE <EMAIL ADDRESS>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
 
 package cmd
 
 import (
-	"errors"
 	"fmt"
-	"github.com/openwhisk/openwhisk-client-go/whisk"
-	"github.com/openwhisk/openwhisk-wskdeploy/utils"
-	"github.com/spf13/cobra"
-	"github.com/spf13/viper"
-	yaml "gopkg.in/yaml.v2"
-	"io/ioutil"
 	"log"
 	"os"
-	"os/exec"
 	"path"
-	"path/filepath"
-	"syscall"
+
+	"github.com/openwhisk/openwhisk-wskdeploy/deployers"
+	"github.com/openwhisk/openwhisk-wskdeploy/utils"
+	"github.com/spf13/cobra"
+	"github.com/spf13/viper"
+
+	"github.com/openwhisk/openwhisk-client-go/whisk"
 )
 
+const ManifestFileName = "manifest"
+const DeploymentFileName = "deployment"
+
 var cfgFile string
+var CliVersion string
+var CliBuild string
+
+var Verbose bool
 var projectPath string
-var manifestPath string
 var deploymentPath string
-var useInteractive string
+var manifestPath string
 var useDefaults string
-var Verbose bool
-var clientConfig *whisk.Config
-var CliVersion string
-var CliBuild string
+var useInteractive string
 
-// RootCmd represents the base command when called without any subcommands
 var RootCmd = &cobra.Command{
 	Use:   "wskdeploy",
 	Short: "A tool set to help deploy your openwhisk packages in batch.",
@@ -95,51 +92,40 @@ application:
 	// has an action associated with it:
 	Run: func(cmd *cobra.Command, args []string) {
 
-		log.Println("OpenWhisk Deploy initial configuration")
-		log.Println("Project path is ", projectPath)
+		whisk.SetVerbose(Verbose)
 
-		var searchPath = path.Join(projectPath, "serverless.yaml")
-		log.Println("Searching for serverless manifest on path ", searchPath)
+		if manifestPath == "" {
+			manifestPath = path.Join(projectPath, ManifestFileName+".yaml")
+		}
 
-		if _, err := os.Stat(searchPath); err == nil {
-			log.Println("Found severless manifest")
+		if deploymentPath == "" {
+			deploymentPath = path.Join(projectPath, DeploymentFileName+".yaml")
+		}
 
-			dat, err := ioutil.ReadFile(searchPath)
-			utils.Check(err)
+		if utils.FileExists(manifestPath) {
 
-			var manifest utils.Manifest
+			var deployer = deployers.NewServiceDeployer()
+			deployer.ProjectPath = projectPath
+			deployer.ManifestPath = manifestPath
+			deployer.DeploymentPath = deploymentPath
 
-			err = yaml.Unmarshal(dat, &manifest)
-			utils.Check(err)
+			userHome := utils.GetHomeDirectory()
+			propPath := path.Join(userHome, ".wskprops")
 
-			if manifest.Provider.Name != "openwhisk" {
-				log.Println("Starting Serverless deployment")
-				execErr := executeServerless()
-				utils.Check(execErr)
-				fmt.Println("Deployment complete")
-			} else {
-				log.Println("Starting OpenWhisk deployment")
-				deployer, err := executeDeployer(manifestPath)
-				utils.Check(err)
-				if deployer.InteractiveChoice {
-					fmt.Println("Deployment complete")
-				}
-			}
+			whiskClient, clientConfig := deployers.NewWhiskClient(propPath, deploymentPath)
+			deployer.Client = whiskClient
+			deployer.ClientConfig = clientConfig
 
-		} else {
-			log.Println("Starting OpenWhisk deployment")
-			_, err := os.Stat(manifestPath)
-			if err != nil {
-				err = errors.New("manifest file not found.")
-			}
+			err := deployer.ConstructDeploymentPlan()
 			utils.Check(err)
-			deployer, err := executeDeployer(manifestPath)
+
+			err = deployer.Deploy()
 			utils.Check(err)
-			if deployer.InteractiveChoice {
-				log.Println("Deployment complete")
-			}
 
+		} else {
+			log.Println("missing manifest.yaml file")
 		}
+
 	},
 }
 
@@ -167,9 +153,8 @@ func init() {
 	RootCmd.Flags().StringVarP(&manifestPath, "manifest", "m", "", "path to manifest file")
 	RootCmd.Flags().StringVarP(&deploymentPath, "deployment", "d", "", "path to deployment file")
 	RootCmd.Flags().StringVar(&useDefaults, "allow-defaults", "false", "allow defaults")
-	RootCmd.Flags().StringVar(&useInteractive, "allow-interactive", "true", "allow interactive prompts")
+	RootCmd.Flags().StringVar(&useInteractive, "allow-interactive", "false", "allow interactive prompts")
 	RootCmd.PersistentFlags().BoolVarP(&Verbose, "verbose", "v", false, "verbose output")
-
 }
 
 // initConfig reads in config file and ENV variables if set.
@@ -187,74 +172,3 @@ func initConfig() {
 		fmt.Println("Using config file:", viper.ConfigFileUsed())
 	}
 }
-
-func executeDeployer(manifestPath string) (*ServiceDeployer, error) {
-	userHome := utils.GetHomeDirectory()
-	propPath := path.Join(userHome, ".wskprops")
-	deployer := NewServiceDeployer()
-
-	isInteractive, err := utils.GetBoolFromString(useInteractive)
-	utils.Check(err)
-
-	isDefault, err := utils.GetBoolFromString(useDefaults)
-	utils.Check(err)
-
-	deployer.IsInteractive = isInteractive
-	deployer.IsDefault = isDefault
-	deployer.ManifestPath = manifestPath
-	deployer.ProjectPath = projectPath
-	deployer.DeploymentPath = deploymentPath
-	// from propPath and deploymentPath get all the information
-	// and we return the information back for later usage if necessary
-	deployer.Client, clientConfig = utils.NewClient(propPath, deploymentPath)
-
-	err = deployer.ConstructDeploymentPlan()
-	if err != nil {
-		return nil, err
-	}
-
-	err = deployer.Deploy()
-	if err != nil {
-		return nil, err
-	}
-
-	return deployer, nil
-}
-
-// Process manifest using OpenWhisk Tool
-func executeOpenWhisk(manifest utils.Manifest, manifestPath string) error {
-	err := filepath.Walk(manifestPath, processPath)
-	utils.Check(err)
-	fmt.Println("OpenWhisk processing TBD")
-	return nil
-}
-
-func processPath(path string, f os.FileInfo, err error) error {
-	fmt.Println("Visited ", path)
-	return nil
-}
-
-// If "serverless" is installed, then use it to process manifest
-func executeServerless() error {
-	//utils.Check
-	if os.Getenv("AWS_ACCESS_KEY_ID") == "" || os.Getenv("AWS_SECRET_ACCESS_KEY") == "" {
-		return &utils.ServerlessErr{"Please set missing environment variables AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY tokens"}
-	}
-	binary, lookErr := exec.LookPath(utils.ServerlessBinaryCommand)
-	if lookErr != nil {
-		panic(lookErr)
-	}
-	args := make([]string, 2)
-	args[0] = utils.ServerlessBinaryCommand
-	args[1] = "deploy"
-
-	env := os.Environ()
-
-	os.Chdir(projectPath)
-	execErr := syscall.Exec(binary, args, env)
-	if execErr != nil {
-		return &utils.ServerlessErr{execErr.Error()}
-	}
-
-	return nil
-}
diff --git a/cmd/servicedeployer.go b/cmd/servicedeployer.go
deleted file mode 100644
index 51ca526ca..000000000
--- a/cmd/servicedeployer.go
+++ /dev/null
@@ -1,433 +0,0 @@
-/*
-* Copyright 2015-2016 IBM Corporation
-*
-* Licensed under the Apache License, Version 2.0 (the "License");
-* you may not use this file except in compliance with the License.
-* You may obtain a copy of the License at
-*
-* http://www.apache.org/licenses/LICENSE-2.0
-*
-* Unless required by applicable law or agreed to in writing, software
-* distributed under the License is distributed on an "AS IS" BASIS,
-* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-* See the License for the specific language governing permissions and
-* limitations under the License.
- */
-
-package cmd
-
-import (
-	"bufio"
-	"bytes"
-	"fmt"
-	"github.com/openwhisk/openwhisk-client-go/whisk"
-	"github.com/openwhisk/openwhisk-wskdeploy/utils"
-	"log"
-	"os"
-	"path"
-	"path/filepath"
-	"strings"
-	"sync"
-)
-
-//ServiceDeployer defines a prototype service deployer.  It should do the following:
-//   1. Collect information from the manifest file (if any)
-//   2. Collect information from the deployment file (if any)
-//   3. Collect information about the source code files in the working directory
-//   4. Create a deployment plan to create OpenWhisk service
-type ServiceDeployer struct {
-	Actions        map[string]utils.ActionRecord
-	Triggers       map[string]*whisk.Trigger
-	Packages       map[string]*whisk.SentPackageNoPublish
-	Rules          map[string]*whisk.Rule
-	Client         *whisk.Client
-	mt             sync.RWMutex
-	IsInteractive  bool
-	IsDefault      bool
-	ManifestPath   string
-	ProjectPath    string
-	DeploymentPath string
-	//whether to deploy the action under the package
-	DeployActionInPackage bool
-	InteractiveChoice     bool
-}
-
-// NewServiceDeployer is a Factory to create a new ServiceDeployer
-func NewServiceDeployer() *ServiceDeployer {
-	var dep ServiceDeployer
-	dep.Actions = make(map[string]utils.ActionRecord)
-	dep.Packages = make(map[string]*whisk.SentPackageNoPublish)
-	dep.Triggers = make(map[string]*whisk.Trigger)
-	dep.Rules = make(map[string]*whisk.Rule)
-	dep.IsInteractive = true
-	dep.DeployActionInPackage = true
-	return &dep
-}
-
-// ConstructDeploymentPlan will collect information from the manifest, descriptors, and any
-// defaults to determine what assets need to be installed.
-func (deployer *ServiceDeployer) ConstructDeploymentPlan() error {
-
-	if deployer.IsDefault == true {
-		deployer.ReadDirectory()
-	}
-
-	deployer.HandleYamlDir()
-
-	return nil
-}
-
-// ReadDirectory will collect information from the files on disk. These represent actions
-func (deployer *ServiceDeployer) ReadDirectory() error {
-
-	err := filepath.Walk(deployer.ProjectPath, func(filePath string, f os.FileInfo, err error) error {
-		if filePath != deployer.ProjectPath {
-			isDirectory := utils.IsDirectory(filePath)
-
-			if isDirectory == true {
-				baseName := path.Base(filePath)
-				if strings.HasPrefix(baseName, ".") {
-					return filepath.SkipDir
-				}
-				err = deployer.CreatePackageFromDirectory(baseName)
-
-			} else {
-				action, err := utils.CreateActionFromFile(deployer.ProjectPath, filePath)
-				utils.Check(err)
-				deployer.Actions[action.Name] = utils.ActionRecord{action, filePath}
-			}
-		}
-		return err
-	})
-
-	utils.Check(err)
-	return nil
-}
-
-func (deployer *ServiceDeployer) CreatePackageFromDirectory(directoryName string) error {
-	fmt.Println("Making a package ", directoryName)
-	return nil
-}
-
-// DeployActions into OpenWhisk
-func (deployer *ServiceDeployer) DeployActions() error {
-
-	for _, action := range deployer.Actions {
-		//fmt.Println("Got action ", action.Exec.Code)
-		deployer.createAction(action.Action)
-	}
-	return nil
-}
-
-// Deploy Triggers into OpenWhisk
-func (deployer *ServiceDeployer) DeployTriggers() error {
-	for _, trigger := range deployer.Triggers {
-		deployer.createTrigger(trigger)
-	}
-	return nil
-
-}
-
-// Deploy Rules into OpenWhisk
-func (deployer *ServiceDeployer) DeployRules() error {
-	for _, rule := range deployer.Rules {
-		deployer.createRule(rule)
-	}
-
-	return nil
-}
-
-func (deployer *ServiceDeployer) createTrigger(trigger *whisk.Trigger) {
-	_, _, err := deployer.Client.Triggers.Insert(trigger, true)
-	if err != nil {
-		wskErr := err.(*whisk.WskError)
-		fmt.Printf("Got error creating trigger with error message: %v and error code: %v.\n", wskErr.Error(), wskErr.ExitCode)
-	}
-}
-
-func (deployer *ServiceDeployer) createRule(rule *whisk.Rule) {
-	// The rule's trigger should include the namespace with pattern /namespace/trigger
-	rule.Trigger = deployer.getQualifiedName(rule.Trigger, clientConfig.Namespace)
-	// The rule's action should include the namespace and package with pattern /namespace/package/action
-	// please refer https://github.com/openwhisk/openwhisk/issues/1577
-	pkgName := deployer.getPackageName()
-	rule.Action = deployer.getQualifiedName(strings.Join([]string{pkgName, rule.Action}, "/"), clientConfig.Namespace)
-	_, _, err := deployer.Client.Rules.Insert(rule, true)
-	if err != nil {
-		wskErr := err.(*whisk.WskError)
-		fmt.Printf("Got error creating rule with error message: %v and error code: %v.\n", wskErr.Error(), wskErr.ExitCode)
-	}
-}
-
-// Utility function to call go-whisk framework to make action
-func (deployer *ServiceDeployer) createAction(action *whisk.Action) {
-	// call ActionService Thru Client
-	if deployer.DeployActionInPackage {
-		pkgname := deployer.getPackageName()
-		// the action will be created under package with pattern 'packagename/actionname'
-		action.Name = strings.Join([]string{pkgname, action.Name}, "/")
-	}
-	_, _, err := deployer.Client.Actions.Insert(action, false, true)
-	if err != nil {
-		wskErr := err.(*whisk.WskError)
-		fmt.Printf("Got error creating action with error message: %v and error code: %v.\n", wskErr.Error(), wskErr.ExitCode)
-	}
-}
-
-func (deployer *ServiceDeployer) getPackageName() string {
-	if len(deployer.Packages) > 0 {
-		//get the first available package name by default
-		for _, pkg := range deployer.Packages {
-			if pkg.Name != "" {
-				return pkg.Name
-			}
-		}
-	}
-	return ""
-}
-
-func (deployer *ServiceDeployer) createPackage(packa *whisk.SentPackageNoPublish) {
-	_, _, err := deployer.Client.Packages.Insert(packa, true)
-	if err != nil {
-		wskErr := err.(*whisk.WskError)
-		fmt.Printf("Got error creating package with error message: %v and error code: %v.\n", wskErr.Error(), wskErr.ExitCode)
-	}
-}
-
-// Wrapper parser to handle yaml dir
-func (deployer *ServiceDeployer) HandleYamlDir() error {
-	mm := utils.NewYAMLParser()
-	packg, err := mm.ComposePackage(deployer.ManifestPath)
-	utils.Check(err)
-	actions, err := mm.ComposeActions(deployer.ManifestPath)
-	utils.Check(err)
-	//for implementation of feed support(issue#47). The trigger configs are in manifest.yaml,
-	//If there is feed nodes, then parse the deployment yaml to get the feed, and create
-	//the triggers with feed configs as annonations of the trigger, so change the compose trigger
-	//interface to include both manifest and deployment path.
-	triggers, err := mm.ComposeTriggers(deployer.ManifestPath, deployer.DeploymentPath)
-	utils.Check(err)
-	rules, err := mm.ComposeRules(deployer.ManifestPath)
-	utils.Check(err)
-	if !deployer.SetActions(actions) {
-		log.Panicln("duplication founded during deploy actions")
-	}
-	if !deployer.SetPackage(packg) {
-		log.Panicln("duplication founded during deploy package")
-	}
-	if !deployer.SetTriggers(triggers) {
-		log.Panicln("duplication founded during deploy triggers")
-	}
-	if !deployer.SetRules(rules) {
-		log.Panicln("duplication founded during deploy rules")
-	}
-
-	deployer.createPackage(packg)
-
-	return nil
-}
-
-func (deployer *ServiceDeployer) printDeploymentAssets() {
-
-	fmt.Println("----==== OpenWhisk Deployment Plan ====----")
-	fmt.Println("Deploy Packages:")
-	fmt.Println("----------------")
-	for _, pkg := range deployer.Packages {
-		var buffer bytes.Buffer
-		buffer.WriteString(pkg.Namespace)
-		buffer.WriteString("/")
-		buffer.WriteString(pkg.Name)
-		fmt.Printf("    %s (version: %s)\n", buffer.String(), pkg.Version)
-	}
-
-	fmt.Println("\nDeploy Actions:")
-	fmt.Println("----------------")
-	for _, action := range deployer.Actions {
-		var buffer bytes.Buffer
-		buffer.WriteString(action.Action.Namespace)
-		buffer.WriteString("/")
-		buffer.WriteString(action.Action.Name)
-		fmt.Printf("    %s (version: %s)\n", buffer.String(), action.Action.Version)
-	}
-
-	fmt.Println("\nDeploy Triggers:")
-	fmt.Println("----------------")
-	for _, trigger := range deployer.Triggers {
-		var buffer bytes.Buffer
-		buffer.WriteString(trigger.Namespace)
-		buffer.WriteString("/")
-		buffer.WriteString(trigger.Name)
-		fmt.Printf("    %s (version: %s)\n", buffer.String(), trigger.Version)
-	}
-
-	fmt.Println("\nDeploy Rules:")
-	fmt.Println("----------------")
-	for _, rule := range deployer.Rules {
-		var buffer bytes.Buffer
-		buffer.WriteString(rule.Namespace)
-		buffer.WriteString("/")
-		buffer.WriteString(rule.Name)
-		fmt.Printf("    %s (version: %s)\n", buffer.String(), rule.Version)
-	}
-
-}
-
-// Use relfect util to deploy everything in this service deployer
-// according some planning?
-func (deployer *ServiceDeployer) Deploy() error {
-	if deployer.IsInteractive == true {
-		deployer.printDeploymentAssets()
-		reader := bufio.NewReader(os.Stdin)
-		fmt.Print("Do you really want to deploy this? (y/n): ")
-
-		text, _ := reader.ReadString('\n')
-		text = strings.TrimSpace(text)
-
-		if strings.EqualFold(text, "y") || strings.EqualFold(text, "yes") {
-			deployer.InteractiveChoice = true
-			if err := deployer.DeployActions(); err != nil {
-				return err
-			}
-			if err := deployer.DeployTriggers(); err != nil {
-				return err
-			}
-			if err := deployer.DeployRules(); err != nil {
-				return err
-			}
-		} else {
-			deployer.InteractiveChoice = false
-			fmt.Println("OK. Cancelling deployment")
-		}
-	}
-
-	return nil
-}
-
-func (deployer *ServiceDeployer) SetPackage(pkg *whisk.SentPackageNoPublish) bool {
-	deployer.mt.Lock()
-	defer deployer.mt.Unlock()
-	existPkg, exist := deployer.Packages[pkg.Name]
-	if exist {
-		if deployer.IsDefault == true {
-
-			log.Printf("Updating package %s with values from manifest file ", pkg.Name)
-
-			existPkg.Annotations = pkg.Annotations
-			existPkg.Namespace = pkg.Namespace
-			existPkg.Parameters = pkg.Parameters
-			existPkg.Publish = pkg.Publish
-			existPkg.Version = pkg.Version
-
-			deployer.Packages[pkg.Name] = existPkg
-			return true
-		} else {
-			return false
-		}
-	}
-
-	deployer.Packages[pkg.Name] = pkg
-	return true
-}
-
-func (deployer *ServiceDeployer) SetActions(actions []utils.ActionRecord) bool {
-	deployer.mt.Lock()
-	defer deployer.mt.Unlock()
-
-	for _, action := range actions {
-		//fmt.Println(action.Action.Name)
-		existAction, exist := deployer.Actions[action.Action.Name]
-
-		if exist {
-			if deployer.IsDefault == true {
-				// look for actions declared in filesystem default as well as manifest
-				// if one exists, merge if they are the same (either same Filepath or manifest doesn't specify a Filepath)
-				// if they are not the same log error
-				if action.Filepath != "" {
-					if existAction.Filepath != action.Filepath {
-						log.Printf("Action %s has location %s in manifest but already exists at %s", action.Action.Name, action.Filepath, existAction)
-						return false
-					} else {
-						// merge the two, overwrite existing action with manifest values
-						existAction.Action.Annotations = action.Action.Annotations
-						existAction.Action.Exec.Kind = action.Action.Exec.Kind
-						existAction.Action.Limits = action.Action.Limits
-						existAction.Action.Namespace = action.Action.Namespace
-						existAction.Action.Parameters = action.Action.Parameters
-						existAction.Action.Publish = action.Action.Publish
-						existAction.Action.Version = action.Action.Version
-
-						deployer.Actions[action.Action.Name] = existAction
-
-						return true
-					}
-				}
-			} else {
-				// no defaults, so assume everything is in the incoming ActionRecord
-				// return false since it means the action is declared twice in the manifest
-				log.Printf("Action %s is declared more than once", action.Action.Name)
-				return false
-			}
-		}
-		// doesn't exist so just add to deployer actions
-		deployer.Actions[action.Action.Name] = action
-	}
-	return true
-}
-
-func (deployer *ServiceDeployer) SetTriggers(triggers []*whisk.Trigger) bool {
-	deployer.mt.Lock()
-	defer deployer.mt.Unlock()
-
-	for _, trigger := range triggers {
-		existTrigger, exist := deployer.Triggers[trigger.Name]
-		if exist {
-			existTrigger.Name = trigger.Name
-			existTrigger.ActivationId = trigger.ActivationId
-			existTrigger.Namespace = trigger.Namespace
-			existTrigger.Annotations = trigger.Annotations
-			existTrigger.Version = trigger.Version
-			existTrigger.Parameters = trigger.Parameters
-			existTrigger.Publish = trigger.Publish
-		} else {
-			deployer.Triggers[trigger.Name] = trigger
-		}
-
-	}
-	return true
-}
-
-func (deployer *ServiceDeployer) SetRules(rules []*whisk.Rule) bool {
-	deployer.mt.Lock()
-	defer deployer.mt.Unlock()
-
-	for _, rule := range rules {
-		existRule, exist := deployer.Rules[rule.Name]
-		if exist {
-			existRule.Name = rule.Name
-			existRule.Publish = rule.Publish
-			existRule.Version = rule.Version
-			existRule.Namespace = rule.Namespace
-			existRule.Action = rule.Action
-			existRule.Trigger = rule.Trigger
-			existRule.Status = rule.Status
-		} else {
-			deployer.Rules[rule.Name] = rule
-		}
-
-	}
-	return true
-}
-
-// from whisk go client
-func (deployer *ServiceDeployer) getQualifiedName(name string, namespace string) string {
-	if strings.HasPrefix(name, "/") {
-		return name
-	} else if strings.HasPrefix(namespace, "/") {
-		return fmt.Sprintf("%s/%s", namespace, name)
-	} else {
-		if len(namespace) == 0 {
-			namespace = clientConfig.Namespace
-		}
-		return fmt.Sprintf("/%s/%s", namespace, name)
-	}
-}
diff --git a/cmd/transmorgrify.go b/cmd/transmorgrify.go
deleted file mode 100644
index 6cde149f1..000000000
--- a/cmd/transmorgrify.go
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package cmd
-
-import (
-	"fmt"
-
-	"github.com/spf13/cobra"
-)
-
-// transmorgrifyCmd represents the transmorgrify command
-var transmorgrifyCmd = &cobra.Command{
-	Use:   "transmorgrify",
-	Short: "A brief description of your command",
-	Long: `A longer description that spans multiple lines and likely contains examples
-and usage of using your command. For example:
-
-Cobra is a CLI library for Go that empowers applications.
-This application is a tool to generate the needed files
-to quickly create a Cobra application.`,
-	Run: func(cmd *cobra.Command, args []string) {
-		// TODO: Work your own magic here
-		fmt.Println("transmorgrify called")
-	},
-}
-
-func init() {
-	RootCmd.AddCommand(transmorgrifyCmd)
-
-	// Here you will define your flags and configuration settings.
-
-	// Cobra supports Persistent Flags which will work for this command
-	// and all subcommands, e.g.:
-	// transmorgrifyCmd.PersistentFlags().String("foo", "", "A help for foo")
-
-	// Cobra supports local flags which will only run when this command
-	// is called directly, e.g.:
-	// transmorgrifyCmd.Flags().BoolP("toggle", "t", false, "Help message for toggle")
-
-}
diff --git a/config/clientconfiguration.go b/config/clientconfiguration.go
new file mode 100644
index 000000000..0a5891825
--- /dev/null
+++ b/config/clientconfiguration.go
@@ -0,0 +1,95 @@
+package config
+
+import (
+	"bufio"
+	"fmt"
+	"net/http"
+	"os"
+	"strings"
+
+	"github.com/openwhisk/openwhisk-client-go/whisk"
+	"github.com/openwhisk/openwhisk-wskdeploy/parsers"
+	"github.com/openwhisk/openwhisk-wskdeploy/utils"
+)
+
+var ClientConfig *whisk.Config
+
+func NewClient(proppath string, deploymentPath string) (*whisk.Client, *whisk.Config) {
+	var clientConfig *whisk.Config
+	configs, err := LoadConfiguration(proppath)
+	utils.Check(err)
+	//we need to get Apihost from property file which currently not defined in sample deployment file.
+	baseURL, err := utils.GetURLBase(configs[1])
+	utils.Check(err)
+	if deploymentPath != "" {
+		mm := parsers.NewYAMLParser()
+		deployment := mm.ParseDeployment(deploymentPath)
+		// We get the first package from the sample deployment file.
+		pkg := deployment.Application.GetPackageList()[0]
+		clientConfig = &whisk.Config{
+			AuthToken: pkg.Credential, //Authtoken
+			Namespace: pkg.Namespace,  //Namespace
+			BaseURL:   baseURL,
+			Version:   "v1",
+			Insecure:  true,
+		}
+
+	} else {
+		clientConfig = &whisk.Config{
+			AuthToken: configs[2], //Authtoken
+			Namespace: configs[0], //Namespace
+			BaseURL:   baseURL,
+			Version:   "v1",
+			Insecure:  true, // true if you want to ignore certificate signing
+
+		}
+
+	}
+
+	// Setup network client
+	client, err := whisk.NewClient(http.DefaultClient, clientConfig)
+	utils.Check(err)
+	return client, clientConfig
+}
+
+// Load configuration will load properties from a file
+func LoadConfiguration(propPath string) ([]string, error) {
+	props, err := ReadProps(propPath)
+	utils.Check(err)
+	Namespace := props["NAMESPACE"]
+	Apihost := props["APIHOST"]
+	Authtoken := props["AUTH"]
+	return []string{Namespace, Apihost, Authtoken}, nil
+}
+
+func ReadProps(path string) (map[string]string, error) {
+
+	props := map[string]string{}
+
+	file, err := os.Open(path)
+	if err != nil {
+		// If file does not exist, just return props
+		fmt.Printf("Unable to read whisk properties file '%s' (file open error: %s); falling back to default properties\n", path, err)
+		return props, nil
+	}
+	defer file.Close()
+
+	lines := []string{}
+	scanner := bufio.NewScanner(file)
+	for scanner.Scan() {
+		lines = append(lines, scanner.Text())
+	}
+
+	props = map[string]string{}
+	for _, line := range lines {
+		kv := strings.Split(line, "=")
+		if len(kv) != 2 {
+			// Invalid format; skip
+			continue
+		}
+		props[kv[0]] = kv[1]
+	}
+
+	return props, nil
+
+}
diff --git a/deployers/deploymentreader.go b/deployers/deploymentreader.go
new file mode 100644
index 000000000..bb41c6c83
--- /dev/null
+++ b/deployers/deploymentreader.go
@@ -0,0 +1,185 @@
+package deployers
+
+import (
+	"github.com/openwhisk/openwhisk-client-go/whisk"
+	"github.com/openwhisk/openwhisk-wskdeploy/parsers"
+)
+
+type DeploymentReader struct {
+	serviceDeployer      *ServiceDeployer
+	DeploymentDescriptor *parsers.DeploymentYAML
+}
+
+func NewDeploymentReader(serviceDeployer *ServiceDeployer) *DeploymentReader {
+	var dep DeploymentReader
+	dep.serviceDeployer = serviceDeployer
+
+	return &dep
+}
+
+// Wrapper parser to handle yaml dir
+func (reader *DeploymentReader) HandleYaml() error {
+
+	dep := reader.serviceDeployer
+
+	deploymentParser := parsers.NewYAMLParser()
+	deployment := deploymentParser.ParseDeployment(dep.DeploymentPath)
+
+	reader.DeploymentDescriptor = deployment
+
+	return nil
+}
+
+// Update entities with deployment settings
+func (reader *DeploymentReader) BindAssets() error {
+
+	reader.bindPackageInputsAndAnnotations()
+	reader.bindActionInputsAndAnnotations()
+	reader.bindTriggerInputsAndAnnotations()
+
+	return nil
+
+}
+
+func (reader *DeploymentReader) bindPackageInputsAndAnnotations() {
+
+	packArray := make([]parsers.Package, 0)
+
+	if reader.DeploymentDescriptor.Application.Packages == nil {
+		packArray = append(packArray, reader.DeploymentDescriptor.Application.Package)
+	} else {
+		for _, depPacks := range reader.DeploymentDescriptor.Application.Packages {
+			packArray = append(packArray, depPacks)
+		}
+	}
+
+	for _, pack := range packArray {
+		serviceDeployPack := reader.serviceDeployer.Deployment.Packages[pack.Packagename]
+
+		var keyValArr whisk.KeyValueArr
+		for name, input := range pack.Inputs {
+			var keyVal whisk.KeyValue
+
+			keyVal.Key = name
+			keyVal.Value = input
+
+			keyValArr = append(keyValArr, keyVal)
+		}
+
+		serviceDeployPack.Package.Parameters = keyValArr
+
+		keyValArr = keyValArr[:0]
+		for name, input := range pack.Annotations {
+			var keyVal whisk.KeyValue
+
+			keyVal.Key = name
+			keyVal.Value = input
+
+			keyValArr = append(keyValArr, keyVal)
+		}
+
+		serviceDeployPack.Package.Annotations = keyValArr
+
+	}
+}
+
+func (reader *DeploymentReader) bindActionInputsAndAnnotations() {
+
+	packArray := make([]parsers.Package, 1)
+
+	if reader.DeploymentDescriptor.Application.Packages == nil {
+		packArray = append(packArray, reader.DeploymentDescriptor.Application.Package)
+	} else {
+		for _, depPacks := range reader.DeploymentDescriptor.Application.Packages {
+			packArray = append(packArray, depPacks)
+		}
+	}
+
+	for _, pack := range packArray {
+
+		for actionName, action := range pack.Actions {
+
+			serviceDeployPack := reader.serviceDeployer.Deployment.Packages[pack.Packagename]
+
+			var keyValArr whisk.KeyValueArr
+			for name, input := range action.Inputs {
+				var keyVal whisk.KeyValue
+
+				keyVal.Key = name
+				keyVal.Value = input
+
+				keyValArr = append(keyValArr, keyVal)
+			}
+
+			if wskAction, exists := serviceDeployPack.Actions[actionName]; exists {
+				wskAction.Action.Parameters = keyValArr
+			}
+
+			keyValArr = keyValArr[:0]
+
+			for name, input := range action.Annotations {
+				var keyVal whisk.KeyValue
+
+				keyVal.Key = name
+				keyVal.Value = input
+
+				keyValArr = append(keyValArr, keyVal)
+			}
+
+			if wskAction, exists := serviceDeployPack.Actions[actionName]; exists {
+				wskAction.Action.Annotations = keyValArr
+			}
+		}
+
+	}
+}
+
+func (reader *DeploymentReader) bindTriggerInputsAndAnnotations() {
+	packArray := make([]parsers.Package, 1)
+
+	if reader.DeploymentDescriptor.Application.Packages == nil {
+		packArray = append(packArray, reader.DeploymentDescriptor.Application.Package)
+	} else {
+		for _, depPacks := range reader.DeploymentDescriptor.Application.Packages {
+			packArray = append(packArray, depPacks)
+		}
+	}
+
+	for _, pack := range packArray {
+
+		serviceDeployPack := reader.serviceDeployer.Deployment.Packages[pack.Packagename]
+
+		for triggerName, trigger := range pack.Triggers {
+
+			var keyValArr whisk.KeyValueArr
+			for name, input := range trigger.Inputs {
+				var keyVal whisk.KeyValue
+
+				keyVal.Key = name
+				keyVal.Value = input
+
+				keyValArr = append(keyValArr, keyVal)
+			}
+
+			if wskTrigger, exists := serviceDeployPack.Triggers[triggerName]; exists {
+				wskTrigger.Parameters = keyValArr
+			}
+
+			keyValArr = keyValArr[:0]
+
+			for name, input := range trigger.Annotations {
+				var keyVal whisk.KeyValue
+
+				keyVal.Key = name
+				keyVal.Value = input
+
+				keyValArr = append(keyValArr, keyVal)
+			}
+
+			if wskTrigger, exists := serviceDeployPack.Triggers[triggerName]; exists {
+				wskTrigger.Annotations = keyValArr
+			}
+		}
+
+	}
+}
diff --git a/deployers/filesystemreader.go b/deployers/filesystemreader.go
new file mode 100644
index 000000000..4d26e0972
--- /dev/null
+++ b/deployers/filesystemreader.go
@@ -0,0 +1 @@
+package deployers
diff --git a/deployers/manifestreader.go b/deployers/manifestreader.go
new file mode 100644
index 000000000..7c91ca7aa
--- /dev/null
+++ b/deployers/manifestreader.go
@@ -0,0 +1,264 @@
+package deployers
+
+import (
+	"fmt"
+	"log"
+	"strings"
+
+	"github.com/openwhisk/openwhisk-client-go/whisk"
+	"github.com/openwhisk/openwhisk-wskdeploy/config"
+	"github.com/openwhisk/openwhisk-wskdeploy/parsers"
+	"github.com/openwhisk/openwhisk-wskdeploy/utils"
+)
+
+type ManifestReader struct {
+	serviceDeployer *ServiceDeployer
+}
+
+func NewManfiestReader(serviceDeployer *ServiceDeployer) *ManifestReader {
+	var dep ManifestReader
+	dep.serviceDeployer = serviceDeployer
+
+	return &dep
+}
+
+// Wrapper parser to handle yaml dir
+func (deployer *ManifestReader) HandleYaml() error {
+
+	dep := deployer.serviceDeployer
+
+	manifestParser := parsers.NewYAMLParser()
+	manifest := manifestParser.ParseManifest(dep.ManifestPath)
+
+	packg, err := manifestParser.ComposePackage(manifest)
+
+	utils.Check(err)
+
+	actions, err := manifestParser.ComposeActions(manifest, dep.ManifestPath)
+	utils.Check(err)
+
+	sequences, err := manifestParser.ComposeSequences(dep.ClientConfig.Namespace, packg.Name, manifest)
+	utils.Check(err)
+
+	triggers, err := manifestParser.ComposeTriggers(manifest)
+	utils.Check(err)
+
+	rules, err := manifestParser.ComposeRules(manifest)
+	utils.Check(err)
+
+	if !deployer.SetPackage(packg) {
+		log.Panicln("Cannot assign package " + packg.Name)
+	}
+	if !deployer.SetActions(packg.Name, actions) {
+		log.Panicln("duplication founded during deploy actions")
+	}
+	if !deployer.SetSequences(packg.Name, sequences) {
+		log.Panicln("duplication founded during deploy actions")
+	}
+	if !deployer.SetTriggers(packg.Name, triggers) {
+		log.Panicln("duplication founded during deploy triggers")
+	}
+	if !deployer.SetRules(packg.Name, rules) {
+		log.Panicln("duplication founded during deploy rules")
+	}
+
+	//deployer.createPackage(packg)
+
+	return nil
+}
+
+func (reader *ManifestReader) SetPackage(pkg *whisk.SentPackageNoPublish) bool {
+
+	dep := reader.serviceDeployer
+
+	dep.mt.Lock()
+	defer dep.mt.Unlock()
+	depPkg, exist := dep.Deployment.Packages[pkg.Name]
+	if exist {
+		if dep.IsDefault == true {
+			existPkg := depPkg.Package
+			existPkg.Annotations = pkg.Annotations
+			existPkg.Namespace = pkg.Namespace
+			existPkg.Parameters = pkg.Parameters
+			existPkg.Publish = pkg.Publish
+			existPkg.Version = pkg.Version
+
+			dep.Deployment.Packages[pkg.Name].Package = existPkg
+			return true
+		} else {
+			return false
+		}
+	}
+
+	newPack := NewDeploymentPackage()
+	newPack.Package = pkg
+	dep.Deployment.Packages[pkg.Name] = newPack
+	return true
+}
+
+func (reader *ManifestReader) SetActions(packageName string, actions []utils.ActionRecord) bool {
+
+	dep := reader.serviceDeployer
+
+	dep.mt.Lock()
+	defer dep.mt.Unlock()
+
+	for _, action := range actions {
+		//fmt.Println(action.Action.Name)
+		existAction, exist := dep.Deployment.Packages[packageName].Actions[action.Action.Name]
+
+		if exist {
+			if dep.IsDefault == true {
+				// look for actions declared in filesystem default as well as manifest
+				// if one exists, merge if they are the same (either same Filepath or manifest doesn't specify a Filepath)
+				// if they are not the same log error
+				if action.Filepath != "" {
+					if existAction.Filepath != action.Filepath {
+						log.Printf("Action %s has location %s in manifest but already exists at %s", action.Action.Name, action.Filepath, existAction)
+						return false
+					} else {
+						// merge the two, overwrite existing action with manifest values
+						existAction.Action.Annotations = action.Action.Annotations
+						existAction.Action.Exec.Kind = action.Action.Exec.Kind
+						existAction.Action.Limits = action.Action.Limits
+						existAction.Action.Namespace = action.Action.Namespace
+						existAction.Action.Parameters = action.Action.Parameters
+						existAction.Action.Publish = action.Action.Publish
+						existAction.Action.Version = action.Action.Version
+
+						existAction.Packagename = packageName
+
+						dep.Deployment.Packages[packageName].Actions[action.Action.Name] = existAction
+
+						return true
+					}
+				}
+			} else {
+				// no defaults, so assume everything is in the incoming ActionRecord
+				// return false since it means the action is declared twice in the manifest
+				log.Printf("Action %s is declared more than once", action.Action.Name)
+				return false
+			}
+		}
+		// doesn't exist so just add to deployer actions
+		action.Packagename = packageName
+
+		dep.Deployment.Packages[packageName].Actions[action.Action.Name] = action
+	}
+	return true
+}
+
+func (reader *ManifestReader) SetSequences(packageName string, actions []utils.ActionRecord) bool {
+
+	dep := reader.serviceDeployer
+
+	dep.mt.Lock()
+	defer dep.mt.Unlock()
+
+	for _, action := range actions {
+		//fmt.Println(action.Action.Name)
+		existAction, exist := dep.Deployment.Packages[packageName].Sequences[action.Action.Name]
+
+		if exist {
+			if dep.IsDefault == true {
+				// look for actions declared in filesystem default as well as manifest
+				// if one exists, merge if they are the same (either same Filepath or manifest doesn't specify a Filepath)
+				// if they are not the same log error
+				if action.Filepath != "" {
+					if existAction.Filepath != action.Filepath {
+						log.Printf("Action %s has location %s in manifest but already exists at %s", action.Action.Name, action.Filepath, existAction)
+						return false
+					} else {
+						// merge the two, overwrite existing action with manifest values
+						existAction.Action.Annotations = action.Action.Annotations
+						existAction.Action.Exec.Kind = action.Action.Exec.Kind
+						existAction.Action.Limits = action.Action.Limits
+						existAction.Action.Namespace = action.Action.Namespace
+						existAction.Action.Parameters = action.Action.Parameters
+						existAction.Action.Publish = action.Action.Publish
+						existAction.Action.Version = action.Action.Version
+
+						existAction.Packagename = packageName
+
+						dep.Deployment.Packages[packageName].Sequences[action.Action.Name] = existAction
+
+						return true
+					}
+				}
+			} else {
+				// no defaults, so assume everything is in the incoming ActionRecord
+				// return false since it means the action is declared twice in the manifest
+				log.Printf("Action %s is declared more than once", action.Action.Name)
+				return false
+			}
+		}
+		// doesn't exist so just add to deployer sequences
+		action.Packagename = packageName
+		dep.Deployment.Packages[packageName].Sequences[action.Action.Name] = action
+
+	}
+	return true
+}
+
+func (reader *ManifestReader) SetTriggers(packageName string, triggers []*whisk.Trigger) bool {
+
+	dep := reader.serviceDeployer
+
+	dep.mt.Lock()
+	defer dep.mt.Unlock()
+
+	for _, trigger := range triggers {
+		existTrigger, exist := dep.Deployment.Packages[packageName].Triggers[trigger.Name]
+		if exist {
+			existTrigger.Name = trigger.Name
+			existTrigger.ActivationId = trigger.ActivationId
+			existTrigger.Namespace = trigger.Namespace
+			existTrigger.Annotations = trigger.Annotations
+			existTrigger.Version = trigger.Version
+			existTrigger.Parameters = trigger.Parameters
+			existTrigger.Publish = trigger.Publish
+		} else {
+			dep.Deployment.Packages[packageName].Triggers[trigger.Name] = trigger
+		}
+
+	}
+	return true
+}
+
+func (reader *ManifestReader) SetRules(packageName string, rules []*whisk.Rule) bool {
+	dep := reader.serviceDeployer
+
+	dep.mt.Lock()
+	defer dep.mt.Unlock()
+
+	for _, rule := range rules {
+		existRule, exist := dep.Deployment.Packages[packageName].Rules[rule.Name]
+		if exist {
+			existRule.Name = rule.Name
+			existRule.Publish = rule.Publish
+			existRule.Version = rule.Version
+			existRule.Namespace = rule.Namespace
+			existRule.Action = rule.Action
+			existRule.Trigger = rule.Trigger
+			existRule.Status = rule.Status
+		} else {
+			dep.Deployment.Packages[packageName].Rules[rule.Name] = rule
+		}
+
+	}
+	return true
+}
+
+// from whisk go client
+func (deployer *ManifestReader) getQualifiedName(name string, namespace string) string {
+	if strings.HasPrefix(name, "/") {
+		return name
+	} else if strings.HasPrefix(namespace, "/") {
+		return fmt.Sprintf("%s/%s", namespace, name)
+	} else {
+		if len(namespace) == 0 {
+			namespace = config.ClientConfig.Namespace
+		}
+		return fmt.Sprintf("/%s/%s", namespace, name)
+	}
+}
diff --git a/deployers/servicedeployer.go b/deployers/servicedeployer.go
new file mode 100644
index 000000000..8b4860ace
--- /dev/null
+++ b/deployers/servicedeployer.go
@@ -0,0 +1,318 @@
+/*
+* Copyright 2015-2016 IBM Corporation
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+ */
+
+package deployers
+
+import (
+	"bufio"
+	"fmt"
+	"os"
+	"strings"
+	"sync"
+
+	"github.com/openwhisk/openwhisk-client-go/whisk"
+	"github.com/openwhisk/openwhisk-wskdeploy/utils"
+)
+
+type DeploymentApplication struct {
+	Packages map[string]*DeploymentPackage
+}
+
+func NewDeploymentApplication() *DeploymentApplication {
+	var dep DeploymentApplication
+	dep.Packages = make(map[string]*DeploymentPackage)
+	return &dep
+}
+
+type DeploymentPackage struct {
+	Package   *whisk.SentPackageNoPublish
+	Actions   map[string]utils.ActionRecord
+	Triggers  map[string]*whisk.Trigger
+	Rules     map[string]*whisk.Rule
+	Sequences map[string]utils.ActionRecord
+}
+
+func NewDeploymentPackage() *DeploymentPackage {
+	var dep DeploymentPackage
+	dep.Actions = make(map[string]utils.ActionRecord)
+	dep.Triggers = make(map[string]*whisk.Trigger)
+	dep.Rules = make(map[string]*whisk.Rule)
+	dep.Sequences = make(map[string]utils.ActionRecord)
+	return &dep
+}
+
+//ServiceDeployer defines a prototype service deployer.  It should do the following:
+//   1. Collect information from the manifest file (if any)
+//   2. Collect information from the deployment file (if any)
+//   3. Collect information about the source code files in the working directory
+//   4. Create a deployment plan to create OpenWhisk service
+type ServiceDeployer struct {
+	Deployment     *DeploymentApplication
+	Client         *whisk.Client
+	mt             sync.RWMutex
+	IsInteractive  bool
+	IsDefault      bool
+	ManifestPath   string
+	ProjectPath    string
+	DeploymentPath string
+	//whether to deploy the action under the package
+	DeployActionInPackage bool
+	InteractiveChoice     bool
+	ClientConfig          *whisk.Config
+}
+
+// NewServiceDeployer is a Factory to create a new ServiceDeployer
+func NewServiceDeployer() *ServiceDeployer {
+	var dep ServiceDeployer
+	dep.Deployment = NewDeploymentApplication()
+	dep.IsInteractive = true
+	dep.DeployActionInPackage = true
+
+	return &dep
+}
+
+func (deployer *ServiceDeployer) ConstructDeploymentPlan() error {
+
+	// process manifest file
+	var manifestReader = NewManfiestReader(deployer)
+	manifestReader.HandleYaml()
+
+	// process deploymet file
+	var deploymentReader = NewDeploymentReader(deployer)
+	deploymentReader.HandleYaml()
+
+	deploymentReader.BindAssets()
+
+	// print report
+	deployer.printDeploymentAssets()
+
+	return nil
+}
+
+// Use relfect util to deploy everything in this service deployer
+// according some planning?
+func (deployer *ServiceDeployer) Deploy() error {
+
+	if deployer.IsInteractive == true {
+		deployer.printDeploymentAssets()
+		reader := bufio.NewReader(os.Stdin)
+		fmt.Print("Do you really want to deploy this? (y/n): ")
+
+		text, _ := reader.ReadString('\n')
+		text = strings.TrimSpace(text)
+
+		if strings.EqualFold(text, "y") || strings.EqualFold(text, "yes") {
+			deployer.InteractiveChoice = true
+			return deployer.deployAssets()
+
+		} else {
+			deployer.InteractiveChoice = false
+			fmt.Println("OK. Cancelling deployment")
+			return nil
+		}
+	}
+
+	// non-interactive
+	return deployer.deployAssets()
+
+}
+
+func (deployer *ServiceDeployer) deployAssets() error {
+
+	if err := deployer.DeployPackages(); err != nil {
+		return err
+	}
+
+	if err := deployer.DeployActions(); err != nil {
+		return err
+	}
+
+	if err := deployer.DeploySequences(); err != nil {
+		return err
+	}
+
+	if err := deployer.DeployTriggers(); err != nil {
+		return err
+	}
+
+	if err := deployer.DeployRules(); err != nil {
+		return err
+	}
+	return nil
+}
+
+func (deployer *ServiceDeployer) DeployPackages() error {
+
+	for _, pack := range deployer.Deployment.Packages {
+		deployer.createPackage(pack.Package)
+	}
+	return nil
+}
+
+// DeployActions into OpenWhisk
+func (deployer *ServiceDeployer) DeploySequences() error {
+
+	for _, pack := range deployer.Deployment.Packages {
+		for _, action := range pack.Sequences {
+			deployer.createAction(pack.Package.Name, action.Action)
+		}
+	}
+	return nil
+}
+
+// DeployActions into OpenWhisk
+func (deployer *ServiceDeployer) DeployActions() error {
+
+	for _, pack := range deployer.Deployment.Packages {
+		for _, action := range pack.Actions {
+			deployer.createAction(pack.Package.Name, action.Action)
+		}
+	}
+	return nil
+}
+
+// Deploy Triggers into OpenWhisk
+func (deployer *ServiceDeployer) DeployTriggers() error {
+	for _, pack := range deployer.Deployment.Packages {
+		for _, trigger := range pack.Triggers {
+			deployer.createTrigger(pack.Package.Name, trigger)
+		}
+	}
+	return nil
+
+}
+
+// Deploy Rules into OpenWhisk
+func (deployer *ServiceDeployer) DeployRules() error {
+	for _, pack := range deployer.Deployment.Packages {
+		for _, rule := range pack.Rules {
+			deployer.createRule(pack.Package.Name, rule)
+		}
+	}
+	return nil
+}
+
+func (deployer *ServiceDeployer) createPackage(packa *whisk.SentPackageNoPublish) {
+	_, _, err := deployer.Client.Packages.Insert(packa, true)
+	if err != nil {
+		wskErr := err.(*whisk.WskError)
+		fmt.Printf("Got error creating package with error message: %v and error code: %v.\n", wskErr.Error(), wskErr.ExitCode)
+	}
+}
+
+func (deployer *ServiceDeployer) createTrigger(pkgname string, trigger *whisk.Trigger) {
+	_, _, err := deployer.Client.Triggers.Insert(trigger, true)
+	if err != nil {
+		wskErr := err.(*whisk.WskError)
+		fmt.Printf("Got error creating trigger with error message: %v and error code: %v.\n", wskErr.Error(), wskErr.ExitCode)
+	}
+}
+
+func (deployer *ServiceDeployer) createRule(pkgname string, rule *whisk.Rule) {
+	// The rule's trigger should include the namespace with pattern /namespace/trigger
+	rule.Trigger = deployer.getQualifiedName(rule.Trigger, deployer.ClientConfig.Namespace)
+	// The rule's action should include the namespace and package with pattern /namespace/package/action
+	// please refer https://github.com/openwhisk/openwhisk/issues/1577
+
+	rule.Action = deployer.getQualifiedName(strings.Join([]string{pkgname, rule.Action}, "/"), deployer.ClientConfig.Namespace)
+	_, _, err := deployer.Client.Rules.Insert(rule, true)
+	if err != nil {
+		wskErr := err.(*whisk.WskError)
+		fmt.Printf("Got error creating rule with error message: %v and error code: %v.\n", wskErr.Error(), wskErr.ExitCode)
+	}
+}
+
+// Utility function to call go-whisk framework to make action
+func (deployer *ServiceDeployer) createAction(pkgname string, action *whisk.Action) {
+	// call ActionService Thru Client
+	if deployer.DeployActionInPackage {
+
+		// the action will be created under package with pattern 'packagename/actionname'
+		action.Name = strings.Join([]string{pkgname, action.Name}, "/")
+	}
+	_, _, err := deployer.Client.Actions.Insert(action, false, true)
+	if err != nil {
+		wskErr := err.(*whisk.WskError)
+		fmt.Printf("Got error creating action with error message: %v and error code: %v.\n", wskErr.Error(), wskErr.ExitCode)
+	}
+}
+
+// from whisk go client
+func (deployer *ServiceDeployer) getQualifiedName(name string, namespace string) string {
+	if strings.HasPrefix(name, "/") {
+		return name
+	} else if strings.HasPrefix(namespace, "/") {
+		return fmt.Sprintf("%s/%s", namespace, name)
+	} else {
+		if len(namespace) == 0 {
+			namespace = deployer.ClientConfig.Namespace
+		}
+		return fmt.Sprintf("/%s/%s", namespace, name)
+	}
+}
+
+func (deployer *ServiceDeployer) printDeploymentAssets() {
+
+	fmt.Println("         ____      ___                   _    _ _     _     _\n        /\\   \\    / _ \\ _ __   ___ _ __ | |  | | |__ (_)___| | __\n   /\\  /__\\   \\  | | | | '_ \\ / _ \\ '_ \\| |  | | '_ \\| / __| |/ /\n  /  \\____ \\  /  | |_| | |_) |  __/ | | | |/\\| | | | | \\__ \\   <\n  \\   \\  /  \\/    \\___/| .__/ \\___|_| |_|__/\\__|_| |_|_|___/_|\\_\\ \n   \\___\\/              |_|\n")
+
+	fmt.Println("Packages:")
+	for _, pack := range deployer.Deployment.Packages {
+		fmt.Println("Name: " + pack.Package.Name)
+
+		for _, action := range pack.Actions {
+			fmt.Println("  * action: " + action.Action.Name)
+			fmt.Println("    bindings: ")
+			for _, p := range action.Action.Parameters {
+
+				value := "?"
+				if str, ok := p.Value.(string); ok {
+					value = str
+				}
+				fmt.Println("        - name: " + p.Key + " value: " + value)
+			}
+		}
+
+		fmt.Println("")
+		for _, action := range pack.Sequences {
+			fmt.Println("  * sequence: " + action.Action.Name)
+		}
+
+		fmt.Println("")
+		for _, trigger := range pack.Triggers {
+			fmt.Println("  * trigger: " + trigger.Name)
+			fmt.Println("    bindings: ")
+
+			for _, p := range trigger.Parameters {
+
+				value := "?"
+				if str, ok := p.Value.(string); ok {
+					value = str
+				}
+				fmt.Println("        - name: " + p.Key + " value: " + value)
+			}
+		}
+
+		fmt.Println("")
+		for _, rule := range pack.Rules {
+			fmt.Println("  rule: " + rule.Name)
+			fmt.Println("    - trigger: " + rule.Trigger + "\n    - action: " + rule.Action)
+		}
+
+		fmt.Println("")
+
+	}
+
+}
diff --git a/deployers/whiskclient.go b/deployers/whiskclient.go
new file mode 100644
index 000000000..aee0acaba
--- /dev/null
+++ b/deployers/whiskclient.go
@@ -0,0 +1,61 @@
+package deployers
+
+import (
+	"net/http"
+	"net/url"
+
+	"github.com/openwhisk/openwhisk-client-go/whisk"
+	"github.com/openwhisk/openwhisk-wskdeploy/parsers"
+	"github.com/openwhisk/openwhisk-wskdeploy/utils"
+)
+
+func NewWhiskClient(proppath string, deploymentPath string) (*whisk.Client, *whisk.Config) {
+	var clientConfig *whisk.Config
+	configs, err := utils.LoadConfiguration(proppath)
+	utils.Check(err)
+
+	credential := configs[2]
+	namespace := configs[0]
+	//we need to get Apihost from property file which currently not defined in sample deployment file.
+	baseURL, err := utils.GetURLBase(configs[1])
+	utils.Check(err)
+
+	if deploymentPath != "" {
+		mm := parsers.NewYAMLParser()
+		deployment := mm.ParseDeployment(deploymentPath)
+		// We get the first package from the sample deployment file.
+		credentialDep := deployment.Application.Credential
+		namespaceDep := deployment.Application.Namespace
+		baseUrlDep := deployment.Application.BaseUrl
+
+		if credentialDep != "" {
+			credential = credentialDep
+		}
+
+		if namespaceDep != "" {
+			namespace = namespaceDep
+		}
+
+		if baseUrlDep != "" {
+			u, err := url.Parse(baseUrlDep)
+			utils.Check(err)
+
+			baseURL = u
+		}
+	}
+
+	clientConfig = &whisk.Config{
+		AuthToken: credential, //Authtoken
+		Namespace: namespace,  //Namespace
+		BaseURL:   baseURL,
+		Version:   "v1",
+		Insecure:  true, // true if you want to ignore certificate signing
+
+	}
+
+	// Setup network client
+	client, err := whisk.NewClient(http.DefaultClient, clientConfig)
+	utils.Check(err)
+	return client, clientConfig
+
+}
diff --git a/doc.go b/doc.go
new file mode 100644
index 000000000..992eee1e7
--- /dev/null
+++ b/doc.go
@@ -0,0 +1,6 @@
+// wskdeploy project doc.go
+
+/*
+wskdeploy document
+*/
+package main
diff --git a/main.go b/main.go
index 0fedd94f6..3961b1f13 100644
--- a/main.go
+++ b/main.go
@@ -1,24 +1,24 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+// Copyright Â© 2017 NAME HERE <EMAIL ADDRESS>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
 
 package main
 
-import (
-	"github.com/openwhisk/openwhisk-wskdeploy/cmd"
-)
+import "github.com/openwhisk/openwhisk-wskdeploy/cmd"
+
+func main() {
+	cmd.Execute()
+}
 
 var (
 	//Version ...The Version of the tool
@@ -31,7 +31,3 @@ func init() {
 	cmd.CliVersion = Version
 	cmd.CliBuild = Build
 }
-
-func main() {
-	cmd.Execute()
-}
diff --git a/utils/deploy_parser.go b/parsers/deploy_parser.go
similarity index 80%
rename from utils/deploy_parser.go
rename to parsers/deploy_parser.go
index 0fd9a3769..235983ee3 100644
--- a/utils/deploy_parser.go
+++ b/parsers/deploy_parser.go
@@ -1,8 +1,10 @@
-package utils
+package parsers
 
 import (
-	"gopkg.in/yaml.v2"
 	"log"
+
+	"github.com/openwhisk/openwhisk-wskdeploy/utils"
+	"gopkg.in/yaml.v2"
 )
 
 func (dm *YAMLParser) UnmarshalDeployment(input []byte, deploy *DeploymentYAML) error {
@@ -25,8 +27,8 @@ func (dm *YAMLParser) MarshalDeployment(deployment *DeploymentYAML) (output []by
 
 func (dm *YAMLParser) ParseDeployment(dply string) *DeploymentYAML {
 	dplyyaml := DeploymentYAML{}
-	content, err := new(ContentReader).LocalReader.ReadLocal(dply)
-	Check(err)
+	content, err := new(utils.ContentReader).LocalReader.ReadLocal(dply)
+	utils.Check(err)
 	err = dm.UnmarshalDeployment(content, &dplyyaml)
 	dplyyaml.Filepath = dply
 	return &dplyyaml
@@ -36,8 +38,8 @@ func (dm *YAMLParser) ParseDeployment(dply string) *DeploymentYAML {
 //This is for parse the deployment yaml file.
 func (app *Application) GetPackageList() []Package {
 	var s1 []Package = make([]Package, 0)
-	for pkg_name, pkg := range app.Packages {
-		pkg.Packagename = pkg_name
+	for _, pkg := range app.Packages {
+		pkg.Packagename = pkg.Packagename
 		s1 = append(s1, pkg)
 	}
 	return s1
diff --git a/parsers/manifest_parser.go b/parsers/manifest_parser.go
new file mode 100644
index 000000000..16524c3ab
--- /dev/null
+++ b/parsers/manifest_parser.go
@@ -0,0 +1,162 @@
+package parsers
+
+import (
+	"log"
+	"os"
+	"path"
+	"strings"
+
+	"github.com/openwhisk/openwhisk-client-go/whisk"
+	"github.com/openwhisk/openwhisk-wskdeploy/utils"
+	"gopkg.in/yaml.v2"
+)
+
+func (dm *YAMLParser) Unmarshal(input []byte, manifest *ManifestYAML) error {
+	err := yaml.Unmarshal(input, manifest)
+	if err != nil {
+		log.Fatalf("error happened during unmarshal :%v", err)
+		return err
+	}
+	return nil
+}
+
+func (dm *YAMLParser) Marshal(manifest *ManifestYAML) (output []byte, err error) {
+	data, err := yaml.Marshal(manifest)
+	if err != nil {
+		log.Fatalf("err happened during marshal :%v", err)
+		return nil, err
+	}
+	return data, nil
+}
+
+func (dm *YAMLParser) ParseManifest(mani string) *ManifestYAML {
+	mm := NewYAMLParser()
+	maniyaml := ManifestYAML{}
+	content, err := new(utils.ContentReader).LocalReader.ReadLocal(mani)
+	utils.Check(err)
+	err = mm.Unmarshal(content, &maniyaml)
+	utils.Check(err)
+	maniyaml.Filepath = mani
+	return &maniyaml
+}
+
+// Is we consider multi pacakge in one yaml?
+func (dm *YAMLParser) ComposePackage(mani *ManifestYAML) (*whisk.SentPackageNoPublish, error) {
+	//mani := dm.ParseManifest(manipath)
+	pag := &whisk.SentPackageNoPublish{}
+	pag.Name = mani.Package.Packagename
+	//The namespace for this package is absent, so we use default guest here.
+	pag.Namespace = mani.Package.Namespace
+	pag.Publish = false
+	return pag, nil
+}
+
+func (dm *YAMLParser) ComposeSequences(namespace string, packageName string, mani *ManifestYAML) ([]utils.ActionRecord, error) {
+	var s1 []utils.ActionRecord = make([]utils.ActionRecord, 0)
+	for key, sequence := range mani.Package.Sequences {
+		wskaction := new(whisk.Action)
+		wskaction.Exec = new(whisk.Exec)
+		wskaction.Exec.Kind = "sequence"
+		actionList := strings.Split(sequence.Actions, ",")
+
+		var components []string
+		for _, a := range actionList {
+
+			act := strings.TrimSpace(a)
+
+			if !strings.HasPrefix(act, packageName+"/") {
+				act = path.Join(packageName, act)
+			}
+			components = append(components, path.Join("/"+namespace, act))
+		}
+
+		wskaction.Exec.Components = components
+		wskaction.Name = key
+		wskaction.Publish = false
+		wskaction.Namespace = namespace
+
+		record := utils.ActionRecord{wskaction, packageName, key}
+		s1 = append(s1, record)
+	}
+	return s1, nil
+}
+
+func (dm *YAMLParser) ComposeActions(mani *ManifestYAML, manipath string) ([]utils.ActionRecord, error) {
+
+	var s1 []utils.ActionRecord = make([]utils.ActionRecord, 0)
+	for key, action := range mani.Package.Actions {
+		splitmanipath := strings.Split(manipath, string(os.PathSeparator))
+		filePath := strings.TrimRight(manipath, splitmanipath[len(splitmanipath)-1]) + action.Location
+		dat, err := new(utils.ContentReader).LocalReader.ReadLocal(filePath)
+		utils.Check(err)
+
+		wskaction := new(whisk.Action)
+		wskaction.Exec = new(whisk.Exec)
+		wskaction.Exec.Code = string(dat)
+		wskaction.Exec = new(whisk.Exec)
+		wskaction.Exec.Code = string(dat)
+
+		if action.Runtime != "" {
+			wskaction.Exec.Kind = action.Runtime
+		} else if action.Location != "" {
+
+			ext := path.Ext(filePath)
+			kind := "nodejs:default"
+
+			switch ext {
+			case ".swift":
+				kind = "swift:default"
+			case ".js":
+				kind = "nodejs:default"
+			case ".py":
+				kind = "python"
+			}
+
+			wskaction.Exec.Kind = kind
+		}
+
+		wskaction.Name = key
+		wskaction.Publish = false
+
+		record := utils.ActionRecord{wskaction, "", action.Location}
+		s1 = append(s1, record)
+	}
+
+	return s1, nil
+
+}
+
+func (dm *YAMLParser) ComposeTriggers(manifest *ManifestYAML) ([]*whisk.Trigger, error) {
+
+	var t1 []*whisk.Trigger = make([]*whisk.Trigger, 0)
+	pkg := manifest.Package
+	for _, trigger := range pkg.GetTriggerList() {
+		wsktrigger := new(whisk.Trigger)
+		wsktrigger.Name = trigger.Name
+		wsktrigger.Namespace = trigger.Namespace
+		wsktrigger.Publish = false
+		t1 = append(t1, wsktrigger)
+	}
+	return t1, nil
+}
+
+func (dm *YAMLParser) ComposeRules(manifest *ManifestYAML) ([]*whisk.Rule, error) {
+
+	var r1 []*whisk.Rule = make([]*whisk.Rule, 0)
+	pkg := manifest.Package
+	for _, rule := range pkg.GetRuleList() {
+		wskrule := rule.ComposeWskRule()
+		r1 = append(r1, wskrule)
+	}
+
+	return r1, nil
+}
+
+func (action *Action) ComposeWskAction(manipath string) (*whisk.Action, error) {
+	wskaction, err := utils.CreateActionFromFile(manipath, action.Location)
+	utils.Check(err)
+	wskaction.Name = action.Name
+	wskaction.Version = action.Version
+	wskaction.Namespace = action.Namespace
+	return wskaction, err
+}
diff --git a/utils/yamlparser.go b/parsers/yamlparser.go
similarity index 71%
rename from utils/yamlparser.go
rename to parsers/yamlparser.go
index fa94a6d55..06bde32a6 100644
--- a/utils/yamlparser.go
+++ b/parsers/yamlparser.go
@@ -1,4 +1,4 @@
-package utils
+package parsers
 
 import (
 	"github.com/openwhisk/openwhisk-client-go/whisk"
@@ -14,7 +14,7 @@ type ParseYaml interface {
 	Marshal(manifest *ManifestYAML) (output []byte, err error)
 
 	//Compose Package entity according to yaml content
-	ComposePackage(manifestpath string) ([]*whisk.Package, error)
+	ComposePackages(manifestpath string) ([]*whisk.Package, error)
 
 	// Compose Action entities according to yaml content
 	ComposeActions(manifestpath string) ([]*whisk.Action, error)
@@ -23,7 +23,7 @@ type ParseYaml interface {
 	ComposeTriggers(manifestpath string, deploymentpath string) ([]*whisk.Trigger, error)
 
 	// Compose Rule entities according to yaml content
-	ComposeRule(manifestpath string) ([]*whisk.Rule, error)
+	ComposeRules(manifestpath string) ([]*whisk.Rule, error)
 }
 
 type YAMLParser struct {
@@ -42,7 +42,14 @@ type Action struct {
 	Inputs     map[string]interface{} `yaml:"inputs"`     //used in both manifest.yaml and deployment.yaml
 	Outputs    map[string]interface{} `yaml:"outputs"`    //used in manifest.yaml
 	//mapping to wsk.Action.Name
-	Name string
+	Name        string
+	Annotations map[string]interface{} `yaml: annotations`
+}
+
+type Dependency struct {
+	Name    string
+	Url     string
+	Version string
 }
 
 type Trigger struct {
@@ -53,7 +60,8 @@ type Trigger struct {
 	Credential string                 `yaml:"credential"` //used in deployment.yaml
 	Inputs     map[string]interface{} `yaml:"inputs"`     //used in deployment.yaml
 	//mapping to wsk.Trigger.Name
-	Name string
+	Name        string
+	Annotations map[string]interface{} `yaml: annotations`
 }
 
 type Feed struct {
@@ -77,28 +85,39 @@ type Rule struct {
 	Name string
 }
 
+type Sequence struct {
+	Actions string
+}
+
 type Package struct {
 	//mapping to wsk.SentPackageNoPublish.Name
 	Packagename string `yaml:"name"` //used in manifest.yaml
 	//mapping to wsk.SentPackageNoPublish.Version
-	Version           string `yaml:"version"`            //used in manifest.yaml
-	License           string `yaml:"license"`            //used in manifest.yaml
-	Function          string `yaml:"function"`           //used in deployment.yaml
-	PackageCredential string `yaml:"package_credential"` //used in deployment.yaml
+	Version           string                `yaml:"version"`            //used in manifest.yaml
+	License           string                `yaml:"license"`            //used in manifest.yaml
+	Dependencies      map[string]Dependency `yaml: dependencies`        // used in manifest.yaml
+	Function          string                `yaml:"function"`           //used in deployment.yaml
+	PackageCredential string                `yaml:"package_credential"` //used in deployment.yaml
 	//mapping to wsk.SentPackageNoPublish.Namespace
-	Namespace  string             `yaml:"namespace"`  //used in deployment.yaml
-	Credential string             `yaml:"credential"` //used in deployment.yaml
-	Actions    map[string]Action  `yaml:"actions"`    //used in both manifest.yaml and deployment.yaml
-	Triggers   map[string]Trigger `yaml:"triggers"`   //used in both manifest.yaml and deployment.yaml
-	Feeds      map[string]Feed    `yaml:"feeds"`      //used in both manifest.yaml and deployment.yaml
-	Rules      map[string]Rule    `yaml:"rules"`      //used in both manifest.yaml and deployment.yaml
-	Inputs     map[string]string  `yaml:"inputs"`     //used in deployment.yaml
+	Namespace   string                 `yaml:"namespace"`  //used in deployment.yaml
+	Credential  string                 `yaml:"credential"` //used in deployment.yaml
+	Actions     map[string]Action      `yaml:"actions"`    //used in both manifest.yaml and deployment.yaml
+	Triggers    map[string]Trigger     `yaml:"triggers"`   //used in both manifest.yaml and deployment.yaml
+	Feeds       map[string]Feed        `yaml:"feeds"`      //used in both manifest.yaml and deployment.yaml
+	Rules       map[string]Rule        `yaml:"rules"`      //used in both manifest.yaml and deployment.yaml
+	Inputs      map[string]string      `yaml:"inputs"`     //used in deployment.yaml
+	Sequences   map[string]Sequence    `yaml: "sequences"`
+	Annotations map[string]interface{} `yaml: annotations`
 }
 
 type Application struct {
-	Name      string             `yaml:"name"`      //used in deployment.yaml
-	Namespace string             `yaml:"namespace"` //used in deployment.yaml
-	Packages  map[string]Package `yaml:"packages"`  //used in deployment.yaml
+	Name       string    `yaml:"name"`      //used in deployment.yaml
+	Namespace  string    `yaml:"namespace"` //used in deployment.yaml
+	Credential string    `yaml:"credential"`
+	BaseUrl    string    `yaml: baseUrl`
+	Version    string    `yaml:"version"`
+	Packages   []Package `yaml:"packages"` //used in deployment.yaml
+	Package    Package   `yaml:"package"`
 }
 
 type DeploymentYAML struct {
diff --git a/tests/testcases/helloworld/deployment.yaml b/tests/testcases/helloworld/deployment.yaml
new file mode 100644
index 000000000..df1d265a5
--- /dev/null
+++ b/tests/testcases/helloworld/deployment.yaml
@@ -0,0 +1,10 @@
+application:
+  name: myHello
+  namespace: _
+  version: 0.0.1
+  package:
+    name: helloworld
+    actions:
+      hello:
+        inputs:
+          name: Paul
\ No newline at end of file
diff --git a/tests/testcases/helloworld/manifest.yaml b/tests/testcases/helloworld/manifest.yaml
index 64bf9702e..f09926625 100644
--- a/tests/testcases/helloworld/manifest.yaml
+++ b/tests/testcases/helloworld/manifest.yaml
@@ -33,3 +33,4 @@ package:
     trigger2:
       name: trigger2
 
+
diff --git a/tests/testcases/helloworld/manifest_full.yml b/tests/testcases/helloworld/manifest_full.yml
deleted file mode 100644
index b91d155de..000000000
--- a/tests/testcases/helloworld/manifest_full.yml
+++ /dev/null
@@ -1,21 +0,0 @@
-  package:
-  name: helloworld
-  version: 1.0
-  license: Apache-2.0
-  actions:
-    hello:
-      version: 1.0
-      location: src/greeting.js
-      runtime: nodejs@6
-      inputs:
-        name:
-          type: string
-          description: A person's name
-        place:
-          type: string
-          description: Where the person is from.
-      outputs:
-        payload:
-          type: string
-          description: a simple greeting message: Hello, name from place!
-
diff --git a/tests/testcases/helloworld/manifest_simplified.yml b/tests/testcases/helloworld/manifest_simplified.yml
deleted file mode 100644
index 217c69b59..000000000
--- a/tests/testcases/helloworld/manifest_simplified.yml
+++ /dev/null
@@ -1,15 +0,0 @@
-package:
-  name: helloworld
-  version: 1.0
-  license: Apache-2.0
-  actions:
-    hello:
-      version: 1.0
-      location: src/greeting.js
-      runtime: nodejs
-      inputs:
-        name: string
-        place: string
-      outputs:
-        payload: string
-
diff --git a/tests/testcases/openstack/deployment.yaml b/tests/testcases/openstack/deployment.yaml
index c5eb6d637..54550796e 100644
--- a/tests/testcases/openstack/deployment.yaml
+++ b/tests/testcases/openstack/deployment.yaml
@@ -1,32 +1,36 @@
-package:
-	name: JiraBackupSolution:
-  actions:
-    getApiToken:
-      inputs:
-        host: ibmaic-myhost.com
-        port: 5000
-        endpointName: nova
-        userId: YYYYYY
-        password: XXXXXX
-        projectId: YYYYYYY
-    callSlack:
-      inputs:
-        url: https://hooks.slack.com/services/XXXXX
-        channel: XXXXXX
-        username: YYYYYYYY
-  triggers:
-    backupTrigger_APP:
-      inputs: 
-        cron: 0 4 * * *
-        triggerPlayload: {"backupName":"AIPLTULJAPP001", "backupType":"daily backup", "rotation":7, "queryString":{"name":"AIPLTULJAPP001.aic-platform.com"}}}
-    backupTrigger_DB:
-      inputs:
-        cron: 0 5 * * *
-        triggerPlayload: {"backupName":"AIPLTULJDB001", "backupType":"daily backup", "rotation":7, "queryString":{"name":"AIPLTULDB001.aic-platform.com"}}}
-    backupTrigger_WEB:
-      inputs:
-        cron: 0 10 * * *
-        triggerPlayload: {"backupName":"AIPLTULJWEB001", "backupType":"daily backup", "rotation":7, "queryString":{"name":"AIPLTULJWEB001.aic-platform.com"}}}
+application:
+  name: GBSBackups
+  namespace: _
+  version: 0.0.1
+  package:
+      name: JiraBackupSolution
+      actions:
+        getApiToken:
+          inputs:
+            host: ibmaic-myhost.com
+            port: 5000
+            endpointName: nova
+            userId: YYYYYY
+            password: XXXXXX
+            projectId: YYYYYYY
+        callSlack:
+          inputs:
+            url: https://hooks.slack.com/services/XXXXX
+            channel: XXXXXX
+            username: YYYYYYYY
+      triggers:
+        backupTrigger_APP:
+          inputs: 
+            cron: 0 4 * * * 
+            triggerPlayload: '{"backupName":"AIPLTULJAPP001", "backupType":"daily backup", "rotation":7, "queryString":{"name":"AIPLTULJAPP001.aic-platform.com"}}}'
+        backupTrigger_DB:
+          inputs:
+            cron: 0 5 * * *
+            triggerPlayload: '{"backupName":"AIPLTULJDB001", "backupType":"daily backup", "rotation":7, "queryString":{"name":"AIPLTULDB001.aic-platform.com"}}}'
+        backupTrigger_WEB:
+          inputs:
+            cron: 0 10 * * *
+            triggerPlayload: '{"backupName":"AIPLTULJWEB001", "backupType":"daily backup", "rotation":7, "queryString":{"name":"AIPLTULJWEB001.aic-platform.com"}}}'
 
 
 
diff --git a/tests/testcases/openstack/manifest.yml b/tests/testcases/openstack/manifest.yaml
similarity index 95%
rename from tests/testcases/openstack/manifest.yml
rename to tests/testcases/openstack/manifest.yaml
index 37f1aa28d..ee91d01df 100644
--- a/tests/testcases/openstack/manifest.yml
+++ b/tests/testcases/openstack/manifest.yaml
@@ -46,14 +46,14 @@ package:
           type: string
         triggerPayload:
           type: string
-    backupTrigger_APP:
+    backupTrigger_DB:
       source: /whisk.system/alarms/alarms
       inputs:
         cron:
           type: string
         triggerPayload:
           type: string
-    backupTrigger_APP:
+    backupTrigger_WEB:
       source: /whisk.system/alarms/alarms
       inputs:
         cron:
diff --git a/tests/testcases/openstack/src/callSlack.js b/tests/testcases/openstack/src/callSlack.js
new file mode 100644
index 000000000..3cb3370e4
--- /dev/null
+++ b/tests/testcases/openstack/src/callSlack.js
@@ -0,0 +1,71 @@
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+//
+//  Post Slack Message
+//
+//  @param apiToken apiToken retrieved from Keystone
+//
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+var request = require('request');
+
+//var whisk = { console: console };
+//main({url: 'https://hooks.slack.com/services/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', channel: '#platform-alerts', username: 'WhiskBot', icon: ':exclamation:', title: 'title', content: 'content'});
+
+function main(msg) {
+    var postPromise = post(msg.url,
+         msg.channel, {
+         username : msg.username || 'whisk',
+         icon : msg.icon || ':openwhisk:',
+         status : msg.status || 'good',
+         title : msg.title || '',
+         content : msg.content || ''
+    });
+
+    return postPromise;
+}
+
+function colorForStatus(status) {
+    if (status === 'good' || status === 'danger')
+        return status;
+    else if (status === 'warning')
+        return '#FF9900';
+    else
+        return '#3333FF';
+}
+
+function post(url, channel, msg) {
+    var form = {
+        channel : channel,
+        username : msg.username,
+        icon_emoji : msg.icon,
+        mrkdwn_in : [ 'fields' ],
+        attachments : [ {
+            fallback : msg.content,
+            color : colorForStatus(msg.status),
+            fields : [ {
+                title : msg.title,
+                value : msg.content,
+                short : false
+            } ]
+        } ]
+    };
+
+    return new Promise(function(resolve, reject) {
+      request.post({
+          url : url,
+          formData : {
+              payload : JSON.stringify(form)
+          }
+      }, function(error, response, body) {
+          if (!error && response.statusCode == 200 && body == 'ok') {
+              console.log('posted', msg.content, 'to slack');
+              resolve();
+          } else {
+              console.log('[error]', error, body);
+              reject(error);
+          }
+      });
+    });
+}
\ No newline at end of file
diff --git a/tests/testcases/openstack/src/createBackup.js b/tests/testcases/openstack/src/createBackup.js
new file mode 100644
index 000000000..12fba7a76
--- /dev/null
+++ b/tests/testcases/openstack/src/createBackup.js
@@ -0,0 +1,130 @@
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+//
+//  Create a snapshot of a server
+//
+//  @param apiToken apiToken retrieved from Keystone
+//
+//  http://developer.openstack.org/api-ref/compute/?expanded=create-server-back-up-createbackup-action-detail
+//
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+var request = require('request')
+
+function pad(n){return (n < 10? '0' : '') + n;}
+
+function main(params) {
+
+    console.log('createNewSnapshot. got params '+JSON.stringify(params))
+
+     if (!params.apiToken) {
+        return {"msg" : "Missing apiToken"}
+    }
+     if (!params.apiEndpoint) {
+        return {"msg" : "Missing apiEndpoint"}
+    }
+     if (!params.serverId ) {
+        return {"msg" : "Missing snapshot serverId"}
+    }
+
+    if (!params.context) {
+        return {"msg" : "Missing context"}
+    }
+
+    if (!params.context.backupName) {
+        return {"msg" : "Missing backup name"}
+    }
+
+    if (!params.context.backupType) {
+        return {"msg" : "Missing backup type"}
+    }
+
+    if (!params.context.rotation) {
+        return {"msg" : "Missing rotation"}
+    }
+
+    var apiEndpoint = params.apiEndpoint
+    var apiToken = params.apiToken
+    var serverId = params.serverId
+    var backupName = params.context.backupName
+    var backupType = params.context.backupType
+    var rotation = params.context.rotation
+
+
+
+    d = new Date();
+    d.setUTCHours(d.getUTCHours() - 5);
+    var backupDate = d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes())
+    console.log('Backup Date : ' + backupDate)
+
+    var backupNameDate = backupName + '.' + backupDate
+
+    console.log('createNewSnapshot params ' + JSON.stringify(params))
+
+    var context = null
+    if (params.context) {
+        context = params.context
+    }
+
+    var headers = {
+        'X-Auth-Token': apiToken,
+        'content-type': 'application/json'
+    };
+
+    //May be a better way to parse this
+    var post_data = {
+        createBackup: {
+            name: backupNameDate,
+            backup_type: backupType,
+            rotation: rotation
+        }
+    };  
+
+    var url = apiEndpoint+'/servers/'+serverId+'/action'
+
+    // hardcode for now
+    var options = {
+        method: 'POST',
+        json: post_data,
+        headers: headers
+    };
+
+   
+    var headers = {
+        'X-Auth-Token':apiToken
+    };
+
+    console.log('Options are : '+ JSON.stringify(options))
+
+    return new Promise(function(resolve, reject) {
+        request(url, options, function(error, res, body) {
+
+
+            if (error) {
+                var strContent = "Error occured in backing up server: " + backupName + "(" + serverId + "). Error: " + JSON.stringify(error)
+                reject({ status: "danger",  title: "Backup Report", content: strContent})
+            } else if (res.statusCode >= 400) {
+                for (var key in body) {
+                    if (body.hasOwnProperty(key)) {
+                        var strCode = body[key].code
+                        var strError = key
+                        var strMsg = body[key].message
+                    }
+                }
+                var strContent = "Server: " + backupName + "(" + serverId + "). \nCode: " + strCode + "\nWarning: " + strError + "\nMessage: " + strMsg
+                var strStatus = "warning"
+            } else {
+                var strContent = "Backup complete for server: " + backupName + "(" + serverId + ")"
+                var strStatus = "good"
+            }
+
+            console.log('Response Code: ' + res.statusCode + ' Body: '+ JSON.stringify(body))
+
+            resolve({ status: strStatus,  title: "Backup Report", content: strContent })
+        });
+
+    });
+    
+}
diff --git a/tests/testcases/openstack/src/getApiToken.js b/tests/testcases/openstack/src/getApiToken.js
new file mode 100644
index 000000000..d6ac4b391
--- /dev/null
+++ b/tests/testcases/openstack/src/getApiToken.js
@@ -0,0 +1,140 @@
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+//
+//  Get Auth Token from Keystone
+//
+//  Will retrieve the auth token and storage URL for the object store service.  Uses V3 of the auth calls
+//
+//  The params object should look like:
+// 
+//  "userId":"f45adsa0d0478c", "password":"sd2rsS^kdfsd", "projectId":"11fdseerff"}
+//
+//  @param userId: user id (not user name)
+//  @param password: password
+//  @param projectId: project/tenantId
+//  @param host: hostname of keystone endpoint (don't include 'https://')
+//  @param port: port of keystone endpoint
+//  @param endpointName: the name of the public endpoint service you want (nova, swift, etc)
+//  
+//
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+var request = require('request')
+var url = require('url')
+
+function main(params) {
+
+    if (!params.userId || !params.password || !params.projectId || !params.host || !params.port || !params.endpointName) {
+        return {"msg" : "Missing required parameters"}
+    }
+
+    console.log('getApiToken. Params '+JSON.stringify(params))
+
+    var userId = params.userId
+    var password = params.password
+    var projectId = params.projectId
+    var pathPrefix = ""
+    var host = params.host
+    var port = params.port
+    var endpointName = params.endpointName
+
+    // customize your path here.
+    if (params.pathPrefix) {
+        pathPrefix = params.pathPrefix
+    }
+
+    var endpointUrl = 'https://' + host + ':' + port + '/v3/auth/tokens'
+
+    var context = null
+    if (params.context) {
+        context = params.context
+    }
+
+   
+    var body = {
+    "auth": {
+        "identity": {
+            "methods": [
+                "password"
+            ],
+            "password": {
+                "user": {
+                    "id": userId,
+                    "password": password
+                }
+            }
+        },
+        "scope": {
+            "project": {
+                "id": projectId
+            }
+        }
+    }
+}
+
+    var headers = {
+       'Content-Type': 'application/json',
+       'Content-Length': Buffer.byteLength(JSON.stringify(body), ['utf8'])
+    };
+
+    var options = {
+        method: 'POST',
+        headers: headers,
+        json: body
+    };
+
+    console.log("got options "+ JSON.stringify(options))
+
+    return new Promise(function(resolve, reject) {
+        request(endpointUrl, options, function (error, response, body) {
+            //console.log(body)
+            if (!error) {
+
+                var authToken = response.headers['x-subject-token']
+
+                var j = body
+                var entries = j.token.catalog
+            
+                for (var i = 0; i < entries.length; i++) {
+                    var entry = entries[i]
+                    console.log('Comparing '+ entry.name + " with "+endpointName)
+                    if (entry.name === endpointName) {
+                        var endpoints = entry.endpoints
+
+                        console.log('Got endpoints '+endpoints)
+                        for (var j = 0; j < endpoints.length; j++) {
+                            var endpoint = endpoints[j]
+                            if (endpoint.interface === 'public') {
+                                console.log('Public endpoint is ' + endpoint.url)
+                                console.log('Auth token is ' + authToken)
+
+                                var urlParts = url.parse(endpoint.url,true)
+
+                                var jsonResponse = {apiToken: authToken, 
+                                    endpointUrl: endpoint.url, 
+                                    host: urlParts.hostname, 
+                                    port: urlParts.port, 
+                                    path: urlParts.path, 
+                                    protocol: urlParts.protocol}
+
+                                if (context) {
+                                    jsonResponse.context = context
+                                }
+
+                                return resolve(jsonResponse)
+                            }
+                        }
+                    }
+            } 
+            
+            reject({'msg': 'Cannot find public endpoint in response from keystone'})
+
+            } else {
+                reject(error)
+            }
+        });
+
+    });    
+}
diff --git a/tests/testcases/openstack/src/getServers.js b/tests/testcases/openstack/src/getServers.js
new file mode 100644
index 000000000..4e4003564
--- /dev/null
+++ b/tests/testcases/openstack/src/getServers.js
@@ -0,0 +1,83 @@
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+//
+//  Get Servers from Nova
+//
+//  Will retrieve a list of filtered servers from Nova.  
+//
+//  @param apiToken apiToken retrieved from Keystone
+//
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+
+var request = require('request')
+
+function main(params) {
+
+    if (!params.apiToken || !params.host || !params.port || !params.path || !params.protocol) {
+        return {"msg" : "Missing required params"}
+    }
+
+    console.log('Got params ' + JSON.stringify(params))
+
+    var apiToken = params.apiToken
+    var host = params.host
+    var port = params.port
+    var path = params.path
+    var protocol = params.protocol
+
+
+    var context = null
+    if (params.context) {
+        context = params.context
+    }
+   
+    var headers = {
+        'X-Auth-Token':apiToken
+    };
+ 
+    var apiEndpoint = protocol+'//'+host+':'+port+path
+   
+   var url = apiEndpoint+'/servers'
+
+    // hardcode for now
+    var options = {
+        method: 'GET',
+        headers: headers
+    };
+
+    
+    if (context && context.queryString) {
+        options.qs = context.queryString
+    }
+
+    console.log('Options are : '+ JSON.stringify(options))
+
+    return new Promise(function(resolve, reject) {
+        request(url, options, function(error, res, body) {
+            
+            if (error) {
+                reject(error)
+            }
+
+            var j = JSON.parse(body)
+
+            if (context) {
+                j.context = context
+            }
+
+            // set this for downstream actions that want compute endpoint
+            j.apiEndpoint = apiEndpoint
+            j.apiToken = apiToken
+
+            if (j.servers.length > 0) {
+                j.serverId = j.servers[0].id
+            } 
+
+            console.log(j)
+            resolve(j)
+        });
+    });
+    
+}
diff --git a/tests/testcases/openstack/src/greeting.js b/tests/testcases/openstack/src/greeting.js
new file mode 100644
index 000000000..eaa68346e
--- /dev/null
+++ b/tests/testcases/openstack/src/greeting.js
@@ -0,0 +1,11 @@
+/**
+ * Return a simple greeting message for someone.
+ *
+ * @param name A person's name.
+ * @param place Where the person is from.
+ */
+function main(params) {
+    var name = params.name || params.payload || 'stranger';
+    var place = params.place || 'somewhere';
+    return {payload:  'Hello, ' + name + ' from ' + place + '!'};
+}
diff --git a/tests/testcases/whiskbot/deployment.yaml b/tests/testcases/whiskbot/deployment.yaml
index 549325726..88ac386c7 100644
--- a/tests/testcases/whiskbot/deployment.yaml
+++ b/tests/testcases/whiskbot/deployment.yaml
@@ -1,20 +1,24 @@
-package:
+Application:
   name: whiskbot
-  inputs:
-    fieldToEncrypt: XXXX
-    fieldPathToEncrypt: YYYYY
-    encryptionPassword: XXXXX
-    wskauths: YYYYYYYYY
-  actions:
-    fire:
-      inputs:
-        triggername: XXXXXXX
-      annotations:
-        web-export: true
-    newbot-setup:
-      inputs:
-        configPage: YYYYYYYYY
-  sequences:
-    newbot:
-      annotaions:
-        web-export: true
\ No newline at end of file
+  namespace: mynamespace
+  version: 1.0
+  package:
+    name: whiskbot
+    inputs:
+      fieldToEncrypt: XXXX
+      fieldPathToEncrypt: YYYYY
+      encryptionPassword: XXXXX
+      wskauths: YYYYYYYYY
+    actions:
+      fire:
+        inputs:
+          triggername: XXXXXXX
+        annotations:
+          web-export: true
+      newbot-setup:
+        inputs:
+          configPage: YYYYYYYYY
+    sequences:
+      newbot:
+        annotaions:
+          web-export: true
\ No newline at end of file
diff --git a/tests/util_test.go b/tests/util_test.go
index 637441ae7..f1bdd9253 100644
--- a/tests/util_test.go
+++ b/tests/util_test.go
@@ -1,8 +1,9 @@
 package tests
 
 import (
-	"github.com/openwhisk/openwhisk-wskdeploy/utils"
 	"testing"
+
+	"github.com/openwhisk/openwhisk-wskdeploy/utils"
 )
 
 var contentReader = new(utils.ContentReader)
diff --git a/tests/yamlparser_test.go b/tests/yamlparser_test.go
index 917d3172a..19c09126f 100644
--- a/tests/yamlparser_test.go
+++ b/tests/yamlparser_test.go
@@ -1,10 +1,10 @@
 package tests
 
 import (
-	"github.com/openwhisk/openwhisk-wskdeploy/utils"
-	"github.com/stretchr/testify/assert"
 	"io/ioutil"
 	"testing"
+
+	"github.com/stretchr/testify/assert"
 )
 
 var manifest_yaml = "testcases/helloworld/manifest.yaml"
@@ -23,8 +23,8 @@ func TestParseManifestYAML(t *testing.T) {
 		panic(err)
 	}
 
-	var manifest utils.ManifestYAML
-	err = utils.NewYAMLParser().Unmarshal(data, &manifest)
+	var manifest parsers.ManifestYAML
+	err = parsers.NewYAMLParser().Unmarshal(data, &manifest)
 	if err != nil {
 		panic(err)
 	}
@@ -62,8 +62,8 @@ func TestParseManifestYAML_trigger(t *testing.T) {
 		panic(err)
 	}
 
-	var manifest utils.ManifestYAML
-	err = utils.NewYAMLParser().Unmarshal(data, &manifest)
+	var manifest parsers.ManifestYAML
+	err = parsers.NewYAMLParser().Unmarshal(data, &manifest)
 	if err != nil {
 		panic(err)
 	}
@@ -87,8 +87,8 @@ func TestParseManifestYAML_rule(t *testing.T) {
 		panic(err)
 	}
 
-	var manifest utils.ManifestYAML
-	err = utils.NewYAMLParser().Unmarshal(data, &manifest)
+	var manifest parsers.ManifestYAML
+	err = parsers.NewYAMLParser().Unmarshal(data, &manifest)
 	if err != nil {
 		panic(err)
 	}
@@ -113,8 +113,8 @@ func TestParseManifestYAML_feed(t *testing.T) {
 		panic(err)
 	}
 
-	var manifest utils.ManifestYAML
-	err = utils.NewYAMLParser().Unmarshal(data, &manifest)
+	var manifest parsers.ManifestYAML
+	err = parsers.NewYAMLParser().Unmarshal(data, &manifest)
 	if err != nil {
 		panic(err)
 	}
@@ -143,7 +143,7 @@ func TestParseManifestYAML_feed(t *testing.T) {
 
 func TestParseDeploymentYAML_Application(t *testing.T) {
 	//var deployment utils.DeploymentYAML
-	mm := utils.NewYAMLParser()
+	mm := parsers.NewYAMLParser()
 	deployment := mm.ParseDeployment(testfile1)
 
 	//get and verify application name
@@ -153,7 +153,7 @@ func TestParseDeploymentYAML_Application(t *testing.T) {
 
 func TestParseDeploymentYAML_Package(t *testing.T) {
 	//var deployment utils.DeploymentYAML
-	mm := utils.NewYAMLParser()
+	mm := parsers.NewYAMLParser()
 	deployment := mm.ParseDeployment(testfile2)
 
 	assert.Equal(t, 1, len(deployment.Application.Packages), "Get package list failed.")
@@ -174,7 +174,7 @@ func TestParseDeploymentYAML_Package(t *testing.T) {
 }
 
 func TestParseDeploymentYAML_Action(t *testing.T) {
-	mm := utils.NewYAMLParser()
+	mm := parsers.NewYAMLParser()
 	deployment := mm.ParseDeployment(testfile2)
 
 	for pkg_name := range deployment.Application.Packages {
@@ -201,7 +201,7 @@ func TestParseDeploymentYAML_Action(t *testing.T) {
 }
 
 func TestComposeWskPackage(t *testing.T) {
-	mm := utils.NewYAMLParser()
+	mm := parsers.NewYAMLParser()
 	deployment := mm.ParseDeployment(testfile2)
 	manifest := mm.ParseManifest(manifestfile1)
 
@@ -219,7 +219,7 @@ func TestComposeWskPackage(t *testing.T) {
 }
 
 func TestComposeWskTrigger(t *testing.T) {
-	mm := utils.NewYAMLParser()
+	mm := parsers.NewYAMLParser()
 	deployment := mm.ParseDeployment(testfile4)
 	manifest := mm.ParseManifest(manifestfile3)
 
@@ -245,7 +245,7 @@ func TestComposeWskTrigger(t *testing.T) {
 }
 
 func TestComposeWskRule(t *testing.T) {
-	mm := utils.NewYAMLParser()
+	mm := parsers.NewYAMLParser()
 	manifest := mm.ParseManifest(manifestfile4)
 
 	pkg := manifest.Package
diff --git a/utils/contentreader.go b/utils/contentreader.go
new file mode 100644
index 000000000..0bf7124dc
--- /dev/null
+++ b/utils/contentreader.go
@@ -0,0 +1,33 @@
+package utils
+
+import (
+	"io/ioutil"
+	"net/http"
+)
+
+// agnostic util reader to fetch content from web or local path or potentially other places.
+type ContentReader struct {
+	URLReader
+	LocalReader
+}
+
+type URLReader struct {
+}
+
+func (urlReader *URLReader) ReadUrl(url string) (content []byte, err error) {
+	resp, err := http.Get(url)
+	Check(err)
+	b, err := ioutil.ReadAll(resp.Body)
+	defer resp.Body.Close()
+	Check(err)
+	return b, nil
+}
+
+type LocalReader struct {
+}
+
+func (localReader *LocalReader) ReadLocal(path string) (content []byte, err error) {
+	cont, err := ioutil.ReadFile(path)
+	Check(err)
+	return cont, nil
+}
diff --git a/utils/errorhandlers.go b/utils/errorhandlers.go
new file mode 100644
index 000000000..7d9f1abb8
--- /dev/null
+++ b/utils/errorhandlers.go
@@ -0,0 +1,34 @@
+package utils
+
+import (
+	"errors"
+	"log"
+	"os"
+)
+
+// ServerlessErr records errors from the Serverless binary
+type ServerlessErr struct {
+	Msg string
+}
+
+func (e *ServerlessErr) Error() string {
+	return e.Msg
+}
+
+// Check is a util function to panic when there is an error.
+func Check(e error) {
+	defer func() {
+		if err := recover(); err != nil {
+			log.Printf("runtime panic : %v", err)
+		}
+	}()
+
+	if e != nil {
+		log.Printf("%v", e)
+		erro := errors.New("Error happened during execution, please type 'wskdeploy -h' for help messages.")
+		log.Printf("%v", erro)
+		os.Exit(1)
+
+	}
+
+}
diff --git a/utils/fileoperations.go b/utils/fileoperations.go
new file mode 100644
index 000000000..4b81c6d6d
--- /dev/null
+++ b/utils/fileoperations.go
@@ -0,0 +1,137 @@
+package utils
+
+import (
+	"bufio"
+	"errors"
+	"log"
+	"os"
+	"path"
+	"path/filepath"
+	"strings"
+
+	"github.com/openwhisk/openwhisk-client-go/whisk"
+)
+
+func FileExists(file string) bool {
+	_, err := os.Stat(file)
+	if err != nil {
+		err = errors.New("File not found.")
+		return false
+	} else {
+		return true
+	}
+}
+
+func IsDirectory(filePath string) bool {
+	f, err := os.Open(filePath)
+	Check(err)
+
+	defer f.Close()
+
+	fi, err := f.Stat()
+	Check(err)
+
+	switch mode := fi.Mode(); {
+	case mode.IsDir():
+		return true
+	case mode.IsRegular():
+		return false
+	default:
+		return false
+	}
+}
+
+func CreateActionFromFile(manipath, filePath string) (*whisk.Action, error) {
+	ext := path.Ext(filePath)
+	baseName := path.Base(filePath)
+	//check if the file if from local or from web
+	//currently only consider http
+	islocal := !strings.HasPrefix(filePath, "http")
+	name := strings.TrimSuffix(baseName, filepath.Ext(baseName))
+	action := new(whisk.Action)
+	//better refactor this
+	if islocal {
+		splitmanipath := strings.Split(manipath, string(os.PathSeparator))
+		filePath = strings.TrimRight(manipath, splitmanipath[len(splitmanipath)-1]) + filePath
+	}
+	// process source code files
+	if ext == ".swift" || ext == ".js" || ext == ".py" {
+
+		kind := "nodejs:default"
+
+		switch ext {
+		case ".swift":
+			kind = "swift:default"
+		case ".js":
+			kind = "nodejs:default"
+		case ".py":
+			kind = "python"
+		}
+
+		var dat []byte
+		var err error
+
+		if islocal {
+			dat, err = new(ContentReader).LocalReader.ReadLocal(filePath)
+		} else {
+			dat, err = new(ContentReader).URLReader.ReadUrl(filePath)
+		}
+
+		Check(err)
+		action.Exec = new(whisk.Exec)
+		action.Exec.Code = string(dat)
+		action.Exec = new(whisk.Exec)
+		action.Exec.Code = string(dat)
+		action.Exec.Kind = kind
+		action.Name = name
+		action.Publish = false
+		return action, nil
+		//dat, err := new(ContentReader).URLReader.ReadUrl(filePath)
+		//Check(err)
+
+	}
+	// If the action is not supported, we better to return an error.
+	return nil, errors.New("Unsupported action type.")
+}
+
+func ReadProps(path string) (map[string]string, error) {
+
+	props := map[string]string{}
+
+	file, err := os.Open(path)
+	if err != nil {
+		// If file does not exist, just return props
+		log.Printf("Unable to read whisk properties file '%s' (file open error: %s); falling back to default properties\n", path, err)
+		return props, nil
+	}
+	defer file.Close()
+
+	lines := []string{}
+	scanner := bufio.NewScanner(file)
+	for scanner.Scan() {
+		lines = append(lines, scanner.Text())
+	}
+
+	props = map[string]string{}
+	for _, line := range lines {
+		kv := strings.Split(line, "=")
+		if len(kv) != 2 {
+			// Invalid format; skip
+			continue
+		}
+		props[kv[0]] = kv[1]
+	}
+
+	return props, nil
+
+}
+
+// Load configuration will load properties from a file
+func LoadConfiguration(propPath string) ([]string, error) {
+	props, err := ReadProps(propPath)
+	Check(err)
+	Namespace := props["NAMESPACE"]
+	Apihost := props["APIHOST"]
+	Authtoken := props["AUTH"]
+	return []string{Namespace, Apihost, Authtoken}, nil
+}
diff --git a/utils/manifest_parser.go b/utils/manifest_parser.go
deleted file mode 100644
index 462b82807..000000000
--- a/utils/manifest_parser.go
+++ /dev/null
@@ -1,112 +0,0 @@
-package utils
-
-import (
-	"github.com/openwhisk/openwhisk-client-go/whisk"
-	"gopkg.in/yaml.v2"
-	"log"
-	"strings"
-)
-
-// Is we consider multi pacakge in one yaml?
-func (dm *YAMLParser) ComposePackage(manipath string) (*whisk.SentPackageNoPublish, error) {
-	mani := dm.ParseManifest(manipath)
-	pag := &whisk.SentPackageNoPublish{}
-	pag.Name = mani.Package.Packagename
-	//The namespace for this package is absent, so we use default guest here.
-	pag.Namespace = mani.Package.Namespace
-	pag.Publish = false
-	return pag, nil
-}
-
-func (dm *YAMLParser) Unmarshal(input []byte, manifest *ManifestYAML) error {
-	err := yaml.Unmarshal(input, manifest)
-	if err != nil {
-		log.Fatalf("error happened during unmarshal :%v", err)
-		return err
-	}
-	return nil
-}
-
-func (dm *YAMLParser) Marshal(manifest *ManifestYAML) (output []byte, err error) {
-	data, err := yaml.Marshal(manifest)
-	if err != nil {
-		log.Fatalf("err happened during marshal :%v", err)
-		return nil, err
-	}
-	return data, nil
-}
-
-func (dm *YAMLParser) ParseManifest(mani string) *ManifestYAML {
-	mm := NewYAMLParser()
-	maniyaml := ManifestYAML{}
-	content, err := new(ContentReader).LocalReader.ReadLocal(mani)
-	Check(err)
-	err = mm.Unmarshal(content, &maniyaml)
-	maniyaml.Filepath = mani
-	return &maniyaml
-}
-
-func (dm *YAMLParser) ComposeActions(manipath string) ([]ActionRecord, error) {
-	mani := dm.ParseManifest(manipath)
-	var s1 []ActionRecord = make([]ActionRecord, 0)
-	for _, action := range mani.Package.Actions {
-		wskaction, err := CreateActionFromFile(manipath, action.Location)
-		Check(err)
-
-		record := ActionRecord{wskaction, action.Location}
-		s1 = append(s1, record)
-	}
-	return s1, nil
-}
-
-func (dm *YAMLParser) ComposeTriggers(mani string, deploy string) ([]*whisk.Trigger, error) {
-	mm := NewYAMLParser()
-	manifest := mm.ParseManifest(mani)
-	//parse the deployment yaml to get feed info as annotations for triggers
-	deployment := mm.ParseDeployment(deploy)
-	//This is to get the pkgs in deployment yaml
-	var kva []whisk.KeyValue = make([]whisk.KeyValue, 0)
-	for _, dep_pkg := range deployment.Application.GetPackageList() {
-		for _, feed := range dep_pkg.GetFeedList() {
-			log.Printf("feed name is %v", feed.Name)
-			feedFullName := strings.Join([]string{dep_pkg.Packagename, feed.Name}, "/")
-			kv := whisk.KeyValue{"feed", feedFullName}
-			kva = append(kva, kv)
-			for k, v := range feed.Inputs {
-				kv := whisk.KeyValue{k, v}
-				kva = append(kva, kv)
-			}
-		}
-	}
-
-	//parse the manifest yaml
-	var t1 []*whisk.Trigger = make([]*whisk.Trigger, 0)
-	pkg := manifest.Package
-	for _, trigger := range pkg.GetTriggerList() {
-		wsktrigger := trigger.ComposeWskTrigger(kva)
-		t1 = append(t1, wsktrigger)
-	}
-	return t1, nil
-}
-
-func (dm *YAMLParser) ComposeRules(mani string) ([]*whisk.Rule, error) {
-	mm := NewYAMLParser()
-	manifest := mm.ParseManifest(mani)
-	var r1 []*whisk.Rule = make([]*whisk.Rule, 0)
-	pkg := manifest.Package
-	for _, rule := range pkg.GetRuleList() {
-		wskrule := rule.ComposeWskRule()
-		r1 = append(r1, wskrule)
-	}
-
-	return r1, nil
-}
-
-func (action *Action) ComposeWskAction(manipath string) (*whisk.Action, error) {
-	wskaction, err := CreateActionFromFile(manipath, action.Location)
-	Check(err)
-	wskaction.Name = action.Name
-	wskaction.Version = action.Version
-	wskaction.Namespace = action.Namespace
-	return wskaction, err
-}
diff --git a/utils/misc.go b/utils/misc.go
new file mode 100644
index 000000000..c6e517d68
--- /dev/null
+++ b/utils/misc.go
@@ -0,0 +1,49 @@
+package utils
+
+import (
+	"fmt"
+	"net/url"
+	"os/user"
+
+	"github.com/openwhisk/openwhisk-client-go/whisk"
+)
+
+// ActionRecord is a container to keep track of
+// a whisk action struct and a location filepath we use to
+// map files and manifest declared actions
+type ActionRecord struct {
+	Action      *whisk.Action
+	Packagename string
+	Filepath    string
+}
+
+type TriggerRecord struct {
+	Trigger     *whisk.Trigger
+	Packagename string
+}
+
+type RuleRecord struct {
+	Rule        *whisk.Rule
+	Packagename string
+}
+
+// Utility to convert hostname to URL object
+func GetURLBase(host string) (*url.URL, error) {
+
+	urlBase := fmt.Sprintf("%s/api/", host)
+	url, err := url.Parse(urlBase)
+
+	if len(url.Scheme) == 0 || len(url.Host) == 0 {
+		urlBase = fmt.Sprintf("https://%s/api/", host)
+		url, err = url.Parse(urlBase)
+	}
+
+	return url, err
+}
+
+func GetHomeDirectory() string {
+	usr, err := user.Current()
+	Check(err)
+
+	return usr.HomeDir
+}
diff --git a/utils/util.go b/utils/util.go
deleted file mode 100644
index 4c1443b3e..000000000
--- a/utils/util.go
+++ /dev/null
@@ -1,285 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package utils
-
-import (
-	"bufio"
-	"errors"
-	"fmt"
-	"github.com/openwhisk/openwhisk-client-go/whisk"
-	"io/ioutil"
-	"log"
-	"net/http"
-	"net/url"
-	"os"
-	"os/user"
-	"path"
-	"path/filepath"
-	"strings"
-)
-
-// ActionRecord is a container to keep track of
-// a whisk action struct and a location filepath we use to
-// map files and manifest declared actions
-type ActionRecord struct {
-	Action   *whisk.Action
-	Filepath string
-}
-
-func NewClient(proppath string, deploymentPath string) (*whisk.Client, *whisk.Config) {
-	var clientConfig *whisk.Config
-	configs, err := LoadConfiguration(proppath)
-	Check(err)
-	//we need to get Apihost from property file which currently not defined in sample deployment file.
-	baseURL, err := GetURLBase(configs[1])
-	Check(err)
-	if deploymentPath != "" {
-		mm := NewYAMLParser()
-		deployment := mm.ParseDeployment(deploymentPath)
-		// We get the first package from the sample deployment file.
-		pkg := deployment.Application.GetPackageList()[0]
-		clientConfig = &whisk.Config{
-			AuthToken: pkg.Credential, //Authtoken
-			Namespace: pkg.Namespace,  //Namespace
-			BaseURL:   baseURL,
-			Version:   "v1",
-			Insecure:  true,
-		}
-
-	} else {
-		clientConfig = &whisk.Config{
-			AuthToken: configs[2], //Authtoken
-			Namespace: configs[0], //Namespace
-			BaseURL:   baseURL,
-			Version:   "v1",
-			Insecure:  true, // true if you want to ignore certificate signing
-
-		}
-
-	}
-
-	// Setup network client
-	client, err := whisk.NewClient(http.DefaultClient, clientConfig)
-	Check(err)
-	return client, clientConfig
-}
-
-// ServerlessBinaryCommand is the CLI name to run serverless
-const ServerlessBinaryCommand = "serverless"
-
-// ManifestProvider is a provider description in the manifest
-type ManifestProvider struct {
-	Name    string
-	Runtime string
-}
-
-// Manifest is the main manifest file
-type Manifest struct {
-	Service  string
-	Provider ManifestProvider
-}
-
-// ServerlessErr records errors from the Serverless binary
-type ServerlessErr struct {
-	Msg string
-}
-
-func (e *ServerlessErr) Error() string {
-	return e.Msg
-}
-
-// Check is a util function to panic when there is an error.
-func Check(e error) {
-	defer func() {
-		if err := recover(); err != nil {
-			log.Printf("runtime panic : %v", err)
-		}
-	}()
-
-	if e != nil {
-		log.Printf("%v", e)
-		erro := errors.New("Error happened during execution, please type 'wskdeploy -h' for help messages.")
-		log.Printf("%v", erro)
-		os.Exit(1)
-
-	}
-
-}
-
-type URLReader struct {
-}
-
-func (urlReader *URLReader) ReadUrl(url string) (content []byte, err error) {
-	resp, err := http.Get(url)
-	Check(err)
-	b, err := ioutil.ReadAll(resp.Body)
-	defer resp.Body.Close()
-	Check(err)
-	return b, nil
-}
-
-type LocalReader struct {
-}
-
-func (localReader *LocalReader) ReadLocal(path string) (content []byte, err error) {
-	cont, err := ioutil.ReadFile(path)
-	Check(err)
-	return cont, nil
-}
-
-// agnostic util reader to fetch content from web or local path or potentially other places.
-type ContentReader struct {
-	URLReader
-	LocalReader
-}
-
-func GetHomeDirectory() string {
-	usr, err := user.Current()
-	Check(err)
-
-	return usr.HomeDir
-}
-
-// Utility to convert hostname to URL object
-func GetURLBase(host string) (*url.URL, error) {
-
-	urlBase := fmt.Sprintf("%s/api/", host)
-	url, err := url.Parse(urlBase)
-
-	if len(url.Scheme) == 0 || len(url.Host) == 0 {
-		urlBase = fmt.Sprintf("https://%s/api/", host)
-		url, err = url.Parse(urlBase)
-	}
-
-	return url, err
-}
-
-func ReadProps(path string) (map[string]string, error) {
-
-	props := map[string]string{}
-
-	file, err := os.Open(path)
-	if err != nil {
-		// If file does not exist, just return props
-		fmt.Printf("Unable to read whisk properties file '%s' (file open error: %s); falling back to default properties\n", path, err)
-		return props, nil
-	}
-	defer file.Close()
-
-	lines := []string{}
-	scanner := bufio.NewScanner(file)
-	for scanner.Scan() {
-		lines = append(lines, scanner.Text())
-	}
-
-	props = map[string]string{}
-	for _, line := range lines {
-		kv := strings.Split(line, "=")
-		if len(kv) != 2 {
-			// Invalid format; skip
-			continue
-		}
-		props[kv[0]] = kv[1]
-	}
-
-	return props, nil
-
-}
-
-func IsDirectory(filePath string) bool {
-	f, err := os.Open(filePath)
-	Check(err)
-
-	defer f.Close()
-
-	fi, err := f.Stat()
-	Check(err)
-
-	switch mode := fi.Mode(); {
-	case mode.IsDir():
-		return true
-	case mode.IsRegular():
-		return false
-	default:
-		return false
-	}
-}
-
-func CreateActionFromFile(manipath, filePath string) (*whisk.Action, error) {
-	ext := path.Ext(filePath)
-	baseName := path.Base(filePath)
-	//check if the file if from local or from web
-	//currently only consider http
-	islocal := !strings.HasPrefix(filePath, "http")
-	name := strings.TrimSuffix(baseName, filepath.Ext(baseName))
-	action := new(whisk.Action)
-	//better refactor this
-	if islocal {
-		splitmanipath := strings.Split(manipath, string(os.PathSeparator))
-		filePath = strings.TrimRight(manipath, splitmanipath[len(splitmanipath)-1]) + filePath
-	}
-	// process source code files
-	if ext == ".swift" || ext == ".js" || ext == ".py" {
-
-		kind := "nodejs:default"
-
-		switch ext {
-		case ".swift":
-			kind = "swift:default"
-		case ".js":
-			kind = "nodejs:default"
-		case ".py":
-			kind = "python"
-		}
-		if islocal {
-			dat, err := new(ContentReader).LocalReader.ReadLocal(filePath)
-			Check(err)
-			action.Exec = new(whisk.Exec)
-			action.Exec.Code = string(dat)
-		}
-		dat, err := new(ContentReader).URLReader.ReadUrl(filePath)
-		Check(err)
-		action.Exec = new(whisk.Exec)
-		action.Exec.Code = string(dat)
-		action.Exec.Kind = kind
-		action.Name = name
-		action.Publish = false
-		return action, nil
-	}
-	// If the action is not supported, we better to return an error.
-	return nil, errors.New("Unsupported action type.")
-}
-
-func GetBoolFromString(value string) (bool, error) {
-	if strings.EqualFold(value, "true") || strings.EqualFold(value, "t") || strings.EqualFold(value, "yes") || strings.EqualFold(value, "y") {
-		return true, nil
-	} else if strings.EqualFold(value, "false") || strings.EqualFold(value, "f") || strings.EqualFold(value, "no") || strings.EqualFold(value, "n") {
-		return false, nil
-	}
-
-	return false, fmt.Errorf("Value %s not a valid comparison for boolean", value)
-}
-
-// Load configuration will load properties from a file
-func LoadConfiguration(propPath string) ([]string, error) {
-	props, err := ReadProps(propPath)
-	Check(err)
-	Namespace := props["NAMESPACE"]
-	Apihost := props["APIHOST"]
-	Authtoken := props["AUTH"]
-	return []string{Namespace, Apihost, Authtoken}, nil
-}
