diff --git a/controller/MiNiFiController.cpp b/controller/MiNiFiController.cpp
index 77d4bdb557..f5901be31d 100644
--- a/controller/MiNiFiController.cpp
+++ b/controller/MiNiFiController.cpp
@@ -39,7 +39,6 @@
 #include "cxxopts.hpp"
 
 int main(int argc, char **argv) {
-
   std::shared_ptr<logging::Logger> logger = logging::LoggerConfiguration::getConfiguration().getLogger("controller");
 
   const std::string minifiHome = determineMinifiHome(logger);
@@ -71,8 +70,7 @@ int main(int argc, char **argv) {
 
   if (nullptr == secure_context) {
     std::string secureStr;
-    bool is_secure = false;
-    if (configuration->get(minifi::Configure::nifi_remote_input_secure, secureStr) && org::apache::nifi::minifi::utils::StringUtils::StringToBool(secureStr, is_secure)) {
+    if (configuration->get(minifi::Configure::nifi_remote_input_secure, secureStr) && org::apache::nifi::minifi::utils::StringUtils::toBool(secureStr).value_or(false)) {
       secure_context = std::make_shared<minifi::controllers::SSLContextService>("ControllerSocketProtocolSSL", configuration);
       secure_context->onEnable();
     }
@@ -130,8 +128,7 @@ int main(int argc, char **argv) {
     if ((IsNullOrEmpty(host) && port == -1)) {
       std::cout << "MiNiFi Controller is disabled" << std::endl;
       exit(0);
-    } else
-
+    }
     if (result.count("noheaders")) {
       show_headers = false;
     }
@@ -161,14 +158,17 @@ int main(int argc, char **argv) {
     if (result.count("c") > 0) {
       auto& components = result["c"].as<std::vector<std::string>>();
       for (const auto& connection : components) {
-        auto socket = secure_context != nullptr ? stream_factory_->createSecureSocket(host, port, secure_context) : stream_factory_->createSocket(host, port);
+        auto socket = secure_context != nullptr ? stream_factory_->createSecureSocket(host, port, secure_context)
+                                                : stream_factory_->createSocket(host, port);
         if (clearConnection(std::move(socket), connection)) {
           std::cout << "Sent clear command to " << connection << ". Size before clear operation sent: " << std::endl;
-          socket = secure_context != nullptr ? stream_factory_->createSecureSocket(host, port, secure_context) : stream_factory_->createSocket(host, port);
+          socket = secure_context != nullptr ? stream_factory_->createSecureSocket(host, port, secure_context)
+                                             : stream_factory_->createSocket(host, port);
           if (getConnectionSize(std::move(socket), std::cout, connection) < 0)
             std::cout << "Could not connect to remote host " << host << ":" << port << std::endl;
-        } else
+        } else {
           std::cout << "Could not connect to remote host " << host << ":" << port << std::endl;
+        }
       }
     }
 
@@ -179,9 +179,7 @@ int main(int argc, char **argv) {
         if (getConnectionSize(std::move(socket), std::cout, component) < 0)
           std::cout << "Could not connect to remote host " << host << ":" << port << std::endl;
       }
-
     }
-
     if (result.count("l") > 0) {
       auto& option = result["l"].as<std::string>();
       auto socket = secure_context != nullptr ? stream_factory_->createSecureSocket(host, port, secure_context) : stream_factory_->createSocket(host, port);
@@ -192,9 +190,7 @@ int main(int argc, char **argv) {
         if (listConnections(std::move(socket), std::cout, show_headers) < 0)
           std::cout << "Could not connect to remote host " << host << ":" << port << std::endl;
       }
-
     }
-
     if (result.count("getfull") > 0) {
       auto socket = secure_context != nullptr ? stream_factory_->createSecureSocket(host, port, secure_context) : stream_factory_->createSocket(host, port);
       if (getFullConnections(std::move(socket), std::cout) < 0)
diff --git a/extensions/http-curl/processors/InvokeHTTP.cpp b/extensions/http-curl/processors/InvokeHTTP.cpp
index 42f2933f65..b83e15d260 100644
--- a/extensions/http-curl/processors/InvokeHTTP.cpp
+++ b/extensions/http-curl/processors/InvokeHTTP.cpp
@@ -220,7 +220,7 @@ void InvokeHTTP::onSchedule(const std::shared_ptr<core::ProcessContext> &context
     logger_->log_debug("%s attribute is missing, so default value of %s will be used", DateHeader.getName(), DateHeader.getValue());
   }
 
-  date_header_include_ = utils::StringUtils::StringToBool(dateHeaderStr, date_header_include_);
+  date_header_include_ = utils::StringUtils::toBool(dateHeaderStr).value_or(DateHeader.getValue());
 
   if (!context->getProperty(PropPutOutputAttributes.getName(), put_attribute_name_)) {
     logger_->log_debug("%s attribute is missing, so default value of %s will be used", PropPutOutputAttributes.getName(), PropPutOutputAttributes.getValue());
@@ -230,19 +230,19 @@ void InvokeHTTP::onSchedule(const std::shared_ptr<core::ProcessContext> &context
     logger_->log_debug("%s attribute is missing, so default value of %s will be used", AttributesToSend.getName(), AttributesToSend.getValue());
   }
 
-  std::string always_output_response = "false";
+  std::string always_output_response;
   if (!context->getProperty(AlwaysOutputResponse.getName(), always_output_response)) {
     logger_->log_debug("%s attribute is missing, so default value of %s will be used", AlwaysOutputResponse.getName(), AlwaysOutputResponse.getValue());
   }
 
-  utils::StringUtils::StringToBool(always_output_response, always_output_response_);
+  always_output_response_ = utils::StringUtils::toBool(always_output_response).value_or(false);
 
   std::string penalize_no_retry = "false";
   if (!context->getProperty(PenalizeOnNoRetry.getName(), penalize_no_retry)) {
     logger_->log_debug("%s attribute is missing, so default value of %s will be used", PenalizeOnNoRetry.getName(), PenalizeOnNoRetry.getValue());
   }
 
-  utils::StringUtils::StringToBool(penalize_no_retry, penalize_no_retry_);
+  penalize_no_retry_ = utils::StringUtils::toBool(penalize_no_retry).value_or(false);
 
   std::string context_name;
   if (context->getProperty(SSLContext.getName(), context_name) && !IsNullOrEmpty(context_name)) {
@@ -257,12 +257,10 @@ void InvokeHTTP::onSchedule(const std::shared_ptr<core::ProcessContext> &context
     logger_->log_debug("%s attribute is missing, so default value of %s will be used", UseChunkedEncoding.getName(), UseChunkedEncoding.getValue());
   }
 
-  utils::StringUtils::StringToBool(useChunkedEncoding, use_chunked_encoding_);
+  use_chunked_encoding_ = utils::StringUtils::toBool(useChunkedEncoding).value_or(false);
 
-  std::string disablePeerVerification = "false";
-  if (context->getProperty(DisablePeerVerification.getName(), disablePeerVerification)) {
-    utils::StringUtils::StringToBool(disablePeerVerification, disable_peer_verification_);
-  }
+  std::string disablePeerVerification;
+  disable_peer_verification_ = (context->getProperty(DisablePeerVerification.getName(), disablePeerVerification) && utils::StringUtils::toBool(disablePeerVerification).value_or(false));
 
   proxy_ = {};
   context->getProperty(ProxyHost.getName(), proxy_.host);
diff --git a/extensions/http-curl/processors/InvokeHTTP.h b/extensions/http-curl/processors/InvokeHTTP.h
index a853f803e8..778eb59c8f 100644
--- a/extensions/http-curl/processors/InvokeHTTP.h
+++ b/extensions/http-curl/processors/InvokeHTTP.h
@@ -19,10 +19,10 @@
 #ifndef __INVOKE_HTTP_H__
 #define __INVOKE_HTTP_H__
 
+#include <curl/curl.h>
 #include <memory>
 #include <string>
 
-#include <curl/curl.h>
 #include "utils/ByteArrayCallback.h"
 #include "FlowFileRecord.h"
 #include "core/Processor.h"
@@ -44,7 +44,6 @@ namespace processors {
 // InvokeHTTP Class
 class InvokeHTTP : public core::Processor {
  public:
-
   // Constructor
   /*!
    * Create a new processor
@@ -107,7 +106,6 @@ class InvokeHTTP : public core::Processor {
   }
 
  protected:
-
   /**
    * Generate a transaction ID
    * @return transaction ID string.
@@ -166,7 +164,7 @@ class InvokeHTTP : public core::Processor {
   std::shared_ptr<logging::Logger> logger_{logging::LoggerFactory<InvokeHTTP>::getLogger()};
 };
 
-REGISTER_RESOURCE(InvokeHTTP,"An HTTP client processor which can interact with a configurable HTTP Endpoint. "
+REGISTER_RESOURCE(InvokeHTTP, "An HTTP client processor which can interact with a configurable HTTP Endpoint. "
     "The destination URL and HTTP Method are configurable. FlowFile attributes are converted to HTTP headers and the "
     "FlowFile contents are included as the body of the request (if the HTTP Method is PUT, POST or PATCH).");
 
@@ -176,4 +174,4 @@ REGISTER_RESOURCE(InvokeHTTP,"An HTTP client processor which can interact with a
 } /* namespace apache */
 } /* namespace org */
 
-#endif
+#endif  // EXTENSIONS_HTTP_CURL_PROCESSORS_INVOKEHTTP_H_
diff --git a/extensions/http-curl/protocols/RESTSender.cpp b/extensions/http-curl/protocols/RESTSender.cpp
index 0f831e3305..948ffd405d 100644
--- a/extensions/http-curl/protocols/RESTSender.cpp
+++ b/extensions/http-curl/protocols/RESTSender.cpp
@@ -25,6 +25,7 @@
 #include <map>
 #include <string>
 #include <vector>
+#include <limits>
 #include "utils/file/FileUtils.h"
 #include "utils/StringUtils.h"
 #include "utils/file/FileManager.h"
@@ -55,7 +56,7 @@ void RESTSender::initialize(core::controller::ControllerServiceProvider* control
       }
     }
     configure->get("nifi.c2.rest.heartbeat.minimize.updates", "c2.rest.heartbeat.minimize.updates", update_str);
-    utils::StringUtils::StringToBool(update_str, minimize_updates_);
+    minimize_updates_ = utils::StringUtils::toBool(update_str).value_or(false);
   }
   logger_->log_debug("Submitting to %s", rest_uri_);
 }
diff --git a/extensions/http-curl/tests/unit/InvokeHTTPTests.cpp b/extensions/http-curl/tests/unit/InvokeHTTPTests.cpp
index 4fe4ab8639..7f1f119443 100644
--- a/extensions/http-curl/tests/unit/InvokeHTTPTests.cpp
+++ b/extensions/http-curl/tests/unit/InvokeHTTPTests.cpp
@@ -37,7 +37,6 @@
 #include "core/ProcessSession.h"
 #include "core/ProcessorNode.h"
 #include "processors/InvokeHTTP.h"
-#include "processors/ListenHTTP.h"
 #include "processors/LogAttribute.h"
 #include "utils/gsl.h"
 
diff --git a/extensions/mqtt/processors/AbstractMQTTProcessor.cpp b/extensions/mqtt/processors/AbstractMQTTProcessor.cpp
index aef1ba7aaa..a8ef81009e 100644
--- a/extensions/mqtt/processors/AbstractMQTTProcessor.cpp
+++ b/extensions/mqtt/processors/AbstractMQTTProcessor.cpp
@@ -22,6 +22,7 @@
 #include <memory>
 #include <string>
 #include <cinttypes>
+#include <set>
 
 #include "utils/TimeUtil.h"
 #include "utils/StringUtils.h"
@@ -84,11 +85,17 @@ void AbstractMQTTProcessor::onSchedule(const std::shared_ptr<core::ProcessContex
     passWord_ = value;
     logger_->log_debug("AbstractMQTTProcessor: PassWord [%s]", passWord_);
   }
-  value = "";
-  if (context->getProperty(CleanSession.getName(), value) && !value.empty() &&
-      org::apache::nifi::minifi::utils::StringUtils::StringToBool(value, cleanSession_)) {
+
+  const auto cleanSession_parsed = [&] () -> utils::optional<bool> {
+    std::string property_value;
+    if (!context->getProperty(CleanSession.getName(), property_value)) return utils::nullopt;
+    return utils::StringUtils::toBool(property_value);
+  }();
+  if ( cleanSession_parsed ) {
+    cleanSession_ = *cleanSession_parsed;
     logger_->log_debug("AbstractMQTTProcessor: CleanSession [%d]", cleanSession_);
   }
+
   value = "";
   if (context->getProperty(KeepLiveInterval.getName(), value) && !value.empty()) {
     core::TimeUnit unit;
@@ -146,7 +153,7 @@ void AbstractMQTTProcessor::onSchedule(const std::shared_ptr<core::ProcessContex
     MQTTClient_create(&client_, uri_.c_str(), clientID_.c_str(), MQTTCLIENT_PERSISTENCE_NONE, NULL);
   }
   if (client_) {
-    MQTTClient_setCallbacks(client_, (void *) this, connectionLost, msgReceived, msgDelivered);
+    MQTTClient_setCallbacks(client_, this, connectionLost, msgReceived, msgDelivered);
     // call reconnect to bootstrap
     this->reconnect();
   }
@@ -174,7 +181,7 @@ bool AbstractMQTTProcessor::reconnect() {
   }
   if (isSubscriber_) {
     ret = MQTTClient_subscribe(client_, topic_.c_str(), qos_);
-    if(ret != MQTTCLIENT_SUCCESS) {
+    if (ret != MQTTCLIENT_SUCCESS) {
       logger_->log_error("Failed to subscribe to MQTT topic %s (%d)", topic_, ret);
       return false;
     }
diff --git a/extensions/mqtt/processors/PublishMQTT.cpp b/extensions/mqtt/processors/PublishMQTT.cpp
index d1c2415859..351cd5fcf4 100644
--- a/extensions/mqtt/processors/PublishMQTT.cpp
+++ b/extensions/mqtt/processors/PublishMQTT.cpp
@@ -63,8 +63,14 @@ void PublishMQTT::onSchedule(const std::shared_ptr<core::ProcessContext> &contex
     max_seg_size_ = valInt;
     logger_->log_debug("PublishMQTT: max flow segment size [%" PRIu64 "]", max_seg_size_);
   }
-  value = "";
-  if (context->getProperty(Retain.getName(), value) && !value.empty() && org::apache::nifi::minifi::utils::StringUtils::StringToBool(value, retain_)) {
+
+  const auto retain_parsed = [&] () -> utils::optional<bool> {
+    std::string property_value;
+    if (!context->getProperty(CleanSession.getName(), property_value)) return utils::nullopt;
+    return utils::StringUtils::toBool(property_value);
+  }();
+  if ( retain_parsed ) {
+    retain_ = *retain_parsed;
     logger_->log_debug("PublishMQTT: Retain [%d]", retain_);
   }
 }
@@ -75,7 +81,6 @@ void PublishMQTT::onTrigger(const std::shared_ptr<core::ProcessContext>& /*conte
     yield();
     return;
   }
-  
   std::shared_ptr<core::FlowFile> flowFile = session->get();
 
   if (!flowFile) {
diff --git a/extensions/opc/src/putopc.cpp b/extensions/opc/src/putopc.cpp
index 1f3fe633a4..ef1be63508 100644
--- a/extensions/opc/src/putopc.cpp
+++ b/extensions/opc/src/putopc.cpp
@@ -96,7 +96,7 @@ namespace processors {
   void PutOPCProcessor::initialize() {
     PutOPCProcessor::ValueType.clearAllowedValues();
     core::PropertyValue pv;
-    for(const auto& kv : opc::StringToOPCDataTypeMap) {
+    for (const auto& kv : opc::StringToOPCDataTypeMap) {
       pv = kv.first;
       PutOPCProcessor::ValueType.addAllowedValue(pv);
     }
@@ -132,7 +132,7 @@ namespace processors {
       throw Exception(PROCESS_SCHEDULE_EXCEPTION, error_msg);
     }
 
-    if(idType_ == opc::OPCNodeIDType::Int) {
+    if (idType_ == opc::OPCNodeIDType::Int) {
       try {
         std::stoi(nodeID_);
       } catch(...) {
@@ -140,8 +140,8 @@ namespace processors {
         throw Exception(PROCESS_SCHEDULE_EXCEPTION, error_msg);
       }
     }
-    if(idType_ != opc::OPCNodeIDType::Path) {
-      if(!context->getProperty(ParentNameSpaceIndex.getName(), nameSpaceIdx_)) {
+    if (idType_ != opc::OPCNodeIDType::Path) {
+      if (!context->getProperty(ParentNameSpaceIndex.getName(), nameSpaceIdx_)) {
         auto error_msg = utils::StringUtils::join_pack(ParentNameSpaceIndex.getName(), " is mandatory in case ", ParentNodeIDType.getName(), " is not Path");
         throw Exception(PROCESS_SCHEDULE_EXCEPTION, error_msg);
       }
@@ -150,7 +150,6 @@ namespace processors {
     std::string typestr;
     context->getProperty(ValueType.getName(), typestr);
     nodeDataType_ = opc::StringToOPCDataTypeMap.at(typestr);  // This throws, but allowed values are generated based on this map -> that's a really unexpected error
-
   }
 
   void PutOPCProcessor::onTrigger(const std::shared_ptr<core::ProcessContext> &context, const std::shared_ptr<core::ProcessSession> &session) {
@@ -301,9 +300,9 @@ namespace processors {
             break;
           }
           case opc::OPCNodeDataType::Boolean: {
-            bool value;
-            if (utils::StringUtils::StringToBool(contentstr, value)) {
-              sc = connection_->update_node(targetnode, value);
+            utils::optional<bool> contentstr_parsed = utils::StringUtils::toBool(contentstr);
+            if (contentstr_parsed) {
+              sc = connection_->update_node(targetnode, contentstr_parsed.value());
             } else {
               throw opc::OPCException(GENERAL_EXCEPTION, "Content cannot be converted to bool");
             }
@@ -378,9 +377,9 @@ namespace processors {
             break;
           }
           case opc::OPCNodeDataType::Boolean: {
-            bool value;
-            if (utils::StringUtils::StringToBool(contentstr, value)) {
-              sc = connection_->add_node(parentNodeID_, targetnode, browsename, value, nodeDataType_, &resultnode);
+            utils::optional<bool> contentstr_parsed = utils::StringUtils::toBool(contentstr);
+            if (contentstr_parsed) {
+              sc = connection_->add_node(parentNodeID_, targetnode, browsename, contentstr_parsed.value(), nodeDataType_, &resultnode);
             } else {
               throw opc::OPCException(GENERAL_EXCEPTION, "Content cannot be converted to bool");
             }
diff --git a/extensions/openwsman/processors/SourceInitiatedSubscriptionListener.cpp b/extensions/openwsman/processors/SourceInitiatedSubscriptionListener.cpp
index e25567af69..39a1eff4a7 100644
--- a/extensions/openwsman/processors/SourceInitiatedSubscriptionListener.cpp
+++ b/extensions/openwsman/processors/SourceInitiatedSubscriptionListener.cpp
@@ -17,6 +17,7 @@
  */
 
 #include "SourceInitiatedSubscriptionListener.h"
+#include <openssl/x509.h>
 
 #include <memory>
 #include <algorithm>
@@ -31,8 +32,8 @@
 #include <string>
 #include <utility>
 #include <vector>
+#include <tuple>
 
-#include <openssl/x509.h>
 extern "C" {
 #include "wsman-api.h"
 #include "wsman-xml-api.h"
@@ -784,7 +785,6 @@ void SourceInitiatedSubscriptionListener::initialize() {
 void SourceInitiatedSubscriptionListener::onSchedule(const std::shared_ptr<core::ProcessContext> &context, const std::shared_ptr<core::ProcessSessionFactory> &sessionFactory) {
   std::string ssl_certificate_file;
   std::string ssl_ca_file;
-  bool verify_peer = true;
 
   state_manager_ = context->getStateManager();
   if (state_manager_ == nullptr) {
@@ -794,87 +794,86 @@ void SourceInitiatedSubscriptionListener::onSchedule(const std::shared_ptr<core:
   std::string value;
   context->getProperty(ListenHostname.getName(), listen_hostname_);
   if (!context->getProperty(ListenPort.getName(), value)) {
-    throw Exception(PROCESSOR_EXCEPTION,"Listen Port attribute is missing or invalid");
+    throw Exception(PROCESSOR_EXCEPTION, "Listen Port attribute is missing or invalid");
   } else {
     core::Property::StringToInt(value, listen_port_);
   }
   context->getProperty(SubscriptionManagerPath.getName(), subscription_manager_path_);
   context->getProperty(SubscriptionsBasePath.getName(), subscriptions_base_path_);
   if (!context->getProperty(SSLCertificate.getName(), ssl_certificate_file)) {
-    throw Exception(PROCESSOR_EXCEPTION,"SSL Certificate attribute is missing");
+    throw Exception(PROCESSOR_EXCEPTION, "SSL Certificate attribute is missing");
   }
   if (!context->getProperty(SSLCertificateAuthority.getName(), ssl_ca_file)) {
-    throw Exception(PROCESSOR_EXCEPTION,"SSL Certificate Authority attribute is missing");
+    throw Exception(PROCESSOR_EXCEPTION, "SSL Certificate Authority attribute is missing");
   }
   if (!context->getProperty(SSLVerifyPeer.getName(), value)) {
-    throw Exception(PROCESSOR_EXCEPTION,"SSL Verify Peer attribute is missing or invalid");
-  } else {
-    utils::StringUtils::StringToBool(value, verify_peer);
+    throw Exception(PROCESSOR_EXCEPTION, "SSL Verify Peer attribute is missing");
   }
+  bool verify_peer = utils::StringUtils::toBool(value).value_or(true);
   context->getProperty(XPathXmlQuery.getName(), xpath_xml_query_);
   if (!context->getProperty(InitialExistingEventsStrategy.getName(), initial_existing_events_strategy_)) {
-    throw Exception(PROCESSOR_EXCEPTION,"Initial Existing Events Strategy attribute is missing or invalid");
+    throw Exception(PROCESSOR_EXCEPTION, "Initial Existing Events Strategy attribute is missing or invalid");
   }
   if (!context->getProperty(SubscriptionExpirationInterval.getName(), value)) {
-    throw Exception(PROCESSOR_EXCEPTION,"Subscription Expiration Interval attribute is missing or invalid");
+    throw Exception(PROCESSOR_EXCEPTION, "Subscription Expiration Interval attribute is missing or invalid");
   } else {
     core::TimeUnit unit;
     if (!core::Property::StringToTime(value, subscription_expiration_interval_, unit) ||
         !core::Property::ConvertTimeUnitToMS(subscription_expiration_interval_, unit, subscription_expiration_interval_)) {
-      throw Exception(PROCESSOR_EXCEPTION,"Subscription Expiration Interval attribute is invalid");
+      throw Exception(PROCESSOR_EXCEPTION, "Subscription Expiration Interval attribute is invalid");
     }
   }
   if (!context->getProperty(HeartbeatInterval.getName(), value)) {
-    throw Exception(PROCESSOR_EXCEPTION,"Heartbeat Interval attribute is missing or invalid");
+    throw Exception(PROCESSOR_EXCEPTION, "Heartbeat Interval attribute is missing or invalid");
   } else {
     core::TimeUnit unit;
     if (!core::Property::StringToTime(value, heartbeat_interval_, unit) || !core::Property::ConvertTimeUnitToMS(heartbeat_interval_, unit, heartbeat_interval_)) {
-      throw Exception(PROCESSOR_EXCEPTION,"Heartbeat Interval attribute is invalid");
+      throw Exception(PROCESSOR_EXCEPTION, "Heartbeat Interval attribute is invalid");
     }
   }
   if (!context->getProperty(MaxElements.getName(), value)) {
-    throw Exception(PROCESSOR_EXCEPTION,"Max Elements attribute is missing or invalid");
+    throw Exception(PROCESSOR_EXCEPTION, "Max Elements attribute is missing or invalid");
   } else if (!core::Property::StringToInt(value, max_elements_)) {
-    throw Exception(PROCESSOR_EXCEPTION,"Max Elements attribute is invalid");
+    throw Exception(PROCESSOR_EXCEPTION, "Max Elements attribute is invalid");
   }
   if (!context->getProperty(MaxLatency.getName(), value)) {
-    throw Exception(PROCESSOR_EXCEPTION,"Max Latency attribute is missing or invalid");
+    throw Exception(PROCESSOR_EXCEPTION, "Max Latency attribute is missing or invalid");
   } else {
     core::TimeUnit unit;
     if (!core::Property::StringToTime(value, max_latency_, unit) || !core::Property::ConvertTimeUnitToMS(max_latency_, unit, max_latency_)) {
-      throw Exception(PROCESSOR_EXCEPTION,"Max Latency attribute is invalid");
+      throw Exception(PROCESSOR_EXCEPTION, "Max Latency attribute is invalid");
     }
   }
   if (!context->getProperty(ConnectionRetryInterval.getName(), value)) {
-    throw Exception(PROCESSOR_EXCEPTION,"Connection Retry Interval attribute is missing or invalid");
+    throw Exception(PROCESSOR_EXCEPTION, "Connection Retry Interval attribute is missing or invalid");
   } else {
     core::TimeUnit unit;
     if (!core::Property::StringToTime(value, connection_retry_interval_, unit) || !core::Property::ConvertTimeUnitToMS(connection_retry_interval_, unit, connection_retry_interval_)) {
-      throw Exception(PROCESSOR_EXCEPTION,"Connection Retry Interval attribute is invalid");
+      throw Exception(PROCESSOR_EXCEPTION, "Connection Retry Interval attribute is invalid");
     }
   }
   if (!context->getProperty(ConnectionRetryCount.getName(), value)) {
-    throw Exception(PROCESSOR_EXCEPTION,"Connection Retry Count attribute is missing or invalid");
+    throw Exception(PROCESSOR_EXCEPTION, "Connection Retry Count attribute is missing or invalid");
   } else if (!core::Property::StringToInt(value, connection_retry_count_)) {
-    throw Exception(PROCESSOR_EXCEPTION,"Connection Retry Count attribute is invalid");
+    throw Exception(PROCESSOR_EXCEPTION, "Connection Retry Count attribute is invalid");
   }
 
   FILE* fp = fopen(ssl_ca_file.c_str(), "rb");
   if (fp == nullptr) {
-    throw Exception(PROCESSOR_EXCEPTION,"Failed to open file specified by SSL Certificate Authority attribute");
+    throw Exception(PROCESSOR_EXCEPTION, "Failed to open file specified by SSL Certificate Authority attribute");
   }
   X509* ca = nullptr;
   PEM_read_X509(fp, &ca, nullptr, nullptr);
   fclose(fp);
   if (ca == nullptr) {
-    throw Exception(PROCESSOR_EXCEPTION,"Failed to parse file specified by SSL Certificate Authority attribute");
+    throw Exception(PROCESSOR_EXCEPTION, "Failed to parse file specified by SSL Certificate Authority attribute");
   }
   utils::tls::X509_unique_ptr ca_ptr{ca};
 
   std::array<uint8_t, 20U> hash_buf;
   int ret = X509_digest(ca, EVP_sha1(), hash_buf.data(), nullptr);
   if (ret != 1) {
-    throw Exception(PROCESSOR_EXCEPTION,"Failed to get fingerprint for CA specified by SSL Certificate Authority attribute");
+    throw Exception(PROCESSOR_EXCEPTION, "Failed to get fingerprint for CA specified by SSL Certificate Authority attribute");
   }
   ssl_ca_cert_thumbprint_ = utils::StringUtils::to_hex(hash_buf.data(), hash_buf.size(), true /*uppercase*/);
   logger_->log_debug("%s SHA-1 thumbprint is %s", ssl_ca_file.c_str(), ssl_ca_cert_thumbprint_.c_str());
@@ -906,7 +905,7 @@ void SourceInitiatedSubscriptionListener::onSchedule(const std::shared_ptr<core:
   } catch (const std::exception& e) {
     throw Exception(PROCESSOR_EXCEPTION, std::string("Failed to initialize server, error: ") + e.what());
   } catch (...) {
-    throw Exception(PROCESSOR_EXCEPTION,"Failed to initialize server");
+    throw Exception(PROCESSOR_EXCEPTION, "Failed to initialize server");
   }
   handler_ = std::unique_ptr<Handler>(new Handler(*this));
   server_->addHandler("**", *handler_);
diff --git a/extensions/pcap/CapturePacket.cpp b/extensions/pcap/CapturePacket.cpp
index ed6c8c90e2..8ab435bf79 100644
--- a/extensions/pcap/CapturePacket.cpp
+++ b/extensions/pcap/CapturePacket.cpp
@@ -70,19 +70,17 @@ std::string CapturePacket::generate_new_pcap(const std::string &base_path) {
 
 void CapturePacket::packet_callback(pcpp::RawPacket* packet, pcpp::PcapLiveDevice* /*dev*/, void* data) {
   // parse the packet
-  PacketMovers* capture_mechanism = (PacketMovers*) data;
+  PacketMovers* capture_mechanism = reinterpret_cast<PacketMovers*>(data);
 
   CapturePacketMechanism *capture;
 
   if (capture_mechanism->source.try_dequeue(capture)) {
-
     // if needed - write the packet to the output pcap file
 
     if (capture->writer_ != nullptr) {
       capture->writer_->writePacket(*packet);
 
       if (capture->incrementAndCheck()) {
-
         capture->writer_->close();
 
         auto new_capture = create_new_capture(capture->getBasePath(), capture->getMaxSize());
@@ -93,7 +91,6 @@ void CapturePacket::packet_callback(pcpp::RawPacket* packet, pcpp::PcapLiveDevic
       } else {
         capture_mechanism->source.enqueue(capture);
       }
-
     }
   }
 }
@@ -138,7 +135,7 @@ void CapturePacket::onSchedule(const std::shared_ptr<core::ProcessContext> &cont
 
   value = "";
   if (context->getProperty(CaptureBluetooth.getName(), value)) {
-    utils::StringUtils::StringToBool(value, capture_bluetooth_);
+    capture_bluetooth_ = utils::StringUtils::toBool(value).value_or(false);
   }
 
   core::Property attached_controllers("Network Controllers", "List of network controllers to attach to -- each may be a regex", ".*");
@@ -226,8 +223,7 @@ void CapturePacket::onTrigger(const std::shared_ptr<core::ProcessContext> &conte
   }
 }
 
-}
-/* namespace processors */
+} /* namespace processors */
 } /* namespace minifi */
 } /* namespace nifi */
 } /* namespace apache */
diff --git a/extensions/sftp/processors/FetchSFTP.cpp b/extensions/sftp/processors/FetchSFTP.cpp
index ea6729eb03..e50e1f1503 100644
--- a/extensions/sftp/processors/FetchSFTP.cpp
+++ b/extensions/sftp/processors/FetchSFTP.cpp
@@ -132,17 +132,17 @@ void FetchSFTP::onSchedule(const std::shared_ptr<core::ProcessContext> &context,
   if (!context->getProperty(CreateDirectory.getName(), value)) {
     logger_->log_error("Create Directory attribute is missing or invalid");
   } else {
-    utils::StringUtils::StringToBool(value, create_directory_);
+    create_directory_ = utils::StringUtils::toBool(value).value_or(false);
   }
   if (!context->getProperty(DisableDirectoryListing.getName(), value)) {
     logger_->log_error("Disable Directory Listing attribute is missing or invalid");
   } else {
-    utils::StringUtils::StringToBool(value, disable_directory_listing_);
+    disable_directory_listing_ = utils::StringUtils::toBool(value).value_or(false);
   }
   if (!context->getProperty(UseCompression.getName(), value)) {
     logger_->log_error("Use Compression attribute is missing or invalid");
   } else {
-    utils::StringUtils::StringToBool(value, use_compression_);
+    use_compression_ = utils::StringUtils::toBool(value).value_or(false);
   }
 
   startKeepaliveThreadIfNeeded();
diff --git a/extensions/sftp/processors/ListSFTP.cpp b/extensions/sftp/processors/ListSFTP.cpp
index c144ea62e7..858d8e394b 100644
--- a/extensions/sftp/processors/ListSFTP.cpp
+++ b/extensions/sftp/processors/ListSFTP.cpp
@@ -32,6 +32,8 @@
 #include <string>
 #include <utility>
 #include <vector>
+#include <tuple>
+#include <deque>
 
 #include "utils/ByteArrayCallback.h"
 #include "utils/TimeUtil.h"
@@ -210,12 +212,12 @@ void ListSFTP::onSchedule(const std::shared_ptr<core::ProcessContext> &context,
   if (!context->getProperty(SearchRecursively.getName(), value)) {
     logger_->log_error("Search Recursively attribute is missing or invalid");
   } else {
-    utils::StringUtils::StringToBool(value, search_recursively_);
+    search_recursively_ = utils::StringUtils::toBool(value).value_or(false);
   }
   if (!context->getProperty(FollowSymlink.getName(), value)) {
     logger_->log_error("Follow symlink attribute is missing or invalid");
   } else {
-    utils::StringUtils::StringToBool(value, follow_symlink_);
+    follow_symlink_ = utils::StringUtils::toBool(value).value_or(false);
   }
   if (context->getProperty(FileFilterRegex.getName(), file_filter_regex_)) {
     try {
@@ -242,7 +244,7 @@ void ListSFTP::onSchedule(const std::shared_ptr<core::ProcessContext> &context,
   if (!context->getProperty(IgnoreDottedFiles.getName(), value)) {
     logger_->log_error("Ignore Dotted Files attribute is missing or invalid");
   } else {
-    utils::StringUtils::StringToBool(value, ignore_dotted_files_);
+    ignore_dotted_files_ = utils::StringUtils::toBool(value).value_or(true);
   }
   context->getProperty(TargetSystemTimestampPrecision.getName(), target_system_timestamp_precision_);
   context->getProperty(EntityTrackingInitialListingTarget.getName(), entity_tracking_initial_listing_target_);
@@ -319,7 +321,7 @@ bool ListSFTP::filter(const std::string& parent_path, const std::tuple<std::stri
     return false;
   }
   if (!(attrs.flags & LIBSSH2_SFTP_ATTR_PERMISSIONS)) {
-    // TODO: maybe do a fallback stat here
+    // TODO(Bakai): maybe do a fallback stat here
     logger_->log_error("Failed to get permissions in stat for \"%s/%s\"", parent_path.c_str(), filename.c_str());
     return false;
   }
@@ -337,7 +339,7 @@ bool ListSFTP::filterFile(const std::string& parent_path, const std::string& fil
   if (!(attrs.flags & LIBSSH2_SFTP_ATTR_UIDGID) ||
       !(attrs.flags & LIBSSH2_SFTP_ATTR_SIZE) ||
       !(attrs.flags & LIBSSH2_SFTP_ATTR_ACMODTIME)) {
-    // TODO: maybe do a fallback stat here
+    // TODO(Bakai): maybe do a fallback stat here
     logger_->log_error("Failed to get all attributes in stat for \"%s/%s\"", parent_path.c_str(), filename.c_str());
     return false;
   }
diff --git a/extensions/sftp/processors/PutSFTP.cpp b/extensions/sftp/processors/PutSFTP.cpp
index 1fdc1b4507..47436cbfbf 100644
--- a/extensions/sftp/processors/PutSFTP.cpp
+++ b/extensions/sftp/processors/PutSFTP.cpp
@@ -175,7 +175,7 @@ void PutSFTP::onSchedule(const std::shared_ptr<core::ProcessContext> &context, c
   if (!context->getProperty(CreateDirectory.getName(), value)) {
     logger_->log_error("Create Directory attribute is missing or invalid");
   } else {
-    utils::StringUtils::StringToBool(value, create_directory_);
+    create_directory_ = utils::StringUtils::toBool(value).value_or(false);
   }
   if (!context->getProperty(BatchSize.getName(), value)) {
     logger_->log_error("Batch Size attribute is missing or invalid");
@@ -184,15 +184,15 @@ void PutSFTP::onSchedule(const std::shared_ptr<core::ProcessContext> &context, c
   }
   context->getProperty(ConflictResolution.getName(), conflict_resolution_);
   if (context->getProperty(RejectZeroByte.getName(), value)) {
-    utils::StringUtils::StringToBool(value, reject_zero_byte_);
+    reject_zero_byte_ = utils::StringUtils::toBool(value).value_or(true);
   }
   if (context->getProperty(DotRename.getName(), value)) {
-    utils::StringUtils::StringToBool(value, dot_rename_);
+    dot_rename_ = utils::StringUtils::toBool(value).value_or(true);
   }
   if (!context->getProperty(UseCompression.getName(), value)) {
     logger_->log_error("Use Compression attribute is missing or invalid");
   } else {
-    utils::StringUtils::StringToBool(value, use_compression_);
+    use_compression_ = utils::StringUtils::toBool(value).value_or(false);
   }
 
   startKeepaliveThreadIfNeeded();
@@ -259,9 +259,9 @@ bool PutSFTP::processOne(const std::shared_ptr<core::ProcessContext> &context, c
     remote_path = ".";
   }
   if (context->getDynamicProperty(DisableDirectoryListing.getName(), value)) {
-    utils::StringUtils::StringToBool(value, disable_directory_listing);
+    disable_directory_listing = utils::StringUtils::toBool(value).value_or(false);
   } else if (context->getProperty(DisableDirectoryListing.getName(), value)) {
-    utils::StringUtils::StringToBool(value, disable_directory_listing);
+    disable_directory_listing = utils::StringUtils::toBool(value).value_or(false);
   }
   context->getProperty(TempFilename, temp_file_name, flow_file);
   if (context->getProperty(LastModifiedTime, value, flow_file)) {
diff --git a/extensions/sftp/processors/SFTPProcessorBase.cpp b/extensions/sftp/processors/SFTPProcessorBase.cpp
index a35ffd50a3..d650865b2e 100644
--- a/extensions/sftp/processors/SFTPProcessorBase.cpp
+++ b/extensions/sftp/processors/SFTPProcessorBase.cpp
@@ -158,7 +158,7 @@ void SFTPProcessorBase::parseCommonPropertiesOnSchedule(const std::shared_ptr<co
   if (!context->getProperty(StrictHostKeyChecking.getName(), value)) {
     logger_->log_error("Strict Host Key Checking attribute is missing or invalid");
   } else {
-    utils::StringUtils::StringToBool(value, strict_host_checking_);
+    strict_host_checking_ = utils::StringUtils::toBool(value).value_or(false);
   }
   context->getProperty(HostKeyFile.getName(), host_key_file_);
   if (!context->getProperty(ConnectionTimeout.getName(), value)) {
@@ -180,7 +180,7 @@ void SFTPProcessorBase::parseCommonPropertiesOnSchedule(const std::shared_ptr<co
   if (!context->getProperty(SendKeepaliveOnTimeout.getName(), value)) {
     logger_->log_error("Send Keep Alive On Timeout attribute is missing or invalid");
   } else {
-    utils::StringUtils::StringToBool(value, use_keepalive_on_timeout_);
+    use_keepalive_on_timeout_ = utils::StringUtils::toBool(value).value_or(true);
   }
   context->getProperty(ProxyType.getName(), proxy_type_);
 }
diff --git a/extensions/standard-processors/processors/ExecuteProcess.cpp b/extensions/standard-processors/processors/ExecuteProcess.cpp
index 1dac5c6bc4..9350920973 100644
--- a/extensions/standard-processors/processors/ExecuteProcess.cpp
+++ b/extensions/standard-processors/processors/ExecuteProcess.cpp
@@ -99,7 +99,7 @@ void ExecuteProcess::onTrigger(core::ProcessContext *context, core::ProcessSessi
     }
   }
   if (context->getProperty(RedirectErrorStream.getName(), value)) {
-    org::apache::nifi::minifi::utils::StringUtils::StringToBool(value, _redirectErrorStream);
+    _redirectErrorStream =  org::apache::nifi::minifi::utils::StringUtils::toBool(value).value_or(false);
   }
   this->_fullCommand = _command + " " + _commandArgument;
   if (_fullCommand.length() == 0) {
diff --git a/extensions/standard-processors/processors/GetFile.cpp b/extensions/standard-processors/processors/GetFile.cpp
index 41d43e00cc..f3989e213f 100644
--- a/extensions/standard-processors/processors/GetFile.cpp
+++ b/extensions/standard-processors/processors/GetFile.cpp
@@ -123,10 +123,10 @@ void GetFile::onSchedule(core::ProcessContext *context, core::ProcessSessionFact
     core::Property::StringToInt(value, request_.batchSize);
   }
   if (context->getProperty(IgnoreHiddenFile.getName(), value)) {
-    org::apache::nifi::minifi::utils::StringUtils::StringToBool(value, request_.ignoreHiddenFile);
+    request_.ignoreHiddenFile = org::apache::nifi::minifi::utils::StringUtils::toBool(value).value_or(true);
   }
   if (context->getProperty(KeepSourceFile.getName(), value)) {
-    org::apache::nifi::minifi::utils::StringUtils::StringToBool(value, request_.keepSourceFile);
+    request_.keepSourceFile = org::apache::nifi::minifi::utils::StringUtils::toBool(value).value_or(false);
   }
 
   context->getProperty(MaxAge.getName(), request_.maxAge);
@@ -142,7 +142,7 @@ void GetFile::onSchedule(core::ProcessContext *context, core::ProcessSessionFact
   context->getProperty(PollInterval.getName(), request_.pollInterval);
 
   if (context->getProperty(Recurse.getName(), value)) {
-    org::apache::nifi::minifi::utils::StringUtils::StringToBool(value, request_.recursive);
+    request_.recursive = org::apache::nifi::minifi::utils::StringUtils::toBool(value).value_or(true);
   }
 
   if (context->getProperty(FileFilter.getName(), value)) {
diff --git a/extensions/standard-processors/processors/GetTCP.cpp b/extensions/standard-processors/processors/GetTCP.cpp
index e55967f37b..749d515bab 100644
--- a/extensions/standard-processors/processors/GetTCP.cpp
+++ b/extensions/standard-processors/processors/GetTCP.cpp
@@ -119,7 +119,6 @@ void GetTCP::initialize() {
 
 void GetTCP::onSchedule(const std::shared_ptr<core::ProcessContext> &context, const std::shared_ptr<core::ProcessSessionFactory> &sessionFactory) {
   std::string value;
-  stay_connected_ = true;
   if (context->getProperty(EndpointList.getName(), value)) {
     endpoints = utils::StringUtils::split(value, ",");
   }
@@ -129,11 +128,11 @@ void GetTCP::onSchedule(const std::shared_ptr<core::ProcessContext> &context, co
     concurrent_handlers_ = handlers;
   }
 
+  stay_connected_ = true;
   if (context->getProperty(StayConnected.getName(), value)) {
-    utils::StringUtils::StringToBool(value, stay_connected_);
-  } else {
-    stay_connected_ = true;
+    stay_connected_ = utils::StringUtils::toBool(value).value_or(true);
   }
+
   int connects = 0;
   if (context->getProperty(ConnectionAttemptLimit.getName(), connects)) {
     connection_attempt_limit_ = connects;
diff --git a/extensions/standard-processors/processors/HashContent.cpp b/extensions/standard-processors/processors/HashContent.cpp
index 3f123213ae..d74f888cb6 100644
--- a/extensions/standard-processors/processors/HashContent.cpp
+++ b/extensions/standard-processors/processors/HashContent.cpp
@@ -48,6 +48,7 @@ void HashContent::initialize() {
   std::set<core::Property> properties;
   properties.insert(HashAttribute);
   properties.insert(HashAlgorithm);
+  properties.insert(FailOnEmpty);
   setSupportedProperties(properties);
   //! Set the supported relationships
   std::set<core::Relationship> relationships;
@@ -62,9 +63,8 @@ void HashContent::onSchedule(core::ProcessContext *context, core::ProcessSession
   attrKey_ = (context->getProperty(HashAttribute.getName(), value)) ? value : "Checksum";
   algoName_ = (context->getProperty(HashAlgorithm.getName(), value)) ? value : "SHA256";
 
-  if (context->getProperty(HashAlgorithm.getName(), value)) {
-    bool bool_value;
-    failOnEmpty_ = utils::StringUtils::StringToBool(value, bool_value) && bool_value;  // Only true in case of valid true string
+  if (context->getProperty(FailOnEmpty.getName(), value)) {
+    failOnEmpty_ = utils::StringUtils::toBool(value).value_or(false);
   } else {
     failOnEmpty_ = false;
   }
@@ -84,6 +84,7 @@ void HashContent::onTrigger(core::ProcessContext *, core::ProcessSession *sessio
   }
 
   if (failOnEmpty_ && flowFile->getSize() == 0) {
+    logger_->log_debug("Failure as flow file is empty");
     session->transfer(flowFile, Failure);
   }
 
diff --git a/extensions/standard-processors/processors/ListenSyslog.cpp b/extensions/standard-processors/processors/ListenSyslog.cpp
index ed512d004b..23abb24f4a 100644
--- a/extensions/standard-processors/processors/ListenSyslog.cpp
+++ b/extensions/standard-processors/processors/ListenSyslog.cpp
@@ -269,7 +269,7 @@ void ListenSyslog::onTrigger(core::ProcessContext *context, core::ProcessSession
     _messageDelimiter = value;
   }
   if (context->getProperty(ParseMessages.getName(), value)) {
-    org::apache::nifi::minifi::utils::StringUtils::StringToBool(value, _parseMessages);
+    _parseMessages = org::apache::nifi::minifi::utils::StringUtils::toBool(value).value_or(false);
   }
   if (context->getProperty(Port.getName(), value)) {
     int64_t oldPort = _port;
diff --git a/extensions/standard-processors/processors/PutFile.cpp b/extensions/standard-processors/processors/PutFile.cpp
index 3765856c18..33e223c9b5 100644
--- a/extensions/standard-processors/processors/PutFile.cpp
+++ b/extensions/standard-processors/processors/PutFile.cpp
@@ -95,7 +95,7 @@ void PutFile::onSchedule(core::ProcessContext *context, core::ProcessSessionFact
 
   std::string value;
   context->getProperty(CreateDirs.getName(), value);
-  utils::StringUtils::StringToBool(value, try_mkdirs_);
+  try_mkdirs_ = utils::StringUtils::toBool(value).value_or(true);
 
   if (context->getProperty(MaxDestFiles.getName(), value)) {
     core::Property::StringToInt(value, max_dest_files_);
diff --git a/extensions/standard-processors/tests/unit/GetFileTests.cpp b/extensions/standard-processors/tests/unit/GetFileTests.cpp
index b6ce5ae4c0..a7fe54510e 100644
--- a/extensions/standard-processors/tests/unit/GetFileTests.cpp
+++ b/extensions/standard-processors/tests/unit/GetFileTests.cpp
@@ -21,6 +21,7 @@
 #include <fstream>
 
 #include "TestBase.h"
+#include "TestUtils.h"
 #include "LogAttribute.h"
 #include "GetFile.h"
 #include "utils/file/FileUtils.h"
@@ -100,3 +101,35 @@ TEST_CASE("GetFile: Directory", "[getFileDir]") {
   auto get_file = plan->addProcessor("GetFile", "Get");
   REQUIRE_THROWS_AS(plan->runNextProcessor(), minifi::Exception&);
 }
+
+TEST_CASE("GetFileHiddenPropertyCheck", "[getFileProperty]") {
+  TestController testController;
+  LogTestController::getInstance().setTrace<TestPlan>();
+  LogTestController::getInstance().setTrace<processors::GetFile>();
+  LogTestController::getInstance().setTrace<processors::LogAttribute>();
+  auto plan = testController.createPlan();
+
+  auto temp_path = minifi::utils::createTempDir(&testController);
+  std::string in_file(temp_path + utils::file::FileUtils::get_separator() + "testfifo");
+  std::string hidden_in_file(temp_path + utils::file::FileUtils::get_separator() + ".testfifo");
+
+  auto get_file = plan->addProcessor("GetFile", "Get");
+  plan->setProperty(get_file, processors::GetFile::IgnoreHiddenFile.getName(), "false");
+
+  plan->setProperty(get_file, processors::GetFile::Directory.getName(), temp_path);
+  auto log_attr = plan->addProcessor("LogAttribute", "Log", core::Relationship("success", "description"), true);
+  plan->setProperty(log_attr, processors::LogAttribute::FlowFilesToLog.getName(), "0");
+
+  std::ofstream in_file_stream(in_file);
+  in_file_stream << "This file is not hidden" << std::endl;
+  in_file_stream.close();
+
+  std::ofstream hidden_in_file_stream(hidden_in_file);
+  hidden_in_file_stream << "This file is hidden" << std::endl;
+  hidden_in_file_stream.close();
+
+  plan->runNextProcessor();
+  plan->runNextProcessor();
+
+  REQUIRE(LogTestController::getInstance().contains("Logged 2 flow files"));
+}
diff --git a/extensions/standard-processors/tests/unit/HashContentTest.cpp b/extensions/standard-processors/tests/unit/HashContentTest.cpp
index 2504cb6c8b..cd677ea619 100644
--- a/extensions/standard-processors/tests/unit/HashContentTest.cpp
+++ b/extensions/standard-processors/tests/unit/HashContentTest.cpp
@@ -27,6 +27,7 @@
 #include <iostream>
 
 #include "TestBase.h"
+#include "TestUtils.h"
 #include "core/Core.h"
 
 #include "core/FlowFile.h"
@@ -131,4 +132,34 @@ TEST_CASE("Test usage of ExtractText", "[extracttextTest]") {
   REQUIRE(LogTestController::getInstance().contains(log_check));
 }
 
+TEST_CASE("TestingFailOnEmptyProperty", "[HashContentPropertiesCheck]") {
+  TestController testController;
+  LogTestController::getInstance().setTrace<org::apache::nifi::minifi::processors::LogAttribute>();
+  LogTestController::getInstance().setTrace<org::apache::nifi::minifi::processors::GetFile>();
+  LogTestController::getInstance().setTrace<core::ProcessSession>();
+  LogTestController::getInstance().setTrace<org::apache::nifi::minifi::processors::HashContent>();
+  std::shared_ptr<TestPlan> plan = testController.createPlan();
+
+  auto tempdir = minifi::utils::createTempDir(&testController);
+  std::shared_ptr<core::Processor> getfile = plan->addProcessor("GetFile", "getfileCreate2");
+  plan->setProperty(getfile, org::apache::nifi::minifi::processors::GetFile::Directory.getName(), tempdir);
+  plan->setProperty(getfile, org::apache::nifi::minifi::processors::GetFile::KeepSourceFile.getName(), "true");
+
+  std::shared_ptr<core::Processor> md5processor = plan->addProcessor("HashContent", "HashContentMD5",
+                                                                     core::Relationship("success", "description"), true);
+  plan->setProperty(md5processor, org::apache::nifi::minifi::processors::HashContent::HashAttribute.getName(), MD5_ATTR);
+  plan->setProperty(md5processor, org::apache::nifi::minifi::processors::HashContent::HashAlgorithm.getName(), "MD5");
+  plan->setProperty(md5processor, org::apache::nifi::minifi::processors::HashContent::FailOnEmpty.getName(), "true");
+
+  std::stringstream stream_dir;
+  stream_dir << tempdir << utils::file::FileUtils::get_separator() << TEST_FILE;
+  std::string test_file_path = stream_dir.str();
+  std::ofstream test_file(test_file_path, std::ios::binary);
+
+  plan->runNextProcessor();
+  plan->runNextProcessor();
+
+  REQUIRE(LogTestController::getInstance().contains("Failure as flow file is empty"));
+}
+
 #endif  // OPENSSL_SUPPORT
diff --git a/extensions/standard-processors/tests/unit/PutFileTests.cpp b/extensions/standard-processors/tests/unit/PutFileTests.cpp
index 2d422e2bfb..acd3386a14 100644
--- a/extensions/standard-processors/tests/unit/PutFileTests.cpp
+++ b/extensions/standard-processors/tests/unit/PutFileTests.cpp
@@ -28,6 +28,7 @@
 
 #include "utils/file/FileUtils.h"
 #include "TestBase.h"
+#include "TestUtils.h"
 #include "processors/LogAttribute.h"
 #include "processors/GetFile.h"
 #include "processors/PutFile.h"
@@ -39,6 +40,7 @@
 #include "core/ProcessSession.h"
 #include "core/ProcessorNode.h"
 #include "core/reporting/SiteToSiteProvenanceReportingTask.h"
+#include "Exception.h"
 
 TEST_CASE("Test Creation of PutFile", "[getfileCreate]") {
   TestController testController;
@@ -467,4 +469,91 @@ TEST_CASE("TestPutFilePermissions", "[PutFilePermissions]") {
   REQUIRE(utils::file::FileUtils::get_permissions(putfiledir, perms));
   REQUIRE(perms == 0777);
 }
+
+TEST_CASE("PutFileCreateDirectoryTest", "[PutFileProperties]") {
+  TestController testController;
+  LogTestController::getInstance().setDebug<minifi::processors::GetFile>();
+  LogTestController::getInstance().setDebug<TestPlan>();
+  LogTestController::getInstance().setDebug<minifi::processors::PutFile>();
+  LogTestController::getInstance().setDebug<minifi::processors::PutFile::ReadCallback>();
+  LogTestController::getInstance().setDebug<minifi::processors::LogAttribute>();
+
+  std::shared_ptr<TestPlan> plan = testController.createPlan();
+  std::shared_ptr<core::Processor> getfile = plan->addProcessor("GetFile", "getfileCreate2");
+  std::shared_ptr<core::Processor> putfile = plan->addProcessor("PutFile", "putfile", core::Relationship("success", "description"), true);
+  plan->addProcessor("LogAttribute", "logattribute", core::Relationship("success", "description"), true);
+
+  // Define Directory
+  auto dir = minifi::utils::createTempDir(&testController);
+  // Defining a sub directory
+  auto putfiledir = minifi::utils::createTempDir(&testController) + utils::file::FileUtils::get_separator() + "test_dir";
+
+  plan->setProperty(putfile, org::apache::nifi::minifi::processors::PutFile::Directory.getName(), putfiledir);
+  plan->setProperty(getfile, org::apache::nifi::minifi::processors::GetFile::Directory.getName(), dir);
+
+  SECTION("with an empty file and create directory property set to true") {
+    plan->setProperty(putfile, org::apache::nifi::minifi::processors::PutFile::CreateDirs.getName(), "true");
+
+    std::ofstream of(std::string(dir) + utils::file::FileUtils::get_separator() + "tstFile.ext");
+    of.close();
+    auto path = std::string(putfiledir) + utils::file::FileUtils::get_separator() + "tstFile.ext";
+
+    plan->runNextProcessor();
+    plan->runNextProcessor();
+
+    REQUIRE(org::apache::nifi::minifi::utils::file::exists(putfiledir));
+    REQUIRE(org::apache::nifi::minifi::utils::file::exists(path));
+  }
+
+  SECTION("with an empty file and create directory property set to false") {
+    plan->setProperty(putfile, org::apache::nifi::minifi::processors::PutFile::CreateDirs.getName(), "false");
+    putfile->setAutoTerminatedRelationships({core::Relationship("failure", "description")});
+
+    std::ofstream of(std::string(dir) + utils::file::FileUtils::get_separator() + "tstFile.ext");
+    of.close();
+    auto path = std::string(putfiledir) + utils::file::FileUtils::get_separator() + "tstFile.ext";
+
+    plan->runNextProcessor();
+    plan->runNextProcessor();
+
+    REQUIRE_FALSE(org::apache::nifi::minifi::utils::file::exists(putfiledir));
+    REQUIRE_FALSE(org::apache::nifi::minifi::utils::file::exists(path));
+    std::string check = "Failed to create empty file: " + path;
+    REQUIRE(LogTestController::getInstance().contains(check));
+  }
+
+  SECTION("with a non-empty file and create directory property set to true") {
+    plan->setProperty(putfile, org::apache::nifi::minifi::processors::PutFile::CreateDirs.getName(), "true");
+
+    std::ofstream of(std::string(dir) + utils::file::FileUtils::get_separator() + "tstFile.ext");
+    of << "tempFile";
+    of.close();
+    auto path = std::string(putfiledir) + utils::file::FileUtils::get_separator() + "tstFile.ext";
+
+    plan->runNextProcessor();
+    plan->runNextProcessor();
+
+    REQUIRE(org::apache::nifi::minifi::utils::file::exists(putfiledir));
+    REQUIRE(org::apache::nifi::minifi::utils::file::exists(path));
+  }
+
+  SECTION("with a non-empty file and create directory property set to false") {
+    plan->setProperty(putfile, org::apache::nifi::minifi::processors::PutFile::CreateDirs.getName(), "false");
+    putfile->setAutoTerminatedRelationships({core::Relationship("failure", "description")});
+
+    std::ofstream of(std::string(dir) + utils::file::FileUtils::get_separator() + "tstFile.ext");
+    of << "tempFile";
+    of.close();
+    auto path = std::string(putfiledir) + utils::file::FileUtils::get_separator() + "tstFile.ext";
+
+    plan->runNextProcessor();
+    plan->runNextProcessor();
+
+    REQUIRE_FALSE(org::apache::nifi::minifi::utils::file::exists(putfiledir));
+    REQUIRE_FALSE(org::apache::nifi::minifi::utils::file::exists(path));
+    std::string check = "PutFile commit put file operation to " + path + " failed because write failed";
+    REQUIRE(LogTestController::getInstance().contains(check));
+  }
+}
+
 #endif
diff --git a/libminifi/include/utils/StringUtils.h b/libminifi/include/utils/StringUtils.h
index cd23e4f6f3..44a4f2d869 100644
--- a/libminifi/include/utils/StringUtils.h
+++ b/libminifi/include/utils/StringUtils.h
@@ -75,13 +75,10 @@ struct string_traits<wchar_t>{
 class StringUtils {
  public:
   /**
-   * Converts a string to a boolean
-   * Better handles mixed case.
+   * Checks and converts a string to a boolean
    * @param input input string
-   * @param output output string.
+   * @returns an optional of a boolean: true if the string is "true" (ignoring case), false if it is "false" (ignoring case), nullopt for any other value
    */
-  static bool StringToBool(std::string input, bool &output);
-
   static utils::optional<bool> toBool(const std::string& input);
 
   static std::string toLower(std::string str);
diff --git a/libminifi/src/RemoteProcessorGroupPort.cpp b/libminifi/src/RemoteProcessorGroupPort.cpp
index 532af55190..c4155ecb9a 100644
--- a/libminifi/src/RemoteProcessorGroupPort.cpp
+++ b/libminifi/src/RemoteProcessorGroupPort.cpp
@@ -143,7 +143,8 @@ void RemoteProcessorGroupPort::onSchedule(const std::shared_ptr<core::ProcessCon
 
   std::string http_enabled_str;
   if (configure_->get(Configure::nifi_remote_input_http, http_enabled_str)) {
-    if (utils::StringUtils::StringToBool(http_enabled_str, http_enabled_)) {
+    http_enabled_ = utils::StringUtils::toBool(http_enabled_str).value_or(false);
+    if (http_enabled_) {
       if (client_type_ == sitetosite::CLIENT_TYPE::RAW) {
         logger_->log_trace("Remote Input HTTP Enabled, but raw has been suggested for %s", protocol_uuid_.to_string());
       }
@@ -159,9 +160,7 @@ void RemoteProcessorGroupPort::onSchedule(const std::shared_ptr<core::ProcessCon
     ssl_service = std::static_pointer_cast<minifi::controllers::SSLContextService>(service);
   } else {
     std::string secureStr;
-    bool is_secure = false;
-    if (configure_->get(Configure::nifi_remote_input_secure, secureStr) &&
-        org::apache::nifi::minifi::utils::StringUtils::StringToBool(secureStr, is_secure)) {
+    if (configure_->get(Configure::nifi_remote_input_secure, secureStr) && utils::StringUtils::toBool(secureStr).value_or(false)) {
       ssl_service = std::make_shared<minifi::controllers::SSLContextService>(RPG_SSL_CONTEXT_SERVICE_NAME, configure_);
       ssl_service->onEnable();
     }
diff --git a/libminifi/src/c2/C2Agent.cpp b/libminifi/src/c2/C2Agent.cpp
index 8d962b5030..11472f3d42 100644
--- a/libminifi/src/c2/C2Agent.cpp
+++ b/libminifi/src/c2/C2Agent.cpp
@@ -186,7 +186,8 @@ void C2Agent::configure(const std::shared_ptr<Configure> &configure, bool reconf
   }
 
   std::string update_settings;
-  if (configure->get("nifi.c2.agent.update.allow", "c2.agent.update.allow", update_settings) && utils::StringUtils::StringToBool(update_settings, allow_updates_)) {
+  if (configure->get("nifi.c2.agent.update.allow", "c2.agent.update.allow", update_settings)) {
+     allow_updates_ = utils::StringUtils::toBool(update_settings).value_or(true);
     // allow the agent to be updated. we then need to get an update command to execute after
   }
 
diff --git a/libminifi/src/c2/ControllerSocketProtocol.cpp b/libminifi/src/c2/ControllerSocketProtocol.cpp
index 83223029c0..c3b5f35b47 100644
--- a/libminifi/src/c2/ControllerSocketProtocol.cpp
+++ b/libminifi/src/c2/ControllerSocketProtocol.cpp
@@ -39,8 +39,6 @@ void ControllerSocketProtocol::initialize(core::controller::ControllerServicePro
   stream_factory_ = minifi::io::StreamFactory::getInstance(configuration);
 
   std::string host = "localhost", port, limitStr, context_name;
-  bool anyInterface = false;
-
   std::shared_ptr<minifi::controllers::SSLContextService> secure_context = nullptr;
 
   if (configuration_->get("controller.ssl.context.service", context_name)) {
@@ -51,18 +49,13 @@ void ControllerSocketProtocol::initialize(core::controller::ControllerServicePro
   }
   if (nullptr == secure_context) {
     std::string secureStr;
-    bool is_secure = false;
-    if (configuration->get(Configure::nifi_remote_input_secure, secureStr) && org::apache::nifi::minifi::utils::StringUtils::StringToBool(secureStr, is_secure)) {
+    if (configuration->get(Configure::nifi_remote_input_secure, secureStr) && org::apache::nifi::minifi::utils::StringUtils::toBool(secureStr).value_or(false)) {
       secure_context = std::make_shared<minifi::controllers::SSLContextService>("ControllerSocketProtocolSSL", configuration);
       secure_context->onEnable();
     }
   }
 
-  std::string value;
-
-  if (configuration_->get("controller.socket.local.any.interface", limitStr)) {
-    utils::StringUtils::StringToBool(limitStr, anyInterface);
-  }
+  const bool anyInterface = configuration_->get("controller.socket.local.any.interface", limitStr) && utils::StringUtils::toBool(limitStr).value_or(false);
 
   // if host name isn't defined we will use localhost
   configuration_->get("controller.socket.host", host);
@@ -249,8 +242,7 @@ void ControllerSocketProtocol::parse_content(const std::vector<C2ContentResponse
   for (const auto &payload_content : content) {
     if (payload_content.name == "Components") {
       for (auto content : payload_content.operation_arguments) {
-        bool is_enabled = false;
-        minifi::utils::StringUtils::StringToBool(content.second.to_string(), is_enabled);
+        bool is_enabled = minifi::utils::StringUtils::toBool(content.second.to_string()).value_or(false);
         std::lock_guard<std::mutex> lock(controller_mutex_);
         component_map_[content.first] = is_enabled;
       }
diff --git a/libminifi/src/controllers/UpdatePolicyControllerService.cpp b/libminifi/src/controllers/UpdatePolicyControllerService.cpp
index 751ad25fa6..2a89f960fd 100644
--- a/libminifi/src/controllers/UpdatePolicyControllerService.cpp
+++ b/libminifi/src/controllers/UpdatePolicyControllerService.cpp
@@ -80,11 +80,11 @@ void UpdatePolicyControllerService::onEnable() {
 
   bool enable_all = false;
   if (getProperty(AllowAllProperties.getName(), enableStr)) {
-    enable_all = utils::StringUtils::StringToBool(enableStr, enable_all);
+    enable_all = utils::StringUtils::toBool(enableStr).value_or(false);
   }
 
   if (getProperty(PersistUpdates.getName(), persistStr)) {
-    persist_updates_ = utils::StringUtils::StringToBool(persistStr, persist_updates_);
+    persist_updates_ = utils::StringUtils::toBool(persistStr).value_or(false);
   }
 
   auto builder = state::UpdatePolicyBuilder::newBuilder(enable_all);
diff --git a/libminifi/src/controllers/keyvalue/AbstractAutoPersistingKeyValueStoreService.cpp b/libminifi/src/controllers/keyvalue/AbstractAutoPersistingKeyValueStoreService.cpp
index 8b907dc9ea..04fc61390c 100644
--- a/libminifi/src/controllers/keyvalue/AbstractAutoPersistingKeyValueStoreService.cpp
+++ b/libminifi/src/controllers/keyvalue/AbstractAutoPersistingKeyValueStoreService.cpp
@@ -74,7 +74,7 @@ void AbstractAutoPersistingKeyValueStoreService::onEnable() {
   if (!getProperty(AlwaysPersist.getName(), value)) {
     logger_->log_error("Always Persist attribute is missing or invalid");
   } else {
-    utils::StringUtils::StringToBool(value, always_persist_);
+    always_persist_ = utils::StringUtils::toBool(value).value_or(false);
   }
   if (!getProperty(AutoPersistenceInterval.getName(), value)) {
     logger_->log_error("Auto Persistence Interval attribute is missing or invalid");
diff --git a/libminifi/src/core/logging/LoggerConfiguration.cpp b/libminifi/src/core/logging/LoggerConfiguration.cpp
index a0575414ab..2b895470b0 100644
--- a/libminifi/src/core/logging/LoggerConfiguration.cpp
+++ b/libminifi/src/core/logging/LoggerConfiguration.cpp
@@ -95,7 +95,7 @@ void LoggerConfiguration::initialize(const std::shared_ptr<LoggerProperties> &lo
    */
   std::string shorten_names_str;
   if (logger_properties->getString("spdlog.shorten_names", shorten_names_str)) {
-    utils::StringUtils::StringToBool(shorten_names_str, shorten_names_);
+    shorten_names_ = utils::StringUtils::toBool(shorten_names_str).value_or(false);
   }
 
   formatter_ = std::make_shared<spdlog::pattern_formatter>(spdlog_pattern);
diff --git a/libminifi/src/core/repository/VolatileContentRepository.cpp b/libminifi/src/core/repository/VolatileContentRepository.cpp
index 7ed6378993..71b4a0271d 100644
--- a/libminifi/src/core/repository/VolatileContentRepository.cpp
+++ b/libminifi/src/core/repository/VolatileContentRepository.cpp
@@ -40,13 +40,11 @@ bool VolatileContentRepository::initialize(const std::shared_ptr<Configure> &con
   VolatileRepository::initialize(configure);
 
   if (configure != nullptr) {
-    bool minimize_locking = false;
     std::string value;
     std::stringstream strstream;
     strstream << Configure::nifi_volatile_repository_options << getName() << "." << minimal_locking;
     if (configure->get(strstream.str(), value)) {
-      utils::StringUtils::StringToBool(value, minimize_locking);
-      minimize_locking_ = minimize_locking;
+      minimize_locking_ =  utils::StringUtils::toBool(value).value_or(true);
     }
   }
   if (!minimize_locking_) {
diff --git a/libminifi/src/core/yaml/YamlConfiguration.cpp b/libminifi/src/core/yaml/YamlConfiguration.cpp
index 38afd40898..d5d2e6e7d4 100644
--- a/libminifi/src/core/yaml/YamlConfiguration.cpp
+++ b/libminifi/src/core/yaml/YamlConfiguration.cpp
@@ -717,10 +717,7 @@ namespace {
   void handleExceptionOnValidatedProcessorPropertyRead(const core::Property& propertyFromProcessor, const YAML::Node& propertyValueNode,
       const std::shared_ptr<Configure>& config, const std::type_index& defaultType, std::shared_ptr<logging::Logger>& logger) {
     std::string eof;
-    bool exit_on_failure = false;
-    if (config->get(Configure::nifi_flow_configuration_file_exit_failure, eof)) {
-      utils::StringUtils::StringToBool(eof, exit_on_failure);
-    }
+    bool const exit_on_failure = (config->get(Configure::nifi_flow_configuration_file_exit_failure, eof) && utils::StringUtils::toBool(eof).value_or(false));
     logger->log_error("Invalid conversion for field %s. Value %s", propertyFromProcessor.getName(), propertyValueNode.as<std::string>());
     if (exit_on_failure) {
       // We do not exit here even if exit_on_failure is set. Maybe we should?
diff --git a/libminifi/src/core/yaml/YamlConnectionParser.cpp b/libminifi/src/core/yaml/YamlConnectionParser.cpp
index 2d2b26543d..81d53ad2c6 100644
--- a/libminifi/src/core/yaml/YamlConnectionParser.cpp
+++ b/libminifi/src/core/yaml/YamlConnectionParser.cpp
@@ -168,8 +168,7 @@ uint64_t YamlConnectionParser::getFlowFileExpirationFromYaml() const {
 bool YamlConnectionParser::getDropEmptyFromYaml() const {
   const YAML::Node drop_empty_node = connectionNode_["drop empty"];
   if (drop_empty_node) {
-    bool dropEmpty = false;
-    return utils::StringUtils::StringToBool(drop_empty_node.as<std::string>(), dropEmpty) && dropEmpty;
+    return utils::StringUtils::toBool(drop_empty_node.as<std::string>()).value_or(false);
   }
   return false;
 }
diff --git a/libminifi/src/io/StreamFactory.cpp b/libminifi/src/io/StreamFactory.cpp
index 66cd3467ca..5f589962ce 100644
--- a/libminifi/src/io/StreamFactory.cpp
+++ b/libminifi/src/io/StreamFactory.cpp
@@ -80,8 +80,7 @@ class SocketCreator : public AbstractStreamFactory {
 // std::mutex StreamFactory::context_mutex_;
 StreamFactory::StreamFactory(const std::shared_ptr<Configure> &configure) {
   std::string secureStr;
-  bool is_secure = false;
-  if (configure->get(Configure::nifi_remote_input_secure, secureStr) && org::apache::nifi::minifi::utils::StringUtils::StringToBool(secureStr, is_secure)) {
+  if (configure->get(Configure::nifi_remote_input_secure, secureStr) && org::apache::nifi::minifi::utils::StringUtils::toBool(secureStr).value_or(false)) {
 #ifdef OPENSSL_SUPPORT
     delegate_ = std::make_shared<SocketCreator<TLSSocket, TLSContext>>(configure);
 #else
diff --git a/libminifi/src/io/tls/TLSSocket.cpp b/libminifi/src/io/tls/TLSSocket.cpp
index 776fa44c32..a19e5b97e6 100644
--- a/libminifi/src/io/tls/TLSSocket.cpp
+++ b/libminifi/src/io/tls/TLSSocket.cpp
@@ -66,10 +66,9 @@ int16_t TLSContext::initialize(bool server_method) {
   }
 
   std::string clientAuthStr;
-  bool needClientCert = true;
-  if (!(configure_->get(Configure::nifi_security_need_ClientAuth, clientAuthStr) && org::apache::nifi::minifi::utils::StringUtils::StringToBool(clientAuthStr, needClientCert))) {
-    needClientCert = true;
-  }
+  bool need_client_cert = (!configure_->get(Configure::nifi_security_need_ClientAuth, clientAuthStr) ||
+       org::apache::nifi::minifi::utils::StringUtils::toBool(clientAuthStr).value_or(true));
+
   const SSL_METHOD *method;
   method = server_method ? TLSv1_2_server_method() : TLSv1_2_client_method();
   auto local_context = std::unique_ptr<SSL_CTX, decltype(&deleteContext)>(SSL_CTX_new(method), deleteContext);
@@ -79,7 +78,7 @@ int16_t TLSContext::initialize(bool server_method) {
     return error_value;
   }
 
-  if (needClientCert) {
+  if (need_client_cert) {
     std::string certificate;
     std::string privatekey;
     std::string passphrase;
diff --git a/libminifi/src/utils/StringUtils.cpp b/libminifi/src/utils/StringUtils.cpp
index d6d6efe237..80285606b2 100644
--- a/libminifi/src/utils/StringUtils.cpp
+++ b/libminifi/src/utils/StringUtils.cpp
@@ -27,12 +27,6 @@ namespace nifi {
 namespace minifi {
 namespace utils {
 
-bool StringUtils::StringToBool(std::string input, bool &output) {
-  std::transform(input.begin(), input.end(), input.begin(), ::tolower);
-  std::istringstream(input) >> std::boolalpha >> output;
-  return output;
-}
-
 utils::optional<bool> StringUtils::toBool(const std::string& str) {
   std::string trimmed = trim(str);
   if (equalsIgnoreCase(trimmed, "true")) {
diff --git a/libminifi/test/KamikazeProcessor.cpp b/libminifi/test/KamikazeProcessor.cpp
index ae1c27be00..e8081bdb4b 100644
--- a/libminifi/test/KamikazeProcessor.cpp
+++ b/libminifi/test/KamikazeProcessor.cpp
@@ -53,14 +53,12 @@ void KamikazeProcessor::initialize() {
 
 void KamikazeProcessor::onSchedule(core::ProcessContext *context, core::ProcessSessionFactory* /*sessionFactory*/) {
   std::string value;
-  bool bool_value;
-
-  _throwInOnTrigger = false;
   context->getProperty(ThrowInOnTrigger.getName(), value);
-  _throwInOnTrigger = utils::StringUtils::StringToBool(value, bool_value) && bool_value;
+  _throwInOnTrigger = utils::StringUtils::toBool(value).value_or(false);
 
   context->getProperty(ThrowInOnSchedule.getName(), value);
-  if (utils::StringUtils::StringToBool(value, bool_value) && bool_value) {
+
+  if (utils::StringUtils::toBool(value).value_or(false)) {
     throw Exception(PROCESS_SCHEDULE_EXCEPTION, OnScheduleExceptionStr);
   }
   logger_->log_error("%s", OnScheduleLogStr);
diff --git a/libminifi/test/unit/PropertyTests.cpp b/libminifi/test/unit/PropertyTests.cpp
index 38de23c1eb..67a66ba462 100644
--- a/libminifi/test/unit/PropertyTests.cpp
+++ b/libminifi/test/unit/PropertyTests.cpp
@@ -52,18 +52,6 @@ bool conversionTest(uint64_t number, core::TimeUnit unit, uint64_t check, Conver
   return returnStatus && out == check;
 }
 
-TEST_CASE("Test Boolean Conversion", "[testboolConversion]") {
-  bool b;
-  REQUIRE(true == org::apache::nifi::minifi::utils::StringUtils::StringToBool("true", b));
-  REQUIRE(true == org::apache::nifi::minifi::utils::StringUtils::StringToBool("True", b));
-  REQUIRE(true == org::apache::nifi::minifi::utils::StringUtils::StringToBool("TRue", b));
-  REQUIRE(true == org::apache::nifi::minifi::utils::StringUtils::StringToBool("tRUE", b));
-  REQUIRE(false == org::apache::nifi::minifi::utils::StringUtils::StringToBool("FALSE", b));
-  REQUIRE(false == org::apache::nifi::minifi::utils::StringUtils::StringToBool("FALLSEY", b));
-  REQUIRE(false == org::apache::nifi::minifi::utils::StringUtils::StringToBool("FaLSE", b));
-  REQUIRE(false == org::apache::nifi::minifi::utils::StringUtils::StringToBool("false", b));
-}
-
 TEST_CASE("Test Time Conversion", "[testConversion]") {
   uint64_t out;
   REQUIRE(true == conversionTest(2000000, core::TimeUnit::NANOSECOND, 2, ConversionTestTarget::MS));
