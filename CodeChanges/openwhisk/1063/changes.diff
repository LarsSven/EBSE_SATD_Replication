diff --git a/tests/src/com/google/code/tempusfugit/concurrency/ParallelRunner.java b/tests/src/com/google/code/tempusfugit/concurrency/ParallelRunner.java
deleted file mode 100644
index ee45c803d4a..00000000000
--- a/tests/src/com/google/code/tempusfugit/concurrency/ParallelRunner.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (c) 2009-2015, toby weston & tempus-fugit committers
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * Here's a quick hack to allow us to control the number of threads
- * used by tempus fugit dynamically.   This is cloned-and-owned from tempusfugit
- * since the library is not designed to allow extension.
- *
- * We have to put it in this package to fake Java out into allowing us to
- * see package-protected classes.
- */
-
-package com.google.code.tempusfugit.concurrency;
-
-import static java.util.concurrent.Executors.newFixedThreadPool;
-
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.atomic.AtomicLong;
-
-import org.junit.runners.BlockJUnit4ClassRunner;
-import org.junit.runners.model.InitializationError;
-
-import com.google.code.tempusfugit.concurrency.ConcurrentTestRunner;
-import common.WhiskProperties;
-
-public class ParallelRunner extends BlockJUnit4ClassRunner {
-
-    public ParallelRunner(Class<?> type) throws InitializationError {
-        super(type);
-        setScheduler(new ConcurrentScheduler(createExecutor(type)));
-    }
-
-    private static ExecutorService createExecutor(Class<?> type) {
-        assert WhiskProperties.concurrentTestCount >= 1;
-        System.out.println("ParallelRunner: " + WhiskProperties.concurrentTestCount + " threads.");
-        return newFixedThreadPool(WhiskProperties.concurrentTestCount, new ConcurrentTestRunnerThreadFactory());
-    }
-
-    private static class ConcurrentTestRunnerThreadFactory implements ThreadFactory {
-        private AtomicLong count = new AtomicLong();
-
-        public Thread newThread(Runnable runnable) {
-            return new Thread(runnable, ConcurrentTestRunner.class.getSimpleName() + "-Thread-" + count.getAndIncrement());
-        }
-    }
-}
diff --git a/tests/src/common/BasicLauncher.java b/tests/src/common/BasicLauncher.java
deleted file mode 100644
index 07bbb789d8a..00000000000
--- a/tests/src/common/BasicLauncher.java
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*******************************************************************************
- * Copyright (c) 2002 - 2006 IBM Corporation.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package common;
-
-import java.io.BufferedOutputStream;
-import java.io.IOException;
-import java.util.logging.Logger;
-
-/**
- * A generic process launcher.
- *
- * MODIFIED so that the cmd is stored as a single string or as an array. In case
- * arguments contains spaces, the latter must be used because the former form
- * does not undestand quoting.
- */
-public class BasicLauncher extends Launcher {
-
-    protected String[] cmds;
-
-    public BasicLauncher(boolean captureOutput, boolean captureErr, Logger logger) {
-        super(captureOutput, captureErr, logger);
-    }
-
-    public String getCmd() {
-        StringBuilder sb = new StringBuilder();
-        String sep = "";
-        for (String s : cmds) {
-            sb.append(sep);
-            sb.append(s);
-            sep = " ";
-        }
-        return sb.toString();
-    }
-
-    public void setCmd(String... newCmds) {
-        cmds = newCmds;
-    }
-
-    @Override
-    public String toString() {
-        StringBuffer result = new StringBuffer(super.toString());
-        result.append(" (cmd: ");
-        result.append(getCmd());
-        return result.toString();
-    }
-
-    /*
-     * Launch with no timeout.
-     */
-    public int launch() throws IllegalArgumentException, IOException {
-        return launch(0);
-    }
-
-    /**
-     * Launch the process and wait until it is finished. Returns the exit value
-     * of the process.  Timeout is expressed in milli-seconds and a value of 0
-     * indicates no timeout.
-     */
-    public int launch(int timeoutMilli) throws IllegalArgumentException, IOException {
-        Process p = spawnProcess(cmds);
-        Thread d1 = isCaptureErr() ? captureStdErr(p) : drainStdErr(p);
-        Thread d2 = isCaptureOutput() ? captureStdOut(p) : drainStdOut(p);
-        if (getInput() != null) {
-            final BufferedOutputStream input = new BufferedOutputStream(p.getOutputStream());
-            try {
-                input.write(getInput(), 0, getInput().length);
-                input.flush();
-                input.close();
-            } catch (IOException e) {
-                e.printStackTrace();
-                throw new IOException("error priming stdin", e);
-            }
-        }
-        try {
-            if (timeoutMilli == 0) {
-                d1.join();
-                d2.join();
-            } else {
-                d1.join(timeoutMilli);
-                d2.join(timeoutMilli);
-            }
-        } catch (InterruptedException e) {
-            throw new Error("Internal error", e);
-        }
-        if (isCaptureErr()) {
-            Drainer d = (Drainer) d1;
-            setStdErr(d.getCapture().toByteArray());
-        }
-        if (isCaptureOutput()) {
-            Drainer d = (Drainer) d2;
-            setStdOut(d.getCapture().toByteArray());
-        }
-        return p.exitValue();
-    }
-}
diff --git a/tests/src/common/Launcher.java b/tests/src/common/Launcher.java
deleted file mode 100644
index ad32f923e26..00000000000
--- a/tests/src/common/Launcher.java
+++ /dev/null
@@ -1,403 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*******************************************************************************
- * Copyright (c) 2002 - 2006 IBM Corporation.
- * All rights reserved. This program and the accompanying materials
- * are made available under the terms of the Eclipse Public License v1.0
- * which accompanies this distribution, and is available at
- * http://www.eclipse.org/legal/epl-v10.html
- *
- * Contributors:
- *     IBM Corporation - initial API and implementation
- *******************************************************************************/
-package common;
-
-import java.io.BufferedInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.PrintStream;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.logging.Logger;
-
-/**
- * Abstract base class for a process launcher
- */
-public abstract class Launcher {
-
-    // use a fairly big buffer size to avoid performance problems with the
-    // default
-    private final static int BUFFER_SIZE = 32 * 1024;
-
-    protected File workingDir = null;
-
-    protected Map<String, String> env = null;
-
-    protected byte[] stdOut = null;
-
-    protected byte[] stdErr = null;
-
-    private byte[] input = null;
-
-    /**
-     * capture the contents of stdout?
-     */
-    private final boolean captureOutput;
-
-    /**
-     * capture the contents of stderr?
-     */
-    private final boolean captureErr;
-
-    private final Logger logger;
-
-    protected Launcher(Logger logger) {
-        super();
-        this.captureOutput = false;
-        this.captureErr = false;
-        this.logger = logger;
-    }
-
-    protected Launcher(boolean captureOutput, boolean captureErr, Logger logger) {
-        super();
-        this.captureOutput = captureOutput;
-        this.captureErr = captureErr;
-        this.logger = logger;
-    }
-
-    public File getWorkingDir() {
-        return workingDir;
-    }
-
-    public void setWorkingDir(File newWorkingDir) {
-        workingDir = newWorkingDir;
-    }
-
-    public Map<String, String> getEnv() {
-        return env;
-    }
-
-    public void setEnv(Map<String, String> newEnv) {
-        env = newEnv;
-    }
-
-    @Override
-    public String toString() {
-        StringBuffer result = new StringBuffer(super.toString());
-        result.append(" (workingDir: ");
-        result.append(workingDir);
-        result.append(", env: ");
-        result.append(env);
-        result.append(')');
-        return result.toString();
-    }
-
-    /**
-     * Spawn a process to execute the given command
-     *
-     * @return an object representing the process
-     */
-    protected Process spawnProcess(String cmd) throws IllegalArgumentException, IOException {
-        if (cmd == null) {
-            throw new IllegalArgumentException("cmd cannot be null");
-        }
-        if (logger != null) {
-            logger.info("spawning process " + cmd);
-        }
-        String[] ev = getEnv() == null ? null : buildEnv(getEnv());
-        Process p = Runtime.getRuntime().exec(cmd, ev, getWorkingDir());
-        return p;
-    }
-
-    /**
-     * Spawn a process to execute the given command
-     *
-     * @return an object representing the process
-     */
-    protected Process spawnProcess(String[] cmd) throws IllegalArgumentException, IOException {
-        if (cmd == null) {
-            throw new IllegalArgumentException("cmd cannot be null");
-        }
-        if (logger != null) {
-            logger.info("spawning process " + Arrays.toString(cmd));
-        }
-        String[] ev = getEnv() == null ? null : buildEnv(getEnv());
-        Process p = Runtime.getRuntime().exec(cmd, ev, getWorkingDir());
-        return p;
-    }
-
-    private String[] buildEnv(Map<String, String> ev) {
-        String[] result = new String[ev.size()];
-        int i = 0;
-        for (Iterator<Map.Entry<String, String>> it = ev.entrySet().iterator(); it
-                .hasNext();) {
-            Map.Entry<String, String> e = it.next();
-            result[i++] = e.getKey() + "=" + e.getValue();
-        }
-        return result;
-    }
-
-    protected Thread drainStdOut(Process p) {
-        final BufferedInputStream out = new BufferedInputStream(p.getInputStream(), BUFFER_SIZE);
-        Thread result = new Drainer(p) {
-            @Override
-            void drain() throws IOException {
-                drainAndPrint(out, System.out);
-            }
-
-            @Override
-            void blockingDrain() throws IOException {
-                blockingDrainAndPrint(out, System.out);
-            }
-        };
-        result.start();
-        return result;
-    }
-
-    protected Drainer captureStdOut(Process p) {
-        final BufferedInputStream out = new BufferedInputStream(p.getInputStream(), BUFFER_SIZE);
-        final ByteArrayOutputStream b = new ByteArrayOutputStream(BUFFER_SIZE);
-        Drainer result = new Drainer(p) {
-            @Override
-            void drain() throws IOException {
-                drainAndCatch(out, b);
-            }
-
-            @Override
-            void blockingDrain() throws IOException {
-                blockingDrainAndCatch(out, b);
-            }
-        };
-        result.setCapture(b);
-        result.start();
-        return result;
-    }
-
-    protected Thread drainStdErr(Process p) {
-        final BufferedInputStream err = new BufferedInputStream(p.getErrorStream(), BUFFER_SIZE);
-        Thread result = new Drainer(p) {
-            @Override
-            void drain() throws IOException {
-                drainAndPrint(err, System.err);
-            }
-
-            @Override
-            void blockingDrain() throws IOException {
-                blockingDrainAndPrint(err, System.err);
-            }
-        };
-        result.start();
-        return result;
-    }
-
-    protected Drainer captureStdErr(Process p) {
-        final BufferedInputStream out = new BufferedInputStream(p.getErrorStream(), BUFFER_SIZE);
-        final ByteArrayOutputStream b = new ByteArrayOutputStream(BUFFER_SIZE);
-        Drainer result = new Drainer(p) {
-            @Override
-            void drain() throws IOException {
-                drainAndCatch(out, b);
-            }
-
-            @Override
-            void blockingDrain() throws IOException {
-                blockingDrainAndCatch(out, b);
-            }
-        };
-        result.setCapture(b);
-        result.start();
-        return result;
-    }
-
-    /**
-     * A thread that runs in a loop, performing the drain() action until a
-     * process terminates
-     */
-    protected abstract class Drainer extends Thread {
-
-        // how many ms to sleep before waking up to check the streams?
-        private static final int SLEEP_MS = 5;
-
-        private final Process p;
-
-        private ByteArrayOutputStream capture;
-
-        /**
-         * Drain data from the stream, but don't block.
-         */
-        abstract void drain() throws IOException;
-
-        /**
-         * Drain data from the stream until it is finished. Block if necessary.
-         */
-        abstract void blockingDrain() throws IOException;
-
-        Drainer(Process p) {
-            this.p = p;
-        }
-
-        @Override
-        public void run() {
-            try {
-                boolean repeat = true;
-                while (repeat) {
-                    try {
-                        Thread.sleep(SLEEP_MS);
-                    } catch (InterruptedException e1) {
-                        // e1.printStackTrace();
-                        // just ignore and continue
-                    }
-                    drain();
-                    try {
-                        p.exitValue();
-                        // if we get here, the process has terminated
-                        repeat = false;
-                        blockingDrain();
-                        if (logger != null) {
-                            logger.fine("process terminated with exit code "
-                                    + p.exitValue());
-                        }
-                    } catch (IllegalThreadStateException e) {
-                        // this means the process has not yet terminated.
-                        repeat = true;
-                    }
-                }
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-
-        public ByteArrayOutputStream getCapture() {
-            return capture;
-        }
-
-        public void setCapture(ByteArrayOutputStream capture) {
-            this.capture = capture;
-        }
-    }
-
-    /**
-     * Drain some data from the input stream, and print said data to p. Do not
-     * block.
-     */
-    private void drainAndPrint(BufferedInputStream s, PrintStream p) throws IOException {
-        try {
-            while (s.available() > 0) {
-                byte[] data = new byte[s.available()];
-                s.read(data);
-                p.print(new String(data));
-            }
-        } catch (IOException e) {
-            // assume the stream has been closed (e.g. the process died)
-            // so, just exit
-        }
-    }
-
-    /**
-     * Drain all data from the input stream, and print said data to p. Block if
-     * necessary.
-     */
-    private void blockingDrainAndPrint(BufferedInputStream s, PrintStream p) throws IOException {
-        ByteArrayOutputStream b = new ByteArrayOutputStream();
-        try {
-            // gather all the data from the stream.
-            int next = s.read();
-            while (next != -1) {
-                b.write(next);
-                next = s.read();
-            }
-        } catch (IOException e) {
-            // assume the stream has been closed (e.g. the process died)
-            // so, just print the data and then leave
-        }
-
-        // print the data.
-        p.print(b.toString());
-    }
-
-    /**
-     * Drain some data from the input stream, and append said data to b. Do not
-     * block.
-     */
-    private void drainAndCatch(BufferedInputStream s, ByteArrayOutputStream b)
-            throws IOException {
-        try {
-            while (s.available() > 0) {
-                byte[] data = new byte[s.available()];
-                int nRead = s.read(data);
-                b.write(data, 0, nRead);
-            }
-        } catch (IOException e) {
-            // assume the stream has been closed (e.g. the process died)
-            // so, just exit
-        }
-    }
-
-    /**
-     * Drain all data from the input stream, and append said data to p. Block if
-     * necessary.
-     */
-    private void blockingDrainAndCatch(BufferedInputStream s,
-            ByteArrayOutputStream b) throws IOException {
-        try {
-            int next = s.read();
-            while (next != -1) {
-                b.write(next);
-                next = s.read();
-            }
-        } catch (IOException e) {
-            // assume the stream has been closed (e.g. the process died)
-            // so, just exit
-        }
-    }
-
-    public boolean isCaptureOutput() {
-        return captureOutput;
-    }
-
-    public boolean isCaptureErr() {
-        return captureErr;
-    }
-
-    public byte[] getStdout() {
-        return stdOut;
-    }
-
-    public byte[] getStderr() {
-        return stdErr;
-    }
-
-    protected void setStdOut(byte[] newOutput) {
-        stdOut = newOutput;
-    }
-
-    protected void setStdErr(byte[] newErr) {
-        stdErr = newErr;
-    }
-
-    public byte[] getInput() {
-        return input;
-    }
-
-    /**
-     * Set input which will be fed to the launched process's stdin
-     */
-    public void setInput(byte[] input) {
-        this.input = input;
-    }
-}
diff --git a/tests/src/common/TestUtils.java b/tests/src/common/TestUtils.java
index 86aa11ee884..d9d5aff8558 100644
--- a/tests/src/common/TestUtils.java
+++ b/tests/src/common/TestUtils.java
@@ -18,29 +18,28 @@
 
 import static org.junit.Assert.assertTrue;
 
+import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileReader;
 import java.io.IOException;
-import java.nio.file.Files;
-import java.nio.file.FileSystems;
-import java.nio.file.Path;
-import java.nio.file.StandardCopyOption;
+import java.io.InputStream;
+import java.io.InputStreamReader;
 import java.text.SimpleDateFormat;
+import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.logging.Level;
 import java.util.logging.Logger;
-import java.util.Collections;
-import java.util.UUID;
 
-import com.google.gson.JsonObject;
-import com.google.gson.JsonArray;
-import com.google.gson.JsonParser;
-import com.google.gson.JsonElement;
 import org.junit.rules.TestWatcher;
 import org.junit.runner.Description;
 
+import com.google.gson.JsonArray;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonObject;
+import com.google.gson.JsonParser;
+
 import junit.runner.Version;
 
 /**
@@ -52,17 +51,18 @@ public class TestUtils {
     public static final int SUCCESS_EXIT = 0;
     public static final int ERROR_EXIT = 1;
     public static final int MISUSE_EXIT = 2;
-    public static final int ACCEPTED = 202;      // 202
-    public static final int BAD_REQUEST = 144;   // 400 - 256 = 144
-    public static final int UNAUTHORIZED = 145;  // 401 - 256 = 145
-    public static final int FORBIDDEN = 147;     // 403 - 256 = 147
-    public static final int NOT_FOUND = 148;     // 404 - 256 = 148
-    public static final int NOTALLOWED = 149;    // 405 - 256 = 149
-    public static final int CONFLICT = 153;      // 409 - 256 = 153
-    public static final int REQUEST_ENTITY_TOO_LARGE = 157;      // 413 - 256 = 157
-    public static final int THROTTLED = 173;     // 429 (TOO_MANY_REQUESTS) - 256 = 173
-    public static final int TIMEOUT = 246;       // 502 (GATEWAY_TIMEOUT)   - 256 = 246
-    public static final int DONTCARE_EXIT = -1;  // any value is ok
+    public static final int ACCEPTED = 202; // 202
+    public static final int BAD_REQUEST = 144; // 400 - 256 = 144
+    public static final int UNAUTHORIZED = 145; // 401 - 256 = 145
+    public static final int FORBIDDEN = 147; // 403 - 256 = 147
+    public static final int NOT_FOUND = 148; // 404 - 256 = 148
+    public static final int NOTALLOWED = 149; // 405 - 256 = 149
+    public static final int CONFLICT = 153; // 409 - 256 = 153
+    public static final int REQUEST_ENTITY_TOO_LARGE = 157; // 413 - 256 = 157
+    public static final int THROTTLED = 173; // 429 (TOO_MANY_REQUESTS) - 256 =
+                                             // 173
+    public static final int TIMEOUT = 246; // 502 (GATEWAY_TIMEOUT) - 256 = 246
+    public static final int DONTCARE_EXIT = -1; // any value is ok
     public static final int ANY_ERROR_EXIT = -2; // any non-zero value is ok
 
     private static final File catalogDir = WhiskProperties.getFileRelativeToWhiskHome("catalog");
@@ -70,7 +70,6 @@ public class TestUtils {
     private static final File vcapFile = WhiskProperties.getVCAPServicesFile();
     private static final String envServices = System.getenv("VCAP_SERVICES");
 
-
     static {
         logger.setLevel(Level.INFO);
         System.out.println("JUnit version is: " + Version.id());
@@ -79,7 +78,8 @@ public class TestUtils {
     /**
      * Gets path to file relative to catalog directory.
      *
-     * @param name relative filename
+     * @param name
+     *            relative filename
      */
     public static String getCatalogFilename(String name) {
         return new File(catalogDir, name).toString();
@@ -88,7 +88,8 @@ public static String getCatalogFilename(String name) {
     /**
      * Gets path to test action file relative to test catalog directory.
      *
-     * @param name the filename of the test action
+     * @param name
+     *            the filename of the test action
      * @return
      */
     public static String getTestActionFilename(String name) {
@@ -97,6 +98,7 @@ public static String getTestActionFilename(String name) {
 
     /**
      * Gets the value of VCAP_SERVICES
+     *
      * @return VCAP_SERVICES as a JSON object
      */
     public static JsonObject getVCAPServices() {
@@ -112,16 +114,19 @@ public static JsonObject getVCAPServices() {
         }
     }
 
-    /* Gets a VCAP_SERVICES credentials
-     * @return VCAP credentials as a <String, String> map for each <property, value> pair in credentials
+    /*
+     * Gets a VCAP_SERVICES credentials
+     *
+     * @return VCAP credentials as a <String, String> map for each <property,
+     * value> pair in credentials
      */
     public static Map<String, String> getVCAPcredentials(String vcapService) {
         try {
             JsonArray vcapArray = getVCAPServices().get(vcapService).getAsJsonArray();
             JsonObject vcapObject = vcapArray.get(0).getAsJsonObject();
             JsonObject credentials = vcapObject.get("credentials").getAsJsonObject();
-            Map<String,String> map = new HashMap<String,String>();
-            for(Map.Entry<String, JsonElement> entry : credentials.entrySet()) {
+            Map<String, String> map = new HashMap<String, String>();
+            for (Map.Entry<String, JsonElement> entry : credentials.entrySet()) {
                 map.put(entry.getKey(), credentials.get(entry.getKey()).getAsString());
             }
 
@@ -133,7 +138,8 @@ public static Map<String, String> getVCAPcredentials(String vcapService) {
     }
 
     /**
-     * @return a junit {@link TestWatcher} that prints a message when each test starts and ends
+     * @return a junit {@link TestWatcher} that prints a message when each test
+     *         starts and ends
      */
     public static TestWatcher makeTestWatcher() {
         return new TestWatcher() {
@@ -160,13 +166,17 @@ public static void setForkJoinConcurrency() {
 
     /**
      * Sets the number of concurrent tests to run based on value provided.
-     * @throws IllegalStateException if count < 1
+     *
+     * @throws IllegalStateException
+     *             if count < 1
      */
     public static void setForkJoinConcurrency(int count) {
         if (count > 0) {
             System.out.format("concurrent test threads %d\n", count);
             System.setProperty("java.util.concurrent.ForkJoinPool.common.parallelism", Integer.toString(count));
-        } else throw new IllegalStateException("test thread count must be positive");
+        } else {
+            throw new IllegalStateException("test thread count must be positive");
+        }
     }
 
     /**
@@ -188,18 +198,21 @@ public static String getTime() {
     }
 
     public static int sleep(int secs) {
-        if (secs > 0) try {
-            Thread.sleep(secs*1000);
-        } catch (InterruptedException e) {}
+        if (secs > 0)
+            try {
+                Thread.sleep(secs * 1000);
+            } catch (InterruptedException e) {
+            }
         return secs;
     }
 
     public static interface Once<T> {
         /**
-         * a method that returns a T when some condition is satisfied,
-         * and otherwise returns null.
+         * a method that returns a T when some condition is satisfied, and
+         * otherwise returns null.
          *
-         * The intention is that this will be called until satisfied once, and then no more.
+         * The intention is that this will be called until satisfied once, and
+         * then no more.
          */
         T once() throws IOException;
     }
@@ -287,47 +300,61 @@ public String toString() {
         }
     }
 
-    public static RunResult runCmd(File dir, String... params) throws IllegalArgumentException, IOException {
+    public static RunResult runCmd(File dir, String... params) throws IOException {
         return runCmd(TestUtils.DONTCARE_EXIT, dir, logger, null, params);
     }
 
-    public static Pair<String, String> runCmd(int expectedExitCode, File dir, String... params) throws IllegalArgumentException, IOException {
+    public static Pair<String, String> runCmd(int expectedExitCode, File dir, String... params) throws IOException {
         return runCmd(expectedExitCode, dir, logger, null, params).logs();
     }
 
-    public static Pair<String, String> runQuietly(int expectedExitCode, File dir, String... params) throws IllegalArgumentException, IOException {
+    public static Pair<String, String> runQuietly(int expectedExitCode, File dir, String... params) throws IOException {
         return runCmd(expectedExitCode, dir, null, null, params).logs();
     }
 
     /*
      * Run with no timeout.
      */
-    public static RunResult runCmd(int expectedExitCode, File dir, Logger logger,
-                                   Map<String, String> env, String... params) throws IllegalArgumentException, IOException {
+    public static RunResult runCmd(int expectedExitCode, File dir, Logger logger, Map<String, String> env, String... params) throws IOException {
         return runCmd(expectedExitCode, 0, dir, logger, env, params);
     }
 
     /**
      * Run a command in another process (exec())
      *
-     * @param expectedExitCode the exit code expected from the command when it exists
-     * @param timeoutMilli kill the underlying process after this amount of time (0 if no timeout)
-     * @param dir the working directory the command runs with
-     * @param logger object to manage logging message
-     * @param env TODO
-     * @param params parameters to pass on the command line to the spawnded command
+     * @param expectedExitCode
+     *            the exit code expected from the command when it exists
+     * @param timeoutMilli
+     *            kill the underlying process after this amount of time (0 if no
+     *            timeout)
+     * @param dir
+     *            the working directory the command runs with
+     * @param logger
+     *            object to manage logging message
+     * @param env
+     *            TODO
+     * @param params
+     *            parameters to pass on the command line to the spawnded command
      * @return
+     * @throws IOException
      */
-    public static RunResult runCmd(int expectedExitCode, int timeoutMilli, File dir, Logger logger,
-                                   Map<String, String> env, String... params) throws IllegalArgumentException, IOException {
+    public static RunResult runCmd(int expectedExitCode, int timeoutMilli, File dir, Logger logger, Map<String, String> env, String... params) throws IOException {
+        ProcessBuilder pb = new ProcessBuilder(params);
+        pb.directory(dir);
+        if (env != null)
+            pb.environment().putAll(env);
+        Process p = pb.start();
 
-        BasicLauncher bl = new BasicLauncher(true, true, logger);
-        bl.setCmd(params);
-        bl.setWorkingDir(dir);
-        bl.setEnv(env);
+        String stdout = inputStreamToString(p.getInputStream());
+        String stderr = inputStreamToString(p.getErrorStream());
 
-        int exitCode = bl.launch(timeoutMilli);
-        RunResult rr = new RunResult(exitCode, new String(bl.getStdout()), new String(bl.getStderr()));
+        try {
+            p.waitFor();
+        } catch (InterruptedException e) {
+            // TODO Auto-generated catch block
+            e.printStackTrace();
+        }
+        RunResult rr = new RunResult(p.exitValue(), stdout, stderr);
         if (logger != null) {
             logger.info("RunResult: " + rr);
         }
@@ -335,45 +362,14 @@ public static RunResult runCmd(int expectedExitCode, int timeoutMilli, File dir,
         return rr;
     }
 
-    /**
-     * WARNING: Consider using the WSK_CONFIG_FILE environment variable in
-     *          tests that will be manipulating the CLI property values.
-     *          Use this method only after determining WSK_CONFIG_FILE will
-     *          not work for the test case.
-     */
-    public static File backupWskProps() throws IOException {
-        String homedir = System.getProperty("user.home");
-        Path wskpropsPath = FileSystems.getDefault().getPath(homedir, ".wskprops");
-        String tempfileName =  UUID.randomUUID().toString()+".wskprops";
-        Path tempfilePath = FileSystems.getDefault().getPath(homedir, tempfileName);
-        try {
-            Files.copy(wskpropsPath, tempfilePath, StandardCopyOption.REPLACE_EXISTING );
-        }
-        catch (IOException e) {
-            throw e;
-        }
-        return tempfilePath.toFile();
-    }
-
-    /**
-     * WARNING: Consider using the WSK_CONFIG_FILE environment variable in
-     *          tests that will be manipulating the CLI property values.
-     *          Use this method only after determining WSK_CONFIG_FILE will
-     *          not work for the test case.
-     */
-    public static void restoreWskProps(File backupWskProps) throws IOException {
-        String homedir = System.getProperty("user.home");
-        Path wskpropsPath = FileSystems.getDefault().getPath(homedir, ".wskprops");
-        try {
-            Files.copy(backupWskProps.toPath(), wskpropsPath, StandardCopyOption.REPLACE_EXISTING );
-        }
-        catch (IOException e) {
-            throw e;
+    private static String inputStreamToString(InputStream in) throws IOException {
+        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
+        StringBuilder builder = new StringBuilder();
+        String line = null;
+        while ((line = reader.readLine()) != null) {
+            builder.append(line);
+            builder.append(System.getProperty("line.separator"));
         }
-    }
-
-    public static File getWskPropsFile() {
-        String homedir = System.getProperty("user.home");
-        return new File(homedir + File.separator + ".wskprops");
+        return builder.toString();
     }
 }
diff --git a/tests/src/common/Util.java b/tests/src/common/Util.java
deleted file mode 100644
index 63b199bb578..00000000000
--- a/tests/src/common/Util.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package common;
-
-import java.io.File;
-import java.io.FileOutputStream;
-import java.nio.file.Files;
-import java.text.DateFormat;
-import java.text.SimpleDateFormat;
-import java.util.Arrays;
-import java.util.Date;
-import java.util.List;
-
-import org.apache.commons.codec.binary.Base64;
-
-/**
- * Misc utility.
- */
-public class Util {
-
-    public static void sleep(double durSec) {
-        try {
-            Thread.sleep((int) (durSec * 1000));
-        } catch (InterruptedException ie) {
-            // Should we have figured out when we started and resumed sleeping
-            // for remaining amount?
-        }
-    }
-
-    // Java8 would make this unnecessary.
-    public static String join(String[] strs, String sep) {
-        StringBuilder sb = new StringBuilder();
-        String separator = "";
-        for (String s : strs) {
-            sb.append(separator);
-            sb.append(s);
-            separator = sep;
-        }
-        return sb.toString();
-    }
-
-    public static String join(List<String> strs, String sep) {
-        return join(strs.toArray(new String[strs.size()]), sep);
-    }
-
-    private static DateFormat dateFormatter = new SimpleDateFormat("HH:mm:ss");
-
-    public static synchronized String getTimeString() {
-        return dateFormatter.format(new Date());
-    }
-
-    public static <T> T[] concat(T[] first, @SuppressWarnings("unchecked") T... second) {
-        T[] result = Arrays.copyOf(first, first.length + second.length);
-        System.arraycopy(second, 0, result, first.length, second.length);
-        return result;
-    }
-
-    // Read a binary file and base64 encode the result.
-    public static byte[] readFile64(File file) {
-        return Base64.encodeBase64(readFile(file));
-    }
-
-    // Write the given base64 data as binary to file.
-    public static boolean writeFile64(File file, byte[] base64Data) {
-        return writeFile(file, Base64.decodeBase64(base64Data));
-    }
-
-    // Read a binary file
-    public static byte[] readFile(File file) {
-        try {
-            return Files.readAllBytes(file.toPath());
-        } catch (Exception e) {
-            System.out.println("Could not read file " + file + ": " + e);
-            return null;
-        }
-    }
-
-    // Write a binary file
-    public static boolean writeFile(File file, byte[] data) {
-        try {
-            FileOutputStream fos = new FileOutputStream(file);
-            fos.write(data, 0, data.length);
-            fos.flush();
-            fos.close();
-            return true;
-        } catch (Exception e) {
-            System.out.println("writeFile failed with " + e);
-            return false;
-        }
-    }
-}
diff --git a/tests/src/common/Wsk.scala b/tests/src/common/Wsk.scala
index a3073d11784..648a5e6e62d 100644
--- a/tests/src/common/Wsk.scala
+++ b/tests/src/common/Wsk.scala
@@ -150,8 +150,8 @@ trait ListOrGetFromCollection extends FullyQualifiedNames {
         summary: Boolean = false)(
             implicit wp: WskProps): RunResult = {
         val params = Seq(noun, "get", "--auth", wp.authKey) ++
-          Seq(fqn(name)) ++
-          { if (summary) Seq("--summary") else Seq() }
+            Seq(fqn(name)) ++
+            { if (summary) Seq("--summary") else Seq() }
         cli(wp.overrides ++ params, expectedExitCode)
     }
 }
@@ -368,7 +368,7 @@ class WskRule(override val usePythonCLI: Boolean = false)
         name: String,
         expectedExitCode: Int = SUCCESS_EXIT)(
             implicit wp: WskProps): RunResult = {
-        val disable = Try { disableRule(name, 30 seconds, expectedExitCode) }
+        val disable = Try { disableRule(name, expectedExitCode) }
         if (expectedExitCode != DONTCARE_EXIT)
             disable.get // throws exception
         super.delete(name, expectedExitCode)
@@ -383,13 +383,10 @@ class WskRule(override val usePythonCLI: Boolean = false)
      */
     def enableRule(
         name: String,
-        timeout: Duration,
         expectedExitCode: Int = SUCCESS_EXIT)(
             implicit wp: WskProps): RunResult = {
         val result = cli(wp.overrides ++ Seq(noun, "enable", "--auth", wp.authKey, fqn(name)), expectedExitCode)
         assert(result.stdout.contains("ok:"), result)
-        val b = waitfor(() => checkRuleState(name, active = true), totalWait = timeout)
-        assert(b)
         result
     }
 
@@ -402,13 +399,10 @@ class WskRule(override val usePythonCLI: Boolean = false)
      */
     def disableRule(
         name: String,
-        timeout: Duration,
         expectedExitCode: Int = SUCCESS_EXIT)(
             implicit wp: WskProps): RunResult = {
         val result = cli(wp.overrides ++ Seq(noun, "disable", "--auth", wp.authKey, fqn(name)), expectedExitCode)
         assert(result.stdout.contains("ok:"), result)
-        val b = waitfor(() => checkRuleState(name, active = false), totalWait = timeout)
-        assert(b)
         result
     }
 
@@ -555,13 +549,14 @@ class WskActivation(override val usePythonCLI: Boolean = false)
         entity: Option[String],
         limit: Option[Int] = None,
         since: Option[Instant] = None,
-        retries: Int = 10)(
+        retries: Int = 10,
+        pollPeriod: Duration = 1.second)(
             implicit wp: WskProps): Seq[String] = {
         Try {
             retry({
                 val result = ids(list(filter = entity, limit = limit, since = since))
                 if (result.length >= N) result else throw PartialResult(result)
-            }, retries, waitBeforeRetry = Some(1 second))
+            }, retries, waitBeforeRetry = Some(pollPeriod))
         } match {
             case Success(ids)                => ids
             case Failure(PartialResult(ids)) => ids
@@ -778,7 +773,7 @@ sealed trait RunWskCmd {
             showCmd: Boolean = false): RunResult = {
         val args = baseCommand
         if (verbose) args += "--verbose"
-        if (showCmd) println(args +" "+ params.mkString(" "))
+        if (showCmd) println(args + " " + params.mkString(" "))
         val rr = TestUtils.runCmd(DONTCARE_EXIT, workingDir, TestUtils.logger, sys.env ++ env, args ++ params: _*)
         rr.validateExitCode(expectedExitCode)
         rr
@@ -789,7 +784,7 @@ sealed trait RunWskCmd {
      * an optional a status line following by the JSON data
      */
     def parseJsonString(jsonStr: String): JsObject = {
-        jsonStr.substring(jsonStr.indexOf("\n") + 1).parseJson.asJsObject  // Skip optional status line before parsing
+        jsonStr.substring(jsonStr.indexOf("\n") + 1).parseJson.asJsObject // Skip optional status line before parsing
     }
 }
 
diff --git a/tests/src/common/WskCli.java b/tests/src/common/WskCli.java
deleted file mode 100644
index 93fed260f7d..00000000000
--- a/tests/src/common/WskCli.java
+++ /dev/null
@@ -1,1002 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package common;
-
-import static common.TestUtils.DONTCARE_EXIT;
-import static common.TestUtils.SUCCESS_EXIT;
-import static org.junit.Assert.assertTrue;
-
-import java.io.File;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParser;
-
-import common.TestUtils.RunResult;
-
-/**
- * An object that encapsulates configuration information needed to drive the
- * whisk CLI
- */
-public class WskCli {
-
-    private String cliPath;
-    private String[] baseCmd;
-
-    private final File binaryPath;
-    public String subject;
-    public final String authKey;
-
-    private Map<String, String> env = null;
-
-    public static enum Item {
-        Package("package"), Trigger("trigger"), Action("action"), Rule("rule"), Activation("activation");
-
-        private final String name; // singular form of the noun used by the CLI
-
-        private Item(String s) {
-            this.name = s;
-        }
-    }
-
-    public WskCli() {
-        this(true, WhiskProperties.getAuthFileForTesting());
-    }
-
-    public WskCli(Boolean usePythonCLI) {
-        this(usePythonCLI, WhiskProperties.getAuthFileForTesting());
-    }
-
-    public WskCli(Boolean usePythonCLI, String authKey) {
-        this(usePythonCLI, "default", authKey);
-    }
-
-    protected WskCli(Boolean usePythonCLI, File authFile) {
-        this(usePythonCLI, "default", authFile);
-    }
-
-    public WskCli(Boolean usePythonCLI, String subject, File authFile) {
-        this(usePythonCLI, subject, WhiskProperties.readAuthKey(authFile));
-    }
-
-    public WskCli(Boolean usePythonCLI, String subject, String authKey) {
-        if (usePythonCLI) {
-            cliPath = WhiskProperties.useCLIDownload() ? getDownloadedPythonCLIPath() : WhiskProperties.getPythonCLIPath();
-            baseCmd = new String[] {WhiskProperties.python, cliPath};
-        } else {
-            cliPath = WhiskProperties.useCLIDownload() ? getDownloadedGoCLIPath() : WhiskProperties.getGoCLIPath();
-            baseCmd = new String[] {cliPath};
-        }
-
-        this.subject = subject;
-        this.authKey = authKey;
-        this.binaryPath = new File(cliPath);
-    }
-
-    public void setSubject(String subject) {
-        this.subject = subject;
-    }
-
-    public String getSubject() {
-        return this.subject;
-    }
-
-    public boolean checkExists() {
-        assertTrue("did not find " + binaryPath, binaryPath.exists());
-        return true;
-    }
-
-    /** What is the path to a downloaded CLI? **/
-    private String getDownloadedPythonCLIPath() {
-        String binary = System.getProperty("user.home") + File.separator + ".local" + File.separator + "bin" + File.separator + "wsk";
-        return binary;
-    }
-
-    /** What is the path to a downloaded Go CLI? **/
-    private String getDownloadedGoCLIPath() {
-        String binary = System.getProperty("user.home") + File.separator + ".local" + File.separator + "bin" +
-                File.separator + "go-cli" + File.separator + "wsk";
-        return binary;
-    }
-
-    public String namespace() throws IOException {
-        String result = cli("namespace", "list", "--auth", authKey).stdout;
-        String[] lines = result.split("\n");
-        assert (lines.length >= 2);
-        return lines[1].trim();
-    }
-
-    public String downloadDocker(File destPath) throws IOException {
-        return cli(true, SUCCESS_EXIT, destPath, "sdk", "install", "docker").stdout;
-    }
-
-    public String pollActivations(int seconds) throws IOException {
-        return cli(SUCCESS_EXIT, "activation", "poll", "--auth", authKey, "--exit", Integer.toString(seconds)).stdout;
-    }
-
-    /**
-     * Lists all items (not just recent ones).
-     */
-    public String listAll(Item item) throws IOException {
-        return cli(SUCCESS_EXIT, item.name, "list", "--auth", authKey, "--limit", "0").stdout;
-    }
-
-    /**
-     * Lists only recent items.
-     */
-    public String list(Item item) throws IOException {
-        return list(item, null);
-    }
-
-    /**
-     * Lists only recent items.
-     */
-    public String list(Item item, String namespace) throws IOException {
-        if (item == Item.Activation) {
-            return listActivations(namespace);
-        } else {
-            String[] cmd = { item.name, "list", "--auth", authKey };
-            if (namespace != null)
-                cmd = Util.concat(cmd, new String[] { namespace });
-            return cli(SUCCESS_EXIT, cmd).stdout;
-        }
-    }
-
-    /**
-     * Lists only recent activations.
-     *
-     * @param namespace
-     *            the namespace in which to list (null indicates default
-     *            namespace)
-     * @param full
-     *            if true grab the full activation record
-     * @return CLI stdout
-     */
-    public String listActivations(String namespace) throws IOException {
-        // bump limit to return all activations
-        String[] cmd = { Item.Activation.name, "list", "--auth", authKey, "--limit", "0" };
-        if (namespace != null)
-            cmd = Util.concat(cmd, new String[] { namespace });
-        return cli(SUCCESS_EXIT, cmd).stdout;
-    }
-
-    /**
-     * Gets an {@code Item} (e.g., action) identified by its {@code item} type
-     * and and {@code name}. Asserts an error if item does not exist or if the
-     * there is an error in the CLI.
-     *
-     * @param item
-     *            the item type
-     * @param name
-     *            the name of the item
-     * @return CLI stdout
-     */
-    public String get(Item item, String name) throws IOException {
-        return get(SUCCESS_EXIT, item, name);
-    }
-
-    /**
-     * Gets an {@code Item} (e.g., action) identified by its {@code item} type
-     * and and {@code name}. Asserts an error if CLI response code does not
-     * match {@code expectedExitCode}.
-     *
-     * @param expectedExitCode
-     *            the expected CLI exit code
-     * @param item
-     *            the item type
-     * @param name
-     *            the name of the item
-     * @return CLI stdout
-     */
-    public String get(int expectedExitCode, Item item, String name) throws IOException {
-        return cli(DONTCARE_EXIT, item.name, "get", "--auth", authKey, name).stdout;
-    }
-
-    /**
-     * Deletes an {@code Item} (e.g., action) identified by its {@code item}
-     * type and and {@code name} if it exists.
-     *
-     * @param item
-     *            the item type
-     * @param name
-     *            the name of the item
-     * @return CLI stdout
-     */
-    public String sanitize(Item item, String name) throws IOException {
-        return delete(DONTCARE_EXIT, item, name);
-    }
-
-    /**
-     * Deletes an {@code Item} (e.g., action) identified by its {@code item}
-     * type and and {@code name}. Asserts an error if item does not exist or if
-     * the there is an error in the CLI.
-     *
-     * @param item
-     *            the item type
-     * @param name
-     *            the name of the item
-     * @return CLI stdout
-     */
-    public String delete(Item item, String name) throws IOException {
-        return delete(SUCCESS_EXIT, item, name);
-    }
-
-    /**
-     * Deletes an {@code Item} (e.g., action) identified by its {@code item}
-     * type and and {@code name}. Asserts an error if CLI response code does not
-     * match {@code expectedExitCode}.
-     *
-     * @param expectedExitCode
-     *            the expected CLI exit code
-     * @param item
-     *            the item type
-     * @param name
-     *            the name of the item
-     * @return CLI stdout
-     */
-    public String delete(int expectedExitCode, Item item, String name) throws IOException {
-        if (item == Item.Rule) {
-            try {
-                disableRule(expectedExitCode, name, 30);
-            } catch (Throwable t) {
-                if (expectedExitCode == DONTCARE_EXIT) {
-                } else
-                    throw t;
-            }
-        }
-        return cli(expectedExitCode, item.name, "delete", "--auth", authKey, name).stdout;
-    }
-
-    public String copyAction(String name, String existingAction) throws IOException {
-        return createAction(SUCCESS_EXIT, name, existingAction, null, null, false, false, true, false, 0);
-    }
-
-    public String createAction(String name, String file) throws IOException {
-        return createAction(name, file, null, false, false);
-    }
-
-    public String createAction(String name, String file, int timeoutMillis) throws IOException {
-        return createAction(name, file, null, false, false, timeoutMillis);
-    }
-
-    public String createAction(int expectedCode, String name, String file) throws IOException {
-        return createAction(expectedCode, name, file, null, false, false);
-    }
-
-    public String createAction(String name, String[] actions) throws IOException {
-        String csv = String.join(",", actions);
-        return createAction(SUCCESS_EXIT, name, csv, null, null, true, false, false, true, 0);
-    }
-
-    public String createAction(String name, String[] actions, int timeoutMillis) throws IOException {
-        String csv = String.join(",", actions);
-        return createAction(SUCCESS_EXIT, name, csv, null, null, true, false, false, true, timeoutMillis);
-    }
-
-    public String createAction(String name, String file, Map<String, String> params) throws IOException {
-        return createAction(name, file, params, false, false);
-    }
-
-    public String createAction(String name, String file, String library) throws IOException {
-        return createAction(SUCCESS_EXIT, name, file, library, null, false, false, false, false, 0);
-    }
-
-    public String createAction(String name, String file, String library, Map<String, String> params) throws IOException {
-        return createAction(SUCCESS_EXIT, name, file, library, params, false, false, false, false, 0);
-    }
-
-    public String createAction(String name, String file, boolean update, boolean shared) throws IOException {
-        return createAction(SUCCESS_EXIT, name, file, null, null, false, update, false, shared, 0);
-    }
-
-    public String createAction(String name, String file, Map<String, String> params, boolean update, boolean shared) throws IOException {
-        return createAction(SUCCESS_EXIT, name, file, null, params, false, update, false, shared, 0);
-    }
-
-    public String createAction(String name, String file, Map<String, String> params, boolean update, boolean shared, int timeoutMillis) throws IOException {
-        return createAction(SUCCESS_EXIT, name, file, null, params, false, update, false, shared, timeoutMillis);
-    }
-
-    public String updateAction(String name, boolean shared) throws IOException {
-        return createAction(SUCCESS_EXIT, name, null, null, null, false, true, false, shared, 0);
-    }
-
-    public String createAction(int expectedCode, String name, String file, Map<String, String> params, boolean update, boolean shared) throws IOException {
-        return createAction(expectedCode, name, file, null, params, false, update, false, shared, 0);
-
-    }
-
-    public String createAction(int expectedCode, String name, String artifact, String library, Map<String, String> params, boolean sequence, boolean update, boolean copy, boolean shared, int timeoutMillis) throws IOException {
-        String[] cmd1 = { "action", "update", "--auth", authKey, name };
-        String[] cmd2 = { "action", "create", "--auth", authKey, name, artifact };
-        String[] cmd = update ? cmd1 : cmd2;
-
-        if (update && artifact != null) {
-            cmd = Util.concat(cmd, new String[] { artifact });
-        }
-
-        if (params != null) {
-            for (String key : params.keySet()) {
-                String value = params.get(key);
-                cmd = Util.concat(cmd, new String[] { "--param", key, value });
-            }
-        }
-
-        if (timeoutMillis > 0) {
-            cmd = Util.concat(cmd, new String[] { "--timeout", Integer.toString(timeoutMillis) });
-        }
-
-        if (sequence) {
-            cmd = Util.concat(cmd, new String[] { "--sequence" });
-        }
-
-        if (library != null) {
-            cmd = Util.concat(cmd, new String[] { "--lib", library });
-        }
-
-        if (copy) {
-            cmd = Util.concat(cmd, new String[] { "--copy" });
-        }
-
-        if (shared) {
-            cmd = Util.concat(cmd, new String[] { "--shared", "yes"});
-        }
-
-        RunResult result = cli(expectedCode, cmd);
-        String stdout = result.stdout;
-        if (expectedCode == SUCCESS_EXIT && update) {
-            assertTrue(stdout, stdout.contains("ok: updated action"));
-        } else if (expectedCode == SUCCESS_EXIT) {
-            assertTrue(stdout, stdout.contains("ok: created action"));
-        }
-        return expectedCode == SUCCESS_EXIT ? stdout : stdout.concat(result.stderr);
-    }
-
-    public String updatePackage(String name, Map<String, String> params) throws IOException {
-        return createPackage(SUCCESS_EXIT, name, params, "", true, false);
-    }
-
-    public String createPackage(String name, Map<String, String> params) throws IOException {
-        return createPackage(SUCCESS_EXIT, name, params, "", false, false);
-    }
-
-    public String createPackage(int expectedCode, String name, Map<String, String> params, String copyFrom, boolean update, boolean shared) throws IOException {
-        String op = "create";
-        if (update) {
-            op = "update";
-        }
-
-        String[] cmd = { "package", op, "--auth", authKey, name };
-        if (params != null) {
-            for (String key : params.keySet()) {
-                String value = params.get(key);
-                cmd = Util.concat(cmd, new String[] { "--param", key, value });
-            }
-        }
-
-        if (copyFrom != null && copyFrom.trim().length() > 0) {
-            cmd = Util.concat(cmd, new String[] { "--copy", copyFrom });
-        }
-
-        if (shared) {
-            cmd = Util.concat(cmd, new String[] { "--shared" });
-        }
-
-        RunResult result = cli(expectedCode, cmd);
-        String stdout = result.stdout;
-        if (expectedCode == SUCCESS_EXIT && update) {
-            assertTrue(stdout, stdout.contains("ok: updated package"));
-        } else if (expectedCode == SUCCESS_EXIT) {
-            assertTrue(stdout, stdout.contains("ok: created package"));
-        }
-        return expectedCode == SUCCESS_EXIT ? stdout : stdout.concat(result.stderr);
-    }
-
-    public String bindPackage(int expectedCode, String packageName, String name, Map<String, String> params) throws IOException {
-        String[] cmd = { "package", "bind", "--auth", authKey, packageName, name };
-        if (params != null) {
-            for (String key : params.keySet()) {
-                String value = params.get(key);
-                cmd = Util.concat(cmd, new String[] { "--param", key, value });
-            }
-        }
-
-        RunResult result = cli(expectedCode, cmd);
-        String stdout = result.stdout;
-        if (expectedCode == SUCCESS_EXIT) {
-            assertTrue(stdout, stdout.contains("ok: created binding " + name));
-        }
-        return expectedCode == SUCCESS_EXIT ? stdout : stdout.concat(result.stderr);
-    }
-
-    public String refreshPackages(int expectedCode, String namespace) throws IOException {
-        String[] cmd = { "package", "refresh", "--auth", authKey, namespace };
-
-        RunResult result = cli(expectedCode, cmd);
-        String stdout = result.stdout;
-        return expectedCode == SUCCESS_EXIT ? stdout : stdout.concat(result.stderr);
-    }
-
-    public String getContainerStatisticsForItem(String actionName) {
-
-        return null;
-    }
-
-    public String createDockerAction(String name, String container, boolean update) throws IOException {
-        String[] cmd = { "action", "create", "--auth", authKey, name, "--docker", container };
-        if (update) {
-            cmd = Util.concat(cmd, new String[] { "--update" });
-        }
-
-        String result = cli(cmd).stdout;
-        assertTrue(result, result.contains("ok: created action"));
-        return result;
-    }
-
-    public void createTrigger(String name) throws IOException {
-        createTrigger(SUCCESS_EXIT, name);
-    }
-
-    public void createTrigger(int expectedCode, String name) throws IOException {
-        String result = cli(expectedCode, "trigger", "create", "--auth", authKey, name).stdout;
-        if (expectedCode == SUCCESS_EXIT) {
-            assertTrue(result, result.contains("ok: created trigger"));
-        }
-    }
-
-    public void createRule(String name, String trigger, String action) throws IOException {
-        createRule(SUCCESS_EXIT, name, trigger, action);
-    }
-
-    public void createRule(int expectedCode, String name, String trigger, String action) throws IOException {
-        String result = cli(expectedCode, "rule", "create", "--auth", authKey, name, trigger, action).stdout;
-        if (expectedCode == SUCCESS_EXIT) {
-            assertTrue(result, result.contains("ok: created rule"));
-        }
-    }
-
-    public String enableRule(String name, int timeout) throws IOException {
-        String result = cli("rule", "enable", "--auth", authKey, name).stdout;
-        assertTrue(result, result.contains("ok:"));
-        Boolean b = TestUtils.waitfor(() -> {
-            return checkRuleState(name, true);
-        } , 0, 1, timeout);
-        assert (b);
-        return result;
-    }
-
-    public String disableRule(String name, int timeout) throws IOException {
-        return disableRule(SUCCESS_EXIT, name, timeout);
-    }
-
-    public String disableRule(int expectedCode, String name, int timeout) throws IOException {
-        String result = cli(expectedCode, "rule", "disable", "--auth", authKey, name).stdout;
-        assertTrue(result, result.contains("ok:"));
-        Boolean b = TestUtils.waitfor(() -> {
-            return checkRuleState(name, false);
-        } , 0, 1, timeout);
-        assert (b);
-        return result;
-    }
-
-    private boolean checkRuleState(String name, boolean active) throws IOException {
-        String result = cli("rule", "status", "--auth", authKey, name).stdout;
-        return active ? result.contains("is active") : result.contains("is inactive");
-    }
-
-    /**
-     * Fires a trigger.
-     *
-     * @param name
-     *            the name of the trigger
-     * @param arg
-     *            the arguments to attach to the trigger
-     * @return CLI stdout
-     */
-    public String trigger(String name, String arg) throws IOException {
-        String result = cli("trigger", "fire", "--auth", authKey, name, arg).stdout;
-        assertTrue(result, result.contains("ok: triggered"));
-        return result;
-    }
-
-    /*
-     * Same as trigger but return result without checking error code.
-     */
-    public RunResult triggerNoCheck(String name, String arg) throws IOException {
-        return cli(DONTCARE_EXIT, "trigger", "fire", "--auth", authKey, name, arg);
-    }
-
-    public RunResult invokeNoCheck(String actionName, Map<String, String> params) throws IOException {
-        return invoke(DONTCARE_EXIT, actionName, params, false);
-    }
-
-    public String invoke(String name, Map<String, String> params) throws IOException {
-        String[] cmd = { "action", "invoke", "--auth", authKey, name };
-        if (params != null) {
-            for (String key : params.keySet()) {
-                String value = params.get(key);
-                cmd = Util.concat(cmd, new String[] { "--param", key, value });
-            }
-        }
-
-        int expectedCode = SUCCESS_EXIT;
-        RunResult result = cli(expectedCode, cmd);
-        String stdout = result.stdout;
-        if (expectedCode == SUCCESS_EXIT) {
-            assertTrue(stdout, stdout.contains("ok:"));
-            return extractActivationIdFromCliResult(stdout);
-        } else
-            return null;
-    }
-
-    // Returns the invocation ID and result.
-    public Pair<String, String> invokeBlocking(String name, Map<String, String> params) throws IOException {
-        String response = invoke(SUCCESS_EXIT, name, params, true).stdout;
-        String activationId = extractActivationIdFromCliResult(response);
-        String result = extractActivationResultFromCliResult(response);
-        JsonObject json = new JsonParser().parse(result).getAsJsonObject();
-        if (json == null || json.get("response") == null) {
-            return Pair.make(activationId, "invalid Json response: " + result);
-        } else {
-            return Pair.make(activationId, json.get("response").toString());
-        }
-    }
-
-    /**
-     * Invoke Item in blocking mode, ignoring the return code.
-     *
-     * @param name
-     *            name of the item to invoke
-     * @param params
-     *            the invocation arguments
-     * @return
-     * @throws IOException
-     */
-    public Pair<String, String> invokeBlockingIgnoringExitcode(String name, Map<String, String> params) throws IOException {
-        String response = invoke(TestUtils.DONTCARE_EXIT, name, params, true).stdout;
-        String activationId = extractActivationIdFromCliResult(response);
-        String result = extractActivationResultFromCliResult(response);
-        return Pair.make(activationId, result);
-    }
-
-    public String invokeBlockingIgnoringExitcodeReturnPlainResult(String name, Map<String, String> params) throws IOException {
-        return invoke(TestUtils.DONTCARE_EXIT, name, params, true).stdout;
-    }
-
-    public RunResult invoke(int expectedCode, String name, Map<String, String> params, boolean blocking) throws IOException {
-        String[] cmd = new String[] { "action", "invoke", "--auth", authKey, name };
-        for (String key : params.keySet()) {
-            String value = params.get(key);
-            cmd = Util.concat(cmd, new String[] { "--param", key, value });
-        }
-        String[] args = blocking ? Util.concat(cmd, "--blocking") : cmd;
-        return cli(expectedCode, args);
-    }
-
-    /**
-     * Get a list of the activation ids for all activations of a particular
-     * action name.
-     *
-     * @param name
-     *            name of the action.
-     * @param since
-     *            since parameter for cli. Only activations after this timestamp will be returned.
-     * @return the activation ids
-     */
-    public List<String> getActivations(String name, long since) throws IOException {
-        return getActivations(name, since, 0);
-    }
-
-    /**
-     * Get a list of the activation ids for the most recent N activations of a
-     * particular action name.
-     *
-     * @param name
-     *            name of the action.
-     * @param since
-     *            since parameter for cli. Only activations after this timestamp will be returned.
-     * @param lastN
-     *            how many activation ids to fetch
-     * @return the activation ids
-     */
-    public List<String> getActivations(String name, long since, int lastN) throws IOException {
-        String canonicalName = name;
-        String result = cli(SUCCESS_EXIT, "activation", "list", canonicalName, "--limit", "" + lastN, "--since", String.valueOf(since), "--auth", authKey).stdout;
-        String[] lines = result.split("\n");
-        List<String> activations = new ArrayList<String>();
-        for (int i = 1; i < lines.length; i++) {
-            String[] parts = lines[i].split(" ");
-            activations.add(parts[0]);
-        }
-        return activations;
-    }
-
-    /**
-     * Does there exist an activation id for a particular action which equals
-     * the expected string?
-     *
-     * @param name
-     *            the name of the action.
-     * @param expected
-     *            the expected activation id.
-     * @param since
-     *            since parameter for cli. Only activations after this timestamp will be returned.
-     * @param totalWait
-     *            wait up until this many seconds for the id to appear.
-     * @return true if found, false otherwise
-     */
-    public boolean activationsContain(String name, String expected, long since, int totalWait) throws IOException {
-        Boolean b = TestUtils.waitfor(() -> {
-            List<String> ids = getActivations(name, since, 0);
-            for (String id : ids) {
-                if (id.contains(expected))
-                    return true;
-            }
-            return false;
-        } , 0, 1, totalWait);
-        return (b != null) && b;
-    }
-
-    /**
-     * Wait for at least N activation ids for a particular action to appear.
-     *
-     * @param name
-     *            name of the action.
-     * @param expected
-     *            how many activation ids are expected?
-     * @param since
-     *            since parameter for cli. Only activations after this timestamp will be returned.
-     * @param totalWait
-     *            wait up until this many seconds for the expected ids to appear
-     */
-    public List<String> waitForActivations(String name, int expected, long since, int totalWait) throws IOException {
-        return TestUtils.waitfor(() -> {
-            List<String> activations = getActivations(name, since, 0);
-            return (activations.size() >= expected) ? activations : null;
-        } , 0, 1, totalWait);
-    }
-
-    public RunResult getResult(String activationId) throws IOException {
-        RunResult result = cli(DONTCARE_EXIT, "activation", "result", activationId, "--auth", authKey);
-        return result;
-    }
-
-    /**
-     * Fetch the logs (stdout, stderr) recorded for a particular activation
-     */
-    public RunResult getLogsForActivation(String activationId) throws IOException {
-        RunResult result = cli(DONTCARE_EXIT, "activation", "logs", activationId, "--auth", authKey);
-        return result;
-    }
-
-    /**
-     * Do the logs for a particular activation contain a certain string?
-     *
-     * @param activationId
-     *            the id of the activation
-     * @param w
-     *            the string to search for
-     * @param totalWait
-     *            wait up to the this many seconds for the string to appear
-     * @return whether log contains entry
-     * @throws IOException
-     */
-    public boolean logsForActivationContain(String activationId, String w, int totalWait) throws IOException {
-        return logsForActivationContainGet(activationId, w, totalWait) != null;
-    }
-
-    /**
-     * Do the logs for a particular activation contain a certain string? If so,
-     * return the log.
-     *
-     * @param activationId
-     *            the id of the activation
-     * @param w
-     *            the string to search for
-     * @param totalWait
-     *            wait up to the this many seconds for the string to appear
-     * @return the log if there is a match
-     * @throws IOException
-     */
-    public String logsForActivationContainGet(String activationId, String w, int totalWait) throws IOException {
-        String regex = ".*" + w + ".*";
-        return checkActivationFor(activationId, regex, 1, 1, totalWait);
-    }
-
-    /**
-     * Do the logs for a particular activation contain a certain string? If so,
-     * return the log. Else null.
-     *
-     * @param activationId
-     *            the id of the activation
-     * @param w
-     *            the string to search for
-     * @param initialWait
-     *            wait this many seconds before checking logs
-     * @param pollPeriod
-     *            poll at this interval in seconds
-     * @param totalWait
-     *            wait up to the this many seconds for the activation record to
-     *            appear
-     * @return the activation log if there is match; otherwise null
-     * @throws IOException
-     */
-    private String checkActivationFor(String activationId, String sRegex, int initialWait, int pollPeriod, int totalWait) throws IOException {
-        Pattern p = Pattern.compile(sRegex, Pattern.DOTALL);
-        String log = TestUtils.waitfor(() -> {
-            RunResult result = getLogsForActivation(activationId);
-            if (result.exitCode == SUCCESS_EXIT) {
-                return result.stdout;
-            } else
-                return null;
-        } , initialWait, pollPeriod, totalWait);
-        if (log != null) {
-            Matcher m = p.matcher(log);
-            return m.find() ? log : null;
-        } else
-            return null;
-    }
-
-    /***
-     * Do the logs for a particular action contain a certain string?
-     *
-     * @param action
-     *            name of the action.
-     * @param w
-     *            the string to search for
-     * @param since
-     *            since parameter for cli. Only activations after this timestamp will be returned.
-     * @param totalWait
-     *            wait up to the this many seconds for the string to appear
-     * @return the the first activation log if there is match; otherwise null
-     * @throws IOException
-     */
-    public String firstLogsForActionContainGet(String action, String regex, long since, int totalWait) throws IOException {
-        return matchLogsForActionContain(action, regex, since, 1, 1, totalWait);
-    }
-
-    /**
-     * Do the logs for a particular action contain a certain string? If so
-     * return the matching log. If not, return null.
-     *
-     * @param action
-     *            name of the action.
-     * @param w
-     *            the string to search for
-     * @param since
-     *            since parameter for cli. Only activations after this timestamp will be returned.
-     * @param initialWait
-     *            wait this many seconds before checking lobs
-     * @param pollPeriod
-     *            poll at this interval in seconds
-     * @param totalWait
-     *            wait up to the this many seconds for the string to appear
-     * @return
-     * @throws IOException
-     */
-    private String matchLogsForActionContain(String action, String sRegex, long since, int initialWait, int pollPeriod, int totalWait) throws IOException {
-        Pattern p = Pattern.compile(sRegex, Pattern.DOTALL);
-        String l = TestUtils.waitfor(() -> {
-            List<String> activationIds = getActivations(action, since);
-            for (String id : activationIds) {
-                RunResult result = getLogsForActivation(id);
-                if (result.exitCode == SUCCESS_EXIT) {
-                    Matcher m = p.matcher(result.stdout);
-                    if (m.find())
-                        return result.stdout;
-                }
-            }
-            return null;
-        } , initialWait, pollPeriod, totalWait);
-        return l;
-    }
-
-    public List<String> getLogsForAction(String action, long since) throws IOException {
-        List<String> result = new ArrayList<String>();
-        List<String> activationIds = getActivations(action, since);
-        for (String id : activationIds) {
-            RunResult res = getLogsForActivation(id);
-            if (res.exitCode == SUCCESS_EXIT) {
-                result.add(res.stdout);
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Do the logs for a particular action contain a certain string?
-     *
-     * @param action
-     *            name of the action.
-     * @param w
-     *            the string to search for
-     * @param since
-     *            since parameter for cli. Only activations after this timestamp will be returned.
-     * @param initialWait
-     *            wait this many seconds before checking lobs
-     * @param pollPeriod
-     *            poll at this interval in seconds
-     * @param totalWait
-     *            wait up to the this many seconds for the string to appear
-     * @return
-     * @throws IOException
-     */
-    private boolean logsForActionContain(String action, String sRegex, long since, int initialWait, int pollPeriod, int totalWait) throws IOException {
-        return matchLogsForActionContain(action, sRegex, since, initialWait, pollPeriod, totalWait) != null;
-    }
-
-    /**
-     * Do the logs for a particular action contain a certain string?
-     *
-     * @param action
-     *            name of the action.
-     * @param w
-     *            the string to search for
-     * @param since
-     *            since parameter for cli. Only activations after this timestamp will be returned.
-     * @param totalWait
-     *            wait up to the this many seconds for the string to appear
-     * @return
-     * @throws IOException
-     */
-    public boolean logsForActionContain(String action, String w, long since, int totalWait) throws IOException {
-        String regex = ".*" + w + ".*";
-        return logsForActionContain(action, regex, since, 1, 1, totalWait);
-    }
-
-    /**
-     * Does the result for a particular activation contain a certain string? If
-     * so, return the result. Else null.
-     *
-     * @param activationId
-     *            the id of the activation
-     * @param w
-     *            the string to search for
-     * @param initialWait
-     *            wait this many seconds before checking logs
-     * @param pollPeriod
-     *            poll at this interval in seconds
-     * @param totalWait
-     *            wait up to the this many seconds for the activation record to
-     *            appear
-     * @return the activation result if there is match; otherwise null
-     * @throws IOException
-     */
-    public String checkResultFor(String activationId, String sRegex, int initialWait, int pollPeriod, int totalWait) throws IOException {
-        Pattern p = Pattern.compile(sRegex, Pattern.DOTALL);
-        String log = TestUtils.waitfor(() -> {
-            RunResult result = getResult(activationId);
-            if (result.exitCode == SUCCESS_EXIT) {
-                return result.stdout;
-            } else
-                return null;
-        } , initialWait, pollPeriod, totalWait);
-        if (log != null) {
-            Matcher m = p.matcher(log);
-            return m.find() ? log : null;
-        } else
-            return null;
-    }
-
-    /**
-     * Does the result for a particular activation contain a certain string? If
-     * so, return true else false.
-     *
-     * @param activationId
-     *            the id of the activation
-     * @param w
-     *            the string to search for
-     * @param totalWait
-     *            wait up to the this many seconds for the activation record to
-     *            appear
-     * @return the activation result if there is match; otherwise null
-     * @throws IOException
-     */
-    public boolean checkResultFor(String activationId, String sRegex, int totalWait) throws IOException {
-        return checkResultFor(activationId, sRegex, 1, 1, totalWait) != null;
-    }
-
-    public static String extractActivationIdFromCliResult(String result) {
-        assertTrue(result, result.contains("ok: invoked"));
-        // a characteristic string that comes right before the activationId
-        String idPrefix = "with id ";
-        int start = result.indexOf(idPrefix) + idPrefix.length();
-        int end = start;
-        assertTrue(start > 0);
-        while (end < result.length() && result.charAt(end) != '\n')
-            end++;
-        return result.substring(start, end); // a uuid
-    }
-
-    protected static String extractActivationResultFromCliResult(String result) {
-        // a characteristic string that comes right before the result
-        String resultPrefix = "{";
-        assertTrue(result, result.contains(resultPrefix));
-        int start = result.indexOf(resultPrefix);
-        int end = result.length();
-        return result.substring(start, end); // the result
-    }
-
-    /**
-     * Run a wsk command. This will automatically add the auth key to the
-     * command.
-     */
-    public RunResult runCmd(String... params) throws IOException {
-        List<String> newParams = new ArrayList<String>();
-        newParams.addAll(Arrays.asList(params));
-        newParams.add("--auth");
-        newParams.add(authKey);
-        return cli(DONTCARE_EXIT, newParams.toArray(params));
-    }
-
-    /**
-     * Run a command wsk [params].
-     *
-     * @return <stdout,stderr>
-     * @throws IOException
-     * @throws IllegalArgumentException
-     */
-    public RunResult cli(String... params) throws IllegalArgumentException, IOException {
-        return cli(true, TestUtils.SUCCESS_EXIT, params);
-    }
-
-    /**
-     * Run a command wsk [params] where the arguments come in as an array. Use
-     * this instead of the other form with quoting.
-     *
-     * @param expectedExitCode
-     *            if DONTCARE_EXIT then exit code is ignored, else check that
-     *            exit code matches expected value
-     * @return <stdout,stderr>
-     */
-    public RunResult cli(int expectedExitCode, String... params) throws IllegalArgumentException, IOException {
-        return cli(false, expectedExitCode, params);
-    }
-
-    public RunResult cli(boolean verbose, int expectedExitCode, String... params) throws IllegalArgumentException, IOException {
-        return cli(verbose, expectedExitCode, new File("."), params);
-    }
-
-    /**
-     * Run a command wsk [params] where the arguments come in as an array. Use
-     * this instead of the other form with quoting. Allows control of verbosity.
-     *
-     * @param verbose
-     *            true to run with --verbose
-     * @param expectedExitCode
-     *            if DONTCARE_EXIT then exit code is ignored, else check that
-     *            exit code matches expected value
-     * @return RunResult which contains stdout,stderr, exit code
-     */
-    public RunResult cli(boolean verbose, int expectedExitCode, File workingDir, String... params) throws IllegalArgumentException, IOException {
-        String[] cmd = verbose ? Util.concat(baseCmd, "--verbose") : baseCmd;
-        String[] args = Util.concat(cmd, "-i", "--apihost", WhiskProperties.getEdgeHost());
-        RunResult rr = TestUtils.runCmd(DONTCARE_EXIT, workingDir, TestUtils.logger, this.env, Util.concat(args, params));
-        rr.validateExitCode(expectedExitCode);
-        return rr;
-    }
-
-    public void setEnv(Map<String, String> env) {
-        this.env = env;
-    }
-}
diff --git a/tests/src/common/WskTestHelpers.scala b/tests/src/common/WskTestHelpers.scala
index b47c25d88de..43499287cf4 100644
--- a/tests/src/common/WskTestHelpers.scala
+++ b/tests/src/common/WskTestHelpers.scala
@@ -26,7 +26,8 @@ import scala.language.postfixOps
 import org.scalatest.Matchers
 
 import common.TestUtils.RunResult
-import spray.json.JsObject
+import spray.json._
+import java.time.Instant
 
 /**
  * Test fixture to ease cleaning of whisk entities created during testing.
@@ -43,7 +44,7 @@ trait WskTestHelpers extends Matchers {
      * in given collection.
      *
      */
-    private class AssetCleaner(assetsToDeleteAfterTest: Assets, wskprops: WskProps) {
+    class AssetCleaner(assetsToDeleteAfterTest: Assets, wskprops: WskProps) {
         def withCleaner[T <: DeleteFromCollection](cli: T, name: String, confirmDelete: Boolean = true)(
             cmd: (T, String) => RunResult): RunResult = {
             cli.sanitize(name)(wskprops) // sanitize (delete) if asset exists
@@ -84,10 +85,27 @@ trait WskTestHelpers extends Matchers {
         }
     }
 
+    /**
+     * An arbitrary response of a whisk action. Includes the result as a JsObject as the
+     * structure of "result" is not defined.
+     */
+    case class CliActivationResponse(result: Option[JsObject], status: String, success: Boolean)
+    object CliActivationResponse extends DefaultJsonProtocol {
+        implicit val serdes = jsonFormat3(CliActivationResponse.apply)
+    }
+
+    /**
+     * Activation record as it is returned by the CLI.
+     */
+    case class CliActivation(activationId: String, logs: Option[List[String]], response: CliActivationResponse, start: Long, end: Long, cause: Option[String])
+    object CliActivation extends DefaultJsonProtocol {
+        implicit val serdes = jsonFormat6(CliActivation.apply)
+    }
+
     /**
      * Extracts an activation id from a wsk command producing a RunResult with such an id.
      * If id is found, polls activations until one matching id is found. If found, pass
-     * the activation as a JsObject to the post processor which then check for expected values.
+     * the activation to the post processor which then check for expected values.
      */
     def withActivation(
         wsk: WskActivation,
@@ -95,7 +113,7 @@ trait WskTestHelpers extends Matchers {
         initialWait: Duration = 1 second,
         pollPeriod: Duration = 1 second,
         totalWait: Duration = 30 seconds)(
-            check: JsObject => Unit)(
+            check: CliActivation => Unit)(
                 implicit wskprops: WskProps): Unit = {
         val activationId = wsk.extractActivationId(run)
 
@@ -108,7 +126,7 @@ trait WskTestHelpers extends Matchers {
         if (activation.isLeft) {
             assert(false, s"error waiting for activation $id: ${activation.left.get}")
         } else try {
-            check(activation.right.get)
+            check(activation.right.get.convertTo[CliActivation])
         } catch {
             case error: Throwable =>
                 println(s"check failed for activation $id: ${activation.right.get}")
@@ -116,6 +134,38 @@ trait WskTestHelpers extends Matchers {
         }
     }
 
+    /**
+     * Polls until it finds {@code N} activationIds from an entity. Asserts the count
+     * of the activationIds actually equal {@code N}. Takes a {@code since} parameter
+     * defining the oldest activationId to consider valid.
+     */
+    def withActivationsFromEntity(
+        wsk: WskActivation,
+        entity: String,
+        N: Int = 1,
+        since: Option[Instant] = None,
+        pollPeriod: Duration = 1 second,
+        totalWait: Duration = 30 seconds)(
+            check: Seq[CliActivation] => Unit)(
+                implicit wskprops: WskProps): Unit = {
+
+        val activationIds = wsk.pollFor(N, Some(entity), since = since)
+        withClue(s"did not find $N activations for $entity since $since") {
+            activationIds.length shouldBe N
+        }
+
+        val parsed = activationIds.map { id =>
+            wsk.parseJsonString(wsk.get(id).stdout).convertTo[CliActivation]
+        }
+        try {
+            check(parsed)
+        } catch {
+            case error: Throwable =>
+                println(s"check failed for activations $activationIds: ${parsed}")
+                throw error
+        }
+    }
+
     /**
      * In the case that test throws an exception, print stderr and stdout
      * from the provided RunResult.
diff --git a/tests/src/limits/ActionLimitsTests.scala b/tests/src/limits/ActionLimitsTests.scala
index 4913e4586d6..0e628d4c48a 100644
--- a/tests/src/limits/ActionLimitsTests.scala
+++ b/tests/src/limits/ActionLimitsTests.scala
@@ -69,7 +69,7 @@ class ActionLimitsTests extends TestHelpers with WskTestHelpers {
 
             val run = wsk.action.invoke(name, Map("payload" -> allowedActionDuration.plus(1 second).toMillis.toJson))
             withActivation(wsk.activation, run) {
-                _.fields("response").asJsObject.fields("result").toString should include(
+                _.response.result.get.toString should include(
                     s""""error":"action exceeded its time limits of ${allowedActionDuration.toMillis} milliseconds"""")
             }
     }
@@ -86,7 +86,7 @@ class ActionLimitsTests extends TestHelpers with WskTestHelpers {
 
             val run = wsk.action.invoke(name, Map("payload" -> allowedActionDuration.minus(1 second).toMillis.toJson))
             withActivation(wsk.activation, run) {
-                _.fields("response").asJsObject.fields("result").toString should include(
+                _.response.result.get.toString should include(
                     """[OK] message terminated successfully""")
 
             }
@@ -106,7 +106,7 @@ class ActionLimitsTests extends TestHelpers with WskTestHelpers {
 
             val run = wsk.action.invoke(name, Map("payload" -> characters.toJson))
             withActivation(wsk.activation, run) { response =>
-                val lines = response.fields("logs").convertTo[List[String]]
+                val lines = response.logs.get
                 lines.last should be(s"Logs have been truncated because they exceeded the limit of ${allowedSize.toMB} megabytes")
                 // dropping 39 characters (timestamp + streamname)
                 lines.dropRight(1).map(_.drop(39)).mkString.sizeInBytes should be <= allowedSize
@@ -123,11 +123,13 @@ class ActionLimitsTests extends TestHelpers with WskTestHelpers {
 
             val run = wsk.action.invoke(name)
             withActivation(wsk.activation, run) { response =>
-                val logs = response.fields("logs").convertTo[List[String]]
+                val logs = response.logs.get
                 logs.size shouldBe 1
                 logs.head should include("0123456789abcdef")
-                response.fields("response").asJsObject.fields("result").toString should include(s""""msg":1""")
-                response.fields("response").asJsObject.fields("status").toString should include("success")
+
+                response.response.status shouldBe "success"
+                response.response.result shouldBe Some(JsObject(
+                    "msg" -> 1.toJson))
             }
     }
 
diff --git a/tests/src/packages/GreetingTests.scala b/tests/src/packages/GreetingTests.scala
new file mode 100644
index 00000000000..f3811517e7b
--- /dev/null
+++ b/tests/src/packages/GreetingTests.scala
@@ -0,0 +1,74 @@
+/*
+ * Copyright 2015-2016 IBM Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package packages.samples
+
+import java.io.File
+
+import org.junit.runner.RunWith
+import org.scalatest.junit.JUnitRunner
+
+import common.TestHelpers
+import common.Wsk
+import common.WskProps
+import common.WskTestHelpers
+import spray.json._
+import spray.json.DefaultJsonProtocol._
+
+@RunWith(classOf[JUnitRunner])
+class GreetingTests extends TestHelpers
+    with WskTestHelpers {
+
+    implicit val wskprops = WskProps()
+    val wsk = new Wsk()
+    val catalogDir = new File(scala.util.Properties.userDir.toString(), "../packages")
+    val greetingAction = "/whisk.system/samples/greeting"
+
+    behavior of "Greeting sample"
+
+    it should "contain stranger from somewhere when using a 'wrong' parameter" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val helloMessage = "Hello, stranger from somewhere!".toJson
+            val run = wsk.action.invoke(greetingAction, Map("dummy" -> "dummy".toJson))
+            withActivation(wsk.activation, run) {
+                activation =>
+                    activation.response.success shouldBe true
+                    activation.response.result shouldBe Some(JsObject("payload" -> helloMessage.toJson))
+            }
+    }
+
+    it should "contain the sent name when using the 'name' parameter, defaulting the place to somewhere" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val helloStranger = "Hello, Mork from somewhere!".toJson
+            val run = wsk.action.invoke(greetingAction, Map("name" -> "Mork".toJson))
+            withActivation(wsk.activation, run) {
+                activation =>
+                    activation.response.success shouldBe true
+                    activation.response.result shouldBe Some(JsObject("payload" -> helloStranger.toJson))
+            }
+    }
+
+    it should "contain the sent name and place when using 'name' and 'place' parameters" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val helloMessage = "Hello, Mork from Ork!".toJson
+            val run = wsk.action.invoke(greetingAction, Map("name" -> "Mork".toJson, "place" -> "Ork".toJson))
+            withActivation(wsk.activation, run) {
+                activation =>
+                    activation.response.success shouldBe true
+                    activation.response.result shouldBe Some(JsObject("payload" -> helloMessage.toJson))
+            }
+    }
+}
diff --git a/tests/src/packages/SamplesTests.java b/tests/src/packages/SamplesTests.java
deleted file mode 100644
index febe7ceb525..00000000000
--- a/tests/src/packages/SamplesTests.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package packages;
-
-import static common.Pair.make;
-import static org.junit.Assert.assertTrue;
-
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import com.google.code.tempusfugit.concurrency.ParallelRunner;
-
-import common.Pair;
-import common.TestUtils;
-import common.WskCli;
-
-/**
- * Test actions in samples package.
- */
-@RunWith(ParallelRunner.class)
-public class SamplesTests {
-    private static final Boolean usePythonCLI = false;
-    private final WskCli wsk = new WskCli(usePythonCLI);
-
-    @BeforeClass
-    public static void setUp() throws Exception {
-    }
-
-    /**
-     * Test the greeting action.
-     */
-    @Test
-    public void testGreeting() throws Exception {
-        String action = "/whisk.system/samples/greeting";
-
-        Pair<String, String> response = wsk.invokeBlocking(action, TestUtils.makeParameter("dummy", "dummy"));
-        assertTrue("Wrong default parameters", response.snd.contains("Hello, stranger from somewhere!"));
-
-        response = wsk.invokeBlocking(action, TestUtils.makeParameter("name", "Mork"));
-        assertTrue("Wrong name", response.snd.contains("Hello, Mork from somewhere!"));
-
-        response = wsk.invokeBlocking(action, TestUtils.makeParameter(make("name", "Mork"), make("place", "Ork")));
-        assertTrue("Wrong name and place", response.snd.contains("Hello, Mork from Ork!"));
-    }
-
-}
diff --git a/tests/src/packages/SlackTests.java b/tests/src/packages/SlackTests.java
deleted file mode 100644
index 07db3c142f3..00000000000
--- a/tests/src/packages/SlackTests.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package packages;
-
-import static common.Pair.make;
-import static org.junit.Assert.assertTrue;
-
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import com.google.code.tempusfugit.concurrency.ParallelRunner;
-
-import common.TestUtils;
-import common.WskCli;
-
-/**
- * Tests for rules using command line interface
- */
-@RunWith(ParallelRunner.class)
-public class SlackTests {
-  private static final Boolean usePythonCLI = false;
-  private static final WskCli wsk = new WskCli(usePythonCLI);
-
-  private static final int DEFAULT_WAIT = 100;
-
-  @Test(timeout=120*1000)
-  public void createSlackMessageObject() throws Exception {
-    String username = "Test";
-    String channel = "gittoslack";
-    String text = "Hello Test!";
-    String url = "https://hooks.slack.com/services/ABC/";
-
-    String activationId = wsk.invoke("/whisk.system/slack/post", TestUtils.makeParameter(
-            make("username", username),
-            make("channel", channel),
-            make("text", text), make("url", url)));
-
-    String expectedChannel = "channel: '" + channel + "'";
-    String expectedUsername = "username: '" + username + "'";
-    String expectedText = "text: '" + text + "'";
-
-    assertTrue("Expected message not found: " + expectedChannel, wsk.logsForActivationContain(activationId, expectedChannel, DEFAULT_WAIT));
-    assertTrue("Expected message not found: " + expectedUsername, wsk.logsForActivationContain(activationId, expectedUsername, DEFAULT_WAIT));
-    assertTrue("Expected message not found: " + expectedText, wsk.logsForActivationContain(activationId, expectedText, DEFAULT_WAIT));
-    assertTrue("Expected message not found: " + url, wsk.logsForActivationContain(activationId, url, DEFAULT_WAIT));
-  }
-
-}
diff --git a/tests/src/packages/SlackTests.scala b/tests/src/packages/SlackTests.scala
new file mode 100644
index 00000000000..ab6078b5b21
--- /dev/null
+++ b/tests/src/packages/SlackTests.scala
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2015-2016 IBM Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package packages.slack
+
+import org.junit.runner.RunWith
+import org.scalatest.BeforeAndAfterAll
+import org.scalatest.junit.JUnitRunner
+
+import common.JsHelpers
+import common.TestHelpers
+import common.Wsk
+import common.WskProps
+import common.WskTestHelpers
+import spray.json.DefaultJsonProtocol.StringJsonFormat
+import spray.json.pimpAny
+
+@RunWith(classOf[JUnitRunner])
+class SlackTests extends TestHelpers
+    with WskTestHelpers
+    with BeforeAndAfterAll
+    with JsHelpers {
+
+    implicit val wskprops = WskProps()
+    val wsk = new Wsk()
+    val username = "Test";
+    val channel = "gittoslack";
+    val text = "Hello Test!";
+    val url = "https://hooks.slack.com/services/ABC/";
+    val slackAction = "/whisk.system/slack/post"
+
+    val expectedChannel = "channel: '" + channel + "'"
+    val expectedUsername = "username: '" + username + "'";
+    val expectedText = "text: '" + text + "'";
+
+    "Slack Package" should "print the object being sent to slack" in {
+        val run = wsk.action.invoke(slackAction, Map("username" -> username.toJson, "channel" -> channel.toJson, "text" -> text.toJson, "url" -> url.toJson))
+        withActivation(wsk.activation, run) {
+            activation =>
+                activation.response.success shouldBe true
+                val logs = activation.logs.get.mkString("\n")
+                logs should include(expectedChannel)
+                logs should include(expectedUsername)
+                logs should include(expectedText)
+                logs should include(url)
+        }
+    }
+
+}
diff --git a/tests/src/packages/UtilsTests.scala b/tests/src/packages/UtilsTests.scala
index e046325a1d2..9d5ad255bd5 100644
--- a/tests/src/packages/UtilsTests.scala
+++ b/tests/src/packages/UtilsTests.scala
@@ -34,8 +34,8 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
     behavior of "Util Actions"
 
     /**
-      * Test the Node.js "cat" action
-      */
+     * Test the Node.js "cat" action
+     */
     it should "concatenate an array of strings using the node.js cat action" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -48,13 +48,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("lines" -> lines))) {
-                _.fields("response").toString should include(""""payload":"seven\neight\nnine"""")
+                _.response.result.get.toString should include(""""payload":"seven\neight\nnine"""")
             }
     }
 
     /**
-      * Test the "cat" action using Node.js 6
-      */
+     * Test the "cat" action using Node.js 6
+     */
     it should "concatenate an array of strings using the cat action on node.js 6" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -67,13 +67,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("lines" -> lines))) {
-                _.fields("response").toString should include(""""payload":"seven\neight\nnine"""")
+                _.response.result.get.toString should include(""""payload":"seven\neight\nnine"""")
             }
     }
 
     /**
-      * Test the Swift "cat" action using Swift 3
-      */
+     * Test the Swift "cat" action using Swift 3
+     */
     ignore should "concatenate an array of strings using the swift cat action" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -86,14 +86,14 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("lines" -> lines))) {
-                _.fields("response").toString should include(""""payload":"seven\neight\nnine\n"""")
+                _.response.result.get.toString should include(""""payload":"seven\neight\nnine\n"""")
             }
 
     }
 
     /**
-      * Test the Node.js "split" action
-      */
+     * Test the Node.js "split" action
+     */
     it should "split a string into an array of strings using the node.js split action" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -106,13 +106,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("payload" -> "seven,eight,nine".toJson, "separator" -> ",".toJson))) {
-                _.fields("response").toString should include (""""lines":["seven","eight","nine"]""")
+                _.response.result.get.toString should include(""""lines":["seven","eight","nine"]""")
             }
     }
 
     /**
-      * Test the "split" action using Node.js 6
-      */
+     * Test the "split" action using Node.js 6
+     */
     it should "split a string into an array of strings using the split action on nodejs 6" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -125,13 +125,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("payload" -> "seven,eight,nine".toJson, "separator" -> ",".toJson))) {
-                _.fields("response").toString should include (""""lines":["seven","eight","nine"]""")
+                _.response.result.get.toString should include(""""lines":["seven","eight","nine"]""")
             }
     }
 
     /**
-      * Test the Swift "split" action using Swift 3
-      */
+     * Test the Swift "split" action using Swift 3
+     */
     ignore should "split a string into an array of strings using the swift split action" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -144,13 +144,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("payload" -> "seven,eight,nine".toJson, "separator" -> ",".toJson))) {
-                _.fields("response").toString should include (""""lines":["seven","eight","nine"]""")
+                _.response.result.get.toString should include(""""lines":["seven","eight","nine"]""")
             }
     }
 
     /**
-      * Test the Node.js "head" action
-      */
+     * Test the Node.js "head" action
+     */
     it should "extract first n elements of an array of strings using the node.js head action" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -163,13 +163,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("lines" -> lines, "num" -> JsNumber(2)))) {
-                _.fields("response").toString should include(""""lines":["seven","eight"]""")
+                _.response.result.get.toString should include(""""lines":["seven","eight"]""")
             }
     }
 
     /**
-      * Test the "head" action using Node.js 6
-      */
+     * Test the "head" action using Node.js 6
+     */
     it should "extract first n elements of an array of strings using the head action on nodejs 6" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -182,13 +182,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("lines" -> lines, "num" -> JsNumber(2)))) {
-                _.fields("response").toString should include(""""lines":["seven","eight"]""")
+                _.response.result.get.toString should include(""""lines":["seven","eight"]""")
             }
     }
 
     /**
-      * Test the Swift "head" action using Swift 3
-      */
+     * Test the Swift "head" action using Swift 3
+     */
     ignore should "extract first n elements of an array of strings using the swift head action" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -201,13 +201,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("lines" -> lines, "num" -> JsNumber(2)))) {
-                _.fields("response").toString should include(""""lines":["seven","eight"]""")
+                _.response.result.get.toString should include(""""lines":["seven","eight"]""")
             }
     }
 
     /**
-      * Test the Node.js "sort" action
-      */
+     * Test the Node.js "sort" action
+     */
     it should "sort an array of strings using the node.js sort action" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -220,13 +220,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("lines" -> lines))) {
-                _.fields("response").toString should include(""""lines":["eight","nine","seven"]""")
+                _.response.result.get.toString should include(""""lines":["eight","nine","seven"]""")
             }
     }
 
     /**
-      * Test the "sort" action using Node.js 6
-      */
+     * Test the "sort" action using Node.js 6
+     */
     it should "sort an array of strings using the sort action on nodejs 6" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -239,13 +239,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("lines" -> lines))) {
-                _.fields("response").toString should include(""""lines":["eight","nine","seven"]""")
+                _.response.result.get.toString should include(""""lines":["eight","nine","seven"]""")
             }
     }
 
     /**
-      * Test the Swift "sort" action using Swift 3
-      */
+     * Test the Swift "sort" action using Swift 3
+     */
     ignore should "sort an array of strings using the swift sort action" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -258,13 +258,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("lines" -> lines))) {
-                _.fields("response").toString should include(""""lines":["eight","nine","seven"]""")
+                _.response.result.get.toString should include(""""lines":["eight","nine","seven"]""")
             }
     }
 
     /**
-      * Test the Node.js "wordCount" action
-      */
+     * Test the Node.js "wordCount" action
+     */
     it should "count the number of words in a string using the node.js word count action" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -277,13 +277,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("payload" -> "one two three".toJson))) {
-                _.fields("response").toString should include(""""count":3""")
+                _.response.result.get.toString should include(""""count":3""")
             }
     }
 
     /**
-      * Test the "wordCount" action using Node.js 6
-      */
+     * Test the "wordCount" action using Node.js 6
+     */
     it should "count the number of words in a string using the word count action on nodejs 6" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -296,13 +296,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("payload" -> "one two three".toJson))) {
-                _.fields("response").toString should include(""""count":3""")
+                _.response.result.get.toString should include(""""count":3""")
             }
     }
 
     /**
-      * Test the Swift "wordCount" action using Swift 3
-      */
+     * Test the Swift "wordCount" action using Swift 3
+     */
     ignore should "count the number of words in a string using the swift word count action" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -315,13 +315,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("payload" -> "one two three".toJson))) {
-                _.fields("response").toString should include(""""count":3""")
+                _.response.result.get.toString should include(""""count":3""")
             }
     }
 
     /**
-      * Test the Node.js "helloPromises" action
-      */
+     * Test the Node.js "helloPromises" action
+     */
     it should "return a hello message as an array of strings using the node.js helloPromises action" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -334,13 +334,13 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("place" -> "Chicago".toJson))) {
-                _.fields("response").toString should include(""""lines":["Hello,","stranger","from","Chicago!"]""")
+                _.response.result.get.toString should include(""""lines":["Hello,","stranger","from","Chicago!"]""")
             }
     }
 
     /**
-      * Test the "helloPromises" action using Node.js 6
-      */
+     * Test the "helloPromises" action using Node.js 6
+     */
     it should "return a hello message as an array of strings using helloPromises action on nodejs 6" in withAssetCleaner(wskprops) {
         (wp, assetHelper) =>
             val wsk = new Wsk(usePythonCLI)
@@ -353,7 +353,7 @@ class UtilsTests extends TestHelpers with WskTestHelpers with Matchers {
             }
 
             withActivation(wsk.activation, wsk.action.invoke(actionName, Map("place" -> "Chicago".toJson))) {
-                _.fields("response").toString should include(""""lines":["Hello,","stranger","from","Chicago!"]""")
+                _.response.result.get.toString should include(""""lines":["Hello,","stranger","from","Chicago!"]""")
             }
     }
 
diff --git a/tests/src/packages/websocket/WebSocketTests.scala b/tests/src/packages/websocket/WebSocketTests.scala
index e5b2011b47a..8b247fd00ba 100644
--- a/tests/src/packages/websocket/WebSocketTests.scala
+++ b/tests/src/packages/websocket/WebSocketTests.scala
@@ -30,16 +30,16 @@ import common.TestHelpers
 import common.Wsk
 import common.WskProps
 import common.WskTestHelpers
-import spray.json.DefaultJsonProtocol.BooleanJsonFormat
 import spray.json.DefaultJsonProtocol.StringJsonFormat
 import spray.json.pimpAny
+import spray.json.JsObject
 
 @RunWith(classOf[JUnitRunner])
 class WebSocketTests
-        extends TestHelpers
-        with WskTestHelpers
-        with BeforeAndAfterAll
-        with JsHelpers {
+    extends TestHelpers
+    with WskTestHelpers
+    with BeforeAndAfterAll
+    with JsHelpers {
 
     implicit val wskprops = WskProps()
     val wsk = new Wsk(usePythonCLI = false)
@@ -64,8 +64,9 @@ class WebSocketTests
             val run = wsk.action.invoke(websocketSendAction, Map("uri" -> serverURI.toString.toJson, "payload" -> uniquePayload))
             withActivation(wsk.activation, run, 1 second, 1 second, 180 seconds) {
                 activation =>
-                    activation.getFieldPath("response", "success") should be(Some(true.toJson))
-                    activation.getFieldPath("response", "result", "payload") should be(Some(uniquePayload))
+                    activation.response.success shouldBe true
+                    activation.response.result shouldBe Some(JsObject(
+                        "payload" -> uniquePayload))
             }
     }
 
@@ -76,10 +77,10 @@ class WebSocketTests
             val run = wsk.action.invoke(websocketSendAction, Map("uri" -> badURI.toString.toJson, "payload" -> "This is the message to send".toJson))
             withActivation(wsk.activation, run) {
                 activation =>
-                    activation.getFieldPath("response", "success") should be(Some(false.toJson))
+                    activation.response.success shouldBe false
 
                     // the exact error content comes from the ws Node module
-                    activation.fieldPathExists("response", "result", "error") should be(true)
+                    activation.response.result.get.fields.get("error") shouldBe defined
             }
     }
 
@@ -88,9 +89,9 @@ class WebSocketTests
             val run = wsk.action.invoke(websocketSendAction, Map("uri" -> serverURI.toString.toJson))
             withActivation(wsk.activation, run) {
                 activation =>
-                    activation.getFieldPath("response", "success") should be(Some(false.toJson))
-
-                    activation.getFieldPath("response", "result", "error") should be(Some("You must specify a payload parameter.".toJson))
+                    activation.response.success shouldBe false
+                    activation.response.result shouldBe Some(JsObject(
+                        "error" -> "You must specify a payload parameter.".toJson))
             }
     }
 
@@ -99,9 +100,9 @@ class WebSocketTests
             val run = wsk.action.invoke(websocketSendAction, Map("payload" -> "This is the message to send".toJson))
             withActivation(wsk.activation, run) {
                 activation =>
-                    activation.getFieldPath("response", "success") should be(Some(false.toJson))
-
-                    activation.getFieldPath("response", "result", "error") should be(Some("You must specify a uri parameter.".toJson))
+                    activation.response.success shouldBe false
+                    activation.response.result shouldBe Some(JsObject(
+                        "error" -> "You must specify a uri parameter.".toJson))
             }
     }
 }
diff --git a/tests/src/services/KafkaTests.java b/tests/src/services/KafkaTests.java
deleted file mode 100644
index 199aabca9b4..00000000000
--- a/tests/src/services/KafkaTests.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package services;
-
-import static org.junit.Assert.assertTrue;
-
-import java.io.UnsupportedEncodingException;
-import java.util.Collections;
-import java.util.Properties;
-import java.util.concurrent.ExecutionException;
-
-import org.apache.kafka.clients.consumer.ConsumerConfig;
-import org.apache.kafka.clients.consumer.ConsumerRecord;
-import org.apache.kafka.clients.consumer.ConsumerRecords;
-import org.apache.kafka.clients.consumer.KafkaConsumer;
-import org.apache.kafka.clients.producer.KafkaProducer;
-import org.apache.kafka.clients.producer.ProducerConfig;
-import org.apache.kafka.clients.producer.ProducerRecord;
-import org.apache.kafka.clients.producer.RecordMetadata;
-import org.apache.kafka.common.serialization.ByteArrayDeserializer;
-import org.apache.kafka.common.serialization.StringSerializer;
-import org.junit.Rule;
-import org.junit.Test;
-import org.junit.Ignore;
-import org.junit.rules.TestRule;
-
-import common.TestUtils;
-import common.WhiskProperties;
-
-/**
- * Tests that interact directly with kafka
- */
-@Ignore //ignoring until intermittent fails have been resolved. test works if KafkaConnectorTests.java runs first.
-public class KafkaTests {
-
-    @Rule
-    public TestRule watcher = TestUtils.makeTestWatcher();
-
-    /**
-     * Basic test of publish-subscribe using Kafka.
-     */
-    @Test
-    public void stegosaurus() throws UnsupportedEncodingException, InterruptedException, ExecutionException {
-        String topic = "Dinosaurs";
-        KafkaProducer<String, String> producer = makeProducer();
-        KafkaConsumer<byte[], byte[]> consumer = makeConsumer(topic);
-        try {
-            for (int i = 0; i < 3; i++) {
-                String msg = "Stegosaurus-" + System.currentTimeMillis();
-                System.out.println(msg);
-                publish(producer, "Dinosaurs", msg);
-
-                String received = consumeOneMessage(consumer, topic);
-                System.out.println("consumed: " + received);
-                assertTrue(received.equals(msg));
-            }
-
-        } finally {
-            producer.close();
-            consumer.close();
-        }
-    }
-
-    /**
-     * Creates a Kafka producer.
-     */
-    private static KafkaProducer<String, String> makeProducer() throws InterruptedException, ExecutionException {
-        Properties props = new Properties();
-        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, WhiskProperties.getKafkaHost() + ":" + WhiskProperties.getKafkaPort());
-        props.put(ProducerConfig.ACKS_CONFIG, "1");
-
-        StringSerializer keySerializer = new StringSerializer();
-        StringSerializer valueSerializer = new StringSerializer();
-        KafkaProducer<String, String> producer = new KafkaProducer<String, String>(props, keySerializer, valueSerializer);
-        return producer;
-    }
-
-    /**
-     * Publishes a single message to Kafka.
-     */
-    private static void publish(KafkaProducer<String, String> producer, String topic, String message) throws InterruptedException, ExecutionException {
-        ProducerRecord<String, String> data = new ProducerRecord<String, String>(topic, message);
-        RecordMetadata status = producer.send(data).get();
-        System.out.format("sent message: %s[%d][%d]\n", status.topic(), status.partition(), status.offset());
-    }
-
-    /**
-     * Pulls messages message from a Kafka topic and returns the most recent one
-     * or null if no messages found.
-     */
-    static KafkaConsumer<byte[], byte[]> makeConsumer(String topic) throws InterruptedException {
-        Properties props = new Properties();
-        props.put(ConsumerConfig.GROUP_ID_CONFIG, "kafkatest");
-        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, WhiskProperties.getKafkaHost() + ":" + WhiskProperties.getKafkaPort());
-        props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, "10000");
-        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "latest");
-
-        ByteArrayDeserializer keyDeserializer = new ByteArrayDeserializer();
-        ByteArrayDeserializer valueDeserializer = new ByteArrayDeserializer();
-        KafkaConsumer<byte[], byte[]> consumer = new KafkaConsumer<byte[], byte[]>(props, keyDeserializer, valueDeserializer);
-        consumer.subscribe(Collections.singletonList(topic));
-        consumer.poll(1000); // initializes consumer group coordinator
-        return consumer;
-    }
-
-    /**
-     * Pulls messages message from a Kafka topic and returns the most recent one
-     * or null if no messages found.
-     */
-    static String consumeOneMessage(KafkaConsumer<byte[], byte[]> consumer, String topic) {
-        System.out.print("received: ");
-        ConsumerRecords<byte[], byte[]> records = consumer.poll(1000);
-        int count = records.count();
-        System.out.println(count);
-        assertTrue(count >= 1);
-        String last = null;
-        for (ConsumerRecord<byte[], byte[]> record : records) {
-            String result = new String(record.value());
-            System.out.println(result);
-            last = result;
-        }
-        consumer.commitSync();
-        return last;
-    }
-}
diff --git a/tests/src/system/basic/CLIActionTests.java b/tests/src/system/basic/CLIActionTests.java
deleted file mode 100644
index 1b8ed97289f..00000000000
--- a/tests/src/system/basic/CLIActionTests.java
+++ /dev/null
@@ -1,501 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package system.basic;
-
-import static common.WskCli.Item.Action;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.junit.BeforeClass;
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import com.google.code.tempusfugit.concurrency.ParallelRunner;
-
-import common.Pair;
-import common.TestUtils;
-import common.TestUtils.RunResult;
-import common.WskCli;
-
-/**
- * Tests for rules using command line interface
- */
-@RunWith(ParallelRunner.class)
-public class CLIActionTests {
-    private static final Boolean usePythonCLI = false;
-    private static final WskCli wsk = new WskCli(usePythonCLI);
-
-    public static final String[] sampleTestWords = new String[] { "SHERLOCK", "WATSON", "LESTRADE" };
-    private static final int DEFAULT_WAIT = 100;  // Wait this long for logs to show up
-
-    @BeforeClass
-    public static void setUp() throws Exception {
-    }
-
-    /**
-     * Test the hello world demo sequence.
-     */
-    @Test(timeout=120*1000)
-    public void helloWorldDemo() throws Exception {
-        long duration = helloWorldHelper(wsk, "helloWorldDemo", 2*DEFAULT_WAIT);
-        assertTrue("Test took " + duration + "ms -- this is too slow.", duration < 2*DEFAULT_WAIT*1000);
-    }
-
-    /**
-     * Test the hello world demo sequence
-     */
-    @Test(timeout=120*1000)
-    public void helloWorldDemoWithSpace() throws Exception {
-        long duration = helloWorldHelper(wsk, "hello World demo with space", 2*DEFAULT_WAIT);
-        assertTrue("Test took " + duration + "ms -- this is too slow.", duration < 2*DEFAULT_WAIT*1000);
-    }
-
-    // Convenience method for when short test word vector is ok
-    public static long helloWorldHelper(WskCli wsk, String actionName, int waitTime) throws Exception {
-        return helloWorldHelper(wsk, actionName, waitTime, sampleTestWords, false);
-    }
-
-    /**
-     * Static method extracted for reuse.
-     *
-     * @param wsk the WskCLI instance to use so we can select the auth
-     * @param actionName name of the action to install and test
-     * @param waitTime an upper bound on how long do we expect this test to take
-     * @param testWords a list of testwords to use
-     */
-    public static long helloWorldHelper(WskCli wsk, String actionName, int waitTime,
-                                        String[] testWords, boolean skipCheck) throws Exception {
-        try {
-            long start = System.currentTimeMillis();
-
-            wsk.sanitize(Action, actionName);
-            wsk.createAction(actionName, TestUtils.getCatalogFilename("samples/hello.js"));
-
-            // keep track of invoke ids and use them to check the output of the activation
-            List<String> activationIds = new ArrayList<String>();
-            for (String tw : testWords) {
-                String activationId = wsk.invoke(actionName, TestUtils.makeParameter("payload", tw+actionName));
-                activationIds.add(activationId);
-            }
-            for (int i =0; i < activationIds.size(); i++) {
-                String tw = testWords[i];
-                String activationId = activationIds.get(i);
-                String expected = tw+actionName;
-                if (!wsk.logsForActivationContain(activationId, expected, waitTime)) {
-                    if (skipCheck)
-                        System.out.println("Did not find " + expected + " in activation " + activationId);
-                    else
-                        assertFalse("Did not find " + expected + " in activation " + activationId, true);
-                }
-            }
-            return System.currentTimeMillis() - start;
-        } finally {
-            wsk.delete(Action, actionName);
-        }
-    }
-
-    private static String[] testSentences = new String[] {
-            "Mary had a little lamb, little lamb, little lamb, da.",
-            "It was the best of times.  It was the worst of times.",
-            "To be or not to be" };
-
-    @Test(timeout=240*1000)
-    public void twoAction() throws Exception {
-        try {
-            wsk.sanitize(Action, "twoAction1");
-            wsk.sanitize(Action, "twoAction2");
-            wsk.createAction("twoAction1", TestUtils.getCatalogFilename("samples/hello.js"));
-            wsk.createAction("twoAction2", TestUtils.getCatalogFilename("samples/wc.js"));
-            ArrayList<String> expected = new ArrayList<String>();
-            ArrayList<String> activationIds = new ArrayList<String>();
-            for (String s : testSentences) {
-                String word = s.substring(0, s.indexOf(' '));
-                String activationId = wsk.invoke("twoAction1", TestUtils.makeParameter("payload", word));
-                expected.add(word);
-                activationIds.add(activationId);
-                activationId = wsk.invoke("twoAction2", TestUtils.makeParameter("payload", s));
-                expected.add(s);
-                activationIds.add(activationId);
-            }
-            for (int i = 0; i < expected.size(); i++) {
-                String exp = expected.get(i);
-                String activationId = activationIds.get(i);
-                boolean present = wsk.logsForActivationContain(activationId, exp, DEFAULT_WAIT);
-                assertTrue("Expected '" + exp + "' which is missing in log for activation " + activationId, present);
-            }
-        } finally {
-            wsk.delete(Action, "twoAction1");
-            wsk.delete(Action, "twoAction2");
-        }
-    }
-
-    @Test(timeout=120*1000)
-    public void invokeAction() throws Exception {
-        String action = "invokeAction";
-        try {
-            wsk.sanitize(Action, action);
-            wsk.createAction(action, TestUtils.getCatalogFilename("samples/wc.js"));
-            String now = String.format("%s %s", action, new Date().toString());
-            String activationId = wsk.invoke(action, TestUtils.makeParameter("payload", now));
-            String expected = String.format("The message '%s' has", now);
-            boolean present = wsk.logsForActivationContain(activationId, expected, DEFAULT_WAIT);
-            assertTrue("Expected '" + expected + "' which is missing in log for activation " + activationId, present);
-            String result = wsk.getResult(activationId).stdout.trim();
-            assertTrue("Expected result for " + activationId + " to be non-empty but is '" + result + "'", result.contains("7"));
-            assertTrue("Expected result to not contain error", !result.contains("error"));
-        } finally {
-            wsk.delete(Action, action);
-        }
-    }
-
-    @Test(timeout=120*1000)
-    public void incorrectActionInvoke() throws Exception {
-        String payload = "bob";
-        String[] cmd = { "action", "invoke", "/whisk.system/samples/helloWorld", payload };
-        RunResult rr = wsk.runCmd(cmd);
-
-        if (usePythonCLI) {
-            assertTrue("Expect a cli error exit code", rr.exitCode == 2);
-            assertTrue("Expect a cli usage message", rr.stderr.contains("usage: wsk [-h] [-v]"));
-            assertTrue("Expect a cli error message", rr.stderr.contains("wsk: error: unrecognized arguments: " + payload));
-        } else {
-            assertTrue("Expect a cli error exit code", rr.exitCode == 1);
-            assertTrue("Expect a cli usage message", rr.stderr.contains("Run 'wsk --help' for usage."));
-            assertTrue("Expect a cli error message", rr.stderr.contains("error: Invalid argument(s): " + payload));
-        }
-    }
-
-    @Test(timeout=120*1000)
-    public void invokeAsyncAction() throws Exception {
-        String action = "invokeAsyncAction";
-        try {
-            wsk.sanitize(Action, action);
-            wsk.createAction(action, TestUtils.getCatalogFilename("samples/helloAsync.js"));
-            String now = String.format("%s %s", action, new Date().toString());
-            String activationId = wsk.invoke(action, TestUtils.makeParameter("payload", now));
-            String expected = String.format("The message '%s' has", now);
-            boolean present = wsk.logsForActivationContain(activationId, expected, DEFAULT_WAIT);
-            assertTrue("Expected '" + expected + "' which is missing in log for activation " + activationId, present);
-            String result = wsk.getResult(activationId).stdout.trim();
-            assertTrue("Expected result for " + activationId + " to be non-empty but is '" + result + "'", result.contains("7"));
-            assertTrue("Expected result to not contain error but is '" + result + "'", !result.contains("error"));
-        } finally {
-            wsk.delete(Action, action);
-        }
-    }
-
-    @Test(timeout=120*1000)
-    public void invokeMonkeySyncDoneTwice() throws Exception {
-        String action = "invokeMonkeySyncDoneTwice";
-        try {
-            wsk.sanitize(Action, action);
-            wsk.createAction(action, TestUtils.getTestActionFilename("helloSyncDoneTwice.js"));
-            String now = String.format("%s %s", action, new Date().toString());
-            String activationId = wsk.invoke(action, TestUtils.makeParameter("payload", now));
-            String expected = String.format("The message '%s' has", now);
-            boolean present = wsk.logsForActivationContain(activationId, expected, DEFAULT_WAIT);
-            assertTrue("Expected '" + expected + "' which is missing in log for activation " + activationId, present);
-            String result = wsk.getResult(activationId).stdout.trim();
-            assertTrue("Expected result for " + activationId + " to be non-empty but is '" + result + "'", result.contains("7"));
-            assertTrue("Expected result to be positive", !result.contains("-1"));
-            assertTrue("Expected result to not contain error", !result.contains("error"));
-        } finally {
-            wsk.delete(Action, action);
-        }
-    }
-
-    @Test(timeout=120*1000)
-    public void invokeMonkeyAsyncDoneTwice() throws Exception {
-        String action = "invokeMonkeyAsyncDoneTwice";
-        try {
-            wsk.sanitize(Action, action);
-            wsk.createAction(action, TestUtils.getTestActionFilename("helloAsyncDoneTwice.js"));
-            String now = String.format("%s %s", action, new Date().toString());
-            String activationId = wsk.invoke(action, TestUtils.makeParameter("payload", now));
-            String expected = String.format("The message '%s' has", now);
-            boolean present = wsk.logsForActivationContain(activationId, expected, DEFAULT_WAIT);
-            assertTrue("Expected '" + expected + "' which is missing in log for activation " + activationId, present);
-            String result = wsk.getResult(activationId).stdout.trim();
-            assertTrue("Expected result of " + activationId + " to be non-empty but is '" + result + "'", result.contains("7"));
-            assertTrue("Expected result to be positive", !result.contains("-1"));
-            assertTrue("Expected result to not contain error", !result.contains("error"));
-        } finally {
-            wsk.delete(Action, action);
-        }
-    }
-
-    @Test(timeout=120*1000)
-    public void blockingInvokeAsyncAction() throws Exception {
-        String action = "blockingInvokeAsyncAction";
-        try {
-            wsk.sanitize(Action, action);
-            wsk.createAction(action, TestUtils.getCatalogFilename("samples/helloAsync.js"));
-            String now = String.format("%s %s", action, new Date().toString(), 120*1000);
-            int numWords = now.trim().split("\\s").length;
-            Pair<String, String> pair = wsk.invokeBlocking(action, TestUtils.makeParameter("payload", now));
-            String activationId = pair.fst;
-            String result = pair.snd;
-            String expected = String.format("The message '%s' has", now);
-            boolean present = wsk.logsForActivationContain(activationId, expected, DEFAULT_WAIT);
-            assertTrue("Expected '" + expected + "' which is missing in log for activation " + activationId, present);
-            assertTrue("Result should have number of words", result.contains(String.valueOf(numWords)));
-            assertTrue("Expected result to not contain error", !result.contains("error"));
-        } finally {
-            wsk.delete(Action, action);
-        }
-    }
-
-    @Test(timeout=120*1000)
-    public void invokeNestedBlockingAction() throws Exception {
-        String parentAction = "nestedBlockingAction";
-        String childAction = "wc";
-        try {
-            wsk.sanitize(Action, childAction);
-            wsk.sanitize(Action, parentAction);
-            wsk.createAction(childAction, TestUtils.getCatalogFilename("samples/wc.js"));
-            wsk.createAction(parentAction, TestUtils.getCatalogFilename("samples/wcbin.js"), 120*1000);
-            String now = String.format("%s %s", parentAction, new Date().toString());
-            int numWords = now.trim().split("\\s").length;
-            String numWordsBinary = Integer.toBinaryString(numWords) + " (base 2)";
-            Pair<String, String> pair = wsk.invokeBlocking(parentAction, TestUtils.makeParameter("payload", now));
-            String activationId = pair.fst;
-            String result = pair.snd;
-            assertTrue("Result "+activationId+" should have number of words", result.contains(numWordsBinary));
-            assertTrue("Expected result to not contain error", !result.contains("error"));
-        } finally {
-            wsk.delete(Action, childAction);
-            wsk.delete(Action, parentAction);
-        }
-    }
-
-    @Test(timeout=120*1000)
-    public void copyAction() throws Exception {
-        String action = "copyAction";
-        try {
-            wsk.sanitize(Action, action);
-            wsk.copyAction(action, "/whisk.system/samples/wordCount");
-            String now = String.format("%s %s", action, new Date().toString());
-            String activationId = wsk.invoke(action, TestUtils.makeParameter("payload", now));
-            String expected = String.format("The message '%s' has", now);
-            boolean present = wsk.logsForActivationContain(activationId, expected, DEFAULT_WAIT);
-            assertTrue("Expected '" + expected + "' which is missing in log for activation " + activationId, present);
-            String result = wsk.getResult(activationId).stdout.trim();
-            assertTrue("Expected result of " + activationId + " to be non-empty", result.contains("7"));
-            assertTrue("Expected result to not contain error", !result.contains("error"));
-        } finally {
-            wsk.delete(Action, action);
-        }
-    }
-
-    @Test(timeout=120*1000)
-    public void updateAction() throws Exception {
-        String action = "updateAction";
-        String publishFalseStr = "\"publish\": false";
-        String publishTrueStr = "\"publish\": true";
-        try {
-            wsk.sanitize(Action, action);
-            // create private action then update it to public
-            wsk.createAction(action, TestUtils.getCatalogFilename("samples/wc.js"), false, false);
-            String item = wsk.get(Action, action);
-            assertTrue("Expect action to not be shared", item.contains(publishFalseStr));
-            wsk.updateAction(action, true);
-            item = wsk.get(Action, action);
-            assertTrue("Expect action to be shared", item.contains(publishTrueStr));
-        } finally {
-            wsk.delete(Action, action);
-        }
-    }
-
-    @Test(timeout=120*1000)
-    public void createActionWithEmptyFile() throws Exception {
-        String action = "createActionWithEmptyFile";
-        String expectedCode = "\"code\": \"\"";
-        try {
-            wsk.sanitize(Action, action);
-            wsk.createAction(action, TestUtils.getTestActionFilename("empty.js"), false, false);
-            String item = wsk.get(Action, action);
-            assertTrue("Expect code to be an empty string", item.contains(expectedCode));
-        } finally {
-            wsk.delete(Action, action);
-        }
-    }
-
-    @Test(timeout=120*1000)
-    public void invokeActionWithNoCode() throws Exception {
-        String name = "invokeActionWithNoCode";
-        try {
-            wsk.sanitize(Action, name);
-            wsk.createAction(name, TestUtils.getTestActionFilename("empty.js"));
-            String activationId = wsk.invoke(name, null);
-            String expected = "Missing main/no code to execute.";
-            boolean present = wsk.checkResultFor(activationId, expected, 45);
-            assertTrue("Expected '" + expected + "' which is missing in log for activation " + activationId, present);
-        } finally {
-            wsk.delete(Action, name);
-        }
-    }
-
-    @Test(timeout=120*1000)
-    public void invokeActionWithSpace() throws Exception {
-        String name = "WORD COUNT";
-        try {
-            wsk.sanitize(Action, name);
-            wsk.createAction(name, TestUtils.getCatalogFilename("samples/wc.js"));
-            String activationId = wsk.invoke(name, TestUtils.makeParameter("payload", "bob barker"));
-            String expected = "The message 'bob barker' has";
-            boolean present = wsk.logsForActivationContain(activationId, expected, DEFAULT_WAIT);
-            assertTrue("Expected '" + expected + "' which is missing in log for activation " + activationId, present);
-        } finally {
-            wsk.delete(Action, name);
-        }
-    }
-
-    @Test(timeout=120*1000)
-    public void parameterBinding() throws Exception {
-        try {
-            wsk.sanitize(Action, "PB_PRINT");
-            @SuppressWarnings("serial")
-            Map<String, String> boundParams = new HashMap<String, String>() {{
-                put("bar", "test1");
-                put("foo", "test2");
-            }};
-            wsk.createAction("PB_PRINT", TestUtils.getCatalogFilename("samples/printParams.js"), boundParams);
-
-            // Check if bound parameters get passed to action.
-            String now = new Date().toString();
-            String activationId = wsk.invoke("PB_PRINT", TestUtils.makeParameter("payload", now));
-            String expected = String.format(".*bar: test1.*foo: test2.*payload: %s", now);
-            boolean present = wsk.logsForActivationContain(activationId, expected, DEFAULT_WAIT);
-            assertTrue("Expected '" + expected + "' which is missing in log for activation " + activationId, present);
-
-            // Check if run time parameter overrides bound parameter.
-            activationId = wsk.invoke("PB_PRINT", TestUtils.makeParameter("foo", now));
-            expected = String.format(".*bar: test1.*foo: %s", now);
-            present = wsk.logsForActivationContain(activationId, expected, DEFAULT_WAIT);
-            assertTrue("Expected '" + expected + "' which is missing in log for activation " + activationId, present);
-        } finally {
-            wsk.delete(Action, "PB_PRINT");
-        }
-    }
-
-    @Test(timeout=240*1000)
-    public void recreateAndInvokeAction() throws Exception {
-      String action = "recreateAction";
-      try {
-          String now = String.format("%s %s", action, new Date().toString());
-          String expectedFirstResult = String.format("The message '%s' has", now);
-          String expectedSecondResult = String.format("hello %s!", now);
-
-          wsk.sanitize(Action, action);
-          wsk.createAction(action, TestUtils.getCatalogFilename("samples/wc.js"));
-          String activationId = wsk.invoke(action, TestUtils.makeParameter("payload", now));
-          boolean present = wsk.logsForActivationContain(activationId, expectedFirstResult, DEFAULT_WAIT);
-          assertTrue("Expected '" + expectedFirstResult + "' which is missing in log for activation " + activationId, present);
-
-          String result = wsk.getResult(activationId).stdout.trim();
-          assertTrue("Expected result for " + activationId + " to be non-empty but is '" + result + "'", result.contains("7"));
-          assertTrue("Expected result to not contain error", !result.contains("error"));
-
-          wsk.delete(Action, action);
-          wsk.createAction(action, TestUtils.getCatalogFilename("samples/hello.js"));
-
-          activationId = wsk.invoke(action, TestUtils.makeParameter("payload", now));
-          present = wsk.logsForActivationContain(activationId, expectedFirstResult, DEFAULT_WAIT);
-          assertTrue("Unexpected '" + expectedFirstResult + "' which is in log for activation " + activationId, !present);
-          present = wsk.logsForActivationContain(activationId, expectedSecondResult, DEFAULT_WAIT);
-          assertTrue("Expected '" + expectedSecondResult + "' which is missing in log for activation " + activationId, present);
-      } finally {
-          wsk.delete(Action, action);
-      }
-    }
-
-    @Ignore
-    @Test(timeout=120*1000)
-    public void invokeActionWithSpecialCharacters() throws Exception {
-        String action = "invokeActionWithUTF8";
-        try {
-            wsk.sanitize(Action, action);
-            wsk.createAction(action, TestUtils.getCatalogFilename("samples/hello.js"));
-            String msg = "«ταБЬℓσö»: 1<2 & 4+1>³, now 20%€§$ off!";
-            String expected = "hello " + msg;
-            String activationId = wsk.invoke(action, TestUtils.makeParameter("payload", msg));
-            boolean present = wsk.logsForActivationContain(activationId, expected, DEFAULT_WAIT);
-            assertTrue("Expected '" + expected + "' which is missing in log for activation " + activationId, present);
-        } finally {
-            wsk.delete(Action, action);
-        }
-    }
-
-    @Test(timeout = 120 * 1000)
-    public void testPingNotAllowed() throws Exception {
-        String action = "testPingNotAllowed";
-        try {
-            wsk.sanitize(Action, action);
-            wsk.createAction(action, TestUtils.getTestActionFilename("ping.js"));
-            String hostToPing = "google.com";
-            long startInvoke = System.currentTimeMillis();
-            String activationId = wsk.invoke(action, TestUtils.makeParameter("payload", hostToPing));
-            String expected = "ping: icmp open socket: Operation not permitted";
-            wsk.activationsContain(action, activationId, startInvoke, DEFAULT_WAIT);
-            String result = wsk.getResult(activationId).stdout.trim();
-            assertTrue("Expected result of " + activationId + " to be '" + expected + "' non-empty but is '" + result + "'", result.contains(expected));
-        } finally {
-            wsk.delete(Action, action);
-        }
-    }
-
-    /**
-     * Test creating an action from a js file always returning an application error.
-     * The invocation should succeed, the activation result should contain an error as
-     * defined in the action and the logs should be empty.
-     */
-    @Test
-    public void applicationError() throws Exception {
-        for(int i = 1; i <= 2; i++) {
-            String actionName = "APPLICATIONERROR" + i;
-            String result;
-
-            wsk.sanitize(Action, actionName);
-            result = wsk.createAction(actionName,  TestUtils.getTestActionFilename("applicationError" + i + ".js"));
-            assertTrue(result, result.contains("ok: created"));
-
-            String activationId = wsk.invoke(actionName, Collections.<String,String>emptyMap());
-
-            boolean bool = wsk.checkResultFor(activationId, "error thrown on purpose", 45);
-            assertTrue("Expected 'error' which is missing in result for activation " + activationId, bool);
-
-            RunResult logs = wsk.getLogsForActivation(activationId);
-
-            String stdout = logs.stdout.trim();
-            String stderr = logs.stderr.trim();
-
-            assertTrue("stdout should be empty, was:\n" + stdout, stdout.isEmpty());
-            assertTrue("stderr should be empty, was:\n" + stderr, stderr.isEmpty());
-
-            result = wsk.delete(Action, actionName);
-            assertTrue(result, result.contains("ok: deleted"));
-        }
-    }
-}
diff --git a/tests/src/system/basic/CLIJavaTests.scala b/tests/src/system/basic/CLIJavaTests.scala
index b7bb390ca63..61a6af6331c 100644
--- a/tests/src/system/basic/CLIJavaTests.scala
+++ b/tests/src/system/basic/CLIJavaTests.scala
@@ -17,7 +17,6 @@
 package system.basic
 
 import scala.concurrent.duration.DurationInt
-import scala.language.postfixOps
 
 import common.TestHelpers
 import common.TestUtils
@@ -39,8 +38,8 @@ class CLIJavaTests
 
     implicit val wskprops = WskProps()
     val wsk = new Wsk(usePythonCLI = false)
-    val expectedDuration = 120 seconds
-    val activationPollDuration = 60 seconds
+    val expectedDuration = 120.seconds
+    val activationPollDuration = 60.seconds
 
     behavior of "Java Actions"
 
@@ -56,11 +55,11 @@ class CLIJavaTests
 
             val start = System.currentTimeMillis()
             withActivation(wsk.activation, wsk.action.invoke(name), totalWait = activationPollDuration) {
-                _.fields("response").toString should include("Hello stranger!")
+                _.response.result.get.toString should include("Hello stranger!")
             }
 
             withActivation(wsk.activation, wsk.action.invoke(name, Map("name" -> JsString("Sir"))), totalWait = activationPollDuration) {
-                _.fields("response").toString should include("Hello Sir!")
+                _.response.result.get.toString should include("Hello Sir!")
             }
 
             withClue("Test duration exceeds expectation (ms)") {
diff --git a/tests/src/system/basic/CLIPythonTests.scala b/tests/src/system/basic/CLIPythonTests.scala
index c43c8c80d1e..a3eefe97373 100644
--- a/tests/src/system/basic/CLIPythonTests.scala
+++ b/tests/src/system/basic/CLIPythonTests.scala
@@ -50,7 +50,7 @@ class CLIPythonTests
             }
 
             withActivation(wsk.activation, wsk.action.invoke(name, Map("name" -> "Prince".toJson))) {
-                _.fields("response").toString should include("Prince")
+                _.response.result.get.toString should include("Prince")
             }
     }
 
@@ -63,7 +63,7 @@ class CLIPythonTests
 
             withActivation(wsk.activation, wsk.action.invoke(name)) {
                 activation =>
-                    val result = activation.fields("response").asJsObject.fields("result").asJsObject
+                    val result = activation.response.result.get
                     result.fields.get("error") shouldBe empty
                     result.fields.get("auth") shouldBe Some(JsString(WhiskProperties.readAuthKey(WhiskProperties.getAuthFileForTesting)))
                     result.fields.get("edge").toString.trim should not be empty
@@ -79,8 +79,8 @@ class CLIPythonTests
 
             withActivation(wsk.activation, wsk.action.invoke(name)) {
                 activation =>
-                    activation.getFieldPath("response", "result", "error") shouldBe Some(JsString("The action failed to generate or locate a binary. See logs for details."))
-                    activation.fields("logs").toString should { not include ("pythonaction.py") and not include ("flask") }
+                    activation.response.result.get.fields.get("error") shouldBe Some(JsString("The action failed to generate or locate a binary. See logs for details."))
+                    activation.logs.get.mkString("\n") should { not include ("pythonaction.py") and not include ("flask") }
             }
     }
 }
diff --git a/tests/src/system/basic/CLIRuleTests.java b/tests/src/system/basic/CLIRuleTests.java
deleted file mode 100644
index 8aaed200cba..00000000000
--- a/tests/src/system/basic/CLIRuleTests.java
+++ /dev/null
@@ -1,456 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package system.basic;
-
-import static common.WskCli.Item.Action;
-import static common.WskCli.Item.Activation;
-import static common.WskCli.Item.Rule;
-import static common.WskCli.Item.Trigger;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ThreadLocalRandom;
-
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-
-import com.google.code.tempusfugit.concurrency.ParallelRunner;
-import com.google.gson.JsonObject;
-import com.google.gson.JsonParser;
-
-import common.TestUtils;
-import common.WskCli;
-
-/**
- * Tests for rules using command line interface
- */
-@RunWith(ParallelRunner.class)
-public class CLIRuleTests {
-    private static final Boolean usePythonCLI = false;
-    private static final WskCli wsk = new WskCli(usePythonCLI);
-    private static final int RULE_DELAY = 30;
-    private static final int DELAY = 90;
-    // NEGATIVE_DELAY is used for tests when checking that something doesn't
-    // show up in activations
-    private static final int NEGATIVE_DELAY = 30;
-
-    @BeforeClass
-    public static void setUp() throws Exception {
-    }
-
-    /**
-     * rule test with one trigger and one action
-     */
-    @Test
-    public void rule1to1() throws Exception {
-        try {
-        	wsk.sanitize(Rule, "R_121");
-        	wsk.sanitize(Action, "A_121");
-        	wsk.sanitize(Trigger, "T_121");
-
-            wsk.createAction("A_121", TestUtils.getCatalogFilename("samples/wc.js"));
-            wsk.createTrigger("T_121");
-            wsk.createRule("R_121", "T_121", "A_121");
-            long beforeTrigger = System.currentTimeMillis();
-            wsk.trigger("T_121", "bob 121");
-
-            String expected = "The message 'bob 121' has";
-            List<String> activationIds = wsk.waitForActivations("A_121", 1, beforeTrigger, DELAY);
-            assertTrue("Not enough activation ids found", activationIds != null);
-            // the most recent id
-            String activationId = activationIds.get(0);
-            assertTrue("Expected message not found: " + expected, wsk.logsForActivationContain(activationId, expected, DELAY));
-        } finally {
-        	wsk.delete(Rule, "R_121");
-        	wsk.delete(Action, "A_121");
-            wsk.delete(Trigger, "T_121");
-        }
-    }
-
-    /**
-     * rule test with one trigger and one action (action has space in name)
-     */
-    @Test
-    public void rule1to1WithSpaceInActionName() throws Exception {
-        try {
-            wsk.sanitize(Rule, "R_121s");
-            wsk.sanitize(Action, "A_121s A_121s");
-            wsk.sanitize(Trigger, "T_121s");
-
-            wsk.createAction("A_121s A_121s", TestUtils.getCatalogFilename("samples/wc.js"));
-            wsk.createTrigger("T_121s");
-            wsk.createRule("R_121s", "T_121s", "A_121s A_121s");
-            long beforeTrigger = System.currentTimeMillis();
-            wsk.trigger("T_121s", "bob 121");
-
-            String expected = "The message 'bob 121' has";
-            List<String> activationIds = wsk.waitForActivations("A_121s A_121s", 1, beforeTrigger, DELAY);
-            assertTrue("Not enough activation ids found", activationIds != null);
-            // the most recent id
-            String activationId = activationIds.get(0);
-            assertTrue("Expected message not found: " + expected, wsk.logsForActivationContain(activationId, expected, DELAY));
-        } finally {
-            wsk.delete(Rule, "R_121s");
-            wsk.delete(Action, "A_121s A_121s");
-            wsk.delete(Trigger, "T_121s");
-        }
-    }
-
-    /**
-     * rule test with two triggers and one action
-     */
-    @Test
-    public void rule2to1() throws Exception {
-        try {
-            wsk.sanitize(Action, "A_221");
-            wsk.sanitize(Trigger, "T1_221");
-            wsk.sanitize(Trigger, "T2_221");
-            wsk.sanitize(Rule, "R1_221");
-            wsk.sanitize(Rule, "R2_221");
-
-            wsk.createAction("A_221", TestUtils.getCatalogFilename("samples/wc.js"));
-            wsk.createTrigger("T1_221");
-            wsk.createTrigger("T2_221");
-            wsk.createRule("R1_221", "T1_221", "A_221");
-            wsk.createRule("R2_221", "T2_221", "A_221");
-
-            long beforeTrigger = System.currentTimeMillis();
-            wsk.trigger("T2_221", "i'll be back");
-            wsk.trigger("T1_221", "terminator");
-
-            String expected1 = "The message 'terminator' has";
-            assertTrue("Expected message not found: " + expected1, wsk.logsForActionContain("A_221", expected1, beforeTrigger, DELAY));
-
-            String expected2 = "The message 'i'll be back' has";
-            assertTrue("Expected message not found: " + expected1, wsk.logsForActionContain("A_221", expected2, beforeTrigger, DELAY));
-
-        } finally {
-            wsk.delete(Action, "A_221");
-            wsk.delete(Trigger, "T1_221");
-            wsk.delete(Trigger, "T2_221");
-            wsk.delete(Rule, "R1_221");
-            wsk.delete(Rule, "R2_221");
-        }
-    }
-
-    /**
-     * rule test with one trigger and two actions
-     */
-    @Test
-    public void rule1to2() throws Exception {
-        try {
-            wsk.sanitize(Action, "A1_122");
-            wsk.sanitize(Action, "A2_122");
-            wsk.sanitize(Trigger, "T1_122");
-            wsk.sanitize(Rule, "R1_122");
-            wsk.sanitize(Rule, "R2_122");
-
-            wsk.createAction("A1_122", TestUtils.getCatalogFilename("samples/wc.js"));
-            wsk.createAction("A2_122", TestUtils.getCatalogFilename("samples/hello.js"));
-            wsk.createTrigger("T1_122");
-            wsk.createRule("R1_122", "T1_122", "A1_122");
-            wsk.createRule("R2_122", "T1_122", "A2_122");
-
-            long beforeTrigger = System.currentTimeMillis();
-            wsk.trigger("T1_122", "put a fork in it");
-
-            String expected1 = "The message 'put a fork in it' has";
-            assertTrue("Expected message not found: " + expected1, wsk.logsForActionContain("A1_122", expected1, beforeTrigger, DELAY));
-
-            String expected2 = "hello put a fork in it";
-            assertTrue("Expected message not found: " + expected2, wsk.logsForActionContain("A2_122", expected2, beforeTrigger, DELAY));
-
-        } finally {
-            wsk.delete(Action, "A1_122");
-            wsk.delete(Action, "A2_122");
-            wsk.delete(Trigger, "T1_122");
-            wsk.delete(Rule, "R1_122");
-            wsk.delete(Rule, "R2_122");
-        }
-    }
-
-    /**
-     * rule test with two triggers and two actions
-     */
-    @Test
-    public void rule2to2() throws Exception {
-        long startMilli = System.currentTimeMillis();
-        try {
-            wsk.sanitize(Action, "A1_222");
-            wsk.sanitize(Action, "A2_222");
-            wsk.sanitize(Trigger, "T1_222");
-            wsk.sanitize(Trigger, "T2_222");
-            wsk.sanitize(Rule, "Alpha");
-            wsk.sanitize(Rule, "Beta");
-            wsk.sanitize(Rule, "Gamma");
-            wsk.sanitize(Rule, "Delta");
-            long endMilli = System.currentTimeMillis();
-            System.out.format("rule2to2: %.1f seconds to sanitize\n", (endMilli - startMilli) / 1000.0);
-            startMilli = endMilli;
-
-            wsk.createAction("A1_222", TestUtils.getCatalogFilename("samples/wc.js"));
-            wsk.createAction("A2_222", TestUtils.getCatalogFilename("samples/hello.js"));
-            wsk.createTrigger("T1_222");
-            wsk.createTrigger("T2_222");
-            wsk.createRule("Alpha", "T1_222", "A1_222");
-            wsk.createRule("Beta", "T1_222", "A2_222");
-            wsk.createRule("Gamma", "T2_222", "A1_222");
-            wsk.createRule("Delta", "T2_222", "A2_222");
-            endMilli = System.currentTimeMillis();
-            System.out.format("rule2to2: %.1f seconds to create actions and rules\n", (endMilli - startMilli) / 1000.0);
-            startMilli = endMilli;
-
-            long beforeTrigger = System.currentTimeMillis();
-            wsk.trigger("T1_222", "XXX");
-            wsk.trigger("T2_222", "YYY");
-            endMilli = System.currentTimeMillis();
-            System.out.format("rule2to2: %.1f seconds to trigger\n", (endMilli - startMilli) / 1000.0);
-            startMilli = endMilli;
-
-            List<String> activations = wsk.waitForActivations("A1_222", 2, beforeTrigger, DELAY);
-            assertTrue("Not enough activation ids found", activations != null);
-
-            String expected1 = "The message 'XXX' has";
-            assertTrue("Expected message not found: " + expected1, wsk.logsForActionContain("A1_222", expected1, beforeTrigger, DELAY));
-            String expected2 = "The message 'YYY' has";
-            assertTrue("Expected message not found: " + expected2, wsk.logsForActionContain("A1_222", expected2, beforeTrigger, DELAY));
-            endMilli = System.currentTimeMillis();
-            System.out.format("rule2to2: %.1f seconds for first check\n", (endMilli - startMilli) / 1000.0);
-
-            startMilli = endMilli;
-
-            expected1 = "hello XXX";
-            expected2 = "hello YYY";
-            assertTrue("Expected message not found: " + expected1, wsk.logsForActionContain("A2_222", expected1, beforeTrigger, DELAY));
-            assertTrue("Expected message not found: " + expected2, wsk.logsForActionContain("A2_222", expected2, beforeTrigger, DELAY));
-            endMilli = System.currentTimeMillis();
-            System.out.format("rule2to2: %.1f seconds for second check\n", (endMilli - startMilli) / 1000.0);
-
-            startMilli = endMilli;
-        } finally {
-            wsk.delete(Action, "A1_222");
-            wsk.delete(Action, "A2_222");
-            wsk.delete(Trigger, "T1_222");
-            wsk.delete(Trigger, "T2_222");
-            wsk.delete(Rule, "Alpha");
-            wsk.delete(Rule, "Beta");
-            wsk.delete(Rule, "Gamma");
-            wsk.delete(Rule, "Delta");
-            long endMilli = System.currentTimeMillis();
-            System.out.format("rule2to2: %.1f seconds for cleanup\n", (endMilli - startMilli) / 1000.0);
-        }
-    }
-
-    /**
-     * rule test to make sure deleting a rule also disables it.
-     */
-    @Test
-    public void ruleDisable() throws Exception {
-        long startMilli = System.currentTimeMillis();
-        try {
-            wsk.sanitize(Action, "A_321");
-            wsk.sanitize(Trigger, "T_321");
-            wsk.sanitize(Rule, "R_321");
-            long endMilli = System.currentTimeMillis();
-            System.out.format("ruleDisable: %.1f seconds to sanitize\n", (endMilli - startMilli) / 1000.0);
-            startMilli = endMilli;
-
-            wsk.createAction("A_321", TestUtils.getCatalogFilename("samples/wc.js"));
-            wsk.createTrigger("T_321");
-            wsk.createRule("R_321", "T_321", "A_321");
-            wsk.delete(Rule, "R_321");
-            endMilli = System.currentTimeMillis();
-            System.out.format("ruleDisable: %.1f seconds to create and delete rule/action\n", (endMilli - startMilli) / 1000.0);
-            startMilli = endMilli;
-            wsk.trigger("T_321", "ralph");
-            endMilli = System.currentTimeMillis();
-            System.out.format("ruleDisable: %.1f seconds to trigger\n", (endMilli - startMilli) / 1000.0);
-            startMilli = endMilli;
-
-            // retrieve activation ids; wait for at least one
-            List<String> activations = wsk.waitForActivations("A_321", 1, startMilli, NEGATIVE_DELAY);
-            assertTrue("Unexpected activation id found: ", activations == null || activations.size() == 0);
-            endMilli = System.currentTimeMillis();
-            System.out.format("ruleDisable: %.1f seconds to get activation\n", (endMilli - startMilli) / 1000.0);
-            startMilli = endMilli;
-        } finally {
-            wsk.delete(Action, "A_321");
-            wsk.delete(Trigger, "T_321");
-            wsk.sanitize(Rule, "R_321");
-            long endMilli = System.currentTimeMillis();
-            System.out.format("ruleDisable: %.1f seconds to cleanup\n", (endMilli - startMilli) / 1000.0);
-        }
-    }
-
-    /**
-     * rule test to check if a rule can be deleted and recreated with the same
-     * name.
-     */
-    @Test
-    public void ruleRecreate() throws Exception {
-        try {
-            wsk.sanitize(Action, "A_421");
-            wsk.sanitize(Trigger, "T_421");
-            wsk.sanitize(Trigger, "T_422");
-            wsk.sanitize(Rule, "R_421");
-
-            wsk.createAction("A_421", TestUtils.getCatalogFilename("samples/wc.js"));
-            wsk.createTrigger("T_421");
-            wsk.createRule("R_421", "T_421", "A_421");
-            wsk.delete(Rule, "R_421");
-            wsk.createTrigger("T_422");
-            wsk.createRule("R_421", "T_422", "A_421");
-            long beforeTrigger = System.currentTimeMillis();
-            wsk.trigger("T_422", "david");
-
-            List<String> activations = wsk.waitForActivations("A_421", 1, beforeTrigger, NEGATIVE_DELAY);
-            if (activations == null || activations.size() == 0) {
-                assertFalse("Did not find any activations for A_421", true);
-                return;
-            }
-            String activationId = activations.get(0);
-            String expected = "The message 'david' has";
-            assertTrue("Expected message found: " + expected, wsk.logsForActivationContain(activationId, expected, DELAY));
-        } finally {
-            wsk.delete(Action, "A_421");
-            wsk.delete(Trigger, "T_421");
-            wsk.delete(Trigger, "T_422");
-            wsk.sanitize(Rule, "R_421");
-        }
-    }
-
-    /**
-     * rule test to check if a rule can be disable and enabled.
-     */
-    @Test
-    public void ruleDisableEnable() throws Exception {
-        try {
-            wsk.sanitize(Action, "A_621");
-            wsk.sanitize(Trigger, "T_621");
-            wsk.sanitize(Rule, "R_621");
-
-            wsk.createAction("A_621", TestUtils.getCatalogFilename("samples/wc.js"));
-            wsk.createTrigger("T_621");
-            wsk.createRule("R_621", "T_621", "A_621");
-
-            wsk.disableRule("R_621", RULE_DELAY);
-            wsk.trigger("T_621", "batman");
-
-            wsk.enableRule("R_621", RULE_DELAY);
-            long beforeTrigger = System.currentTimeMillis();
-            wsk.trigger("T_621", "bruce wayne");
-
-            List<String> activations = wsk.waitForActivations("A_621", 1, beforeTrigger, DELAY);
-            assertTrue("Not enough activation ids found", activations != null);
-
-            String activationId = activations.get(0);
-            String expected = "The message 'bruce wayne' has";
-            assertTrue("Expected message not found: " + expected, wsk.logsForActivationContain(activationId, expected, DELAY));
-
-            String unexpected = "The message 'batman' has";
-            assertFalse("Unexpected message found: " + unexpected, wsk.logsForActivationContain(activationId, unexpected, NEGATIVE_DELAY));
-        } finally {
-            wsk.delete(Action, "A_621");
-            wsk.delete(Trigger, "T_621");
-            wsk.sanitize(Rule, "R_621");
-        }
-    }
-
-    /**
-     * Test for presence of activation records for trigger, rule, and action.
-     */
-    @Test
-    public void activations() throws Exception {
-        int nameSuffix = ThreadLocalRandom.current().nextInt(Integer.MAX_VALUE);
-        String action = "ACT_A_" + nameSuffix;
-        String rule = "ACT_R_" + nameSuffix;
-        String trigger = "ACT_T_" + nameSuffix;
-
-        final class ActivationInfo {
-            public String activationId;
-            public String cause;
-
-            public ActivationInfo(String activationId, String cause) {
-                this.activationId = activationId;
-                this.cause = cause;
-            }
-
-            @Override
-            public String toString() {
-                return "ActivationInfo [activationId=" + activationId + ", cause=" + cause + "]";
-            }
-        }
-
-        try {
-            wsk.sanitize(Action, action);
-            wsk.sanitize(Trigger, trigger);
-            wsk.sanitize(Rule, rule);
-
-            wsk.createAction(action, TestUtils.getCatalogFilename("utils/date.js"));
-            wsk.createTrigger(trigger);
-            wsk.createRule(rule, trigger, action);
-            wsk.trigger(trigger, "bobby 121");
-
-            // Get activations
-            Set<String> entities = new HashSet<String>(Arrays.asList(new String[] { trigger, action, rule }));
-            Map<String, ActivationInfo> activations = TestUtils.waitfor(() -> {
-                String list = wsk.list(Activation);
-                String[] lines = list.split("\\r?\\n");
-                Map<String, ActivationInfo> infos = new HashMap<String, ActivationInfo>();
-                for (String line : lines) {
-                    String[] words = line.split("\\s+");
-                    if (words.length == 2) {
-                        String entityName = words[1];
-                        String activationId = words[0];
-                        if (entities.contains(entityName)) {
-                            String activation = wsk.get(Activation, activationId);
-                            // remove "ok" line in stdout; leaving json
-                            activation = activation.substring(activation.indexOf(System.getProperty("line.separator")) + 1);
-                            JsonObject json = new JsonParser().parse(activation).getAsJsonObject();
-                            String cause = json.get("cause") != null ? json.get("cause").getAsString() : "";
-                            infos.put(entityName, new ActivationInfo(activationId, cause));
-                        }
-                    }
-                }
-                return infos.size() == 3 ? infos : null;
-            } , 8, 1, DELAY);
-
-            // Check that activations exist.
-            assertTrue("Activation not found for " + trigger, activations.containsKey(trigger));
-            assertTrue("Activation not found for " + rule, activations.containsKey(rule));
-            assertTrue("Activation not found for " + action, activations.containsKey(action));
-
-            // Check that activation cause is correct.
-            assertTrue("Wrong cause found for " + trigger, activations.get(trigger).cause.equals(""));
-            assertTrue("Wrong cause found for " + rule, activations.get(rule).cause.equals(activations.get(trigger).activationId));
-            // assertTrue("Wrong cause found for " + action, activations.get(action).cause.equals(activations.get(rule).activationId));
-
-        } finally {
-            wsk.delete(Rule, rule);
-            wsk.delete(Action, action);
-            wsk.delete(Trigger, trigger);
-        }
-    }
-
-}
diff --git a/tests/src/system/basic/CLISequentialTests.java b/tests/src/system/basic/CLISequentialTests.java
deleted file mode 100644
index 01bbb4edc27..00000000000
--- a/tests/src/system/basic/CLISequentialTests.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright 2015-2016 IBM Corporation
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package system.basic;
-
-import static common.WskCli.Item.Action;
-import static common.WskCli.Item.Rule;
-import static common.WskCli.Item.Trigger;
-import static org.junit.Assert.assertTrue;
-
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-import common.TestUtils;
-import common.WskCli;
-
-/**
- * This tests suite does not use a parallel junit runner. This is intended for
- * testing system invariants such as concurrent activation counts and
- * thresholds.
- */
-public class CLISequentialTests {
-    private static final Boolean usePythonCLI = false;
-    private static final WskCli wsk = new WskCli(usePythonCLI);
-
-    @BeforeClass
-    public static void setUp() throws Exception {
-    }
-
-    /**
-     * Tests that a trigger connected to a deleted action does not cause a
-     * normal action to fail due to lingering errors such as limits not
-     * correctly tracking.
-     *
-     * To test that loadbalancer/invoker activation count is consistent, we emit
-     * slow enough not to be throttled by the controller.
-     *
-     * The concurrency limit of 100 is hardcoded for now because there is no
-     * query API.
-     */
-    @Test
-    public void ruleDeletedAction() throws Exception {
-        try {
-            wsk.sanitize(Action, "A_normal");
-            wsk.sanitize(Action, "A_del");
-            wsk.sanitize(Trigger, "T_del");
-            wsk.sanitize(Rule, "R_del");
-
-            wsk.createAction("A_normal", TestUtils.getCatalogFilename("samples/hello.js"));
-            wsk.createAction("A_del", TestUtils.getCatalogFilename("samples/wc.js"));
-            wsk.createTrigger("T_del");
-            wsk.createRule("R_del", "T_del", "A_del");
-            wsk.delete(Action, "A_del");
-
-            // Try to trip inconsistency in concurrent activation count of a
-            // broken trigger but not rate throttler
-            // The numbers are hardcoded because we currently have no API for
-            // setting or querying all limits.
-            // The threads are used so this test doesn't take too long (> 3 min)
-            // but we can't run too fast either (< 1 min).
-            final int LIMIT = 100; // concurrent limit
-            final int THREADS = 5;
-            Thread[] threads = new Thread[THREADS];
-            for (int i = 0; i < threads.length; i++) {
-                final int index = i; // for "closure"
-                threads[i] = new Thread() {
-                    public void run() {
-                        try {
-                            int ITERATIONS = 1 + (LIMIT / THREADS);
-                            System.out.println("Thread " + index + ". Running part 1 at " + System.currentTimeMillis());
-                            for (int j = 0; j < 1 + ITERATIONS / 2; j++)
-                                wsk.triggerNoCheck("T_del", "deletePayload_1_" + j);
-                            Thread.sleep(30 * 1000); // so as to not trigger
-                                                     // per-minute throttle
-                            System.out.println("Thread " + index + ". Running part 2 at " + System.currentTimeMillis());
-                            for (int j = 0; j < 1 + ITERATIONS / 2; j++)
-                                wsk.triggerNoCheck("T_del", "deletePayload_2_" + j);
-                            System.out.println("Thread " + index + ". Done at " + System.currentTimeMillis());
-                        } catch (Exception e) {
-                            System.out.println("Exception: " + e);
-                        }
-                    }
-                };
-                threads[i].start();
-            }
-            for (int i = 0; i < threads.length; i++) {
-                threads[i].join();
-            }
-            Thread.sleep(5 * 1000); // allow triggers and counts to propagate so
-                                    // we can test throttle
-
-            // Check that it's working normally
-            String expected = "A_normal_payload";
-            System.out.println("Now running unrelated activation at " + System.currentTimeMillis());
-            String activationId = wsk.invoke("A_normal", TestUtils.makeParameter("payload", expected));
-            boolean found = wsk.logsForActivationContain(activationId, expected, 45);
-            System.out.println("Log: " + wsk.getLogsForActivation(activationId).stdout);
-            assertTrue("Did not find " + expected + " in activation " + activationId, found);
-
-        } finally {
-            wsk.sanitize(Action, "A_normal");
-            wsk.sanitize(Action, "A_del");
-            wsk.sanitize(Trigger, "T_del");
-            wsk.sanitize(Rule, "R_del");
-        }
-    }
-
-}
diff --git a/tests/src/system/basic/PackageTests.scala b/tests/src/system/basic/PackageTests.scala
index 2421da97cb7..b312856cc3c 100644
--- a/tests/src/system/basic/PackageTests.scala
+++ b/tests/src/system/basic/PackageTests.scala
@@ -122,7 +122,7 @@ class PackageTests
             val now = new Date().toString()
             val run = wsk.action.invoke(bindActionName, Map("payload" -> now.toJson))
             withActivation(wsk.activation, run, totalWait = LOG_DELAY) {
-                _.fields("logs").toString should include regex (
+                _.logs.get.mkString(" ") should include regex (
                     String.format(".*key0: value0.*key1a: value1a.*key1b: value2b.*key2a: value2a.*payload: %s", now))
             }
     }
diff --git a/tests/src/system/basic/Swift3WhiskObjectTests.scala b/tests/src/system/basic/Swift3WhiskObjectTests.scala
index c0fcfe220bc..8ed55c30174 100644
--- a/tests/src/system/basic/Swift3WhiskObjectTests.scala
+++ b/tests/src/system/basic/Swift3WhiskObjectTests.scala
@@ -27,7 +27,6 @@ import common.TestUtils
 import common.Wsk
 import common.WskProps
 import common.WskTestHelpers
-import spray.json.DefaultJsonProtocol.BooleanJsonFormat
 import spray.json.DefaultJsonProtocol.StringJsonFormat
 import spray.json.pimpAny
 import common.JsHelpers
@@ -57,13 +56,13 @@ class Swift3WhiskObjectTests
             withActivation(wsk.activation, run, initialWait = 5 seconds, totalWait = 60 seconds) {
                 activation =>
                     // should be successful
-                    activation.fields("response").asJsObject.fields("success") should be(true.toJson)
+                    activation.response.success shouldBe true
 
                     // should have a field named "activationId" which is the date action's activationId
-                    activation.fields("response").asJsObject.fields("result").asJsObject.fields("activationId").toString.length should be >= 32
+                    activation.response.result.get.fields("activationId").toString.length should be >= 32
 
                     // check for "date" field that comes from invoking the date action
-                    activation.fieldPathExists("response", "result", "response", "result", "date") should be(true)
+                    activation.response.result.get.fieldPathExists("response", "result", "date") should be(true)
             }
     }
 
@@ -87,10 +86,10 @@ class Swift3WhiskObjectTests
             withActivation(wsk.activation, run, initialWait = 5 seconds, totalWait = 60 seconds) {
                 activation =>
                     // should be successful
-                    activation.fields("response").asJsObject.fields("success") should be(true.toJson)
+                    activation.response.success shouldBe true
 
                     // should have a field named "activationId" which is the date action's activationId
-                    activation.fields("response").asJsObject.fields("result").asJsObject.fields("activationId").toString.length should be >= 32
+                    activation.response.result.get.fields("activationId").toString.length should be >= 32
 
                     // should result in an activation for triggerName
                     val triggerActivations = wsk.activation.pollFor(1, Some(triggerName), retries = 20)
diff --git a/tests/src/system/basic/WskActionSequenceTests.scala b/tests/src/system/basic/WskActionSequenceTests.scala
index c6a2e1e3f65..50f3b284972 100644
--- a/tests/src/system/basic/WskActionSequenceTests.scala
+++ b/tests/src/system/basic/WskActionSequenceTests.scala
@@ -71,11 +71,10 @@ class WskActionSequenceTests
             val run = wsk.action.invoke(name, Map("payload" -> args.mkString("\n").toJson))
             withActivation(wsk.activation, run, totalWait = allowedActionDuration) {
                 activation =>
-                    activation.getFieldPath("response", "result", "payload") shouldBe defined
-                    activation.getFieldPath("response", "result", "length") should not be defined
-                    activation.getFieldPath("response", "result", "lines") should be(Some {
-                        Array(now).toJson
-                    })
+                    val result = activation.response.result.get
+                    result.fields.get("payload") shouldBe defined
+                    result.fields.get("length") should not be defined
+                    result.fields.get("lines") shouldBe Some(JsArray(Vector(now.toJson)))
             }
 
             // update action sequence
@@ -84,10 +83,9 @@ class WskActionSequenceTests
             val secondrun = wsk.action.invoke(name, Map("payload" -> args.mkString("\n").toJson))
             withActivation(wsk.activation, secondrun, totalWait = allowedActionDuration) {
                 activation =>
-                    activation.getFieldPath("response", "result", "length") should be(Some(2.toJson))
-                    activation.getFieldPath("response", "result", "lines") should be(Some {
-                        args.sortWith(_.compareTo(_) < 0).toArray.toJson
-                    })
+                    val result = activation.response.result.get
+                    result.fields.get("length") shouldBe Some(2.toJson)
+                    result.fields.get("lines") shouldBe Some(args.sortWith(_.compareTo(_) < 0).toArray.toJson)
             }
     }
 
diff --git a/tests/src/system/basic/WskActionTests.scala b/tests/src/system/basic/WskActionTests.scala
new file mode 100644
index 00000000000..fc14ebf6e39
--- /dev/null
+++ b/tests/src/system/basic/WskActionTests.scala
@@ -0,0 +1,268 @@
+/*
+ * Copyright 2015-2016 IBM Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package system.basic
+
+import org.junit.runner.RunWith
+import org.scalatest.junit.JUnitRunner
+
+import common.JsHelpers
+import common.TestHelpers
+import common.TestUtils
+import common.Wsk
+import common.WskProps
+import common.WskTestHelpers
+import spray.json._
+import spray.json.DefaultJsonProtocol._
+import spray.json.JsObject
+import spray.json.pimpAny
+
+@RunWith(classOf[JUnitRunner])
+class WskActionTests
+    extends TestHelpers
+    with WskTestHelpers
+    with JsHelpers {
+
+    implicit val wskprops = WskProps()
+    val wsk = new Wsk(usePythonCLI = false)
+
+    val testString = "this is a test"
+    val testResult = JsObject("count" -> testString.split(" ").length.toJson)
+
+    behavior of "Whisk actions"
+
+    it should "invoke an action with a space in the name" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val name = "hello Async"
+            assetHelper.withCleaner(wsk.action, name) {
+                (action, _) => action.create(name, Some(TestUtils.getCatalogFilename("samples/helloAsync.js")))
+            }
+
+            val run = wsk.action.invoke(name, Map("payload" -> testString.toJson))
+            withActivation(wsk.activation, run) {
+                activation =>
+                    activation.response.status shouldBe "success"
+                    activation.response.result shouldBe Some(testResult)
+                    activation.logs.get.mkString(" ") should include(testString)
+            }
+    }
+
+    it should "pass parameters bound on creation-time to the action" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val name = "printParams"
+            val params = Map(
+                "param1" -> "test1",
+                "param2" -> "test2")
+
+            assetHelper.withCleaner(wsk.action, name) {
+                (action, _) =>
+                    action.create(
+                        name,
+                        Some(TestUtils.getCatalogFilename("samples/printParams.js")),
+                        parameters = params.mapValues(_.toJson))
+            }
+
+            val invokeParams = Map("payload" -> testString)
+            val run = wsk.action.invoke(name, invokeParams.mapValues(_.toJson))
+            withActivation(wsk.activation, run) {
+                activation =>
+                    val logs = activation.logs.get.mkString(" ")
+
+                    (params ++ invokeParams).foreach {
+                        case (key, value) =>
+                            logs should include(s"params.$key: $value")
+                    }
+            }
+    }
+
+    it should "copy an action and invoke it successfully" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val name = "copied"
+            assetHelper.withCleaner(wsk.action, name) {
+                (action, _) => action.create(name, Some("/whisk.system/samples/wordCount"), Some("copy"))
+            }
+
+            val run = wsk.action.invoke(name, Map("payload" -> testString.toJson))
+            withActivation(wsk.activation, run) {
+                activation =>
+                    activation.response.status shouldBe "success"
+                    activation.response.result shouldBe Some(testResult)
+                    activation.logs.get.mkString(" ") should include(testString)
+            }
+    }
+
+    it should "recreate and invoke a new action with different code" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val name = "recreatedAction"
+            assetHelper.withCleaner(wsk.action, name, false) {
+                (action, _) => action.create(name, Some(TestUtils.getCatalogFilename("samples/wc.js")))
+            }
+
+            val run1 = wsk.action.invoke(name, Map("payload" -> testString.toJson))
+            withActivation(wsk.activation, run1) {
+                activation =>
+                    activation.response.status shouldBe "success"
+                    activation.logs.get.mkString(" ") should include(s"The message '$testString' has")
+            }
+
+            wsk.action.delete(name)
+            assetHelper.withCleaner(wsk.action, name) {
+                (action, _) => action.create(name, Some(TestUtils.getCatalogFilename("samples/hello.js")))
+            }
+
+            val run2 = wsk.action.invoke(name, Map("payload" -> testString.toJson))
+            withActivation(wsk.activation, run2) {
+                activation =>
+                    activation.response.status shouldBe "success"
+                    activation.logs.get.mkString(" ") should include(s"hello $testString")
+            }
+    }
+
+    it should "fail to invoke an action with an empty file" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val name = "empty"
+            assetHelper.withCleaner(wsk.action, name) {
+                (action, _) => action.create(name, Some(TestUtils.getTestActionFilename("empty.js")))
+            }
+            val run = wsk.action.invoke(name)
+            withActivation(wsk.activation, run) {
+                activation =>
+                    activation.response.status shouldBe "action developer error"
+                    activation.response.result shouldBe Some(JsObject("error" -> "Missing main/no code to execute.".toJson))
+            }
+    }
+
+    it should "create an action with an empty file" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val name = "empty"
+            assetHelper.withCleaner(wsk.action, name) {
+                (action, _) => action.create(name, Some(TestUtils.getTestActionFilename("empty.js")))
+            }
+            val rr = wsk.action.get(name)
+            wsk.parseJsonString(rr.stdout).getFieldPath("exec", "code") shouldBe Some(JsString(""))
+    }
+
+    it should "blocking invoke nested blocking actions" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val name = "nestedBlockingAction"
+            val child = "wc"
+
+            assetHelper.withCleaner(wsk.action, name) {
+                (action, _) => action.create(name, Some(TestUtils.getCatalogFilename("samples/wcbin.js")))
+            }
+            assetHelper.withCleaner(wsk.action, child) {
+                (action, _) => action.create(child, Some(TestUtils.getCatalogFilename("samples/wc.js")))
+            }
+
+            val run = wsk.action.invoke(name, Map("payload" -> testString.toJson), blocking = true)
+            val activation = wsk.parseJsonString(run.stdout).convertTo[CliActivation]
+
+            withClue(s"check failed for activation: $activation") {
+                val wordCount = testString.split(" ").length
+                activation.response.result.get shouldBe JsObject("binaryCount" -> s"${wordCount.toBinaryString} (base 2)".toJson)
+            }
+    }
+
+    it should "blocking invoke an asynchronous action" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val name = "helloAsync"
+            assetHelper.withCleaner(wsk.action, name) {
+                (action, _) => action.create(name, Some(TestUtils.getCatalogFilename("samples/helloAsync.js")))
+            }
+
+            val run = wsk.action.invoke(name, Map("payload" -> testString.toJson), blocking = true)
+            val activation = wsk.parseJsonString(run.stdout).convertTo[CliActivation]
+
+            withClue(s"check failed for activation: $activation") {
+                activation.response.status shouldBe "success"
+                activation.response.result shouldBe Some(testResult)
+                activation.logs shouldBe None
+            }
+    }
+
+    it should "return the value of the first synchronous whisk.done()" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val name = "helloSyncDoneTwice"
+            assetHelper.withCleaner(wsk.action, name) {
+                (action, _) => action.create(name, Some(TestUtils.getTestActionFilename("helloSyncDoneTwice.js")))
+            }
+
+            val run = wsk.action.invoke(name, Map("payload" -> testString.toJson))
+            withActivation(wsk.activation, run) {
+                activation =>
+                    activation.response.status shouldBe "success"
+                    activation.response.result shouldBe Some(testResult)
+                    activation.logs.get.mkString(" ") should include(testString)
+            }
+    }
+
+    it should "return the value of the first asynchronous whisk.done()" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val name = "helloSyncDoneTwice"
+            assetHelper.withCleaner(wsk.action, name) {
+                (action, _) => action.create(name, Some(TestUtils.getTestActionFilename("helloAsyncDoneTwice.js")))
+            }
+
+            val run = wsk.action.invoke(name, Map("payload" -> testString.toJson))
+            withActivation(wsk.activation, run) {
+                activation =>
+                    activation.response.status shouldBe "success"
+                    activation.response.result shouldBe Some(testResult)
+                    activation.logs.get.mkString(" ") should include(testString)
+            }
+    }
+
+    it should "reject an invoke with the wrong parameters set" in {
+        val payload = "bob"
+        val rr = wsk.cli(Seq("action", "invoke", "/whisk.system/samples/helloWorld", payload), expectedExitCode = TestUtils.ANY_ERROR_EXIT)
+        rr.exitCode shouldBe 1
+        rr.stderr should include("Run 'wsk --help' for usage.")
+        rr.stderr should include(s"error: Invalid argument(s): $payload")
+    }
+
+    it should "not be able to use 'ping' in an action" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val name = "ping"
+            assetHelper.withCleaner(wsk.action, name) {
+                (action, _) => action.create(name, Some(TestUtils.getTestActionFilename("ping.js")))
+            }
+
+            val run = wsk.action.invoke(name, Map("payload" -> "google.com".toJson))
+            withActivation(wsk.activation, run) {
+                activation =>
+                    activation.response.result shouldBe Some(JsObject(
+                        "stderr" -> "ping: icmp open socket: Operation not permitted\n".toJson,
+                        "stdout" -> "".toJson))
+            }
+    }
+
+    ignore should "support UTF-8 as input and output format" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val name = "utf8Test"
+            assetHelper.withCleaner(wsk.action, name) {
+                (action, _) => action.create(name, Some(TestUtils.getCatalogFilename("samples/hello.js")))
+            }
+
+            val utf8 = "«ταБЬℓσö»: 1<2 & 4+1>³, now 20%€§$ off!"
+            val run = wsk.action.invoke(name, Map("payload" -> utf8.toJson))
+            withActivation(wsk.activation, run) {
+                activation =>
+                    activation.response.status shouldBe "success"
+                    activation.logs.get.mkString(" ") should include(s"hello $utf8")
+            }
+    }
+
+}
diff --git a/tests/src/system/basic/WskBasicNodeTests.scala b/tests/src/system/basic/WskBasicNodeTests.scala
index e72eba471f9..ca4075a3a42 100644
--- a/tests/src/system/basic/WskBasicNodeTests.scala
+++ b/tests/src/system/basic/WskBasicNodeTests.scala
@@ -26,7 +26,6 @@ import common.TestUtils
 import common.Wsk
 import common.WskProps
 import common.WskTestHelpers
-import spray.json.DefaultJsonProtocol.BooleanJsonFormat
 import spray.json.DefaultJsonProtocol.StringJsonFormat
 import spray.json.pimpAny
 import spray.json.pimpString
@@ -35,9 +34,9 @@ import spray.json.JsObject
 
 @RunWith(classOf[JUnitRunner])
 class WskBasicNodeTests
-        extends TestHelpers
-        with WskTestHelpers
-        with JsHelpers {
+    extends TestHelpers
+    with WskTestHelpers
+    with JsHelpers {
 
     implicit val wskprops = WskProps()
     val wsk = new Wsk()
@@ -108,9 +107,10 @@ class WskBasicNodeTests
             val runResolve = wsk.action.invoke(invokeActionName, Map("resolveOrReject" -> "resolve".toJson))
             withActivation(wsk.activation, runResolve) {
                 activation =>
-                    activation.getFieldPath("response", "result", "activationId") shouldBe defined
-                    activation.getFieldPath("response", "result", "error") should not be defined
-                    activation.getFieldPath("response", "result", "result", "message") should be(Some {
+                    val result = activation.response.result.get
+                    result.fields.get("activationId") shouldBe defined
+                    result.fields.get("error") should not be defined
+                    result.getFieldPath("result", "message") should be(Some {
                         "Three second rule!".toJson
                     })
 
@@ -122,8 +122,9 @@ class WskBasicNodeTests
             val runReject = wsk.action.invoke(invokeActionName, Map("resolveOrReject" -> "reject".toJson))
             withActivation(wsk.activation, runReject) {
                 activation =>
-                    activation.getFieldPath("response", "result", "activationId") should not be defined
-                    activation.getFieldPath("response", "result", "error") shouldBe defined
+                    val result = activation.response.result.get
+                    result.fields.get("activationId") should not be defined
+                    result.fields.get("error") shouldBe defined
 
                     val duration = System.currentTimeMillis() - start
                     duration should be >= expectedDuration.toMillis
@@ -155,9 +156,10 @@ class WskBasicNodeTests
             val runResolve = wsk.action.invoke(invokeActionName, Map("resolveOrReject" -> "resolve".toJson))
             withActivation(wsk.activation, runResolve) {
                 activation =>
-                    activation.getFieldPath("response", "result", "activationId") shouldBe defined
-                    activation.getFieldPath("response", "result", "error") should not be defined
-                    activation.getFieldPath("response", "result", "result", "message") should be(Some {
+                    val result = activation.response.result.get
+                    result.fields.get("activationId") shouldBe defined
+                    result.fields.get("error") should not be defined
+                    result.getFieldPath("result", "message") should be(Some {
                         "Three second rule!".toJson
                     })
 
@@ -169,8 +171,9 @@ class WskBasicNodeTests
             val runReject = wsk.action.invoke(invokeActionName, Map("resolveOrReject" -> "reject".toJson))
             withActivation(wsk.activation, runReject) {
                 activation =>
-                    activation.getFieldPath("response", "result", "activationId") should not be defined
-                    activation.getFieldPath("response", "result", "error") shouldBe defined
+                    val result = activation.response.result.get
+                    result.fields.get("activationId") should not be defined
+                    result.fields.get("error") shouldBe defined
 
                     val duration = System.currentTimeMillis() - start
                     duration should be >= expectedDuration.toMillis
@@ -192,8 +195,8 @@ class WskBasicNodeTests
             val runReject = wsk.action.invoke(nameOfActionThatTriggers)
             withActivation(wsk.activation, runReject) {
                 activation =>
-                    activation.getFieldPath("response", "success") shouldBe Some(false.toJson)
-                    activation.getFieldPath("response", "result", "error") shouldBe defined
+                    activation.response.success shouldBe false
+                    activation.response.result.get.fields.get("error") shouldBe defined
             }
 
             val triggerName = "UnitTestTrigger"
@@ -207,8 +210,8 @@ class WskBasicNodeTests
             val runResolve = wsk.action.invoke(nameOfActionThatTriggers)
             withActivation(wsk.activation, runResolve) {
                 activation =>
-                    activation.getFieldPath("response", "success") shouldBe Some(true.toJson)
-                    activation.getFieldPath("response", "result", "activationId") shouldBe defined
+                    activation.response.success shouldBe true
+                    activation.response.result.get.fields.get("activationId") shouldBe defined
             }
     }
 
@@ -227,8 +230,8 @@ class WskBasicNodeTests
             val runReject = wsk.action.invoke(nameOfActionThatTriggers)
             withActivation(wsk.activation, runReject) {
                 activation =>
-                    activation.getFieldPath("response", "success") shouldBe Some(false.toJson)
-                    activation.getFieldPath("response", "result", "error") shouldBe defined
+                    activation.response.success shouldBe false
+                    activation.response.result.get.fields.get("error") shouldBe defined
             }
 
             val triggerName = "UnitTestTrigger"
@@ -242,8 +245,8 @@ class WskBasicNodeTests
             val runResolve = wsk.action.invoke(nameOfActionThatTriggers)
             withActivation(wsk.activation, runResolve) {
                 activation =>
-                    activation.getFieldPath("response", "success") shouldBe Some(true.toJson)
-                    activation.getFieldPath("response", "result", "activationId") shouldBe defined
+                    activation.response.success shouldBe true
+                    activation.response.result.get.fields.get("activationId") shouldBe defined
             }
     }
 
diff --git a/tests/src/system/basic/WskBasicTests.scala b/tests/src/system/basic/WskBasicTests.scala
index 25dd57705a3..b95595010d5 100644
--- a/tests/src/system/basic/WskBasicTests.scala
+++ b/tests/src/system/basic/WskBasicTests.scala
@@ -18,8 +18,6 @@ package system.basic
 
 import java.time.Instant
 
-import scala.concurrent.duration.DurationInt
-
 import org.junit.runner.RunWith
 import org.scalatest.junit.JUnitRunner
 
@@ -169,9 +167,9 @@ class WskBasicTests
             val run = wsk.action.invoke(name, args)
             withActivation(wsk.activation, run) {
                 activation =>
-                    val result = activation.fields("response").asJsObject.fields("result").asJsObject
-                    result.fields("args") shouldBe args.toJson
-                    result.fields("msg") shouldBe "Hello from arbitrary C program!".toJson
+                    activation.response.result shouldBe Some(JsObject(
+                        "args" -> args.toJson,
+                        "msg" -> "Hello from arbitrary C program!".toJson))
             }
     }
 
@@ -191,9 +189,9 @@ class WskBasicTests
             val run = wsk.action.invoke(name, Map("payload" -> "whatever".toJson))
             withActivation(wsk.activation, run) {
                 activation =>
-                    activation.fields("response").asJsObject.fields("status") should be("action developer error".toJson)
+                    activation.response.status shouldBe "action developer error"
                     // representing nodejs giving an error when given malformed.js
-                    activation.fields("response").asJsObject.toString should include("ReferenceError")
+                    activation.response.result.get.toString should include("ReferenceError")
             }
     }
 
@@ -243,8 +241,8 @@ class WskBasicTests
             val run = wsk.trigger.fire(name, dynamicParams)
             withActivation(wsk.activation, run) {
                 activation =>
-                    activation.fields("response").asJsObject.fields("result") should be(dynamicParams.toJson)
-                    activation.fields("end") should be(Instant.EPOCH.toEpochMilli.toJson)
+                    activation.response.result shouldBe Some(dynamicParams.toJson)
+                    activation.end shouldBe Instant.EPOCH.toEpochMilli
             }
 
             wsk.trigger.list().stdout should include(name)
@@ -273,7 +271,7 @@ class WskBasicTests
             wsk.rule.create(ruleName, trigger = triggerName, action = actionName, update = true, expectedExitCode = CONFLICT)
 
             // now, we disable the rule, so that we can perform the actual update
-            wsk.rule.disableRule(ruleName, 30.seconds);
+            wsk.rule.disableRule(ruleName);
 
             // finally, we perform the update, and expect success this time
             wsk.rule.create(ruleName, trigger = triggerName, action = actionName, update = true)
diff --git a/tests/src/system/basic/WskRuleTests.scala b/tests/src/system/basic/WskRuleTests.scala
new file mode 100644
index 00000000000..d7a6f4df847
--- /dev/null
+++ b/tests/src/system/basic/WskRuleTests.scala
@@ -0,0 +1,290 @@
+/*
+ * Copyright 2015-2016 IBM Corporation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package system.basic
+
+import org.junit.runner.RunWith
+import org.scalatest.junit.JUnitRunner
+
+import common.JsHelpers
+import common.TestHelpers
+import common.TestUtils
+import common.Wsk
+import common.WskProps
+import common.WskTestHelpers
+import spray.json._
+import spray.json.DefaultJsonProtocol._
+import java.time.Instant
+
+@RunWith(classOf[JUnitRunner])
+class WskRuleTests
+    extends TestHelpers
+    with JsHelpers
+    with WskTestHelpers {
+
+    implicit val wskprops = WskProps()
+    val wsk = new Wsk(usePythonCLI = false)
+    val defaultAction = TestUtils.getCatalogFilename("samples/wc.js")
+    val secondAction = TestUtils.getCatalogFilename("samples/hello.js")
+
+    val testString = "this is a test"
+    val testResult = JsObject("count" -> testString.split(" ").length.toJson)
+
+    /**
+     * Sets up trigger -> rule -> action triplets. Deduplicates triggers and rules
+     * and links it all up.
+     *
+     * @param rules Tuple3s containing (rule, trigger, (actionName, actionFile))
+     */
+    def ruleSetup(rules: Seq[(String, String, (String, String))], assetHelper: AssetCleaner) = {
+        val triggers = rules.map(_._2).distinct
+        val actions = rules.map(_._3).distinct
+
+        triggers.foreach { trigger =>
+            assetHelper.withCleaner(wsk.trigger, trigger) {
+                (trigger, name) => trigger.create(name)
+            }
+        }
+
+        actions.foreach {
+            case (actionName, file) =>
+                assetHelper.withCleaner(wsk.action, actionName) {
+                    (action, name) => action.create(name, Some(file))
+                }
+        }
+
+        rules.foreach {
+            case (ruleName, triggerName, action) =>
+                assetHelper.withCleaner(wsk.rule, ruleName) {
+                    (rule, name) => rule.create(name, triggerName, action._1)
+                }
+        }
+    }
+
+    behavior of "Whisk rules"
+
+    it should "invoke the action attached on trigger fire, creating an activation for each entity including the cause" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val ruleName = "r1to1"
+            val triggerName = "t1to1"
+            val actionName = "a1 to 1" // spaces in name intended for greater test coverage
+
+            ruleSetup(Seq(
+                (ruleName, triggerName, (actionName, defaultAction))),
+                assetHelper)
+
+            val now = Instant.now
+            val run = wsk.trigger.fire(triggerName, Map("payload" -> testString.toJson))
+
+            withActivation(wsk.activation, run) {
+                triggerActivation =>
+                    triggerActivation.cause shouldBe None
+
+                    withActivationsFromEntity(wsk.activation, ruleName, since = Some(Instant.ofEpochMilli(triggerActivation.start))) {
+                        _.head.cause shouldBe Some(triggerActivation.activationId)
+                    }
+
+                    withActivationsFromEntity(wsk.activation, actionName, since = Some(Instant.ofEpochMilli(triggerActivation.start))) {
+                        _.head.response.result shouldBe Some(testResult)
+                    }
+            }
+    }
+
+    it should "not activate an action if the rule is deleted when the trigger is fired" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val ruleName = "ruleDelete"
+            val triggerName = "ruleDeleteTrigger"
+            val actionName = "ruleDeleteAction"
+
+            assetHelper.withCleaner(wsk.trigger, triggerName) {
+                (trigger, name) => trigger.create(name)
+            }
+            assetHelper.withCleaner(wsk.action, actionName) {
+                (action, name) => action.create(name, Some(defaultAction))
+            }
+            assetHelper.withCleaner(wsk.rule, ruleName, false) {
+                (rule, name) => rule.create(name, triggerName, actionName)
+            }
+
+            val first = wsk.trigger.fire(triggerName, Map("payload" -> "bogus".toJson))
+            wsk.rule.delete(ruleName)
+            wsk.trigger.fire(triggerName, Map("payload" -> "bogus2".toJson))
+
+            withActivation(wsk.activation, first) {
+                activation =>
+                    // tries to find 2 activations for the action, should only find 1
+                    val activations = wsk.activation.pollFor(2, Some(actionName), since = Some(Instant.ofEpochMilli(activation.start)), retries = 30)
+
+                    activations.length shouldBe 1
+            }
+    }
+
+    it should "enable and disable a rule and check action is activated only when rule is enabled" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val ruleName = "ruleDisable"
+            val triggerName = "ruleDisableTrigger"
+            val actionName = "ruleDisableAction"
+
+            ruleSetup(Seq(
+                (ruleName, triggerName, (actionName, defaultAction))),
+                assetHelper)
+
+            val first = wsk.trigger.fire(triggerName, Map("payload" -> testString.toJson))
+            wsk.rule.disableRule(ruleName)
+            wsk.trigger.fire(triggerName, Map("payload" -> s"$testString with added words".toJson))
+            wsk.rule.enableRule(ruleName)
+            wsk.trigger.fire(triggerName, Map("payload" -> testString.toJson))
+
+            withActivation(wsk.activation, first) {
+                triggerActivation =>
+                    withActivationsFromEntity(wsk.activation, actionName, N = 2, since = Some(Instant.ofEpochMilli(triggerActivation.start))) {
+                        activations =>
+                            val results = activations.map(_.response.result)
+                            results should contain theSameElementsAs Seq(Some(testResult), Some(testResult))
+                    }
+            }
+    }
+
+    it should "be able to recreate a rule with the same name and match it successfully" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val ruleName = "ruleRecreate"
+            val triggerName1 = "ruleRecreateTrigger1"
+            val triggerName2 = "ruleRecreateTrigger2"
+            val actionName = "ruleRecreateAction"
+
+            assetHelper.withCleaner(wsk.trigger, triggerName1) {
+                (trigger, name) => trigger.create(name)
+            }
+            assetHelper.withCleaner(wsk.action, actionName) {
+                (action, name) => action.create(name, Some(defaultAction))
+            }
+            assetHelper.withCleaner(wsk.rule, ruleName, false) {
+                (rule, name) => rule.create(name, triggerName1, actionName)
+            }
+
+            wsk.rule.delete(ruleName)
+
+            assetHelper.withCleaner(wsk.trigger, triggerName2) {
+                (trigger, name) => trigger.create(name)
+            }
+            assetHelper.withCleaner(wsk.rule, ruleName) {
+                (rule, name) => rule.create(name, triggerName2, actionName)
+            }
+
+            val first = wsk.trigger.fire(triggerName2, Map("payload" -> testString.toJson))
+            withActivation(wsk.activation, first) {
+                triggerActivation =>
+                    withActivationsFromEntity(wsk.activation, actionName, since = Some(Instant.ofEpochMilli(triggerActivation.start))) {
+                        _.head.response.result shouldBe Some(testResult)
+                    }
+            }
+    }
+
+    it should "connect two triggers via rules to one action and activate it accordingly" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val triggerName1 = "t2to1a"
+            val triggerName2 = "t2to1b"
+            val actionName = "a2to1"
+
+            ruleSetup(Seq(
+                ("r2to1a", triggerName1, (actionName, defaultAction)),
+                ("r2to1b", triggerName2, (actionName, defaultAction))),
+                assetHelper)
+
+            val testPayloads = Seq("got three words", "got four words, period")
+
+            val run = wsk.trigger.fire(triggerName1, Map("payload" -> testPayloads(0).toJson))
+            wsk.trigger.fire(triggerName2, Map("payload" -> testPayloads(1).toJson))
+
+            withActivation(wsk.activation, run) {
+                triggerActivation =>
+                    withActivationsFromEntity(wsk.activation, actionName, N = 2, since = Some(Instant.ofEpochMilli(triggerActivation.start))) {
+                        activations =>
+                            val results = activations.map(_.response.result)
+                            val expectedResults = testPayloads.map { payload =>
+                                Some(JsObject("count" -> payload.split(" ").length.toJson))
+                            }
+
+                            results should contain theSameElementsAs expectedResults
+                    }
+            }
+    }
+
+    it should "connect one trigger to two different actions, invoking them both eventually" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val triggerName = "t1to2"
+            val actionName1 = "a1to2a"
+            val actionName2 = "a1to2b"
+
+            ruleSetup(Seq(
+                ("r1to2a", triggerName, (actionName1, defaultAction)),
+                ("r1to2b", triggerName, (actionName2, secondAction))),
+                assetHelper)
+
+            val run = wsk.trigger.fire(triggerName, Map("payload" -> testString.toJson))
+
+            withActivation(wsk.activation, run) {
+                triggerActivation =>
+                    withActivationsFromEntity(wsk.activation, actionName1, since = Some(Instant.ofEpochMilli(triggerActivation.start))) {
+                        _.head.response.result shouldBe Some(testResult)
+                    }
+                    withActivationsFromEntity(wsk.activation, actionName2, since = Some(Instant.ofEpochMilli(triggerActivation.start))) {
+                        _.head.logs.get.mkString(" ") should include(s"hello $testString")
+                    }
+            }
+    }
+
+    it should "connect two triggers to two different actions, invoking them both eventually" in withAssetCleaner(wskprops) {
+        (wp, assetHelper) =>
+            val triggerName1 = "t1to2a"
+            val triggerName2 = "t1to2b"
+            val actionName1 = "a1to2a"
+            val actionName2 = "a1to2b"
+
+            ruleSetup(Seq(
+                ("r2to2a", triggerName1, (actionName1, defaultAction)),
+                ("r2to2b", triggerName1, (actionName2, secondAction)),
+                ("r2to2c", triggerName2, (actionName1, defaultAction)),
+                ("r2to2d", triggerName2, (actionName2, secondAction))),
+                assetHelper)
+
+            val testPayloads = Seq("got three words", "got four words, period")
+            val run = wsk.trigger.fire(triggerName1, Map("payload" -> testPayloads(0).toJson))
+            wsk.trigger.fire(triggerName2, Map("payload" -> testPayloads(1).toJson))
+
+            withActivation(wsk.activation, run) {
+                triggerActivation =>
+                    withActivationsFromEntity(wsk.activation, actionName1, N = 2, since = Some(Instant.ofEpochMilli(triggerActivation.start))) {
+                        activations =>
+                            val results = activations.map(_.response.result)
+                            val expectedResults = testPayloads.map { payload =>
+                                Some(JsObject("count" -> payload.split(" ").length.toJson))
+                            }
+
+                            results should contain theSameElementsAs expectedResults
+                    }
+                    withActivationsFromEntity(wsk.activation, actionName2, N = 2, since = Some(Instant.ofEpochMilli(triggerActivation.start))) {
+                        activations =>
+                            // drops the leftmost 39 characters (timestamp + streamname)
+                            val logs = activations.map(_.logs.get.map(_.drop(39))).flatten
+                            val expectedLogs = testPayloads.map { payload => s"hello $payload!" }
+
+                            logs should contain theSameElementsAs expectedLogs
+                    }
+            }
+    }
+
+}
diff --git a/tests/src/whisk/core/cli/test/SwiftTests.scala b/tests/src/whisk/core/cli/test/SwiftTests.scala
index 2f579587bd1..6d3af916c7c 100644
--- a/tests/src/whisk/core/cli/test/SwiftTests.scala
+++ b/tests/src/whisk/core/cli/test/SwiftTests.scala
@@ -54,11 +54,11 @@ class SwiftTests
 
             val start = System.currentTimeMillis()
             withActivation(wsk.activation, wsk.action.invoke(name), totalWait = activationPollDuration) {
-                _.fields("response").toString should include("Hello stranger!")
+                _.response.result.get.toString should include("Hello stranger!")
             }
 
             withActivation(wsk.activation, wsk.action.invoke(name, Map("name" -> "Sir".toJson)), totalWait = activationPollDuration) {
-                _.fields("response").toString should include("Hello Sir!")
+                _.response.result.get.toString should include("Hello Sir!")
             }
 
             withClue("Test duration exceeds expectation (ms)") {
@@ -85,8 +85,9 @@ class SwiftTests
 
             withActivation(wsk.activation, wsk.action.invoke(name), totalWait = activationPollDuration) {
                 activation =>
-                    activation.fields("response").toString should include(""""url":"https://httpbin.org/get"""")
-                    activation.fields("response").toString should not include ("Error")
+                    val result = activation.response.result.get
+                    result.toString should include(""""url":"https://httpbin.org/get"""")
+                    result.toString should not include ("Error")
             }
     }
 }
diff --git a/tools/build/scanCode.py b/tools/build/scanCode.py
index 678c47342df..1975230e81f 100755
--- a/tools/build/scanCode.py
+++ b/tools/build/scanCode.py
@@ -41,8 +41,7 @@ def exceptional_paths():
         "bin/wskadmin",
         "bin/wskdev",
         "bin/go-cli/wsk",
-        "tests/build/reports",
-        "tests/src/com/google/code/tempusfugit/concurrency/ParallelRunner.java"
+        "tests/build/reports"
     ]
 
 ####
