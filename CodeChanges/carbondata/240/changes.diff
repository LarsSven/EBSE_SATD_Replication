diff --git a/core/src/main/java/org/apache/carbondata/core/constants/CarbonCommonConstants.java b/core/src/main/java/org/apache/carbondata/core/constants/CarbonCommonConstants.java
index dce57707ab8..310b1c3f339 100644
--- a/core/src/main/java/org/apache/carbondata/core/constants/CarbonCommonConstants.java
+++ b/core/src/main/java/org/apache/carbondata/core/constants/CarbonCommonConstants.java
@@ -877,6 +877,16 @@ public final class CarbonCommonConstants {
    */
   public static String ENABLE_BLOCKLET_DISTRIBUTION_DEFAULTVALUE = "true";
 
+  /**
+   * This batch size is used to send rows from load step to another step in batches.
+   */
+  public static final String DATA_LOAD_BATCH_SIZE = "DATA_LOAD_BATCH_SIZE";
+
+  /**
+   * Default size of data load batch size.
+   */
+  public static final String DATA_LOAD_BATCH_SIZE_DEFAULT = "1000";
+
   private CarbonCommonConstants() {
   }
 }
diff --git a/core/src/main/java/org/apache/carbondata/core/util/CarbonProperties.java b/core/src/main/java/org/apache/carbondata/core/util/CarbonProperties.java
index 19ed02a9e51..b856928842f 100644
--- a/core/src/main/java/org/apache/carbondata/core/util/CarbonProperties.java
+++ b/core/src/main/java/org/apache/carbondata/core/util/CarbonProperties.java
@@ -447,6 +447,40 @@ private int[] getIntArray(String commaSeparatedLevels) {
     return compactionSize;
   }
 
+  /**
+   * Number of cores should be used while loading data.
+   *
+   * @return
+   */
+  public int getNumberOfCores() {
+    int numberOfCores;
+    try {
+      numberOfCores = Integer.parseInt(CarbonProperties.getInstance()
+          .getProperty(CarbonCommonConstants.NUM_CORES_LOADING,
+              CarbonCommonConstants.NUM_CORES_DEFAULT_VAL));
+    } catch (NumberFormatException exc) {
+      numberOfCores = Integer.parseInt(CarbonCommonConstants.NUM_CORES_DEFAULT_VAL);
+    }
+    return numberOfCores;
+  }
+
+  /**
+   * Batch size of rows while sending data from one step to another in data loading.
+   *
+   * @return
+   */
+  public int getBatchSize() {
+    int batchSize;
+    try {
+      batchSize = Integer.parseInt(CarbonProperties.getInstance()
+          .getProperty(CarbonCommonConstants.DATA_LOAD_BATCH_SIZE,
+              CarbonCommonConstants.DATA_LOAD_BATCH_SIZE_DEFAULT));
+    } catch (NumberFormatException exc) {
+      batchSize = Integer.parseInt(CarbonCommonConstants.DATA_LOAD_BATCH_SIZE_DEFAULT);
+    }
+    return batchSize;
+  }
+
   /**
    * Validate the restrictions
    *
diff --git a/processing/src/main/java/org/apache/carbondata/processing/newflow/AbstractDataLoadProcessorStep.java b/processing/src/main/java/org/apache/carbondata/processing/newflow/AbstractDataLoadProcessorStep.java
index 69fe5116fb6..cc4da629766 100644
--- a/processing/src/main/java/org/apache/carbondata/processing/newflow/AbstractDataLoadProcessorStep.java
+++ b/processing/src/main/java/org/apache/carbondata/processing/newflow/AbstractDataLoadProcessorStep.java
@@ -29,6 +29,11 @@
 /**
  * This base abstract class for data loading.
  * It can do transformation jobs as per the implementation.
+ *
+ * Life cycle of this class is
+ * First initialize() is called to initialize the step
+ * then execute() is called to process the step logic and
+ * then close() is called to close any resources if any opened in the step.
  */
 public abstract class AbstractDataLoadProcessorStep {
 
@@ -49,11 +54,11 @@ public AbstractDataLoadProcessorStep(CarbonDataLoadConfiguration configuration,
   public abstract DataField[] getOutput();
 
   /**
-   * Intialization process for this step.
+   * Initialization process for this step.
    *
    * @throws CarbonDataLoadingException
    */
-  public abstract void intialize() throws CarbonDataLoadingException;
+  public abstract void initialize() throws CarbonDataLoadingException;
 
   /**
    * Tranform the data as per the implementation.
@@ -111,14 +116,15 @@ protected CarbonRowBatch processRowBatch(CarbonRowBatch rowBatch) {
    */
   protected abstract CarbonRow processRow(CarbonRow row);
 
-  /**
-   * It is called when task is called successfully.
-   */
-  public abstract void finish();
 
   /**
-   * Closing of resources after step execution can be done here.
+   * Close all resources.This method is called after execute() is finished.
+   * It will be called in both success and failure cases.
    */
-  public abstract void close();
+  public void close() {
+    if (child != null) {
+      child.close();
+    }
+  }
 
 }
diff --git a/processing/src/main/java/org/apache/carbondata/processing/newflow/complexobjects/ArrayObject.java b/processing/src/main/java/org/apache/carbondata/processing/newflow/complexobjects/ArrayObject.java
new file mode 100644
index 00000000000..4c7fc6389b8
--- /dev/null
+++ b/processing/src/main/java/org/apache/carbondata/processing/newflow/complexobjects/ArrayObject.java
@@ -0,0 +1,37 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.carbondata.processing.newflow.complexobjects;
+
+public class ArrayObject {
+
+  private Object[] data;
+
+  public ArrayObject(Object[] data) {
+    this.data = data;
+  }
+
+  public Object[] getData() {
+    return data;
+  }
+
+  public void setData(Object[] data) {
+    this.data = data;
+  }
+}
diff --git a/processing/src/main/java/org/apache/carbondata/processing/newflow/complexobjects/StructObject.java b/processing/src/main/java/org/apache/carbondata/processing/newflow/complexobjects/StructObject.java
new file mode 100644
index 00000000000..1e329a49ca6
--- /dev/null
+++ b/processing/src/main/java/org/apache/carbondata/processing/newflow/complexobjects/StructObject.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.carbondata.processing.newflow.complexobjects;
+
+public class StructObject {
+
+  private Object[] data;
+
+  public StructObject(Object[] data) {
+    this.data = data;
+  }
+
+  public Object[] getData() {
+    return data;
+  }
+
+  public void setData(Object[] data) {
+    this.data = data;
+  }
+
+}
diff --git a/processing/src/main/java/org/apache/carbondata/processing/newflow/constants/DataLoadProcessorConstants.java b/processing/src/main/java/org/apache/carbondata/processing/newflow/constants/DataLoadProcessorConstants.java
index 9d35ccb8fe1..15f5b0e12e1 100644
--- a/processing/src/main/java/org/apache/carbondata/processing/newflow/constants/DataLoadProcessorConstants.java
+++ b/processing/src/main/java/org/apache/carbondata/processing/newflow/constants/DataLoadProcessorConstants.java
@@ -33,4 +33,5 @@ public final class DataLoadProcessorConstants {
   public static final String COMPLEX_DELIMITERS = "COMPLEX_DELIMITERS";
 
   public static final String DIMENSION_LENGTHS = "DIMENSION_LENGTHS";
+
 }
diff --git a/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/CarbonParserFactory.java b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/CarbonParserFactory.java
new file mode 100644
index 00000000000..fcf122ee2e8
--- /dev/null
+++ b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/CarbonParserFactory.java
@@ -0,0 +1,77 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.carbondata.processing.newflow.parser;
+
+import java.util.List;
+
+import org.apache.carbondata.core.carbon.metadata.schema.table.column.CarbonColumn;
+import org.apache.carbondata.core.carbon.metadata.schema.table.column.CarbonDimension;
+import org.apache.carbondata.processing.newflow.parser.impl.ArrayParserImpl;
+import org.apache.carbondata.processing.newflow.parser.impl.PrimitiveParserImpl;
+import org.apache.carbondata.processing.newflow.parser.impl.StructParserImpl;
+
+public final class CarbonParserFactory {
+
+  /**
+   * Create parser for the carbon column.
+   * @param carbonColumn
+   * @param complexDelimiters
+   * @return
+   */
+  public static GenericParser createParser(CarbonColumn carbonColumn, String[] complexDelimiters) {
+    return createParser(carbonColumn, complexDelimiters, 0);
+  }
+
+  /**
+   * This method may be called recursively if the carbon column is complex type.
+   * @param carbonColumn
+   * @param complexDelimiters, these delimiters which are used to separate the complex data types.
+   * @param depth It is like depth of tree, if column has children then depth is 1, And depth
+   *              becomes 2 if children has children. This depth is used select the complex
+   *              delimiters
+   * @return GenericParser
+   */
+  private static GenericParser createParser(CarbonColumn carbonColumn, String[] complexDelimiters,
+      int depth) {
+    switch (carbonColumn.getDataType()) {
+      case ARRAY:
+        List<CarbonDimension> listOfChildDimensions =
+            ((CarbonDimension) carbonColumn).getListOfChildDimensions();
+        // Create array parser with complex delimiter
+        ArrayParserImpl arrayParser = new ArrayParserImpl(complexDelimiters[depth]);
+        for (CarbonDimension dimension : listOfChildDimensions) {
+          arrayParser.addChildren(createParser(dimension, complexDelimiters, depth + 1));
+        }
+        return arrayParser;
+      case STRUCT:
+        List<CarbonDimension> dimensions =
+            ((CarbonDimension) carbonColumn).getListOfChildDimensions();
+        // Create struct parser with complex delimiter
+        StructParserImpl parser = new StructParserImpl(complexDelimiters[depth]);
+        for (CarbonDimension dimension : dimensions) {
+          parser.addChildren(createParser(dimension, complexDelimiters, depth + 1));
+        }
+        return parser;
+      case MAP:
+        throw new UnsupportedOperationException("Complex type Map is not supported yet");
+      default:
+        return new PrimitiveParserImpl();
+    }
+  }
+}
diff --git a/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/ComplexParser.java b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/ComplexParser.java
new file mode 100644
index 00000000000..5200a1ede2d
--- /dev/null
+++ b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/ComplexParser.java
@@ -0,0 +1,31 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.carbondata.processing.newflow.parser;
+
+/**
+ * It parses data string as per complex data type.
+ */
+public interface ComplexParser<E> extends GenericParser<E> {
+
+  /**
+   * Children to this parser.
+   * @param parser
+   */
+  void addChildren(GenericParser parser);
+}
diff --git a/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/GenericParser.java b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/GenericParser.java
new file mode 100644
index 00000000000..bdc13abdaa9
--- /dev/null
+++ b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/GenericParser.java
@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.carbondata.processing.newflow.parser;
+
+/**
+ * Parse the data according to implementation, The implementation classes can be struct, array or
+ * map datatypes.
+ * It remains thread safe as the state of implementation class should not change while
+ * calling @{@link GenericParser#parse(String)} method
+ */
+public interface GenericParser<E> {
+
+  /**
+   * Parse the data as per the delimiter
+   * @param data
+   * @return
+   */
+  E parse(String data);
+
+}
diff --git a/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/RowParser.java b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/RowParser.java
new file mode 100644
index 00000000000..910e3871104
--- /dev/null
+++ b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/RowParser.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.carbondata.processing.newflow.parser;
+
+/**
+ * Parse the complete row at once.
+ */
+public interface RowParser {
+
+  /**
+   * Parse row.
+   * @param row input row to be parsed.
+   * @return parsed row.
+   */
+  Object[] parseRow(Object[] row);
+
+}
diff --git a/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/impl/ArrayParserImpl.java b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/impl/ArrayParserImpl.java
new file mode 100644
index 00000000000..7fc95e7eb86
--- /dev/null
+++ b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/impl/ArrayParserImpl.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.carbondata.processing.newflow.parser.impl;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Pattern;
+
+import org.apache.carbondata.core.util.CarbonUtil;
+import org.apache.carbondata.processing.newflow.complexobjects.ArrayObject;
+import org.apache.carbondata.processing.newflow.parser.ComplexParser;
+import org.apache.carbondata.processing.newflow.parser.GenericParser;
+
+import org.apache.commons.lang.ArrayUtils;
+import org.apache.commons.lang.StringUtils;
+
+/**
+ * It parses the string to @{@link ArrayObject} using delimiter.
+ * It is thread safe as the state of class don't change while
+ * calling @{@link GenericParser#parse(String)} method
+ */
+public class ArrayParserImpl implements ComplexParser<ArrayObject> {
+
+  private Pattern pattern;
+
+  private List<GenericParser> children = new ArrayList<>();
+
+  public ArrayParserImpl(String delimiter) {
+    pattern = Pattern.compile(CarbonUtil.delimiterConverter(delimiter));
+  }
+
+  @Override
+  public ArrayObject parse(String data) {
+    if (StringUtils.isNotEmpty(data)) {
+      String[] split = pattern.split(data, -1);
+      if (ArrayUtils.isNotEmpty(split)) {
+        Object[] array = new Object[children.size()];
+        for (int i = 0; i < children.size(); i++) {
+          array[i] = children.get(i).parse(split[i]);
+        }
+        return new ArrayObject(array);
+      }
+    }
+    return null;
+  }
+
+  @Override
+  public void addChildren(GenericParser parser) {
+    children.add(parser);
+  }
+}
diff --git a/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/impl/PrimitiveParserImpl.java b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/impl/PrimitiveParserImpl.java
new file mode 100644
index 00000000000..a7c08b5fd8a
--- /dev/null
+++ b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/impl/PrimitiveParserImpl.java
@@ -0,0 +1,30 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.carbondata.processing.newflow.parser.impl;
+
+import org.apache.carbondata.processing.newflow.parser.GenericParser;
+
+public class PrimitiveParserImpl implements GenericParser<Object> {
+
+  @Override
+  public Object parse(String data) {
+    return data;
+  }
+
+}
diff --git a/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/impl/RowParserImpl.java b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/impl/RowParserImpl.java
new file mode 100644
index 00000000000..9c1edd1f040
--- /dev/null
+++ b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/impl/RowParserImpl.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.carbondata.processing.newflow.parser.impl;
+
+import org.apache.carbondata.processing.newflow.parser.GenericParser;
+import org.apache.carbondata.processing.newflow.parser.RowParser;
+
+public class RowParserImpl implements RowParser {
+
+  private GenericParser[] genericParsers;
+
+  public RowParserImpl(GenericParser[] genericParsers) {
+    this.genericParsers = genericParsers;
+  }
+
+  @Override
+  public Object[] parseRow(Object[] row) {
+    for (int i = 0; i < row.length; i++) {
+      row[i] = genericParsers[i].parse(row[i].toString());
+    }
+    return row;
+  }
+}
diff --git a/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/impl/StructParserImpl.java b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/impl/StructParserImpl.java
new file mode 100644
index 00000000000..b38a2e48a72
--- /dev/null
+++ b/processing/src/main/java/org/apache/carbondata/processing/newflow/parser/impl/StructParserImpl.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.carbondata.processing.newflow.parser.impl;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Pattern;
+
+import org.apache.carbondata.core.util.CarbonUtil;
+import org.apache.carbondata.processing.newflow.complexobjects.StructObject;
+import org.apache.carbondata.processing.newflow.parser.ComplexParser;
+import org.apache.carbondata.processing.newflow.parser.GenericParser;
+
+import org.apache.commons.lang.ArrayUtils;
+import org.apache.commons.lang.StringUtils;
+
+/**
+ * It parses the string to @{@link StructObject} using delimiter.
+ * It is thread safe as the state of class don't change while
+ * calling @{@link GenericParser#parse(String)} method
+ */
+public class StructParserImpl implements ComplexParser<StructObject> {
+
+  private Pattern pattern;
+
+  private List<GenericParser> children = new ArrayList<>();
+
+  public StructParserImpl(String delimiter) {
+    pattern = Pattern.compile(CarbonUtil.delimiterConverter(delimiter));
+  }
+
+  @Override
+  public StructObject parse(String data) {
+    if (StringUtils.isNotEmpty(data)) {
+      String[] split = pattern.split(data, -1);
+      if (ArrayUtils.isNotEmpty(split)) {
+        Object[] array = new Object[children.size()];
+        for (int i = 0; i < children.size(); i++) {
+          array[i] = children.get(i).parse(split[i]);
+        }
+        return new StructObject(array);
+      }
+    }
+    return null;
+  }
+
+  @Override
+  public void addChildren(GenericParser parser) {
+    children.add(parser);
+  }
+}
diff --git a/processing/src/main/java/org/apache/carbondata/processing/newflow/steps/input/InputProcessorStepImpl.java b/processing/src/main/java/org/apache/carbondata/processing/newflow/steps/input/InputProcessorStepImpl.java
new file mode 100644
index 00000000000..75009c5a333
--- /dev/null
+++ b/processing/src/main/java/org/apache/carbondata/processing/newflow/steps/input/InputProcessorStepImpl.java
@@ -0,0 +1,167 @@
+package org.apache.carbondata.processing.newflow.steps.input;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.carbondata.common.CarbonIterator;
+import org.apache.carbondata.common.logging.LogService;
+import org.apache.carbondata.common.logging.LogServiceFactory;
+import org.apache.carbondata.core.util.CarbonProperties;
+import org.apache.carbondata.processing.newflow.AbstractDataLoadProcessorStep;
+import org.apache.carbondata.processing.newflow.CarbonDataLoadConfiguration;
+import org.apache.carbondata.processing.newflow.DataField;
+import org.apache.carbondata.processing.newflow.constants.DataLoadProcessorConstants;
+import org.apache.carbondata.processing.newflow.exception.CarbonDataLoadingException;
+import org.apache.carbondata.processing.newflow.parser.CarbonParserFactory;
+import org.apache.carbondata.processing.newflow.parser.GenericParser;
+import org.apache.carbondata.processing.newflow.parser.RowParser;
+import org.apache.carbondata.processing.newflow.parser.impl.RowParserImpl;
+import org.apache.carbondata.processing.newflow.row.CarbonRow;
+import org.apache.carbondata.processing.newflow.row.CarbonRowBatch;
+
+/**
+ * It reads data from record reader and sends data to next step.
+ */
+public class InputProcessorStepImpl extends AbstractDataLoadProcessorStep {
+
+  private static final LogService LOGGER =
+      LogServiceFactory.getLogService(InputProcessorStepImpl.class.getName());
+
+  private GenericParser[] genericParsers;
+
+  private List<Iterator<Object[]>> inputIterators;
+
+  public InputProcessorStepImpl(CarbonDataLoadConfiguration configuration,
+      AbstractDataLoadProcessorStep child, List<Iterator<Object[]>> inputIterators) {
+    super(configuration, child);
+    this.inputIterators = inputIterators;
+  }
+
+  @Override
+  public DataField[] getOutput() {
+    DataField[] fields = configuration.getDataFields();
+    String[] header = configuration.getHeader();
+    DataField[] output = new DataField[fields.length];
+    int k = 0;
+    for (int i = 0; i < header.length; i++) {
+      for (int j = 0; j < fields.length; j++) {
+        if (header[j].equalsIgnoreCase(fields[j].getColumn().getColName())) {
+          output[k++] = fields[j];
+          break;
+        }
+      }
+    }
+    return output;
+  }
+
+  @Override
+  public void initialize() throws CarbonDataLoadingException {
+    DataField[] output = getOutput();
+    genericParsers = new GenericParser[output.length];
+    for (int i = 0; i < genericParsers.length; i++) {
+      genericParsers[i] = CarbonParserFactory.createParser(output[i].getColumn(),
+          (String[]) configuration
+              .getDataLoadProperty(DataLoadProcessorConstants.COMPLEX_DELIMITERS));
+    }
+  }
+
+
+
+  @Override
+  public Iterator<CarbonRowBatch>[] execute() {
+    int batchSize = CarbonProperties.getInstance().getBatchSize();
+    List<Iterator<Object[]>>[] readerIterators = partitionInputReaderIterators();
+    Iterator<CarbonRowBatch>[] outIterators = new Iterator[readerIterators.length];
+    for (int i = 0; i < outIterators.length; i++) {
+      outIterators[i] = new InputProcessorIterator(readerIterators[i], genericParsers, batchSize);
+    }
+    return outIterators;
+  }
+
+  /**
+   * Partition input iterators equally as per the number of threads.
+   * @return
+   */
+  private List<Iterator<Object[]>>[] partitionInputReaderIterators() {
+    // Get the number of cores configured in property.
+    int numberOfCores = CarbonProperties.getInstance().getNumberOfCores();
+    // Get the minimum of number of cores and iterators size to get the number of parallel threads
+    // to be launched.
+    int parallelThreadNumber = Math.min(inputIterators.size(), numberOfCores);
+
+    List<Iterator<Object[]>>[] iterators = new List[parallelThreadNumber];
+    for (int i = 0; i < parallelThreadNumber; i++) {
+      iterators[i] = new ArrayList<>();
+    }
+    // Equally partition the iterators as per number of threads
+    for (int i = 0; i < inputIterators.size(); i++) {
+      iterators[i % parallelThreadNumber].add(inputIterators.get(i));
+    }
+    return iterators;
+  }
+
+  @Override
+  protected CarbonRow processRow(CarbonRow row) {
+    return null;
+  }
+
+  /**
+   * This iterator wraps the list of iterators and it starts iterating the each
+   * iterator of the list one by one. It also parse the data while iterating it.
+   */
+  private static class InputProcessorIterator extends CarbonIterator<CarbonRowBatch> {
+
+    private List<Iterator<Object[]>> inputIterators;
+
+    private Iterator<Object[]> currentIterator;
+
+    private int counter;
+
+    private int batchSize;
+
+    private RowParser rowParser;
+
+    public InputProcessorIterator(List<Iterator<Object[]>> inputIterators,
+        GenericParser[] genericParsers, int batchSize) {
+      this.inputIterators = inputIterators;
+      this.batchSize = batchSize;
+      this.rowParser = new RowParserImpl(genericParsers);
+      this.counter = 0;
+      // Get the first iterator from the list.
+      currentIterator = inputIterators.get(counter++);
+    }
+
+    @Override
+    public boolean hasNext() {
+      return internalHasNext();
+    }
+
+    private boolean internalHasNext() {
+      boolean hasNext = currentIterator.hasNext();
+      // If iterator is finished then check for next iterator.
+      if (!hasNext) {
+        // Check next iterator is available in the list.
+        if (counter < inputIterators.size()) {
+          // Get the next iterator from the list.
+          currentIterator = inputIterators.get(counter++);
+        }
+        hasNext = internalHasNext();
+      }
+      return hasNext;
+    }
+
+    @Override
+    public CarbonRowBatch next() {
+      // Create batch and fill it.
+      CarbonRowBatch carbonRowBatch = new CarbonRowBatch();
+      int count = 0;
+      while (internalHasNext() && count < batchSize) {
+        carbonRowBatch.addRow(new CarbonRow(rowParser.parseRow(currentIterator.next())));
+        count++;
+      }
+      return carbonRowBatch;
+    }
+  }
+
+}
