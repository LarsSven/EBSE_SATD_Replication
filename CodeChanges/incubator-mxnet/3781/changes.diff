diff --git a/src/operator/reshape-inl.h b/src/operator/reshape-inl.h
index 0b549162a3d3..8df1e2659b25 100644
--- a/src/operator/reshape-inl.h
+++ b/src/operator/reshape-inl.h
@@ -123,9 +123,23 @@ struct ReshapeParam : public dmlc::Parameter<ReshapeParam> {
               "and always fixed as input");
     DMLC_DECLARE_FIELD(shape)
     .set_default(ShapeInfo())
-    .describe("Target new shape. If the dim is same, set it to 0. If the dim is set "
-              "to be -1, it will be inferred from the rest of dims. One and only one dim "
-              "can be -1");
+    .describe("Target shape, a tuple, t=(t_1,t_2,..,t_m).\n"
+              "Let the input dims be s=(s_1,s_2,..,s_n).\n"
+              "The output dims u=(u_1,u_2,..,u_p) are computed from s and t.\n"
+              "The target shape tuple elements t_i are read in order, and used to "
+              " generate successive output dims u_p:\n"
+              "t_i:       meaning:      behavior:\n"
+              "+ve        explicit      u_p = t_i\n"
+              "0          copy          u_p = s_i\n"
+              "-1         infer         u_p = (Prod s_i) / (Prod u_j | j != p)\n"
+              "-2         copy all      u_p = s_i, u_p+1 = s_i+1, ...\n"
+              "-3         merge two     u_p = s_i * s_i+1\n"
+              "-4,a,b     split two     u_p = a, u_p+1 = b | a * b = s_i\n"
+              "The split directive (-4) in the target shape tuple is followed by "
+              "two dimensions, one of which can be -1, which means it will be "
+              "inferred from the other one and the original dimension.\n"
+              "The can only be one globally inferred dimension (-1), aside from "
+              "any -1 occuring in a split directive.");
     DMLC_DECLARE_FIELD(reverse)
       .set_default(false)
       .describe("Whether to match the shapes from the backward. If reverse is true, "
@@ -217,42 +231,69 @@ class ReshapeProp : public OperatorProperty {
       }
       std::vector<int> tmp;
       int src_idx = 0;
-      int neg_idx = -1;
+      int inf_idx = -1;
       size_t new_size = dshape.Size();
-      bool keep = true;
       if (param_.reverse) {
         std::reverse(dshape_vec.begin(), dshape_vec.end());
         std::reverse(param_shape_vec.begin(), param_shape_vec.end());
       }
-      for (index_t i = 0; i < param_shape_vec.size(); ++i) {
+      auto dshape_len = dshape_vec.size();
+      auto params_len = param_shape_vec.size();
+      for (index_t i = 0; i < params_len; ++i) {
         int proposed_dim = param_shape_vec[i];
         if (proposed_dim == 0) {
           // keep same
-          CHECK_EQ(keep, true) << "After set manual dim, can't keep original dim";
+          CHECK_LT(src_idx, dshape_len);
           tmp.push_back(dshape_vec[src_idx++]);
           new_size /= tmp.back();
-        } else if (proposed_dim < 0) {
+        } else if (proposed_dim == -1) {
           // infer
-          CHECK_LT(neg_idx, 0) << "One and only one dim can be inferred";
-          neg_idx = i;
+          CHECK_LT(inf_idx, 0) << "One and only one dim can be inferred";
+          inf_idx = i;
           tmp.push_back(0);
           src_idx++;
+        } else if (proposed_dim == -2) {
+          // copy all remaining dims from source
+          while (src_idx < dshape_len) {
+            size_t dn = dshape_vec[src_idx++];
+            new_size /= dn;
+            tmp.push_back(dn);
+          }
+        } else if (proposed_dim == -3) {
+          // merge two dims from source
+          CHECK_LT(src_idx, dshape_len-1);
+          size_t d1 = dshape_vec[src_idx++];
+          size_t d2 = dshape_vec[src_idx++];
+          size_t dn = d1 * d2;
+          new_size /= dn;
+          tmp.push_back(dn);
+        } else if (proposed_dim == -4) {
+          // split the source dim s into two dims
+          // read the left dim and then the right dim (either can be -1)
+          CHECK_LT(i + 2, params_len);
+          CHECK_LT(src_idx, dshape_len);
+          size_t d0 = dshape_vec[src_idx++];
+          int d1 = param_shape_vec[++i];
+          int d2 = param_shape_vec[++i];
+          CHECK(d1 != -1 || d2 != -1) << "Split dims cannot both be -1.";
+          if (d1 == -1) d1 = d0 / d2;
+          if (d2 == -1) d2 = d0 / d1;
+          CHECK_EQ(d1 * d2, d0) <<
+            "Split dims " << d1 << ", " << d2 << " do not divide original dim " << d0;
+          new_size /= d0;
+          tmp.push_back(d1);
+          tmp.push_back(d2);
         } else {
           // greater than 0, new shape
           CHECK_EQ(new_size % proposed_dim, 0) << "Illegal dim setting, can't be divided.";
           tmp.push_back(proposed_dim);
           new_size /= proposed_dim;
-          // after set manual shape, can't keep same
-          if (param_shape_vec.size() != dshape_vec.size()) {
-            keep = false;
-          } else {
-            src_idx++;
-          }
+          src_idx++;
         }
       }
 
-      if (neg_idx >= 0) {
-        tmp[neg_idx] = new_size;
+      if (inf_idx >= 0) {
+        tmp[inf_idx] = new_size;
       }
       if (param_.reverse) {
         std::reverse(param_shape_vec.begin(), param_shape_vec.end());
@@ -262,15 +303,15 @@ class ReshapeProp : public OperatorProperty {
       TShape oshape(tmp.begin(), tmp.end());
       CHECK_EQ(oshape.Size(), dshape.Size())
         << "Target shape size is different to source. "
-        << "Target: " << param_.target_shape.Size()
-        << "\nSource: " << dshape.Size();
+        << "Target: " << oshape
+        << "\nSource: " << dshape;
       out_shape->clear();
       out_shape->push_back(oshape);
     } else {
       LOG(INFO) << "Using target_shape will be deprecated.";
       TShape oshape = param_.target_shape;
       int neg_count = 0;
-      index_t neg_idx = 0;
+      index_t inf_idx = 0;
       index_t start_idx = param_.keep_highest ? 1 : 0;
       if (param_.keep_highest) {
         oshape[0] = dshape[0];
@@ -278,12 +319,12 @@ class ReshapeProp : public OperatorProperty {
       for (index_t i = start_idx; i < oshape.ndim(); ++i) {
         if (oshape[i] == 0) {
           neg_count++;
-          neg_idx = i;
+          inf_idx = i;
         }
       }
       if (neg_count == 1) {
-        oshape[neg_idx] = 1;
-        oshape[neg_idx] = dshape.Size() / oshape.Size();
+        oshape[inf_idx] = 1;
+        oshape[inf_idx] = dshape.Size() / oshape.Size();
       }
 
       CHECK(oshape.Size() == dshape.Size())
diff --git a/src/operator/reshape.cc b/src/operator/reshape.cc
index 7719c01953b0..ae3f081b8aaa 100644
--- a/src/operator/reshape.cc
+++ b/src/operator/reshape.cc
@@ -31,7 +31,47 @@ Operator* ReshapeProp::CreateOperatorEx(Context ctx, std::vector<TShape> *in_sha
 DMLC_REGISTER_PARAMETER(ReshapeParam);
 
 MXNET_REGISTER_OP_PROPERTY(Reshape, ReshapeProp)
-.describe("Reshape input to target shape")
+.describe("Reshape input according to a target shape spec.\n"
+"The target shape is a tuple and can be a simple list of dimensions "
+"such as (12,3) or it can incorporate special codes that correspond "
+"to contextual operations that refer to the input dimensions.\n"
+"The special codes are all expressed as integers less than 1. These "
+"codes effectively refer to a machine that pops input dims off the "
+"beginning of the input dims list and pushes resulting output dims "
+"onto the end of the output dims list, which starts empty. The codes "
+"are:\n"
+"  0  Copy     Pop one input dim and push it onto the output dims\n"
+" -1  Infer    Push a dim that is inferred later from all other output dims\n"
+" -2  CopyAll  Pop all remaining input dims and push them onto output dims\n"
+" -3  Merge2   Pop two input dims, multiply them, and push result\n"
+" -4  Split2   Pop one input dim, and read two next target shape specs,\n"
+"              push them both onto output dims (either can be -1 and will\n"
+"              be inferred from the other\n"
+" The exact mathematical behavior of these codes is given in the "
+"description of the 'shape' parameter. All non-codes (positive "
+"integers) just pop a dim off the input dims (if any), throw it away, "
+"and then push the specified integer onto the output dims.\n"
+"Examples:\n"
+"Type     Input      Target            Output\n"
+"Copy     (2,3,4)    (4,0,2)           (4,3,2)\n"
+"Copy     (2,3,4)    (2,0,0)           (2,3,4)\n"
+"Infer    (2,3,4)    (6,1,-1)          (6,1,4)\n"
+"Infer    (2,3,4)    (3,-1,8)          (3,1,8)\n"
+"CopyAll  (9,8,7)    (-2)              (9,8,7)\n"
+"CopyAll  (9,8,7)    (9,-2)            (9,8,7)\n"
+"CopyAll  (9,8,7)    (-2,1,1)          (9,8,7,1,1)\n"
+"Merge2   (3,4)      (-3)              (12)\n"
+"Merge2   (3,4,5)    (-3,0)            (12,5)\n"
+"Merge2   (3,4,5)    (0,-3)            (3,20)\n"
+"Merge2   (3,4,5,6)  (-3,0,0)          (12,5,6)\n"
+"Merge2   (3,4,5,6)  (-3,-2)           (12,5,6)\n"
+"Split2   (12)       (-4,6,2)          (6,2)\n"
+"Split2   (12)       (-4,2,6)          (2,6)\n"
+"Split2   (12)       (-4,-1,6)         (2,6)\n"
+"Split2   (12,9)     (-4,2,6,0)        (2,6,9)\n"
+"Split2   (12,9,9,9) (-4,2,6,-2)       (2,6,9,9,9)\n"
+"Split2   (12,12)    (-4,2,-1,-4,-1,2) (2,6,6,2)\n"
+)
 .add_argument("data", "Symbol", "Input data to reshape.")
 .add_arguments(ReshapeParam::__FIELDS__());
 
diff --git a/tests/python/unittest/test_operator.py b/tests/python/unittest/test_operator.py
index 06d68029360c..f15e6ec56594 100644
--- a/tests/python/unittest/test_operator.py
+++ b/tests/python/unittest/test_operator.py
@@ -955,19 +955,33 @@ def test_reshape_new(src_shape, shape_args, reverse, dst_shape):
             'Src Shape = %s, Shape Arguments = %s, Reverse = %s, Dst Shape = %s'\
             %(str(src_shape), str(shape_args), str(reverse), str(dst_shape))
     # Test new api (Using shape)
-    test_cases = [[(2, 3, 5, 5), (0, -1), False, (2, 75)],
-                  [(2, 3, 5, 5), (0, 0, -1), False, (2, 3, 25)],
-                  [(5, 3, 4, 5), (0, -1, 0), False, (5, 15, 4)],
-                  [(2, 3, 5, 4), (-1, 0, 0), False, (8, 3, 5)],
-                  [(2, 3, 5, 5), (0, 0, 0, 0), False, (2, 3, 5, 5)],
-                  [(2, 4, 5, 3), (-1, 2, 2, 1), False, (30, 2, 2, 1)],
-                  [(2, 3, 5, 5), (0, -1), True, (5, 30)],
-                  [(2, 3, 5, 5), (0, 0, -1), True, (3, 5, 10)],
-                  [(5, 3, 4, 5), (0, -1, 0), True, (3, 20, 5)],
-                  [(2, 3, 5, 4), (-1, 0, 0), True, (6, 5, 4)],
-                  [(2, 3, 4, 5), (3, -1, 0), True, (3, 8, 5)],
-                  [(2, 3, 5, 5), (5, 3, 0, -1), True, (5, 3, 5, 2)],
-                  [(2, 3, 5, 5), (0, 0, 0, 0), True, (2, 3, 5, 5)]]
+    test_cases = [
+        [(2, 3, 5, 5),  (0, -1),          False, (2, 75)],
+        [(2, 3, 5, 5),  (0, 0, -1),       False, (2, 3, 25)],
+        [(5, 3, 4, 5),  (0, -1, 0),       False, (5, 15, 4)],
+        [(2, 3, 5, 4),  (-1, 0, 0),       False, (8, 3, 5)],
+        [(2, 3, 5, 5),  (0, 0, 0, 0),     False, (2, 3, 5, 5)],
+        [(2, 4, 5, 3),  (-1, 2, 2, 1),    False, (30, 2, 2, 1)],
+        [(2, 3, 5, 6),  (-2,),            False, (2, 3, 5, 6)],
+        [(2, 3, 5, 6),  (6, 1, -2),       False, (6, 1, 5, 6)],
+        [(2, 3, 5, 6),  (-3, -3),         False, (6, 30)],
+        [(2, 3, 5, 6),  (-3, -1),         False, (6, 30)],
+        [(64,),         (-4, 16, 4),      False, (16, 4)],
+        [(64,),         (-4, 16, -1),     False, (16, 4)],
+        [(64, 1, 2, 3), (-4, 16, -1, -2), False, (16, 4, 1, 2, 3)],
+        [(2, 3, 5, 5),  (0, -1),          True,  (5, 30)],
+        [(2, 3, 5, 5),  (0, 0, -1),       True,  (3, 5, 10)],
+        [(5, 3, 4, 5),  (0, -1, 0),       True,  (3, 20, 5)],
+        [(2, 3, 5, 4),  (-1, 0, 0),       True,  (6, 5, 4)],
+        [(2, 3, 4, 5),  (3, -1, 0),       True,  (3, 8, 5)],
+        [(2, 3, 5, 5),  (5, 3, 0, -1),    True,  (5, 3, 5, 2)],
+        [(2, 3, 5, 5),  (0, 0, 0, 0),     True,  (2, 3, 5, 5)],
+        [(2, 3, 5, 6),  (-2,),            True,  (2, 3, 5, 6)],
+        [(2, 3, 5, 6),  (-2, 1, 30),      True,  (2, 3, 1, 30)],
+        [(2, 3, 5, 6),  (-3, -3),         True,  (6, 30)],
+        [(64,),         (16, 4, -4),      True,  (16, 4)],
+        [(64,),         (16, -1, -4),     True,  (16, 4)],
+        [(1, 2, 3, 64), (-2, -1, 16, -4), True,  (1, 2, 3, 4, 16)]]
     for test_case in test_cases:
         test_reshape_new(*test_case)
     # Test old api
