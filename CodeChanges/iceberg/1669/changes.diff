diff --git a/bundled-guava/src/main/java/org/apache/iceberg/GuavaClasses.java b/bundled-guava/src/main/java/org/apache/iceberg/GuavaClasses.java
index 107e420b213..0225f16c0d2 100644
--- a/bundled-guava/src/main/java/org/apache/iceberg/GuavaClasses.java
+++ b/bundled-guava/src/main/java/org/apache/iceberg/GuavaClasses.java
@@ -26,8 +26,10 @@
 import com.google.common.base.Preconditions;
 import com.google.common.base.Splitter;
 import com.google.common.base.Throwables;
+import com.google.common.collect.ArrayListMultimap;
 import com.google.common.collect.BiMap;
 import com.google.common.collect.FluentIterable;
+import com.google.common.collect.HashBasedTable;
 import com.google.common.collect.ImmutableBiMap;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
@@ -90,6 +92,9 @@ public class GuavaClasses {
     MoreExecutors.class.getName();
     ThreadFactoryBuilder.class.getName();
     Iterables.class.getName();
+    ListMultimap.class.getName();
+    HashBasedTable.class.getName();
+    ArrayListMultimap.class.getName();
   }
 
 }
diff --git a/flink/src/main/java/org/apache/iceberg/flink/FlinkTableProperties.java b/flink/src/main/java/org/apache/iceberg/flink/FlinkTableProperties.java
new file mode 100644
index 00000000000..2b557cda80d
--- /dev/null
+++ b/flink/src/main/java/org/apache/iceberg/flink/FlinkTableProperties.java
@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.iceberg.flink;
+
+/**
+ * Table Properties when using Flink IcebergSink.
+ */
+public class FlinkTableProperties {
+
+  private FlinkTableProperties() {
+  }
+
+  public static final String CASE_SENSITIVE = "case-sensitive";
+  public static final boolean CASE_SENSITIVE_DEFAULT = false;
+
+  public static final String NUMS_DATAFILE_MERGE = "nums.datafile.merge";
+  public static final int NUMS_DATAFILE_MERGE_DEFAULT = 100;
+
+  public static final String NUMS_NEW_SNAPSHOT_MERGE = "nums.new-snapshot.merge";
+  public static final int NUMS_NEW_SNAPSHOT_MERGE_DEFAULT = 100;
+
+  public static final String SNAPSHOT_RETAIN_LAST_MINUTES = "snapshot.retain.last.minutes";
+  public static final int SNAPSHOT_RETAIN_LAST_MINUTES_DEFAULT = -1;
+
+  public static final String SNAPSHOT_RETAIN_LAST_NUMS = "snapshot.retain.last.nums";
+  public static final int SNAPSHOT_RETAIN_LAST_NUMS_DEFAULT = 100;
+}
diff --git a/flink/src/main/java/org/apache/iceberg/flink/sink/FlinkSink.java b/flink/src/main/java/org/apache/iceberg/flink/sink/FlinkSink.java
index 7f1d9ca021f..744dfdc7500 100644
--- a/flink/src/main/java/org/apache/iceberg/flink/sink/FlinkSink.java
+++ b/flink/src/main/java/org/apache/iceberg/flink/sink/FlinkSink.java
@@ -25,9 +25,9 @@
 import java.util.Map;
 import org.apache.flink.api.common.functions.MapFunction;
 import org.apache.flink.api.common.typeinfo.TypeInformation;
-import org.apache.flink.api.common.typeinfo.Types;
 import org.apache.flink.streaming.api.datastream.DataStream;
 import org.apache.flink.streaming.api.datastream.DataStreamSink;
+import org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;
 import org.apache.flink.streaming.api.functions.sink.DiscardingSink;
 import org.apache.flink.table.api.TableSchema;
 import org.apache.flink.table.data.RowData;
@@ -41,7 +41,14 @@
 import org.apache.iceberg.Schema;
 import org.apache.iceberg.Table;
 import org.apache.iceberg.flink.FlinkSchemaUtil;
+import org.apache.iceberg.flink.FlinkTableProperties;
 import org.apache.iceberg.flink.TableLoader;
+import org.apache.iceberg.flink.sink.rewrite.DataFileReplaceOperator;
+import org.apache.iceberg.flink.sink.rewrite.DataFileReplaceOperatorOut;
+import org.apache.iceberg.flink.sink.rewrite.DataFileRewriteOperator;
+import org.apache.iceberg.flink.sink.rewrite.DataFileRewriteOperatorOut;
+import org.apache.iceberg.flink.sink.rewrite.FileScanTaskGenerateOperator;
+import org.apache.iceberg.flink.sink.rewrite.FileScanTaskGenerateOperatorOut;
 import org.apache.iceberg.relocated.com.google.common.base.Preconditions;
 import org.apache.iceberg.types.TypeUtil;
 import org.apache.iceberg.util.PropertyUtil;
@@ -179,21 +186,60 @@ public DataStreamSink<RowData> build() {
         try (TableLoader loader = tableLoader) {
           this.table = loader.loadTable();
         } catch (IOException e) {
-          throw new UncheckedIOException("Failed to load iceberg table from table loader: " + tableLoader, e);
+          throw new UncheckedIOException(
+              "Failed to load iceberg table from table loader: " + tableLoader,
+              e);
         }
       }
 
       IcebergStreamWriter<RowData> streamWriter = createStreamWriter(table, tableSchema);
       IcebergFilesCommitter filesCommitter = new IcebergFilesCommitter(tableLoader, overwrite);
 
-      this.writeParallelism = writeParallelism == null ? rowDataInput.getParallelism() : writeParallelism;
-
-      DataStream<Void> returnStream = rowDataInput
-          .transform(ICEBERG_STREAM_WRITER_NAME, TypeInformation.of(DataFile.class), streamWriter)
-          .setParallelism(writeParallelism)
-          .transform(ICEBERG_FILES_COMMITTER_NAME, Types.VOID, filesCommitter)
+      DataStream<?> returnStream = rowDataInput
+          .transform(ICEBERG_STREAM_WRITER_NAME,
+              TypeInformation.of(DataFile.class), streamWriter)
+          .setParallelism(rowDataInput.getParallelism())
+          .transform(ICEBERG_FILES_COMMITTER_NAME,
+              TypeInformation.of(Long.class), filesCommitter)
           .setParallelism(1)
           .setMaxParallelism(1);
+      int retainLastSnapMinutes = PropertyUtil.propertyAsInt(table.properties(),
+          FlinkTableProperties.SNAPSHOT_RETAIN_LAST_MINUTES,
+          FlinkTableProperties.SNAPSHOT_RETAIN_LAST_MINUTES_DEFAULT);
+      if (retainLastSnapMinutes > 0) {
+        // Generate scan task.
+        final String scanTaskGenId = "Iceberg-FileScanTask-Generator";
+        FileScanTaskGenerateOperator fileScanTaskOp = new FileScanTaskGenerateOperator(tableLoader);
+        returnStream = ((DataStream<Long>) returnStream)
+            .transform(scanTaskGenId, TypeInformation.of(FileScanTaskGenerateOperatorOut.class), fileScanTaskOp)
+            .setParallelism(1)
+            .setMaxParallelism(1)
+            .uid(scanTaskGenId);
+
+        // Put rewrite operator.
+        final String datafileRewriteId = "Iceberg-Datafile-Rewrite";
+        boolean caseSensitive = PropertyUtil.propertyAsBoolean(table.properties(),
+            FlinkTableProperties.CASE_SENSITIVE,
+            FlinkTableProperties.CASE_SENSITIVE_DEFAULT);
+
+        DataFileRewriteOperator rewriteDataFileOperator = new DataFileRewriteOperator(tableLoader, table.schema(),
+            table.io(), table.encryption(), caseSensitive, table.properties(),
+            getTaskWriterFactory(table, tableSchema));
+
+        returnStream = ((DataStream<FileScanTaskGenerateOperatorOut>) returnStream)
+            .transform(datafileRewriteId, TypeInformation.of(DataFileRewriteOperatorOut.class), rewriteDataFileOperator)
+            .uid(datafileRewriteId);
+
+        // Put replace operator.
+        final String datafileMergeId = "Iceberg-Datafile-Replace";
+        DataFileReplaceOperator replaceDataFileOperator =
+            new DataFileReplaceOperator(tableLoader);
+        returnStream = ((SingleOutputStreamOperator<DataFileRewriteOperatorOut>) returnStream)
+            .transform(datafileMergeId, TypeInformation.of(DataFileReplaceOperatorOut.class), replaceDataFileOperator)
+            .setParallelism(1)
+            .setMaxParallelism(1)
+            .uid(datafileMergeId);
+      }
 
       return returnStream.addSink(new DiscardingSink())
           .name(String.format("IcebergSink %s", table.name()))
@@ -201,15 +247,32 @@ public DataStreamSink<RowData> build() {
     }
   }
 
-  static IcebergStreamWriter<RowData> createStreamWriter(Table table, TableSchema requestedSchema) {
+  static IcebergStreamWriter<RowData> createStreamWriter(Table table,
+                                                         TableSchema requestedSchema) {
     Preconditions.checkArgument(table != null, "Iceberg table should't be null");
+    TaskWriterFactory<RowData> taskWriterFactory = getTaskWriterFactory(table, requestedSchema);
+    return new IcebergStreamWriter<>(table.name(), taskWriterFactory);
+  }
+
+  private static FileFormat getFileFormat(Map<String, String> properties) {
+    String formatString = properties.getOrDefault(DEFAULT_FILE_FORMAT, DEFAULT_FILE_FORMAT_DEFAULT);
+    return FileFormat.valueOf(formatString.toUpperCase(Locale.ENGLISH));
+  }
+
+  private static long getTargetFileSizeBytes(Map<String, String> properties) {
+    return PropertyUtil.propertyAsLong(properties,
+        WRITE_TARGET_FILE_SIZE_BYTES,
+        WRITE_TARGET_FILE_SIZE_BYTES_DEFAULT);
+  }
 
+  private static TaskWriterFactory<RowData> getTaskWriterFactory(Table table, TableSchema requestedSchema) {
     RowType flinkSchema;
     if (requestedSchema != null) {
       // Convert the flink schema to iceberg schema firstly, then reassign ids to match the existing iceberg schema.
-      Schema writeSchema = TypeUtil.reassignIds(FlinkSchemaUtil.convert(requestedSchema), table.schema());
+      Schema writeSchema = TypeUtil
+          .reassignIds(FlinkSchemaUtil.convert(requestedSchema),
+              table.schema());
       TypeUtil.validateWriteSchema(table.schema(), writeSchema, true, true);
-
       // We use this flink schema to read values from RowData. The flink's TINYINT and SMALLINT will be promoted to
       // iceberg INTEGER, that means if we use iceberg's table schema to read TINYINT (backend by 1 'byte'), we will
       // read 4 bytes rather than 1 byte, it will mess up the byte array in BinaryRowData. So here we must use flink
@@ -218,25 +281,8 @@ static IcebergStreamWriter<RowData> createStreamWriter(Table table, TableSchema
     } else {
       flinkSchema = FlinkSchemaUtil.convert(table.schema());
     }
-
     Map<String, String> props = table.properties();
-    long targetFileSize = getTargetFileSizeBytes(props);
-    FileFormat fileFormat = getFileFormat(props);
-
-    TaskWriterFactory<RowData> taskWriterFactory = new RowDataTaskWriterFactory(table.schema(), flinkSchema,
-        table.spec(), table.locationProvider(), table.io(), table.encryption(), targetFileSize, fileFormat, props);
-
-    return new IcebergStreamWriter<>(table.name(), taskWriterFactory);
-  }
-
-  private static FileFormat getFileFormat(Map<String, String> properties) {
-    String formatString = properties.getOrDefault(DEFAULT_FILE_FORMAT, DEFAULT_FILE_FORMAT_DEFAULT);
-    return FileFormat.valueOf(formatString.toUpperCase(Locale.ENGLISH));
-  }
-
-  private static long getTargetFileSizeBytes(Map<String, String> properties) {
-    return PropertyUtil.propertyAsLong(properties,
-        WRITE_TARGET_FILE_SIZE_BYTES,
-        WRITE_TARGET_FILE_SIZE_BYTES_DEFAULT);
+    return new RowDataTaskWriterFactory(table.schema(), flinkSchema, table.spec(), table.locationProvider(),
+        table.io(), table.encryption(), getTargetFileSizeBytes(props), getFileFormat(props), props);
   }
 }
diff --git a/flink/src/main/java/org/apache/iceberg/flink/sink/IcebergFilesCommitter.java b/flink/src/main/java/org/apache/iceberg/flink/sink/IcebergFilesCommitter.java
index 1734a0d7d6f..a781a82f9a1 100644
--- a/flink/src/main/java/org/apache/iceberg/flink/sink/IcebergFilesCommitter.java
+++ b/flink/src/main/java/org/apache/iceberg/flink/sink/IcebergFilesCommitter.java
@@ -53,8 +53,8 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-class IcebergFilesCommitter extends AbstractStreamOperator<Void>
-    implements OneInputStreamOperator<DataFile, Void>, BoundedOneInput {
+class IcebergFilesCommitter extends AbstractStreamOperator<Long>
+    implements OneInputStreamOperator<DataFile, Long>, BoundedOneInput {
 
   private static final long serialVersionUID = 1L;
   private static final long INITIAL_CHECKPOINT_ID = -1L;
@@ -192,6 +192,8 @@ private void commitUpToCheckpoint(NavigableMap<Long, List<DataFile>> dataFilesMa
 
     // Clear the committed data files from dataFilesPerCheckpoint.
     pendingFileMap.clear();
+
+    output.collect(new StreamRecord<>(table.currentSnapshot().snapshotId()));
   }
 
   private void replacePartitions(List<DataFile> dataFiles, String newFlinkJobId, long checkpointId) {
diff --git a/flink/src/main/java/org/apache/iceberg/flink/sink/TaskWriterFactory.java b/flink/src/main/java/org/apache/iceberg/flink/sink/TaskWriterFactory.java
index 6ed76963810..9d56ec6a812 100644
--- a/flink/src/main/java/org/apache/iceberg/flink/sink/TaskWriterFactory.java
+++ b/flink/src/main/java/org/apache/iceberg/flink/sink/TaskWriterFactory.java
@@ -27,7 +27,7 @@
  *
  * @param <T> data type of record.
  */
-interface TaskWriterFactory<T> extends Serializable {
+public interface TaskWriterFactory<T> extends Serializable {
 
   /**
    * Initialize the factory with a given taskId and attemptId.
diff --git a/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/AbstractRewriteOperator.java b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/AbstractRewriteOperator.java
new file mode 100644
index 00000000000..3afbe807dc3
--- /dev/null
+++ b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/AbstractRewriteOperator.java
@@ -0,0 +1,163 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.iceberg.flink.sink.rewrite;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+import org.apache.flink.streaming.api.operators.AbstractStreamOperator;
+import org.apache.flink.streaming.api.operators.BoundedOneInput;
+import org.apache.flink.streaming.api.operators.ChainingStrategy;
+import org.apache.flink.streaming.api.operators.OneInputStreamOperator;
+import org.apache.flink.util.Preconditions;
+import org.apache.iceberg.CombinedScanTask;
+import org.apache.iceberg.FileScanTask;
+import org.apache.iceberg.PartitionSpec;
+import org.apache.iceberg.Table;
+import org.apache.iceberg.TableProperties;
+import org.apache.iceberg.expressions.Expression;
+import org.apache.iceberg.expressions.Expressions;
+import org.apache.iceberg.flink.FlinkTableProperties;
+import org.apache.iceberg.flink.TableLoader;
+import org.apache.iceberg.io.CloseableIterable;
+import org.apache.iceberg.io.CloseableIterator;
+import org.apache.iceberg.relocated.com.google.common.collect.ListMultimap;
+import org.apache.iceberg.relocated.com.google.common.collect.Lists;
+import org.apache.iceberg.relocated.com.google.common.collect.Maps;
+import org.apache.iceberg.relocated.com.google.common.collect.Multimaps;
+import org.apache.iceberg.relocated.com.google.common.collect.Streams;
+import org.apache.iceberg.util.PropertyUtil;
+import org.apache.iceberg.util.StructLikeWrapper;
+import org.apache.iceberg.util.TableScanUtil;
+
+abstract class AbstractRewriteOperator<InT, OutT> extends AbstractStreamOperator<OutT>
+    implements OneInputStreamOperator<InT, OutT>, BoundedOneInput {
+
+  private final Expression filter;
+  private final TableLoader tableLoader;
+  private boolean caseSensitive;
+  private transient PartitionSpec spec;
+  private transient long targetSizeInBytes;
+  private transient long splitOpenFileCost;
+  private transient int splitLookback;
+  private transient Table table;
+
+  AbstractRewriteOperator(TableLoader tableLoader) {
+    this.tableLoader = tableLoader;
+    this.filter = Expressions.alwaysTrue();
+    super.setChainingStrategy(ChainingStrategy.ALWAYS);
+  }
+
+  @Override
+  public void open() throws Exception {
+    super.open();
+    this.tableLoader.open();
+    this.table = tableLoader.loadTable();
+
+    long splitSize = PropertyUtil.propertyAsLong(
+        table.properties(),
+        TableProperties.SPLIT_SIZE,
+        TableProperties.SPLIT_SIZE_DEFAULT);
+    long targetFileSize = PropertyUtil.propertyAsLong(
+        table.properties(),
+        TableProperties.WRITE_TARGET_FILE_SIZE_BYTES,
+        TableProperties.WRITE_TARGET_FILE_SIZE_BYTES_DEFAULT);
+    this.targetSizeInBytes = Math.min(splitSize, targetFileSize);
+
+    this.splitLookback = PropertyUtil.propertyAsInt(
+        table.properties(),
+        TableProperties.SPLIT_LOOKBACK,
+        TableProperties.SPLIT_LOOKBACK_DEFAULT);
+    this.splitOpenFileCost = PropertyUtil.propertyAsLong(
+        table.properties(),
+        TableProperties.SPLIT_OPEN_FILE_COST,
+        TableProperties.SPLIT_OPEN_FILE_COST_DEFAULT);
+
+    this.caseSensitive = PropertyUtil.propertyAsBoolean(
+        table.properties(),
+        FlinkTableProperties.CASE_SENSITIVE,
+        FlinkTableProperties.CASE_SENSITIVE_DEFAULT
+    );
+
+    this.spec = table.spec();
+  }
+
+  protected List<CombinedScanTask> generateFileScanTask() {
+    // a bin contains targetSizeInBytes / splitOpenFileCost items,
+    // a bin group contains max splitLookback bins. if bin group size < splitLookback,
+    // then return the first bin for each time, else remove the largest and return.
+    return generateFilteredGroupedTasks().values().stream()
+        .map(scanTasks -> {
+          CloseableIterable<FileScanTask> splitTasks = TableScanUtil.splitFiles(
+              CloseableIterable.withNoopClose(scanTasks), targetSizeInBytes);
+          return TableScanUtil
+              .planTasks(splitTasks, targetSizeInBytes, splitLookback, splitOpenFileCost);
+        })
+        .flatMap(Streams::stream)
+        .collect(Collectors.toList());
+  }
+
+  private Map<StructLikeWrapper, Collection<FileScanTask>> generateFilteredGroupedTasks() {
+    Map<StructLikeWrapper, Collection<FileScanTask>> groupedTasks = Maps.newHashMap();
+    try (CloseableIterable<FileScanTask> fileScanTasks =
+             table.newScan()
+                 .caseSensitive(caseSensitive)
+                 .ignoreResiduals()
+                 .filter(filter)
+                 .planFiles()) {
+      Preconditions.checkArgument(fileScanTasks != null, "file scan task should not be null.");
+      groupedTasks = groupTasksByPartition(fileScanTasks.iterator());
+    } catch (IOException e) {
+      LOG.warn("Failed to close task iterable", e);
+    }
+    return groupedTasks.entrySet().stream()
+        .filter(kv -> !kv.getValue().isEmpty())
+        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
+  }
+
+  private Map<StructLikeWrapper, Collection<FileScanTask>> groupTasksByPartition(
+      CloseableIterator<FileScanTask> tasksIter) {
+    ListMultimap<StructLikeWrapper, FileScanTask> tasksGroupedByPartition = Multimaps.newListMultimap(
+        Maps.newHashMap(), Lists::newArrayList);
+    try (CloseableIterator<FileScanTask> iter = tasksIter) {
+      iter.forEachRemaining(task -> {
+        StructLikeWrapper structLike = StructLikeWrapper.forType(spec.partitionType()).set(task.file().partition());
+        tasksGroupedByPartition.put(structLike, task);
+      });
+    } catch (IOException e) {
+      LOG.warn("Failed to close task iterator", e);
+    }
+    return tasksGroupedByPartition.asMap();
+  }
+
+  @Override
+  public void endInput() throws Exception {
+  }
+
+  public Table table() {
+    return table;
+  }
+
+  public long getTargetSizeInBytes() {
+    return targetSizeInBytes;
+  }
+}
diff --git a/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/DataFileReplaceOperator.java b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/DataFileReplaceOperator.java
new file mode 100644
index 00000000000..a72c4cbdce7
--- /dev/null
+++ b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/DataFileReplaceOperator.java
@@ -0,0 +1,132 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.iceberg.flink.sink.rewrite;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.iceberg.DataFile;
+import org.apache.iceberg.RewriteFiles;
+import org.apache.iceberg.flink.FlinkTableProperties;
+import org.apache.iceberg.flink.TableLoader;
+import org.apache.iceberg.io.FileIO;
+import org.apache.iceberg.relocated.com.google.common.collect.ArrayListMultimap;
+import org.apache.iceberg.relocated.com.google.common.collect.HashBasedTable;
+import org.apache.iceberg.relocated.com.google.common.collect.Iterables;
+import org.apache.iceberg.relocated.com.google.common.collect.Multimap;
+import org.apache.iceberg.relocated.com.google.common.collect.Sets;
+import org.apache.iceberg.relocated.com.google.common.collect.Table;
+import org.apache.iceberg.util.PropertyUtil;
+import org.apache.iceberg.util.Tasks;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class DataFileReplaceOperator extends
+    AbstractRewriteOperator<DataFileRewriteOperatorOut, DataFileReplaceOperatorOut> {
+
+  private static final Logger LOG = LoggerFactory.getLogger(DataFileReplaceOperator.class);
+  private Table<Long, List<DataFile>, Integer> addedFileCache;
+  private Multimap<Long, DataFile> currentDataFileCache;
+
+  private transient long tableSnapshotRetainMills;
+  private transient int tableSnapshotRetainNums;
+
+  public DataFileReplaceOperator(TableLoader tableLoader) {
+    super(tableLoader);
+    this.addedFileCache = HashBasedTable.create();
+    this.currentDataFileCache = ArrayListMultimap.create();
+  }
+
+  @Override
+  public void open() throws Exception {
+    super.open();
+    this.tableSnapshotRetainMills = PropertyUtil.propertyAsInt(table().properties(),
+        FlinkTableProperties.SNAPSHOT_RETAIN_LAST_MINUTES,
+        FlinkTableProperties.SNAPSHOT_RETAIN_LAST_MINUTES_DEFAULT) * 60 * 1000L;
+    this.tableSnapshotRetainNums = PropertyUtil.propertyAsInt(table().properties(),
+        FlinkTableProperties.SNAPSHOT_RETAIN_LAST_NUMS, FlinkTableProperties.SNAPSHOT_RETAIN_LAST_NUMS_DEFAULT);
+  }
+
+  @Override
+  public void processElement(StreamRecord<DataFileRewriteOperatorOut> element) throws Exception {
+    if (element != null) {
+      DataFileRewriteOperatorOut lastOpOut = element.getValue();
+      long lastBatchMills = lastOpOut.getTaskTriggerMillis();
+      if (!addedFileCache.rowKeySet().isEmpty()) {
+        long maxMills = Collections.max(addedFileCache.rowKeySet());
+        if (lastBatchMills > maxMills) {
+          // skip the old merge file list and do the new one. it means the pre batch of merge
+          // does not success because one task of current batch of merge has arrived. we only
+          // need to do the latest batch.
+          addedFileCache.clear();
+        }
+      }
+      addedFileCache.put(lastBatchMills, lastOpOut.getAddedDataFiles(), lastOpOut.getSubTaskId());
+      lastOpOut.getCurrentDataFiles().forEach(elem -> {
+        currentDataFileCache.put(lastBatchMills, elem);
+      });
+      if (addedFileCache.row(lastBatchMills).size() == lastOpOut.getTaskNums()) {
+        // all datafile list has arrived for current batch, so we can do merge.
+        List<DataFile> addedDataFiles = addedFileCache.columnKeySet().stream()
+            .flatMap(Collection::stream)
+            .collect(Collectors.toList());
+        List<DataFile> currentDataFiles = new ArrayList<>(currentDataFileCache.get(lastBatchMills));
+        replaceDataFiles(currentDataFiles, addedDataFiles);
+        doExpireSnapshot();
+        LOG.info("Current merge window time is: {}", lastBatchMills);
+        addedFileCache.clear();
+        currentDataFiles.clear();
+      }
+    }
+  }
+
+  private void replaceDataFiles(Iterable<DataFile> deletedDataFiles, Iterable<DataFile> addedDataFiles) {
+    try {
+      table().refresh();
+      RewriteFiles rewriteFiles = table().newRewrite();
+      rewriteFiles.rewriteFiles(Sets.newHashSet(deletedDataFiles), Sets.newHashSet(addedDataFiles));
+      rewriteFiles.commit();
+    } catch (Exception e) {
+      FileIO fileIO = table().io();
+      Tasks.foreach(Iterables.transform(addedDataFiles, f -> {
+        assert f != null;
+        return f.path().toString();
+      }))
+          .retry(3)
+          .suppressFailureWhenFinished()
+          .onFailure((location, exc) -> LOG.warn("Failed to delete: {}", location, exc))
+          .run(fileIO::deleteFile);
+      throw e;
+    }
+  }
+
+  private void doExpireSnapshot() {
+    if (tableSnapshotRetainMills > 0) {
+      table().expireSnapshots()
+          .expireOlderThan(System.currentTimeMillis() - tableSnapshotRetainMills)
+          .retainLast(tableSnapshotRetainNums)
+          .commit();
+    }
+  }
+
+}
diff --git a/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/DataFileReplaceOperatorOut.java b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/DataFileReplaceOperatorOut.java
new file mode 100644
index 00000000000..9cfce36b0f4
--- /dev/null
+++ b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/DataFileReplaceOperatorOut.java
@@ -0,0 +1,23 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.iceberg.flink.sink.rewrite;
+
+public class DataFileReplaceOperatorOut {
+}
diff --git a/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/DataFileRewriteOperator.java b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/DataFileRewriteOperator.java
new file mode 100644
index 00000000000..8b772a1a896
--- /dev/null
+++ b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/DataFileRewriteOperator.java
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.iceberg.flink.sink.rewrite;
+
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.flink.table.data.RowData;
+import org.apache.iceberg.BaseCombinedScanTask;
+import org.apache.iceberg.CombinedScanTask;
+import org.apache.iceberg.DataFile;
+import org.apache.iceberg.FileScanTask;
+import org.apache.iceberg.Schema;
+import org.apache.iceberg.TableProperties;
+import org.apache.iceberg.encryption.EncryptionManager;
+import org.apache.iceberg.flink.TableLoader;
+import org.apache.iceberg.flink.sink.TaskWriterFactory;
+import org.apache.iceberg.io.FileIO;
+import org.apache.iceberg.relocated.com.google.common.collect.Lists;
+
+public class DataFileRewriteOperator extends
+    AbstractRewriteOperator<FileScanTaskGenerateOperatorOut, DataFileRewriteOperatorOut> {
+  private TaskWriterFactory<RowData> writerFactory;
+  private FileIO io;
+  private Schema schema;
+  private EncryptionManager encryptionManager;
+  private boolean caseSensitive;
+  private String nameMapping;
+
+  private transient RowDataRewriter rowDataRewriter;
+
+  public DataFileRewriteOperator(TableLoader tableLoader,
+                                 Schema schema,
+                                 FileIO io,
+                                 EncryptionManager encryptionManager,
+                                 boolean caseSensitive,
+                                 Map<String, String> tblProperties,
+                                 TaskWriterFactory<RowData> writerFactory) {
+    super(tableLoader);
+    this.io = io;
+    this.schema = schema;
+    this.encryptionManager = encryptionManager;
+    this.writerFactory = writerFactory;
+    this.caseSensitive = caseSensitive;
+    this.nameMapping = tblProperties.get(TableProperties.DEFAULT_NAME_MAPPING);
+  }
+
+  @Override
+  public void open() throws Exception {
+    writerFactory.initialize(getRuntimeContext().getIndexOfThisSubtask(), getRuntimeContext().getAttemptNumber());
+    this.rowDataRewriter = new RowDataRewriter(io, schema, nameMapping, encryptionManager,
+        writerFactory, caseSensitive);
+  }
+
+  @Override
+  public void processElement(StreamRecord<FileScanTaskGenerateOperatorOut> element) throws Exception {
+    if (element != null) {
+      CombinedScanTask task = element.getValue().getOneCombineScanTask();
+      int totalCombinedScanTaskNums = element.getValue().getTotalCombineScanTasks();
+      long taskMillis = element.getValue().getCurrentTaskMillis();
+
+      List<FileScanTask> fileScanTasks = Lists.newArrayList(task.files());
+
+      List<DataFile> currentDataFiles = fileScanTasks.stream()
+          .map(FileScanTask::file)
+          .collect(Collectors.toList());
+      // filter files which don't need to be rewrote.
+      List<FileScanTask> filterFileScanTasks = fileScanTasks.stream()
+          .filter(fileScanTask -> fileScanTask.file().fileSizeInBytes() >= getTargetSizeInBytes())
+          .collect(Collectors.toList());
+      // Remove the scan task which don't need to rewrite. we should return these after rewrite.
+      fileScanTasks.removeAll(filterFileScanTasks);
+      if (fileScanTasks.size() > 0) {
+        LOG.info("There are {} file need to be rewrite.", fileScanTasks.size());
+        CombinedScanTask needRewriteScanTask = new BaseCombinedScanTask(fileScanTasks);
+        List<DataFile> rewriteDataFiles = rowDataRewriter.rewriteDataForTask(needRewriteScanTask);
+        List<DataFile> noNeedRewriteDataFiles = filterFileScanTasks.stream()
+            .map(FileScanTask::file)
+            .collect(Collectors.toList());
+        // return back no-rewrite datafiles
+        rewriteDataFiles.addAll(noNeedRewriteDataFiles);
+
+        DataFileRewriteOperatorOut result = new DataFileRewriteOperatorOut(rewriteDataFiles, currentDataFiles,
+            taskMillis, totalCombinedScanTaskNums, getRuntimeContext().getIndexOfThisSubtask());
+        output.collect(new StreamRecord<>(result));
+      }
+
+      LOG.info("Finish current DataFile rewrite");
+    } else {
+      LOG.warn("Get empty element.");
+    }
+  }
+
+  @Override
+  public void endInput() throws Exception {
+  }
+}
diff --git a/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/DataFileRewriteOperatorOut.java b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/DataFileRewriteOperatorOut.java
new file mode 100644
index 00000000000..7313244c8ef
--- /dev/null
+++ b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/DataFileRewriteOperatorOut.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.iceberg.flink.sink.rewrite;
+
+import java.util.List;
+import org.apache.iceberg.DataFile;
+
+public class DataFileRewriteOperatorOut {
+  private long taskTriggerMillis;
+  private int taskNums;
+  private int subTaskId;
+  private List<DataFile> addedDataFiles;
+  private List<DataFile> currentDataFiles;
+
+  /**
+   * @param addedDataFiles new datafiles generated by rewrite operator.
+   * @param currentDataFiles current datafiles need to be replaced.
+   * @param taskMillis current merge task trigger time.
+   * @param taskNums total taskNums
+   * @param subTaskId current flink subtask id.
+   */
+  public DataFileRewriteOperatorOut(List<DataFile> addedDataFiles, List<DataFile> currentDataFiles,
+                                    long taskMillis, int taskNums, int subTaskId) {
+    this.addedDataFiles = addedDataFiles;
+    this.taskNums = taskNums;
+    this.subTaskId = subTaskId;
+    this.taskTriggerMillis = taskMillis;
+    this.currentDataFiles = currentDataFiles;
+  }
+
+  public List<DataFile> getAddedDataFiles() {
+    return addedDataFiles;
+  }
+
+  public List<DataFile> getCurrentDataFiles() {
+    return currentDataFiles;
+  }
+
+  public long getTaskTriggerMillis() {
+    return taskTriggerMillis;
+  }
+
+  public int getTaskNums() {
+    return taskNums;
+  }
+
+  public int getSubTaskId() {
+    return subTaskId;
+  }
+}
diff --git a/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/FileScanTaskGenerateOperator.java b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/FileScanTaskGenerateOperator.java
new file mode 100644
index 00000000000..b9babf6e953
--- /dev/null
+++ b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/FileScanTaskGenerateOperator.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.iceberg.flink.sink.rewrite;
+
+import java.util.List;
+import java.util.Set;
+import org.apache.flink.streaming.runtime.streamrecord.StreamRecord;
+import org.apache.iceberg.CombinedScanTask;
+import org.apache.iceberg.DataFile;
+import org.apache.iceberg.flink.FlinkTableProperties;
+import org.apache.iceberg.flink.TableLoader;
+import org.apache.iceberg.relocated.com.google.common.collect.Lists;
+import org.apache.iceberg.relocated.com.google.common.collect.Sets;
+import org.apache.iceberg.util.PropertyUtil;
+
+public class FileScanTaskGenerateOperator extends
+    AbstractRewriteOperator<Long, FileScanTaskGenerateOperatorOut> {
+  private int rewriteTaskTriggerSnapCounts;
+  private int rewriteTaskTriggerFileCounts;
+  // snapshot counts to trigger merge;
+  private transient Set<Long> committedSnapshotCache;
+
+  public FileScanTaskGenerateOperator(TableLoader tableLoader) {
+    super(tableLoader);
+  }
+
+  @Override
+  public void open() throws Exception {
+    super.open();
+    this.committedSnapshotCache = Sets.newLinkedHashSet();
+    this.rewriteTaskTriggerFileCounts = PropertyUtil.propertyAsInt(table().properties(),
+        FlinkTableProperties.NUMS_DATAFILE_MERGE, FlinkTableProperties.NUMS_DATAFILE_MERGE_DEFAULT);
+    this.rewriteTaskTriggerSnapCounts = PropertyUtil.propertyAsInt(table().properties(),
+        FlinkTableProperties.NUMS_NEW_SNAPSHOT_MERGE, FlinkTableProperties.NUMS_NEW_SNAPSHOT_MERGE_DEFAULT);
+  }
+
+  @Override
+  public void processElement(StreamRecord<Long> element) throws Exception {
+    table().refresh();
+    List<DataFile> addedFiles = Lists.newArrayList(table().currentSnapshot().addedFiles());
+
+    committedSnapshotCache.add(element.getValue());
+    if (committedSnapshotCache.size() == rewriteTaskTriggerSnapCounts ||
+        addedFiles.size() >= rewriteTaskTriggerFileCounts) {
+      forwardScanTask();
+      committedSnapshotCache.clear();
+    }
+  }
+
+  private void forwardScanTask() {
+    final long currentTimeMillis = System.currentTimeMillis();
+    List<CombinedScanTask> combinedScanTasks = generateFileScanTask();
+    combinedScanTasks.forEach(combinedScanTask -> {
+      output.collect(new StreamRecord<>(new FileScanTaskGenerateOperatorOut(combinedScanTask,
+          currentTimeMillis, combinedScanTasks.size())));
+    });
+  }
+
+  @Override
+  public void endInput() throws Exception {
+    super.endInput();
+    if (committedSnapshotCache.size() > 0) {
+      forwardScanTask();
+      committedSnapshotCache.clear();
+    }
+  }
+
+  @Override
+  public void close() throws Exception {
+    super.close();
+    if (committedSnapshotCache.size() > 0) {
+      forwardScanTask();
+      committedSnapshotCache.clear();
+    }
+  }
+}
diff --git a/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/FileScanTaskGenerateOperatorOut.java b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/FileScanTaskGenerateOperatorOut.java
new file mode 100644
index 00000000000..a0051da4711
--- /dev/null
+++ b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/FileScanTaskGenerateOperatorOut.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.iceberg.flink.sink.rewrite;
+
+import org.apache.iceberg.CombinedScanTask;
+
+public class FileScanTaskGenerateOperatorOut {
+  private final CombinedScanTask oneCombineScanTask;
+  private final long currentTaskMillis;
+  private final int totalCombineScanTasks;
+
+  public FileScanTaskGenerateOperatorOut(CombinedScanTask oneCombineScanTask,
+                                         long currentTaskMillis,
+                                         int totalCombineScanTasks) {
+    this.oneCombineScanTask = oneCombineScanTask;
+    this.currentTaskMillis = currentTaskMillis;
+    this.totalCombineScanTasks = totalCombineScanTasks;
+  }
+
+  public CombinedScanTask getOneCombineScanTask() {
+    return oneCombineScanTask;
+  }
+
+  public long getCurrentTaskMillis() {
+    return currentTaskMillis;
+  }
+
+  public int getTotalCombineScanTasks() {
+    return totalCombineScanTasks;
+  }
+}
diff --git a/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/RowDataRewriter.java b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/RowDataRewriter.java
new file mode 100644
index 00000000000..1a46bc6df65
--- /dev/null
+++ b/flink/src/main/java/org/apache/iceberg/flink/sink/rewrite/RowDataRewriter.java
@@ -0,0 +1,86 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+package org.apache.iceberg.flink.sink.rewrite;
+
+import java.io.Serializable;
+import java.util.List;
+import org.apache.flink.table.data.RowData;
+import org.apache.iceberg.CombinedScanTask;
+import org.apache.iceberg.DataFile;
+import org.apache.iceberg.Schema;
+import org.apache.iceberg.encryption.EncryptionManager;
+import org.apache.iceberg.flink.sink.TaskWriterFactory;
+import org.apache.iceberg.flink.source.RowDataIterator;
+import org.apache.iceberg.io.FileIO;
+import org.apache.iceberg.io.TaskWriter;
+import org.apache.iceberg.relocated.com.google.common.collect.Lists;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class RowDataRewriter implements Serializable {
+  private static final Logger LOG = LoggerFactory.getLogger(RowDataRewriter.class);
+
+  private final Schema schema;
+  private final FileIO io;
+  private final EncryptionManager encryptionManager;
+  private final String nameMapping;
+  private final TaskWriterFactory<RowData> taskWriterFactory;
+  private final boolean caseSensitive;
+
+  public RowDataRewriter(FileIO io, Schema schema, String nameMapping, EncryptionManager encryptionManager,
+                         TaskWriterFactory<RowData> taskWriterFactory, boolean caseSensitive) {
+    this.schema = schema;
+    this.io = io;
+    this.encryptionManager = encryptionManager;
+    this.caseSensitive = caseSensitive;
+    this.nameMapping = nameMapping;
+    this.taskWriterFactory = taskWriterFactory;
+  }
+
+  public List<DataFile> rewriteDataForTask(CombinedScanTask task) throws Exception {
+
+    TaskWriter<RowData> writer = taskWriterFactory.create();
+    try (RowDataIterator dataIterator = new RowDataIterator(
+        task, io, encryptionManager, schema, schema, nameMapping, caseSensitive)) {
+      while (dataIterator.hasNext()) {
+        RowData row = dataIterator.next();
+        writer.write(row);
+      }
+      writer.close();
+      return Lists.newArrayList(writer.complete());
+    } catch (Throwable originalThrowable) {
+      try {
+        writer.abort();
+        LOG.error("Aborting task.", originalThrowable);
+      } catch (Throwable inner) {
+        if (originalThrowable != inner) {
+          originalThrowable.addSuppressed(inner);
+          LOG.warn("Suppressing exception in catch: {}", inner.getMessage(), inner);
+        }
+      }
+
+      if (originalThrowable instanceof Exception) {
+        throw originalThrowable;
+      } else {
+        throw new RuntimeException(originalThrowable);
+      }
+    }
+  }
+}
diff --git a/flink/src/main/java/org/apache/iceberg/flink/source/RowDataIterator.java b/flink/src/main/java/org/apache/iceberg/flink/source/RowDataIterator.java
index 5a568144d1f..b907c95edcd 100644
--- a/flink/src/main/java/org/apache/iceberg/flink/source/RowDataIterator.java
+++ b/flink/src/main/java/org/apache/iceberg/flink/source/RowDataIterator.java
@@ -47,14 +47,14 @@
 import org.apache.iceberg.types.TypeUtil;
 import org.apache.iceberg.util.PartitionUtil;
 
-class RowDataIterator extends DataIterator<RowData> {
+public class RowDataIterator extends DataIterator<RowData> {
 
   private final Schema tableSchema;
   private final Schema projectedSchema;
   private final String nameMapping;
   private final boolean caseSensitive;
 
-  RowDataIterator(CombinedScanTask task, FileIO io, EncryptionManager encryption, Schema tableSchema,
+  public RowDataIterator(CombinedScanTask task, FileIO io, EncryptionManager encryption, Schema tableSchema,
                   Schema projectedSchema, String nameMapping, boolean caseSensitive) {
     super(task, io, encryption);
     this.tableSchema = tableSchema;
diff --git a/flink/src/test/java/org/apache/iceberg/flink/SimpleDataUtil.java b/flink/src/test/java/org/apache/iceberg/flink/SimpleDataUtil.java
index 3eb7f164332..844fe2df48a 100644
--- a/flink/src/test/java/org/apache/iceberg/flink/SimpleDataUtil.java
+++ b/flink/src/test/java/org/apache/iceberg/flink/SimpleDataUtil.java
@@ -28,6 +28,7 @@
 import org.apache.flink.table.data.RowData;
 import org.apache.flink.table.data.StringData;
 import org.apache.flink.table.types.logical.RowType;
+import org.apache.flink.types.Row;
 import org.apache.hadoop.conf.Configuration;
 import org.apache.hadoop.fs.Path;
 import org.apache.iceberg.DataFile;
@@ -94,6 +95,14 @@ public static RowData createRowData(Integer id, String data) {
     return GenericRowData.of(id, StringData.fromString(data));
   }
 
+  public static List<Row> generateRows(int rowCounts) {
+    List<Row> rows = Lists.newArrayList();
+    for (int i = 0; i < rowCounts; i++) {
+      rows.add(Row.of(i, String.valueOf(i % 3)));
+    }
+    return rows;
+  }
+
   public static DataFile writeFile(Schema schema, PartitionSpec spec, Configuration conf,
                                    String location, String filename, List<RowData> rows)
       throws IOException {
@@ -138,4 +147,6 @@ public static void assertTableRecords(String tablePath, List<Record> expected) t
     Preconditions.checkArgument(expected != null, "expected records shouldn't be null");
     assertTableRecords(new HadoopTables().load(tablePath), expected);
   }
+
+
 }
diff --git a/flink/src/test/java/org/apache/iceberg/flink/sink/TestFlinkIcebergSink.java b/flink/src/test/java/org/apache/iceberg/flink/sink/TestFlinkIcebergSink.java
index 0022425d844..8bffe611614 100644
--- a/flink/src/test/java/org/apache/iceberg/flink/sink/TestFlinkIcebergSink.java
+++ b/flink/src/test/java/org/apache/iceberg/flink/sink/TestFlinkIcebergSink.java
@@ -39,6 +39,7 @@
 import org.apache.iceberg.FileFormat;
 import org.apache.iceberg.Table;
 import org.apache.iceberg.TableProperties;
+import org.apache.iceberg.flink.FlinkTableProperties;
 import org.apache.iceberg.flink.SimpleDataUtil;
 import org.apache.iceberg.flink.TableLoader;
 import org.apache.iceberg.relocated.com.google.common.collect.ImmutableMap;
@@ -58,7 +59,7 @@ public class TestFlinkIcebergSink extends AbstractTestBase {
       SimpleDataUtil.FLINK_SCHEMA.getFieldTypes());
   private static final DataFormatConverters.RowConverter CONVERTER = new DataFormatConverters.RowConverter(
       SimpleDataUtil.FLINK_SCHEMA.getFieldDataTypes());
-
+  private static final int ROW_COUNTS = 1000;
   @Rule
   public TemporaryFolder tempFolder = new TemporaryFolder();
 
@@ -118,6 +119,45 @@ private List<RowData> convertToRowData(List<Row> rows) {
     return rows.stream().map(CONVERTER::toInternal).collect(Collectors.toList());
   }
 
+  @Test
+  public void testWriteRowDataWithRewrite() throws Exception {
+    List<Row> rows = SimpleDataUtil.generateRows(ROW_COUNTS);
+
+    DataStream<RowData> dataStream = env.addSource(new FiniteTestSource<>(rows), ROW_TYPE_INFO)
+        .map(CONVERTER::toInternal, RowDataTypeInfo.of(SimpleDataUtil.ROW_TYPE));
+    File folder = tempFolder.newFolder();
+    String warehouse = folder.getAbsolutePath();
+
+    tablePath = warehouse.concat("/test");
+    Assert.assertTrue("Should create the table path correctly.", new File(tablePath).mkdir());
+
+    Map<String, String> props = ImmutableMap.of(TableProperties.DEFAULT_FILE_FORMAT, format.name());
+    table = SimpleDataUtil.createTable(tablePath, props, partitioned);
+
+    table.updateProperties()
+        .set(FlinkTableProperties.NUMS_NEW_SNAPSHOT_MERGE, String.valueOf(5))
+        .set(FlinkTableProperties.SNAPSHOT_RETAIN_LAST_MINUTES, String.valueOf(1))
+        .set(FlinkTableProperties.SNAPSHOT_RETAIN_LAST_NUMS, String.valueOf(1))
+        .commit();
+
+    FlinkSink.forRowData(dataStream)
+        .table(table)
+        .tableLoader(tableLoader)
+        .build();
+
+    env.execute("Test Iceberg Write with Rewrite");
+
+    List<RowData> expectedRows = Lists.newArrayList(Iterables.concat(convertToRowData(rows),
+        convertToRowData(rows)));
+    SimpleDataUtil.assertTableRows(tablePath, expectedRows);
+
+    table.updateProperties()
+        .remove(FlinkTableProperties.NUMS_NEW_SNAPSHOT_MERGE)
+        .remove(FlinkTableProperties.SNAPSHOT_RETAIN_LAST_MINUTES)
+        .remove(FlinkTableProperties.SNAPSHOT_RETAIN_LAST_NUMS)
+        .commit();
+  }
+
   @Test
   public void testWriteRowData() throws Exception {
     List<Row> rows = Lists.newArrayList(
diff --git a/flink/src/test/java/org/apache/iceberg/flink/sink/TestIcebergFilesCommitter.java b/flink/src/test/java/org/apache/iceberg/flink/sink/TestIcebergFilesCommitter.java
index 2ce7c368600..1f604a2b6ab 100644
--- a/flink/src/test/java/org/apache/iceberg/flink/sink/TestIcebergFilesCommitter.java
+++ b/flink/src/test/java/org/apache/iceberg/flink/sink/TestIcebergFilesCommitter.java
@@ -98,7 +98,7 @@ public void testCommitTxnWithoutDataFiles() throws Exception {
     long checkpointId = 0;
     long timestamp = 0;
     JobID jobId = new JobID();
-    try (OneInputStreamOperatorTestHarness<DataFile, Void> harness = createStreamSink(jobId)) {
+    try (OneInputStreamOperatorTestHarness<DataFile, Long> harness = createStreamSink(jobId)) {
       harness.setup();
       harness.open();
 
@@ -129,7 +129,7 @@ public void testCommitTxn() throws Exception {
     long timestamp = 0;
 
     JobID jobID = new JobID();
-    try (OneInputStreamOperatorTestHarness<DataFile, Void> harness = createStreamSink(jobID)) {
+    try (OneInputStreamOperatorTestHarness<DataFile, Long> harness = createStreamSink(jobID)) {
       harness.setup();
       harness.open();
       assertSnapshotSize(0);
@@ -162,7 +162,7 @@ public void testOrderedEventsBetweenCheckpoints() throws Exception {
     long timestamp = 0;
 
     JobID jobId = new JobID();
-    try (OneInputStreamOperatorTestHarness<DataFile, Void> harness = createStreamSink(jobId)) {
+    try (OneInputStreamOperatorTestHarness<DataFile, Long> harness = createStreamSink(jobId)) {
       harness.setup();
       harness.open();
 
@@ -209,7 +209,7 @@ public void testDisorderedEventsBetweenCheckpoints() throws Exception {
     long timestamp = 0;
 
     JobID jobId = new JobID();
-    try (OneInputStreamOperatorTestHarness<DataFile, Void> harness = createStreamSink(jobId)) {
+    try (OneInputStreamOperatorTestHarness<DataFile, Long> harness = createStreamSink(jobId)) {
       harness.setup();
       harness.open();
 
@@ -254,7 +254,7 @@ public void testRecoveryFromValidSnapshot() throws Exception {
     OperatorSubtaskState snapshot;
 
     JobID jobId = new JobID();
-    try (OneInputStreamOperatorTestHarness<DataFile, Void> harness = createStreamSink(jobId)) {
+    try (OneInputStreamOperatorTestHarness<DataFile, Long> harness = createStreamSink(jobId)) {
       harness.setup();
       harness.open();
 
@@ -274,7 +274,7 @@ public void testRecoveryFromValidSnapshot() throws Exception {
     }
 
     // Restore from the given snapshot
-    try (OneInputStreamOperatorTestHarness<DataFile, Void> harness = createStreamSink(jobId)) {
+    try (OneInputStreamOperatorTestHarness<DataFile, Long> harness = createStreamSink(jobId)) {
       harness.setup();
       harness.initializeState(snapshot);
       harness.open();
@@ -305,7 +305,7 @@ public void testRecoveryFromSnapshotWithoutCompletedNotification() throws Except
     OperatorSubtaskState snapshot;
     List<RowData> expectedRows = Lists.newArrayList();
     JobID jobId = new JobID();
-    try (OneInputStreamOperatorTestHarness<DataFile, Void> harness = createStreamSink(jobId)) {
+    try (OneInputStreamOperatorTestHarness<DataFile, Long> harness = createStreamSink(jobId)) {
       harness.setup();
       harness.open();
 
@@ -322,7 +322,7 @@ public void testRecoveryFromSnapshotWithoutCompletedNotification() throws Except
       assertMaxCommittedCheckpointId(jobId, -1L);
     }
 
-    try (OneInputStreamOperatorTestHarness<DataFile, Void> harness = createStreamSink(jobId)) {
+    try (OneInputStreamOperatorTestHarness<DataFile, Long> harness = createStreamSink(jobId)) {
       harness.setup();
       harness.initializeState(snapshot);
       harness.open();
@@ -346,7 +346,7 @@ public void testRecoveryFromSnapshotWithoutCompletedNotification() throws Except
 
     // Redeploying flink job from external checkpoint.
     JobID newJobId = new JobID();
-    try (OneInputStreamOperatorTestHarness<DataFile, Void> harness = createStreamSink(newJobId)) {
+    try (OneInputStreamOperatorTestHarness<DataFile, Long> harness = createStreamSink(newJobId)) {
       harness.setup();
       harness.initializeState(snapshot);
       harness.open();
@@ -377,7 +377,7 @@ public void testStartAnotherJobToWriteSameTable() throws Exception {
     List<RowData> tableRows = Lists.newArrayList();
 
     JobID oldJobId = new JobID();
-    try (OneInputStreamOperatorTestHarness<DataFile, Void> harness = createStreamSink(oldJobId)) {
+    try (OneInputStreamOperatorTestHarness<DataFile, Long> harness = createStreamSink(oldJobId)) {
       harness.setup();
       harness.open();
 
@@ -403,7 +403,7 @@ public void testStartAnotherJobToWriteSameTable() throws Exception {
     checkpointId = 0;
     timestamp = 0;
     JobID newJobId = new JobID();
-    try (OneInputStreamOperatorTestHarness<DataFile, Void> harness = createStreamSink(newJobId)) {
+    try (OneInputStreamOperatorTestHarness<DataFile, Long> harness = createStreamSink(newJobId)) {
       harness.setup();
       harness.open();
 
@@ -435,7 +435,7 @@ public void testMultipleJobsWriteSameTable() throws Exception {
       int jobIndex = i % 3;
       int checkpointId = i / 3;
       JobID jobId = jobs[jobIndex];
-      try (OneInputStreamOperatorTestHarness<DataFile, Void> harness = createStreamSink(jobId)) {
+      try (OneInputStreamOperatorTestHarness<DataFile, Long> harness = createStreamSink(jobId)) {
         harness.setup();
         harness.open();
 
@@ -460,7 +460,7 @@ public void testMultipleJobsWriteSameTable() throws Exception {
   @Test
   public void testBoundedStream() throws Exception {
     JobID jobId = new JobID();
-    try (OneInputStreamOperatorTestHarness<DataFile, Void> harness = createStreamSink(jobId)) {
+    try (OneInputStreamOperatorTestHarness<DataFile, Long> harness = createStreamSink(jobId)) {
       harness.setup();
       harness.open();
 
@@ -494,7 +494,7 @@ private void assertSnapshotSize(int expectedSnapshotSize) {
     Assert.assertEquals(expectedSnapshotSize, Lists.newArrayList(table.snapshots()).size());
   }
 
-  private OneInputStreamOperatorTestHarness<DataFile, Void> createStreamSink(JobID jobID)
+  private OneInputStreamOperatorTestHarness<DataFile, Long> createStreamSink(JobID jobID)
       throws Exception {
     TestOperatorFactory factory = TestOperatorFactory.of(tablePath);
     return new OneInputStreamOperatorTestHarness<>(factory, createEnvironment(jobID));
@@ -513,8 +513,8 @@ private static MockEnvironment createEnvironment(JobID jobID) {
         .build();
   }
 
-  private static class TestOperatorFactory extends AbstractStreamOperatorFactory<Void>
-      implements OneInputStreamOperatorFactory<DataFile, Void> {
+  private static class TestOperatorFactory extends AbstractStreamOperatorFactory<Long>
+      implements OneInputStreamOperatorFactory<DataFile, Long> {
     private final String tablePath;
 
     private TestOperatorFactory(String tablePath) {
@@ -527,7 +527,7 @@ private static TestOperatorFactory of(String tablePath) {
 
     @Override
     @SuppressWarnings("unchecked")
-    public <T extends StreamOperator<Void>> T createStreamOperator(StreamOperatorParameters<Void> param) {
+    public <T extends StreamOperator<Long>> T createStreamOperator(StreamOperatorParameters<Long> param) {
       IcebergFilesCommitter committer = new IcebergFilesCommitter(TableLoader.fromHadoopTable(tablePath), false);
       committer.setup(param.getContainingTask(), param.getStreamConfig(), param.getOutput());
       return (T) committer;
