diff --git a/airflow/www/forms.py b/airflow/www/forms.py
index 2c8771f51af7b..9e7f07ecd5f8b 100644
--- a/airflow/www/forms.py
+++ b/airflow/www/forms.py
@@ -19,15 +19,16 @@
 import json
 from operator import itemgetter
 
+import pendulum
 from flask_appbuilder.fieldwidgets import (
     BS3PasswordFieldWidget, BS3TextAreaFieldWidget, BS3TextFieldWidget, Select2Widget,
 )
 from flask_appbuilder.forms import DynamicForm
 from flask_babel import lazy_gettext
 from flask_wtf import FlaskForm
-from wtforms import validators
+from wtforms import validators, widgets
 from wtforms.fields import (
-    BooleanField, DateTimeField, IntegerField, PasswordField, SelectField, StringField, TextAreaField,
+    BooleanField, DateTimeField, Field, IntegerField, PasswordField, SelectField, StringField, TextAreaField,
 )
 
 from airflow.models import Connection
@@ -36,6 +37,32 @@
 from airflow.www.widgets import AirflowDateTimePickerWidget
 
 
+class DateTimeWithTimezoneField(Field):
+    """
+    A text field which stores a `datetime.datetime` matching a format.
+    """
+    widget = widgets.TextInput()
+
+    def __init__(self, label=None, validators=None, format='%Y-%m-%d %H:%M:%S%Z', **kwargs):
+        super(DateTimeWithTimezoneField, self).__init__(label, validators, **kwargs)
+        self.format = format
+
+    def _value(self):
+        if self.raw_data:
+            return ' '.join(self.raw_data)
+        else:
+            return self.data and self.data.strftime(self.format) or ''
+
+    def process_formdata(self, valuelist):
+        if valuelist:
+            date_str = ' '.join(valuelist)
+            try:
+                self.data = pendulum.parse(date_str)
+            except ValueError:
+                self.data = None
+                raise ValueError(self.gettext('Not a valid datetime value'))
+
+
 class DateTimeForm(FlaskForm):
     # Date filter form needed for task views
     execution_date = DateTimeField(
@@ -80,7 +107,7 @@ class DagRunForm(DynamicForm):
         lazy_gettext('State'),
         choices=(('success', 'success'), ('running', 'running'), ('failed', 'failed'),),
         widget=Select2Widget())
-    execution_date = DateTimeField(
+    execution_date = DateTimeWithTimezoneField(
         lazy_gettext('Execution Date'),
         widget=AirflowDateTimePickerWidget())
     external_trigger = BooleanField(
@@ -91,10 +118,7 @@ class DagRunForm(DynamicForm):
         widget=BS3TextAreaFieldWidget())
 
     def populate_obj(self, item):
-        # TODO: This is probably better done as a custom field type so we can
-        # set TZ at parse time
         super().populate_obj(item)
-        item.execution_date = timezone.make_aware(item.execution_date)
         if item.conf:
             item.conf = json.loads(item.conf)
 
diff --git a/tests/www/test_views.py b/tests/www/test_views.py
index 343fea8ef8599..848df86665fe7 100644
--- a/tests/www/test_views.py
+++ b/tests/www/test_views.py
@@ -29,7 +29,7 @@
 import unittest
 import urllib
 from contextlib import contextmanager
-from datetime import datetime as dt, timedelta
+from datetime import datetime as dt, timedelta, timezone as tz
 from typing import Any, Dict, Generator, List, NamedTuple
 from unittest import mock
 from urllib.parse import quote_plus
@@ -2587,11 +2587,11 @@ def setUpClass(cls):
     def tearDown(self):
         self.clear_table(models.DagRun)
 
-    def test_create_dagrun(self):
+    def test_create_dagrun_execution_date_with_timezone(self):
         data = {
             "state": "running",
             "dag_id": "example_bash_operator",
-            "execution_date": "2018-07-06 05:04:03",
+            "execution_date": "2018-07-06 05:04:03-02:00",
             "run_id": "test_create_dagrun",
         }
         resp = self.client.post('/dagrun/add',
@@ -2601,14 +2601,14 @@ def test_create_dagrun(self):
 
         dr = self.session.query(models.DagRun).one()
 
-        self.assertEqual(dr.execution_date, timezone.convert_to_utc(datetime(2018, 7, 6, 5, 4, 3)))
+        self.assertEqual(dr.execution_date, dt(2018, 7, 6, 5, 4, 3, tzinfo=tz(timedelta(hours=-2))))
 
     def test_create_dagrun_valid_conf(self):
         conf_value = dict(Valid=True)
         data = {
             "state": "running",
             "dag_id": "example_bash_operator",
-            "execution_date": "2018-07-06 05:05:03",
+            "execution_date": "2018-07-06 05:05:03-02:00",
             "run_id": "test_create_dagrun_valid_conf",
             "conf": json.dumps(conf_value)
         }
