diff --git a/heron/api/src/java/com/twitter/heron/api/Config.java b/heron/api/src/java/com/twitter/heron/api/Config.java
index 23af1ee256a..58e07af6fe1 100644
--- a/heron/api/src/java/com/twitter/heron/api/Config.java
+++ b/heron/api/src/java/com/twitter/heron/api/Config.java
@@ -146,6 +146,60 @@ public class Config extends HashMap<String, Object> {
    * spout0:12434,spout1:345353,bolt1:545356.
    */
   public static final String TOPOLOGY_COMPONENT_RAMMAP = "topology.component.rammap";
+  /**
+   * Is this topology stateful? The format of this flag is boolean
+   * When set to true, Heron will try to take the snapshots of
+   * all of the components of the topology every
+   * TOPOLOGY_STATEFUL_CHECKPOINT_INTERVAL_SECONDS seconds. Upon failure of
+   * any component, its state is recovered to the last checkpoint saved. The
+   * spouts/bolts of the topology have to implement IStatefulComponent for state
+   * to be actually captured.
+   * Setting this flag to false does not initiate any checkpointing
+   * mechanism. This means that even if the components themselves are
+   * IStatefulComponents their state is not saved/recovered.
+   */
+  public static final String TOPOLOGY_STATEFUL_ENABLED = "topology.stateful.enabled";
+  /**
+   * What's the checkpoint interval for stateful topologies in seconds
+   */
+  public static final String TOPOLOGY_STATEFUL_CHECKPOINT_INTERVAL_SECONDS =
+                             "topology.stateful.checkpoint.interval.seconds";
+  /**
+   * What's the provider for state? i.e. one where state is stored
+   */
+  public static final String TOPOLOGY_STATEFUL_PROVIDER_CLASS =
+                             "topology.stateful.provider.class";
+  /**
+   * What's the config for state provider?
+   */
+  public static final String TOPOLOGY_STATEFUL_PROVIDER_CONFIG_FILE =
+                             "topology.stateful.provider.config.file";
+  /**
+   * Boolean flag that says that the stateful topology should start from
+   * clean state, i.e. ignore any checkpoint state
+   */
+  public static final String TOPOLOGY_STATEFUL_START_CLEAN =
+                             "topology.stateful.start.clean";
+  /**
+   * Do we want to run this topology in exactly once semantics?
+   * The format of this flag is boolean.
+   * When set to true, Heron will try to do a distributed checkpoint
+   * based on Lamport's idea of distributed snapshotting every
+   * TOPOLOGY_STATEFUL_CHECKPOINT_INTERVAL_SECONDS seconds. When any component
+   * of the topology dies, Heron initiates a recovery mechanism to restart
+   * the topology from the last globally consistent checkpoint.
+   * Heron topologies can be run in many modes.
+   * 1. When TOPOLOGY_ENABLE_ACKING is enabled, Heron will run the topology
+   * in the classic atleast-once semantics.
+   * 2. When TOPOLOGY_EXACTLYONCE_ENABLED is enabled, Heron will run the
+   * topology in exactly once sematics. Note that the spouts/bolts have to
+   * implement IStatefulComponents for them to really save/restore their state.
+   * 3. When neither is enabled, the topology is run in atmost-once semantics
+   * 4. If both TOPOLOGY_ENABLE_ACKING and TOPOLOGY_EXACTLYONCE_ENABLED are set
+   * then the TOPOLOGY_EXACTLYONCE_ENABLED semantics has preference and the
+   * topology is run in exactly once semantics
+   */
+  public static final String TOPOLOGY_EXACTLYONCE_ENABLED = "topology.exactlyonce.enabled";
   /**
    * Name of the topology. This config is automatically set by Heron when the topology is submitted.
    */
@@ -209,6 +263,12 @@ public class Config extends HashMap<String, Object> {
     apiVars.add(TOPOLOGY_CONTAINER_MAX_RAM_HINT);
     apiVars.add(TOPOLOGY_CONTAINER_PADDING_PERCENTAGE);
     apiVars.add(TOPOLOGY_COMPONENT_RAMMAP);
+    apiVars.add(TOPOLOGY_STATEFUL_START_CLEAN);
+    apiVars.add(TOPOLOGY_STATEFUL_CHECKPOINT_INTERVAL_SECONDS);
+    apiVars.add(TOPOLOGY_STATEFUL_PROVIDER_CLASS);
+    apiVars.add(TOPOLOGY_STATEFUL_PROVIDER_CONFIG_FILE);
+    apiVars.add(TOPOLOGY_STATEFUL_ENABLED);
+    apiVars.add(TOPOLOGY_EXACTLYONCE_ENABLED);
     apiVars.add(TOPOLOGY_NAME);
     apiVars.add(TOPOLOGY_TEAM_NAME);
     apiVars.add(TOPOLOGY_TEAM_EMAIL);
@@ -388,6 +448,31 @@ public static void setComponentJvmOptions(
 
   }
 
+  public static void setTopologyStatefulEnabled(Map<String, Object> conf, boolean stateful) {
+    conf.put(Config.TOPOLOGY_STATEFUL_ENABLED, String.valueOf(stateful));
+  }
+
+  public static void setTopologyStatefulCheckpointIntervalSecs(Map<String, Object> conf, int secs) {
+    conf.put(Config.TOPOLOGY_STATEFUL_CHECKPOINT_INTERVAL_SECONDS, Integer.toString(secs));
+  }
+
+  public static void setTopologyStatefulProviderClass(Map<String, Object> conf, String provider) {
+    conf.put(Config.TOPOLOGY_STATEFUL_PROVIDER_CLASS, provider);
+  }
+
+  public static void setTopologyStatefulProviderConfigFile(Map<String, Object> conf,
+                                                           String config) {
+    conf.put(Config.TOPOLOGY_STATEFUL_PROVIDER_CONFIG_FILE, config);
+  }
+
+  public static void setTopologyStatefulStartClean(Map<String, Object> conf, boolean clean) {
+    conf.put(Config.TOPOLOGY_STATEFUL_START_CLEAN, String.valueOf(clean));
+  }
+
+  public static void setTopologyExactlyOnceEnabled(Map<String, Object> conf, boolean exactOnce) {
+    conf.put(Config.TOPOLOGY_EXACTLYONCE_ENABLED, String.valueOf(exactOnce));
+  }
+
   public void setDebug(boolean isOn) {
     setDebug(this, isOn);
   }
@@ -509,4 +594,28 @@ public void setComponentJvmOptions(String component, String jvmOptions) {
   public Set<String> getApiVars() {
     return apiVars;
   }
+
+  public void setTopologyStatefulEnabled(boolean stateful) {
+    setTopologyStatefulEnabled(this, stateful);
+  }
+
+  public void setTopologyStatefulCheckpointIntervalSecs(int secs) {
+    setTopologyStatefulCheckpointIntervalSecs(this, secs);
+  }
+
+  public void setTopologyStatefulProviderClass(String provider) {
+    setTopologyStatefulProviderClass(this, provider);
+  }
+
+  public void setTopologyStatefulProviderConfigFile(String config) {
+    setTopologyStatefulProviderConfigFile(this, config);
+  }
+
+  public void setTopologyStatefulStartClean(boolean clean) {
+    setTopologyStatefulStartClean(this, clean);
+  }
+
+  public void setTopologyExactlyOnceEnabled(boolean exactOnce) {
+    setTopologyExactlyOnceEnabled(this, exactOnce);
+  }
 }
diff --git a/heron/api/src/java/com/twitter/heron/api/state/HashMapState.java b/heron/api/src/java/com/twitter/heron/api/state/HashMapState.java
new file mode 100644
index 00000000000..5ccb6cca12e
--- /dev/null
+++ b/heron/api/src/java/com/twitter/heron/api/state/HashMapState.java
@@ -0,0 +1,26 @@
+// Copyright 2016 Twitter. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.twitter.heron.api.state;
+
+import java.io.Serializable;
+import java.util.HashMap;
+
+/**
+ * A State backed up by HashMap
+ */
+public class HashMapState<K extends Serializable, V extends Serializable>
+             extends HashMap<K, V> implements State<K, V> {
+  private static final long serialVersionUID = -6152858128057246318L;
+}
diff --git a/heron/api/src/java/com/twitter/heron/api/state/State.java b/heron/api/src/java/com/twitter/heron/api/state/State.java
new file mode 100644
index 00000000000..da56b88cad7
--- /dev/null
+++ b/heron/api/src/java/com/twitter/heron/api/state/State.java
@@ -0,0 +1,26 @@
+// Copyright 2016 Twitter. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.twitter.heron.api.state;
+
+import java.io.Serializable;
+import java.util.Map;
+
+/**
+ * State represents the state interface as seen by stateful bolts and spouts.
+ * In Heron, state gives a notional Key/Value interface along with the
+ * ability to iterate over the key/values
+ */
+public interface State<K extends Serializable, V extends Serializable> extends Map<K, V> {
+}
diff --git a/heron/api/src/java/com/twitter/heron/api/topology/IStatefulComponent.java b/heron/api/src/java/com/twitter/heron/api/topology/IStatefulComponent.java
new file mode 100644
index 00000000000..222cd7de5c1
--- /dev/null
+++ b/heron/api/src/java/com/twitter/heron/api/topology/IStatefulComponent.java
@@ -0,0 +1,47 @@
+// Copyright 2016 Twitter. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package com.twitter.heron.api.topology;
+
+import java.io.Serializable;
+
+import com.twitter.heron.api.state.State;
+
+/**
+ * Defines a component that saves its internal state in the State interface
+ */
+public interface IStatefulComponent<K extends Serializable, V extends Serializable>
+                 extends IComponent {
+
+  /**
+   * Initializes the state of the function or operator to that of a previous checkpoint.
+   * This method is invoked when a component is executed as part of a recovery run. In case
+   * there was prior state associated with the component, the state will be empty.
+   * Stateful Spouts/Bolts are expected to hold on to the state variable to save their
+   * internal state
+   * <p>
+   * Note that initialState() is called before open() or prepare().
+   *
+   * @param state the previously saved state of the component.
+   */
+  void initState(State<K, V> state);
+
+  /**
+   * This is a hook for the component to perform some actions just before the
+   * framework saves its state.
+   *
+   * @param checkpointId the ID of the checkpoint
+   */
+  void preSave(String checkpointId);
+}
