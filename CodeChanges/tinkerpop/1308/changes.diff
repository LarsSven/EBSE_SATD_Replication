diff --git a/CHANGELOG.asciidoc b/CHANGELOG.asciidoc
index 12a53ecd707..94449cf2445 100644
--- a/CHANGELOG.asciidoc
+++ b/CHANGELOG.asciidoc
@@ -65,8 +65,10 @@ This release also includes changes from <<release-3-4-3, 3.4.3>>.
 * Added kerberos authentication to Gremlin-Python.
 * Added audit logging to bytecode-based traversals.
 * Changed `TraversalStrategy` application methodology to apply each strategy in turn to each level of the traversal hierarchy starting from root down to children.
+* Added a VertexProgramRestrictionStrategy.
 * Prevented more than one `Client` from connecting to the same Gremlin Server session.
 * Changed the Groovy dependency in `gremlin-driver` to a `provided` scope.
+* Added support for configuring an `Authorizer` implementation to Gremlin Server, allowing for authorization of individual gremlin requests.
 * Removed internal functionality for the session close message in Gremlin Server - the message is accepted but ignored if sent.
 * Removed `Property.Exceptions.propertyValueCanNotBeNull` exception type as `null` now has meaning in Gremlin.
 * Removed the "experimental" support for multi/meta-properties in Neo4j.
@@ -88,6 +90,8 @@ This release also includes changes from <<release-3-4-3, 3.4.3>>.
 * Removed previously deprecated `AbstractOpProcessor.generateMetaData(ChannelHandlerContext, RequestMessage, ResponseStatusCode, Iterator)`
 * Removed previously deprecated `BulkDumperVertexProgram` and `BulkLoaderVertexProgram`.
 
+!!! Improvements: do not forget to close TINKERPOP-2418 (StateKey.AUTHENTICATED_USER) when merging the PR for TINKERPOP-2389 (Authorization)
+
 == TinkerPop 3.4.0 (Avant-Gremlin Construction #3 for Theremin and Flowers)
 
 image::https://raw.githubusercontent.com/apache/tinkerpop/master/docs/static/images/avant-gremlin.png[width=185]
@@ -1867,7 +1871,7 @@ This release also includes changes from <<release-3-1-7, 3.1.7>>.
 * Fixed a bug in `RepeatUnrollStrategy` where `LoopsStep` and `LambdaHolder` should invalidate the strategy's application.
 * Deprecated `authentication.className` setting in favor of using `authentication.authenticator`.
 * Added `authentication.authenticationHandler` setting.
-* Added abstraction to authorization to allow users to plug in their own `AbstractAuthorizationHandler` implementations.
+* Added abstraction to authentication to allow users to plug in their own `AbstractAuthenticationHandler` implementations.
 * Fixed a `NullPointerException` bug in `B_LP_O_S_SE_SL_Traverser`.
 * `PathRetractionStrategy` now uses the marker-model to reduce recursive lookups of invalidating steps.
 * `ProfileStrategy` now uses the marker-model to reduce recursive lookups of `ProfileSideEffectStep`.
diff --git a/docs/src/dev/provider/index.asciidoc b/docs/src/dev/provider/index.asciidoc
index 02162a43d0a..aa820213e53 100644
--- a/docs/src/dev/provider/index.asciidoc
+++ b/docs/src/dev/provider/index.asciidoc
@@ -1080,7 +1080,7 @@ a different language.
 
 Unlike Standard and Session OpProcessors, the Traversal OpProcessor does not simply return the results of the
 `Traversal`. It instead returns `Traverser` objects which allows the client to take advantage of
-link:https://tinkerpop.apache.org/docs/current/reference/#barrier-step[bulking]. To describe this interaction more
+link:https://tinkerpop.apache.org/docs/x.y.z/reference/#barrier-step[bulking]. To describe this interaction more
 directly, the returned `Traverser` will represent some value from the `Traversal` result and the number of times it
 is represented in the full stream of results. So, if a `Traversal` happens to return the same vertex twenty times
 it won't return twenty instances of the same object. It will return one in `Traverser` with the `bulk` value set to
@@ -1147,25 +1147,43 @@ one key value pair present (since only one `Traversal` is being submitted, there
 single alias).
 |=========================================================
 
-=== Authentication
+=== Authentication and Authorization
 
 Gremlin Server supports link:https://en.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer[SASL-based]
 authentication.  A SASL implementation provides a series of challenges and responses that a driver must comply with
-in order to authenticate.  By default, Gremlin Server only supports the "PLAIN" SASL mechanism, which is a cleartext
-password system.  When authentication is enabled, an incoming request is intercepted before it is evaluated by the
-`ScriptEngine`.  The request is saved on the server and a `AUTHENTICATE` challenge response (status code `407`) is
-returned to the client.
-
-The client will detect the `AUTHENTICATE` and respond with an `authentication` for the `op` and an `arg` named `sasl`
-that contains the password.  The password should be either, an encoded sequence of UTF-8 bytes, delimited by 0
-(US-ASCII NUL), where the form is : `<NUL>username<NUL>password`, or a Base64 encoded string of the former (which
-in this instance would be `AHVzZXJuYW1lAHBhc3N3b3Jk`).  Should Gremlin Server be able to authenticate with the
-provided credentials, the server will return the results of the original request as it normally does without
-authentication.  If it cannot authenticate given the challenge response from the client, it will return `UNAUTHORIZED`
-(status code `401`).
+in order to authenticate.  Gremlin Server supports the "PLAIN" SASL mechanism, which is a cleartext
+password system, for all link:https://tinkerpop.apache.org/docs/current/tutorials/gremlin-language-variants/[Gremlin Language Variants].
+Other SASL mechanisms supported for selected clients are listed in the
+link:https://tinkerpop.apache.org/docs/x.y.z/reference/#security[security section of the Gremlin Server reference documentation].
+
+When authentication is enabled, an incoming request is intercepted before it is evaluated by the `ScriptEngine`.  The
+request is saved on the server and a `AUTHENTICATE` challenge response (status code `407`) is returned to the client.
+
+The client will detect the `AUTHENTICATE` and respond with an `authentication` for the `op` and an `arg` named `sasl`.
+In case of the "PLAIN" SASL mechanism the `arg` contains the password.  The password should be either, an encoded
+sequence of UTF-8 bytes, delimited by 0 (US-ASCII NUL), where the form is : `<NUL>username<NUL>password`, or a Base64
+encoded string of the former (which in this instance would be `AHVzZXJuYW1lAHBhc3N3b3Jk`).  Should Gremlin Server be
+able to authenticate with the provided credentials, the server will return the results of the original request as it
+normally does without authentication.  If it cannot authenticate given the challenge response from the client, it will
+return `UNAUTHORIZED` (status code `401`).
 
 NOTE: Gremlin Server does not support the "authorization identity" as described in link:https://tools.ietf.org/html/rfc4616[RFC4616].
 
+In addition to authenticating users at the start of a connection, Gremlin Server allows providers to authorize users on
+a per request basis. If
+link:https://tinkerpop.apache.org/docs/x.y.z/reference/#_configuring_2[a java class is configured] that implements the
+link:https://tinkerpop.apache.org/javadocs/x.y.z/full/org/apache/tinkerpop/gremlin/server/authz/Authorizer.html[Authorizer interface],
+Gremlin Server passes each request to this `Authorizer`. The `Authorizer` can deny authorization for the request by
+throwing an exception and Gremlin Server returns `UNAUTHORIZED` (status code `401`) to the client. The `Authorizer`
+authorizes the request by returning the original request or the request with some additional constraints. Gremlin Server
+proceeds with the returned request and on its turn returns the result of the request to the client. More details on
+implementing authorization can be found in the
+link:https://tinkerpop.apache.org/docs/x.y.z/reference/#security[reference documentation for Gremlin Server security].
+
+NOTE: While Gremlin Server supports this authorization feature it is not a feature that TinkerPop requires of graph
+providers as part of the agreement between client and server.
+
+
 [[gremlin-plugins]]
 == Gremlin Plugins
 
diff --git a/docs/src/index.asciidoc b/docs/src/index.asciidoc
index dcd22f9b5eb..549cb6ddecd 100644
--- a/docs/src/index.asciidoc
+++ b/docs/src/index.asciidoc
@@ -108,5 +108,5 @@ Provides information on ways to contribute to TinkerPop as well as details on bu
 |image:tinkerpop-enabled.png[width=200] |link:https://tinkerpop.apache.org/docs/x.y.z/dev/provider/[Providers] +
 Documentation for providers who implement the TinkerPop interfaces, develop plugins or drivers, or provide other third-party libraries for TinkerPop.
 |image:gremlin-io2.png[width=200] |link:https://tinkerpop.apache.org/docs/x.y.z/dev/io/[IO Reference] +
-Reference Documentation for providers and users of the various IO formats that TinkerPop has: GraphML, GraphSON and Gryo.
+Reference Documentation for providers and users of the various IO formats that TinkerPop has: GraphML, GraphSON, GraphBinary and Gryo.
 |=========================================================
diff --git a/docs/src/recipes/centrality.asciidoc b/docs/src/recipes/centrality.asciidoc
index 79d5f015d15..d75dbc66e4f 100644
--- a/docs/src/recipes/centrality.asciidoc
+++ b/docs/src/recipes/centrality.asciidoc
@@ -103,7 +103,7 @@ g.V().as("v").
 
 WARNING: Since the betweeness centrality algorithm requires the shortest path between any pair of vertices in the graph,
 its practical applications are very limited. It's recommended to use this algorithm only on small subgraphs (graphs like
-the link:https://tinkerpop.apache.org/docs/current/reference/#grateful-dead[Grateful Dead graph] with only 808 vertices
+the link:https://tinkerpop.apache.org/docs/x.y.z/reference/#grateful-dead[Grateful Dead graph] with only 808 vertices
 and 8049 edges already require a massive amount of compute resources to determine the shortest paths between all vertex
 pairs).
 
@@ -141,7 +141,7 @@ g.withSack(1f).V().as("v").
 
 WARNING: Since the closeness centrality algorithm requires the shortest path between any pair of vertices in the graph,
 its practical applications are very limited. It's recommended to use this algorithm only on small subgraphs (graphs like
-the link:https://tinkerpop.apache.org/docs/current/reference/#grateful-dead[Grateful Dead graph] with only 808 vertices
+the link:https://tinkerpop.apache.org/docs/x.y.z/reference/#grateful-dead[Grateful Dead graph] with only 808 vertices
 and 8049 edges already require a massive amount of compute resources to determine the shortest paths between all vertex
 pairs).
 
@@ -168,7 +168,7 @@ passes through using the vertex as the key. The `Map` of this group count is sto
 time to converge on a solution. Calling `cap('m')` at the end simply extracts the `Map` side-effect stored in "m".
 <2> The entries in the `Map` are then iterated and sorted with the top ten most central vertices presented as output.
 <3> The previous examples can be expanded on a little bit by including a
-link:https://tinkerpop.apache.org/docs/current/reference/#timelimit-step[time limit]. The `timeLimit()` prevents the
+link:https://tinkerpop.apache.org/docs/x.y.z/reference/#timelimit-step[time limit]. The `timeLimit()` prevents the
 traversal from taking longer than one hundred milliseconds to execute (the previous example takes considerably longer
 than that). While the answer provided with the `timeLimit()` is not the absolute ranking, it does provide a relative
 ranking that closely matches the absolute one. The use of `timeLimit()` in certain algorithms (e.g. recommendations)
diff --git a/docs/src/recipes/collections.asciidoc b/docs/src/recipes/collections.asciidoc
index 9ab74eab75c..9efda1b91e4 100644
--- a/docs/src/recipes/collections.asciidoc
+++ b/docs/src/recipes/collections.asciidoc
@@ -22,7 +22,7 @@ image:gremlin-collections.png[width=400]
 Lists and maps form the basis for much of the processing in Gremlin traversals. They are core to how side-effects
 are typically held and how results are generally produced. Being able to pick them apart and reformat them is sometimes
 required. This need to shape the data within a traversal may arise both at the
-link:https://tinkerpop.apache.org/docs/current/reference/#terminal-steps[terminal step] of the traversal (technically
+link:https://tinkerpop.apache.org/docs/x.y.z/reference/#terminal-steps[terminal step] of the traversal (technically
 just prior to the terminal step) or in the middle of a traversal. Considering the former, a transformation just prior
 to iteration will get the result into the form required by the application which would remove the need for additional
 application level manipulation. Moreover, a transformation at this stage may reduce the size of the payload being
diff --git a/docs/src/recipes/recommendation.asciidoc b/docs/src/recipes/recommendation.asciidoc
index d16f7ee8a8f..aab20a4059c 100644
--- a/docs/src/recipes/recommendation.asciidoc
+++ b/docs/src/recipes/recommendation.asciidoc
@@ -269,7 +269,7 @@ place additional limits on the traversal to have it better return more quickly a
 Gremlin provides a number of steps that can help with these limits like:
 link:https://tinkerpop.apache.org/docs/x.y.z/reference/#coin-step[coin()],
 link:https://tinkerpop.apache.org/docs/x.y.z/reference/#sample-step[sample()], and
-link:https://tinkerpop.apache.org/docs/current/reference/#timelimit-step[timeLimit()]. For example, to have the
+link:https://tinkerpop.apache.org/docs/x.y.z/reference/#timelimit-step[timeLimit()]. For example, to have the
 traversal sample the data for no longer than one second, the previous "basic" recommendation could be changed to:
 
 [gremlin-groovy,existing]
diff --git a/docs/src/reference/gremlin-applications.asciidoc b/docs/src/reference/gremlin-applications.asciidoc
index 89ecc4a74f8..6d197a210a2 100644
--- a/docs/src/reference/gremlin-applications.asciidoc
+++ b/docs/src/reference/gremlin-applications.asciidoc
@@ -941,9 +941,12 @@ The following table describes the various YAML configuration options that Gremli
 |Key |Description |Default
 |authentication.authenticator |The fully qualified classname of an `Authenticator` implementation to use.  If this setting is not present, then authentication is effectively disabled. |`AllowAllAuthenticator`
 |authentication.authenticationHandler | The fully qualified classname of an `AbstractAuthenticationHandler` implementation to use. If this setting is not present, but the `authentication.authenticator` is, it will use that authenticator with the default `AbstractAuthenticationHandler` implementation for the specified `Channelizer` |_none_
-|authentication.config |A `Map` of configuration settings to be passes to the `Authenticator` when it is constructed.  The settings available are dependent on the implementation. |_none_
-|authentication.enableAuditLog |The available authenticators can issue audit logging messages, binding the authenticated user to his remote socket address and binding requests with a gremlin query to the remote socket address. For privacy reasons, the default value of this setting is false. The audit logging messages are logged at the INFO level via the `audit.org.apache.tinkerpop.gremlin.server` logger, which can be configured using the log4j.properties file. |false
+|authentication.config |A `Map` of configuration settings to be passed to the `Authenticator` when it is constructed.  The settings available are dependent on the implementation. |_none_
+|authentication.enableAuditLog |Deprecated: replaced by `enableAuditLog` with slight changes in the log message format. |_false_
+|authorization.authorizer |The fully qualified classname of an `Authorizer` implementation to use. |_none_
+|authorization.config |A `Map` of configuration settings to be passed to the `Authorizer` when it is constructed.  The settings available are dependent on the implementation. |_none_
 |channelizer |The fully qualified classname of the `Channelizer` implementation to use.  A `Channelizer` is a "channel initializer" which Gremlin Server uses to define the type of processing pipeline to use.  By allowing different `Channelizer` implementations, Gremlin Server can support different communication protocols (e.g. WebSocket). |`WebSocketChannelizer`
+|enableAuditLog |The `AuthenticationHandler`, `AuthorizationHandler` and processors can issue audit logging messages with the authenticated user, remote socket address and requests with a gremlin query. For privacy reasons, the default value of this setting is false. The audit logging messages are logged at the INFO level via the `audit.org.apache.tinkerpop.gremlin.server` logger, which can be configured using the log4j.properties file. |_false_
 |graphManager |The fully qualified classname of the `GraphManager` implementation to use.  A `GraphManager` is a class that adheres to the TinkerPop `GraphManager` interface, allowing custom implementations for storing and managing graph references, as well as defining custom methods to open and close graphs instantiations. It is important to note that the TinkerPop HTTP and WebSocketChannelizers auto-commit and auto-rollback based on the graphs stored in the graphManager upon script execution completion. To prevent Gremlin Server from starting when all graphs fails, the `CheckedGraphManager` can be used.|`DefaultGraphManager`
 |graphs |A `Map` of `Graph` configuration files where the key of the `Map` becomes the name to which the `Graph` will be bound and the value is the file name of a `Graph` configuration file. |_none_
 |gremlinPool |The number of "Gremlin" threads available to execute actual scripts in a `ScriptEngine`. This pool represents the workers available to handle blocking operations in Gremlin Server. When set to `0`, Gremlin Server will use the value provided by `Runtime.availableProcessors()`. |0
@@ -1053,12 +1056,218 @@ method for processing script evaluation requests.
 The `TraversalOpProcessor` provides a way to accept traversals configured via <<connecting-via-drivers,withRemote()>>.
 It has no special configuration settings.
 
+==== Serialization
+
+Gremlin Server can accept requests and return results using different serialization formats. Serializers implement the
+`MessageSerializer` interface. In doing so, they express the list of mime types they expect to support. When
+configuring multiple serializers it is possible for two or more serializers to support the same mime type. Such a
+situation may be common with a generic mime type such as `application/json`. Serializers are added in the order that
+they are encountered in the configuration file and the first one added for a specific mime type will not be overridden
+by other serializers that also support it.
+
+The format of the serialization is configured by the `serializers` setting described in the table above.  Note that
+some serializers have additional configuration options as defined by the `serializers[X].config` setting.  The
+`config` setting is a `Map` where the keys and values get passed to the serializer at its initialization.  The
+available and/or expected keys are dependent on the serializer being used.  Gremlin Server comes packaged with three
+different serializers: GraphSON, Gryo, and GraphBinary (however, GraphSON and GraphBinary are the only two configured
+by default).
+
+===== GraphSON
+
+The GraphSON serializer produces human readable output in JSON format and is a good configuration choice for those
+trying to use TinkerPop from non-JVM languages.  JSON obviously has wide support across virtually all major
+programming languages and can be consumed by a wide variety of tools. The format itself is described in the
+link:https://tinkerpop.apache.org/docs/current/dev/io/#graphson[IO Documentation].
+
+[source,yaml]
+----
+  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphSONMessageSerializerV1d0 }
+  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphSONMessageSerializerV2d0 }
+----
+
+The above configuration represents the default serialization under the `application/json` MIME type and produces JSON
+consistent with standard JSON data types.  It has the following configuration option:
+
+[width="100%",cols="3,10,^2",options="header"]
+|=========================================================
+|Key |Description |Default
+|ioRegistries |A list of `IoRegistry` implementations to be applied to the serializer. |_none_
+|=========================================================
+
+[source,yaml]
+  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphSONMessageSerializerGremlinV1d0 }
+
+When the standard JSON data types are not enough (e.g. need to identify the difference between `double` and `float`
+data types), the above configuration will embed types into the JSON itself.  The type embedding uses standard Java
+type names, so interpretation from non-JVM languages will be required.  It has the MIME type of
+`application/vnd.gremlin-v1.0+json` and the following configuration options:
+
+[width="100%",cols="3,10,^2",options="header"]
+|=========================================================
+|Key |Description |Default
+|ioRegistries |A list of `IoRegistry` implementations to be applied to the serializer. |_none_
+|=========================================================
+
+===== Gryo
+
+WARNING: Gryo is no longer the recommended serialization format for Gremlin Server. Consider using
+<<server-graphbinary, GraphBinary>> instead.
+
+The Gryo serializer utilizes Kryo-based serialization which produces a binary output.  This format is best consumed
+by JVM-based languages. The format itself is described in the
+link:https://tinkerpop.apache.org/docs/current/dev/io/#gryo[IO Documentation].
+
+[source,yaml]
+  - { className: org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerGremlinV3d0 }
+
+It has the MIME type of `application/vnd.gremlin-v3.0+gryo` and the following configuration options:
+
+[width="100%",cols="3,10,^2",options="header"]
+|=========================================================
+|Key |Description |Default
+|bufferSize |The maximum size of the Kryo buffer for use on a single object being serialized.  Increasing this value will correct `KryoException` errors that complain of "Buffer too small". |_4096_
+|classResolverSupplier |The fully qualified classname of a custom `Supplier<ClassResolver>` which will be used when constructing `Kryo` instances. There is no direct default for this setting, but without a setting the `GryoClassResolver` is used. |_none_
+|custom |A list of classes with custom kryo `Serializer` implementations related to them in the form of `<class>;<serializer-class>`. |_none_
+|ioRegistries |A list of `IoRegistry` implementations to be applied to the serializer. |_none_
+|serializeResultToString |When set to `true`, results are serialized by first calling `toString()` on each object in the result list resulting in an extended MIME Type of `application/vnd.gremlin-v1.0+gryo-stringd`.  When set to `false` Kryo-based serialization is applied. |_false_
+|=========================================================
+
+As described above, there are multiple ways in which to register serializers for Kryo-based serialization.  Note
+that the `ioRegistries` setting is applied first, followed by the `custom` setting.
+
+Those configuring or implementing a `Supplier<ClassResolver>` should consider this an "advanced" option and typically
+important to use cases where server types need to be coerced to client types (i.e. a type is available on the server
+but not on the client).  Implementations should typically instantiate `ClassResolver` implementations that are
+extensions of the `GryoClassResolver` as this class is important to most serialization tasks in TinkerPop.
+
+[[server-graphbinary]]
+===== GraphBinary
+
+GraphBinary is a binary serialization format suitable for object trees, designed to reduce serialization overhead on
+both the client and the server, as well as limiting the size of the payload that is transmitted over the wire. The
+format itself is described in the link:https://tinkerpop.apache.org/docs/current/dev/io/#graphbinary[IO Documentation].
+
+IMPORTANT: GraphBinary is currently only supported on the JVM.
+
+[source,yaml]
+  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphBinaryMessageSerializerV1 }
+
+It has the MIME type of `application/vnd.graphbinary-v1.0` and the following configuration options:
+
+[width="100%",cols="3,10,^2",options="header"]
+|=========================================================
+|Key |Description |Default
+|custom |A list of classes with custom kryo `Serializer` implementations related to them in the form of `<class>;<serializer-class>`. |_none_
+|ioRegistries |A list of `IoRegistry` implementations to be applied to the serializer. |_none_
+|builder |Name of the `TypeSerializerRegistry.Builder` instance to be used to construct the `TypeSerializerRegistry`. |_none_
+|=========================================================
+
+As described above, there are multiple ways in which to register serializers for GraphBinary-based serialization. Note
+that the `ioRegistries` setting is applied first, followed by the `custom` setting.
+
+[[metrics]]
+==== Metrics
+
+Gremlin Server produces metrics about its operations that can yield some insight into how it is performing. These
+metrics are exposed in a variety of ways:
+
+* Directly to the console where Gremlin Server is running
+* CSV file
+* link:http://ganglia.info/[Ganglia]
+* link:http://graphite.wikidot.com/[Graphite]
+* link:http://www.slf4j.org/[SLF4j]
+* link:https://en.wikipedia.org/wiki/Java_Management_Extensions[JMX]
+
+The configuration of each of these outputs is described in the Gremlin Server <<_configuring_2, Configuring>> section.
+Note that Graphite and Ganglia are not included as part of the Gremlin Server distribution and must be installed
+to the server manually.
+
+[source,text]
+----
+bin/gremlin-server.sh install com.codahale.metrics metrics-ganglia 3.0.2
+bin/gremlin-server.sh install com.codahale.metrics metrics-graphite 3.0.2
+----
+
+WARNING: Gremlin Server is built to work with Metrics 3.0.2. Usage of other versions may lead to unexpected problems.
+
+NOTE: Installing Ganglia will include `org.acplt:oncrpc`, which is an LGPL licensed dependency.
+
+Regardless of the output, the metrics gathered are the same. Each metric is prefixed with
+`org.apache.tinkerpop.gremlin.server.GremlinServer` and the following metrics are reported:
+
+* `sessions` - the number of sessions open at the time the metric was last measured.
+* `errors` - the number of total errors, mean rate, as well as the 1, 5, and 15-minute error rates.
+* `op.eval` - the number of script evaluations, mean rate, 1, 5, and 15 minute rates, minimum, maximum, median, mean,
+and standard deviation evaluation times, as well as the 75th, 95th, 98th, 99th and 99.9th percentile evaluation times
+(note that these time apply to both sessionless and in-session requests).
+* `op.traversal` - the number of `Traversal` executions, mean rate, 1, 5, and 15 minute rates, minimum, maximum, median,
+mean, and standard deviation evaluation times, as well as the 75th, 95th, 98th, 99th and 99.9th percentile evaluation
+times.
+* `engine-name.session.session-id.*` - metrics related to different `GremlinScriptEngine` instances configured for
+session-based requests where "engine-name" will be the actual name of the engine, such as "gremlin-groovy" and
+"session-id" will be the identifier for the session itself.
+* `engine-name.sessionless.*` - metrics related to different `GremlinScriptEngine` instances configured for sessionless
+requests where "engine-name" will be the actual name of the engine, such as "gremlin-groovy".
+
+==== As A Service
+
+Gremlin server can be configured to run as a service.
+
+===== Init.d (SysV)
+
+Link `bin/gremlin-server.sh` to `init.d`
+Be sure to set RUNAS to the service user in `bin/gremlin-server.conf`
+
+[source,bash]
+----
+# Install
+ln -s /path/to/apache-tinkerpop-gremlin-server-x.y.z/bin/gremlin-server.sh /etc/init.d/gremlin-server
+
+# Systems with chkconfig/service. E.g. Fedora, Red Hat
+chkconfig --add gremlin-server
+
+# Start
+service gremlin-server start
+
+# Or call directly
+/etc/init.d/gremlin-server restart
+
+----
+
+===== Systemd
+
+To install, copy the service template below to /etc/systemd/system/gremlin.service
+and update the paths `/path/to/apache-tinkerpop-gremlin-server` with the actual install path of Gremlin Server.
+
+[source,bash]
+----
+[Unit]
+Description=Apache TinkerPop Gremlin Server daemon
+Documentation=https://tinkerpop.apache.org/
+After=network.target
+
+[Service]
+Type=forking
+ExecStart=/path/to/apache-tinkerpop-gremlin-server/bin/gremlin-server.sh start
+ExecStop=/path/to/apache-tinkerpop-gremlin-server/bin/gremlin-server.sh stop
+PIDFile=/path/to/apache-tinkerpop-gremlin-server/run/gremlin.pid
+
+[Install]
+WantedBy=multi-user.target
+----
+
+
+Enable the service with `systemctl enable gremlin-server`
+
+Start the service with `systemctl start gremlin-server`
+
+
 [[security]]
-==== Security
+=== Security
 
 image:gremlin-server-secure.png[width=175,float=right] Gremlin Server provides for several features that aid in the
-security of the graphs that it exposes.  In particular it supports SSL for transport layer security, protective
-measures against malicious script execution, and authentication.  Client SSL options are described in the
+security of the graphs that it exposes.  In particular it supports SSL for transport layer security, authentication,
+authorization and protective measures against malicious script execution.  Client SSL options are described in the
 <<gremlin-drivers-variants, Gremlin Drivers and Variants">> sections with varying capability depending on the driver
 chosen. Script execution options are covered <<script-execution, "at the end of this section">>. This section
 starts with authentication.
@@ -1088,7 +1297,7 @@ authentication, Gremlin Server must be configured with an `Authenticator` implem
 Server comes packaged with two implementations called `SimpleAuthenticator` for plain text authentication using HTTP
 BASIC or PLAIN SASL and `Krb5Authenticator` for Kerberos authentication using GSSAPI SASL.
 
-===== Plain text authentication
+==== Plain text authentication
 
 The `SimpleAuthenticator` implements the "PLAIN" SASL mechanism (i.e. plain text) to authenticate a request.  It also
 supports handling basic authentication requests from http clients. It validates
@@ -1199,7 +1408,7 @@ Once the server has started, issue a request passing the credentials with an `Au
 curl -X POST --insecure -u stephen:password -d "{\"gremlin\":\"100-1\"}" "https://localhost:8182"
 
 [[credentials-dsl]]
-===== Credentials Graph DSL
+==== Credentials Graph DSL
 
 The "credentials graph", which has been mentioned in previous sections, is used by Gremlin Server to hold the list of
 users who can authenticate to the server.  It is possible to use virtually any `Graph` instance for this task as long
@@ -1244,7 +1453,7 @@ TinkerGraph to persist that data or to manually persist it (e.g. write the graph
 complete. Alternatively, use a persistent graph to hold the credentials and configure Gremlin Server accordingly.
 
 [[krb5authenticator]]
-===== Kerberos Authentication
+==== Kerberos Authentication
 
 The `Krb5Authenticator` implements the "GSSAPI" SASL mechanism (i.e. Kerberos) to authenticate a request from a Gremlin
 client.  It can be applied in an existing Kerberos environment and validates whether a
@@ -1296,8 +1505,333 @@ JAAS_OPTION="-Djava.security.auth.login.config=conf/gremlin-jaas.conf"
 KRB5_OPTION="-Djava.security.krb5.conf=/etc/krb5.conf"
 export JAVA_OPTIONS="${JAVA_OPTIONS} ${KRB5_OPTION} ${JAAS_OPTION}"
 
+[[authorization]]
+==== Authorization
+While authentication determines which clients can connect to Gremlin Server, authorization regulates which elements
+of the exposed graphs a specific user is allowed to create, read, update or delete (CRUD). Authorization in Gremlin
+Server can take place at two instances. Before execution a user request can be allowed or denied based on the
+presence of operations such as:
+
+* reading from a GraphTraversalSource
+* writing to a GraphTraversalSource
+* presence of lambdas in bytecode
+* script execution
+* `VertexProgram` execution (OLAP)
+* removal or modification of `TraversalStrategy` instances
+
+During execution the applied traversal strategies influence the results and side-effects of a given query.
+
+===== Mechanisms
+Gremlin Server supports three mechanisms to configure authorization:
+
+. With the `ScriptFileGremlinPlugin` a groovy script is configured that instantiates the `GraphTraversalSources` that
+can be accessed by client requests. Using the `withStrategies()` gremlin
+link:https://tinkerpop.apache.org/docs/x.y.z/reference/#start-steps[start step], one can apply so-called
+link:https://tinkerpop.apache.org/docs/x.y.z/reference/#traversalstrategy[TraversalStrategy instances] to these
+`GraphTraversalSource` instances, some of which can serve for authorization purposes (`ReadOnlyStrategy`,
+`LambdaRestrictionStrategy`, `VertexProgramRestrictionStrategy`, `SubgraphStrategy`, `PartitionStrategy`,
+`EdgeLabelVerificationStrategy`), provided that users are not allowed to remove or modify these `TraversalStrategy`
+instances afterwards. The `ScriptFileGremlinPlugin` is found in the yaml configuration file for Gremlin Server:
++
+[source,yaml]
+----
+scriptEngines: {
+  gremlin-groovy: {
+    plugins: {
+      org.apache.tinkerpop.gremlin.jsr223.ScriptFileGremlinPlugin: {files: [scripts/empty-sample.groovy]}}}}
+----
+. Administrators can configure an authorizer class, an implementation of the `Authorizer` interface. An authorizer receives
+a request before it is executed and it can decide to pass or deny the request, based on the information it has available
+on the requesting user or can seek externally.
+. Apart from passing or denying requests, an `Authorizer` implementation can actively modify the request, in particular
+add the `TraversalStrategy` instances mentioned in item 1.
+
+IMPORTANT: This section is written with gremlin bytecode requests in mind. Realizing authorization for script requests
+is hardly feasible, because such requests get full access to Gremlin Server's execution environment. Although the section
+<<script-execution>> explains how the client access to this environment can be restricted, it is not possible to deny
+execution of `GraphFactory.open()` or `GraphTraversalSource.getGraph()` methods without resorting to TinkerPop
+implementation details (that is, internal API's that can change without notice).
+
+The three mechanisms for authorization each have their merits in terms of simplicity and flexibility. The table below
+gives an overview.
+
+[width="95%",cols="5,2,2,4",options="header"]
+|=========================================================
+|Type (mechanism) |GraphTraversalSources |Groups |Bytecode analysis
+|Implicit (init script) | all accessible |one |`withStrategies()`
+|Passive (pass/deny) | selected access |few |hybrid
+|Active (inject) |selected access |many |hybrid
+|=========================================================
+
+With implicit authorization (only adding restricting `TraversalStrategy` instances in the initialization script of
+Gremlin Server) all authenticated users can access all hosted `GraphTraversalSources` and all face the same
+restrictions. One would need separate Gremlin Server instances for each authorization policy and apply an authenticator
+that restricts access to a group of users (that is, supports in authorization).
+
+The other extreme is the active authorization solution that injects the restricting `Strategies` into the user request,
+following a policy that takes into account both the authenticated user and the original request. While this solution is
+the most flexible and can support an almost unlimited number of authorization policies, it is somewhat complex to
+implement. In particular, applying the `SubgraphStrategy` requires knowledge about the schema of the graph.
+
+The passive authoratization solution perhaps provides a middle ground to start implementing authorization. This
+solution assumes that the `SubgraphStrategy` is applied in the Gremlin Server initialization script, because compliance
+with a subgraph restriction can only be determined during the actual execution of the gremlin traversal. Note that the
+same graph can be reused with different `SubgraphStrategies`. Now, authorization policies can be defined in terms of
+accessible `GraphTraversalSources` and the authorizer can simply match the requested access to a `GraphTraversalSource`
+against the policies applicable to the authenticated user. Like for the active authorization solution, other restrictions
+such as read only access can be either applied at authorization time as policy in the authorizer itself or at request
+execution time as a result of an applied `Strategy` (denoted as 'hybrid' bytecode analysis in the table). A code
+example pursuing the former option is provided in the <<authz-code-example, next section>>.
+
+NOTE: Both the passive and active authorization solutions need to analyze the gremlin bytecode of the original request
+for unwanted removal of restricting Strategies.
+
+NOTE: Gremlin Server is not shipped with `Authorizer` implementations, because these would heavily depend on the external
+systems to integrate with, e.g. link:https://ldap.com/directory-servers/[LDAP systems] or
+link:https://ranger.apache.org/[Apache Ranger ]. However, third-party implementations can be
+offered as <<gremlin-plugins, gremlin plugins>>.
+
+[[authz-code-example]]
+===== Code example
+The two java classes below provide an example implementation of the `Authorizer` interface; they originate from
+link:https://github.com/apache/tinkerpop/tree/x.y.z/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/authz[Gremlin Server's test package].
+If you copy the files into a project, build them into a jar and add the jar to Gremlin Server's CLASSPATH, you can use
+them by adding the following to Gremlin Server's yaml configuration file:
+
+[source, yaml]
+----
+authentication: {
+  authenticator: org.apache.tinkerpop.gremlin.server.auth.SimpleAuthenticator,
+  config: {
+    credentialsDb: conf/tinkergraph-credentials.properties}}
+authorization: {
+  authorizer: org.yourpackage.AllowListAuthorizer,
+  config: {
+    authorizationAllowList: your/path/allow-list.yaml}}
+----
+
+The `AllowListAuthorizer` supports granting groups of users access to statically configured `GraphTraversalSource`
+instances and to the "sandbox", where sandbox means that the group is allowed anything unless restricted by Gremlin
+Server's <<script-execution,sandbox>>. For denying mutating steps and OLAP operations in bytecode requests, the
+`AllowListAuthorizer` relies on the `ReadOnlyStrategy` and `VertexProgramRestrictionStrategy` being present in the
+`GraphTraversalSource`. However, it always denies the use of lambdas in bytecode requests unless the user has the
+"sandbox" grant. It uses the `BytecodeHelper.getLambdaLanguage()` method to detect these.
+
+The grants to groups of users can be configured in a simple yaml file. In addition to the special value "sandbox" for
+a grant for string based requests and lambdas, the special value "anonymous" can be used to denote any user.
+
+[source,java]
+----
+package org.yourpackage;
+
+import org.apache.tinkerpop.gremlin.driver.message.RequestMessage;
+import org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.verification.VertexProgramRestrictionStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.Bytecode;
+import org.apache.tinkerpop.gremlin.process.traversal.TraversalSource;
+import org.apache.tinkerpop.gremlin.process.traversal.strategy.decoration.SubgraphStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.strategy.verification.ReadOnlyStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.util.BytecodeHelper;
+import org.apache.tinkerpop.gremlin.server.Settings.AuthorizationSettings;
+import org.apache.tinkerpop.gremlin.server.auth.AuthenticatedUser;
+
+import java.util.*;
+
+/**
+ * Authorizes a user per request, based on a list that grants access to {@link TraversalSource} instances for
+ * bytecode requests and to gremlin server's sandbox for string requests and lambdas. The {@link
+ * AuthorizationSettings}.config must have an authorizationAllowList entry that contains the name of a YAML file.
+ * This authorizer is for demonstration purposes only. It does not scale well in the number of users regarding
+ * memory usage and administrative burden.
+ */
+public class AllowListAuthorizer implements Authorizer {
+
+    public static final String SANDBOX = "sandbox";
+    public static final String REJECT_BYTECODE = "User not authorized for bytecode requests on %s";
+    public static final String REJECT_LAMBDA = "lambdas";
+    public static final String REJECT_MUTATE = "the ReadOnlyStrategy";
+    public static final String REJECT_OLAP = "the VertexProgramRestrictionStrategy";
+    public static final String REJECT_SUBGRAPH = "the SubgraphStrategy";
+    public static final String REJECT_STRING = "User not authorized for string-based requests.";
+    public static final String KEY_AUTHORIZATION_ALLOWLIST = "authorizationAllowList";
+
+    // Collections derived from the list with allowed users for fast lookups
+    private final Map<String, List<String>> usernamesByTraversalSource = new HashMap<>();
+    private final Set<String> usernamesSandbox = new HashSet<>();
+
+    /**
+     * This method is called once upon system startup to initialize the {@code AllowListAuthorizer}.
+     */
+    @Override
+    public void setup(final Map<String,Object> config) {
+        AllowList allowList;
+        final String file = (String) config.get(KEY_AUTHORIZATION_ALLOWLIST);
+
+        try {
+            allowList = AllowList.read(file);
+        } catch (Exception e) {
+            throw new IllegalArgumentException(String.format("Failed to read list with allowed users from %s", file));
+        }
+        for (Map.Entry<String, List<String>> entry : allowList.grants.entrySet()) {
+            if (!entry.getKey().equals(SANDBOX)) {
+                usernamesByTraversalSource.put(entry.getKey(), new ArrayList<>());
+            }
+            for (final String group : entry.getValue()) {
+                if (allowList.groups.get(group) == null) {
+                    throw new RuntimeException(String.format("Group '%s' not defined in file with allowed users.", group));
+                }
+                if (entry.getKey().equals(SANDBOX)) {
+                    usernamesSandbox.addAll(allowList.groups.get(group));
+                } else {
+                    usernamesByTraversalSource.get(entry.getKey()).addAll(allowList.groups.get(group));
+                }
+            }
+        }
+    }
+
+    /**
+     * Checks whether a user is authorized to have a gremlin bytecode request from a client answered and raises an
+     * {@link AuthorizationException} if this is not the case. For a request to be authorized, the user must either
+     * have a grant for the requested {@link TraversalSource}, without using lambdas, mutating steps or OLAP, or have a
+     * sandbox grant.
+     *
+     * @param user {@link AuthenticatedUser} that needs authorization.
+     * @param bytecode The gremlin {@link Bytecode} request to authorize the user for.
+     * @param aliases A {@link Map} with a single key/value pair that maps the name of the {@link TraversalSource} in the
+     *                {@link Bytecode} request to name of one configured in Gremlin Server.
+     * @return The original or modified {@link Bytecode} to be used for further processing.
+     */
+    @Override
+    public Bytecode authorize(final AuthenticatedUser user, final Bytecode bytecode, final Map<String, String> aliases) throws AuthorizationException {
+        final Set<String> usernames = new HashSet<>();
+
+        for (final String resource: aliases.values()) {
+            usernames.addAll(usernamesByTraversalSource.get(resource));
+        }
+        final boolean userHasTraversalSourceGrant = usernames.contains(user.getName()) || usernames.contains(AuthenticatedUser.ANONYMOUS_USERNAME);
+        final boolean userHasSandboxGrant = usernamesSandbox.contains(user.getName()) || usernamesSandbox.contains(AuthenticatedUser.ANONYMOUS_USERNAME);
+        final boolean runsLambda = BytecodeHelper.getLambdaLanguage(bytecode).isPresent();
+        final boolean touchesReadOnlyStrategy = bytecode.toString().contains(ReadOnlyStrategy.class.getSimpleName());
+        final boolean touchesOLAPRestriction = bytecode.toString().contains(VertexProgramRestrictionStrategy.class.getSimpleName());
+        // This element becomes obsolete after resolving TINKERPOP-2473 for allowing only a single instance of each traversal strategy.
+        final boolean touchesSubgraphStrategy = bytecode.toString().contains(SubgraphStrategy.class.getSimpleName());
+
+        final List<String> rejections = new ArrayList<>();
+        if (runsLambda) {
+            rejections.add(REJECT_LAMBDA);
+        }
+        if (touchesReadOnlyStrategy) {
+            rejections.add(REJECT_MUTATE);
+        }
+        if (touchesOLAPRestriction) {
+            rejections.add(REJECT_OLAP);
+        }
+        if (touchesSubgraphStrategy) {
+            rejections.add(REJECT_SUBGRAPH);
+        }
+        String rejectMessage = REJECT_BYTECODE;
+        if (rejections.size() > 0) {
+            rejectMessage += " using " + String.join(", ", rejections);
+        }
+        rejectMessage += ".";
+
+        if ( (!userHasTraversalSourceGrant || runsLambda || touchesOLAPRestriction || touchesReadOnlyStrategy || touchesSubgraphStrategy) && !userHasSandboxGrant) {
+            throw new AuthorizationException(String.format(rejectMessage, aliases.values()));
+        }
+        return bytecode;
+    }
+
+    /**
+     * Checks whether a user is authorized to have a script request from a gremlin client answered and raises an
+     * {@link AuthorizationException} if this is not the case.
+     *
+     * @param user {@link AuthenticatedUser} that needs authorization.
+     * @param msg {@link RequestMessage} in which the {@link org.apache.tinkerpop.gremlin.driver.Tokens}.ARGS_GREMLIN argument can contain an arbitrary succession of script statements.
+     */
+    public void authorize(final AuthenticatedUser user, final RequestMessage msg) throws AuthorizationException {
+        if (!usernamesSandbox.contains(user.getName())) {
+            throw new AuthorizationException(REJECT_STRING);
+        }
+    }
+}
+----
+
+[source,java]
+----
+package org.yourpackage;
+
+import org.yaml.snakeyaml.TypeDescription;
+import org.yaml.snakeyaml.Yaml;
+import org.yaml.snakeyaml.constructor.Constructor;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+
+/**
+ * AllowList for the AllowListAuthorizer as configured by a YAML file.
+ */
+public class AllowList {
+
+    /**
+     * Holds lists of groups by grant. A grant is either a TraversalSource name or the "sandbox" value. With the
+     * sandbox grant users can access all TraversalSource instances and execute groovy scripts as string based
+     * requests or as lambda functions, only limited by Gremlin Server's sandbox definition.
+     */
+    public Map<String, List<String>> grants;
+
+    /**
+     * Holds lists of user names by groupname. The "anonymous" user name can be used to denote any user.
+     */
+    public Map<String, List<String>> groups;
+
+    /**
+     * Read a configuration from a YAML file into an {@link AllowList} object.
+     *
+     * @param file the location of a AllowList YAML configuration file
+     * @return An {@link Optional} object wrapping the created {@link AllowList}
+     */
+    public static AllowList read(final String file) throws Exception {
+        final InputStream stream = new FileInputStream(new File(file));
+
+        final Constructor constructor = new Constructor(AllowList.class);
+        final TypeDescription allowListDescription = new TypeDescription(AllowList.class);
+        allowListDescription.putMapPropertyType("grants", String.class, Object.class);
+        allowListDescription.putMapPropertyType("groups", String.class, Object.class);
+        constructor.addTypeDescription(allowListDescription);
+
+        final Yaml yaml = new Yaml(constructor);
+        return yaml.loadAs(stream, AllowList.class);
+    }
+}
+----
+
+
+allow-list.yaml:
+[source,yaml]
+----
+grants: {
+gclassic: [groupclassic],
+gmodern: [groupmodern],
+gcrew: [groupclassic, groupmodern],
+ggrateful: [groupgrateful],
+sandbox: [groupsandbox]
+}
+
+groups: {
+groupclassic: [userclassic],
+groupmodern: [usermodern, stephen],
+groupsink: [usersink],
+groupgrateful: [anonymous],
+groupsandbox: [usersandbox, marko]
+}
+----
+
+
 [[script-execution]]
-===== Protecting Script Execution
+==== Protecting Script Execution
 
 It is important to remember that Gremlin Server exposes `GremlinScriptEngine` instances that allows for remote execution
 of arbitrary code on the server.  Obviously, this situation can represent a security risk or, more minimally, provide
@@ -1465,211 +1999,6 @@ A final thought on the topic of `GroovyCompilerGremlinPlugin` implementation is
 can fine tune the Groovy compilation process.  Read more about compilation customization in the
 link:http://docs.groovy-lang.org/latest/html/documentation/#compilation-customizers[Groovy Documentation].
 
-==== Serialization
-
-Gremlin Server can accept requests and return results using different serialization formats. Serializers implement the
-`MessageSerializer` interface. In doing so, they express the list of mime types they expect to support. When
-configuring multiple serializers it is possible for two or more serializers to support the same mime type. Such a
-situation may be common with a generic mime type such as `application/json`. Serializers are added in the order that
-they are encountered in the configuration file and the first one added for a specific mime type will not be overridden
-by other serializers that also support it.
-
-The format of the serialization is configured by the `serializers` setting described in the table above.  Note that
-some serializers have additional configuration options as defined by the `serializers[X].config` setting.  The
-`config` setting is a `Map` where the keys and values get passed to the serializer at its initialization.  The
-available and/or expected keys are dependent on the serializer being used.  Gremlin Server comes packaged with three
-different serializers: GraphSON, Gryo, and GraphBinary (however, GraphSON and GraphBinary are the only two configured
-by default).
-
-===== GraphSON
-
-The GraphSON serializer produces human readable output in JSON format and is a good configuration choice for those
-trying to use TinkerPop from non-JVM languages.  JSON obviously has wide support across virtually all major
-programming languages and can be consumed by a wide variety of tools. The format itself is described in the
-link:https://tinkerpop.apache.org/docs/current/dev/io/#graphson[IO Documentation].
-
-[source,yaml]
-----
-  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphSONMessageSerializerV1d0 }
-  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphSONMessageSerializerV2d0 }
-----
-
-The above configuration represents the default serialization under the `application/json` MIME type and produces JSON
-consistent with standard JSON data types.  It has the following configuration option:
-
-[width="100%",cols="3,10,^2",options="header"]
-|=========================================================
-|Key |Description |Default
-|ioRegistries |A list of `IoRegistry` implementations to be applied to the serializer. |_none_
-|=========================================================
-
-[source,yaml]
-  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphSONMessageSerializerGremlinV1d0 }
-
-When the standard JSON data types are not enough (e.g. need to identify the difference between `double` and `float`
-data types), the above configuration will embed types into the JSON itself.  The type embedding uses standard Java
-type names, so interpretation from non-JVM languages will be required.  It has the MIME type of
-`application/vnd.gremlin-v1.0+json` and the following configuration options:
-
-[width="100%",cols="3,10,^2",options="header"]
-|=========================================================
-|Key |Description |Default
-|ioRegistries |A list of `IoRegistry` implementations to be applied to the serializer. |_none_
-|=========================================================
-
-===== Gryo
-
-WARNING: Gryo is no longer the recommended serialization format for Gremlin Server. Consider using
-<<server-graphbinary, GraphBinary>> instead.
-
-The Gryo serializer utilizes Kryo-based serialization which produces a binary output.  This format is best consumed
-by JVM-based languages. The format itself is described in the
-link:https://tinkerpop.apache.org/docs/current/dev/io/#gryo[IO Documentation].
-
-[source,yaml]
-  - { className: org.apache.tinkerpop.gremlin.driver.ser.GryoMessageSerializerGremlinV3d0 }
-
-It has the MIME type of `application/vnd.gremlin-v3.0+gryo` and the following configuration options:
-
-[width="100%",cols="3,10,^2",options="header"]
-|=========================================================
-|Key |Description |Default
-|bufferSize |The maximum size of the Kryo buffer for use on a single object being serialized.  Increasing this value will correct `KryoException` errors that complain of "Buffer too small". |_4096_
-|classResolverSupplier |The fully qualified classname of a custom `Supplier<ClassResolver>` which will be used when constructing `Kryo` instances. There is no direct default for this setting, but without a setting the `GryoClassResolver` is used. |_none_
-|custom |A list of classes with custom kryo `Serializer` implementations related to them in the form of `<class>;<serializer-class>`. |_none_
-|ioRegistries |A list of `IoRegistry` implementations to be applied to the serializer. |_none_
-|serializeResultToString |When set to `true`, results are serialized by first calling `toString()` on each object in the result list resulting in an extended MIME Type of `application/vnd.gremlin-v1.0+gryo-stringd`.  When set to `false` Kryo-based serialization is applied. |_false_
-|=========================================================
-
-As described above, there are multiple ways in which to register serializers for Kryo-based serialization.  Note
-that the `ioRegistries` setting is applied first, followed by the `custom` setting.
-
-Those configuring or implementing a `Supplier<ClassResolver>` should consider this an "advanced" option and typically
-important to use cases where server types need to be coerced to client types (i.e. a type is available on the server
-but not on the client).  Implementations should typically instantiate `ClassResolver` implementations that are
-extensions of the `GryoClassResolver` as this class is important to most serialization tasks in TinkerPop.
-
-[[server-graphbinary]]
-===== GraphBinary
-
-GraphBinary is a binary serialization format suitable for object trees, designed to reduce serialization overhead on
-both the client and the server, as well as limiting the size of the payload that is transmitted over the wire. The
-format itself is described in the link:https://tinkerpop.apache.org/docs/current/dev/io/#graphbinary[IO Documentation].
-
-IMPORTANT: GraphBinary is currently only supported on the JVM.
-
-[source,yaml]
-  - { className: org.apache.tinkerpop.gremlin.driver.ser.GraphBinaryMessageSerializerV1 }
-
-It has the MIME type of `application/vnd.graphbinary-v1.0` and the following configuration options:
-
-[width="100%",cols="3,10,^2",options="header"]
-|=========================================================
-|Key |Description |Default
-|custom |A list of classes with custom kryo `Serializer` implementations related to them in the form of `<class>;<serializer-class>`. |_none_
-|ioRegistries |A list of `IoRegistry` implementations to be applied to the serializer. |_none_
-|builder |Name of the `TypeSerializerRegistry.Builder` instance to be used to construct the `TypeSerializerRegistry`. |_none_
-|=========================================================
-
-As described above, there are multiple ways in which to register serializers for GraphBinary-based serialization. Note
-that the `ioRegistries` setting is applied first, followed by the `custom` setting.
-
-[[metrics]]
-==== Metrics
-
-Gremlin Server produces metrics about its operations that can yield some insight into how it is performing. These
-metrics are exposed in a variety of ways:
-
-* Directly to the console where Gremlin Server is running
-* CSV file
-* link:http://ganglia.info/[Ganglia]
-* link:http://graphite.wikidot.com/[Graphite]
-* link:http://www.slf4j.org/[SLF4j]
-* link:https://en.wikipedia.org/wiki/Java_Management_Extensions[JMX]
-
-The configuration of each of these outputs is described in the Gremlin Server <<_configuring_2, Configuring>> section.
-Note that Graphite and Ganglia are not included as part of the Gremlin Server distribution and must be installed
-to the server manually.
-
-[source,text]
-----
-bin/gremlin-server.sh install com.codahale.metrics metrics-ganglia 3.0.2
-bin/gremlin-server.sh install com.codahale.metrics metrics-graphite 3.0.2
-----
-
-WARNING: Gremlin Server is built to work with Metrics 3.0.2. Usage of other versions may lead to unexpected problems.
-
-NOTE: Installing Ganglia will include `org.acplt:oncrpc`, which is an LGPL licensed dependency.
-
-Regardless of the output, the metrics gathered are the same. Each metric is prefixed with
-`org.apache.tinkerpop.gremlin.server.GremlinServer` and the following metrics are reported:
-
-* `sessions` - the number of sessions open at the time the metric was last measured.
-* `errors` - the number of total errors, mean rate, as well as the 1, 5, and 15-minute error rates.
-* `op.eval` - the number of script evaluations, mean rate, 1, 5, and 15 minute rates, minimum, maximum, median, mean,
-and standard deviation evaluation times, as well as the 75th, 95th, 98th, 99th and 99.9th percentile evaluation times
-(note that these time apply to both sessionless and in-session requests).
-* `op.traversal` - the number of `Traversal` executions, mean rate, 1, 5, and 15 minute rates, minimum, maximum, median,
-mean, and standard deviation evaluation times, as well as the 75th, 95th, 98th, 99th and 99.9th percentile evaluation
-times.
-* `engine-name.session.session-id.*` - metrics related to different `GremlinScriptEngine` instances configured for
-session-based requests where "engine-name" will be the actual name of the engine, such as "gremlin-groovy" and
-"session-id" will be the identifier for the session itself.
-* `engine-name.sessionless.*` - metrics related to different `GremlinScriptEngine` instances configured for sessionless
-requests where "engine-name" will be the actual name of the engine, such as "gremlin-groovy".
-
-==== As A Service
-
-Gremlin server can be configured to run as a service.
-
-===== Init.d (SysV)
-
-Link `bin/gremlin-server.sh` to `init.d`
-Be sure to set RUNAS to the service user in `bin/gremlin-server.conf`
-
-[source,bash]
-----
-# Install
-ln -s /path/to/apache-tinkerpop-gremlin-server-x.y.z/bin/gremlin-server.sh /etc/init.d/gremlin-server
-
-# Systems with chkconfig/service. E.g. Fedora, Red Hat
-chkconfig --add gremlin-server
-
-# Start
-service gremlin-server start
-
-# Or call directly
-/etc/init.d/gremlin-server restart
-
-----
-
-===== Systemd
-
-To install, copy the service template below to /etc/systemd/system/gremlin.service
-and update the paths `/path/to/apache-tinkerpop-gremlin-server` with the actual install path of Gremlin Server.
-
-[source,bash]
-----
-[Unit]
-Description=Apache TinkerPop Gremlin Server daemon
-Documentation=https://tinkerpop.apache.org/
-After=network.target
-
-[Service]
-Type=forking
-ExecStart=/path/to/apache-tinkerpop-gremlin-server/bin/gremlin-server.sh start
-ExecStop=/path/to/apache-tinkerpop-gremlin-server/bin/gremlin-server.sh stop
-PIDFile=/path/to/apache-tinkerpop-gremlin-server/run/gremlin.pid
-
-[Install]
-WantedBy=multi-user.target
-----
-
-
-Enable the service with `systemctl enable gremlin-server`
-
-Start the service with `systemctl start gremlin-server`
-
 
 === Best Practices
 
diff --git a/docs/src/reference/the-traversal.asciidoc b/docs/src/reference/the-traversal.asciidoc
index 06247c66edf..06ff0af221d 100644
--- a/docs/src/reference/the-traversal.asciidoc
+++ b/docs/src/reference/the-traversal.asciidoc
@@ -3797,6 +3797,33 @@ of the Gremlin traversal machine's compiler. There are 5 categories of strategie
 
 NOTE: The <<explain-step,`explain()`>>-step shows the user how each registered strategy mutates the traversal.
 
+TinkerPop ships with a generous number of `TraversalStrategy` definitions, most of which are applied implicitly when
+executing a gremlin traversal. Users and providers can add `TraversalStrategy` definitions for particular needs. The
+following sections detail how traversal strategies are applied and defined and describe a collection of traversal
+strategies that are generally useful to end-users.
+
+=== Application
+One can explicitly add or remove `TraversalStrategy` strategies on the `GraphTraversalSource` with the `withStrategies()`
+and `withoutStrategies()` <<start-steps, start steps>>, see the <<readonlystrategy, ReadOnlyStrategy>> and the
+<<barrier-step, barrier() step>> for examples. End users typically do this as part of issuing a gremlin traversal, either
+on a locally opened graph or a remotely accessed graph. However, when configuring Gremlin Server, traversal strategies
+can also be applied on exposed `GraphTraversalSource` instances and as part of an `Authorizer` implementation, see
+link:https://tinkerpop.apache.org/docs/x.y.z/reference/#authorization[Gremlin Server Authorization].
+Therefore, one should keep the following in mind when modifiying the list of `TraversalStrategy` strategies:
+
+* A `TraversalStrategy` added to the traversal can be removed again later on. An example is the
+`conf/gremlin-server-modern-readonly.yaml` file from the Gremlin Server distribution, which applies the `ReadOnlyStrategy`
+to the `GraphTraversalSource` that remote clients can connect to. However, a remote client can remove it on its turn
+by applying the `withoutStrategies()` step with the `ReadOnlyStrategy`.
+
+* The traversal strategies assume that they are only applied once: no exception is raised or warning is logged when you
+try it nevertheless. As a result, the behavior in case of multiple application of the same traversal strategy is
+unspecified. For some, like the <<partitionstrategy, PartitionStrategy>> the first instance prevails. For others, like
+the <<subgraphstrategy, SubgraphStrategy>>, the last instance prevails. The `OptionStrategy`, which is applied
+implicitly as a result of a `with()` step, is an exception in that it actually merges the parameters of multiple
+`with()` steps.
+
+=== Definition
 A simple `OptimizationStrategy` is the `IdentityRemovalStrategy`.
 
 [source,java]
@@ -3938,9 +3965,6 @@ g.V().hasLabel('person'). <1>
 <8> `PathRetractionStrategy` will remove paths from the traversers and increase the likelihood of bulking as path data is not required after `select('b')`.
 <9> `AdjacentToIncidentStrategy` will turn `out()` into `outE()` to increase data access locality.
 
-A collection of useful `DecorationStrategy` strategies are provided with TinkerPop and are generally useful to
-end-users.  The following sub-sections detail these strategies:
-
 === ElementIdStrategy
 
 `ElementIdStrategy` provides control over element identifiers. Some Graph implementations, such as TinkerGraph,
@@ -4029,6 +4053,7 @@ new transaction immediately following the `commit()` that raises the events. The
 may also not behave as "snapshots" at the time of their creation as they are "live" references to actual database
 elements.
 
+[[partitionstrategy]]
 === PartitionStrategy
 
 image::partition-graph.png[width=325]
@@ -4123,6 +4148,7 @@ guarantee iteration order, then it is possible that the final result of the trav
 non-deterministic. In these cases, it would be necessary to enforce a deterministic iteration with `order()` prior to
 these steps that make use of randomness to return results.
 
+[[subraphstrategy]]
 === SubgraphStrategy
 
 `SubgraphStrategy` is similar to `PartitionStrategy` in that it constrains a `Traversal` to certain vertices, edges,
@@ -4167,6 +4193,24 @@ g.V().outE().inV().
     by('name')
 ----
 
+=== VertexProgramDenyStrategy
+
+Like the `ReadOnlyStrategy`, the `VertexProgramDenyStrategy` denies the execution of specific traversals. A `Traversal`
+that has the `VertexProgramDenyStrategy` applied will throw an `IllegalStateException` if it uses the
+`withComputer()` step. This `TraversalStrategy` can be useful for configuring `GraphTraversalSource` instances in
+Gremlin Server with the `ScriptFileGremlinPlugin`.
+
+[source,text]
+----
+gremlin> oltpOnly = g.withStrategies(VertexProgramDenyStrategy.instance())
+==>graphtraversalsource[tinkergraph[vertices:5 edges:7], standard]
+gremlin> oltpOnly.withComputer().V().elementMap()
+The TraversalSource does not allow the use of a GraphComputer
+Type ':help' or ':h' for help.
+Display stack trace? [yN]
+----
+
+
 [[dsl]]
 == Domain Specific Languages
 
diff --git a/docs/src/upgrade/release-3.5.x.asciidoc b/docs/src/upgrade/release-3.5.x.asciidoc
index a9fac18fc3d..68e1ef416b0 100644
--- a/docs/src/upgrade/release-3.5.x.asciidoc
+++ b/docs/src/upgrade/release-3.5.x.asciidoc
@@ -343,6 +343,11 @@ return these types of results and not have to work around them:
 
 See: link:https://issues.apache.org/jira/browse/TINKERPOP-2395[TINKERPOP-2395]
 
+==== Gremlin Server
+The `authentication.enableAuditlog` configuration property is deprecated, but replaced by the `enableAuditLog` property
+to also make it available to `Authorizer` implementations. With the new setting enabled, there are slight changes in the
+formatting of audit log messages. In particular, the name of the authenticated user is included in every message.
+
 ==== Python 2.x Support
 
 The gremlinpython module no longer supports Python 2.x. Users must use Python 3 going forward. For the most part, from
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/jsr223/CoreImports.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/jsr223/CoreImports.java
index 9adf03b4392..34c37d18b94 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/jsr223/CoreImports.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/jsr223/CoreImports.java
@@ -24,14 +24,11 @@
 import org.apache.commons.configuration2.CompositeConfiguration;
 import org.apache.commons.configuration2.Configuration;
 import org.apache.commons.configuration2.ConfigurationUtils;
-import org.apache.commons.configuration2.FileBasedConfiguration;
 import org.apache.commons.configuration2.HierarchicalConfiguration;
 import org.apache.commons.configuration2.MapConfiguration;
 import org.apache.commons.configuration2.PropertiesConfiguration;
 import org.apache.commons.configuration2.SubsetConfiguration;
 import org.apache.commons.configuration2.XMLConfiguration;
-import org.apache.commons.configuration2.builder.BasicConfigurationBuilder;
-import org.apache.commons.configuration2.builder.FileBasedConfigurationBuilder;
 import org.apache.commons.configuration2.builder.fluent.Configurations;
 import org.apache.tinkerpop.gremlin.process.computer.Computer;
 import org.apache.tinkerpop.gremlin.process.computer.ComputerResult;
@@ -54,6 +51,7 @@
 import org.apache.tinkerpop.gremlin.process.computer.traversal.step.map.ShortestPath;
 import org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.decoration.VertexProgramStrategy;
 import org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.optimization.GraphFilterStrategy;
+import org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.verification.VertexProgramRestrictionStrategy;
 import org.apache.tinkerpop.gremlin.process.remote.RemoteConnection;
 import org.apache.tinkerpop.gremlin.process.traversal.Bindings;
 import org.apache.tinkerpop.gremlin.process.traversal.IO;
@@ -255,6 +253,7 @@ public final class CoreImports {
         CLASS_IMPORTS.add(ReferenceElementStrategy.class);
         CLASS_IMPORTS.add(StandardVerificationStrategy.class);
         CLASS_IMPORTS.add(EdgeLabelVerificationStrategy.class);
+        CLASS_IMPORTS.add(VertexProgramRestrictionStrategy.class);
         // graph traversal
         CLASS_IMPORTS.add(AnonymousTraversalSource.class);
         CLASS_IMPORTS.add(__.class);
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/computer/traversal/strategy/verification/VertexProgramRestrictionStrategy.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/computer/traversal/strategy/verification/VertexProgramRestrictionStrategy.java
new file mode 100644
index 00000000000..5c9d4b2f3e9
--- /dev/null
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/computer/traversal/strategy/verification/VertexProgramRestrictionStrategy.java
@@ -0,0 +1,58 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.verification;
+
+import org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.decoration.VertexProgramStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
+import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.strategy.AbstractTraversalStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.strategy.verification.ComputerVerificationStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.strategy.verification.VerificationException;
+
+import java.util.Collections;
+import java.util.Set;
+
+/**
+ * Detects the presence of a {@link VertexProgramStrategy} and throws an {@link IllegalStateException} if it is found.
+ *
+ * @author Marc de Lignie
+ */
+public final class VertexProgramRestrictionStrategy extends AbstractTraversalStrategy<TraversalStrategy.VerificationStrategy> implements TraversalStrategy.VerificationStrategy {
+
+    private static final VertexProgramRestrictionStrategy INSTANCE = new VertexProgramRestrictionStrategy();
+
+    private VertexProgramRestrictionStrategy() {
+    }
+
+    @Override
+    public void apply(final Traversal.Admin<?, ?> traversal) {
+        if (traversal.getStrategies().toList().contains(VertexProgramStrategy.instance())) {
+            throw new VerificationException("The TraversalSource does not allow the use of a GraphComputer", traversal);
+        }
+    }
+
+    @Override
+    public Set<Class<? extends VerificationStrategy>> applyPost() {
+        return Collections.singleton(ComputerVerificationStrategy.class);
+    }
+
+    public static VertexProgramRestrictionStrategy instance() {
+        return INSTANCE;
+    }
+}
diff --git a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/BytecodeHelper.java b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/BytecodeHelper.java
index d02c152583d..77df45be04f 100644
--- a/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/BytecodeHelper.java
+++ b/gremlin-core/src/main/java/org/apache/tinkerpop/gremlin/process/traversal/util/BytecodeHelper.java
@@ -45,7 +45,7 @@ private BytecodeHelper() {
     }
 
     /**
-     * Parses {@link Bytecode} to find {@link TraversalStrategy} objects in the source instructions.
+     * Parses {@link Bytecode} to find {@link TraversalStrategy} objects added in the source instructions.
      */
     public static <A extends TraversalStrategy> Iterator<A> findStrategies(final Bytecode bytecode, final Class<A> clazz) {
         return IteratorUtils.map(
diff --git a/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/computer/traversal/strategy/verifcation/VertexProgramRestrictionStrategyTest.java b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/computer/traversal/strategy/verifcation/VertexProgramRestrictionStrategyTest.java
new file mode 100644
index 00000000000..b8a31d15ca2
--- /dev/null
+++ b/gremlin-core/src/test/java/org/apache/tinkerpop/gremlin/process/computer/traversal/strategy/verifcation/VertexProgramRestrictionStrategyTest.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.verifcation;
+
+import org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.verification.VertexProgramRestrictionStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.Traversal;
+import org.apache.tinkerpop.gremlin.structure.util.empty.EmptyGraph;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.junit.runners.Parameterized;
+
+import java.util.Arrays;
+
+import static org.junit.Assert.fail;
+
+/**
+ * @author Marc de Lignie
+ */
+@RunWith(Parameterized.class)
+public class VertexProgramRestrictionStrategyTest {
+
+    @Parameterized.Parameters(name = "{0}")
+    public static Iterable<Object[]> data() {
+        return Arrays.asList(new Object[][]{
+                // illegal
+                {"withComputer().withStrategies(VertexProgramRestrictionStrategy.instance()).V()",
+                        EmptyGraph.instance().traversal().withComputer().withStrategies(VertexProgramRestrictionStrategy.instance()).V(), false},
+                {"withStrategies(VertexProgramRestrictionStrategy.instance()).withComputer().V()",
+                        EmptyGraph.instance().traversal().withStrategies(VertexProgramRestrictionStrategy.instance()).withComputer().V(), false},
+                {"withStrategies(VertexProgramRestrictionStrategy.instance()).withComputer().V().connectedComponent()",
+                        EmptyGraph.instance().traversal().withStrategies(VertexProgramRestrictionStrategy.instance()).withComputer().V().connectedComponent(), false},
+                {"withStrategies(VertexProgramRestrictionStrategy.instance()).withComputer().V().pageRank()",
+                        EmptyGraph.instance().traversal().withStrategies(VertexProgramRestrictionStrategy.instance()).withComputer().V().pageRank(), false},
+                // legal
+                {"withStrategies(VertexProgramRestrictionStrategy.instance()).V()", EmptyGraph.instance().traversal().withStrategies(VertexProgramRestrictionStrategy.instance()).V(), true},
+        });
+    }
+
+    @Parameterized.Parameter(value = 0)
+    public String name;
+
+    @Parameterized.Parameter(value = 1)
+    public Traversal<?, ?> traversal;
+
+    @Parameterized.Parameter(value = 2)
+    public boolean legal;
+
+    @Test
+    public void shouldBeVerifiedIllegal() {
+        try {
+            this.traversal.asAdmin().applyStrategies();
+            if (!this.legal)
+                fail("The traversal should not be allowed: " + this.traversal);
+        } catch (final IllegalStateException ise) {
+            if (this.legal)
+                fail("The traversal should be allowed: " + this.traversal);
+        }
+    }
+}
diff --git a/gremlin-server/data/README.asciidoc b/gremlin-server/data/README.asciidoc
index b3586b9d8a2..d2787f88a16 100644
--- a/gremlin-server/data/README.asciidoc
+++ b/gremlin-server/data/README.asciidoc
@@ -17,9 +17,9 @@ limitations under the License.
 This directory contains data files that are packaged with Gremlin Server:
 
 * `credentials.kryo` - This data file contains a sample graph built from the
-link:https://tinkerpop.apache.org/docs/current/reference/#credentials-dsl[Credentials DSL] which contains a single
-user: `stephen/password`. This file is meant to be used by the `gremlin-server-secure.yaml` and
-`gremlin-server-rest-secure.yaml` configuration files to demonstrate basic authentication functions.
+link:https://tinkerpop.apache.org/docs/current/reference/#credentials-dsl[Credentials DSL] which contains two
+users: `stephen/password` and `marko/rainbow-dash`. This file is meant to be used by the `gremlin-server-secure.yaml`
+and `gremlin-server-rest-secure.yaml` configuration files to demonstrate basic authentication functions.
 * `sample.kryo` - This data file contains a random sample graph generated from the `DistributionGenerator` in
 `IoDataGenerateTest.shouldWriteSampleForGremlinServer()`. It can be configured for use in Gremlin Server by using the
 `load-sample.groovy` server initialization script file packaged with Gremlin Server. This graph has 10,000 vertices
diff --git a/gremlin-server/data/credentials.kryo b/gremlin-server/data/credentials.kryo
index 163d2ef49d7..2a2d6ae6bab 100644
Binary files a/gremlin-server/data/credentials.kryo and b/gremlin-server/data/credentials.kryo differ
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/AbstractChannelizer.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/AbstractChannelizer.java
index a9f4cc1d69f..fe3c9e81d94 100644
--- a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/AbstractChannelizer.java
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/AbstractChannelizer.java
@@ -30,14 +30,15 @@
 import org.apache.tinkerpop.gremlin.driver.ser.GraphSONMessageSerializerV2d0;
 import org.apache.tinkerpop.gremlin.groovy.engine.GremlinExecutor;
 import org.apache.tinkerpop.gremlin.server.auth.Authenticator;
+import org.apache.tinkerpop.gremlin.server.authz.Authorizer;
 import org.apache.tinkerpop.gremlin.server.handler.AbstractAuthenticationHandler;
 import org.apache.tinkerpop.gremlin.server.handler.OpExecutorHandler;
 import org.apache.tinkerpop.gremlin.server.handler.OpSelectorHandler;
+import org.apache.tinkerpop.gremlin.server.util.ServerGremlinExecutor;
 import org.apache.tinkerpop.gremlin.structure.Graph;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelPipeline;
 import io.netty.channel.socket.SocketChannel;
-import org.apache.tinkerpop.gremlin.server.util.ServerGremlinExecutor;
 import org.javatuples.Pair;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -94,6 +95,7 @@ public abstract class AbstractChannelizer extends ChannelInitializer<SocketChann
 
 
     public static final String PIPELINE_AUTHENTICATOR = "authenticator";
+    public static final String PIPELINE_AUTHORIZER = "authorizer";
     public static final String PIPELINE_REQUEST_HANDLER = "request-handler";
     public static final String PIPELINE_HTTP_RESPONSE_ENCODER = "http-response-encoder";
     public static final String PIPELINE_WEBSOCKET_SERVER_COMPRESSION = "web-socket-server-compression-handler";
@@ -111,6 +113,7 @@ public abstract class AbstractChannelizer extends ChannelInitializer<SocketChann
     private OpExecutorHandler opExecutorHandler;
 
     protected Authenticator authenticator;
+    protected Authorizer authorizer;
 
     /**
      * This method is called from within {@link #initChannel(SocketChannel)} just after the SSL handler is put in the pipeline.
@@ -144,6 +147,7 @@ public void init(final ServerGremlinExecutor serverGremlinExecutor) {
         if (sslContext.isPresent()) logger.info("SSL enabled");
 
         authenticator = createAuthenticator(settings.authentication);
+        authorizer = createAuthorizer(settings.authorization);
 
         // these handlers don't share any state and can thus be initialized once per pipeline
         opSelectorHandler = new OpSelectorHandler(settings, graphManager, gremlinExecutor, scheduledExecutorService, this);
@@ -175,16 +179,16 @@ public void initChannel(final SocketChannel ch) throws Exception {
         finalize(pipeline);
     }
 
-    protected AbstractAuthenticationHandler createAuthenticationHandler(final Settings.AuthenticationSettings config) {
+    protected AbstractAuthenticationHandler createAuthenticationHandler(final Settings settings) {
         try {
-            final Class<?> clazz = Class.forName(config.authenticationHandler);
+            final Class<?> clazz = Class.forName(settings.authentication.authenticationHandler);
             final Class[] constructorArgs = new Class[2];
             constructorArgs[0] = Authenticator.class;
-            constructorArgs[1] = Settings.AuthenticationSettings.class;
-            return (AbstractAuthenticationHandler) clazz.getDeclaredConstructor(constructorArgs).newInstance(authenticator, config);
+            constructorArgs[1] = Settings.class;
+            return (AbstractAuthenticationHandler) clazz.getDeclaredConstructor(constructorArgs).newInstance(authenticator, settings);
         } catch (Exception ex) {
             logger.warn(ex.getMessage());
-            throw new IllegalStateException(String.format("Could not create/configure AuthenticationHandler %s", config.authenticationHandler), ex);
+            throw new IllegalStateException(String.format("Could not create/configure AuthenticationHandler %s", settings.authentication.authenticationHandler), ex);
         }
     }
 
@@ -201,6 +205,22 @@ private Authenticator createAuthenticator(final Settings.AuthenticationSettings
         }
     }
 
+    private Authorizer createAuthorizer(final Settings.AuthorizationSettings config) {
+        final String authorizerClass = config.authorizer;
+        if (null == authorizerClass) {
+            return null;
+        }
+        try {
+            final Class<?> clazz = Class.forName(authorizerClass);
+            final Authorizer authorizer = (Authorizer) clazz.newInstance();
+            authorizer.setup(config.config);
+            return authorizer;
+        } catch (Exception ex) {
+            logger.warn(ex.getMessage());
+            throw new IllegalStateException(String.format("Could not create/configure Authorizer %s", authorizer), ex);
+        }
+    }
+
     private void configureSerializers() {
         // grab some sensible defaults if no serializers are present in the config
         final List<Settings.SerializerSettings> serializerSettings =
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/Settings.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/Settings.java
index ae35d0f04df..f58c1407cc4 100644
--- a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/Settings.java
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/Settings.java
@@ -27,11 +27,14 @@
 import org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;
 import org.apache.tinkerpop.gremlin.server.auth.AllowAllAuthenticator;
 import org.apache.tinkerpop.gremlin.server.auth.Authenticator;
+import org.apache.tinkerpop.gremlin.server.authz.Authorizer;
 import org.apache.tinkerpop.gremlin.server.channel.WebSocketChannelizer;
 import org.apache.tinkerpop.gremlin.server.handler.AbstractAuthenticationHandler;
 import org.apache.tinkerpop.gremlin.server.util.DefaultGraphManager;
 import org.apache.tinkerpop.gremlin.server.util.LifeCycleHook;
 import org.apache.tinkerpop.gremlin.structure.Graph;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 import org.yaml.snakeyaml.TypeDescription;
 import org.yaml.snakeyaml.Yaml;
 import org.yaml.snakeyaml.constructor.Constructor;
@@ -59,6 +62,8 @@
  */
 public class Settings {
 
+    private static final Logger logger = LoggerFactory.getLogger(Settings.class);
+
     public Settings() {
         // setup some sensible defaults like gremlin-groovy
         scriptEngines = new HashMap<>();
@@ -220,6 +225,13 @@ public Settings() {
 
     public AuthenticationSettings authentication = new AuthenticationSettings();
 
+    public AuthorizationSettings authorization = new AuthorizationSettings();
+
+    /**
+     * Enable audit logging of authenticated users and gremlin evaluation requests.
+     */
+    public Boolean enableAuditLog = false;
+
     /**
      * Custom settings for {@link OpProcessor} implementations. Implementations are loaded via
      * {@link ServiceLoader} but custom configurations can be supplied through this configuration.
@@ -317,7 +329,15 @@ public static Settings read(final InputStream stream) {
         constructor.addTypeDescription(graphiteReporterDescription);
 
         final Yaml yaml = new Yaml(constructor);
-        return yaml.loadAs(stream, Settings.class);
+        final Settings settings = yaml.loadAs(stream, Settings.class);
+        if (settings.authentication.enableAuditLog && settings.enableAuditLog) {
+            logger.warn("Both authentication.enableAuditLog and settings.enableAuditLog " +
+                        "are enabled, so auditable events are logged twice.");
+        }
+        if (settings.authentication.enableAuditLog && !settings.enableAuditLog) {
+            logger.warn("Configuration property 'authentication.enableAuditLog' is deprecated, use 'enableAuditLog' instead.");
+        }
+        return settings;
     }
 
     /**
@@ -418,7 +438,10 @@ public static class AuthenticationSettings {
 
         /**
          * Enable audit logging of authenticated users and gremlin evaluation requests.
+         * @deprecated As of release 3.5.0, replaced by {@link Settings#enableAuditLog} with slight changes in the
+         * log message format.
          */
+        @Deprecated
         public boolean enableAuditLog = false;
 
         /**
@@ -428,6 +451,23 @@ public static class AuthenticationSettings {
         public Map<String, Object> config = null;
     }
 
+    /**
+     * Settings for the {@link Authenticator} implementation.
+     */
+    public static class AuthorizationSettings {
+        /**
+         * The fully qualified class name of the {@link Authorizer} implementation. This class name will be
+         * used to load the implementation from the classpath. Defaults to null when not specified.
+         */
+        public String authorizer = null;
+
+        /**
+         * A {@link Map} containing {@link Authorizer} specific configurations. Consult the
+         * {@link Authorizer} implementation for specifics on what configurations are expected.
+         */
+        public Map<String, Object> config = null;
+    }
+
     /**
      * Settings to configure SSL support.
      */
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/authz/AuthorizationException.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/authz/AuthorizationException.java
new file mode 100644
index 00000000000..1103027d308
--- /dev/null
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/authz/AuthorizationException.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.server.authz;
+
+/**
+ * An exception that occurs during authorization, i.e. when a requested resource needed for a response to an
+ * evaluation request is not allowed for this user.
+ *
+ * @author Marc de Lignie
+ */
+public class AuthorizationException extends Exception {
+    public AuthorizationException() {
+    }
+
+    public AuthorizationException(final String message) {
+        super(message);
+    }
+
+    public AuthorizationException(final String message, final Throwable cause) {
+        super(message, cause);
+    }
+
+    public AuthorizationException(final Throwable cause) {
+        super(cause);
+    }
+
+    public AuthorizationException(final String message, final Throwable cause, final boolean enableSuppression,
+                                  final boolean writableStackTrace) {
+        super(message, cause, enableSuppression, writableStackTrace);
+    }
+}
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/authz/Authorizer.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/authz/Authorizer.java
new file mode 100644
index 00000000000..c32b78a707d
--- /dev/null
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/authz/Authorizer.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.server.authz;
+
+import org.apache.tinkerpop.gremlin.driver.message.RequestMessage;
+import org.apache.tinkerpop.gremlin.process.traversal.Bytecode;
+import org.apache.tinkerpop.gremlin.process.traversal.TraversalSource;
+import org.apache.tinkerpop.gremlin.server.auth.AuthenticatedUser;
+
+import java.util.Map;
+
+
+/**
+ * Provides the interface for authorizing a user per request.
+ *
+ * @author Marc de Lignie
+ */
+public interface Authorizer {
+    /**
+     * This method is called once upon system startup to initialize the {@code Authorizer}.
+     */
+    public void setup(final Map<String,Object> config) throws AuthorizationException;
+
+    /**
+     * Checks whether a user is authorized to have a gremlin bytecode request from a client answered and raises an
+     * {@link AuthorizationException} if this is not the case. The returned bytecde is used for further processing of
+     * the request.
+     *
+     * @param user {@link AuthenticatedUser} that needs authorization.
+     * @param bytecode The gremlin {@link Bytecode} request to authorize the user for.
+     * @param aliases A {@link Map} with a single key/value pair that maps the name of the {@link TraversalSource} in the
+     *                {@link Bytecode} request to name of one configured in Gremlin Server.
+     * @return The original or modified {@link Bytecode} to be used for further processing.
+     */
+    public Bytecode authorize(final AuthenticatedUser user, final Bytecode bytecode, final Map<String, String> aliases) throws AuthorizationException;
+
+    /**
+     * Checks whether a user is authorized to have a script request from a gremlin client answered and raises an
+     * {@link AuthorizationException} if this is not the case.
+     *
+     * @param user {@link AuthenticatedUser} that needs authorization.
+     * @param msg {@link RequestMessage} in which the {@link org.apache.tinkerpop.gremlin.driver.Tokens}.ARGS_GREMLIN argument can contain an arbitrary succession of script statements.
+     */
+    public void authorize(final AuthenticatedUser user, final RequestMessage msg) throws AuthorizationException;
+
+}
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/channel/HttpChannelizer.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/channel/HttpChannelizer.java
index d65fdf21400..7b3ad995663 100644
--- a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/channel/HttpChannelizer.java
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/channel/HttpChannelizer.java
@@ -18,12 +18,14 @@
  */
 package org.apache.tinkerpop.gremlin.server.channel;
 
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import org.apache.tinkerpop.gremlin.server.AbstractChannelizer;
 import org.apache.tinkerpop.gremlin.server.Channelizer;
 import org.apache.tinkerpop.gremlin.server.Settings;
 import org.apache.tinkerpop.gremlin.server.auth.AllowAllAuthenticator;
 import org.apache.tinkerpop.gremlin.server.handler.AbstractAuthenticationHandler;
 import org.apache.tinkerpop.gremlin.server.handler.HttpBasicAuthenticationHandler;
+import org.apache.tinkerpop.gremlin.server.handler.HttpBasicAuthorizationHandler;
 import org.apache.tinkerpop.gremlin.server.handler.HttpGremlinEndpointHandler;
 import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.http.HttpObjectAggregator;
@@ -43,7 +45,6 @@ public class HttpChannelizer extends AbstractChannelizer {
     private static final Logger logger = LoggerFactory.getLogger(HttpChannelizer.class);
 
     private HttpGremlinEndpointHandler httpGremlinEndpointHandler;
-    private AbstractAuthenticationHandler authenticationHandler;
 
     @Override
     public void init(final ServerGremlinExecutor serverGremlinExecutor) {
@@ -64,26 +65,31 @@ public void configure(final ChannelPipeline pipeline) {
         pipeline.addLast(new HttpObjectAggregator(settings.maxContentLength));
 
         if (authenticator != null) {
-            // Cannot add the same handler instance to multiple times unless
+            // Cannot add the same handler instance multiple times unless
             // it is marked as @Sharable, indicating a race condition will
             // not occur. It may not be a safe assumption that the handler
             // is sharable so create a new handler each time.
-            authenticationHandler = authenticator.getClass() == AllowAllAuthenticator.class ?
-                    null : instantiateAuthenticationHandler(settings.authentication);
+            final AbstractAuthenticationHandler authenticationHandler = authenticator.getClass() == AllowAllAuthenticator.class ?
+                    null : instantiateAuthenticationHandler(settings);
             if (authenticationHandler != null)
                 pipeline.addLast(PIPELINE_AUTHENTICATOR, authenticationHandler);
         }
 
+        if (authorizer != null) {
+            final ChannelInboundHandlerAdapter authorizationHandler = new HttpBasicAuthorizationHandler(authorizer);
+            pipeline.addLast(PIPELINE_AUTHORIZER, authorizationHandler);
+        }
+
         pipeline.addLast("http-gremlin-handler", httpGremlinEndpointHandler);
     }
 
-    private AbstractAuthenticationHandler instantiateAuthenticationHandler(final Settings.AuthenticationSettings authSettings) {
-        final String authHandlerClass = authSettings.authenticationHandler;
+    private AbstractAuthenticationHandler instantiateAuthenticationHandler(final Settings settings) {
+        final String authHandlerClass = settings.authentication.authenticationHandler;
         if (authHandlerClass == null) {
             //Keep things backwards compatible
-            return new HttpBasicAuthenticationHandler(authenticator, authSettings);
+            return new HttpBasicAuthenticationHandler(authenticator, settings);
         } else {
-            return createAuthenticationHandler(authSettings);
+            return createAuthenticationHandler(settings);
         }
     }
 
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/channel/WebSocketChannelizer.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/channel/WebSocketChannelizer.java
index 09bcdd265fb..c4ff402525d 100644
--- a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/channel/WebSocketChannelizer.java
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/channel/WebSocketChannelizer.java
@@ -18,6 +18,7 @@
  */
 package org.apache.tinkerpop.gremlin.server.channel;
 
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.handler.codec.http.websocketx.PingWebSocketFrame;
 import io.netty.handler.codec.http.websocketx.WebSocketDecoderConfig;
 import org.apache.tinkerpop.gremlin.server.AbstractChannelizer;
@@ -25,6 +26,7 @@
 import org.apache.tinkerpop.gremlin.server.auth.AllowAllAuthenticator;
 import org.apache.tinkerpop.gremlin.server.handler.AbstractAuthenticationHandler;
 import org.apache.tinkerpop.gremlin.server.Settings;
+import org.apache.tinkerpop.gremlin.server.handler.WebSocketAuthorizationHandler;
 import org.apache.tinkerpop.gremlin.server.handler.SaslAuthenticationHandler;
 import org.apache.tinkerpop.gremlin.server.handler.WsGremlinBinaryRequestDecoder;
 import org.apache.tinkerpop.gremlin.server.handler.WsGremlinCloseRequestDecoder;
@@ -57,6 +59,7 @@ public class WebSocketChannelizer extends AbstractChannelizer {
     private WsGremlinResponseFrameEncoder wsGremlinResponseFrameEncoder;
     private WsGremlinCloseRequestDecoder wsGremlinCloseRequestDecoder;
     private AbstractAuthenticationHandler authenticationHandler;
+    private ChannelInboundHandlerAdapter authorizationHandler;
 
     @Override
     public void init(final ServerGremlinExecutor serverGremlinExecutor) {
@@ -69,9 +72,11 @@ public void init(final ServerGremlinExecutor serverGremlinExecutor) {
         wsGremlinResponseFrameEncoder = new WsGremlinResponseFrameEncoder();
 
         // configure authentication - null means don't bother to add authentication to the pipeline
-        if (authenticator != null)
-            authenticationHandler = authenticator.getClass() == AllowAllAuthenticator.class ?
-                    null : instantiateAuthenticationHandler(settings.authentication);
+        authenticationHandler = authenticator.getClass() == AllowAllAuthenticator.class ?
+            null : instantiateAuthenticationHandler(settings);
+        if (authorizer != null) {
+            authorizationHandler = new WebSocketAuthorizationHandler(authorizer);
+        }
     }
 
     @Override
@@ -120,6 +125,9 @@ public void configure(final ChannelPipeline pipeline) {
 
         if (authenticationHandler != null)
             pipeline.addLast(PIPELINE_AUTHENTICATOR, authenticationHandler);
+
+        if (authorizationHandler != null)
+            pipeline.addLast(PIPELINE_AUTHORIZER, authorizationHandler);
     }
 
     @Override
@@ -132,13 +140,13 @@ public Object createIdleDetectionMessage() {
         return new PingWebSocketFrame();
     }
 
-    private AbstractAuthenticationHandler instantiateAuthenticationHandler(final Settings.AuthenticationSettings authSettings) {
-        final String authenticationHandler = authSettings.authenticationHandler;
+    private AbstractAuthenticationHandler instantiateAuthenticationHandler(final Settings settings) {
+        final String authenticationHandler = settings.authentication.authenticationHandler;
         if (authenticationHandler == null) {
             //Keep things backwards compatible
-            return new SaslAuthenticationHandler(authenticator, authSettings);
+            return new SaslAuthenticationHandler(authenticator, settings);
         } else {
-            return createAuthenticationHandler(authSettings);
+            return createAuthenticationHandler(settings);
         }
     }
 }
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpBasicAuthenticationHandler.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpBasicAuthenticationHandler.java
index 537b1d47a05..a282874f763 100644
--- a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpBasicAuthenticationHandler.java
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpBasicAuthenticationHandler.java
@@ -20,12 +20,12 @@
 
 import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandlerContext;
-import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.handler.codec.http.DefaultFullHttpResponse;
 import io.netty.handler.codec.http.FullHttpMessage;
 import io.netty.util.ReferenceCountUtil;
 import org.apache.tinkerpop.gremlin.server.GremlinServer;
 import org.apache.tinkerpop.gremlin.server.Settings;
+import org.apache.tinkerpop.gremlin.server.auth.AuthenticatedUser;
 import org.apache.tinkerpop.gremlin.server.auth.AuthenticationException;
 import org.apache.tinkerpop.gremlin.server.auth.Authenticator;
 import org.slf4j.Logger;
@@ -50,14 +50,13 @@
 public class HttpBasicAuthenticationHandler extends AbstractAuthenticationHandler {
     private static final Logger logger = LoggerFactory.getLogger(HttpBasicAuthenticationHandler.class);
     private static final Logger auditLogger = LoggerFactory.getLogger(GremlinServer.AUDIT_LOGGER_NAME);
-    private final Settings.AuthenticationSettings authenticationSettings;
+    private final Settings settings;
 
     private final Base64.Decoder decoder = Base64.getUrlDecoder();
 
-    public HttpBasicAuthenticationHandler(final Authenticator authenticator,
-                                          final Settings.AuthenticationSettings authenticationSettings) {
+    public HttpBasicAuthenticationHandler(final Authenticator authenticator, final Settings settings) {
         super(authenticator);
-        this.authenticationSettings = authenticationSettings;
+        this.settings = settings;
     }
 
     @Override
@@ -103,11 +102,11 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
             credentials.put(PROPERTY_ADDRESS, address);
 
             try {
-                authenticator.authenticate(credentials);
+                final AuthenticatedUser user = authenticator.authenticate(credentials);
+                ctx.channel().attr(StateKey.AUTHENTICATED_USER).set(user);
                 ctx.fireChannelRead(request);
-
                 // User name logged with the remote socket address and authenticator classname for audit logging
-                if (authenticationSettings.enableAuditLog) {
+                if (settings.enableAuditLog || settings.authentication.enableAuditLog) {
                     final String[] authClassParts = authenticator.getClass().toString().split("[.]");
                     auditLogger.info("User {} with address {} authenticated by {}",
                             credentials.get(PROPERTY_USERNAME), address, authClassParts[authClassParts.length - 1]);
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpBasicAuthorizationHandler.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpBasicAuthorizationHandler.java
new file mode 100644
index 00000000000..0951a5d561c
--- /dev/null
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpBasicAuthorizationHandler.java
@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.server.handler;
+
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.handler.codec.http.FullHttpMessage;
+import io.netty.handler.codec.http.FullHttpRequest;
+import io.netty.handler.codec.http.HttpUtil;
+import io.netty.util.ReferenceCountUtil;
+import org.apache.tinkerpop.gremlin.driver.Tokens;
+import org.apache.tinkerpop.gremlin.driver.message.RequestMessage;
+import org.apache.tinkerpop.gremlin.server.GremlinServer;
+import org.apache.tinkerpop.gremlin.server.auth.AuthenticatedUser;
+import org.apache.tinkerpop.gremlin.server.authz.AuthorizationException;
+import org.apache.tinkerpop.gremlin.server.authz.Authorizer;
+import org.javatuples.Quartet;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Map;
+
+import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;
+import static io.netty.handler.codec.http.HttpResponseStatus.INTERNAL_SERVER_ERROR;
+import static io.netty.handler.codec.http.HttpResponseStatus.UNAUTHORIZED;
+
+
+/**
+ *  An authorization handler for the http channel that allows the {@link Authorizer} to be plugged into it.
+ *
+ * @author Marc de Lignie
+ */
+@ChannelHandler.Sharable
+public class HttpBasicAuthorizationHandler extends ChannelInboundHandlerAdapter {
+    private static final Logger logger = LoggerFactory.getLogger(HttpBasicAuthorizationHandler.class);
+    private static final Logger auditLogger = LoggerFactory.getLogger(GremlinServer.AUDIT_LOGGER_NAME);
+
+    private AuthenticatedUser user;
+    private final Authorizer authorizer;
+
+    public HttpBasicAuthorizationHandler(Authorizer authorizer) {
+        this.authorizer = authorizer;
+    }
+
+    @Override
+    public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
+        if (msg instanceof FullHttpMessage){
+            final FullHttpMessage request = (FullHttpMessage) msg;
+            final boolean keepAlive = HttpUtil.isKeepAlive(request);
+            try {
+                user = ctx.channel().attr(StateKey.AUTHENTICATED_USER).get();
+                if (null == user) {    // This is expected when using the AllowAllAuthenticator
+                    user = AuthenticatedUser.ANONYMOUS_USER;
+                }
+                final Quartet<String, Map<String, Object>, String, Map<String, String>> requestArguments =
+                        HttpHandlerUtil.getRequestArguments((FullHttpRequest) request);
+                final RequestMessage requestMessage = RequestMessage.build(Tokens.OPS_EVAL).
+                        processor("").
+                        addArg(Tokens.ARGS_GREMLIN, requestArguments.getValue0()).
+                        addArg(Tokens.ARGS_BINDINGS, requestArguments.getValue1()).
+                        addArg(Tokens.ARGS_LANGUAGE, requestArguments.getValue2()).
+                        addArg(Tokens.ARGS_ALIASES, requestArguments.getValue3()).
+                        create();
+                authorizer.authorize(user, requestMessage);
+                ctx.fireChannelRead(request);
+            } catch (AuthorizationException ex) {  // Expected: users can alternate between allowed and disallowed requests
+                String address = ctx.channel().remoteAddress().toString();
+                if (address.startsWith("/") && address.length() > 1) address = address.substring(1);
+                final String script;
+                try {
+                    script = HttpHandlerUtil.getRequestArguments((FullHttpRequest) request).getValue0();
+                } catch (IllegalArgumentException iae) {
+                    HttpHandlerUtil.sendError(ctx, BAD_REQUEST, iae.getMessage(), keepAlive);
+                    return;
+                }
+                auditLogger.info("User {} with address {} attempted an unauthorized http request: {}",
+                    user.getName(), address, script);
+                final String message = String.format("No authorization for script [%s] - check permissions.", script);
+                HttpHandlerUtil.sendError(ctx, UNAUTHORIZED, message, keepAlive);
+                ReferenceCountUtil.release(msg);
+            } catch (Exception ex) {
+                final String message = String.format(
+                        "%s is not ready to handle requests - unknown error", authorizer.getClass().getSimpleName());
+                HttpHandlerUtil.sendError(ctx, INTERNAL_SERVER_ERROR, message, keepAlive);
+                ReferenceCountUtil.release(msg);
+            }
+        } else {
+            logger.warn("{} only processes FullHttpMessage instances - received {} - channel closing",
+                this.getClass().getSimpleName(), msg.getClass());
+            ctx.close();
+        }
+    }
+}
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpGremlinEndpointHandler.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpGremlinEndpointHandler.java
index b2088e4d422..706cee9c52e 100644
--- a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpGremlinEndpointHandler.java
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpGremlinEndpointHandler.java
@@ -18,7 +18,6 @@
  */
 package org.apache.tinkerpop.gremlin.server.handler;
 
-import com.codahale.metrics.Meter;
 import com.codahale.metrics.Timer;
 import org.javatuples.Pair;
 import org.javatuples.Quartet;
@@ -26,7 +25,6 @@
 import org.slf4j.LoggerFactory;
 import org.apache.commons.lang3.exception.ExceptionUtils;
 import org.apache.tinkerpop.gremlin.driver.MessageSerializer;
-import org.apache.tinkerpop.gremlin.driver.Tokens;
 import org.apache.tinkerpop.gremlin.driver.message.ResponseMessage;
 import org.apache.tinkerpop.gremlin.driver.message.ResponseStatusCode;
 import org.apache.tinkerpop.gremlin.driver.ser.MessageTextSerializer;
@@ -35,18 +33,13 @@
 import org.apache.tinkerpop.gremlin.server.GraphManager;
 import org.apache.tinkerpop.gremlin.server.GremlinServer;
 import org.apache.tinkerpop.gremlin.server.Settings;
+import org.apache.tinkerpop.gremlin.server.auth.AuthenticatedUser;
 import org.apache.tinkerpop.gremlin.server.util.MetricManager;
 import org.apache.tinkerpop.gremlin.structure.Graph;
 import org.apache.tinkerpop.gremlin.util.function.FunctionUtils;
 import org.apache.tinkerpop.gremlin.util.iterator.IteratorUtils;
-import org.apache.tinkerpop.shaded.jackson.databind.JsonNode;
-import org.apache.tinkerpop.shaded.jackson.databind.ObjectMapper;
-import org.apache.tinkerpop.shaded.jackson.databind.node.ArrayNode;
-import org.apache.tinkerpop.shaded.jackson.databind.node.ObjectNode;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.Unpooled;
-import io.netty.channel.ChannelFuture;
-import io.netty.channel.ChannelFutureListener;
 import io.netty.channel.ChannelHandler;
 import io.netty.channel.ChannelHandlerContext;
 import io.netty.channel.ChannelInboundHandlerAdapter;
@@ -57,19 +50,13 @@
 import io.netty.handler.codec.http.FullHttpResponse;
 import io.netty.handler.codec.http.HttpResponseStatus;
 import io.netty.handler.codec.http.HttpUtil;
-import io.netty.handler.codec.http.QueryStringDecoder;
-import io.netty.util.CharsetUtil;
 import io.netty.util.ReferenceCountUtil;
 
 import javax.script.Bindings;
 import javax.script.SimpleBindings;
-import java.io.IOException;
 import java.nio.charset.Charset;
 import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
@@ -103,11 +90,6 @@ public class HttpGremlinEndpointHandler extends ChannelInboundHandlerAdapter {
     private static final Logger logger = LoggerFactory.getLogger(HttpGremlinEndpointHandler.class);
     private static final Logger auditLogger = LoggerFactory.getLogger(GremlinServer.AUDIT_LOGGER_NAME);
     private static final Charset UTF8 = StandardCharsets.UTF_8;
-    static final Meter errorMeter = MetricManager.INSTANCE.getMeter(name(GremlinServer.class, "errors"));
-
-    private static final String ARGS_BINDINGS_DOT = Tokens.ARGS_BINDINGS + ".";
-
-    private static final String ARGS_ALIASES_DOT = Tokens.ARGS_ALIASES + ".";
 
     private static final Timer evalOpTimer = MetricManager.INSTANCE.getTimer(name(GremlinServer.class, "op", "eval"));
 
@@ -116,12 +98,6 @@ public class HttpGremlinEndpointHandler extends ChannelInboundHandlerAdapter {
      */
     private final Map<String, MessageSerializer> serializers;
 
-    /**
-     * This is just a generic mapper to interpret the JSON of a POSTed request.  It is not used for the serialization
-     * of the response.
-     */
-    private static final ObjectMapper mapper = new ObjectMapper();
-
     private final GremlinExecutor gremlinExecutor;
     private final GraphManager graphManager;
     private final Settings settings;
@@ -145,7 +121,7 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
             final boolean keepAlive = HttpUtil.isKeepAlive(req);
 
             if ("/favicon.ico".equals(req.uri())) {
-                sendError(ctx, NOT_FOUND, "Gremlin Server doesn't have a favicon.ico", keepAlive);
+                HttpHandlerUtil.sendError(ctx, NOT_FOUND, "Gremlin Server doesn't have a favicon.ico", keepAlive);
                 ReferenceCountUtil.release(msg);
                 return;
             }
@@ -155,16 +131,16 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
             }
 
             if (req.method() != GET && req.method() != POST) {
-                sendError(ctx, METHOD_NOT_ALLOWED, METHOD_NOT_ALLOWED.toString(), keepAlive);
+                HttpHandlerUtil.sendError(ctx, METHOD_NOT_ALLOWED, METHOD_NOT_ALLOWED.toString(), keepAlive);
                 ReferenceCountUtil.release(msg);
                 return;
             }
 
             final Quartet<String, Map<String, Object>, String, Map<String, String>> requestArguments;
             try {
-                requestArguments = getRequestArguments(req);
+                requestArguments = HttpHandlerUtil.getRequestArguments(req);
             } catch (IllegalArgumentException iae) {
-                sendError(ctx, BAD_REQUEST, iae.getMessage(), keepAlive);
+                HttpHandlerUtil.sendError(ctx, BAD_REQUEST, iae.getMessage(), keepAlive);
                 ReferenceCountUtil.release(msg);
                 return;
             }
@@ -172,7 +148,7 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
             final String acceptString = Optional.ofNullable(req.headers().get("Accept")).orElse("application/json");
             final Pair<String, MessageTextSerializer> serializer = chooseSerializer(acceptString);
             if (null == serializer) {
-                sendError(ctx, BAD_REQUEST, String.format("no serializer for requested Accept header: %s", acceptString),
+                HttpHandlerUtil.sendError(ctx, BAD_REQUEST, String.format("no serializer for requested Accept header: %s", acceptString),
                         keepAlive);
                 ReferenceCountUtil.release(msg);
                 return;
@@ -186,6 +162,15 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
             try {
                 logger.debug("Processing request containing script [{}] and bindings of [{}] on {}",
                         requestArguments.getValue0(), requestArguments.getValue1(), Thread.currentThread().getName());
+                if (settings.enableAuditLog) {
+                    AuthenticatedUser user = ctx.channel().attr(StateKey.AUTHENTICATED_USER).get();
+                    if (null == user) {    // This is expected when using the AllowAllAuthenticator
+                        user = AuthenticatedUser.ANONYMOUS_USER;
+                    }
+                    String address = ctx.channel().remoteAddress().toString();
+                    if (address.startsWith("/") && address.length() > 1) address = address.substring(1);
+                    auditLogger.info("User {} with address {} requested: {}", user.getName(), address, requestArguments.getValue0());
+                }
                 if (settings.authentication.enableAuditLog) {
                     String address = ctx.channel().remoteAddress().toString();
                     if (address.startsWith("/") && address.length() > 1) address = address.substring(1);
@@ -205,7 +190,7 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
                         // handle cors business
                         if (origin != null) response.headers().set(ACCESS_CONTROL_ALLOW_ORIGIN, origin);
 
-                        sendAndCleanupConnection(ctx, keepAlive, response);
+                        HttpHandlerUtil.sendAndCleanupConnection(ctx, keepAlive, response);
                     }
                 });
 
@@ -215,7 +200,7 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
                 try {
                     bindings = createBindings(requestArguments.getValue1(), requestArguments.getValue3());
                 } catch (IllegalStateException iae) {
-                    sendError(ctx, BAD_REQUEST, iae.getMessage(), keepAlive);
+                    HttpHandlerUtil.sendError(ctx, BAD_REQUEST, iae.getMessage(), keepAlive);
                     ReferenceCountUtil.release(msg);
                     return;
                 }
@@ -251,9 +236,9 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
 
                 evalFuture.exceptionally(t -> {
                     if (t.getMessage() != null)
-                        sendError(ctx, INTERNAL_SERVER_ERROR, t.getMessage(), Optional.of(t), keepAlive);
+                        HttpHandlerUtil.sendError(ctx, INTERNAL_SERVER_ERROR, t.getMessage(), Optional.of(t), keepAlive);
                     else
-                        sendError(ctx, INTERNAL_SERVER_ERROR, String.format("Error encountered evaluating script: %s", requestArguments.getValue0())
+                        HttpHandlerUtil.sendError(ctx, INTERNAL_SERVER_ERROR, String.format("Error encountered evaluating script: %s", requestArguments.getValue0())
                                 , Optional.of(t), keepAlive);
                     promise.setFailure(t);
                     return null;
@@ -270,11 +255,11 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
                 // context on whether to close the connection or not, based on keepalive.
                 final Throwable t = ExceptionUtils.getRootCause(ex);
                 if (t instanceof TooLongFrameException) {
-                    sendError(ctx, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, t.getMessage() + " - increase the maxContentLength", keepAlive);
+                    HttpHandlerUtil.sendError(ctx, HttpResponseStatus.REQUEST_ENTITY_TOO_LARGE, t.getMessage() + " - increase the maxContentLength", keepAlive);
                 } else if (t != null){
-                    sendError(ctx, INTERNAL_SERVER_ERROR, t.getMessage(), keepAlive);
+                    HttpHandlerUtil.sendError(ctx, INTERNAL_SERVER_ERROR, t.getMessage(), keepAlive);
                 } else {
-                    sendError(ctx, INTERNAL_SERVER_ERROR, ex.getMessage(), keepAlive);
+                    HttpHandlerUtil.sendError(ctx, INTERNAL_SERVER_ERROR, ex.getMessage(), keepAlive);
                 }
             }
         }
@@ -285,7 +270,7 @@ public void exceptionCaught(final ChannelHandlerContext ctx, final Throwable cau
         logger.error("Error processing HTTP Request", cause);
 
         if (ctx.channel().isActive()) {
-            sendError(ctx, INTERNAL_SERVER_ERROR, cause.getMessage(), false);
+            HttpHandlerUtil.sendError(ctx, INTERNAL_SERVER_ERROR, cause.getMessage(), false);
         }
     }
 
@@ -343,137 +328,6 @@ private Pair<String, MessageTextSerializer> chooseSerializer(final String accept
         return null;
     }
 
-    private static Quartet<String, Map<String, Object>, String, Map<String, String>> getRequestArguments(final FullHttpRequest request) {
-        if (request.method() == GET) {
-            final QueryStringDecoder decoder = new QueryStringDecoder(request.uri());
-            final List<String> gremlinParms = decoder.parameters().get(Tokens.ARGS_GREMLIN);
-
-            if (null == gremlinParms || gremlinParms.size() == 0)
-                throw new IllegalArgumentException("no gremlin script supplied");
-            final String script = gremlinParms.get(0);
-            if (script.isEmpty()) throw new IllegalArgumentException("no gremlin script supplied");
-
-            // query string parameters - take the first instance of a key only - ignore the rest
-            final Map<String, Object> bindings = new HashMap<>();
-            decoder.parameters().entrySet().stream().filter(kv -> kv.getKey().startsWith(ARGS_BINDINGS_DOT))
-                    .forEach(kv -> bindings.put(kv.getKey().substring(ARGS_BINDINGS_DOT.length()), kv.getValue().get(0)));
-
-            final Map<String, String> aliases = new HashMap<>();
-            decoder.parameters().entrySet().stream().filter(kv -> kv.getKey().startsWith(ARGS_ALIASES_DOT))
-                    .forEach(kv -> aliases.put(kv.getKey().substring(ARGS_ALIASES_DOT.length()), kv.getValue().get(0)));
-
-            final List<String> languageParms = decoder.parameters().get(Tokens.ARGS_LANGUAGE);
-            final String language = (null == languageParms || languageParms.size() == 0) ? null : languageParms.get(0);
-
-            return Quartet.with(script, bindings, language, aliases);
-        } else {
-            final JsonNode body;
-            try {
-                body = mapper.readTree(request.content().toString(CharsetUtil.UTF_8));
-            } catch (IOException ioe) {
-                throw new IllegalArgumentException("body could not be parsed", ioe);
-            }
-
-            final JsonNode scriptNode = body.get(Tokens.ARGS_GREMLIN);
-            if (null == scriptNode) throw new IllegalArgumentException("no gremlin script supplied");
-
-            final JsonNode bindingsNode = body.get(Tokens.ARGS_BINDINGS);
-            if (bindingsNode != null && !bindingsNode.isObject())
-                throw new IllegalArgumentException("bindings must be a Map");
-
-            final Map<String, Object> bindings = new HashMap<>();
-            if (bindingsNode != null)
-                bindingsNode.fields().forEachRemaining(kv -> bindings.put(kv.getKey(), fromJsonNode(kv.getValue())));
-
-            final JsonNode aliasesNode = body.get(Tokens.ARGS_ALIASES);
-            if (aliasesNode != null && !aliasesNode.isObject())
-                throw new IllegalArgumentException("aliases must be a Map");
-
-            final Map<String, String> aliases = new HashMap<>();
-            if (aliasesNode != null)
-                aliasesNode.fields().forEachRemaining(kv -> aliases.put(kv.getKey(), kv.getValue().asText()));
-
-            final JsonNode languageNode = body.get(Tokens.ARGS_LANGUAGE);
-            final String language = null == languageNode ? null : languageNode.asText();
-
-            return Quartet.with(scriptNode.asText(), bindings, language, aliases);
-        }
-    }
-
-    public static Object fromJsonNode(final JsonNode node) {
-        if (node.isNull())
-            return null;
-        else if (node.isObject()) {
-            final Map<String, Object> map = new HashMap<>();
-            final ObjectNode objectNode = (ObjectNode) node;
-            final Iterator<String> iterator = objectNode.fieldNames();
-            while (iterator.hasNext()) {
-                String key = iterator.next();
-                map.put(key, fromJsonNode(objectNode.get(key)));
-            }
-            return map;
-        } else if (node.isArray()) {
-            final ArrayNode arrayNode = (ArrayNode) node;
-            final ArrayList<Object> array = new ArrayList<>();
-            for (int i = 0; i < arrayNode.size(); i++) {
-                array.add(fromJsonNode(arrayNode.get(i)));
-            }
-            return array;
-        } else if (node.isFloatingPointNumber())
-            return node.asDouble();
-        else if (node.isIntegralNumber())
-            return node.asLong();
-        else if (node.isBoolean())
-            return node.asBoolean();
-        else
-            return node.asText();
-    }
-
-    private static void sendError(final ChannelHandlerContext ctx, final HttpResponseStatus status,
-                                  final String message, final boolean keepAlive) {
-        sendError(ctx, status, message, Optional.empty(), keepAlive);
-    }
-
-    private static void sendError(final ChannelHandlerContext ctx, final HttpResponseStatus status,
-                                  final String message, final Optional<Throwable> t, final boolean keepAlive) {
-        if (t.isPresent())
-            logger.warn(String.format("Invalid request - responding with %s and %s", status, message), t.get());
-        else
-            logger.warn(String.format("Invalid request - responding with %s and %s", status, message));
-
-        errorMeter.mark();
-        final ObjectNode node = mapper.createObjectNode();
-        node.put("message", message);
-        if (t.isPresent()) {
-            // "Exception-Class" needs to go away - didn't realize it was named that way during review for some reason.
-            // replaced with the same method for exception reporting as is used with websocket/nio protocol
-            node.put("Exception-Class", t.get().getClass().getName());
-            final ArrayNode exceptionList = node.putArray(Tokens.STATUS_ATTRIBUTE_EXCEPTIONS);
-            ExceptionUtils.getThrowableList(t.get()).forEach(throwable -> exceptionList.add(throwable.getClass().getName()));
-            node.put(Tokens.STATUS_ATTRIBUTE_STACK_TRACE, ExceptionUtils.getStackTrace(t.get()));
-        }
-
-        final FullHttpResponse response = new DefaultFullHttpResponse(
-                HTTP_1_1, status, Unpooled.copiedBuffer(node.toString(), CharsetUtil.UTF_8));
-        response.headers().set(CONTENT_TYPE, "application/json");
-
-        sendAndCleanupConnection(ctx, keepAlive, response);
-    }
-
-    private static void sendAndCleanupConnection(final ChannelHandlerContext ctx,
-                                                 final boolean keepAlive,
-                                                 final FullHttpResponse response) {
-        HttpUtil.setKeepAlive(response, keepAlive);
-        HttpUtil.setContentLength(response, response.content().readableBytes());
-
-        final ChannelFuture flushPromise = ctx.writeAndFlush(response);
-
-        if (!keepAlive) {
-            // Close the connection as soon as the response is sent.
-            flushPromise.addListener(ChannelFutureListener.CLOSE);
-        }
-    }
-
     private static void attemptCommit(final Map<String, String> aliases, final GraphManager graphManager, final boolean strict) {
         if (strict)
             graphManager.commit(new HashSet<>(aliases.values()));
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpHandlerUtil.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpHandlerUtil.java
new file mode 100644
index 00000000000..c1ae1e54ea7
--- /dev/null
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/HttpHandlerUtil.java
@@ -0,0 +1,204 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.server.handler;
+
+import com.codahale.metrics.Meter;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.http.DefaultFullHttpResponse;
+import io.netty.handler.codec.http.FullHttpRequest;
+import io.netty.handler.codec.http.FullHttpResponse;
+import io.netty.handler.codec.http.HttpResponseStatus;
+import io.netty.handler.codec.http.HttpUtil;
+import io.netty.handler.codec.http.QueryStringDecoder;
+import io.netty.util.CharsetUtil;
+import org.apache.commons.lang3.exception.ExceptionUtils;
+import org.apache.tinkerpop.gremlin.driver.Tokens;
+import org.apache.tinkerpop.gremlin.server.GremlinServer;
+import org.apache.tinkerpop.gremlin.server.util.MetricManager;
+import org.apache.tinkerpop.shaded.jackson.databind.JsonNode;
+import org.apache.tinkerpop.shaded.jackson.databind.ObjectMapper;
+import org.apache.tinkerpop.shaded.jackson.databind.node.ArrayNode;
+import org.apache.tinkerpop.shaded.jackson.databind.node.ObjectNode;
+import org.javatuples.Quartet;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+
+import static com.codahale.metrics.MetricRegistry.name;
+import static io.netty.handler.codec.http.HttpHeaderNames.CONTENT_TYPE;
+import static io.netty.handler.codec.http.HttpMethod.GET;
+import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;
+
+/**
+ * Provides methods shared by the HTTP handlers.
+ *
+ * @author Stephen Mallette (http://stephen.genoprime.com)
+ */
+public class HttpHandlerUtil {
+    private static final Logger logger = LoggerFactory.getLogger(HttpHandlerUtil.class);
+    static final Meter errorMeter = MetricManager.INSTANCE.getMeter(name(GremlinServer.class, "errors"));
+    private static final String ARGS_BINDINGS_DOT = Tokens.ARGS_BINDINGS + ".";
+    private static final String ARGS_ALIASES_DOT = Tokens.ARGS_ALIASES + ".";
+    /**
+     * This is just a generic mapper to interpret the JSON of a POSTed request.  It is not used for the serialization
+     * of the response.
+     */
+    private static final ObjectMapper mapper = new ObjectMapper();
+
+    static Quartet<String, Map<String, Object>, String, Map<String, String>> getRequestArguments(final FullHttpRequest request) {
+        if (request.method() == GET) {
+            final QueryStringDecoder decoder = new QueryStringDecoder(request.uri());
+            final List<String> gremlinParms = decoder.parameters().get(Tokens.ARGS_GREMLIN);
+
+            if (null == gremlinParms || gremlinParms.size() == 0)
+                throw new IllegalArgumentException("no gremlin script supplied");
+            final String script = gremlinParms.get(0);
+            if (script.isEmpty()) throw new IllegalArgumentException("no gremlin script supplied");
+
+            // query string parameters - take the first instance of a key only - ignore the rest
+            final Map<String, Object> bindings = new HashMap<>();
+            decoder.parameters().entrySet().stream().filter(kv -> kv.getKey().startsWith(ARGS_BINDINGS_DOT))
+                    .forEach(kv -> bindings.put(kv.getKey().substring(ARGS_BINDINGS_DOT.length()), kv.getValue().get(0)));
+
+            final Map<String, String> aliases = new HashMap<>();
+            decoder.parameters().entrySet().stream().filter(kv -> kv.getKey().startsWith(ARGS_ALIASES_DOT))
+                    .forEach(kv -> aliases.put(kv.getKey().substring(ARGS_ALIASES_DOT.length()), kv.getValue().get(0)));
+
+            final List<String> languageParms = decoder.parameters().get(Tokens.ARGS_LANGUAGE);
+            final String language = (null == languageParms || languageParms.size() == 0) ? null : languageParms.get(0);
+
+            return Quartet.with(script, bindings, language, aliases);
+        } else {
+            final JsonNode body;
+            try {
+                body = mapper.readTree(request.content().toString(CharsetUtil.UTF_8));
+            } catch (IOException ioe) {
+                throw new IllegalArgumentException("body could not be parsed", ioe);
+            }
+
+            final JsonNode scriptNode = body.get(Tokens.ARGS_GREMLIN);
+            if (null == scriptNode) throw new IllegalArgumentException("no gremlin script supplied");
+
+            final JsonNode bindingsNode = body.get(Tokens.ARGS_BINDINGS);
+            if (bindingsNode != null && !bindingsNode.isObject())
+                throw new IllegalArgumentException("bindings must be a Map");
+
+            final Map<String, Object> bindings = new HashMap<>();
+            if (bindingsNode != null)
+                bindingsNode.fields().forEachRemaining(kv -> bindings.put(kv.getKey(), fromJsonNode(kv.getValue())));
+
+            final JsonNode aliasesNode = body.get(Tokens.ARGS_ALIASES);
+            if (aliasesNode != null && !aliasesNode.isObject())
+                throw new IllegalArgumentException("aliases must be a Map");
+
+            final Map<String, String> aliases = new HashMap<>();
+            if (aliasesNode != null)
+                aliasesNode.fields().forEachRemaining(kv -> aliases.put(kv.getKey(), kv.getValue().asText()));
+
+            final JsonNode languageNode = body.get(Tokens.ARGS_LANGUAGE);
+            final String language = null == languageNode ? null : languageNode.asText();
+
+            return Quartet.with(scriptNode.asText(), bindings, language, aliases);
+        }
+    }
+
+    private static Object fromJsonNode(final JsonNode node) {
+        if (node.isNull())
+            return null;
+        else if (node.isObject()) {
+            final Map<String, Object> map = new HashMap<>();
+            final ObjectNode objectNode = (ObjectNode) node;
+            final Iterator<String> iterator = objectNode.fieldNames();
+            while (iterator.hasNext()) {
+                String key = iterator.next();
+                map.put(key, fromJsonNode(objectNode.get(key)));
+            }
+            return map;
+        } else if (node.isArray()) {
+            final ArrayNode arrayNode = (ArrayNode) node;
+            final ArrayList<Object> array = new ArrayList<>();
+            for (int i = 0; i < arrayNode.size(); i++) {
+                array.add(fromJsonNode(arrayNode.get(i)));
+            }
+            return array;
+        } else if (node.isFloatingPointNumber())
+            return node.asDouble();
+        else if (node.isIntegralNumber())
+            return node.asLong();
+        else if (node.isBoolean())
+            return node.asBoolean();
+        else
+            return node.asText();
+    }
+
+    static void sendError(final ChannelHandlerContext ctx, final HttpResponseStatus status,
+                          final String message, final boolean keepAlive) {
+        sendError(ctx, status, message, Optional.empty(), keepAlive);
+    }
+
+    static void sendError(final ChannelHandlerContext ctx, final HttpResponseStatus status,
+                          final String message, final Optional<Throwable> t, final boolean keepAlive) {
+        if (t.isPresent())
+            logger.warn(String.format("Invalid request - responding with %s and %s", status, message), t.get());
+        else
+            logger.warn(String.format("Invalid request - responding with %s and %s", status, message));
+
+        errorMeter.mark();
+        final ObjectNode node = mapper.createObjectNode();
+        node.put("message", message);
+        if (t.isPresent()) {
+            // "Exception-Class" needs to go away - didn't realize it was named that way during review for some reason.
+            // replaced with the same method for exception reporting as is used with websocket/nio protocol
+            node.put("Exception-Class", t.get().getClass().getName());
+            final ArrayNode exceptionList = node.putArray(Tokens.STATUS_ATTRIBUTE_EXCEPTIONS);
+            ExceptionUtils.getThrowableList(t.get()).forEach(throwable -> exceptionList.add(throwable.getClass().getName()));
+            node.put(Tokens.STATUS_ATTRIBUTE_STACK_TRACE, ExceptionUtils.getStackTrace(t.get()));
+        }
+
+        final FullHttpResponse response = new DefaultFullHttpResponse(
+                HTTP_1_1, status, Unpooled.copiedBuffer(node.toString(), CharsetUtil.UTF_8));
+        response.headers().set(CONTENT_TYPE, "application/json");
+
+        sendAndCleanupConnection(ctx, keepAlive, response);
+    }
+
+    static void sendAndCleanupConnection(final ChannelHandlerContext ctx,
+                                         final boolean keepAlive,
+                                         final FullHttpResponse response) {
+        HttpUtil.setKeepAlive(response, keepAlive);
+        HttpUtil.setContentLength(response, response.content().readableBytes());
+
+        final ChannelFuture flushPromise = ctx.writeAndFlush(response);
+
+        if (!keepAlive) {
+            // Close the connection as soon as the response is sent.
+            flushPromise.addListener(ChannelFutureListener.CLOSE);
+        }
+    }
+}
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/SaslAndHttpBasicAuthenticationHandler.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/SaslAndHttpBasicAuthenticationHandler.java
index 078dfc1098e..d58553def2f 100644
--- a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/SaslAndHttpBasicAuthenticationHandler.java
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/SaslAndHttpBasicAuthenticationHandler.java
@@ -39,9 +39,8 @@ public class SaslAndHttpBasicAuthenticationHandler extends SaslAuthenticationHan
 
     private final String HTTP_AUTH = "http-authentication";
 
-    public SaslAndHttpBasicAuthenticationHandler(final Authenticator authenticator, 
-                                                 final Settings.AuthenticationSettings authenticationSettings) {
-        super(authenticator, authenticationSettings);
+    public SaslAndHttpBasicAuthenticationHandler(final Authenticator authenticator, final Settings settings) {
+        super(authenticator, settings);
     }
 
     @Override
@@ -51,7 +50,7 @@ public void channelRead(final ChannelHandlerContext ctx, final Object obj) throw
             if (null != pipeline.get(HTTP_AUTH)) {
                 pipeline.remove(HTTP_AUTH);
             }
-            pipeline.addAfter(PIPELINE_AUTHENTICATOR, HTTP_AUTH, new HttpBasicAuthenticationHandler(authenticator, this.authenticationSettings));
+            pipeline.addAfter(PIPELINE_AUTHENTICATOR, HTTP_AUTH, new HttpBasicAuthenticationHandler(authenticator, this.settings));
             ctx.fireChannelRead(obj);
         } else {
             super.channelRead(ctx, obj);
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/SaslAuthenticationHandler.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/SaslAuthenticationHandler.java
index 6b2d248d330..e8216a6919e 100644
--- a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/SaslAuthenticationHandler.java
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/SaslAuthenticationHandler.java
@@ -57,11 +57,11 @@ public class SaslAuthenticationHandler extends AbstractAuthenticationHandler {
     private static final Base64.Encoder BASE64_ENCODER = Base64.getEncoder();
     private static final Logger auditLogger = LoggerFactory.getLogger(GremlinServer.AUDIT_LOGGER_NAME);
 
-    protected final Settings.AuthenticationSettings authenticationSettings;
+    protected final Settings settings;
 
-    public SaslAuthenticationHandler(final Authenticator authenticator, final Settings.AuthenticationSettings authenticationSettings) {
+    public SaslAuthenticationHandler(final Authenticator authenticator, final Settings settings) {
         super(authenticator);
-        this.authenticationSettings = authenticationSettings;
+        this.settings = settings;
     }
 
     @Override
@@ -83,7 +83,7 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) throw
                     // newSaslNegotiator can cause troubles - if we don't catch and respond nicely the driver seems
                     // to hang until timeout which isn't so nice. treating this like a server error as it means that
                     // the Authenticator isn't really ready to deal with requests for some reason.
-                    logger.error("{} is not ready to handle requests - check it's configuration or related services",
+                    logger.error("{} is not ready to handle requests - check its configuration or related services",
                             authenticator.getClass().getSimpleName());
 
                     final ResponseMessage error = ResponseMessage.build(requestMessage)
@@ -111,8 +111,9 @@ public void channelRead(final ChannelHandlerContext ctx, final Object msg) throw
                         final byte[] saslMessage = negotiator.get().evaluateResponse(saslResponse);
                         if (negotiator.get().isComplete()) {
                             final AuthenticatedUser user = negotiator.get().getAuthenticatedUser();
+                            ctx.channel().attr(StateKey.AUTHENTICATED_USER).set(user);
                             // User name logged with the remote socket address and authenticator classname for audit logging
-                            if (authenticationSettings.enableAuditLog) {
+                            if (settings.enableAuditLog || settings.authentication.enableAuditLog) {
                                 String address = ctx.channel().remoteAddress().toString();
                                 if (address.startsWith("/") && address.length() > 1) address = address.substring(1);
                                 final String[] authClassParts = authenticator.getClass().toString().split("[.]");
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/StateKey.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/StateKey.java
index 3d7c8c7a707..7890bec840a 100644
--- a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/StateKey.java
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/StateKey.java
@@ -20,6 +20,7 @@
 
 import org.apache.tinkerpop.gremlin.driver.MessageSerializer;
 import org.apache.tinkerpop.gremlin.driver.message.RequestMessage;
+import org.apache.tinkerpop.gremlin.server.auth.AuthenticatedUser;
 import org.apache.tinkerpop.gremlin.server.auth.Authenticator;
 import org.apache.tinkerpop.gremlin.server.op.session.Session;
 import io.netty.util.AttributeKey;
@@ -57,4 +58,9 @@ private StateKey() {}
      * The key for the current request.
      */
     public static final AttributeKey<RequestMessage> REQUEST_MESSAGE = AttributeKey.valueOf("request");
+
+    /**
+     * The key for the current {@link AuthenticatedUser}.
+     */
+    public static final AttributeKey<AuthenticatedUser> AUTHENTICATED_USER = AttributeKey.valueOf("authenticatedUser");
 }
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/WebSocketAuthorizationHandler.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/WebSocketAuthorizationHandler.java
new file mode 100644
index 00000000000..98a24119c76
--- /dev/null
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/handler/WebSocketAuthorizationHandler.java
@@ -0,0 +1,109 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.server.handler;
+
+import io.netty.channel.ChannelHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+
+import org.apache.tinkerpop.gremlin.driver.Tokens;
+import org.apache.tinkerpop.gremlin.driver.message.RequestMessage;
+import org.apache.tinkerpop.gremlin.driver.message.ResponseMessage;
+import org.apache.tinkerpop.gremlin.driver.message.ResponseStatusCode;
+import org.apache.tinkerpop.gremlin.process.traversal.Bytecode;
+import org.apache.tinkerpop.gremlin.server.GremlinServer;
+import org.apache.tinkerpop.gremlin.server.auth.AuthenticatedUser;
+import org.apache.tinkerpop.gremlin.server.authz.Authorizer;
+import org.apache.tinkerpop.gremlin.server.authz.AuthorizationException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.Map;
+
+
+/**
+ *  An authorization handler for the websockets channel that allows the {@link Authorizer} to be plugged into it.
+ *
+ * @author Marc de Lignie
+ */
+@ChannelHandler.Sharable
+public class WebSocketAuthorizationHandler extends ChannelInboundHandlerAdapter {
+    private static final Logger logger = LoggerFactory.getLogger(WebSocketAuthorizationHandler.class);
+    private static final Logger auditLogger = LoggerFactory.getLogger(GremlinServer.AUDIT_LOGGER_NAME);
+
+    private AuthenticatedUser user;
+    private final Authorizer authorizer;
+
+    public WebSocketAuthorizationHandler(Authorizer authorizer) {
+        this.authorizer = authorizer;
+    }
+
+    @Override
+    public void channelRead(final ChannelHandlerContext ctx, final Object msg) {
+        if (msg instanceof RequestMessage){
+            final RequestMessage requestMessage = (RequestMessage) msg;
+            try {
+                user = ctx.channel().attr(StateKey.AUTHENTICATED_USER).get();
+                if (null == user) {    // This is expected when using the AllowAllAuthenticator
+                    user = AuthenticatedUser.ANONYMOUS_USER;
+                }
+                switch (requestMessage.getOp()) {
+                    case Tokens.OPS_BYTECODE:
+                        final Bytecode bytecode = (Bytecode) requestMessage.getArgs().get(Tokens.ARGS_GREMLIN);
+                        final Map<String, String> aliases = (Map<String, String>) requestMessage.getArgs().get(Tokens.ARGS_ALIASES);
+                        final Bytecode restrictedBytecode = authorizer.authorize(user, bytecode, aliases);
+                        final RequestMessage restrictedMsg = RequestMessage.build(Tokens.OPS_BYTECODE).
+                                overrideRequestId(requestMessage.getRequestId()).
+                                processor("traversal").
+                                addArg(Tokens.ARGS_GREMLIN, restrictedBytecode).
+                                addArg(Tokens.ARGS_ALIASES, aliases).create();
+                        ctx.fireChannelRead(restrictedMsg);
+                        break;
+                    case Tokens.OPS_EVAL:
+                        authorizer.authorize(user, requestMessage);
+                        ctx.fireChannelRead(requestMessage);
+                        break;
+                    default:
+                        throw new AuthorizationException("This AuthorizationHandler only handles requests with OPS_BYTECODE or OPS_EVAL.");
+                }
+            } catch (AuthorizationException ex) {  // Expected: users can alternate between allowed and disallowed requests
+                String address = ctx.channel().remoteAddress().toString();
+                if (address.startsWith("/") && address.length() > 1) address = address.substring(1);
+                auditLogger.info("User {} with address {} attempted an unauthorized request for {} operation: {}",
+                        user.getName(), address, requestMessage.getOp(), requestMessage.getArgs().get(Tokens.ARGS_GREMLIN));
+                interruptEvaluation(ctx, requestMessage, ex.getMessage());
+            } catch (Exception ex) {
+                logger.error("{} is not ready to handle requests - unknown error",
+                    authorizer.getClass().getSimpleName());
+                interruptEvaluation(ctx, requestMessage, "Unknown error in gremlin-server");
+            }
+        } else {
+            logger.warn("{} only processes RequestMessage instances - received {} - channel closing",
+                this.getClass().getSimpleName(), msg.getClass());
+            ctx.close();
+        }
+    }
+
+    private void interruptEvaluation(final ChannelHandlerContext ctx, final RequestMessage requestMessage, final String errorMessage) {
+        final ResponseMessage error = ResponseMessage.build(requestMessage)
+            .statusMessage("Failed to authorize: " + errorMessage)
+            .code(ResponseStatusCode.UNAUTHORIZED).create();
+        ctx.writeAndFlush(error);
+    }
+}
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/op/AbstractEvalOpProcessor.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/op/AbstractEvalOpProcessor.java
index fd4491c667f..e04cd714645 100644
--- a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/op/AbstractEvalOpProcessor.java
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/op/AbstractEvalOpProcessor.java
@@ -30,6 +30,8 @@
 import org.apache.tinkerpop.gremlin.process.traversal.Pop;
 import org.apache.tinkerpop.gremlin.process.traversal.Scope;
 import org.apache.tinkerpop.gremlin.server.OpProcessor;
+import org.apache.tinkerpop.gremlin.server.auth.AuthenticatedUser;
+import org.apache.tinkerpop.gremlin.server.handler.StateKey;
 import org.apache.tinkerpop.gremlin.structure.Column;
 import org.apache.tinkerpop.gremlin.structure.T;
 import org.apache.tinkerpop.gremlin.server.Context;
@@ -202,7 +204,7 @@ protected Optional<ThrowingConsumer<Context>> validateEvalMessage(final RequestM
  *                         {@link GremlinExecutor#eval} method.
      */
     protected void evalOpInternal(final Context ctx, final Supplier<GremlinExecutor> gremlinExecutorSupplier,
-                                  final BindingSupplier bindingsSupplier) throws OpProcessorException {
+                                  final BindingSupplier bindingsSupplier) {
         final Timer.Context timerContext = evalOpTimer.time();
         final RequestMessage msg = ctx.getRequestMessage();
         final GremlinExecutor gremlinExecutor = gremlinExecutorSupplier.get();
@@ -241,6 +243,15 @@ protected void evalOpInternal(final Context ctx, final Supplier<GremlinExecutor>
                     final Iterator itty = IteratorUtils.asIterator(o);
 
                     logger.debug("Preparing to iterate results from - {} - in thread [{}]", msg, Thread.currentThread().getName());
+                    if (settings.enableAuditLog) {
+                        AuthenticatedUser user = ctx.getChannelHandlerContext().channel().attr(StateKey.AUTHENTICATED_USER).get();
+                        if (null == user) {    // This is expected when using the AllowAllAuthenticator
+                            user = AuthenticatedUser.ANONYMOUS_USER;
+                        }
+                        String address = ctx.getChannelHandlerContext().channel().remoteAddress().toString();
+                        if (address.startsWith("/") && address.length() > 1) address = address.substring(1);
+                        auditLogger.info("User {} with address {} requested: {}", user.getName(), address, script);
+                    }
                     if (settings.authentication.enableAuditLog) {
                         String address = ctx.getChannelHandlerContext().channel().remoteAddress().toString();
                         if (address.startsWith("/") && address.length() > 1) address = address.substring(1);
diff --git a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/op/traversal/TraversalOpProcessor.java b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/op/traversal/TraversalOpProcessor.java
index 8a36cd52ce5..1d969a88c99 100644
--- a/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/op/traversal/TraversalOpProcessor.java
+++ b/gremlin-server/src/main/java/org/apache/tinkerpop/gremlin/server/op/traversal/TraversalOpProcessor.java
@@ -36,6 +36,7 @@
 import org.apache.tinkerpop.gremlin.server.GremlinServer;
 import org.apache.tinkerpop.gremlin.server.OpProcessor;
 import org.apache.tinkerpop.gremlin.server.Settings;
+import org.apache.tinkerpop.gremlin.server.auth.AuthenticatedUser;
 import org.apache.tinkerpop.gremlin.server.handler.Frame;
 import org.apache.tinkerpop.gremlin.server.handler.StateKey;
 import org.apache.tinkerpop.gremlin.server.op.AbstractOpProcessor;
@@ -192,6 +193,15 @@ private void iterateBytecodeTraversal(final Context context) throws Exception {
                             .statusMessage(ex.getMessage())
                             .statusAttributeException(ex).create());
         }
+        if (settings.enableAuditLog) {
+            AuthenticatedUser user = context.getChannelHandlerContext().channel().attr(StateKey.AUTHENTICATED_USER).get();
+            if (null == user) {    // This is expected when using the AllowAllAuthenticator
+                user = AuthenticatedUser.ANONYMOUS_USER;
+            }
+            String address = context.getChannelHandlerContext().channel().remoteAddress().toString();
+            if (address.startsWith("/") && address.length() > 1) address = address.substring(1);
+            auditLogger.info("User {} with address {} requested: {}", user.getName(), address, bytecode);
+        }
         if (settings.authentication.enableAuditLog) {
             String address = context.getChannelHandlerContext().channel().remoteAddress().toString();
             if (address.startsWith("/") && address.length() > 1) address = address.substring(1);
diff --git a/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuditLogDeprecatedIntegrateTest.java b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuditLogDeprecatedIntegrateTest.java
new file mode 100644
index 00000000000..a9d7228ce8c
--- /dev/null
+++ b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuditLogDeprecatedIntegrateTest.java
@@ -0,0 +1,384 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.server;
+
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.util.EntityUtils;
+import org.apache.log4j.Logger;
+import org.apache.log4j.spi.LoggingEvent;
+import org.apache.tinkerpop.gremlin.driver.Client;
+import org.apache.tinkerpop.gremlin.driver.Cluster;
+import org.apache.tinkerpop.gremlin.driver.remote.DriverRemoteConnection;
+import org.apache.tinkerpop.gremlin.process.traversal.AnonymousTraversalSource;
+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
+import org.apache.tinkerpop.gremlin.server.auth.AllowAllAuthenticator;
+import org.apache.tinkerpop.gremlin.server.auth.AuthenticatedUser;
+import org.apache.tinkerpop.gremlin.server.auth.Krb5Authenticator;
+import org.apache.tinkerpop.gremlin.server.auth.SimpleAuthenticator;
+import org.apache.tinkerpop.gremlin.server.channel.HttpChannelizer;
+import org.apache.tinkerpop.gremlin.structure.io.graphson.GraphSONTokens;
+import org.apache.tinkerpop.gremlin.util.Log4jRecordingAppender;
+import org.apache.tinkerpop.shaded.jackson.databind.JsonNode;
+import org.apache.tinkerpop.shaded.jackson.databind.ObjectMapper;
+import org.junit.Test;
+import org.slf4j.LoggerFactory;
+
+import java.util.Base64;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Stream;
+
+import static org.apache.log4j.Level.INFO;
+import static org.apache.tinkerpop.gremlin.server.GremlinServer.AUDIT_LOGGER_NAME;
+import static org.apache.tinkerpop.gremlin.server.GremlinServerAuthKrb5IntegrateTest.TESTCONSOLE;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
+/**
+ * Test audit logs. Like other descendants of AbstractGremlinServerIntegrationTest this test suite assumes that
+ * tests are run sequentially and thus the server and kdcServer variables can be reused.
+ *
+ * @author Marc de Lignie
+ */
+public class GremlinServerAuditLogDeprecatedIntegrateTest extends AbstractGremlinServerIntegrationTest {
+    private static final org.slf4j.Logger logger = LoggerFactory.getLogger(GremlinServerAuditLogDeprecatedIntegrateTest.class);
+    private Log4jRecordingAppender recordingAppender = null;
+
+    private final ObjectMapper mapper = new ObjectMapper();
+    private final Base64.Encoder encoder = Base64.getUrlEncoder();
+
+    private static final boolean AUDIT_LOG_ENABLED = true;
+    private static final boolean AUDIT_LOG_DISABLED = false;
+    private static final String TESTCONSOLE2 = "GremlinConsole2";
+
+    private KdcFixture kdcServer;
+
+    @Override
+    public void setUp() throws Exception {
+        recordingAppender = new Log4jRecordingAppender();
+        final Logger rootLogger = Logger.getRootLogger();
+        rootLogger.addAppender(recordingAppender);
+
+        try {
+            final String moduleBaseDir = System.getProperty("basedir");
+            final String authConfigName = moduleBaseDir + "/src/test/resources/org/apache/tinkerpop/gremlin/server/gremlin-console-jaas.conf";
+            System.setProperty("java.security.auth.login.config", authConfigName);
+            kdcServer = new KdcFixture(moduleBaseDir);
+            kdcServer.setUp();
+        } catch(Exception e)  {
+            logger.warn(e.getMessage());
+        }
+        super.setUp();
+    }
+
+    @Override
+    public void tearDown() throws Exception {
+        super.tearDown();
+        final Logger rootLogger = Logger.getRootLogger();
+        rootLogger.removeAppender(recordingAppender);
+        kdcServer.close();
+        System.clearProperty("java.security.auth.login.config");
+        super.tearDown();
+    }
+
+    /**
+     * Configure specific Gremlin Server settings for specific tests.
+     */
+    @Override
+    public Settings overrideSettings(final Settings settings) {
+        settings.host = kdcServer.gremlinHostname;
+        final Settings.SslSettings sslConfig = new Settings.SslSettings();
+        sslConfig.enabled = false;
+        settings.ssl = sslConfig;
+        final Settings.AuthenticationSettings authSettings = new Settings.AuthenticationSettings();
+        settings.authentication = authSettings;
+        authSettings.enableAuditLog = AUDIT_LOG_ENABLED;
+        authSettings.authenticator = Krb5Authenticator.class.getName();
+        final Map<String,Object> authConfig = new HashMap<>();
+        authSettings.config = authConfig;
+
+        final String nameOfTest = name.getMethodName();
+        switch (nameOfTest) {
+            case "shouldAuditLogWithAllowAllAuthenticator":
+                authSettings.authenticator = AllowAllAuthenticator.class.getName();
+                break;
+            case "shouldAuditLogWithTraversalOp":
+            case "shouldAuditLogWithSimpleAuthenticator":
+                authSettings.authenticator = SimpleAuthenticator.class.getName();
+                authConfig.put(SimpleAuthenticator.CONFIG_CREDENTIALS_DB, "conf/tinkergraph-credentials.properties");
+                break;
+            case "shouldNotAuditLogWhenDisabled":
+                authSettings.enableAuditLog = AUDIT_LOG_DISABLED;
+            case "shouldAuditLogWithKrb5Authenticator":
+            case "shouldAuditLogTwoClientsWithKrb5Authenticator":
+                authConfig.put("keytab", kdcServer.serviceKeytabFile.getAbsolutePath());
+                authConfig.put("principal", kdcServer.serverPrincipal);
+                break;
+            case "shouldAuditLogWithHttpTransport":
+                settings.host = "localhost";
+                settings.channelizer = HttpChannelizer.class.getName();
+                authSettings.authenticator = SimpleAuthenticator.class.getName();
+                authConfig.put(SimpleAuthenticator.CONFIG_CREDENTIALS_DB, "conf/tinkergraph-credentials.properties");
+                break;
+        }
+        return settings;
+    }
+
+    @Test
+    public void shouldAuditLogWithAllowAllAuthenticator() throws Exception {
+
+        final Cluster cluster = TestClientFactory.build().addContactPoint(kdcServer.gremlinHostname).create();
+        final Client client = cluster.connect();
+
+        try {
+            assertEquals(2, client.submit("1+1").all().get().get(0).getInt());
+            assertEquals(3, client.submit("1+2").all().get().get(0).getInt());
+            assertEquals(4, client.submit("1+3").all().get().get(0).getInt());
+        } finally {
+            cluster.close();
+        }
+
+        // wait for logger to flush - (don't think there is a way to detect this)
+        stopServer();
+        Thread.sleep(1000);
+
+        // WebSocketChannelizer does not add SaslAuthenticationHandler for AllowAllAuthenticator,
+        // so no authenticated user log line available
+        assertTrue(recordingAppender.logMatchesAny(AUDIT_LOGGER_NAME, INFO, "User with address .+? requested: 1\\+1"));
+        assertTrue(recordingAppender.logMatchesAny(AUDIT_LOGGER_NAME, INFO, "User with address .+? requested: 1\\+2"));
+        assertTrue(recordingAppender.logMatchesAny(AUDIT_LOGGER_NAME, INFO, "User with address .+? requested: 1\\+3"));
+    }
+
+    @Test
+    public void shouldAuditLogWithSimpleAuthenticator() throws Exception {
+        final String username = "stephen";
+        final String password = "password";
+
+        final Cluster cluster = TestClientFactory.build().credentials(username, password)
+                .addContactPoint(kdcServer.gremlinHostname).create();
+        final Client client = cluster.connect();
+
+        try {
+            assertEquals(2, client.submit("1+1").all().get().get(0).getInt());
+            assertEquals(3, client.submit("1+2").all().get().get(0).getInt());
+            assertEquals(4, client.submit("1+3").all().get().get(0).getInt());
+            assertEquals(5, client.submit("1+4").all().get().get(0).getInt());
+        } finally {
+            cluster.close();
+        }
+
+        // wait for logger to flush - (don't think there is a way to detect this)
+        stopServer();
+        Thread.sleep(1000);
+
+        final String simpleAuthenticatorName = SimpleAuthenticator.class.getSimpleName();
+
+        final List<LoggingEvent> log = recordingAppender.getEvents();
+        final Stream<LoggingEvent> auditEvents = log.stream().filter(event -> event.getLoggerName().equals(AUDIT_LOGGER_NAME));
+        final LoggingEvent authEvent = auditEvents
+                .filter(event -> event.getMessage().toString().contains(simpleAuthenticatorName)).iterator().next();
+        final String authMsg = authEvent.getMessage().toString();
+        assertTrue(authEvent.getLevel() == INFO &&
+                authMsg.matches(String.format("User %s with address .+? authenticated by %s", username, simpleAuthenticatorName)));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 1\\+1")));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 1\\+2")));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 1\\+3")));
+    }
+
+    @Test
+    public void shouldAuditLogWithKrb5Authenticator() throws Exception {
+        final Cluster cluster = TestClientFactory.build().jaasEntry(TESTCONSOLE)
+                .protocol(kdcServer.serverPrincipalName).addContactPoint(kdcServer.gremlinHostname).create();
+        final Client client = cluster.connect();
+        try {
+            assertEquals(2, client.submit("1+1").all().get().get(0).getInt());
+            assertEquals(3, client.submit("1+2").all().get().get(0).getInt());
+            assertEquals(4, client.submit("1+3").all().get().get(0).getInt());
+        } finally {
+            cluster.close();
+        }
+
+        // wait for logger to flush - (don't think there is a way to detect this)
+        stopServer();
+        Thread.sleep(1000);
+
+        final List<LoggingEvent> log = recordingAppender.getEvents();
+        final Stream<LoggingEvent> auditEvents = log.stream().filter(event -> event.getLoggerName().equals(AUDIT_LOGGER_NAME));
+        final LoggingEvent authEvent = auditEvents
+                .filter(event -> event.getMessage().toString().contains("Krb5Authenticator")).iterator().next();
+        final String authMsg = authEvent.getMessage().toString();
+        assertTrue(authEvent.getLevel() == INFO &&
+                authMsg.matches(String.format("User %s with address .+? authenticated by Krb5Authenticator", kdcServer.clientPrincipalName)));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 1\\+1")));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 1\\+2")));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 1\\+3")));
+    }
+
+    @Test
+    public void shouldNotAuditLogWhenDisabled() throws Exception {
+        final Cluster cluster = TestClientFactory.build().jaasEntry(TESTCONSOLE)
+                .protocol(kdcServer.serverPrincipalName).addContactPoint(kdcServer.gremlinHostname).create();
+        final Client client = cluster.connect();
+        try {
+            assertEquals(2, client.submit("1+1").all().get().get(0).getInt());
+            assertEquals(3, client.submit("1+2").all().get().get(0).getInt());
+            assertEquals(4, client.submit("1+3").all().get().get(0).getInt());
+        } finally {
+            cluster.close();
+        }
+
+        // wait for logger to flush - (don't think there is a way to detect this)
+        stopServer();
+        Thread.sleep(1000);
+
+        final List<LoggingEvent> log = recordingAppender.getEvents();
+        assertFalse(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User drankye with address .+? authenticated by Krb5Authenticator")));
+        assertFalse(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 1\\+1")));
+        assertFalse(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 1\\+2")));
+        assertFalse(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+            item.getMessage().toString().matches("User with address .+? requested: 1\\+3")));
+    }
+
+    @Test
+    public void shouldAuditLogWithHttpTransport() throws Exception {
+        final CloseableHttpClient httpclient = HttpClients.createDefault();
+        final HttpGet httpget = new HttpGet(TestClientFactory.createURLString("?gremlin=1-1"));
+        httpget.addHeader("Authorization", "Basic " + encoder.encodeToString("stephen:password".getBytes()));
+
+        try (final CloseableHttpResponse response = httpclient.execute(httpget)) {
+            assertEquals(200, response.getStatusLine().getStatusCode());
+            assertEquals("application/json", response.getEntity().getContentType().getValue());
+            final String json = EntityUtils.toString(response.getEntity());
+            final JsonNode node = mapper.readTree(json);
+            assertEquals(0, node.get("result").get("data").get(GraphSONTokens.VALUEPROP).get(0).intValue());
+        }
+
+        // wait for logger to flush - (don't think there is a way to detect this)
+        stopServer();
+        Thread.sleep(1000);
+
+        final String simpleAuthenticatorName = SimpleAuthenticator.class.getSimpleName();
+
+        final List<LoggingEvent> log = recordingAppender.getEvents();
+        final Stream<LoggingEvent> auditEvents = log.stream().filter(event -> event.getLoggerName().equals(AUDIT_LOGGER_NAME));
+        final LoggingEvent authEvent = auditEvents
+                .filter(event -> event.getMessage().toString().contains(simpleAuthenticatorName)).iterator().next();
+        final String authMsg = authEvent.getMessage().toString();
+        assertTrue(authEvent.getLevel() == INFO &&
+                authMsg.matches(String.format("User stephen with address .+? authenticated by %s", simpleAuthenticatorName)));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 1-1")));
+    }
+
+    @Test
+    public void shouldAuditLogWithTraversalOp() throws Exception {
+        final String username = "stephen";
+        final String password = "password";
+
+        final Cluster cluster = TestClientFactory.build().credentials(username, password)
+                .addContactPoint(kdcServer.gremlinHostname).create();
+        final Client client = cluster.connect();
+        final GraphTraversalSource g = AnonymousTraversalSource.traversal().
+                withRemote(DriverRemoteConnection.using(cluster, "gmodern"));
+
+        try {
+            assertEquals(6, g.V().count().next().intValue());
+        } finally {
+            cluster.close();
+        }
+
+        // wait for logger to flush - (don't think there is a way to detect this)
+        stopServer();
+        Thread.sleep(1000);
+
+        final String simpleAuthenticatorName = SimpleAuthenticator.class.getSimpleName();
+
+        final List<LoggingEvent> log = recordingAppender.getEvents();
+        final Stream<LoggingEvent> auditEvents = log.stream().filter(event -> event.getLoggerName().equals(AUDIT_LOGGER_NAME));
+        final LoggingEvent authEvent = auditEvents
+                .filter(event -> event.getMessage().toString().contains(simpleAuthenticatorName)).iterator().next();
+        final String authMsg = authEvent.getMessage().toString();
+        assertTrue(authEvent.getLevel() == INFO &&
+                authMsg.matches(String.format("User %s with address .+? authenticated by %s", username, simpleAuthenticatorName)));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: \\[\\[], \\[V\\(\\), count\\(\\)]]")));
+    }
+
+    @Test
+    public void shouldAuditLogTwoClientsWithKrb5Authenticator() throws Exception {
+        final Cluster cluster = TestClientFactory.build().jaasEntry(TESTCONSOLE)
+                .protocol(kdcServer.serverPrincipalName).addContactPoint(kdcServer.gremlinHostname).create();
+        final Client client = cluster.connect();
+        final Cluster cluster2 = TestClientFactory.build().jaasEntry(TESTCONSOLE2)
+                .protocol(kdcServer.serverPrincipalName).addContactPoint(kdcServer.gremlinHostname).create();
+        final Client client2 = cluster2.connect();
+        try {
+            assertEquals(2, client.submit("1+1").all().get().get(0).getInt());
+            assertEquals(22, client2.submit("11+11").all().get().get(0).getInt());
+            assertEquals(3, client.submit("1+2").all().get().get(0).getInt());
+            assertEquals(23, client2.submit("11+12").all().get().get(0).getInt());
+            assertEquals(24, client2.submit("11+13").all().get().get(0).getInt());
+            assertEquals(4, client.submit("1+3").all().get().get(0).getInt());
+        } finally {
+            cluster.close();
+            cluster2.close();
+        }
+
+        // wait for logger to flush - (don't think there is a way to detect this)
+        stopServer();
+        Thread.sleep(1000);
+
+        final List<LoggingEvent> log = recordingAppender.getEvents();
+        final Stream<LoggingEvent> auditEvents = log.stream().filter(event -> event.getLoggerName().equals(AUDIT_LOGGER_NAME));
+        final LoggingEvent authEvent = auditEvents
+                .filter(event -> event.getMessage().toString().contains("Krb5Authenticator")).iterator().next();
+        final String authMsg = authEvent.getMessage().toString();
+        assertTrue(authEvent.getLevel() == INFO &&
+                authMsg.matches(String.format("User %s with address .+? authenticated by Krb5Authenticator", kdcServer.clientPrincipalName)));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 1\\+1")));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 1\\+2")));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 1\\+3")));
+
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches(String.format("User %s with address .+? authenticated by Krb5Authenticator", kdcServer.clientPrincipalName2))));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 11\\+11")));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 11\\+12")));
+        assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
+                item.getMessage().toString().matches("User with address .+? requested: 11\\+13")));
+    }
+}
\ No newline at end of file
diff --git a/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuditLogIntegrateTest.java b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuditLogIntegrateTest.java
index 4843c6c9530..1955fa0067d 100644
--- a/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuditLogIntegrateTest.java
+++ b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuditLogIntegrateTest.java
@@ -31,6 +31,7 @@
 import org.apache.tinkerpop.gremlin.process.traversal.AnonymousTraversalSource;
 import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
 import org.apache.tinkerpop.gremlin.server.auth.AllowAllAuthenticator;
+import org.apache.tinkerpop.gremlin.server.auth.AuthenticatedUser;
 import org.apache.tinkerpop.gremlin.server.auth.Krb5Authenticator;
 import org.apache.tinkerpop.gremlin.server.auth.SimpleAuthenticator;
 import org.apache.tinkerpop.gremlin.server.channel.HttpChannelizer;
@@ -55,7 +56,7 @@
 import static org.junit.Assert.assertTrue;
 
 /**
- * Test audit logs  and like other descendants of AbstractGremlinServerIntegrationTest this test suite assumes that
+ * Test audit logs. Like other descendants of AbstractGremlinServerIntegrationTest this test suite assumes that
  * tests are run sequentially and thus the server and kdcServer variables can be reused.
  *
  * @author Marc de Lignie
@@ -112,7 +113,7 @@ public Settings overrideSettings(final Settings settings) {
         settings.ssl = sslConfig;
         final Settings.AuthenticationSettings authSettings = new Settings.AuthenticationSettings();
         settings.authentication = authSettings;
-        authSettings.enableAuditLog = AUDIT_LOG_ENABLED;
+        settings.enableAuditLog = AUDIT_LOG_ENABLED;
         authSettings.authenticator = Krb5Authenticator.class.getName();
         final Map<String,Object> authConfig = new HashMap<>();
         authSettings.config = authConfig;
@@ -128,7 +129,7 @@ public Settings overrideSettings(final Settings settings) {
                 authConfig.put(SimpleAuthenticator.CONFIG_CREDENTIALS_DB, "conf/tinkergraph-credentials.properties");
                 break;
             case "shouldNotAuditLogWhenDisabled":
-                authSettings.enableAuditLog = AUDIT_LOG_DISABLED;
+                settings.enableAuditLog = AUDIT_LOG_DISABLED;
             case "shouldAuditLogWithKrb5Authenticator":
             case "shouldAuditLogTwoClientsWithKrb5Authenticator":
                 authConfig.put("keytab", kdcServer.serviceKeytabFile.getAbsolutePath());
@@ -164,9 +165,12 @@ public void shouldAuditLogWithAllowAllAuthenticator() throws Exception {
 
         // WebSocketChannelizer does not add SaslAuthenticationHandler for AllowAllAuthenticator,
         // so no authenticated user log line available
-        assertTrue(recordingAppender.logMatchesAny(AUDIT_LOGGER_NAME, INFO, "User with address .*? requested: 1\\+1"));
-        assertTrue(recordingAppender.logMatchesAny(AUDIT_LOGGER_NAME, INFO, "User with address .*? requested: 1\\+2"));
-        assertTrue(recordingAppender.logMatchesAny(AUDIT_LOGGER_NAME, INFO, "User with address .*? requested: 1\\+3"));
+        assertTrue(recordingAppender.logMatchesAny(AUDIT_LOGGER_NAME, INFO, String.format(
+                "User %s with address .+? requested: 1\\+1", AuthenticatedUser.ANONYMOUS_USERNAME)));
+        assertTrue(recordingAppender.logMatchesAny(AUDIT_LOGGER_NAME, INFO, String.format(
+                "User %s with address .+? requested: 1\\+2", AuthenticatedUser.ANONYMOUS_USERNAME)));
+        assertTrue(recordingAppender.logMatchesAny(AUDIT_LOGGER_NAME, INFO, String.format(
+                "User %s with address .+? requested: 1\\+3", AuthenticatedUser.ANONYMOUS_USERNAME)));
     }
 
     @Test
@@ -199,13 +203,13 @@ public void shouldAuditLogWithSimpleAuthenticator() throws Exception {
                 .filter(event -> event.getMessage().toString().contains(simpleAuthenticatorName)).iterator().next();
         final String authMsg = authEvent.getMessage().toString();
         assertTrue(authEvent.getLevel() == INFO &&
-                authMsg.matches(String.format("User %s with address .*? authenticated by %s", username, simpleAuthenticatorName)));
+                authMsg.matches(String.format("User %s with address .+? authenticated by %s", username, simpleAuthenticatorName)));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 1\\+1")));
+                item.getMessage().toString().matches("User stephen with address .+? requested: 1\\+1")));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 1\\+2")));
+                item.getMessage().toString().matches("User stephen with address .+? requested: 1\\+2")));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 1\\+3")));
+                item.getMessage().toString().matches("User stephen with address .+? requested: 1\\+3")));
     }
 
     @Test
@@ -231,13 +235,13 @@ public void shouldAuditLogWithKrb5Authenticator() throws Exception {
                 .filter(event -> event.getMessage().toString().contains("Krb5Authenticator")).iterator().next();
         final String authMsg = authEvent.getMessage().toString();
         assertTrue(authEvent.getLevel() == INFO &&
-                authMsg.matches(String.format("User %s with address .*? authenticated by Krb5Authenticator", kdcServer.clientPrincipalName)));
+                authMsg.matches(String.format("User %s with address .+? authenticated by Krb5Authenticator", kdcServer.clientPrincipalName)));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 1\\+1")));
+                item.getMessage().toString().matches("User drankye with address .+? requested: 1\\+1")));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 1\\+2")));
+                item.getMessage().toString().matches("User drankye with address .+? requested: 1\\+2")));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 1\\+3")));
+                item.getMessage().toString().matches("User drankye with address .+? requested: 1\\+3")));
     }
 
     @Test
@@ -259,13 +263,13 @@ public void shouldNotAuditLogWhenDisabled() throws Exception {
 
         final List<LoggingEvent> log = recordingAppender.getEvents();
         assertFalse(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User .*? with address .*? authenticated by Krb5Authenticator")));
+                item.getMessage().toString().matches("User drankye with address .+? authenticated by Krb5Authenticator")));
         assertFalse(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 1\\+1")));
+                item.getMessage().toString().matches("User drankye with address .+? requested: 1\\+1")));
         assertFalse(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 1\\+2")));
+                item.getMessage().toString().matches("User drankye with address .+? requested: 1\\+2")));
         assertFalse(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-            item.getMessage().toString().matches("User with address .*? requested: 1\\+3")));
+            item.getMessage().toString().matches("User drankye with address .+? requested: 1\\+3")));
     }
 
     @Test
@@ -294,9 +298,9 @@ public void shouldAuditLogWithHttpTransport() throws Exception {
                 .filter(event -> event.getMessage().toString().contains(simpleAuthenticatorName)).iterator().next();
         final String authMsg = authEvent.getMessage().toString();
         assertTrue(authEvent.getLevel() == INFO &&
-                authMsg.matches(String.format("User %s with address .*? authenticated by %s", "stephen", simpleAuthenticatorName)));
+                authMsg.matches(String.format("User stephen with address .+? authenticated by %s", simpleAuthenticatorName)));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 1-1")));
+                item.getMessage().toString().matches("User stephen with address .+? requested: 1-1")));
     }
 
     @Test
@@ -306,7 +310,6 @@ public void shouldAuditLogWithTraversalOp() throws Exception {
 
         final Cluster cluster = TestClientFactory.build().credentials(username, password)
                 .addContactPoint(kdcServer.gremlinHostname).create();
-        final Client client = cluster.connect();
         final GraphTraversalSource g = AnonymousTraversalSource.traversal().
                 withRemote(DriverRemoteConnection.using(cluster, "gmodern"));
 
@@ -328,9 +331,9 @@ public void shouldAuditLogWithTraversalOp() throws Exception {
                 .filter(event -> event.getMessage().toString().contains(simpleAuthenticatorName)).iterator().next();
         final String authMsg = authEvent.getMessage().toString();
         assertTrue(authEvent.getLevel() == INFO &&
-                authMsg.matches(String.format("User %s with address .*? authenticated by %s", username, simpleAuthenticatorName)));
+                authMsg.matches(String.format("User %s with address .+? authenticated by %s", username, simpleAuthenticatorName)));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: \\[\\[], \\[V\\(\\), count\\(\\)]]")));
+                item.getMessage().toString().matches("User .+? with address .+? requested: \\[\\[], \\[V\\(\\), count\\(\\)]]")));
     }
 
     @Test
@@ -363,21 +366,21 @@ public void shouldAuditLogTwoClientsWithKrb5Authenticator() throws Exception {
                 .filter(event -> event.getMessage().toString().contains("Krb5Authenticator")).iterator().next();
         final String authMsg = authEvent.getMessage().toString();
         assertTrue(authEvent.getLevel() == INFO &&
-                authMsg.matches(String.format("User %s with address .*? authenticated by Krb5Authenticator", kdcServer.clientPrincipalName)));
+                authMsg.matches(String.format("User %s with address .+? authenticated by Krb5Authenticator", kdcServer.clientPrincipalName)));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 1\\+1")));
+                item.getMessage().toString().matches("User drankye with address .+? requested: 1\\+1")));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 1\\+2")));
+                item.getMessage().toString().matches("User drankye with address .+? requested: 1\\+2")));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 1\\+3")));
+                item.getMessage().toString().matches("User drankye with address .+? requested: 1\\+3")));
 
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches(String.format("User %s with address .*? authenticated by Krb5Authenticator", kdcServer.clientPrincipalName2))));
+                item.getMessage().toString().matches(String.format("User %s with address .+? authenticated by Krb5Authenticator", kdcServer.clientPrincipalName2))));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 11\\+11")));
+                item.getMessage().toString().matches("User drankye2 with address .+? requested: 11\\+11")));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 11\\+12")));
+                item.getMessage().toString().matches("User drankye2 with address .+? requested: 11\\+12")));
         assertTrue(log.stream().anyMatch(item -> item.getLevel() == INFO &&
-                item.getMessage().toString().matches("User with address .*? requested: 11\\+13")));
+                item.getMessage().toString().matches("User drankye2 with address .+? requested: 11\\+13")));
     }
 }
\ No newline at end of file
diff --git a/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuthIntegrateTest.java b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuthIntegrateTest.java
index 807e9a787cd..0895ff64154 100644
--- a/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuthIntegrateTest.java
+++ b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuthIntegrateTest.java
@@ -56,7 +56,7 @@ public Settings overrideSettings(final Settings settings) {
         final Settings.AuthenticationSettings authSettings = new Settings.AuthenticationSettings();
         authSettings.authenticator = SimpleAuthenticator.class.getName();
 
-        // use a credentials graph with one user in it: stephen/password
+        // use a credentials graph with two users in it: stephen/password and marko/rainbow-dash
         final Map<String,Object> authConfig = new HashMap<>();
         authConfig.put(SimpleAuthenticator.CONFIG_CREDENTIALS_DB, "conf/tinkergraph-credentials.properties");
 
diff --git a/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuthzIntegrateTest.java b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuthzIntegrateTest.java
new file mode 100644
index 00000000000..5614123f14f
--- /dev/null
+++ b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerAuthzIntegrateTest.java
@@ -0,0 +1,386 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.server;
+
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpGet;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.util.EntityUtils;
+import org.apache.log4j.Logger;
+import org.apache.tinkerpop.gremlin.driver.Client;
+import org.apache.tinkerpop.gremlin.driver.Cluster;
+import org.apache.tinkerpop.gremlin.driver.exception.ResponseException;
+import org.apache.tinkerpop.gremlin.driver.message.ResponseStatusCode;
+import org.apache.tinkerpop.gremlin.driver.remote.DriverRemoteConnection;
+import org.apache.tinkerpop.gremlin.process.traversal.AnonymousTraversalSource;
+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
+import org.apache.tinkerpop.gremlin.server.auth.AllowAllAuthenticator;
+import org.apache.tinkerpop.gremlin.server.auth.SimpleAuthenticator;
+import org.apache.tinkerpop.gremlin.server.authz.AllowListAuthorizer;
+import org.apache.tinkerpop.gremlin.server.channel.HttpChannelizer;
+import org.apache.tinkerpop.gremlin.structure.io.graphson.GraphSONTokens;
+import org.apache.tinkerpop.gremlin.util.Log4jRecordingAppender;
+import org.apache.tinkerpop.gremlin.util.function.Lambda;
+import org.apache.tinkerpop.shaded.jackson.databind.JsonNode;
+import org.apache.tinkerpop.shaded.jackson.databind.ObjectMapper;
+import org.junit.Test;
+
+import java.util.Base64;
+import java.util.HashMap;
+import java.util.Objects;
+
+import static org.apache.log4j.Level.INFO;
+import static org.apache.tinkerpop.gremlin.server.GremlinServer.AUDIT_LOGGER_NAME;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
+/**
+ * Run with:
+ * mvn verify -Dit.test=GremlinServerAuthzIntegrateTest -pl gremlin-server -DskipTests -DskipIntegrationTests=false -Dmaven.javadoc.skip=true -Dorg.slf4j.simpleLogger.defaultLogLevel=info
+ *
+ * @author Marc de Lignie
+ */
+public class GremlinServerAuthzIntegrateTest extends AbstractGremlinServerIntegrationTest {
+
+    private Log4jRecordingAppender recordingAppender;
+    private final ObjectMapper mapper = new ObjectMapper();
+    private final Base64.Encoder encoder = Base64.getUrlEncoder();
+
+    @Override
+    public void setUp() throws Exception {
+        recordingAppender = new Log4jRecordingAppender();
+        final Logger rootLogger = Logger.getRootLogger();
+        rootLogger.addAppender(recordingAppender);
+        super.setUp();
+    }
+
+    @Override
+    public void tearDown() throws Exception {
+        super.tearDown();
+        final Logger rootLogger = Logger.getRootLogger();
+        rootLogger.removeAppender(recordingAppender);
+        super.tearDown();
+    }
+
+    /**
+     * Configure Gremlin Server settings per test.
+     */
+    @Override
+    public Settings overrideSettings(final Settings settings) {
+        final Settings.SslSettings sslConfig = new Settings.SslSettings();
+        sslConfig.enabled = false;
+
+        final Settings.AuthenticationSettings authSettings = new Settings.AuthenticationSettings();
+        authSettings.config = new HashMap<>();
+        authSettings.authenticator = SimpleAuthenticator.class.getName();
+        authSettings.config.put(SimpleAuthenticator.CONFIG_CREDENTIALS_DB, "conf/tinkergraph-credentials.properties");
+
+        final Settings.AuthorizationSettings authzSettings = new Settings.AuthorizationSettings();
+        authzSettings.authorizer = AllowListAuthorizer.class.getName();
+        authzSettings.config = new HashMap<>();
+        final String yamlName = "org/apache/tinkerpop/gremlin/server/allow-list.yaml";
+        final String yamlHttpName = "org/apache/tinkerpop/gremlin/server/allow-list-http-anonymous.yaml";
+        final String file = Objects.requireNonNull(getClass().getClassLoader().getResource(yamlName)).getFile();
+        authzSettings.config.put(AllowListAuthorizer.KEY_AUTHORIZATION_ALLOWLIST, file);
+
+        settings.ssl = sslConfig;
+        settings.authentication = authSettings;
+        settings.authorization = authzSettings;
+        settings.enableAuditLog = true;
+
+        final String nameOfTest = name.getMethodName();
+        switch (nameOfTest) {
+            case "shouldFailBytecodeRequestWithAllowAllAuthenticator":
+            case "shouldFailStringRequestWithAllowAllAuthenticator":
+                authSettings.authenticator = AllowAllAuthenticator.class.getName();
+                break;
+            case "shouldAuthorizeWithHttpTransport":
+            case "shouldFailAuthorizeWithHttpTransport":
+            case "shouldKeepAuthorizingWithHttpTransport":
+                settings.channelizer = HttpChannelizer.class.getName();
+                break;
+            case "shouldAuthorizeWithAllowAllAuthenticatorAndHttpTransport":
+                settings.channelizer = HttpChannelizer.class.getName();
+                authSettings.authenticator = AllowAllAuthenticator.class.getName();
+                authSettings.config = null;
+                final String fileHttp = Objects.requireNonNull(getClass().getClassLoader().getResource(yamlHttpName)).getFile();
+                authzSettings.config.put(AllowListAuthorizer.KEY_AUTHORIZATION_ALLOWLIST, fileHttp);
+                break;
+        }
+        return settings;
+    }
+
+    @Test
+    public void shouldAuthorizeBytecodeRequest() {
+        final Cluster cluster = TestClientFactory.build().credentials("stephen", "password").create();
+        final GraphTraversalSource g = AnonymousTraversalSource.traversal().withRemote(
+                DriverRemoteConnection.using(cluster, "gmodern"));
+
+        try {
+            assertEquals(6, (long) g.V().count().next());
+        } finally {
+            cluster.close();
+        }
+    }
+
+    @Test
+    public void shouldAuthorizeBytecodeRequestWithLambda() {
+        final Cluster cluster = TestClientFactory.build().credentials("marko", "rainbow-dash").create();
+        final GraphTraversalSource g = AnonymousTraversalSource.traversal().withRemote(
+                DriverRemoteConnection.using(cluster, "gclassic"));
+
+        try {
+            assertEquals(6, (long) g.V().count().next());
+            assertEquals(6, (long) g.V().map(Lambda.function("it.get().value('name')")).count().next());
+        } finally {
+            cluster.close();
+        }
+    }
+
+    @Test
+    public void shouldFailBytecodeRequestWithLambda() throws Exception{
+        final Cluster cluster = TestClientFactory.build().credentials("stephen", "password").create();
+        final GraphTraversalSource g = AnonymousTraversalSource.traversal().withRemote(
+                DriverRemoteConnection.using(cluster, "gmodern"));
+
+        try {
+            g.V().map(Lambda.function("it.get().value('name')")).count().next();
+            fail("Authorization for bytecode request with lambda should fail");
+        } catch (Exception ex) {
+            final ResponseException re = (ResponseException) ex.getCause();
+            assertEquals(ResponseStatusCode.UNAUTHORIZED, re.getResponseStatusCode());
+            assertEquals("Failed to authorize: User not authorized for bytecode requests on [gmodern] using lambdas.", re.getMessage());
+
+            // wait for logger to flush - (don't think there is a way to detect this)
+            stopServer();
+            Thread.sleep(1000);
+
+            assertTrue(recordingAppender.logMatchesAny(AUDIT_LOGGER_NAME, INFO,
+                    "User stephen with address .+? attempted an unauthorized request for bytecode operation: " +
+                            "\\[\\[], \\[V\\(\\), map\\(lambda\\[it.get\\(\\).value\\('name'\\)]\\), count\\(\\)]]"));
+        } finally {
+            cluster.close();
+        }
+    }
+
+    @Test
+    public void shouldKeepAuthorizingBytecodeRequests() {
+        final Cluster cluster = TestClientFactory.build().credentials("stephen", "password").create();
+        final GraphTraversalSource g = AnonymousTraversalSource.traversal().withRemote(
+                DriverRemoteConnection.using(cluster, "gmodern"));
+
+        try {
+            assertEquals(6, (long) g.V().count().next());
+            try {
+                g.V().map(Lambda.function("it.get().value('name')")).count().next();
+                fail("Authorization for bytecode request with lambda should fail");
+            } catch (Exception ex) {
+                final ResponseException re = (ResponseException) ex.getCause();
+                assertEquals(ResponseStatusCode.UNAUTHORIZED, re.getResponseStatusCode());
+                assertEquals("Failed to authorize: User not authorized for bytecode requests on [gmodern] using lambdas.", re.getMessage());
+            }
+            assertEquals(6, (long) g.V().count().next());
+        } finally {
+            cluster.close();
+        }
+    }
+
+    @Test
+    public void shouldAuthorizeStringRequest() throws Exception {
+        final Cluster cluster = TestClientFactory.build().credentials("marko", "rainbow-dash").create();
+        final Client client = cluster.connect();
+
+        try {
+            assertEquals(2, client.submit("1+1").all().get().get(0).getInt());
+            assertEquals(6, client.submit("gclassic.V().count()").all().get().get(0).getInt());
+            assertEquals(6, client.submit("gmodern.V().map{it.get().value('name')}.count()").all().get().get(0).getInt());
+        } finally {
+            cluster.close();
+        }
+    }
+
+    @Test
+    public void shouldFailStringRequestWithGroovyScript() throws Exception {
+        final Cluster cluster = TestClientFactory.build().credentials("stephen", "password").create();
+        final Client client = cluster.connect();
+
+        try {
+            client.submit("1+1").all().get();
+            fail("Authorization without authentication should fail");
+        } catch (Exception ex) {
+            final ResponseException re = (ResponseException) ex.getCause();
+            assertEquals(ResponseStatusCode.UNAUTHORIZED, re.getResponseStatusCode());
+            assertEquals("Failed to authorize: User not authorized for string-based requests.", re.getMessage());
+
+            // wait for logger to flush - (don't think there is a way to detect this)
+            stopServer();
+            Thread.sleep(1000);
+
+            assertTrue(recordingAppender.logMatchesAny(AUDIT_LOGGER_NAME, INFO,
+                    "User stephen with address .+? attempted an unauthorized request for eval operation: 1\\+1"));
+        } finally {
+            cluster.close();
+        }
+    }
+
+    @Test
+    public void shouldFailStringRequestWithGremlinTraversal() {
+        final Cluster cluster = TestClientFactory.build().credentials("stephen", "password").create();
+        final Client client = cluster.connect();
+
+        try {
+            client.submit("gmodern.V().count()").all().get();
+            fail("Authorization without authentication should fail");
+        } catch (Exception ex) {
+            final ResponseException re = (ResponseException) ex.getCause();
+            assertEquals(ResponseStatusCode.UNAUTHORIZED, re.getResponseStatusCode());
+            assertEquals("Failed to authorize: User not authorized for string-based requests.", re.getMessage());
+        } finally {
+            cluster.close();
+        }
+    }
+
+    @Test
+    public void shouldAuthorizeSessionedStringRequest() throws Exception {
+        final Cluster cluster = TestClientFactory.build().credentials("marko", "rainbow-dash").create();
+        final Client client = cluster.connect("session1");
+
+        try {
+            assertEquals(2, client.submit("a = 4; 1+1").all().get().get(0).getInt());
+            assertEquals(10, client.submit("gclassic.V().count().next() + a").all().get().get(0).getInt());
+            assertEquals(6, client.submit("gmodern.V().map{it.get().value('name')}.count()").all().get().get(0).getInt());
+        } finally {
+            cluster.close();
+        }
+    }
+
+    @Test
+    public void shouldFailBytecodeRequestWithAllowAllAuthenticator() {
+        final Cluster cluster = TestClientFactory.build().create();
+        try {
+            final GraphTraversalSource g = AnonymousTraversalSource.traversal().withRemote(
+                    DriverRemoteConnection.using(cluster, "gclassic"));
+            g.V().count().next();
+            fail("Authorization without authentication should fail");
+        } catch (Exception ex) {
+            final ResponseException re = (ResponseException) ex.getCause();
+            assertEquals(ResponseStatusCode.UNAUTHORIZED, re.getResponseStatusCode());
+            assertEquals("Failed to authorize: User not authorized for bytecode requests on [gclassic].", re.getMessage());
+        } finally {
+            cluster.close();
+        }
+    }
+
+    @Test
+    public void shouldFailStringRequestWithAllowAllAuthenticator() {
+        final Cluster cluster = TestClientFactory.build().create();
+        final Client client = cluster.connect();
+
+        try {
+            client.submit("1+1").all().get();
+            fail("Authorization without authentication should fail");
+        } catch (Exception ex) {
+            final ResponseException re = (ResponseException) ex.getCause();
+            assertEquals(ResponseStatusCode.UNAUTHORIZED, re.getResponseStatusCode());
+            assertEquals("Failed to authorize: User not authorized for string-based requests.", re.getMessage());
+        } finally {
+            cluster.close();
+        }
+    }
+
+    @Test
+    public void shouldAuthorizeWithHttpTransport() throws Exception {
+        final CloseableHttpClient httpclient = HttpClients.createDefault();
+        final HttpGet httpget = new HttpGet(TestClientFactory.createURLString("?gremlin=2-1"));
+        httpget.addHeader("Authorization", "Basic " + encoder.encodeToString("marko:rainbow-dash".getBytes()));
+
+        try (final CloseableHttpResponse response = httpclient.execute(httpget)) {
+            assertEquals(200, response.getStatusLine().getStatusCode());
+            assertEquals("application/json", response.getEntity().getContentType().getValue());
+            final String json = EntityUtils.toString(response.getEntity());
+            final JsonNode node = mapper.readTree(json);
+            assertEquals(1, node.get("result").get("data").get(GraphSONTokens.VALUEPROP).get(0).get(GraphSONTokens.VALUEPROP).intValue());
+        }
+    }
+
+    @Test
+    public void shouldFailAuthorizeWithHttpTransport() throws Exception {
+        final CloseableHttpClient httpclient = HttpClients.createDefault();
+        final HttpGet httpget = new HttpGet(TestClientFactory.createURLString("?gremlin=3-1"));
+        httpget.addHeader("Authorization", "Basic " + encoder.encodeToString("stephen:password".getBytes()));
+
+        try (final CloseableHttpResponse response = httpclient.execute(httpget)) {
+            assertEquals(401, response.getStatusLine().getStatusCode());
+        }
+        // wait for logger to flush - (don't think there is a way to detect this)
+        stopServer();
+        Thread.sleep(1000);
+
+        assertTrue(recordingAppender.logMatchesAny(AUDIT_LOGGER_NAME, INFO,
+                "User stephen with address .+? attempted an unauthorized http request: 3-1"));
+    }
+
+    @Test
+    public void shouldKeepAuthorizingWithHttpTransport() throws Exception {
+        HttpGet httpget;
+        final CloseableHttpClient httpclient = HttpClients.createDefault();
+
+        httpget = new HttpGet(TestClientFactory.createURLString("?gremlin=4-1"));
+        httpget.addHeader("Authorization", "Basic " + encoder.encodeToString("marko:rainbow-dash".getBytes()));
+        try (final CloseableHttpResponse response = httpclient.execute(httpget)) {
+            assertEquals(200, response.getStatusLine().getStatusCode());
+            assertEquals("application/json", response.getEntity().getContentType().getValue());
+            final String json = EntityUtils.toString(response.getEntity());
+            final JsonNode node = mapper.readTree(json);
+            assertEquals(3, node.get("result").get("data").get(GraphSONTokens.VALUEPROP).get(0).get(GraphSONTokens.VALUEPROP).intValue());
+        }
+
+        httpget = new HttpGet(TestClientFactory.createURLString("?gremlin=5-1"));
+        httpget.addHeader("Authorization", "Basic " + encoder.encodeToString("stephen:password".getBytes()));
+        try (final CloseableHttpResponse response = httpclient.execute(httpget)) {
+            assertEquals(401, response.getStatusLine().getStatusCode());
+        }
+
+        httpget = new HttpGet(TestClientFactory.createURLString("?gremlin=6-1"));
+        httpget.addHeader("Authorization", "Basic " + encoder.encodeToString("marko:rainbow-dash".getBytes()));
+        try (final CloseableHttpResponse response = httpclient.execute(httpget)) {
+            assertEquals(200, response.getStatusLine().getStatusCode());
+            assertEquals("application/json", response.getEntity().getContentType().getValue());
+            final String json = EntityUtils.toString(response.getEntity());
+            final JsonNode node = mapper.readTree(json);
+            assertEquals(5, node.get("result").get("data").get(GraphSONTokens.VALUEPROP).get(0).get(GraphSONTokens.VALUEPROP).intValue());
+        }
+    }
+
+    @Test
+    public void shouldAuthorizeWithAllowAllAuthenticatorAndHttpTransport() throws Exception {
+        final CloseableHttpClient httpclient = HttpClients.createDefault();
+        final HttpGet httpget = new HttpGet(TestClientFactory.createURLString("?gremlin=7-1"));
+
+        try (final CloseableHttpResponse response = httpclient.execute(httpget)) {
+            assertEquals(200, response.getStatusLine().getStatusCode());
+            assertEquals("application/json", response.getEntity().getContentType().getValue());
+            final String json = EntityUtils.toString(response.getEntity());
+            final JsonNode node = mapper.readTree(json);
+            assertEquals(6, node.get("result").get("data").get(GraphSONTokens.VALUEPROP).get(0).get(GraphSONTokens.VALUEPROP).intValue());
+        }
+    }
+}
diff --git a/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerHttpIntegrateTest.java b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerHttpIntegrateTest.java
index f34b0f2c8eb..eb7060c0860 100644
--- a/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerHttpIntegrateTest.java
+++ b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/GremlinServerHttpIntegrateTest.java
@@ -44,13 +44,11 @@
 import java.io.File;
 import java.time.Instant;
 import java.util.Base64;
-import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
 import static org.hamcrest.MatcherAssert.assertThat;
 import static org.hamcrest.core.StringContains.containsString;
-import static org.hamcrest.core.StringStartsWith.startsWith;
 import static org.junit.Assert.assertEquals;
 
 /**
@@ -136,7 +134,7 @@ private void configureForAuthentication(final Settings settings) {
         final Settings.AuthenticationSettings authSettings = new Settings.AuthenticationSettings();
         authSettings.authenticator = SimpleAuthenticator.class.getName();
 
-        // use a credentials graph with one user in it: stephen/password
+        // use a credentials graph with two users in it: stephen/password and marko/rainbow-dash
         final Map<String,Object> authConfig = new HashMap<>();
         authConfig.put(SimpleAuthenticator.CONFIG_CREDENTIALS_DB, "conf/tinkergraph-credentials.properties");
 
@@ -151,7 +149,7 @@ private void configureForAuthenticationWithHandlerClass(final Settings settings)
         //Add basic auth handler to make sure the reflection code path works.
         authSettings.authenticationHandler = HttpBasicAuthenticationHandler.class.getName();
 
-        // use a credentials graph with one user in it: stephen/password
+        // use a credentials graph with two users in it: stephen/password and marko/rainbow-dash
         final Map<String,Object> authConfig = new HashMap<>();
         authConfig.put(SimpleAuthenticator.CONFIG_CREDENTIALS_DB, "conf/tinkergraph-credentials.properties");
 
diff --git a/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/authz/AllowList.java b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/authz/AllowList.java
new file mode 100644
index 00000000000..2d9d5094372
--- /dev/null
+++ b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/authz/AllowList.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.server.authz;
+
+import org.yaml.snakeyaml.TypeDescription;
+import org.yaml.snakeyaml.Yaml;
+import org.yaml.snakeyaml.constructor.Constructor;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+
+
+/**
+ * AllowList for the AllowListAuthorizer as configured by a YAML file.
+ *
+ * @author Marc de Lignie
+ */
+public class AllowList {
+
+    /**
+     * Holds lists of groups by grant. A grant is either a TraversalSource name or the "sandbox" value. With the
+     * sandbox grant users can access all TraversalSource instances and execute groovy scripts as string based
+     * requests or as lambda functions, only limited by Gremlin Server's sandbox definition.
+     */
+    public Map<String, List<String>> grants;
+
+    /**
+     * Holds lists of user names by groupname. The "anonymous" user name can be used to denote any user.
+     */
+    public Map<String, List<String>> groups;
+
+    /**
+     * Read a configuration from a YAML file into an {@link AllowList} object.
+     *
+     * @param file the location of a AllowList YAML configuration file
+     * @return An {@link Optional} object wrapping the created {@link AllowList}
+     */
+    public static AllowList read(final String file) throws Exception {
+        final InputStream stream = new FileInputStream(new File(file));
+
+        final Constructor constructor = new Constructor(AllowList.class);
+        final TypeDescription allowListDescription = new TypeDescription(AllowList.class);
+        allowListDescription.putMapPropertyType("grants", String.class, Object.class);
+        allowListDescription.putMapPropertyType("groups", String.class, Object.class);
+        constructor.addTypeDescription(allowListDescription);
+
+        final Yaml yaml = new Yaml(constructor);
+        return yaml.loadAs(stream, AllowList.class);
+    }
+}
diff --git a/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/authz/AllowListAuthorizer.java b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/authz/AllowListAuthorizer.java
new file mode 100644
index 00000000000..7d4c604b12b
--- /dev/null
+++ b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/authz/AllowListAuthorizer.java
@@ -0,0 +1,152 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.server.authz;
+
+import org.apache.tinkerpop.gremlin.driver.message.RequestMessage;
+import org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.verification.VertexProgramRestrictionStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.Bytecode;
+import org.apache.tinkerpop.gremlin.process.traversal.TraversalSource;
+import org.apache.tinkerpop.gremlin.process.traversal.strategy.decoration.SubgraphStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.strategy.verification.ReadOnlyStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.util.BytecodeHelper;
+import org.apache.tinkerpop.gremlin.server.Settings.AuthorizationSettings;
+import org.apache.tinkerpop.gremlin.server.auth.AuthenticatedUser;
+
+import java.util.*;
+
+
+/**
+ * Authorizes a user per request, based on a list that grants access to {@link TraversalSource} instances for
+ * bytecode requests and to gremlin server's sandbox for string requests and lambdas. The {@link
+ * AuthorizationSettings}.config must have an authorizationAllowList entry that contains the name of a YAML file.
+ * This authorizer is for demonstration purposes only. It does not scale well in the number of users regarding
+ * memory usage and administrative burden.
+ *
+ * @author Marc de Lignie
+ */
+public class AllowListAuthorizer implements Authorizer {
+
+    public static final String SANDBOX = "sandbox";
+    public static final String REJECT_BYTECODE = "User not authorized for bytecode requests on %s";
+    public static final String REJECT_LAMBDA = "lambdas";
+    public static final String REJECT_MUTATE = "the ReadOnlyStrategy";
+    public static final String REJECT_OLAP = "the VertexProgramRestrictionStrategy";
+    public static final String REJECT_SUBGRAPH = "the SubgraphStrategy";
+    public static final String REJECT_STRING = "User not authorized for string-based requests.";
+    public static final String KEY_AUTHORIZATION_ALLOWLIST = "authorizationAllowList";
+
+    // Collections derived from the list with allowed users for fast lookups
+    private final Map<String, List<String>> usernamesByTraversalSource = new HashMap<>();
+    private final Set<String> usernamesSandbox = new HashSet<>();
+
+    /**
+     * This method is called once upon system startup to initialize the {@code AllowListAuthorizer}.
+     */
+    @Override
+    public void setup(final Map<String,Object> config) {
+        AllowList allowList;
+        final String file = (String) config.get(KEY_AUTHORIZATION_ALLOWLIST);
+
+        try {
+            allowList = AllowList.read(file);
+        } catch (Exception e) {
+            throw new IllegalArgumentException(String.format("Failed to read list with allowed users from %s", file));
+        }
+        for (Map.Entry<String, List<String>> entry : allowList.grants.entrySet()) {
+            if (!entry.getKey().equals(SANDBOX)) {
+                usernamesByTraversalSource.put(entry.getKey(), new ArrayList<>());
+            }
+            for (final String group : entry.getValue()) {
+                if (allowList.groups.get(group) == null) {
+                    throw new RuntimeException(String.format("Group '%s' not defined in file with allowed users.", group));
+                }
+                if (entry.getKey().equals(SANDBOX)) {
+                    usernamesSandbox.addAll(allowList.groups.get(group));
+                } else {
+                    usernamesByTraversalSource.get(entry.getKey()).addAll(allowList.groups.get(group));
+                }
+            }
+        }
+    }
+
+    /**
+     * Checks whether a user is authorized to have a gremlin bytecode request from a client answered and raises an
+     * {@link AuthorizationException} if this is not the case. For a request to be authorized, the user must either
+     * have a grant for the requested {@link TraversalSource}, without using lambdas, mutating steps or OLAP, or have a
+     * sandbox grant.
+     *
+     * @param user {@link AuthenticatedUser} that needs authorization.
+     * @param bytecode The gremlin {@link Bytecode} request to authorize the user for.
+     * @param aliases A {@link Map} with a single key/value pair that maps the name of the {@link TraversalSource} in the
+     *                {@link Bytecode} request to name of one configured in Gremlin Server.
+     * @return The original or modified {@link Bytecode} to be used for further processing.
+     */
+    @Override
+    public Bytecode authorize(final AuthenticatedUser user, final Bytecode bytecode, final Map<String, String> aliases) throws AuthorizationException {
+        final Set<String> usernames = new HashSet<>();
+
+        for (final String resource: aliases.values()) {
+            usernames.addAll(usernamesByTraversalSource.get(resource));
+        }
+        final boolean userHasTraversalSourceGrant = usernames.contains(user.getName()) || usernames.contains(AuthenticatedUser.ANONYMOUS_USERNAME);
+        final boolean userHasSandboxGrant = usernamesSandbox.contains(user.getName()) || usernamesSandbox.contains(AuthenticatedUser.ANONYMOUS_USERNAME);
+        final boolean runsLambda = BytecodeHelper.getLambdaLanguage(bytecode).isPresent();
+        final boolean touchesReadOnlyStrategy = bytecode.toString().contains(ReadOnlyStrategy.class.getSimpleName());
+        final boolean touchesOLAPRestriction = bytecode.toString().contains(VertexProgramRestrictionStrategy.class.getSimpleName());
+        // This element becomes obsolete after resolving TINKERPOP-2473 for allowing only a single instance of each traversal strategy.
+        final boolean touchesSubgraphStrategy = bytecode.toString().contains(SubgraphStrategy.class.getSimpleName());
+
+        final List<String> rejections = new ArrayList<>();
+        if (runsLambda) {
+            rejections.add(REJECT_LAMBDA);
+        }
+        if (touchesReadOnlyStrategy) {
+            rejections.add(REJECT_MUTATE);
+        }
+        if (touchesOLAPRestriction) {
+            rejections.add(REJECT_OLAP);
+        }
+        if (touchesSubgraphStrategy) {
+            rejections.add(REJECT_SUBGRAPH);
+        }
+        String rejectMessage = REJECT_BYTECODE;
+        if (rejections.size() > 0) {
+            rejectMessage += " using " + String.join(", ", rejections);
+        }
+        rejectMessage += ".";
+
+        if ( (!userHasTraversalSourceGrant || runsLambda || touchesOLAPRestriction || touchesReadOnlyStrategy || touchesSubgraphStrategy) && !userHasSandboxGrant) {
+            throw new AuthorizationException(String.format(rejectMessage, aliases.values()));
+        }
+        return bytecode;
+    }
+
+    /**
+     * Checks whether a user is authorized to have a script request from a gremlin client answered and raises an
+     * {@link AuthorizationException} if this is not the case.
+     *
+     * @param user {@link AuthenticatedUser} that needs authorization.
+     * @param msg {@link RequestMessage} in which the {@link org.apache.tinkerpop.gremlin.driver.Tokens}.ARGS_GREMLIN argument can contain an arbitrary succession of script statements.
+     */
+    public void authorize(final AuthenticatedUser user, final RequestMessage msg) throws AuthorizationException {
+        if (!usernamesSandbox.contains(user.getName())) {
+            throw new AuthorizationException(REJECT_STRING);
+        }
+    }
+}
diff --git a/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/authz/AuthorizerTest.java b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/authz/AuthorizerTest.java
new file mode 100644
index 00000000000..1b30c243eb7
--- /dev/null
+++ b/gremlin-server/src/test/java/org/apache/tinkerpop/gremlin/server/authz/AuthorizerTest.java
@@ -0,0 +1,278 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package org.apache.tinkerpop.gremlin.server.authz;
+
+import org.apache.tinkerpop.gremlin.driver.Tokens;
+import org.apache.tinkerpop.gremlin.driver.message.RequestMessage;
+import org.apache.tinkerpop.gremlin.process.computer.traversal.strategy.verification.VertexProgramRestrictionStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.Bytecode;
+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.GraphTraversalSource;
+import org.apache.tinkerpop.gremlin.process.traversal.dsl.graph.__;
+import org.apache.tinkerpop.gremlin.process.traversal.strategy.decoration.SubgraphStrategy;
+import org.apache.tinkerpop.gremlin.process.traversal.strategy.verification.ReadOnlyStrategy;
+import org.apache.tinkerpop.gremlin.server.auth.AuthenticatedUser;
+import org.apache.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph;
+import org.apache.tinkerpop.gremlin.util.function.Lambda;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TestName;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Objects;
+import java.util.function.Supplier;
+
+import static org.apache.tinkerpop.gremlin.server.authz.AllowListAuthorizer.REJECT_BYTECODE;
+import static org.apache.tinkerpop.gremlin.server.authz.AllowListAuthorizer.REJECT_LAMBDA;
+import static org.apache.tinkerpop.gremlin.server.authz.AllowListAuthorizer.REJECT_MUTATE;
+import static org.apache.tinkerpop.gremlin.server.authz.AllowListAuthorizer.REJECT_OLAP;
+import static org.apache.tinkerpop.gremlin.server.authz.AllowListAuthorizer.REJECT_SUBGRAPH;
+import static org.apache.tinkerpop.gremlin.server.authz.AllowListAuthorizer.REJECT_STRING;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
+
+
+/**
+ * @author Marc de Lignie
+ *
+ * Run with:
+ * mvn test --projects gremlin-server -Dtest=AuthorizerTest
+ */
+public class AuthorizerTest {
+
+    final String BYTECODE = "bytecode";
+    final String BYTECODE_LAMBDA = "bytecode-lambda";
+    final String BYTECODE_MUTATE = "bytecode-mutate";
+    final String BYTECODE_OLAP = "bytecode-OLAP";
+    final String BYTECODE_SUBGRAPH = "bytecode-subgraph";
+
+    AllowListAuthorizer authorizer;
+    SubgraphTraversals subgraphTraversals;
+
+    @Rule
+    public TestName name = new TestName();
+
+    @Before
+    public void setup() {
+        final Map<String, Object> config = new HashMap<>();
+        final String yamlName = "org/apache/tinkerpop/gremlin/server/allow-list.yaml";
+        String file = Objects.requireNonNull(getClass().getClassLoader().getResource(yamlName)).getFile();
+        config.put(AllowListAuthorizer.KEY_AUTHORIZATION_ALLOWLIST, file);
+        authorizer = new AllowListAuthorizer();
+        authorizer.setup(config);
+    }
+
+    @Test
+    public void shouldAuthorizeBytecodeRequest() throws AuthorizationException {
+        positiveBytecode("userclassic", "gclassic", BYTECODE);
+        positiveBytecode("usermodern", "gmodern", BYTECODE);
+        positiveBytecode("stephen", "gmodern", BYTECODE);
+        positiveBytecode("userclassic", "gcrew", BYTECODE);
+        positiveBytecode("usermodern", "gcrew", BYTECODE);
+        positiveBytecode("stephen", "gcrew", BYTECODE);
+        positiveBytecode("userclassic", "ggrateful", BYTECODE);
+        positiveBytecode("usersink", "ggrateful", BYTECODE);
+        positiveBytecode("anyuser", "ggrateful", BYTECODE);
+        positiveBytecode("usersandbox", "gclassic", BYTECODE);
+        positiveBytecode("marko", "gcrew", BYTECODE);
+    }
+
+    @Test
+    public void shouldNotAuthorizeBytecodeRequest() {
+        negativeBytecode("usersink", "gclassic", BYTECODE);
+        negativeBytecode("usersink", "gmodern", BYTECODE);
+        negativeBytecode("usersink", "gcrew", BYTECODE);
+        negativeBytecode("anyuser", "gclassic", BYTECODE);
+        negativeBytecode("anyuser", "gmodern", BYTECODE);
+        negativeBytecode("anyuser", "gcrew", BYTECODE);
+    }
+
+    @Test
+    public void shouldAuthorizeLambdaBytecodeRequest() throws AuthorizationException {
+        positiveBytecode("usersandbox", "gclassic", BYTECODE_LAMBDA);
+        positiveBytecode("marko", "gcrew", BYTECODE_LAMBDA);
+    }
+
+    @Test
+    public void shouldNotAuthorizeLambdaBytecodeRequest() {
+        negativeBytecode("userclassic", "gclassic", BYTECODE_LAMBDA);
+        negativeBytecode("usermodern", "gmodern", BYTECODE_LAMBDA);
+        negativeBytecode("stephen", "gmodern", BYTECODE_LAMBDA);
+        negativeBytecode("userclassic", "gcrew", BYTECODE_LAMBDA);
+        negativeBytecode("usermodern", "gcrew", BYTECODE_LAMBDA);
+        negativeBytecode("stephen", "gcrew", BYTECODE_LAMBDA);
+        negativeBytecode("userclassic", "ggrateful", BYTECODE_LAMBDA);
+        negativeBytecode("usersink", "ggrateful", BYTECODE_LAMBDA);
+        negativeBytecode("anyuser", "ggrateful", BYTECODE_LAMBDA);
+    }
+
+    @Test
+    public void shouldAuthorizeMutatingBytecodeRequest() throws AuthorizationException {
+        positiveBytecode("usersandbox", "gclassic", BYTECODE_MUTATE);
+        positiveBytecode("marko", "gcrew", BYTECODE_MUTATE);
+    }
+
+    @Test
+    public void shouldNotAuthorizeMutatingBytecodeRequest() {
+        negativeBytecode("userclassic", "gclassic", BYTECODE_MUTATE);
+        negativeBytecode("usermodern", "gmodern", BYTECODE_MUTATE);
+        negativeBytecode("stephen", "gmodern", BYTECODE_MUTATE);
+        negativeBytecode("userclassic", "gcrew", BYTECODE_MUTATE);
+        negativeBytecode("usermodern", "gcrew", BYTECODE_MUTATE);
+        negativeBytecode("stephen", "gcrew", BYTECODE_MUTATE);
+        negativeBytecode("userclassic", "ggrateful", BYTECODE_MUTATE);
+        negativeBytecode("usersink", "ggrateful", BYTECODE_MUTATE);
+        negativeBytecode("anyuser", "ggrateful", BYTECODE_MUTATE);
+    }
+
+    @Test
+    public void shouldAuthorizeOLAPBytecodeRequest() throws AuthorizationException {
+        positiveBytecode("usersandbox", "gclassic", BYTECODE_OLAP);
+        positiveBytecode("marko", "gcrew", BYTECODE_OLAP);
+    }
+
+    @Test
+    public void shouldNotAuthorizeOLAPBytecodeRequest() {
+        negativeBytecode("userclassic", "gclassic", BYTECODE_OLAP);
+        negativeBytecode("usermodern", "gmodern", BYTECODE_OLAP);
+        negativeBytecode("stephen", "gmodern", BYTECODE_OLAP);
+        negativeBytecode("userclassic", "gcrew", BYTECODE_OLAP);
+        negativeBytecode("usermodern", "gcrew", BYTECODE_OLAP);
+        negativeBytecode("stephen", "gcrew", BYTECODE_OLAP);
+        negativeBytecode("userclassic", "ggrateful", BYTECODE_OLAP);
+        negativeBytecode("usersink", "ggrateful", BYTECODE_OLAP);
+        negativeBytecode("anyuser", "ggrateful", BYTECODE_OLAP);
+    }
+
+    @Test
+    public void shouldAuthorizeSubgraphStrategyBytecodeRequest() throws AuthorizationException {
+        subgraphTraversals = new SubgraphTraversals();
+        positiveBytecode("usersandbox", "gclassic", BYTECODE_SUBGRAPH);
+        positiveBytecode("marko", "gcrew", BYTECODE_SUBGRAPH);
+    }
+
+    @Test
+    public void shouldNotAuthorizeSubgraphStrategyBytecodeRequest() {
+        subgraphTraversals = new SubgraphTraversals();
+        negativeBytecode("userclassic", "gclassic", BYTECODE_SUBGRAPH);
+        negativeBytecode("usermodern", "gmodern", BYTECODE_SUBGRAPH);
+        negativeBytecode("stephen", "gmodern", BYTECODE_SUBGRAPH);
+        negativeBytecode("userclassic", "gcrew", BYTECODE_SUBGRAPH);
+        negativeBytecode("usermodern", "gcrew", BYTECODE_SUBGRAPH);
+        negativeBytecode("stephen", "gcrew", BYTECODE_SUBGRAPH);
+        negativeBytecode("userclassic", "ggrateful", BYTECODE_SUBGRAPH);
+        negativeBytecode("usersink", "ggrateful", BYTECODE_SUBGRAPH);
+        negativeBytecode("anyuser", "ggrateful", BYTECODE_SUBGRAPH);
+    }
+
+    @Test
+    public void shouldAuthorizeStringRequest() throws AuthorizationException {
+        authorizer.authorize(new AuthenticatedUser("usersandbox"), buildRequestMessage("gclassic"));
+        authorizer.authorize(new AuthenticatedUser("marko"), buildRequestMessage("gcrew"));
+    }
+
+    @Test
+    public void shouldNotAuthorizeStringReques() {
+        negativeString("userclassic", "gclassic");
+        negativeString("stephen", "gmodern");
+        negativeString("userclassic", "gmodern");
+        negativeString("usersink", "gclassic");
+        negativeString("anyuser", "ggrateful");
+    }
+
+    private void positiveBytecode(final String username, final String traversalSource, final String requestType) throws AuthorizationException {
+        final Map<String, String> aliases = new HashMap<>();
+        aliases.put("g", traversalSource);
+        authorizer.authorize(new AuthenticatedUser(username), bytecodeRequest(requestType), aliases);
+    }
+
+    private void negativeBytecode(final String username, final String traversalSource, final String requestType) {
+        final Map<String, String> aliases = new HashMap<>();
+        aliases.put("g", traversalSource);
+        final String message;
+        switch (requestType) {
+            case BYTECODE:           message = String.format(REJECT_BYTECODE + ".", "[" + traversalSource + "]"); break;
+            case BYTECODE_LAMBDA:    message = String.format(REJECT_BYTECODE + " using " + REJECT_LAMBDA + ".", "[" + traversalSource + "]"); break;
+            case BYTECODE_MUTATE:    message = String.format(REJECT_BYTECODE + " using " + REJECT_MUTATE + ".", "[" + traversalSource + "]"); break;
+            case BYTECODE_OLAP:      message = String.format(REJECT_BYTECODE + " using " + REJECT_OLAP + ".", "[" + traversalSource + "]"); break;
+            case BYTECODE_SUBGRAPH:  message = String.format(REJECT_BYTECODE + " using " + REJECT_SUBGRAPH + ".", "[" + traversalSource + "]"); break;
+            default: throw new IllegalArgumentException();
+        }
+        try {
+            authorizer.authorize(new AuthenticatedUser(username), bytecodeRequest(requestType), aliases);
+            fail("Test code did not fail while it should have failed!");
+        } catch(AuthorizationException e) {
+            assertEquals(message, e.getMessage());
+        }
+    }
+
+    private Bytecode bytecodeRequest(final String requestType) {
+        final GraphTraversalSource g = TinkerGraph.open().traversal();
+        final Bytecode bytecode;
+
+        switch (requestType) {
+            case BYTECODE:           bytecode = g.V().asAdmin().getBytecode(); break;
+            case BYTECODE_LAMBDA:    bytecode = g.V().map(Lambda.function("it.get()")).asAdmin().getBytecode(); break;
+            case BYTECODE_MUTATE:    bytecode = g.withoutStrategies(ReadOnlyStrategy.class).V().addV().asAdmin().getBytecode(); break;
+            case BYTECODE_OLAP:      bytecode = g.withoutStrategies(VertexProgramRestrictionStrategy.class).withComputer().V().asAdmin().getBytecode(); break;
+            case BYTECODE_SUBGRAPH:  bytecode = subgraphTraversals.get(); break;
+            default: throw new IllegalArgumentException();
+        }
+        return bytecode;
+    }
+
+    private void negativeString(final String username, final String traversalSource) {
+        try {
+            authorizer.authorize(new AuthenticatedUser(username), buildRequestMessage(traversalSource));
+            fail("Test code did not fail while it should have failed!");
+        } catch(AuthorizationException e) {
+            assertEquals(REJECT_STRING, e.getMessage());
+        }
+    }
+
+    private RequestMessage buildRequestMessage(final String traversalSource) {
+        final String script = String.format("1+1; %s.V().map{it.get()}", traversalSource);
+        return RequestMessage.build(Tokens.OPS_EVAL).addArg(Tokens.ARGS_GREMLIN, script).create();
+    }
+
+    private static class SubgraphTraversals implements Supplier<Bytecode> {
+        final GraphTraversalSource g = TinkerGraph.open().traversal();
+        final Iterator<Bytecode> mutatingBytecodes = Arrays.asList(
+                g.withoutStrategies(SubgraphStrategy.class).V().asAdmin().getBytecode(),
+                g.withStrategies(SubgraphStrategy.build().vertices(__.bothE()).create()).V().asAdmin().getBytecode(),
+                g.withoutStrategies(SubgraphStrategy.class).V().asAdmin().getBytecode(),
+                g.withStrategies(SubgraphStrategy.build().vertices(__.bothE()).create()).V().asAdmin().getBytecode(),
+                g.withoutStrategies(SubgraphStrategy.class).V().asAdmin().getBytecode(),
+                g.withStrategies(SubgraphStrategy.build().vertices(__.bothE()).create()).V().asAdmin().getBytecode(),
+                g.withoutStrategies(SubgraphStrategy.class).V().asAdmin().getBytecode(),
+                g.withStrategies(SubgraphStrategy.build().vertices(__.bothE()).create()).V().asAdmin().getBytecode(),
+                g.withoutStrategies(SubgraphStrategy.class).V().asAdmin().getBytecode(),
+                g.withStrategies(SubgraphStrategy.build().vertices(__.bothE()).create()).V().asAdmin().getBytecode(),
+                g.withoutStrategies(SubgraphStrategy.class).V().asAdmin().getBytecode(),
+                g.withStrategies(SubgraphStrategy.build().vertices(__.bothE()).create()).V().asAdmin().getBytecode()
+        ).iterator();
+
+        public Bytecode get() {
+            return mutatingBytecodes.next();
+        }
+    }
+}
diff --git a/gremlin-server/src/test/resources/org/apache/tinkerpop/gremlin/server/allow-list-http-anonymous.yaml b/gremlin-server/src/test/resources/org/apache/tinkerpop/gremlin/server/allow-list-http-anonymous.yaml
new file mode 100644
index 00000000000..a4e776bd861
--- /dev/null
+++ b/gremlin-server/src/test/resources/org/apache/tinkerpop/gremlin/server/allow-list-http-anonymous.yaml
@@ -0,0 +1,24 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+grants: {
+  sandbox: [groupsandbox]
+}
+
+groups: {
+  groupsandbox: [anonymous]
+}
diff --git a/gremlin-server/src/test/resources/org/apache/tinkerpop/gremlin/server/allow-list.yaml b/gremlin-server/src/test/resources/org/apache/tinkerpop/gremlin/server/allow-list.yaml
new file mode 100644
index 00000000000..765495229e3
--- /dev/null
+++ b/gremlin-server/src/test/resources/org/apache/tinkerpop/gremlin/server/allow-list.yaml
@@ -0,0 +1,32 @@
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements.  See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership.  The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License.  You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied.  See the License for the
+# specific language governing permissions and limitations
+# under the License.
+
+grants: {
+  gclassic: [groupclassic],
+  gmodern: [groupmodern],
+  gcrew: [groupclassic, groupmodern],
+  ggrateful: [groupgrateful],
+  sandbox: [groupsandbox]
+}
+
+groups: {
+  groupclassic: [userclassic],
+  groupmodern: [usermodern, stephen],
+  groupsink: [usersink],
+  groupgrateful: [anonymous],
+  groupsandbox: [usersandbox, marko]
+}
