diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/disk/iomanager/IOManager.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/disk/iomanager/IOManager.java
index c0bd3604d598c..45d9b9eaf1cb5 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/disk/iomanager/IOManager.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/disk/iomanager/IOManager.java
@@ -301,9 +301,19 @@ public abstract BulkBlockChannelReader createBulkBlockChannelReader(FileIOChanne
 	 * 
 	 * @return The number of temporary file directories.
 	 */
-	public int getNumberOfTempDirs() {
+	public int getNumberOfSpillingDirectories() {
 		return this.paths.length;
 	}
+
+	/**
+	 * Gets the directories that the I/O manager spills to.
+	 * 
+	 * @return The directories that the I/O manager spills to.
+	 */
+	public File[] getSpillingDirectories() {
+		return this.paths;
+	}
+	
 	
 	protected int getNextPathNum() {
 		final int next = this.nextPath;
diff --git a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/EndOfPartitionEvent.java b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/EndOfPartitionEvent.java
index 49d7958efc430..3ecdb945841a4 100644
--- a/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/EndOfPartitionEvent.java
+++ b/flink-runtime/src/main/java/org/apache/flink/runtime/io/network/api/EndOfPartitionEvent.java
@@ -22,19 +22,34 @@
 import org.apache.flink.core.memory.DataOutputView;
 import org.apache.flink.runtime.event.task.RuntimeEvent;
 
-import java.io.IOException;
 
 public class EndOfPartitionEvent extends RuntimeEvent {
 
 	public static final EndOfPartitionEvent INSTANCE = new EndOfPartitionEvent();
-
+	
+	
 	@Override
-	public void read(DataInputView in) throws IOException {
+	public void read(DataInputView in) {
 		// Nothing to do here
 	}
 
 	@Override
-	public void write(DataOutputView out) throws IOException {
+	public void write(DataOutputView out) {
 		// Nothing to do here
 	}
+
+	@Override
+	public int hashCode() {
+		return 1965146673;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		return obj != null && obj.getClass() == EndOfPartitionEvent.class;
+	}
+
+	@Override
+	public String toString() {
+		return getClass().getSimpleName();
+	}
 }
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierBuffer.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierBuffer.java
index 40e84fcdf69dd..f3d39657a94d1 100644
--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierBuffer.java
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierBuffer.java
@@ -19,263 +19,259 @@
 
 import java.io.File;
 import java.io.IOException;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.Queue;
-import java.util.Set;
+import java.util.ArrayDeque;
 
-import org.apache.flink.runtime.io.network.api.EndOfPartitionEvent;
-import org.apache.flink.runtime.io.network.api.reader.AbstractReader;
+import org.apache.flink.runtime.io.disk.iomanager.IOManager;
 import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;
 import org.apache.flink.runtime.io.network.partition.consumer.InputGate;
+import org.apache.flink.runtime.util.event.EventListener;
 import org.apache.flink.streaming.runtime.tasks.CheckpointBarrier;
+
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 /**
- * The barrier buffer is responsible for implementing the blocking behaviour described
- * here: {@link CheckpointBarrier}.
- *
- * <p>
- * To avoid back-pressuring the
- * readers, we buffer up the new data received from the blocked channels until
- * the blocks are released.
+ * The barrier buffer is {@link CheckpointBarrierHandler} that blocks inputs with barriers until
+ * all inputs have received the barrier for a given checkpoint.
+ * 
+ *<p>To avoid back-pressuring the input streams (which may cause distributed deadlocks), the
+ * BarrierBuffer continues receiving buffers from the blocked channels and stores them internally until 
+ * the blocks are released.</p>
  */
-public class BarrierBuffer {
+public class BarrierBuffer implements CheckpointBarrierHandler {
 
 	private static final Logger LOG = LoggerFactory.getLogger(BarrierBuffer.class);
+	
+	/** The gate that the buffer draws its input from */
+	private final InputGate inputGate;
+
+	/** Flags that indicate whether a channel is currently blocked/buffered */
+	private final boolean[] blockedChannels;
+	
+	/** The total number of channels that this buffer handles data from */
+	private final int totalNumberOfInputChannels;
+
+	private final SpillReader spillReader;
+	private final BufferSpiller bufferSpiller;
+	
+	private ArrayDeque<SpillingBufferOrEvent> nonProcessed = new ArrayDeque<SpillingBufferOrEvent>();
+	private ArrayDeque<SpillingBufferOrEvent> blockedNonProcessed = new ArrayDeque<SpillingBufferOrEvent>();
+
+	/** Handler that receives the checkpoint notifications */
+	private EventListener<CheckpointBarrier> checkpointHandler;
+
+	/** The ID of the checkpoint for which we expect barriers */
+	private long currentCheckpointId = -1L;
+
+	/** The number of received barriers (= number of blocked/buffered channels) */
+	private long numReceivedBarriers;
+	
+	/** Flag to indicate whether we have drawn all available input */
+	private boolean endOfStream;
+
+	
+	public BarrierBuffer(InputGate inputGate, IOManager ioManager) throws IOException {
+		this.inputGate = inputGate;
+		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels();
+		this.blockedChannels = new boolean[this.totalNumberOfInputChannels];
+		
+		this.bufferSpiller = new BufferSpiller(ioManager);
+		this.spillReader = new SpillReader();
+	}
 
-	private Queue<SpillingBufferOrEvent> nonProcessed = new LinkedList<SpillingBufferOrEvent>();
-	private Queue<SpillingBufferOrEvent> blockedNonProcessed = new LinkedList<SpillingBufferOrEvent>();
-
-	private Set<Integer> blockedChannels = new HashSet<Integer>();
-	private int totalNumberOfInputChannels;
-
-	private CheckpointBarrier currentBarrier;
-
-	private AbstractReader reader;
-
-	private InputGate inputGate;
-
-	private SpillReader spillReader;
-	private BufferSpiller bufferSpiller;
-
-	private boolean inputFinished = false;
+	// ------------------------------------------------------------------------
+	//  Buffer and barrier handling
+	// ------------------------------------------------------------------------
 
-	private BufferOrEvent endOfStreamEvent = null;
+	@Override
+	public BufferOrEvent getNextNonBlocked() throws IOException, InterruptedException {
+		while (true) {
+			// process buffered BufferOrEvents before grabbing new ones
+			final SpillingBufferOrEvent nextBuffered = nonProcessed.pollFirst();
+			final BufferOrEvent next = nextBuffered == null ?
+					inputGate.getNextBufferOrEvent() :
+					nextBuffered.getBufferOrEvent();
+			
+			if (next != null) {
+				if (isBlocked(next.getChannelIndex())) {
+					// if the channel is blocked we, we just store the BufferOrEvent
+					blockedNonProcessed.add(new SpillingBufferOrEvent(next, bufferSpiller, spillReader));
+				}
+				else if (next.isBuffer() || next.getEvent().getClass() != CheckpointBarrier.class) {
+					return next;
+				}
+				else if (!endOfStream) {
+					// process barriers only if there is a chance of the checkpoint completing
+					processBarrier((CheckpointBarrier) next.getEvent(), next.getChannelIndex());
+				}
+			}
+			else if (!endOfStream) {
+				// end of stream. we feed the data that is still buffered
+				endOfStream = true;
+				releaseBlocks();
+				return getNextNonBlocked();
+			}
+			else {
+				return null;
+			}
+		}
+	}
+	
+	private void processBarrier(CheckpointBarrier receivedBarrier, int channelIndex) throws IOException {
+		final long barrierId = receivedBarrier.getId();
+
+		if (numReceivedBarriers > 0) {
+			// subsequent barrier of a checkpoint.
+			if (barrierId == currentCheckpointId) {
+				// regular case
+				onBarrier(channelIndex);
+			}
+			else if (barrierId > currentCheckpointId) {
+				// we did not complete the current checkpoint
+				LOG.warn("Received checkpoint barrier for checkpoint {} before completing current checkpoint {}. " +
+						"Skipping current checkpoint.", barrierId, currentCheckpointId);
+
+				releaseBlocks();
+				currentCheckpointId = barrierId;
+				onBarrier(channelIndex);
+			}
+			else {
+				// ignore trailing barrier from aborted checkpoint
+				return;
+			}
+			
+		}
+		else if (barrierId > currentCheckpointId) {
+			// first barrier of a new checkpoint
+			currentCheckpointId = barrierId;
+			onBarrier(channelIndex);
+		}
+		else {
+			// trailing barrier from previous (skipped) checkpoint
+			return;
+		}
 
-	private long lastCheckpointId = Long.MIN_VALUE;
+		// check if we have all barriers
+		if (numReceivedBarriers == totalNumberOfInputChannels) {
+			if (LOG.isDebugEnabled()) {
+				LOG.debug("Received all barrier, triggering checkpoint {} at {}",
+						receivedBarrier.getId(), receivedBarrier.getTimestamp());
+			}
 
-	public BarrierBuffer(InputGate inputGate, AbstractReader reader) {
-		this.inputGate = inputGate;
-		totalNumberOfInputChannels = inputGate.getNumberOfInputChannels();
-		this.reader = reader;
-		try {
-			this.bufferSpiller = new BufferSpiller();
-			this.spillReader = new SpillReader();
-		} catch (IOException e) {
-			throw new RuntimeException(e);
+			if (checkpointHandler != null) {
+				checkpointHandler.onEvent(receivedBarrier);
+			}
+			
+			releaseBlocks();
 		}
-
+	}
+	
+	@Override
+	public void registerCheckpointEventHandler(EventListener<CheckpointBarrier> checkpointHandler) {
+		if (this.checkpointHandler == null) {
+			this.checkpointHandler = checkpointHandler;
+		}
+		else {
+			throw new IllegalStateException("BarrierBuffer already has a registered checkpoint handler");
+		}
+	}
+	
+	@Override
+	public boolean isEmpty() {
+		return nonProcessed.isEmpty() && blockedNonProcessed.isEmpty();
 	}
 
-	/**
-	 * Get then next non-blocked non-processed {@link BufferOrEvent}. Returns null if
-	 * none available.
-	 * 
-	 * @throws IOException
-	 */
-	private BufferOrEvent getNonProcessed() throws IOException {
-		SpillingBufferOrEvent nextNonProcessed;
-
-		while ((nextNonProcessed = nonProcessed.poll()) != null) {
-			BufferOrEvent boe = nextNonProcessed.getBufferOrEvent();
-			if (isBlocked(boe.getChannelIndex())) {
-				blockedNonProcessed.add(new SpillingBufferOrEvent(boe, bufferSpiller, spillReader));
-			} else {
-				return boe;
+	@Override
+	public void cleanup() throws IOException {
+		bufferSpiller.close();
+		File spillfile1 = bufferSpiller.getSpillFile();
+		if (spillfile1 != null) {
+			if (!spillfile1.delete()) {
+				LOG.warn("Cannot remove barrier buffer spill file: " + spillfile1.getAbsolutePath());
 			}
 		}
 
-		return null;
+		spillReader.close();
+		File spillfile2 = spillReader.getSpillFile();
+		if (spillfile2 != null) {
+			if (!spillfile2.delete()) {
+				LOG.warn("Cannot remove barrier buffer spill file: " + spillfile2.getAbsolutePath());
+			}
+		}
 	}
-
+	
 	/**
 	 * Checks whether the channel with the given index is blocked.
 	 * 
-	 * @param channelIndex The channel index to check
+	 * @param channelIndex The channel index to check.
+	 * @return True if the channel is blocked, false if not.
 	 */
 	private boolean isBlocked(int channelIndex) {
-		return blockedChannels.contains(channelIndex);
+		return blockedChannels[channelIndex];
 	}
-
-	/**
-	 * Checks whether all channels are blocked meaning that barriers have been
-	 * received from all channels
-	 */
-	private boolean isAllBlocked() {
-		return blockedChannels.size() == totalNumberOfInputChannels;
-	}
-
-	/**
-	 * Returns the next non-blocked {@link BufferOrEvent}. This is a blocking operator.
-	 */
-	public BufferOrEvent getNextNonBlocked() throws IOException, InterruptedException {
-		// If there are non-processed buffers from the previously blocked ones,
-		// we get the next
-		BufferOrEvent bufferOrEvent = getNonProcessed();
-
-		if (bufferOrEvent != null) {
-			return bufferOrEvent;
-		} else if (blockedNonProcessed.isEmpty() && inputFinished) {
-			return endOfStreamEvent;
-		} else {
-			// If no non-processed, get new from input
-			while (true) {
-				if (!inputFinished) {
-					// We read the next buffer from the inputgate
-					bufferOrEvent = inputGate.getNextBufferOrEvent();
-
-					if (!bufferOrEvent.isBuffer()
-							&& bufferOrEvent.getEvent() instanceof EndOfPartitionEvent) {
-						if (inputGate.isFinished()) {
-							// store the event for later if the channel is
-							// closed
-							endOfStreamEvent = bufferOrEvent;
-							inputFinished = true;
-						}
-
-					} else {
-						if (isBlocked(bufferOrEvent.getChannelIndex())) {
-							// If channel blocked we just store it
-							blockedNonProcessed.add(new SpillingBufferOrEvent(bufferOrEvent,
-									bufferSpiller, spillReader));
-						} else {
-							return bufferOrEvent;
-						}
-					}
-				} else {
-					actOnAllBlocked();
-					return getNextNonBlocked();
-				}
-			}
-		}
-	}
-
+	
 	/**
 	 * Blocks the given channel index, from which a barrier has been received.
 	 * 
-	 * @param channelIndex
-	 *            The channel index to block.
+	 * @param channelIndex The channel index to block.
 	 */
-	private void blockChannel(int channelIndex) {
-		if (!blockedChannels.contains(channelIndex)) {
-			blockedChannels.add(channelIndex);
+	private void onBarrier(int channelIndex) throws IOException {
+		if (!blockedChannels[channelIndex]) {
+			blockedChannels[channelIndex] = true;
+			numReceivedBarriers++;
+			
 			if (LOG.isDebugEnabled()) {
-				LOG.debug("Channel blocked with index: " + channelIndex);
-			}
-			if (isAllBlocked()) {
-				actOnAllBlocked();
+				LOG.debug("Received barrier from channel " + channelIndex);
 			}
-
-		} else {
-			throw new RuntimeException("Tried to block an already blocked channel");
+		}
+		else {
+			throw new IOException("Stream corrupt: Repeated barrier for same checkpoint and input stream");
 		}
 	}
 
 	/**
 	 * Releases the blocks on all channels.
 	 */
-	private void releaseBlocks() {
-		if (!nonProcessed.isEmpty()) {
-			// sanity check
-			throw new RuntimeException("Error in barrier buffer logic");
-		}
-		nonProcessed = blockedNonProcessed;
-		blockedNonProcessed = new LinkedList<SpillingBufferOrEvent>();
-
-		try {
-			spillReader.setSpillFile(bufferSpiller.getSpillFile());
-			bufferSpiller.resetSpillFile();
-		} catch (IOException e) {
-			throw new RuntimeException(e);
-		}
-
-		blockedChannels.clear();
-		currentBarrier = null;
+	private void releaseBlocks() throws IOException {
 		if (LOG.isDebugEnabled()) {
-			LOG.debug("All barriers received, blocks released");
+			LOG.debug("Releasing blocks");
 		}
-	}
 
-	/**
-	 * Method that is executed once the barrier has been received from all
-	 * channels.
-	 */
-	private void actOnAllBlocked() {
-		if (LOG.isDebugEnabled()) {
-			LOG.debug("Publishing barrier to the vertex");
+		for (int i = 0; i < blockedChannels.length; i++) {
+			blockedChannels[i] = false;
 		}
-
-		if (currentBarrier != null && !inputFinished) {
-			reader.publish(currentBarrier);
-			lastCheckpointId = currentBarrier.getId();
+		numReceivedBarriers = 0;
+		
+		if (nonProcessed.isEmpty()) {
+			// swap the queues
+			ArrayDeque<SpillingBufferOrEvent> empty = nonProcessed;
+			nonProcessed = blockedNonProcessed;
+			blockedNonProcessed = empty;
 		}
-
-		releaseBlocks();
-	}
-
-	/**
-	 * Processes one {@link org.apache.flink.streaming.runtime.tasks.CheckpointBarrier}
-	 * 
-	 * @param bufferOrEvent The {@link BufferOrEvent} containing the checkpoint barrier
-	 */
-	public void processBarrier(BufferOrEvent bufferOrEvent) {
-		CheckpointBarrier receivedBarrier = (CheckpointBarrier) bufferOrEvent.getEvent();
-
-		if (receivedBarrier.getId() < lastCheckpointId) {
-			// a barrier from an old checkpoint, ignore these
-			return;
-		}
-
-		if (currentBarrier == null) {
-			this.currentBarrier = receivedBarrier;
-			if (LOG.isDebugEnabled()) {
-				LOG.debug("Checkpoint barrier received start waiting for checkpoint: {}", receivedBarrier);
-			}
-		} else if (receivedBarrier.getId() > currentBarrier.getId()) {
-			// we have a barrier from a more recent checkpoint, free all locks and start with
-			// this newer checkpoint
-			if (LOG.isDebugEnabled()) {
-				LOG.debug("Checkpoint barrier received while waiting on checkpoint {}. Restarting waiting with checkpoint {}: ", currentBarrier, receivedBarrier);
-			}
-			releaseBlocks();
-			currentBarrier = receivedBarrier;
-
+		else {
+			throw new IllegalStateException("Unconsumed data from previous checkpoint alignment " +
+					"when starting next checkpoint alignment");
 		}
-		blockChannel(bufferOrEvent.getChannelIndex());
+		
+		// roll over the spill files
+		spillReader.setSpillFile(bufferSpiller.getSpillFile());
+		bufferSpiller.resetSpillFile();
 	}
 
-	public void cleanup() throws IOException {
-		bufferSpiller.close();
-		File spillfile1 = bufferSpiller.getSpillFile();
-		if (spillfile1 != null) {
-			spillfile1.delete();
-		}
+	// ------------------------------------------------------------------------
+	// For Testing
+	// ------------------------------------------------------------------------
 
-		spillReader.close();
-		File spillfile2 = spillReader.getSpillFile();
-		if (spillfile2 != null) {
-			spillfile2.delete();
-		}
+	public long getCurrentCheckpointId() {
+		return this.currentCheckpointId;
 	}
-
+	
+	// ------------------------------------------------------------------------
+	// Utilities 
+	// ------------------------------------------------------------------------
+	
+	@Override
 	public String toString() {
-		return nonProcessed.toString() + blockedNonProcessed.toString();
-	}
-
-	public boolean isEmpty() {
-		return nonProcessed.isEmpty() && blockedNonProcessed.isEmpty();
+		return "Non-Processed: " + nonProcessed + " | Blocked: " + blockedNonProcessed;
 	}
-
 }
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierTracker.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierTracker.java
new file mode 100644
index 0000000000000..6b24556e6eae4
--- /dev/null
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BarrierTracker.java
@@ -0,0 +1,194 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.streaming.runtime.io;
+
+import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;
+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;
+import org.apache.flink.runtime.util.event.EventListener;
+import org.apache.flink.streaming.runtime.tasks.CheckpointBarrier;
+
+import java.io.IOException;
+import java.util.ArrayDeque;
+
+/**
+ * The BarrierTracker keeps track of what checkpoint barriers have been received from
+ * which input channels. 
+ * 
+ * <p>Unlike the {@link BarrierBuffer}, the BarrierTracker does not block the input
+ * channels that have sent barriers, so it cannot be used to gain "exactly-once" processing
+ * guarantees. It can, however, be used to gain "at least once" processing guarantees.</p>
+ */
+public class BarrierTracker implements CheckpointBarrierHandler {
+
+	private static final int MAX_CHECKPOINTS_TO_TRACK = 50;
+	
+	private final InputGate inputGate;
+	
+	private final int totalNumberOfInputChannels;
+	
+	private final ArrayDeque<CheckpointBarrierCount> pendingCheckpoints;
+	
+	private EventListener<CheckpointBarrier> checkpointHandler;
+	
+	private long latestPendingCheckpointID = -1;
+	
+	public BarrierTracker(InputGate inputGate) {
+		this.inputGate = inputGate;
+		this.totalNumberOfInputChannels = inputGate.getNumberOfInputChannels();
+		this.pendingCheckpoints = new ArrayDeque<CheckpointBarrierCount>();
+	}
+
+	@Override
+	public BufferOrEvent getNextNonBlocked() throws IOException, InterruptedException {
+		while (true) {
+			BufferOrEvent next = inputGate.getNextBufferOrEvent();
+			if (next == null) {
+				return null;
+			}
+			else if (next.isBuffer() || next.getEvent().getClass() != CheckpointBarrier.class) {
+				return next;
+			}
+			else {
+				processBarrier((CheckpointBarrier) next.getEvent());
+			}
+		}
+	}
+
+	@Override
+	public void registerCheckpointEventHandler(EventListener<CheckpointBarrier> checkpointHandler) {
+		if (this.checkpointHandler == null) {
+			this.checkpointHandler = checkpointHandler;
+		}
+		else {
+			throw new IllegalStateException("BarrierTracker already has a registered checkpoint handler");
+		}
+	}
+
+	@Override
+	public void cleanup() {
+		pendingCheckpoints.clear();
+	}
+
+	@Override
+	public boolean isEmpty() {
+		return pendingCheckpoints.isEmpty();
+	}
+
+	private void processBarrier(CheckpointBarrier receivedBarrier) {
+		// fast path for single channel trackers
+		if (totalNumberOfInputChannels == 1) {
+			if (checkpointHandler != null) {
+				checkpointHandler.onEvent(receivedBarrier);
+			}
+			return;
+		}
+		
+		// general path for multiple input channels
+		final long barrierId = receivedBarrier.getId();
+
+		// find the checkpoint barrier in the queue of bending barriers
+		CheckpointBarrierCount cbc = null;
+		int pos = 0;
+		
+		for (CheckpointBarrierCount next : pendingCheckpoints) {
+			if (next.checkpointId == barrierId) {
+				cbc = next;
+				break;
+			}
+			pos++;
+		}
+		
+		if (cbc != null) {
+			// add one to the count to that barrier and check for completion
+			int numBarriersNew = cbc.incrementBarrierCount();
+			if (numBarriersNew == totalNumberOfInputChannels) {
+				// checkpoint can be triggered
+				// first, remove this checkpoint and all all prior pending
+				// checkpoints (which are now subsumed)
+				for (int i = 0; i <= pos; i++) {
+					pendingCheckpoints.pollFirst();
+				}
+				
+				// notify the listener
+				if (checkpointHandler != null) {
+					checkpointHandler.onEvent(receivedBarrier);
+				}
+			}
+		}
+		else {
+			// first barrier for that checkpoint ID
+			// add it only if it is newer than the latest checkpoint.
+			// if it is not newer than the latest checkpoint ID, then there cannot be a
+			// successful checkpoint for that ID anyways
+			if (barrierId > latestPendingCheckpointID) {
+				latestPendingCheckpointID = barrierId;
+				pendingCheckpoints.addLast(new CheckpointBarrierCount(barrierId));
+				
+				// make sure we do not track too many checkpoints
+				if (pendingCheckpoints.size() > MAX_CHECKPOINTS_TO_TRACK) {
+					pendingCheckpoints.pollFirst();
+				}
+			}
+		}
+	}
+
+	// ------------------------------------------------------------------------
+	//  
+	// ------------------------------------------------------------------------
+
+	/**
+	 * Simple class for a checkpoint ID with a barrier counter.
+	 */
+	private static final class CheckpointBarrierCount {
+		
+		private final long checkpointId;
+		
+		private int barrierCount;
+		
+		private CheckpointBarrierCount(long checkpointId) {
+			this.checkpointId = checkpointId;
+			this.barrierCount = 1;
+		}
+
+		public int incrementBarrierCount() {
+			return ++barrierCount;
+		}
+		
+		@Override
+		public int hashCode() {
+			return (int) ((checkpointId >>> 32) ^ checkpointId) + 17 * barrierCount; 
+		}
+
+		@Override
+		public boolean equals(Object obj) {
+			if (obj instanceof  CheckpointBarrierCount) {
+				CheckpointBarrierCount that = (CheckpointBarrierCount) obj;
+				return this.checkpointId == that.checkpointId && this.barrierCount == that.barrierCount;
+			}
+			else {
+				return false;
+			}
+		}
+
+		@Override
+		public String toString() {
+			return String.format("checkpointID=%d, count=%d", checkpointId, barrierCount);
+		}
+	}
+}
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BufferSpiller.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BufferSpiller.java
index 0d57d056e6f4b..fda612e7247d0 100644
--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BufferSpiller.java
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/BufferSpiller.java
@@ -22,28 +22,33 @@
 import java.io.RandomAccessFile;
 import java.nio.channels.FileChannel;
 import java.util.Random;
+import java.util.concurrent.atomic.AtomicInteger;
 
-import org.apache.flink.configuration.ConfigConstants;
-import org.apache.flink.configuration.GlobalConfiguration;
+import org.apache.flink.runtime.io.disk.iomanager.IOManager;
 import org.apache.flink.runtime.io.network.buffer.Buffer;
 import org.apache.flink.util.StringUtils;
 
 public class BufferSpiller {
+	
+	/** The random number generator for temp file names */
+	private static final Random RND = new Random();
 
-	protected static Random rnd = new Random();
+	/** The counter that selects the next directory to spill into */
+	private static final AtomicInteger DIRECTORY_INDEX = new AtomicInteger(0);
+	
+	
+	/** The directories to spill to */
+	private final File tempDir;
 
 	private File spillFile;
-	protected FileChannel spillingChannel;
-	private String tempDir;
-
-	public BufferSpiller() throws IOException {
-		String tempDirString = GlobalConfiguration.getString(
-				ConfigConstants.TASK_MANAGER_TMP_DIR_KEY,
-				ConfigConstants.DEFAULT_TASK_MANAGER_TMP_PATH);
-		String[] tempDirs = tempDirString.split(",|" + File.pathSeparator);
-
-		tempDir = tempDirs[rnd.nextInt(tempDirs.length)];
-
+	
+	private FileChannel spillingChannel;
+	
+	
+
+	public BufferSpiller(IOManager ioManager) throws IOException {
+		File[] tempDirs = ioManager.getSpillingDirectories();
+		this.tempDir = tempDirs[DIRECTORY_INDEX.getAndIncrement() % tempDirs.length];
 		createSpillingChannel();
 	}
 
@@ -54,24 +59,20 @@ public void spill(Buffer buffer) throws IOException {
 		try {
 			spillingChannel.write(buffer.getNioBuffer());
 			buffer.recycle();
-		} catch (IOException e) {
+		}
+		catch (IOException e) {
 			close();
-			throw new IOException(e);
+			throw e;
 		}
-
 	}
 
 	@SuppressWarnings("resource")
 	private void createSpillingChannel() throws IOException {
-		this.spillFile = new File(tempDir, randomString(rnd) + ".buffer");
+		this.spillFile = new File(tempDir, randomString(RND) + ".buffer");
 		this.spillingChannel = new RandomAccessFile(spillFile, "rw").getChannel();
 	}
 
-	private static String randomString(Random random) {
-		final byte[] bytes = new byte[20];
-		random.nextBytes(bytes);
-		return StringUtils.byteToHexString(bytes);
-	}
+
 
 	public void close() throws IOException {
 		if (spillingChannel != null && spillingChannel.isOpen()) {
@@ -87,5 +88,12 @@ public void resetSpillFile() throws IOException {
 	public File getSpillFile() {
 		return spillFile;
 	}
+	
+	// ------------------------------------------------------------------------
 
+	private static String randomString(Random random) {
+		final byte[] bytes = new byte[20];
+		random.nextBytes(bytes);
+		return StringUtils.byteToHexString(bytes);
+	}
 }
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierHandler.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierHandler.java
new file mode 100644
index 0000000000000..02dd33d5da066
--- /dev/null
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/CheckpointBarrierHandler.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.streaming.runtime.io;
+
+import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;
+import org.apache.flink.runtime.util.event.EventListener;
+import org.apache.flink.streaming.runtime.tasks.CheckpointBarrier;
+
+import java.io.IOException;
+
+/**
+ * The CheckpointBarrierHandler reacts to checkpoint barrier arriving from the input channels.
+ * Different implementations may either simply track barriers, or block certain inputs on
+ * barriers.
+ */
+public interface CheckpointBarrierHandler {
+
+	/**
+	 * Returns the next {@link BufferOrEvent} that the operator may consume.
+	 * This call blocks until the next BufferOrEvent is available, ir until the stream
+	 * has been determined to be finished.
+	 * 
+	 * @return The next BufferOrEvent, or {@code null}, if the stream is finished.
+	 * @throws java.io.IOException Thrown, if the network or local disk I/O fails.
+	 * @throws java.lang.InterruptedException Thrown, if the thread is interrupted while blocking during
+	 *                                        waiting for the next BufferOrEvent to become available.
+	 */
+	BufferOrEvent getNextNonBlocked() throws IOException, InterruptedException;
+
+	void registerCheckpointEventHandler(EventListener<CheckpointBarrier> checkpointHandler);
+	
+	void cleanup() throws IOException;
+
+	/**
+	 * Checks if the barrier handler has buffered any data internally.
+	 * @return True, if no data is buffered internally, false otherwise.
+	 */
+	boolean isEmpty();
+}
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamInputProcessor.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamInputProcessor.java
index e665710c70bd6..3530ee0f07d8f 100644
--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamInputProcessor.java
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamInputProcessor.java
@@ -23,6 +23,7 @@
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.runtime.accumulators.AccumulatorRegistry;
 import org.apache.flink.runtime.event.task.AbstractEvent;
+import org.apache.flink.runtime.io.disk.iomanager.IOManager;
 import org.apache.flink.runtime.io.network.api.reader.AbstractReader;
 import org.apache.flink.runtime.io.network.api.reader.ReaderBase;
 import org.apache.flink.runtime.io.network.api.serialization.RecordDeserializer;
@@ -33,6 +34,7 @@
 import org.apache.flink.runtime.io.network.partition.consumer.InputGate;
 import org.apache.flink.runtime.plugable.DeserializationDelegate;
 import org.apache.flink.runtime.plugable.NonReusingDeserializationDelegate;
+import org.apache.flink.runtime.util.event.EventListener;
 import org.apache.flink.streaming.api.operators.OneInputStreamOperator;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.MultiplexingStreamRecordSerializer;
@@ -63,11 +65,11 @@
 
 	// We need to keep track of the channel from which a buffer came, so that we can
 	// appropriately map the watermarks to input channels
-	int currentChannel = -1;
+	private int currentChannel = -1;
 
 	private boolean isFinished;
 
-	private final BarrierBuffer barrierBuffer;
+	private final CheckpointBarrierHandler barrierBuffer;
 
 	private long[] watermarks;
 	private long lastEmittedWatermark;
@@ -75,11 +77,18 @@
 	private DeserializationDelegate deserializationDelegate;
 
 	@SuppressWarnings("unchecked")
-	public StreamInputProcessor(InputGate[] inputGates, TypeSerializer<IN> inputSerializer, boolean enableWatermarkMultiplexing) {
+	public StreamInputProcessor(InputGate[] inputGates, TypeSerializer<IN> inputSerializer,
+								EventListener<CheckpointBarrier> checkpointListener,
+								IOManager ioManager,
+								boolean enableWatermarkMultiplexing) throws IOException {
+		
 		super(InputGateUtil.createInputGate(inputGates));
 
-		barrierBuffer = new BarrierBuffer(inputGate, this);
-
+		this.barrierBuffer = new BarrierBuffer(inputGate, ioManager);
+		if (checkpointListener != null) {
+			this.barrierBuffer.registerCheckpointEventHandler(checkpointListener);
+		}
+		
 		StreamRecordSerializer<IN> inputRecordSerializer;
 		if (enableWatermarkMultiplexing) {
 			inputRecordSerializer = new MultiplexingStreamRecordSerializer<IN>(inputSerializer);
@@ -155,24 +164,21 @@ public boolean processInput(OneInputStreamOperator<IN, ?> streamOperator) throws
 				currentChannel = bufferOrEvent.getChannelIndex();
 				currentRecordDeserializer = recordDeserializers[currentChannel];
 				currentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());
-			} else {
+			}
+			else {
 				// Event received
 				final AbstractEvent event = bufferOrEvent.getEvent();
-
-				if (event instanceof CheckpointBarrier) {
-					barrierBuffer.processBarrier(bufferOrEvent);
-				} else {
-					if (handleEvent(event)) {
-						if (inputGate.isFinished()) {
-							if (!barrierBuffer.isEmpty()) {
-								throw new RuntimeException("BarrierBuffer should be empty at this point");
-							}
-							isFinished = true;
-							return false;
-						} else if (hasReachedEndOfSuperstep()) {
-							return false;
-						} // else: More data is coming...
+				if (handleEvent(event)) {
+					if (inputGate.isFinished()) {
+						if (!barrierBuffer.isEmpty()) {
+							throw new RuntimeException("BarrierBuffer should be empty at this point");
+						}
+						isFinished = true;
+						return false;
 					}
+					else if (hasReachedEndOfSuperstep()) {
+						return false;
+					} // else: More data is coming...
 				}
 			}
 		}
@@ -194,6 +200,7 @@ public void clearBuffers() {
 		}
 	}
 
+	@Override
 	public void cleanup() throws IOException {
 		barrierBuffer.cleanup();
 	}
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamTwoInputProcessor.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamTwoInputProcessor.java
index 1fe98bbd74f30..c045a55e9f770 100644
--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamTwoInputProcessor.java
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/io/StreamTwoInputProcessor.java
@@ -21,6 +21,7 @@
 import org.apache.flink.api.common.typeutils.TypeSerializer;
 import org.apache.flink.runtime.accumulators.AccumulatorRegistry;
 import org.apache.flink.runtime.event.task.AbstractEvent;
+import org.apache.flink.runtime.io.disk.iomanager.IOManager;
 import org.apache.flink.runtime.io.network.api.reader.AbstractReader;
 import org.apache.flink.runtime.io.network.api.reader.ReaderBase;
 import org.apache.flink.runtime.io.network.api.serialization.RecordDeserializer;
@@ -31,6 +32,7 @@
 import org.apache.flink.runtime.io.network.partition.consumer.InputGate;
 import org.apache.flink.runtime.plugable.DeserializationDelegate;
 import org.apache.flink.runtime.plugable.NonReusingDeserializationDelegate;
+import org.apache.flink.runtime.util.event.EventListener;
 import org.apache.flink.streaming.api.operators.TwoInputStreamOperator;
 import org.apache.flink.streaming.api.watermark.Watermark;
 import org.apache.flink.streaming.runtime.streamrecord.MultiplexingStreamRecordSerializer;
@@ -68,7 +70,7 @@
 
 	private boolean isFinished;
 
-	private final BarrierBuffer barrierBuffer;
+	private final CheckpointBarrierHandler barrierBuffer;
 
 	private long[] watermarks1;
 	private long lastEmittedWatermark1;
@@ -88,10 +90,16 @@ public StreamTwoInputProcessor(
 			Collection<InputGate> inputGates2,
 			TypeSerializer<IN1> inputSerializer1,
 			TypeSerializer<IN2> inputSerializer2,
-			boolean enableWatermarkMultiplexing) {
+			EventListener<CheckpointBarrier> checkpointListener,
+			IOManager ioManager,
+			boolean enableWatermarkMultiplexing) throws IOException {
+		
 		super(InputGateUtil.createInputGate(inputGates1, inputGates2));
 
-		barrierBuffer = new BarrierBuffer(inputGate, this);
+		this.barrierBuffer = new BarrierBuffer(inputGate, ioManager);
+		if (checkpointListener != null) {
+			this.barrierBuffer.registerCheckpointEventHandler(checkpointListener);
+		}
 
 		StreamRecordSerializer<IN1> inputRecordSerializer1;
 		if (enableWatermarkMultiplexing) {
@@ -190,21 +198,16 @@ public boolean processInput(TwoInputStreamOperator<IN1, IN2, ?> streamOperator)
 			} else {
 				// Event received
 				final AbstractEvent event = bufferOrEvent.getEvent();
-
-				if (event instanceof CheckpointBarrier) {
-					barrierBuffer.processBarrier(bufferOrEvent);
-				} else {
-					if (handleEvent(event)) {
-						if (inputGate.isFinished()) {
-							if (!barrierBuffer.isEmpty()) {
-								throw new RuntimeException("BarrierBuffer should be empty at this point");
-							}
-							isFinished = true;
-							return false;
-						} else if (hasReachedEndOfSuperstep()) {
-							return false;
-						} // else: More data is coming...
-					}
+				if (handleEvent(event)) {
+					if (inputGate.isFinished()) {
+						if (!barrierBuffer.isEmpty()) {
+							throw new RuntimeException("BarrierBuffer should be empty at this point");
+						}
+						isFinished = true;
+						return false;
+					} else if (hasReachedEndOfSuperstep()) {
+						return false;
+					} // else: More data is coming...
 				}
 			}
 		}
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTask.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTask.java
index 9d6e88e375e8f..d0783206feb03 100644
--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTask.java
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/OneInputStreamTask.java
@@ -34,22 +34,27 @@
 
 	@Override
 	public void registerInputOutput() {
-		super.registerInputOutput();
-
-		TypeSerializer<IN> inSerializer = configuration.getTypeSerializerIn1(getUserCodeClassLoader());
-
-		int numberOfInputs = configuration.getNumberOfInputs();
-
-		if (numberOfInputs > 0) {
-			InputGate[] inputGates = getEnvironment().getAllInputGates();
-			inputProcessor = new StreamInputProcessor<IN>(inputGates, inSerializer, getExecutionConfig().areTimestampsEnabled());
-
-			inputProcessor.registerTaskEventListener(getCheckpointBarrierListener(), CheckpointBarrier.class);
-
-			AccumulatorRegistry registry = getEnvironment().getAccumulatorRegistry();
-			AccumulatorRegistry.Reporter reporter = registry.getReadWriteReporter();
-
-			inputProcessor.setReporter(reporter);
+		try {
+			super.registerInputOutput();
+			
+			TypeSerializer<IN> inSerializer = configuration.getTypeSerializerIn1(getUserCodeClassLoader());
+			int numberOfInputs = configuration.getNumberOfInputs();
+	
+			if (numberOfInputs > 0) {
+				InputGate[] inputGates = getEnvironment().getAllInputGates();
+				inputProcessor = new StreamInputProcessor<IN>(inputGates, inSerializer,
+						getCheckpointBarrierListener(), 
+						getEnvironment().getIOManager(),
+						getExecutionConfig().areTimestampsEnabled());
+	
+				// make sure that stream tasks report their I/O statistics
+				AccumulatorRegistry registry = getEnvironment().getAccumulatorRegistry();
+				AccumulatorRegistry.Reporter reporter = registry.getReadWriteReporter();
+				inputProcessor.setReporter(reporter);
+			}
+		}
+		catch (Exception e) {
+			throw new RuntimeException("Failed to initialize stream operator: " + e.getMessage(), e);
 		}
 	}
 
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
index 286202ffe9e46..73082d2d11df9 100644
--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/StreamTask.java
@@ -31,7 +31,6 @@
 import org.apache.flink.configuration.ConfigConstants;
 import org.apache.flink.configuration.GlobalConfiguration;
 import org.apache.flink.runtime.accumulators.AccumulatorRegistry;
-import org.apache.flink.runtime.event.task.TaskEvent;
 import org.apache.flink.runtime.execution.Environment;
 import org.apache.flink.runtime.jobgraph.tasks.AbstractInvokable;
 import org.apache.flink.runtime.jobgraph.tasks.CheckpointNotificationOperator;
@@ -74,7 +73,7 @@
 
 	protected ClassLoader userClassLoader;
 	
-	private EventListener<TaskEvent> checkpointBarrierListener;
+	private EventListener<CheckpointBarrier> checkpointBarrierListener;
 
 	public StreamTask() {
 		streamOperator = null;
@@ -106,7 +105,7 @@ public void registerInputOutput() {
 			streamOperator.setup(outputHandler.getOutput(), headContext);
 		}
 
-		hasChainedOperators = !(outputHandler.getChainedOperators().size() == 1);
+		hasChainedOperators = outputHandler.getChainedOperators().size() != 1;
 	}
 
 	public String getName() {
@@ -199,7 +198,7 @@ public void cancel() {
 		this.isRunning = false;
 	}
 
-	public EventListener<TaskEvent> getCheckpointBarrierListener() {
+	public EventListener<CheckpointBarrier> getCheckpointBarrierListener() {
 		return this.checkpointBarrierListener;
 	}
 
@@ -211,7 +210,7 @@ public EventListener<TaskEvent> getCheckpointBarrierListener() {
 	@Override
 	public void setInitialState(StateHandle<Serializable> stateHandle) throws Exception {
 
-		// We retrieve end restore the states for the chained oeprators.
+		// We retrieve end restore the states for the chained operators.
 		List<Tuple2<StateHandle<Serializable>, Map<String, PartitionedStateHandle>>> chainedStates = (List<Tuple2<StateHandle<Serializable>, Map<String, PartitionedStateHandle>>>) stateHandle.getState();
 
 		// We restore all stateful chained operators
@@ -310,13 +309,12 @@ public String toString() {
 
 	// ------------------------------------------------------------------------
 
-	private class CheckpointBarrierListener implements EventListener<TaskEvent> {
+	private class CheckpointBarrierListener implements EventListener<CheckpointBarrier> {
 
 		@Override
-		public void onEvent(TaskEvent event) {
+		public void onEvent(CheckpointBarrier barrier) {
 			try {
-				CheckpointBarrier sStep = (CheckpointBarrier) event;
-				triggerCheckpoint(sStep.getId(), sStep.getTimestamp());
+				triggerCheckpoint(barrier.getId(), barrier.getTimestamp());
 			}
 			catch (Exception e) {
 				throw new RuntimeException("Error triggering a checkpoint as the result of receiving checkpoint barrier", e);
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTask.java b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTask.java
index f981cd578ea71..b4667b2b90307 100644
--- a/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTask.java
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/main/java/org/apache/flink/streaming/runtime/tasks/TwoInputStreamTask.java
@@ -34,44 +34,52 @@
 
 	private static final Logger LOG = LoggerFactory.getLogger(TwoInputStreamTask.class);
 
-	StreamTwoInputProcessor<IN1, IN2> inputProcessor;
+	private StreamTwoInputProcessor<IN1, IN2> inputProcessor;
 
 	@Override
 	public void registerInputOutput() {
-		super.registerInputOutput();
-
-		TypeSerializer<IN1> inputDeserializer1 = configuration.getTypeSerializerIn1(userClassLoader);
-		TypeSerializer<IN2> inputDeserializer2 = configuration.getTypeSerializerIn2(userClassLoader);
-
-		int numberOfInputs = configuration.getNumberOfInputs();
-
-		ArrayList<InputGate> inputList1 = new ArrayList<InputGate>();
-		ArrayList<InputGate> inputList2 = new ArrayList<InputGate>();
-
-		List<StreamEdge> inEdges = configuration.getInPhysicalEdges(userClassLoader);
-
-		for (int i = 0; i < numberOfInputs; i++) {
-			int inputType = inEdges.get(i).getTypeNumber();
-			InputGate reader = getEnvironment().getInputGate(i);
-			switch (inputType) {
-				case 1:
-					inputList1.add(reader);
-					break;
-				case 2:
-					inputList2.add(reader);
-					break;
-				default:
-					throw new RuntimeException("Invalid input type number: " + inputType);
+		try {
+			super.registerInputOutput();
+	
+			TypeSerializer<IN1> inputDeserializer1 = configuration.getTypeSerializerIn1(userClassLoader);
+			TypeSerializer<IN2> inputDeserializer2 = configuration.getTypeSerializerIn2(userClassLoader);
+	
+			int numberOfInputs = configuration.getNumberOfInputs();
+	
+			ArrayList<InputGate> inputList1 = new ArrayList<InputGate>();
+			ArrayList<InputGate> inputList2 = new ArrayList<InputGate>();
+	
+			List<StreamEdge> inEdges = configuration.getInPhysicalEdges(userClassLoader);
+	
+			for (int i = 0; i < numberOfInputs; i++) {
+				int inputType = inEdges.get(i).getTypeNumber();
+				InputGate reader = getEnvironment().getInputGate(i);
+				switch (inputType) {
+					case 1:
+						inputList1.add(reader);
+						break;
+					case 2:
+						inputList2.add(reader);
+						break;
+					default:
+						throw new RuntimeException("Invalid input type number: " + inputType);
+				}
 			}
+	
+			this.inputProcessor = new StreamTwoInputProcessor<IN1, IN2>(inputList1, inputList2,
+					inputDeserializer1, inputDeserializer2,
+					getCheckpointBarrierListener(),
+					getEnvironment().getIOManager(),
+					getExecutionConfig().areTimestampsEnabled());
+
+			// make sure that stream tasks report their I/O statistics
+			AccumulatorRegistry registry = getEnvironment().getAccumulatorRegistry();
+			AccumulatorRegistry.Reporter reporter = registry.getReadWriteReporter();
+			this.inputProcessor.setReporter(reporter);
+		}
+		catch (Exception e) {
+			throw new RuntimeException("Failed to initialize stream operator: " + e.getMessage(), e);
 		}
-
-		inputProcessor = new StreamTwoInputProcessor<IN1, IN2>(inputList1, inputList2, inputDeserializer1, inputDeserializer2, getExecutionConfig().areTimestampsEnabled());
-
-		AccumulatorRegistry registry = getEnvironment().getAccumulatorRegistry();
-		AccumulatorRegistry.Reporter reporter = registry.getReadWriteReporter();
-		inputProcessor.setReporter(reporter);
-
-		inputProcessor.registerTaskEventListener(getCheckpointBarrierListener(), CheckpointBarrier.class);
 	}
 
 	@Override
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java b/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java
index a20436a0f40cb..06cee03509dfa 100644
--- a/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/runtime/io/network/partition/consumer/StreamTestSingleInputGate.java
@@ -20,11 +20,8 @@
 package org.apache.flink.runtime.io.network.partition.consumer;
 
 import org.apache.flink.api.common.typeutils.TypeSerializer;
-import org.apache.flink.core.memory.DataInputView;
-import org.apache.flink.core.memory.DataOutputView;
 import org.apache.flink.core.memory.MemorySegment;
 import org.apache.flink.runtime.event.task.AbstractEvent;
-import org.apache.flink.runtime.event.task.TaskEvent;
 import org.apache.flink.runtime.io.network.api.EndOfPartitionEvent;
 import org.apache.flink.runtime.io.network.api.serialization.EventSerializer;
 import org.apache.flink.runtime.io.network.api.serialization.RecordSerializer;
@@ -219,14 +216,4 @@ public boolean isEvent() {
 			return isEvent;
 		}
 	}
-
-	public static class DummyEvent extends TaskEvent {
-		@Override
-		public void write(DataOutputView out) throws IOException {
-		}
-
-		@Override
-		public void read(DataInputView in) throws IOException {
-		}
-	}
 }
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/BarrierBufferIOTest.java b/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/BarrierBufferMassiveRandomTest.java
similarity index 57%
rename from flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/BarrierBufferIOTest.java
rename to flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/BarrierBufferMassiveRandomTest.java
index d8a36967fbcd0..c2df4d83e2bc4 100644
--- a/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/BarrierBufferIOTest.java
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/BarrierBufferMassiveRandomTest.java
@@ -23,53 +23,71 @@
 import java.util.Random;
 
 import org.apache.flink.runtime.event.task.TaskEvent;
+import org.apache.flink.runtime.io.disk.iomanager.IOManager;
+import org.apache.flink.runtime.io.disk.iomanager.IOManagerAsync;
 import org.apache.flink.runtime.io.network.buffer.Buffer;
 import org.apache.flink.runtime.io.network.buffer.BufferPool;
 import org.apache.flink.runtime.io.network.buffer.NetworkBufferPool;
 import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;
 import org.apache.flink.runtime.io.network.partition.consumer.InputGate;
 import org.apache.flink.runtime.util.event.EventListener;
+import org.apache.flink.streaming.runtime.tasks.CheckpointBarrier;
+
 import org.junit.Test;
 
-public class BarrierBufferIOTest {
+/**
+ * The test generates two random streams (input channels) which independently
+ * and randomly generate checkpoint barriers. The two streams are very
+ * unaligned, putting heavy work on the BarrierBuffer.
+ */
+public class BarrierBufferMassiveRandomTest {
 
 	@Test
-	public void IOTest() throws IOException, InterruptedException {
-
-		BufferPool pool1 = new NetworkBufferPool(100, 1024).createBufferPool(100, true);
-		BufferPool pool2 = new NetworkBufferPool(100, 1024).createBufferPool(100, true);
-
-		MockInputGate myIG = new MockInputGate(new BufferPool[] { pool1, pool2 },
-				new BarrierGenerator[] { new CountBarrier(100000), new RandomBarrier(100000) });
-		// new BarrierSimulator[] { new CountBarrier(1000), new
-		// CountBarrier(1000) });
-
-		BarrierBuffer barrierBuffer = new BarrierBuffer(myIG,
-				new BarrierBufferTest.MockReader(myIG));
-
+	public void testWithTwoChannelsAndRandomBarriers() {
+		IOManager ioMan = null;
 		try {
-			// long time = System.currentTimeMillis();
+			ioMan = new IOManagerAsync();
+			
+			BufferPool pool1 = new NetworkBufferPool(100, 1024).createBufferPool(100, true);
+			BufferPool pool2 = new NetworkBufferPool(100, 1024).createBufferPool(100, true);
+
+			RandomGeneratingInputGate myIG = new RandomGeneratingInputGate(
+					new BufferPool[] { pool1, pool2 },
+					new BarrierGenerator[] { new CountBarrier(100000), new RandomBarrier(100000) });
+	
+			BarrierBuffer barrierBuffer = new BarrierBuffer(myIG, ioMan);
+			
 			for (int i = 0; i < 2000000; i++) {
 				BufferOrEvent boe = barrierBuffer.getNextNonBlocked();
 				if (boe.isBuffer()) {
 					boe.getBuffer().recycle();
-				} else {
-					barrierBuffer.processBarrier(boe);
 				}
 			}
-			// System.out.println("Ran for " + (System.currentTimeMillis() -
-			// time));
-		} catch (Exception e) {
-			fail();
-		} finally {
-			barrierBuffer.cleanup();
 		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+		finally {
+			if (ioMan != null) {
+				ioMan.shutdown();
+			}
+		}
+	}
+
+	// ------------------------------------------------------------------------
+	//  Mocks and Generators
+	// ------------------------------------------------------------------------
+	
+	protected interface BarrierGenerator {
+		public boolean isNextBarrier();
 	}
 
-	private static class RandomBarrier implements BarrierGenerator {
-		private static Random rnd = new Random();
+	protected static class RandomBarrier implements BarrierGenerator {
+		
+		private static final Random rnd = new Random();
 
-		double threshold;
+		private final double threshold;
 
 		public RandomBarrier(double expectedEvery) {
 			threshold = 1 / expectedEvery;
@@ -83,8 +101,8 @@ public boolean isNextBarrier() {
 
 	private static class CountBarrier implements BarrierGenerator {
 
-		long every;
-		long c = 0;
+		private final long every;
+		private long c = 0;
 
 		public CountBarrier(long every) {
 			this.every = every;
@@ -96,16 +114,16 @@ public boolean isNextBarrier() {
 		}
 	}
 
-	protected static class MockInputGate implements InputGate {
+	protected static class RandomGeneratingInputGate implements InputGate {
 
-		private int numChannels;
-		private BufferPool[] bufferPools;
-		private int[] currentBarriers;
-		BarrierGenerator[] barrierGens;
-		int currentChannel = 0;
-		long c = 0;
+		private final int numChannels;
+		private final BufferPool[] bufferPools;
+		private final int[] currentBarriers;
+		private final BarrierGenerator[] barrierGens;
+		private int currentChannel = 0;
+		private long c = 0;
 
-		public MockInputGate(BufferPool[] bufferPools, BarrierGenerator[] barrierGens) {
+		public RandomGeneratingInputGate(BufferPool[] bufferPools, BarrierGenerator[] barrierGens) {
 			this.numChannels = bufferPools.length;
 			this.currentBarriers = new int[numChannels];
 			this.bufferPools = bufferPools;
@@ -123,37 +141,27 @@ public boolean isFinished() {
 		}
 
 		@Override
-		public void requestPartitions() throws IOException, InterruptedException {
-		}
+		public void requestPartitions() {}
 
 		@Override
 		public BufferOrEvent getNextBufferOrEvent() throws IOException, InterruptedException {
 			currentChannel = (currentChannel + 1) % numChannels;
 
 			if (barrierGens[currentChannel].isNextBarrier()) {
-				return BarrierBufferTest.createBarrier(++currentBarriers[currentChannel],
-						currentChannel);
+				return new BufferOrEvent(
+						new CheckpointBarrier(++currentBarriers[currentChannel], System.currentTimeMillis()),
+							currentChannel);
 			} else {
 				Buffer buffer = bufferPools[currentChannel].requestBuffer();
 				buffer.getMemorySegment().putLong(0, c++);
-
 				return new BufferOrEvent(buffer, currentChannel);
 			}
-
 		}
 
 		@Override
-		public void sendTaskEvent(TaskEvent event) throws IOException {
-		}
+		public void sendTaskEvent(TaskEvent event) {}
 
 		@Override
-		public void registerListener(EventListener<InputGate> listener) {
-		}
-
-	}
-
-	protected interface BarrierGenerator {
-		public boolean isNextBarrier();
+		public void registerListener(EventListener<InputGate> listener) {}
 	}
-
 }
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/BarrierBufferTest.java b/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/BarrierBufferTest.java
index cb5e046e49f90..ad61c6fb49b43 100644
--- a/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/BarrierBufferTest.java
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/BarrierBufferTest.java
@@ -1,12 +1,13 @@
 /*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
  *
- *    http://www.apache.org/licenses/LICENSE-2.0
+ *     http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -17,152 +18,652 @@
 
 package org.apache.flink.streaming.runtime.io;
 
-import static org.junit.Assert.assertEquals;
-
-import java.io.IOException;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Queue;
-
-import org.apache.flink.api.common.accumulators.LongCounter;
 import org.apache.flink.core.memory.MemorySegment;
-import org.apache.flink.runtime.accumulators.AccumulatorRegistry;
 import org.apache.flink.runtime.event.task.TaskEvent;
+import org.apache.flink.runtime.io.disk.iomanager.IOManager;
+import org.apache.flink.runtime.io.disk.iomanager.IOManagerAsync;
 import org.apache.flink.runtime.io.network.api.EndOfPartitionEvent;
-import org.apache.flink.runtime.io.network.api.reader.AbstractReader;
 import org.apache.flink.runtime.io.network.buffer.Buffer;
-import org.apache.flink.runtime.io.network.buffer.BufferRecycler;
 import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;
 import org.apache.flink.runtime.io.network.partition.consumer.InputGate;
 import org.apache.flink.runtime.util.event.EventListener;
 import org.apache.flink.streaming.runtime.tasks.CheckpointBarrier;
 
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
 import org.junit.Test;
 
-public class BarrierBufferTest {
-
-	@Test
-	public void testWithoutBarriers() throws IOException, InterruptedException {
+import java.util.ArrayDeque;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Queue;
 
-		List<BufferOrEvent> input = new LinkedList<BufferOrEvent>();
-		input.add(createBuffer(0));
-		input.add(createBuffer(0));
-		input.add(createBuffer(0));
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
 
-		InputGate mockIG = new MockInputGate(1, input);
-		AbstractReader mockAR = new MockReader(mockIG);
+/**
+ * Tests for the behavior of the {@link BarrierBuffer}.
+ */
+public class BarrierBufferTest {
 
-		BarrierBuffer bb = new BarrierBuffer(mockIG, mockAR);
+	private static int SIZE_COUNTER = 0;
+	
+	private static IOManager IO_MANAGER;
 
-		assertEquals(input.get(0), bb.getNextNonBlocked());
-		assertEquals(input.get(1), bb.getNextNonBlocked());
-		assertEquals(input.get(2), bb.getNextNonBlocked());
+	@BeforeClass
+	public static void setup() {
+		IO_MANAGER = new IOManagerAsync();
+		SIZE_COUNTER = 1;
+	}
 
-		bb.cleanup();
+	@AfterClass
+	public static void shutdownIOManager() {
+		IO_MANAGER.shutdown();
 	}
 
+	// ------------------------------------------------------------------------
+	//  Tests
+	// ------------------------------------------------------------------------
+
+	/**
+	 * Validates that the buffer behaves correctly if no checkpoint barriers come,
+	 * for a single input channel.
+	 */
 	@Test
-	public void testOneChannelBarrier() throws IOException, InterruptedException {
+	public void testSingleChannelNoBarriers() {
+		try {
+			BufferOrEvent[] sequence = { 
+					createBuffer(0), createBuffer(0), createBuffer(0),
+					createEndOfPartition(0)
+			};
+
+			MockInputGate gate = new MockInputGate(1, Arrays.asList(sequence));
+			BarrierBuffer buffer = new BarrierBuffer(gate, IO_MANAGER);
+
+			for (BufferOrEvent boe : sequence) {
+				assertEquals(boe, buffer.getNextNonBlocked());
+			}
+			
+			assertNull(buffer.getNextNonBlocked());
+			assertNull(buffer.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
 
-		List<BufferOrEvent> input = new LinkedList<BufferOrEvent>();
-		input.add(createBuffer(0));
-		input.add(createBuffer(0));
-		input.add(createBarrier(1, 0));
-		input.add(createBuffer(0));
-		input.add(createBuffer(0));
-		input.add(createBarrier(2, 0));
-		input.add(createBuffer(0));
+	/**
+	 * Validates that the buffer behaves correctly if no checkpoint barriers come,
+	 * for an input with multiple input channels.
+	 */
+	@Test
+	public void testMultiChannelNoBarriers() {
+		try {
+			BufferOrEvent[] sequence = { createBuffer(2), createBuffer(2), createBuffer(0),
+					createBuffer(1), createBuffer(0), createEndOfPartition(0),
+					createBuffer(3), createBuffer(1), createEndOfPartition(3),
+					createBuffer(1), createEndOfPartition(1), createBuffer(2), createEndOfPartition(2)
+			};
+
+			MockInputGate gate = new MockInputGate(4, Arrays.asList(sequence));
+			BarrierBuffer buffer = new BarrierBuffer(gate, IO_MANAGER);
+
+			for (BufferOrEvent boe : sequence) {
+				assertEquals(boe, buffer.getNextNonBlocked());
+			}
+
+			assertNull(buffer.getNextNonBlocked());
+			assertNull(buffer.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
 
-		InputGate mockIG = new MockInputGate(1, input);
-		AbstractReader mockAR = new MockReader(mockIG);
+	/**
+	 * Validates that the buffer preserved the order of elements for a 
+	 * input with a single input channel, and checkpoint events.
+	 */
+	@Test
+	public void testSingleChannelWithBarriers() {
+		try {
+			BufferOrEvent[] sequence = {
+					createBuffer(0), createBuffer(0), createBuffer(0),
+					createBarrier(1, 0),
+					createBuffer(0), createBuffer(0), createBuffer(0), createBuffer(0),
+					createBarrier(2, 0), createBarrier(3, 0),
+					createBuffer(0), createBuffer(0),
+					createBarrier(4, 0), createBarrier(5, 0), createBarrier(6, 0),
+					createBuffer(0), createEndOfPartition(0)
+			};
+
+			MockInputGate gate = new MockInputGate(1, Arrays.asList(sequence));
+			BarrierBuffer buffer = new BarrierBuffer(gate, IO_MANAGER);
+
+			ValidatingCheckpointHandler handler = new ValidatingCheckpointHandler();
+			buffer.registerCheckpointEventHandler(handler);
+			handler.setNextExpectedCheckpointId(1L);
+			
+			for (BufferOrEvent boe : sequence) {
+				if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
+					assertEquals(boe, buffer.getNextNonBlocked());
+				}
+			}
+
+			assertNull(buffer.getNextNonBlocked());
+			assertNull(buffer.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
 
-		BarrierBuffer bb = new BarrierBuffer(mockIG, mockAR);
-		BufferOrEvent nextBoe;
+	/**
+	 * Validates that the buffer correctly aligns the streams for inputs with
+	 * multiple input channels, by buffering and blocking certain inputs.
+	 */
+	@Test
+	public void testMultiChannelWithBarriers() {
+		try {
+			BufferOrEvent[] sequence = {
+					// checkpoint with blocked data
+					createBuffer(0), createBuffer(2), createBuffer(0),
+					createBarrier(1, 1), createBarrier(1, 2),
+					createBuffer(2), createBuffer(1), createBuffer(0),
+					createBarrier(1, 0),
+					
+					// checkpoint without blocked data
+					createBuffer(0), createBuffer(0), createBuffer(1), createBuffer(1), createBuffer(2),
+					createBarrier(2, 0), createBarrier(2, 1), createBarrier(2, 2),
+					
+					// checkpoint with data only from one channel
+					createBuffer(2), createBuffer(2),
+					createBarrier(3, 2),
+					createBuffer(2), createBuffer(2),
+					createBarrier(3, 0), createBarrier(3, 1),
+					
+					// empty checkpoint
+					createBarrier(4, 1), createBarrier(4, 2), createBarrier(4, 0),
+
+					// checkpoint with blocked data in mixed order
+					createBuffer(0), createBuffer(2), createBuffer(0),
+					createBarrier(5, 1),
+					createBuffer(2), createBuffer(0), createBuffer(2), createBuffer(1),
+					createBarrier(5, 2),
+					createBuffer(1), createBuffer(0), createBuffer(2), createBuffer(1),
+					createBarrier(5, 0),
+					
+					// some trailing data
+					createBuffer(0),
+					createEndOfPartition(0), createEndOfPartition(1), createEndOfPartition(2)
+			};
+
+			MockInputGate gate = new MockInputGate(3, Arrays.asList(sequence));
+			BarrierBuffer buffer = new BarrierBuffer(gate, IO_MANAGER);
+
+			ValidatingCheckpointHandler handler = new ValidatingCheckpointHandler();
+			buffer.registerCheckpointEventHandler(handler);
+			handler.setNextExpectedCheckpointId(1L);
+			
+			// pre checkpoint 1
+			check(sequence[0], buffer.getNextNonBlocked());
+			check(sequence[1], buffer.getNextNonBlocked());
+			check(sequence[2], buffer.getNextNonBlocked());
+			assertEquals(1L, handler.getNextExpectedCheckpointId());
+
+			// blocking while aligning for checkpoint 1
+			check(sequence[7], buffer.getNextNonBlocked());
+			assertEquals(1L, handler.getNextExpectedCheckpointId());
+
+			// checkpoint 1 done, returning buffered data
+			check(sequence[5], buffer.getNextNonBlocked());
+			assertEquals(2L, handler.getNextExpectedCheckpointId());
+			check(sequence[6], buffer.getNextNonBlocked());
+
+			// pre checkpoint 2
+			check(sequence[9], buffer.getNextNonBlocked());
+			check(sequence[10], buffer.getNextNonBlocked());
+			check(sequence[11], buffer.getNextNonBlocked());
+			check(sequence[12], buffer.getNextNonBlocked());
+			check(sequence[13], buffer.getNextNonBlocked());
+			assertEquals(2L, handler.getNextExpectedCheckpointId());
+			
+			// checkpoint 2 barriers come together
+			check(sequence[17], buffer.getNextNonBlocked());
+			assertEquals(3L, handler.getNextExpectedCheckpointId());
+			check(sequence[18], buffer.getNextNonBlocked());
+
+			// checkpoint 3 starts, data buffered
+			check(sequence[20], buffer.getNextNonBlocked());
+			assertEquals(4L, handler.getNextExpectedCheckpointId());
+			check(sequence[21], buffer.getNextNonBlocked());
+
+			// checkpoint 4 happens without extra data
+			
+			// pre checkpoint 5
+			check(sequence[27], buffer.getNextNonBlocked());
+			assertEquals(5L, handler.getNextExpectedCheckpointId());
+			check(sequence[28], buffer.getNextNonBlocked());
+			check(sequence[29], buffer.getNextNonBlocked());
+			
+			// checkpoint 5 aligning
+			check(sequence[31], buffer.getNextNonBlocked());
+			check(sequence[32], buffer.getNextNonBlocked());
+			check(sequence[33], buffer.getNextNonBlocked());
+			check(sequence[37], buffer.getNextNonBlocked());
+			
+			// buffered data from checkpoint 5 alignment
+			check(sequence[34], buffer.getNextNonBlocked());
+			check(sequence[36], buffer.getNextNonBlocked());
+			check(sequence[38], buffer.getNextNonBlocked());
+			check(sequence[39], buffer.getNextNonBlocked());
+			
+			// remaining data
+			check(sequence[41], buffer.getNextNonBlocked());
+			check(sequence[42], buffer.getNextNonBlocked());
+			check(sequence[43], buffer.getNextNonBlocked());
+			check(sequence[44], buffer.getNextNonBlocked());
+			
+			assertNull(buffer.getNextNonBlocked());
+			assertNull(buffer.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
 
-		assertEquals(input.get(0), nextBoe = bb.getNextNonBlocked());
-		assertEquals(input.get(1), nextBoe = bb.getNextNonBlocked());
-		assertEquals(input.get(2), nextBoe = bb.getNextNonBlocked());
-		bb.processBarrier(nextBoe);
-		assertEquals(input.get(3), nextBoe = bb.getNextNonBlocked());
-		assertEquals(input.get(4), nextBoe = bb.getNextNonBlocked());
-		assertEquals(input.get(5), nextBoe = bb.getNextNonBlocked());
-		bb.processBarrier(nextBoe);
-		assertEquals(input.get(6), nextBoe = bb.getNextNonBlocked());
+	@Test
+	public void testMultiChannelTrailingBlockedData() {
+		try {
+			BufferOrEvent[] sequence = {
+					createBuffer(0), createBuffer(1), createBuffer(2),
+					createBarrier(1, 1), createBarrier(1, 2), createBarrier(1, 0),
+					
+					createBuffer(2), createBuffer(1), createBuffer(0),
+					createBarrier(2, 1),
+					createBuffer(1), createBuffer(1), createEndOfPartition(1), createBuffer(0), createBuffer(2),
+					createBarrier(2, 2),
+					createBuffer(2), createEndOfPartition(2), createBuffer(0), createEndOfPartition(0)
+			};
+
+			MockInputGate gate = new MockInputGate(3, Arrays.asList(sequence));
+			BarrierBuffer buffer = new BarrierBuffer(gate, IO_MANAGER);
+
+			ValidatingCheckpointHandler handler = new ValidatingCheckpointHandler();
+			buffer.registerCheckpointEventHandler(handler);
+			handler.setNextExpectedCheckpointId(1L);
+
+			// pre-checkpoint 1
+			check(sequence[0], buffer.getNextNonBlocked());
+			check(sequence[1], buffer.getNextNonBlocked());
+			check(sequence[2], buffer.getNextNonBlocked());
+			assertEquals(1L, handler.getNextExpectedCheckpointId());
+
+			// pre-checkpoint 2
+			check(sequence[6], buffer.getNextNonBlocked());
+			assertEquals(2L, handler.getNextExpectedCheckpointId());
+			check(sequence[7], buffer.getNextNonBlocked());
+			check(sequence[8], buffer.getNextNonBlocked());
+			
+			// checkpoint 2 alignment
+			check(sequence[13], buffer.getNextNonBlocked());
+			check(sequence[14], buffer.getNextNonBlocked());
+			check(sequence[18], buffer.getNextNonBlocked());
+			check(sequence[19], buffer.getNextNonBlocked());
+
+			// end of stream: remaining buffered contents
+			check(sequence[10], buffer.getNextNonBlocked());
+			check(sequence[11], buffer.getNextNonBlocked());
+			check(sequence[12], buffer.getNextNonBlocked());
+			check(sequence[16], buffer.getNextNonBlocked());
+			check(sequence[17], buffer.getNextNonBlocked());
+
+			assertNull(buffer.getNextNonBlocked());
+			assertNull(buffer.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
 
-		bb.cleanup();
+	/**
+	 * Validates that the buffer correctly aligns the streams in cases
+	 * where some channels receive barriers from multiple successive checkpoints
+	 * before the pending checkpoint is complete.
+	 */
+	@Test
+	public void testMultiChannelWithQueuedFutureBarriers() {
+		try {
+			BufferOrEvent[] sequence = {
+					// checkpoint 1 - with blocked data
+					createBuffer(0), createBuffer(2), createBuffer(0),
+					createBarrier(1, 1), createBarrier(1, 2),
+					createBuffer(2), createBuffer(1), createBuffer(0),
+					createBarrier(1, 0),
+					createBuffer(1), createBuffer(0),
+
+					// checkpoint 2 - where future checkpoint barriers come before
+					// the current checkpoint is complete
+					createBarrier(2, 1),
+					createBuffer(1), createBuffer(2), createBarrier(2, 0),
+					createBarrier(3, 0), createBuffer(0),
+					createBarrier(3, 1), createBuffer(0), createBuffer(1), createBuffer(2),
+					createBarrier(4, 1), createBuffer(1), createBuffer(2),
+
+					// complete checkpoint 2, send a barrier for checkpoints 4 and 5
+					createBarrier(2, 2),
+					createBuffer(2), createBuffer(1), createBuffer(2), createBuffer(0),
+					createBarrier(4, 0),
+					createBuffer(2), createBuffer(1), createBuffer(2), createBuffer(0),
+					createBarrier(5, 1),
+
+					// complete checkpoint 3
+					createBarrier(3, 2),
+					createBuffer(2), createBuffer(1), createBuffer(2), createBuffer(0),
+					createBarrier(6, 1),
+					
+					// complete checkpoint 4, checkpoint 5 remains not fully triggered
+					createBarrier(4, 2),
+					createBuffer(2),
+					createBuffer(1), createEndOfPartition(1),
+					createBuffer(2), createEndOfPartition(2),
+					createBuffer(0), createEndOfPartition(0)
+			};
+
+			MockInputGate gate = new MockInputGate(3, Arrays.asList(sequence));
+			BarrierBuffer buffer = new BarrierBuffer(gate, IO_MANAGER);
+
+			ValidatingCheckpointHandler handler = new ValidatingCheckpointHandler();
+			buffer.registerCheckpointEventHandler(handler);
+			handler.setNextExpectedCheckpointId(1L);
+
+			// around checkpoint 1
+			check(sequence[0], buffer.getNextNonBlocked());
+			check(sequence[1], buffer.getNextNonBlocked());
+			check(sequence[2], buffer.getNextNonBlocked());
+			check(sequence[7], buffer.getNextNonBlocked());
+			
+			check(sequence[5], buffer.getNextNonBlocked());
+			assertEquals(2L, handler.getNextExpectedCheckpointId());
+			check(sequence[6], buffer.getNextNonBlocked());
+			check(sequence[9], buffer.getNextNonBlocked());
+			check(sequence[10], buffer.getNextNonBlocked());
+
+			// alignment of checkpoint 2 - buffering also some barriers for
+			// checkpoints 3 and 4
+			check(sequence[13], buffer.getNextNonBlocked());
+			check(sequence[20], buffer.getNextNonBlocked());
+			check(sequence[23], buffer.getNextNonBlocked());
+			
+			// checkpoint 2 completed
+			check(sequence[12], buffer.getNextNonBlocked());
+			check(sequence[25], buffer.getNextNonBlocked());
+			check(sequence[27], buffer.getNextNonBlocked());
+			check(sequence[30], buffer.getNextNonBlocked());
+			check(sequence[32], buffer.getNextNonBlocked());
+
+			// checkpoint 3 completed (emit buffered)
+			check(sequence[16], buffer.getNextNonBlocked());
+			check(sequence[18], buffer.getNextNonBlocked());
+			check(sequence[19], buffer.getNextNonBlocked());
+			check(sequence[28], buffer.getNextNonBlocked());
+			
+			// past checkpoint 3
+			check(sequence[36], buffer.getNextNonBlocked());
+			check(sequence[38], buffer.getNextNonBlocked());
+
+			// checkpoint 4 completed (emit buffered)
+			check(sequence[22], buffer.getNextNonBlocked());
+			check(sequence[26], buffer.getNextNonBlocked());
+			check(sequence[31], buffer.getNextNonBlocked());
+			check(sequence[33], buffer.getNextNonBlocked());
+			check(sequence[39], buffer.getNextNonBlocked());
+			
+			// past checkpoint 4, alignment for checkpoint 5
+			check(sequence[42], buffer.getNextNonBlocked());
+			check(sequence[45], buffer.getNextNonBlocked());
+			check(sequence[46], buffer.getNextNonBlocked());
+			check(sequence[47], buffer.getNextNonBlocked());
+			check(sequence[48], buffer.getNextNonBlocked());
+			
+			// end of input, emit remainder
+			check(sequence[37], buffer.getNextNonBlocked());
+			check(sequence[43], buffer.getNextNonBlocked());
+			check(sequence[44], buffer.getNextNonBlocked());
+			
+			assertNull(buffer.getNextNonBlocked());
+			assertNull(buffer.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
 	}
 
+	/**
+	 * Validates that the buffer skips over the current checkpoint if it
+	 * receives a barrier from a later checkpoint on a non-blocked input.
+	 */
 	@Test
-	public void testMultiChannelBarrier() throws IOException, InterruptedException {
-
-		List<BufferOrEvent> input = new LinkedList<BufferOrEvent>();
-		input.add(createBuffer(0));
-		input.add(createBuffer(1));
-		input.add(createBarrier(1, 0));
-		input.add(createBarrier(2, 0));
-		input.add(createBuffer(0));
-		input.add(createBarrier(3, 0));
-		input.add(createBuffer(0));
-		input.add(createBuffer(1));
-		input.add(createBarrier(1, 1));
-		input.add(createBuffer(0));
-		input.add(createBuffer(1));
-		input.add(createBarrier(2, 1));
-		input.add(createBarrier(3, 1));
-		input.add(createBarrier(4, 0));
-		input.add(createBuffer(0));
-		input.add(new BufferOrEvent(new EndOfPartitionEvent(), 1));
-		
+	public void testMultiChannelSkippingCheckpoints() {
+		try {
+			BufferOrEvent[] sequence = {
+					// checkpoint 1 - with blocked data
+					createBuffer(0), createBuffer(2), createBuffer(0),
+					createBarrier(1, 1), createBarrier(1, 2),
+					createBuffer(2), createBuffer(1), createBuffer(0),
+					createBarrier(1, 0),
+					createBuffer(1), createBuffer(0),
+
+					// checkpoint 2 will not complete: pre-mature barrier from checkpoint 3
+					createBarrier(2, 1),
+					createBuffer(1), createBuffer(2),
+					createBarrier(2, 0),
+					createBuffer(2), createBuffer(0),
+					createBarrier(3, 2),
+					
+					createBuffer(2),
+					createBuffer(1), createEndOfPartition(1),
+					createBuffer(2), createEndOfPartition(2),
+					createBuffer(0), createEndOfPartition(0)
+			};
+
+			MockInputGate gate = new MockInputGate(3, Arrays.asList(sequence));
+			BarrierBuffer buffer = new BarrierBuffer(gate, IO_MANAGER);
+
+			ValidatingCheckpointHandler handler = new ValidatingCheckpointHandler();
+			buffer.registerCheckpointEventHandler(handler);
+			handler.setNextExpectedCheckpointId(1L);
+
+			// checkpoint 1
+			check(sequence[0], buffer.getNextNonBlocked());
+			check(sequence[1], buffer.getNextNonBlocked());
+			check(sequence[2], buffer.getNextNonBlocked());
+			check(sequence[7], buffer.getNextNonBlocked());
+			assertEquals(1L, buffer.getCurrentCheckpointId());
+			
+			check(sequence[5], buffer.getNextNonBlocked());
+			check(sequence[6], buffer.getNextNonBlocked());
+			check(sequence[9], buffer.getNextNonBlocked());
+			check(sequence[10], buffer.getNextNonBlocked());
+
+			// alignment of checkpoint 2
+			check(sequence[13], buffer.getNextNonBlocked());
+			assertEquals(2L, buffer.getCurrentCheckpointId());
+			check(sequence[15], buffer.getNextNonBlocked());
+
+			// checkpoint 2 aborted, checkpoint 3 started
+			check(sequence[12], buffer.getNextNonBlocked());
+			assertEquals(3L, buffer.getCurrentCheckpointId());
+			check(sequence[16], buffer.getNextNonBlocked());
+			check(sequence[19], buffer.getNextNonBlocked());
+			check(sequence[20], buffer.getNextNonBlocked());
+			check(sequence[23], buffer.getNextNonBlocked());
+			check(sequence[24], buffer.getNextNonBlocked());
+
+			// end of input, emit remainder
+			check(sequence[18], buffer.getNextNonBlocked());
+			check(sequence[21], buffer.getNextNonBlocked());
+			check(sequence[22], buffer.getNextNonBlocked());
+
+			assertNull(buffer.getNextNonBlocked());
+			assertNull(buffer.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
 
-		InputGate mockIG1 = new MockInputGate(2, input);
-		AbstractReader mockAR1 = new MockReader(mockIG1);
+	/**
+	 * Validates that the buffer skips over a later checkpoint if it
+	 * receives a barrier from an even later checkpoint on a blocked input.
+	 * 
+	 * NOTE: This test currently fails, because the barrier buffer does not support
+	 * to unblock inputs before all previously unblocked data is consumed.
+	 * 
+	 * Since this test checks only that the buffer behaves "failsafe" in cases of
+	 * corrupt checkpoint barrier propagation (a situation that does not occur
+	 * under the current model), we ignore it for the moment.
+	 */
+//	@Test
+	public void testMultiChannelSkippingCheckpointsViaBlockedInputs() {
+		try {
+			BufferOrEvent[] sequence = {
+					// checkpoint 1 - with blocked data
+					createBuffer(0), createBuffer(2), createBuffer(0),
+					createBarrier(1, 1), createBarrier(1, 2),
+					createBuffer(2), createBuffer(1), createBuffer(0),
+					createBarrier(1, 0),
+					createBuffer(1), createBuffer(0),
+
+					// checkpoint 2 will not complete: pre-mature barrier from checkpoint 3
+					createBarrier(2, 1),
+					createBuffer(1), createBuffer(2),
+					createBarrier(2, 0),
+					createBuffer(1), createBuffer(0),
+
+					createBarrier(4, 1), // pre-mature barrier on blocked input
+					createBarrier(3, 0), // queued barrier, ignored on replay
+
+					// complete checkpoint 2
+					createBarrier(2, 0),
+					createBuffer(0),
+					
+					createBarrier(3, 2), // should be ignored
+					createBuffer(2),
+					createBarrier(4, 0),
+					createBuffer(0), createBuffer(1), createBuffer(2),
+					createBarrier(4, 1),
+					
+					createBuffer(1), createEndOfPartition(1),
+					createBuffer(2), createEndOfPartition(2),
+					createBuffer(0), createEndOfPartition(0)
+			};
+
+			MockInputGate gate = new MockInputGate(3, Arrays.asList(sequence));
+			BarrierBuffer buffer = new BarrierBuffer(gate, IO_MANAGER);
+
+			// checkpoint 1
+			check(sequence[0], buffer.getNextNonBlocked());
+			check(sequence[1], buffer.getNextNonBlocked());
+			check(sequence[2], buffer.getNextNonBlocked());
+			check(sequence[7], buffer.getNextNonBlocked());
+			assertEquals(1L, buffer.getCurrentCheckpointId());
+			check(sequence[5], buffer.getNextNonBlocked());
+			check(sequence[6], buffer.getNextNonBlocked());
+			check(sequence[9], buffer.getNextNonBlocked());
+			check(sequence[10], buffer.getNextNonBlocked());
+
+			// alignment of checkpoint 2
+			check(sequence[13], buffer.getNextNonBlocked());
+			assertEquals(2L, buffer.getCurrentCheckpointId());
+
+			// checkpoint 2 completed
+			check(sequence[12], buffer.getNextNonBlocked());
+			check(sequence[15], buffer.getNextNonBlocked());
+			check(sequence[16], buffer.getNextNonBlocked());
+			
+			// checkpoint 3 skipped, alignment for 4 started
+			check(sequence[20], buffer.getNextNonBlocked());
+			assertEquals(4L, buffer.getCurrentCheckpointId());
+			check(sequence[22], buffer.getNextNonBlocked());
+			check(sequence[26], buffer.getNextNonBlocked());
+
+			// checkpoint 4 completed
+			check(sequence[24], buffer.getNextNonBlocked());
+			check(sequence[25], buffer.getNextNonBlocked());
+
+			check(sequence[28], buffer.getNextNonBlocked());
+			check(sequence[29], buffer.getNextNonBlocked());
+			check(sequence[30], buffer.getNextNonBlocked());
+			check(sequence[31], buffer.getNextNonBlocked());
+			check(sequence[32], buffer.getNextNonBlocked());
+			check(sequence[33], buffer.getNextNonBlocked());
+			
+			assertNull(buffer.getNextNonBlocked());
+			assertNull(buffer.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
 
-		BarrierBuffer bb = new BarrierBuffer(mockIG1, mockAR1);
-		BufferOrEvent nextBoe;
+	// ------------------------------------------------------------------------
+	//  Utils
+	// ------------------------------------------------------------------------
 
-		check(input.get(0), nextBoe = bb.getNextNonBlocked());
-		check(input.get(1), nextBoe = bb.getNextNonBlocked());
-		check(input.get(2), nextBoe = bb.getNextNonBlocked());
-		bb.processBarrier(nextBoe);
-		check(input.get(7), nextBoe = bb.getNextNonBlocked());
-		check(input.get(8), nextBoe = bb.getNextNonBlocked());
-		bb.processBarrier(nextBoe);
-		check(input.get(3), nextBoe = bb.getNextNonBlocked());
-		bb.processBarrier(nextBoe);
-		check(input.get(10), nextBoe = bb.getNextNonBlocked());
-		check(input.get(11), nextBoe = bb.getNextNonBlocked());
-		bb.processBarrier(nextBoe);
-		check(input.get(4), nextBoe = bb.getNextNonBlocked());
-		check(input.get(5), nextBoe = bb.getNextNonBlocked());
-		bb.processBarrier(nextBoe);
-		check(input.get(12), nextBoe = bb.getNextNonBlocked());
-		bb.processBarrier(nextBoe);
-		check(input.get(6), nextBoe = bb.getNextNonBlocked());
-		check(input.get(9), nextBoe = bb.getNextNonBlocked());
-		check(input.get(13), nextBoe = bb.getNextNonBlocked());
-		bb.processBarrier(nextBoe);
-		check(input.get(14), nextBoe = bb.getNextNonBlocked());
-		check(input.get(15), nextBoe = bb.getNextNonBlocked());
+	private static BufferOrEvent createBarrier(long id, int channel) {
+		return new BufferOrEvent(new CheckpointBarrier(id, System.currentTimeMillis()), channel);
+	}
 
-		bb.cleanup();
+	private static BufferOrEvent createBuffer(int channel) {
+		// since we have no access to the contents, we need to use the size as an
+		// identifier to validate correctness here
+		return new BufferOrEvent(
+				new Buffer(new MemorySegment(new byte[SIZE_COUNTER++]),  DummyBufferRecycler.INSTANCE), channel);
 	}
 
-	private static void check(BufferOrEvent expected, BufferOrEvent actual) {
-		assertEquals(expected.isBuffer(), actual.isBuffer());
-		assertEquals(expected.getChannelIndex(), actual.getChannelIndex());
-		if (expected.isEvent()) {
-			assertEquals(expected.getEvent(), actual.getEvent());
+	private static BufferOrEvent createEndOfPartition(int channel) {
+		return new BufferOrEvent(EndOfPartitionEvent.INSTANCE, channel);
+	}
+	
+	private static void check(BufferOrEvent expected, BufferOrEvent present) {
+		assertNotNull(expected);
+		assertNotNull(present);
+		assertEquals(expected.isBuffer(), present.isBuffer());
+		
+		if (expected.isBuffer()) {
+			// since we have no access to the contents, we need to use the size as an
+			// identifier to validate correctness here
+			assertEquals(expected.getBuffer().getSize(), present.getBuffer().getSize());
+		}
+		else {
+			assertEquals(expected.getEvent(), present.getEvent());
 		}
 	}
+	
+	// ------------------------------------------------------------------------
+	//  Testing Mocks
+	// ------------------------------------------------------------------------
 
-	protected static class MockInputGate implements InputGate {
+	private static class MockInputGate implements InputGate {
 
-		private int numChannels;
-		private Queue<BufferOrEvent> boes;
+		private final int numChannels;
+		private final Queue<BufferOrEvent> boes;
 
 		public MockInputGate(int numChannels, List<BufferOrEvent> boes) {
 			this.numChannels = numChannels;
-			this.boes = new LinkedList<BufferOrEvent>(boes);
+			this.boes = new ArrayDeque<BufferOrEvent>(boes);
 		}
 
 		@Override
@@ -176,48 +677,38 @@ public boolean isFinished() {
 		}
 
 		@Override
-		public void requestPartitions() throws IOException, InterruptedException {
-		}
+		public void requestPartitions() {}
 
 		@Override
-		public BufferOrEvent getNextBufferOrEvent() throws IOException, InterruptedException {
-			return boes.remove();
+		public BufferOrEvent getNextBufferOrEvent() {
+			return boes.poll();
 		}
 
 		@Override
-		public void sendTaskEvent(TaskEvent event) throws IOException {
-		}
+		public void sendTaskEvent(TaskEvent event) {}
 
 		@Override
-		public void registerListener(EventListener<InputGate> listener) {
-		}
-
+		public void registerListener(EventListener<InputGate> listener) {}
 	}
 
-	protected static class MockReader extends AbstractReader {
+	private static class ValidatingCheckpointHandler implements EventListener<CheckpointBarrier> {
+		
+		private long nextExpectedCheckpointId = -1L;
 
-		protected MockReader(InputGate inputGate) {
-			super(inputGate);
+		public void setNextExpectedCheckpointId(long nextExpectedCheckpointId) {
+			this.nextExpectedCheckpointId = nextExpectedCheckpointId;
 		}
 
-		@Override
-		public void setReporter(AccumulatorRegistry.Reporter reporter) {
-
+		public long getNextExpectedCheckpointId() {
+			return nextExpectedCheckpointId;
 		}
-	}
-
-	protected static BufferOrEvent createBarrier(long id, int channel) {
-		return new BufferOrEvent(new CheckpointBarrier(id, System.currentTimeMillis()), channel);
-	}
 
-	protected static BufferOrEvent createBuffer(int channel) {
-		return new BufferOrEvent(new Buffer(new MemorySegment(new byte[] { 1 }),
-				new BufferRecycler() {
-
-					@Override
-					public void recycle(MemorySegment memorySegment) {
-					}
-				}), channel);
+		@Override
+		public void onEvent(CheckpointBarrier barrier) {
+			assertNotNull(barrier);
+			assertTrue("wrong checkpoint id", nextExpectedCheckpointId == -1L || nextExpectedCheckpointId == barrier.getId());
+			assertTrue(barrier.getTimestamp() > 0);
+			nextExpectedCheckpointId++;
+		}
 	}
-
 }
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/BarrierTrackerTest.java b/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/BarrierTrackerTest.java
new file mode 100644
index 0000000000000..b2c570e409070
--- /dev/null
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/BarrierTrackerTest.java
@@ -0,0 +1,404 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.streaming.runtime.io;
+
+import org.apache.flink.core.memory.MemorySegment;
+import org.apache.flink.runtime.event.task.TaskEvent;
+import org.apache.flink.runtime.io.network.buffer.Buffer;
+import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;
+import org.apache.flink.runtime.io.network.partition.consumer.InputGate;
+import org.apache.flink.runtime.util.event.EventListener;
+import org.apache.flink.streaming.runtime.tasks.CheckpointBarrier;
+
+import org.junit.Test;
+
+import java.util.ArrayDeque;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Queue;
+
+import static org.junit.Assert.*;
+
+/**
+ * Tests for the behavior of the barrier tracker.
+ */
+public class BarrierTrackerTest {
+
+	@Test
+	public void testSingleChannelNoBarriers() {
+		try {
+			BufferOrEvent[] sequence = { createBuffer(0), createBuffer(0), createBuffer(0) };
+
+			MockInputGate gate = new MockInputGate(1, Arrays.asList(sequence));
+			BarrierTracker tracker = new BarrierTracker(gate);
+
+			for (BufferOrEvent boe : sequence) {
+				assertEquals(boe, tracker.getNextNonBlocked());
+			}
+			
+			assertNull(tracker.getNextNonBlocked());
+			assertNull(tracker.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+
+	@Test
+	public void testMultiChannelNoBarriers() {
+		try {
+			BufferOrEvent[] sequence = { createBuffer(2), createBuffer(2), createBuffer(0),
+					createBuffer(1), createBuffer(0), createBuffer(3),
+					createBuffer(1), createBuffer(1), createBuffer(2)
+			};
+
+			MockInputGate gate = new MockInputGate(4, Arrays.asList(sequence));
+			BarrierTracker tracker = new BarrierTracker(gate);
+
+			for (BufferOrEvent boe : sequence) {
+				assertEquals(boe, tracker.getNextNonBlocked());
+			}
+
+			assertNull(tracker.getNextNonBlocked());
+			assertNull(tracker.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+
+	@Test
+	public void testSingleChannelWithBarriers() {
+		try {
+			BufferOrEvent[] sequence = {
+					createBuffer(0), createBuffer(0), createBuffer(0),
+					createBarrier(1, 0),
+					createBuffer(0), createBuffer(0), createBuffer(0), createBuffer(0),
+					createBarrier(2, 0), createBarrier(3, 0),
+					createBuffer(0), createBuffer(0),
+					createBarrier(4, 0), createBarrier(5, 0), createBarrier(6, 0),
+					createBuffer(0)
+			};
+
+			MockInputGate gate = new MockInputGate(1, Arrays.asList(sequence));
+			BarrierTracker tracker = new BarrierTracker(gate);
+
+			CheckpointSequenceValidator validator =
+					new CheckpointSequenceValidator(1, 2, 3, 4, 5, 6);
+			tracker.registerCheckpointEventHandler(validator);
+			
+			for (BufferOrEvent boe : sequence) {
+				if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
+					assertEquals(boe, tracker.getNextNonBlocked());
+				}
+			}
+
+			assertNull(tracker.getNextNonBlocked());
+			assertNull(tracker.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+
+	@Test
+	public void testSingleChannelWithSkippedBarriers() {
+		try {
+			BufferOrEvent[] sequence = {
+					createBuffer(0),
+					createBarrier(1, 0),
+					createBuffer(0), createBuffer(0),
+					createBarrier(3, 0), createBuffer(0),
+					createBarrier(4, 0), createBarrier(6, 0), createBuffer(0),
+					createBarrier(7, 0), createBuffer(0), createBarrier(10, 0),
+					createBuffer(0)
+			};
+
+			MockInputGate gate = new MockInputGate(1, Arrays.asList(sequence));
+			BarrierTracker tracker = new BarrierTracker(gate);
+
+			CheckpointSequenceValidator validator =
+					new CheckpointSequenceValidator(1, 3, 4, 6, 7, 10);
+			tracker.registerCheckpointEventHandler(validator);
+
+			for (BufferOrEvent boe : sequence) {
+				if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
+					assertEquals(boe, tracker.getNextNonBlocked());
+				}
+			}
+
+			assertNull(tracker.getNextNonBlocked());
+			assertNull(tracker.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+
+	@Test
+	public void testMultiChannelWithBarriers() {
+		try {
+			BufferOrEvent[] sequence = {
+					createBuffer(0), createBuffer(2), createBuffer(0),
+					createBarrier(1, 1), createBarrier(1, 2),
+					createBuffer(2), createBuffer(1),
+					createBarrier(1, 0),
+					
+					createBuffer(0), createBuffer(0), createBuffer(1), createBuffer(1), createBuffer(2),
+					createBarrier(2, 0), createBarrier(2, 1), createBarrier(2, 2),
+					
+					createBuffer(2), createBuffer(2),
+					createBarrier(3, 2),
+					createBuffer(2), createBuffer(2),
+					createBarrier(3, 0), createBarrier(3, 1),
+					
+					createBarrier(4, 1), createBarrier(4, 2), createBarrier(4, 0),
+					
+					createBuffer(0)
+			};
+
+			MockInputGate gate = new MockInputGate(3, Arrays.asList(sequence));
+			BarrierTracker tracker = new BarrierTracker(gate);
+
+			CheckpointSequenceValidator validator =
+					new CheckpointSequenceValidator(1, 2, 3, 4);
+			tracker.registerCheckpointEventHandler(validator);
+
+			for (BufferOrEvent boe : sequence) {
+				if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
+					assertEquals(boe, tracker.getNextNonBlocked());
+				}
+			}
+
+			assertNull(tracker.getNextNonBlocked());
+			assertNull(tracker.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+
+	@Test
+	public void testMultiChannelSkippingCheckpoints() {
+		try {
+			BufferOrEvent[] sequence = {
+					createBuffer(0), createBuffer(2), createBuffer(0),
+					createBarrier(1, 1), createBarrier(1, 2),
+					createBuffer(2), createBuffer(1),
+					createBarrier(1, 0),
+
+					createBuffer(0), createBuffer(0), createBuffer(1), createBuffer(1), createBuffer(2),
+					createBarrier(2, 0), createBarrier(2, 1), createBarrier(2, 2),
+
+					createBuffer(2), createBuffer(2),
+					createBarrier(3, 2),
+					createBuffer(2), createBuffer(2),
+					
+					// jump to checkpoint 4
+					createBarrier(4, 0),
+					createBuffer(0), createBuffer(1), createBuffer(2),
+					createBarrier(4, 1),
+					createBuffer(1),
+					createBarrier(4, 2),
+					
+					createBuffer(0)
+			};
+
+			MockInputGate gate = new MockInputGate(3, Arrays.asList(sequence));
+			BarrierTracker tracker = new BarrierTracker(gate);
+
+			CheckpointSequenceValidator validator =
+					new CheckpointSequenceValidator(1, 2, 4);
+			tracker.registerCheckpointEventHandler(validator);
+
+			for (BufferOrEvent boe : sequence) {
+				if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
+					assertEquals(boe, tracker.getNextNonBlocked());
+				}
+			}
+			
+			assertNull(tracker.getNextNonBlocked());
+			assertNull(tracker.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+
+	/**
+	 * This test validates that the barrier tracker does not immediately
+	 * discard a pending checkpoint as soon as it sees a barrier from a
+	 * later checkpoint from some channel.
+	 * 
+	 * This behavior is crucial, otherwise topologies where different inputs
+	 * have different latency (and that latency is close to or higher than the
+	 * checkpoint interval) may skip many checkpoints, or fail to complete a
+	 * checkpoint all together.
+	 */
+	@Test
+	public void testCompleteCheckpointsOnLateBarriers() {
+		try {
+			BufferOrEvent[] sequence = {
+					// checkpoint 2
+					createBuffer(1), createBuffer(1), createBuffer(0), createBuffer(2),
+					createBarrier(2, 1), createBarrier(2, 0), createBarrier(2, 2),
+					
+					// incomplete checkpoint 3
+					createBuffer(1), createBuffer(0),
+					createBarrier(3, 1), createBarrier(3, 2),
+					
+					// some barriers from checkpoint 4
+					createBuffer(1), createBuffer(0),
+					createBarrier(4, 2), createBarrier(4, 1),
+					createBuffer(1), createBuffer(2),
+	
+					// last barrier from checkpoint 3
+					createBarrier(3, 0),
+					
+					// complete checkpoint 4
+					createBuffer(0), createBarrier(4, 0),
+					
+					// regular checkpoint 5
+					createBuffer(1), createBuffer(2), createBarrier(5, 1), 
+					createBuffer(0), createBarrier(5, 0),
+					createBuffer(1), createBarrier(5, 2),
+					
+					// checkpoint 6 (incomplete),
+					createBuffer(1), createBarrier(6, 1),
+					createBuffer(0), createBarrier(6, 0),
+					
+					// checkpoint 7, with early barriers for checkpoints 8 and 9
+					createBuffer(1), createBarrier(7, 1),
+					createBuffer(0), createBarrier(7, 2),
+					createBuffer(2), createBarrier(8, 2), 
+					createBuffer(0), createBarrier(8, 1),
+					createBuffer(1), createBarrier(9, 1),
+					
+					// complete checkpoint 7, first barriers from checkpoint 10
+					createBarrier(7, 0),
+					createBuffer(0), createBarrier(9, 2),
+					createBuffer(2), createBarrier(10, 2),
+					
+					// complete checkpoint 8 and 9
+					createBarrier(8, 0),
+					createBuffer(1), createBuffer(2), createBarrier(9, 0),
+					
+					// trailing data
+					createBuffer(1), createBuffer(0), createBuffer(2)
+			};
+
+			MockInputGate gate = new MockInputGate(3, Arrays.asList(sequence));
+			BarrierTracker tracker = new BarrierTracker(gate);
+
+			CheckpointSequenceValidator validator =
+					new CheckpointSequenceValidator(2, 3, 4, 5, 7, 8, 9);
+			tracker.registerCheckpointEventHandler(validator);
+
+			for (BufferOrEvent boe : sequence) {
+				if (boe.isBuffer() || boe.getEvent().getClass() != CheckpointBarrier.class) {
+					assertEquals(boe, tracker.getNextNonBlocked());
+				}
+			}
+
+			assertNull(tracker.getNextNonBlocked());
+			assertNull(tracker.getNextNonBlocked());
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+	}
+
+	// ------------------------------------------------------------------------
+	//  Utils
+	// ------------------------------------------------------------------------
+
+	private static BufferOrEvent createBarrier(long id, int channel) {
+		return new BufferOrEvent(new CheckpointBarrier(id, System.currentTimeMillis()), channel);
+	}
+
+	private static BufferOrEvent createBuffer(int channel) {
+		return new BufferOrEvent(
+				new Buffer(new MemorySegment(new byte[] { 1 }),  DummyBufferRecycler.INSTANCE), channel);
+	}
+	
+	// ------------------------------------------------------------------------
+	//  Testing Mocks
+	// ------------------------------------------------------------------------
+
+	private static class MockInputGate implements InputGate {
+
+		private final int numChannels;
+		private final Queue<BufferOrEvent> boes;
+
+		public MockInputGate(int numChannels, List<BufferOrEvent> boes) {
+			this.numChannels = numChannels;
+			this.boes = new ArrayDeque<BufferOrEvent>(boes);
+		}
+
+		@Override
+		public int getNumberOfInputChannels() {
+			return numChannels;
+		}
+
+		@Override
+		public boolean isFinished() {
+			return boes.isEmpty();
+		}
+
+		@Override
+		public void requestPartitions() {}
+
+		@Override
+		public BufferOrEvent getNextBufferOrEvent() {
+			return boes.poll();
+		}
+
+		@Override
+		public void sendTaskEvent(TaskEvent event) {}
+
+		@Override
+		public void registerListener(EventListener<InputGate> listener) {}
+	}
+
+	private static class CheckpointSequenceValidator implements EventListener<CheckpointBarrier> {
+
+		private final long[] checkpointIDs;
+		
+		private int i = 0;
+
+		private CheckpointSequenceValidator(long... checkpointIDs) {
+			this.checkpointIDs = checkpointIDs;
+		}
+		
+		@Override
+		public void onEvent(CheckpointBarrier barrier) {
+			assertTrue("More checkpoints than expected", i < checkpointIDs.length);
+			assertNotNull(barrier);
+			assertEquals("wrong checkpoint id", checkpointIDs[i++], barrier.getId());
+			assertTrue(barrier.getTimestamp() > 0);
+		}
+	}
+}
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/DummyBufferRecycler.java b/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/DummyBufferRecycler.java
new file mode 100644
index 0000000000000..3f815ef937ef4
--- /dev/null
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/DummyBufferRecycler.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.streaming.runtime.io;
+
+import org.apache.flink.core.memory.MemorySegment;
+import org.apache.flink.runtime.io.network.buffer.BufferRecycler;
+
+/**
+ * A BufferRecycler that does nothing.
+ */
+public class DummyBufferRecycler implements BufferRecycler {
+	
+	public static final BufferRecycler INSTANCE = new DummyBufferRecycler();
+	
+	
+	@Override
+	public void recycle(MemorySegment memorySegment) {}
+}
diff --git a/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/SpillingBufferOrEventTest.java b/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/SpillingBufferOrEventTest.java
index e0fab17364e70..b6cd656ccc116 100644
--- a/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/SpillingBufferOrEventTest.java
+++ b/flink-staging/flink-streaming/flink-streaming-core/src/test/java/org/apache/flink/streaming/runtime/io/SpillingBufferOrEventTest.java
@@ -22,20 +22,36 @@
 
 import java.io.IOException;
 
+import org.apache.flink.runtime.io.disk.iomanager.IOManager;
+import org.apache.flink.runtime.io.disk.iomanager.IOManagerAsync;
 import org.apache.flink.runtime.io.network.buffer.Buffer;
 import org.apache.flink.runtime.io.network.buffer.BufferPool;
 import org.apache.flink.runtime.io.network.buffer.NetworkBufferPool;
 import org.apache.flink.runtime.io.network.partition.consumer.BufferOrEvent;
-import org.apache.flink.streaming.runtime.io.BufferSpiller;
-import org.apache.flink.streaming.runtime.io.SpillReader;
-import org.apache.flink.streaming.runtime.io.SpillingBufferOrEvent;
+
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
 import org.junit.Test;
 
 public class SpillingBufferOrEventTest {
+	
+	private static IOManager IO_MANAGER;
+	
+	@BeforeClass
+	public static void createIOManager() {
+		IO_MANAGER = new IOManagerAsync();
+	}
+	
+	@AfterClass
+	public static void shutdownIOManager() {
+		IO_MANAGER.shutdown();
+	}
 
+	// ------------------------------------------------------------------------
+	
 	@Test
 	public void testSpilling() throws IOException, InterruptedException {
-		BufferSpiller bsp = new BufferSpiller();
+		BufferSpiller bsp = new BufferSpiller(IO_MANAGER);
 		SpillReader spr = new SpillReader();
 
 		BufferPool pool1 = new NetworkBufferPool(10, 256).createBufferPool(2, true);
diff --git a/flink-tests/src/test/java/org/apache/flink/test/manual/StreamingScalabilityAndLatency.java b/flink-tests/src/test/java/org/apache/flink/test/manual/StreamingScalabilityAndLatency.java
new file mode 100644
index 0000000000000..a34ec1576f710
--- /dev/null
+++ b/flink-tests/src/test/java/org/apache/flink/test/manual/StreamingScalabilityAndLatency.java
@@ -0,0 +1,154 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.flink.test.manual;
+
+import org.apache.flink.api.common.functions.MapFunction;
+import org.apache.flink.api.java.tuple.Tuple2;
+import org.apache.flink.configuration.ConfigConstants;
+import org.apache.flink.configuration.Configuration;
+import org.apache.flink.runtime.StreamingMode;
+import org.apache.flink.runtime.minicluster.LocalFlinkMiniCluster;
+import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
+import org.apache.flink.streaming.api.functions.sink.SinkFunction;
+import org.apache.flink.streaming.api.functions.source.ParallelSourceFunction;
+
+import static org.junit.Assert.fail;
+
+public class StreamingScalabilityAndLatency {
+	
+	public static void main(String[] args) throws Exception {
+		if ((Runtime.getRuntime().maxMemory() >>> 20) < 5000) {
+			throw new RuntimeException("This test program needs to run with at least 5GB of heap space.");
+		}
+		
+		final int TASK_MANAGERS = 1;
+		final int SLOTS_PER_TASK_MANAGER = 80;
+		final int PARALLELISM = TASK_MANAGERS * SLOTS_PER_TASK_MANAGER;
+
+		LocalFlinkMiniCluster cluster = null;
+
+		try {
+			Configuration config = new Configuration();
+			config.setInteger(ConfigConstants.LOCAL_INSTANCE_MANAGER_NUMBER_TASK_MANAGER, TASK_MANAGERS);
+			config.setInteger(ConfigConstants.TASK_MANAGER_MEMORY_SIZE_KEY, 80);
+			config.setInteger(ConfigConstants.TASK_MANAGER_NUM_TASK_SLOTS, SLOTS_PER_TASK_MANAGER);
+			config.setInteger(ConfigConstants.TASK_MANAGER_NETWORK_NUM_BUFFERS_KEY, 20000);
+
+			config.setInteger("taskmanager.net.server.numThreads", 1);
+			config.setInteger("taskmanager.net.client.numThreads", 1);
+
+			cluster = new LocalFlinkMiniCluster(config, false, StreamingMode.STREAMING);
+			
+			runPartitioningProgram(cluster.getJobManagerRPCPort(), PARALLELISM);
+		}
+		catch (Exception e) {
+			e.printStackTrace();
+			fail(e.getMessage());
+		}
+		finally {
+			if (cluster != null) {
+				cluster.shutdown();
+			}
+		}
+	}
+	
+	private static void runPartitioningProgram(int jobManagerPort, int parallelism) throws Exception {
+		StreamExecutionEnvironment env = StreamExecutionEnvironment.createRemoteEnvironment("localhost", jobManagerPort);
+		env.setParallelism(parallelism);
+		env.getConfig().enableObjectReuse();
+
+		env.setBufferTimeout(5L);
+//		env.enableCheckpointing(1000);
+
+		env
+			.addSource(new TimeStampingSource())
+			.map(new IdMapper<Tuple2<Long, Long>>())
+			.partitionByHash(0)
+			.addSink(new TimestampingSink());
+		
+		env.execute("Partitioning Program");
+	}
+	
+	public static class TimeStampingSource implements ParallelSourceFunction<Tuple2<Long, Long>> {
+
+		private static final long serialVersionUID = -151782334777482511L;
+
+		private volatile boolean running = true;
+		
+		
+		@Override
+		public void run(SourceContext<Tuple2<Long, Long>> ctx) throws Exception {
+			
+			long num = 100;
+			long counter = (long) (Math.random() * 4096);
+			
+			while (running) {
+				if (num < 100) {
+					num++;
+					ctx.collect(new Tuple2<Long, Long>(counter++, 0L));
+				}
+				else {
+					num = 0;
+					ctx.collect(new Tuple2<Long, Long>(counter++, System.currentTimeMillis()));
+				}
+
+				Thread.sleep(1);
+			}
+		}
+
+		@Override
+		public void cancel() {
+			running = false;
+		}
+	}
+	
+	public static class TimestampingSink implements SinkFunction<Tuple2<Long, Long>> {
+
+		private static final long serialVersionUID = 1876986644706201196L;
+
+		private long maxLatency;
+		private long count; 
+		
+		@Override
+		public void invoke(Tuple2<Long, Long> value) {
+			long ts = value.f1;
+			if (ts != 0L) {
+				long diff = System.currentTimeMillis() - ts;
+				maxLatency = Math.max(diff, maxLatency);
+			}
+			
+			count++;
+			if (count == 5000) {
+				System.out.println("Max latency: " + maxLatency);
+				count = 0;
+				maxLatency = 0;
+			}
+		}
+	}
+
+	public static class IdMapper<T> implements MapFunction<T, T> {
+
+		private static final long serialVersionUID = -6543809409233225099L;
+
+		@Override
+		public T map(T value) {
+			return value;
+		}
+	}
+}
diff --git a/flink-tests/src/test/java/org/apache/flink/test/manual/package-info.java b/flink-tests/src/test/java/org/apache/flink/test/manual/package-info.java
index 893f3cc90469d..1c5744d5379b7 100644
--- a/flink-tests/src/test/java/org/apache/flink/test/manual/package-info.java
+++ b/flink-tests/src/test/java/org/apache/flink/test/manual/package-info.java
@@ -18,7 +18,7 @@
 
 /**
  * This package contains various tests that are not automatically executed, but
- * need to be manually invoked, because they are extremely heavy of require larger-than-usual
- * JVMs.
+ * need to be manually invoked, because they are extremely heavy, time intensive,
+ * of require larger-than-usual JVMs.
  */
 package org.apache.flink.test.manual;
\ No newline at end of file
