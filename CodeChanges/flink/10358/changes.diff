diff --git a/flink-core/src/main/java/org/apache/flink/types/StringValue.java b/flink-core/src/main/java/org/apache/flink/types/StringValue.java
index 1d1e80de97a79..7ce8725ff8674 100644
--- a/flink-core/src/main/java/org/apache/flink/types/StringValue.java
+++ b/flink-core/src/main/java/org/apache/flink/types/StringValue.java
@@ -51,6 +51,12 @@ public class StringValue implements NormalizableKey<StringValue>, CharSequence,
 	private static final char[] EMPTY_STRING = new char[0];
 	
 	private static final int HIGH_BIT = 0x1 << 7;
+
+	private static final int HIGH_BIT14 = 0x1 << 14;
+
+	private static final int HIGH_BIT21 = 0x1 << 21;
+
+	private static final int HIGH_BIT28 = 0x1 << 28;
 	
 	private static final int HIGH_BIT2 = 0x1 << 13;
 	
@@ -740,11 +746,11 @@ private void grow(int size) {
 	// --------------------------------------------------------------------------------------------
 	//                           Static Helpers for String Serialization
 	// --------------------------------------------------------------------------------------------
-	
+
 	public static String readString(DataInput in) throws IOException {
 		// the length we read is offset by one, because a length of zero indicates a null value
 		int len = in.readUnsignedByte();
-		
+
 		if (len == 0) {
 			return null;
 		}
@@ -759,57 +765,151 @@ public static String readString(DataInput in) throws IOException {
 			}
 			len |= curr << shift;
 		}
-		
+
 		// subtract one for the null length
 		len -= 1;
-		
-		final char[] data = new char[len];
 
-		for (int i = 0; i < len; i++) {
-			int c = in.readUnsignedByte();
-			if (c < HIGH_BIT) {
-				data[i] = (char) c;
-			} else {
+		/* as we have no idea about byte-length of the serialized string, we cannot fully
+		 * read it into memory buffer. But we can do it in an optimistic way:
+		 * 1. In a happy case when the string is an us-ascii one, then byte_len == char_len
+		 * 2. If we spot at least one character with code >= 127, then we reallocate the buffer
+		 * to accommodate for the next characters.
+		 */
+
+		// happily assume that the string is an 7 bit us-ascii one
+		byte[] buf = new byte[len];
+		in.readFully(buf);
+
+		final char[] data = new char[len];
+		int charPosition = 0;
+		int bufSize = len;
+		int bytePosition = 0;
+
+		while (charPosition < len) {
+			if (bytePosition == bufSize) {
+				// there is at least `char count - char position` bytes left in case if all the
+				// remaining characters are 7 bit.
+				int minRemainingChars = len - charPosition;
+				// need to refill the buffer as we already reached its end.
+				// we also reuse the old buffer, as it's capacity must always be >= minRemainingChars.
+				in.readFully(buf, 0, minRemainingChars);
+				bytePosition = 0;
+				bufSize = minRemainingChars;
+			}
+			int c = buf[bytePosition++] & 255;
+			// non 7-bit path
+			if (c >= HIGH_BIT) {
 				int shift = 7;
 				int curr;
 				c = c & 0x7f;
-				while ((curr = in.readUnsignedByte()) >= HIGH_BIT) {
+				if (bytePosition == bufSize) {
+					int minRemainingChars = len - charPosition;
+					in.readFully(buf, 0, minRemainingChars);
+					bytePosition = 0;
+					bufSize = minRemainingChars;
+				}
+
+				while ((curr = buf[bytePosition++] & 255) >= HIGH_BIT) {
 					c |= (curr & 0x7f) << shift;
 					shift += 7;
+					if (bytePosition == bufSize) {
+						int minRemainingChars = len - charPosition;
+						// may need to refill the buffer if char bytes are split between the buffers.
+						in.readFully(buf, 0, minRemainingChars);
+						bytePosition = 0;
+						bufSize = minRemainingChars;
+					}
 				}
 				c |= curr << shift;
-				data[i] = (char) c;
 			}
+			data[charPosition++] = (char) c;
 		}
-		
 		return new String(data, 0, len);
 	}
 
 	public static final void writeString(CharSequence cs, DataOutput out) throws IOException {
 		if (cs != null) {
+			int strlen = cs.length();
+
 			// the length we write is offset by one, because a length of zero indicates a null value
-			int lenToWrite = cs.length()+1;
+			int lenToWrite = strlen + 1;
 			if (lenToWrite < 0) {
 				throw new IllegalArgumentException("CharSequence is too long.");
 			}
-	
-			// write the length, variable-length encoded
-			while (lenToWrite >= HIGH_BIT) {
-				out.write(lenToWrite | HIGH_BIT);
-				lenToWrite >>>= 7;
+
+
+			// buffer size needed to contain all the characters
+			int buflen = 0;
+			if (strlen < 8) {
+				// for small strings it's much faster to over-allocate a buffer sized for the worst-case scenario
+				// when all the chars are encoded as 3-byte sequences, than iterating over the source string.
+				buflen = strlen * 3;
+			} else {
+				for (int i = 0; i < strlen; i++) {
+					char c = cs.charAt(i);
+					if ((c & 0xff80) == 0) {
+						buflen++;
+					} else if (c > 0x07FF) {
+						buflen += 3;
+					} else {
+						buflen += 2;
+					}
+				}
 			}
-			out.write(lenToWrite);
-	
+			byte[] buffer;
+			int position = 0;
+			// string is prefixed by it's variable length encoded size, which can take 1-5 bytes.
+			if (lenToWrite < HIGH_BIT) {
+				buflen += 1;
+				buffer = new byte[buflen];
+				buffer[position++] = (byte) lenToWrite;
+			} else if (lenToWrite < HIGH_BIT14) {
+				buflen += 2;
+				buffer = new byte[buflen];
+				buffer[position++] = (byte)(lenToWrite | HIGH_BIT);
+				buffer[position++] = (byte)((lenToWrite >>> 7));
+			} else if (lenToWrite < HIGH_BIT21) {
+				buflen += 3;
+				buffer = new byte[buflen];
+				buffer[position++] = (byte)(lenToWrite | HIGH_BIT);
+				buffer[position++] = (byte)((lenToWrite >>> 7) | HIGH_BIT);
+				buffer[position++] = (byte)((lenToWrite >>> 14));
+			} else if (lenToWrite < HIGH_BIT28) {
+				buflen += 4;
+				buffer = new byte[buflen];
+				buffer[position++] = (byte)(lenToWrite | HIGH_BIT);
+				buffer[position++] = (byte)((lenToWrite >>> 7) | HIGH_BIT);
+				buffer[position++] = (byte)((lenToWrite >>> 14) | HIGH_BIT);
+				buffer[position++] = (byte)((lenToWrite >>> 21));
+			} else {
+				buflen += 5;
+				buffer = new byte[buflen];
+				buffer[position++] = (byte)(lenToWrite | HIGH_BIT);
+				buffer[position++] = (byte)((lenToWrite >>> 7) | HIGH_BIT);
+				buffer[position++] = (byte)((lenToWrite >>> 14) | HIGH_BIT);
+				buffer[position++] = (byte)((lenToWrite >>> 21) | HIGH_BIT);
+				buffer[position++] = (byte)((lenToWrite >>> 28));
+			}
+
+
 			// write the char data, variable length encoded
-			for (int i = 0; i < cs.length(); i++) {
+			for (int i = 0; i < strlen; i++) {
 				int c = cs.charAt(i);
-	
-				while (c >= HIGH_BIT) {
-					out.write(c | HIGH_BIT);
-					c >>>= 7;
+
+				// manual loop unroll, as it performs much better on jdk8
+				if (c < HIGH_BIT) {
+					buffer[position++] = (byte)c;
+				} else if (c < HIGH_BIT14) {
+					buffer[position++] = (byte)(c | HIGH_BIT);
+					buffer[position++] = (byte)((c >>> 7));
+				} else {
+					buffer[position++] = (byte)(c | HIGH_BIT);
+					buffer[position++] = (byte)((c >>> 7) | HIGH_BIT);
+					buffer[position++] = (byte)((c >>> 14));
 				}
-				out.write(c);
 			}
+			out.write(buffer, 0, position);
+
 		} else {
 			out.write(0);
 		}
diff --git a/flink-core/src/test/java/org/apache/flink/types/StringSerializationTest.java b/flink-core/src/test/java/org/apache/flink/types/StringSerializationTest.java
index 5ba880409372f..d3d8188ee92e5 100644
--- a/flink-core/src/test/java/org/apache/flink/types/StringSerializationTest.java
+++ b/flink-core/src/test/java/org/apache/flink/types/StringSerializationTest.java
@@ -20,19 +20,23 @@
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
+import static org.junit.Assert.assertArrayEquals;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.IOException;
+import java.io.DataInput;
+import java.io.DataOutput;
+
 import java.util.Random;
+import java.util.function.BiConsumer;
+import java.util.function.Function;
 
-import org.apache.flink.types.StringValue;
 import org.apache.flink.util.StringUtils;
 import org.junit.Test;
 
-
 /**
  * Test for the serialization of Strings through the StringValue class.
  */
@@ -56,6 +60,87 @@ public void testNonNullValues() {
 			fail("Exception in test: " + e.getMessage());
 		}
 	}
+
+	@Test
+	public void testUnicodeValues() {
+		try {
+			String[] testStrings = new String[] {
+				StringUtils.getRandomString(rnd, 10000, 1024 * 1024 * 2, (char) 1, (char) 127),
+				StringUtils.getRandomString(rnd, 10000, 1024 * 1024 * 2, (char) 128, (char) 16383),
+				StringUtils.getRandomString(rnd, 10000, 1024 * 1024 * 2, (char) 16384, (char) 65535),
+				StringUtils.getRandomString(rnd, 10000, 1024 * 1024 * 2, (char) 1, (char) 16383),
+				StringUtils.getRandomString(rnd, 10000, 1024 * 1024 * 2, (char) 1, (char) 65535),
+				StringUtils.getRandomString(rnd, 10000, 1024 * 1024 * 2, (char) 128, (char) 65535)
+			};
+			testSerialization(testStrings);
+		}
+		catch (Exception e) {
+			System.err.println(e.getMessage());
+			e.printStackTrace();
+			fail("Exception in test: " + e.getMessage());
+		}
+	}
+
+	@Test
+	public void testUnicodeSurrogatePairs() {
+		try {
+			String[] symbols = new String[] {
+				"\uD800\uDF30", "\uD800\uDF31", "\uD800\uDF32", "\uD834\uDF08", "\uD834\uDF56",
+				"\uD834\uDD20", "\uD802\uDC01", "\uD800\uDC09", "\uD87E\uDC9E", "\uD864\uDDF8",
+				"\uD840\uDC0E", "\uD801\uDC80", "\uD801\uDC56", "\uD801\uDC05", "\uD800\uDF01"
+			};
+			String[] buffer = new String[100];
+			Random random = new Random();
+			for (int i = 0; i < 100; i++) {
+				StringBuilder builder = new StringBuilder();
+				for (int j = 0; j < 100; j++) {
+					builder.append(symbols[random.nextInt(symbols.length)]);
+				}
+				buffer[i] = builder.toString();
+			}
+			testSerialization(buffer);
+		} catch (Exception e) {
+			System.err.println(e.getMessage());
+			e.printStackTrace();
+			fail("Exception in test: " + e.getMessage());
+		}
+
+	}
+
+	@Test
+	public void testStringBinaryCompatibility() {
+		try {
+			String[] testStrings = new String[] {
+				StringUtils.getRandomString(rnd, 10000, 1024 * 1024 * 2, (char) 1, (char) 127),
+				StringUtils.getRandomString(rnd, 10000, 1024 * 1024 * 2, (char) 128, (char) 16383),
+				StringUtils.getRandomString(rnd, 10000, 1024 * 1024 * 2, (char) 16384, (char) 65535),
+				StringUtils.getRandomString(rnd, 10000, 1024 * 1024 * 2, (char) 1, (char) 16383),
+				StringUtils.getRandomString(rnd, 10000, 1024 * 1024 * 2, (char) 1, (char) 65535),
+				StringUtils.getRandomString(rnd, 10000, 1024 * 1024 * 2, (char) 128, (char) 65535)
+			};
+
+			for (String testString: testStrings) {
+				// new and old impl should produce the same binary result
+				byte[] oldBytes = serializeBytes(testString, StringSerializationTest::oldWriteString);
+				byte[] newBytes = serializeBytes(testString, StringSerializationTest::newWriteString);
+				assertArrayEquals(oldBytes, newBytes);
+				// old impl should read bytes from new one
+				String oldString = deserializeBytes(newBytes, StringSerializationTest::oldReadString);
+				assertEquals(oldString, testString);
+				// new impl should read bytes from old one
+				String newString = deserializeBytes(oldBytes, StringSerializationTest::newReadString);
+				assertEquals(newString, testString);
+				// it should roundtrip over new impl
+				String roundtrip = deserializeBytes(newBytes, StringSerializationTest::newReadString);
+				assertEquals(roundtrip, testString);
+			}
+		}
+		catch (Exception e) {
+			System.err.println(e.getMessage());
+			e.printStackTrace();
+			fail("Exception in test: " + e.getMessage());
+		}
+	}
 	
 	@Test
 	public void testNullValues() {
@@ -141,6 +226,22 @@ public void testBinaryCopyOfLongStrings() {
 			fail("Exception in test: " + e.getMessage());
 		}
 	}
+
+	public static final byte[] serializeBytes(String value, BiConsumer<String, DataOutput> writer) throws IOException {
+		ByteArrayOutputStream buffer = new ByteArrayOutputStream();
+		DataOutputStream stream = new DataOutputStream(buffer);
+		writer.accept(value, stream);
+		stream.close();
+		return buffer.toByteArray();
+	}
+
+	public static final String deserializeBytes(byte[] value, Function<DataInput, String> reader) throws IOException {
+		ByteArrayInputStream buffer = new ByteArrayInputStream(value);
+		DataInputStream stream = new DataInputStream(buffer);
+		String result = reader.apply(stream);
+		stream.close();
+		return result;
+	}
 	
 	public static final void testSerialization(String[] values) throws IOException {
 		ByteArrayOutputStream baos = new ByteArrayOutputStream(4096);
@@ -200,5 +301,107 @@ public static final void testCopy(String[] values) throws IOException {
 		
 		assertEquals("Wrong number of deserialized values", values.length, num);
 	}
-	
+
+	// needed to test the binary compatibility for new/old string serialization code
+	private static final int HIGH_BIT = 0x1 << 7;
+	private static String oldReadString(DataInput in) {
+		try {
+			// the length we read is offset by one, because a length of zero indicates a null value
+			int len = in.readUnsignedByte();
+
+			if (len == 0) {
+				return null;
+			}
+
+			if (len >= HIGH_BIT) {
+				int shift = 7;
+				int curr;
+				len = len & 0x7f;
+				while ((curr = in.readUnsignedByte()) >= HIGH_BIT) {
+					len |= (curr & 0x7f) << shift;
+					shift += 7;
+				}
+				len |= curr << shift;
+			}
+
+			// subtract one for the null length
+			len -= 1;
+
+			final char[] data = new char[len];
+
+			for (int i = 0; i < len; i++) {
+				int c = in.readUnsignedByte();
+				if (c < HIGH_BIT) {
+					data[i] = (char) c;
+				} else {
+					int shift = 7;
+					int curr;
+					c = c & 0x7f;
+					while ((curr = in.readUnsignedByte()) >= HIGH_BIT) {
+						c |= (curr & 0x7f) << shift;
+						shift += 7;
+					}
+					c |= curr << shift;
+					data[i] = (char) c;
+				}
+			}
+
+			return new String(data, 0, len);
+		} catch (Exception e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+	private static final void oldWriteString(CharSequence cs, DataOutput out) {
+		try {
+			if (cs != null) {
+				// the length we write is offset by one, because a length of zero indicates a null value
+				int lenToWrite = cs.length()+1;
+				if (lenToWrite < 0) {
+					throw new IllegalArgumentException("CharSequence is too long.");
+				}
+
+				// write the length, variable-length encoded
+				while (lenToWrite >= HIGH_BIT) {
+					out.write(lenToWrite | HIGH_BIT);
+					lenToWrite >>>= 7;
+				}
+				out.write(lenToWrite);
+
+				// write the char data, variable length encoded
+				for (int i = 0; i < cs.length(); i++) {
+					int c = cs.charAt(i);
+
+					while (c >= HIGH_BIT) {
+						out.write(c | HIGH_BIT);
+						c >>>= 7;
+					}
+					out.write(c);
+				}
+			} else {
+				out.write(0);
+			}
+		} catch (Exception e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+	public static String newReadString(DataInput in) {
+		try {
+			return StringValue.readString(in);
+		} catch (Exception e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+	public static void newWriteString(CharSequence cs, DataOutput out) {
+		try {
+			StringValue.writeString(cs, out);
+		} catch (Exception e) {
+			throw new RuntimeException(e);
+		}
+	}
+
+
+
 }
