diff --git a/core/sql/bin/SqlciErrors.txt b/core/sql/bin/SqlciErrors.txt
index 895b84f75b..eb24e629db 100644
--- a/core/sql/bin/SqlciErrors.txt
+++ b/core/sql/bin/SqlciErrors.txt
@@ -26,7 +26,7 @@
 1024 ZZZZZ 99999 BEGINNER MINOR DBADMIN File system error $0~NSKCode occurred on $1~String0. $2~String1
 1025 ZZZZZ 99999 BEGINNER MINOR DBADMIN Request failed.  Dependent object $0~string0 exists.
 1026 ZZZZZ 99999 BEGINNER MINOR DBADMIN Only the schema owner or super ID can drop a schema.
-1027 ZZZZZ 99999 BEGINNER MINOR DBADMIN The definition schema $0~SchemaName is dropped when its catalog is dropped.
+1027 ZZZZZ 99999 BEGINNER MINOR DBADMIN The view $0~TableName was created before column privileges were supported. To grant column privileges, please recreate the view.
 1028 ZZZZZ 99999 BEGINNER MINOR DBADMIN The schema must be empty.  It contains at least one object $0~TableName.
 1029 ZZZZZ 99999 BEGINNER MINOR DBADMIN Object $0~TableName could not be created.
 1030 ZZZZZ 99999 BEGINNER MINOR DBADMIN The HBase name has a length of $0~Int0 which is too long. Maximum length supported is $1~Int1.  
diff --git a/core/sql/comexe/ComTdb.h b/core/sql/comexe/ComTdb.h
index 080ea45904..03a2f4bd88 100644
--- a/core/sql/comexe/ComTdb.h
+++ b/core/sql/comexe/ComTdb.h
@@ -1056,6 +1056,7 @@ class ComTdbVirtTableViewInfo : ComTdbVirtTableBase
   char * viewName;
   char * viewText;
   char * viewCheckText;
+  char * viewColUsages;
   Lng32 isUpdatable;
   Lng32 isInsertable;
 };
diff --git a/core/sql/common/ComSmallDefs.h b/core/sql/common/ComSmallDefs.h
index 68de7b7fba..1a1a3bdd51 100644
--- a/core/sql/common/ComSmallDefs.h
+++ b/core/sql/common/ComSmallDefs.h
@@ -646,7 +646,8 @@ enum ComTextType {COM_VIEW_TEXT = 0,
                   COM_COMPUTED_COL_TEXT = 4,
                   COM_HBASE_COL_FAMILY_TEXT = 5,
                   COM_HBASE_SPLIT_TEXT = 6,
-                  COM_STORED_DESC_TEXT = 7
+                  COM_STORED_DESC_TEXT = 7,
+                  COM_VIEW_REF_COLS_TEXT = 8
 };
 
 enum ComColumnDirection { COM_UNKNOWN_DIRECTION
diff --git a/core/sql/common/ComViewColUsage.h b/core/sql/common/ComViewColUsage.h
new file mode 100644
index 0000000000..1ec12c6334
--- /dev/null
+++ b/core/sql/common/ComViewColUsage.h
@@ -0,0 +1,112 @@
+// @@@ START COPYRIGHT @@@
+//
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+//
+// @@@ END COPYRIGHT @@@
+
+/*
+ *****************************************************************************
+ *
+ * File:         ComViewColUsage.h
+ * Description:  Defines the referenced object (table or view) column 
+ *               relationship to the corresponding view column.
+ *               
+ * Created:      7/15/16
+ * Language:     C++
+ *
+ *****************************************************************************
+ */
+
+#ifndef COMVIEWCOLUSAGE_H
+#define COMVIEWCOLUSAGE_H
+
+#include "ComSmallDefs.h"
+#include "str.h"
+
+class ComViewColUsage
+{
+  Int64 viewUID_;
+  Int32 viewColNumber_;
+  Int64 refdUID_;
+  Int32 refdColNumber_;
+  ComObjectType refdObjectType_;
+
+public:
+  ComViewColUsage ()
+  : viewUID_ (0),
+    viewColNumber_ (-1),
+    refdUID_(0),
+    refdColNumber_(-1),
+    refdObjectType_(COM_UNKNOWN_OBJECT)
+  {}
+
+  ComViewColUsage (
+   Int64 viewUID,
+   Int32 viewColNumber,
+   Int64 refdUID,
+   Int32 refdColNumber,
+   ComObjectType refdObjectType)
+ : viewUID_ (viewUID),
+   viewColNumber_ (viewColNumber),
+   refdUID_ (refdUID),
+   refdColNumber_ (refdColNumber),
+   refdObjectType_ (refdObjectType)
+{}
+
+  virtual ~ComViewColUsage()
+  {};
+
+  Int64 getViewUID () { return viewUID_; }
+  void setViewUID(Int64 viewUID) { viewUID_ = viewUID; }
+
+  Int32 getViewColNumber () { return viewColNumber_; }
+  void setViewColNumber(Int32 viewColNumber) { viewColNumber_ = viewColNumber; }
+
+  Int64 getRefdUID () { return refdUID_; }
+  void setRefdUID(Int64 refdUID) { refdUID_ = refdUID; }
+
+  Int32 getRefdColNumber () { return refdColNumber_; }
+  void setRefdColNumber(Int32 refdColNumber) { refdColNumber_ = refdColNumber; }
+
+  Int32 getRefdObjectType () { return refdObjectType_; }
+  void setRefdObjectType(ComObjectType refdObjectType) { refdObjectType_ = refdObjectType; }
+
+  void packUsage (NAString &viewColUsageStr)
+  {
+      // usage contains 2 int64 and 3 int32, 200 chars is big enough to hold 
+      // the string representation
+      char buf[200];
+      str_sprintf(buf, "viewUID: %Ld viewCol: %d refUID: %Ld refCol: %d refType: %d;",
+                  viewUID_, viewColNumber_,
+                  refdUID_, refdColNumber_, refdObjectType_);
+      viewColUsageStr = buf;
+  }
+
+  void unpackUsage (const char *viewColUsageStr)
+  {
+      Int32 theRefdObjectType;
+      Int32 retcode = sscanf(viewColUsageStr, "viewUID: %Ld viewCol: %d refUID: %Ld refCol: %d refType: %d%*s" ,
+             (long long int *)&viewUID_, &viewColNumber_, 
+             (long long int *)&refdUID_, &refdColNumber_, &theRefdObjectType);
+      assert (retcode == 5);
+      refdObjectType_ = (ComObjectType) theRefdObjectType;
+  }
+};
+
+#endif  // COMVIEWCOLUSAGE_H
+
diff --git a/core/sql/generator/Generator.cpp b/core/sql/generator/Generator.cpp
index 6530a3ac7c..9f2be03ec4 100644
--- a/core/sql/generator/Generator.cpp
+++ b/core/sql/generator/Generator.cpp
@@ -2153,6 +2153,14 @@ TrafDesc * Generator::createVirtualTableDesc
       else
 	view_desc->viewDesc()->viewchecktext = NULL;
 
+      if (viewInfo[0].viewColUsages)
+	{
+	  view_desc->viewDesc()->viewcolusages = new GENHEAP(space) char[strlen(viewInfo[0].viewColUsages)+1];
+	  strcpy(view_desc->viewDesc()->viewcolusages, viewInfo[0].viewColUsages);
+	}
+      else
+	view_desc->viewDesc()->viewcolusages = NULL;
+
       view_desc->viewDesc()->setUpdatable(viewInfo[0].isUpdatable);
       view_desc->viewDesc()->setInsertable(viewInfo[0].isInsertable);
     }
diff --git a/core/sql/optimizer/NATable.cpp b/core/sql/optimizer/NATable.cpp
index eb68a51727..fb3b61c6e9 100644
--- a/core/sql/optimizer/NATable.cpp
+++ b/core/sql/optimizer/NATable.cpp
@@ -5071,6 +5071,7 @@ NABoolean createNAFileSets(TrafDesc * table_desc       /*IN*/,
      viewTextInNAWchars_(heap),
      viewTextCharSet_(CharInfo::UnknownCharSet),
      viewCheck_(NULL),
+     viewColUsages_(NULL),
      flags_(IS_INSERTABLE | IS_UPDATABLE),
      insertMode_(COM_REGULAR_TABLE_INSERT_MODE),
      isSynonymTranslationDone_(FALSE),
@@ -5372,6 +5373,22 @@ NABoolean createNAFileSets(TrafDesc * table_desc       /*IN*/,
         memcpy(viewCheck_, view_desc->viewDesc()->viewchecktext,
                viewCheckLength);
       }
+
+      viewColUsages_ = NULL;
+      if(view_desc->viewDesc()->viewcolusages){
+        viewColUsages_ = new (heap_) NAList<ComViewColUsage *>; //initialize empty list
+        char * beginStr (view_desc->viewDesc()->viewcolusages);
+        char * endStr = strchr(beginStr, ';');
+        while (endStr != NULL) {
+          ComViewColUsage *colUsage = new (heap_) ComViewColUsage;
+          NAString currentUsage(beginStr, endStr - beginStr + 1); 
+          colUsage->unpackUsage (currentUsage.data());
+          viewColUsages_->insert(colUsage);
+          beginStr = endStr+1;
+          endStr = strchr(beginStr, ';');
+        }
+      }
+
       setUpdatable(view_desc->viewDesc()->isUpdatable());
       setInsertable(view_desc->viewDesc()->isInsertable());
 
@@ -5793,6 +5810,7 @@ NATable::NATable(BindWA *bindWA,
     viewTextInNAWchars_(heap),
     viewTextCharSet_(CharInfo::UnknownCharSet),
     viewCheck_(NULL),
+    viewColUsages_(NULL),
     flags_(IS_INSERTABLE | IS_UPDATABLE),
     insertMode_(COM_REGULAR_TABLE_INSERT_MODE),
     isSynonymTranslationDone_(FALSE),
@@ -7033,6 +7051,16 @@ NATable::~NATable()
      NADELETEBASIC(viewCheck_, heap_);
      viewCheck_ = NULL;
   } 
+  if (viewColUsages_ != NULL)
+  {
+     for(Int32 i = 0; i < viewColUsages_->entries(); i++)
+     {
+        ComViewColUsage *pUsage = viewColUsages_->operator[](i);
+        NADELETEBASIC(pUsage, heap_);
+     }
+     NADELETEBASIC(viewColUsages_, heap_);
+     viewColUsages_ = NULL;
+  } 
   if (viewFileName_ != NULL)
   {
      NADELETEBASIC(viewFileName_, heap_);
diff --git a/core/sql/optimizer/NATable.h b/core/sql/optimizer/NATable.h
index 8b5e3fe232..e9dcb51be8 100644
--- a/core/sql/optimizer/NATable.h
+++ b/core/sql/optimizer/NATable.h
@@ -45,6 +45,7 @@
 #include "ExpLOBexternal.h"
 #include "ComSecurityKey.h"
 #include "ExpHbaseDefs.h"
+#include "ComViewColUsage.h"
 
 //forward declaration(s)
 // -----------------------------------------------------------------------
@@ -565,6 +566,7 @@ class NATable : public NABasicObject
   Int32   getViewTextLenInNAWchars() const   { return viewTextInNAWchars_.length(); }
 
   const char *getViewCheck() const              { return viewCheck_; }
+  const NAList<ComViewColUsage*> *getViewColUsages() const  { return viewColUsages_; }
 
   NABoolean hasSaltedColumn(Lng32 * saltColPos = NULL);
   NABoolean hasDivisioningColumn(Lng32 * divColPos = NULL);
@@ -1085,6 +1087,7 @@ class NATable : public NABasicObject
   NAWString viewTextInNAWchars_;
   CharInfo::CharSet viewTextCharSet_;
   char *viewCheck_;
+  NAList<ComViewColUsage *> *viewColUsages_;
 
   // ---------------------------------------------------------------------
   // Flags
diff --git a/core/sql/regress/privs1/EXPECTED141 b/core/sql/regress/privs1/EXPECTED141
index 308aae9c46..b846af78ee 100644
Binary files a/core/sql/regress/privs1/EXPECTED141 and b/core/sql/regress/privs1/EXPECTED141 differ
diff --git a/core/sql/regress/privs1/TEST141 b/core/sql/regress/privs1/TEST141
index 8011c2183f..a605f6446a 100755
--- a/core/sql/regress/privs1/TEST141
+++ b/core/sql/regress/privs1/TEST141
@@ -38,7 +38,6 @@ obey TEST141(test_private_user);
 obey TEST141(test_private_role);
 obey TEST141(test_shared_user);
 obey TEST141(test_shared_role);
-obey TEST141(test_view_priv_propagation);
 log;
 obey TEST141(clean_up);
 exit;
@@ -315,57 +314,6 @@ execute get_col_privs;
 sh sqlci -i "TEST141(user2_objects)" -u sql_user2;
 execute get_obj_privs;
 
--- ============================================================================
-?section test_view_priv_propagation
--- ============================================================================
-values (user);
-
--- remove schemas 
-drop schema if exists t141_user1 cascade;
-drop schema if exists t141_user2 cascade;
-drop schema if exists t141_user3 cascade;
-
--- setup database with private schemas owned by users
-create schema t141_user1 authorization sql_user1;
-create schema t141_user2 authorization sql_user2;
-
--- create some tables owned by user1
-set schema t141_user1;
-create table u1t1 (c1 int not null primary key, c2 int, c3 int);
-insert into u1t1 values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
-create table u1t2 (c1 int not null primary key, c2 int, c3 int);
-insert into u1t2 values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
-
--- grant privileges to sql_user2 on tables
-grant select, delete on u1t1 to sql_user2;
-grant select, delete on u1t2 to sql_user2 with grant option;
-
-execute get_obj_privs;
-
--- user2 creates some views
-sh sqlci -i "TEST141(user2_views)" -u sql_user2;
-
-execute get_obj_privs;
-
--- user1 grants insert privilege on tables
-grant insert on u1t1 to sql_user2;
-grant insert on u1t2 to sql_user2 with grant option;
-
-execute get_obj_privs;
-
--- remove with grant option for some privileges
-revoke grant option for insert, delete on u1t2 from sql_user2;
-execute get_obj_privs;
-
--- Add back the with grant option for delete
-grant delete on u1t2 to sql_user2 with grant option;
-execute get_obj_privs;
-
--- Remove insert, and delete entirely
-revoke insert, delete on u1t1 from sql_user2;
-revoke insert, delete on u1t2 from sql_user2;
-execute get_obj_privs;
-
 -- ============================================================================
 ?section user1_objects
 -- ============================================================================
diff --git a/core/sql/regress/privs2/EXPECTED143 b/core/sql/regress/privs2/EXPECTED143
new file mode 100644
index 0000000000..8ab9df2894
Binary files /dev/null and b/core/sql/regress/privs2/EXPECTED143 differ
diff --git a/core/sql/regress/privs2/TEST143 b/core/sql/regress/privs2/TEST143
new file mode 100755
index 0000000000..98a6005002
--- /dev/null
+++ b/core/sql/regress/privs2/TEST143
@@ -0,0 +1,457 @@
+-- ============================================================================
+-- Test: TEST143 
+-- @@@ START COPYRIGHT @@@
+--
+-- Licensed to the Apache Software Foundation (ASF) under one
+-- or more contributor license agreements.  See the NOTICE file
+-- distributed with this work for additional information
+-- regarding copyright ownership.  The ASF licenses this file
+-- to you under the Apache License, Version 2.0 (the
+-- "License"); you may not use this file except in compliance
+-- with the License.  You may obtain a copy of the License at
+--
+--   http://www.apache.org/licenses/LICENSE-2.0
+--
+-- Unless required by applicable law or agreed to in writing,
+-- software distributed under the License is distributed on an
+-- "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+-- KIND, either express or implied.  See the License for the
+-- specific language governing permissions and limitations
+-- under the License.
+--
+-- @@@ END COPYRIGHT @@@
+--
+-- ============================================================================
+-- Functionality: Test view privilege propagation for objects and columns
+--
+-- Expected files: EXPECTED143
+-- ============================================================================
+
+cqd SHOWDDL_DISPLAY_PRIVILEGE_GRANTS 'ON';
+obey TEST143(clean_up);
+log LOG143 clear ;
+obey TEST143(set_up);
+obey TEST143(test_view_object_priv_propagation);
+obey TEST143(test_view_column_priv_propagation);
+obey TEST143(test_view_role_priv_propagation);
+obey TEST143(test_view_misc_priv_propagation);
+log;
+obey TEST143(clean_up);
+exit;
+
+-- ============================================================================
+?section clean_up
+-- ============================================================================
+-- Cleaning up test environment
+drop schema if exists t143_udr cascade;
+drop schema if exists t143_user1 cascade;
+drop schema if exists t143_user2 cascade;
+drop schema if exists t143_user3 cascade;
+drop schema if exists t143_user5 cascade;
+
+revoke role user2_role from sql_user2;
+revoke role user3_role from sql_user3;
+drop role user2_role;
+drop role user3_role;
+
+
+-- ============================================================================
+?section set_up
+-- ============================================================================
+-- Setup the test environment
+
+-- create function to display bitmaps as a bitmap rather than longs
+-- use the function from privs2/TEST140
+sh rm -f ./etest140.dll;
+sh sh $$scriptsdir$$/tools/dll-compile.ksh etest140.cpp
+  2>&1 | tee LOG140-SECONDARY;
+set pattern $$DLL$$ etest140.dll;
+set pattern $$QUOTE$$ '''';
+
+create schema t143_udr;
+set schema t143_udr;
+create library t143_l1 file $$QUOTE$$ $$REGRRUNDIR$$/$$DLL$$ $$QUOTE$$ ;
+create function translateBitmap(bitmap largeint) returns (bitmap_string char (20))
+language c parameter style sql external name 'translateBitmap'
+library t143_l1
+deterministic no sql final call allow any parallelism state area size 1024 ;
+grant execute on function t143_udr.translateBitmap to "PUBLIC";
+
+-- query to read privs from metadata
+prepare get_obj_privs from
+select distinct
+   substring (object_name,11,15) as object_name,
+   object_type as type,
+   substring(authname(grantor_id),1,10) as grantor,
+   substring(authname(grantee_id),1,10) as grantee,
+   t143_udr.translateBitmap(privileges_bitmap) as granted_privs,
+   t143_udr.translateBitmap(grantable_bitmap) as grantable_privs
+from "_PRIVMGR_MD_".object_privileges
+where object_uid in
+     (select object_uid
+      from "_MD_".objects
+      where object_name like 'U%' and schema_name like 'T143_USER%')
+  order by 1, 2, 3
+;
+
+prepare get_col_privs from
+select distinct
+   substring (object_name,11,15) as object_name,
+   column_number,
+   substring(authname(grantor_id),1,10) as grantor,
+   substring(authname(grantee_id),1,10) as grantee,
+   t143_udr.translateBitmap(privileges_bitmap) as granted_privs,
+   t143_udr.translateBitmap(grantable_bitmap) as grantable_privs
+from "_PRIVMGR_MD_".column_privileges
+where object_uid in
+     (select object_uid
+      from "_MD_".objects
+      where object_name like 'U%' and schema_name like 'T143_USER%')
+  order by 1, 2, 3, 4
+;
+
+-- set up role infrastructure
+create role user2_role;
+create role user3_role;
+grant role user2_role to sql_user2;
+grant role user3_role to sql_user3;
+
+-- ============================================================================
+?section test_view_object_priv_propagation
+-- ============================================================================
+values (user);
+
+-- remove schemas 
+drop schema if exists t143_user1 cascade;
+drop schema if exists t143_user2 cascade;
+
+-- setup database with private schemas owned by users
+create schema t143_user1 authorization sql_user1;
+create schema t143_user2 authorization sql_user2;
+
+-- create some tables owned by user1
+set schema t143_user1;
+create table u1t1 (c1 int not null primary key, c2 int, c3 int);
+insert into u1t1 values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
+create table u1t2 (c1 int not null primary key, c2 int, c3 int);
+insert into u1t2 values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
+
+-- grant privileges to sql_user2 on tables
+grant select, delete on u1t1 to sql_user2;
+grant select, delete on u1t2 to sql_user2 with grant option;
+
+execute get_obj_privs;
+
+-- user2 creates some views
+sh sqlci -i "TEST143(user2_views)" -u sql_user2;
+
+execute get_obj_privs;
+
+-- user1 grants insert privilege on tables
+--    u2v1 should have insert priv
+--    u2v2 should have insert priv WGO
+grant insert on u1t1 to sql_user2;
+grant insert on u1t2 to sql_user2 with grant option;
+execute get_obj_privs;
+
+-- remove with grant option for some privileges
+--    u2v2 should have insert, delete without WGO
+--    u2v2 should have select WGO
+revoke grant option for insert, delete on u1t2 from sql_user2;
+execute get_obj_privs;
+
+-- Add back the with grant option for delete
+--    u2v2 should have select, delete with WGO
+grant delete on u1t2 to sql_user2 with grant option;
+execute get_obj_privs;
+
+-- Remove insert, and delete entirely
+--    u2v2 has select WGO
+revoke insert, delete on u1t1 from sql_user2;
+revoke insert, delete on u1t2 from sql_user2;
+execute get_obj_privs;
+
+-- ============================================================================
+?section test_view_column_priv_propagation
+-- ============================================================================
+
+-- regression test 129 tests that views can be created based on column privs
+--  and that revoke works (or fails) according to specifications.
+-- this section tests that privileges are propagated to dependent views when 
+--  privs are changed on referenced objects
+values (user);
+
+-- remove schemas
+drop schema if exists t143_user1 cascade;
+drop schema if exists t143_user3 cascade;
+
+-- setup database with private schemas owned by users
+create schema t143_user1 authorization sql_user1;
+create schema t143_user3 authorization sql_user3;
+
+-- create some tables owned by user1
+set schema t143_user1;
+create table u1t1 (c1 int not null primary key, c2 int, c3 int);
+insert into u1t1 values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
+create table u1t2 (c1 int not null primary key, c2 int, c3 int);
+insert into u1t2 values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
+create table u1t3 (c1 int not null primary key, c2 int, c3 int, c4 int);
+insert into u1t3 values (1,1,1,1), (2,2,2,2), (3,3,3,3), (4,4,4,4), (5,5,5,5);
+
+-- grant column level privileges to sql_user3
+grant select (c1,c2) on t143_user1.u1t1 to sql_user3;
+grant select (c1,c3) on t143_user1.u1t2 to sql_user3 with grant option;
+grant select (c2,c3,c1,c4) on t143_user1.u1t3 to sql_user3;
+execute get_col_privs;
+
+-- user3 can create all views
+sh sqlci -i "TEST143(user3_views)" -u sql_user3;
+
+-- Add column privs to tables that are propagated to views
+--   u3v1 can now insert without WGO
+--   u3v2 still cannot insert
+--   u3v3 can insert without WGO
+--   u3v4 can update without WGO
+grant insert (c1, c2) on t143_user1.u1t1 to sql_user3;
+grant insert (c1) on t143_user1.u1t2 to sql_user3;
+grant update on t143_user1.u1t3 to sql_user3;
+execute get_obj_privs;
+execute get_col_privs;
+
+-- Revoke privileges
+--   u3v1 can no longer insert even though one column has insert priv
+--   u3v3 can no longer insert
+--   u3v4 can not longer update
+revoke insert (c1) on t143_user1.u1t1 from sql_user3;
+revoke insert (c1) on t143_user1.u1t2 from sql_user3;
+revoke update  on t143_user1.u1t3 from sql_user3;
+execute get_obj_privs;
+execute get_col_privs;
+
+-- Test WGO grants 
+--  grant WGO
+grant references (c1, c2, c3) on t143_user1.u1t1 to sql_user3 with grant option;
+execute get_obj_privs;
+-- revoke WGO
+revoke grant option for references (c1) on t143_user1.u1t1 from sql_user3;
+execute get_obj_privs;
+execute get_col_privs;
+
+-- ============================================================================
+?section test_view_role_priv_propagation
+-- ============================================================================
+values (user);
+
+-- remove schemas
+drop schema if exists t143_user1 cascade;
+drop schema if exists t143_user2 cascade;
+drop schema if exists t143_user3 cascade;
+
+-- setup database with private schemas owned by users
+create schema t143_user1 authorization sql_user1;
+create schema t143_user2 authorization sql_user2;
+create schema t143_user3 authorization sql_user3;
+
+-- create some tables owned by user1
+set schema t143_user1;
+create table u1t1 (c1 int not null primary key, c2 int, c3 int);
+insert into u1t1 values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
+create table u1t2 (c1 int not null primary key, c2 int, c3 int);
+insert into u1t2 values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
+create table u1t3 (c1 int not null primary key, c2 int, c3 int, c4 int);
+insert into u1t3 values (1,1,1,1), (2,2,2,2), (3,3,3,3), (4,4,4,4), (5,5,5,5);
+
+-- grant privileges to roles on tables
+grant select (c1,c2,c3) on t143_user1.u1t1 to user2_role;
+grant select (c1,c2) on t143_user1.u1t1 to user3_role;
+grant select (c1,c2,c3) on t143_user1.u1t2 to user2_role with grant option;
+grant select (c1,c3) on t143_user1.u1t2 to user3_role with grant option;
+grant select (c2,c3,c1,c4) on t143_user1.u1t3 to user3_role;
+
+-- create views
+grant role user2_role to sql_user2;
+grant role user3_role to sql_user3;
+sh sqlci -i "TEST143(user2_views)" -u sql_user2;
+sh sqlci -i "TEST143(user3_views)" -u sql_user3;
+
+-- user1 grants insert privilege on tables to roles
+--    u2v1 should have insert priv without WGO
+--    u2v2 should have insert priv WGO
+--    u3v1 should have insert priv without WGO
+--    u3v2 should not be granted insert, only one col
+--    u3v3 should have insert priv without WGO
+--    u3v4 shoud have update without WGO, select with WGO
+grant insert on u1t1 to user2_role;
+grant insert on u1t2 to user2_role with grant option;
+grant insert (c1, c2) on t143_user1.u1t1 to user3_role;
+grant insert (c1) on t143_user1.u1t2 to user3_role;
+grant update on t143_user1.u1t3 to user3_role;
+grant select (c2, c3, c1,c4) on t143_user1.u1t3 to user3_role with grant option;
+execute get_obj_privs;
+execute get_col_privs;
+
+-- Reset privs
+revoke insert on u1t1 from user2_role;
+revoke grant option for insert on u1t2 from user2_role;
+revoke insert (c1, c2) on t143_user1.u1t1 from user3_role;
+revoke insert (c1) on t143_user1.u1t2 from user3_role;
+revoke update on t143_user1.u1t3 from user3_role;
+revoke grant option for select (c2, c3) on t143_user1.u1t3 from user3_role; 
+execute get_obj_privs;
+execute get_col_privs;
+
+-- ============================================================================
+?section test_view_misc_priv_propagation
+-- ============================================================================
+--
+-- Verifies that multiple views with different owners don't cause issues
+-- 
+--  Views:
+--
+-- u1v1 -> u1t1
+-- u5v1 -> u1t1
+-- u5v2 -> u1t1
+-- u2v1 -> u1v1 -> u1t1
+-- u3v1 -> u2v1 -> u1v1 ->u1t1
+-- u3v2 -> u3v1 -> u2v1 -> u1v1 -> u1t1
+
+values (user);
+
+-- remove schemas
+drop schema if exists t143_user1 cascade;
+drop schema if exists t143_user2 cascade;
+drop schema if exists t143_user3 cascade;
+drop schema if exists t143_user5 cascade;
+
+-- setup database with private schemas owned by users
+create schema t143_user1 authorization sql_user1;
+create schema t143_user2 authorization user2_role;
+create schema t143_user3 authorization sql_user3;
+create schema t143_user5 authorization sql_user5;
+
+-- create objects owned by sql_user1
+set schema t143_user1;
+create table u1t1 (c1 int not null primary key, c2 int, c3 int);
+insert into u1t1 values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);
+grant select (c1) on u1t1 to sql_user5;
+grant select (c2, c3) on u1t1 to sql_user5 with grant option;
+
+create view u1v1 (u1v1_c1, u1v1_c2) as select c2, c3 from u1t1;
+grant select on u1v1 to user2_role with grant option;
+grant select on u1v1 to sql_user5;
+
+-- create objects for role user2_role;
+set schema t143_user2;
+create view u2v1 (u2v1_c1, u2v1_c2) as
+  select u1v1_c2, u1v1_c1 from t143_user1.u1v1;
+grant select (u2v1_c1, u2v1_c2) on u2v1 to sql_user3;
+grant select on u2v1 to sql_user6 with grant option;
+grant select (u2v1_c2) on u2v1 to sql_user6;
+
+-- create objects for user sql_user3
+set schema t143_user3;
+create view u3v1 (u3v1_c1, u3v1_c2) as
+  select u2v1_c2, u2v1_c1 
+  from t143_user2.u2v1;
+
+-- create objects for user sq1_user5
+set schema t143_user5;
+create view u5v1(u5v1_c1, u5v1_c2, u5v1_c3) as 
+   select * from t143_user1.u1t1;
+create view u5v2 (u5v1_c1) as
+  select u5v1_c2 from t143_user5.u5v1, t143_user1.u1v1;
+ 
+-- u1v1 user1 grants: select user2_role WGO, select user5
+-- u2v1 user2-role grants: select user6 WGO
+execute get_obj_privs;
+
+-- u1t1 user1 grants: c1-select, c2/c3-select WGO user5
+-- u2v1 user2_role grants: c1/c2-select user3, select-c2 user6
+execute get_col_privs;
+
+-- Run some different tests:
+
+-- fails with no priv
+grant select (u3v1_c1, u3v1_c2) on t143_user3.u3v1 to sql_user4;
+
+-- user2_role grants to user3 WGO
+grant select (u2v1_c1, u2v1_c2) on t143_user2.u2v1 to sql_user3 with grant option;
+
+-- now user3's grant works, user4 can create views on u3v1
+grant select (u3v1_c1, u3v1_c2) on t143_user3.u3v1 to sql_user4;
+
+-- grant insert on user1's table, doesn't affect any views
+grant insert on t143_user1.u1t1 to user2_role with grant option;
+
+-- u1t1 user1 grants: insert user2_role WGO
+execute get_obj_privs;
+-- u2v1 user2_role grants: + c1/c2 WGO user3 
+-- u3v1 user3 grants: select-c1/c2 user4
+execute get_col_privs;
+
+-- grant insert on user1's view
+-- fails because u1v1 is not an insertable view
+-- unfortunately, the returned error is not the best
+grant insert on t143_user1.u1v1 to user2_role;
+
+-- grant update on user1's view, this works
+grant update on t143_user1.u1v1 to user2_role;
+
+-- grant privileges by user5, these fail
+grant select on t143_user5.u5v1 to sql_user4;
+grant select (u5v1_c1, u5v1_c2, u5v1_c3) on t143_user5.u5v1 to sql_user4; 
+
+-- this fails, sql_user5 has WGO for the underlying column (u5v1_c2) but the
+-- columns cannot be split
+grant select (u5v1_c2) on t143_user5.u5v1 to sql_user4; 
+
+-- this succeeds
+grant select on t143_user5.u5v2 to sql_user4; 
+
+-- u1v1 user1 grants: + update user2_role
+-- u5v2 user5 grants: c1-select user4
+execute get_obj_privs;
+execute get_col_privs;
+
+-- ============================================================================
+?section user2_views
+-- ============================================================================
+-- executed by sql_user2
+log LOG143;
+cqd SHOWDDL_DISPLAY_PRIVILEGE_GRANTS 'ON';
+values (user);
+set schema t143_user2;
+
+create view u2v1 as select * from t143_user1.u1t1;
+create view u2v2 as select * from t143_user1.u1t2;
+
+-- ============================================================================
+?section user3_views
+-- ============================================================================
+-- executed by sql_user3
+log LOG143;
+cqd SHOWDDL_DISPLAY_PRIVILEGE_GRANTS 'ON';
+values (user);
+set schema t143_user3;
+
+-- following views can be created based on granted privs
+create view u3v1 as select c1, c2 from t143_user1.u1t1;
+showddl u3v1;
+create view u3v2 as select c1, c3 from t143_user1.u1t2;
+showddl u3v2;
+create view u3v3 as select c1 from t143_user1.u1t2;
+showddl u3v3;
+create view u3v4 as select c2, c1, c4 from t143_user1.u1t3;
+showddl u3v4;
+
+get tables;
+get views;
+
+?section show_views
+showddl t143_user2.u2v1;
+showddl t143_user2.u2v2;
+showddl t143_user3.u3v1;
+showddl t143_user3.u3v2;
+showddl t143_user3.u3v3;
+showddl t143_user3.u3v4;
+
diff --git a/core/sql/sqlcat/ReadTableDef.cpp b/core/sql/sqlcat/ReadTableDef.cpp
index 31bafb7cdd..be64096fd1 100644
--- a/core/sql/sqlcat/ReadTableDef.cpp
+++ b/core/sql/sqlcat/ReadTableDef.cpp
@@ -93,4 +93,3 @@ ReadTableDef::~ReadTableDef()
   // end any transactions started by "me"
 }
 
-
diff --git a/core/sql/sqlcat/TrafDDLdesc.cpp b/core/sql/sqlcat/TrafDDLdesc.cpp
index 5bfe1d88e3..b6be69a7ff 100644
--- a/core/sql/sqlcat/TrafDDLdesc.cpp
+++ b/core/sql/sqlcat/TrafDDLdesc.cpp
@@ -603,6 +603,7 @@ Long TrafViewDesc::pack(void * space)
 
   viewtext = (viewtext ? (char*)(((Space*)space)->convertToOffset(viewtext)) : NULL);
   viewchecktext = (viewchecktext ? (char*)(((Space*)space)->convertToOffset(viewchecktext)) : NULL);
+  viewcolusages = (viewcolusages ? (char*)(((Space*)space)->convertToOffset(viewcolusages)) : NULL);
 
   return TrafDesc::pack(space);
 }
@@ -614,6 +615,7 @@ Lng32 TrafViewDesc::unpack(void * base, void * reallocator)
 
   viewtext = (viewtext ? (char*)((char*)base - (Long)viewtext) : NULL);
   viewchecktext = (viewchecktext ? (char*)((char*)base - (Long)viewchecktext) : NULL);
+  viewcolusages = (viewcolusages ? (char*)((char*)base - (Long)viewcolusages) : NULL);
 
   return TrafDesc::unpack(base, reallocator);
 }
diff --git a/core/sql/sqlcat/TrafDDLdesc.h b/core/sql/sqlcat/TrafDDLdesc.h
index b97f027f7f..f6fa7dac64 100644
--- a/core/sql/sqlcat/TrafDDLdesc.h
+++ b/core/sql/sqlcat/TrafDDLdesc.h
@@ -1096,6 +1096,7 @@ class TrafViewDesc : public TrafDesc {
   char*  viewfilename;    // the physical file, to be Opened for auth-cking.
   char*  viewtext;
   char*  viewchecktext;
+  char*  viewcolusages;
 
   Int64 viewDescFlags; // my flags
 
diff --git a/core/sql/sqlcomp/CmpDDLCatErrorCodes.h b/core/sql/sqlcomp/CmpDDLCatErrorCodes.h
index 25f439cbbb..55d0468436 100644
--- a/core/sql/sqlcomp/CmpDDLCatErrorCodes.h
+++ b/core/sql/sqlcomp/CmpDDLCatErrorCodes.h
@@ -59,7 +59,7 @@ enum CatErrorCode { CAT_FIRST_ERROR = 1000
                   , CAT_FS_ERROR                                  = 1024
                   , CAT_DEPENDENT_OBJECTS_EXIST                   = 1025
                   , CAT_SCHEMA_ID_AND_USER_ID_DO_NOT_MATCH        = 1026
-                  , CAT_DEFINITION_SCHEMA_CAN_NOT_BE_DROPPED_BY_USER
+                  , CAT_COLUMN_PRIVILEGE_NOT_ALLOWED              = 1027
                   , CAT_SCHEMA_IS_NOT_EMPTY                       = 1028
                   , CAT_UNABLE_TO_CREATE_OBJECT                   = 1029
                   , CAT_HBASE_NAME_TOO_LONG                       = 1030
diff --git a/core/sql/sqlcomp/CmpSeabaseDDL.h b/core/sql/sqlcomp/CmpSeabaseDDL.h
index c150a26462..64ca868aa7 100644
--- a/core/sql/sqlcomp/CmpSeabaseDDL.h
+++ b/core/sql/sqlcomp/CmpSeabaseDDL.h
@@ -833,6 +833,10 @@ class CmpSeabaseDDL
   short buildViewColInfo(StmtDDLCreateView * createViewParseNode,
 			 ElemDDLColDefArray * colDefArray);
   
+  short buildViewTblColUsage(const StmtDDLCreateView * createViewParseNode,
+                             const ComTdbVirtTableColumnInfo * colInfoArray,
+                             const Int64 viewObjUID, NAString &viewColUsageText);
+
   short buildColInfoArray(ElemDDLParamDefArray *paramArray,
                           ComTdbVirtTableColumnInfo * colInfoArray);
   
@@ -855,6 +859,7 @@ class CmpSeabaseDDL
   short gatherViewPrivileges (const StmtDDLCreateView * createViewParseNode,
                               ExeCliInterface * cliInterface,
                               NABoolean viewCreator,
+                              Int32 userID,
                               PrivMgrBitmap &privilegesBitmap,
                               PrivMgrBitmap &grantableBitmap);
 
diff --git a/core/sql/sqlcomp/CmpSeabaseDDLtable.cpp b/core/sql/sqlcomp/CmpSeabaseDDLtable.cpp
index a44a44a79f..4ea4d51818 100644
--- a/core/sql/sqlcomp/CmpSeabaseDDLtable.cpp
+++ b/core/sql/sqlcomp/CmpSeabaseDDLtable.cpp
@@ -11201,6 +11201,18 @@ TrafDesc * CmpSeabaseDDL::getSeabaseUserTableDesc(const NAString &catName,
 
       viewInfoArray[0].viewText = new(STMTHEAP) char[viewText.length() + 1];
       strcpy(viewInfoArray[0].viewText, viewText.data());
+
+      // get view col usages from TEXT table
+      NAString viewColUsages;
+      if (getTextFromMD(&cliInterface, objUID, COM_VIEW_REF_COLS_TEXT, 0, viewColUsages))
+        {
+          processReturn();
+          
+          return NULL;
+        }
+
+      viewInfoArray[0].viewColUsages = new(STMTHEAP) char[viewColUsages.length() + 1];
+      strcpy(viewInfoArray[0].viewColUsages, viewColUsages.data());
     }
 
   ComTdbVirtTableSequenceInfo * seqInfo = NULL;
diff --git a/core/sql/sqlcomp/CmpSeabaseDDLview.cpp b/core/sql/sqlcomp/CmpSeabaseDDLview.cpp
index b423d9b68f..50be2fe96a 100644
--- a/core/sql/sqlcomp/CmpSeabaseDDLview.cpp
+++ b/core/sql/sqlcomp/CmpSeabaseDDLview.cpp
@@ -40,6 +40,7 @@
 
 #include "ComObjectName.h"
 #include "ComUser.h"
+#include "ComViewColUsage.h"
 
 #include "StmtDDLCreateView.h"
 #include "StmtDDLDropView.h"
@@ -66,6 +67,7 @@ static bool checkAccessPrivileges(
    const ParTableUsageList & vtul,
    const ParViewColTableColsUsageList & vctcul,
    NABoolean viewCreator,
+   Int32 userID,
    PrivMgrBitmap & privilegesBitmap,
    PrivMgrBitmap & grantableBitmap);
 
@@ -247,6 +249,60 @@ short CmpSeabaseDDL::buildViewColInfo(StmtDDLCreateView * createViewParseNode,
   return 0;
 }
 
+// Build view column usages -> relate view-col <=> referenced-col
+// This relationship is a string of values that gets stored in the TEXT table
+short CmpSeabaseDDL::buildViewTblColUsage(const StmtDDLCreateView * createViewParseNode,
+                                          const ComTdbVirtTableColumnInfo * colInfoArray,
+                                          const Int64 objUID, NAString &viewColUsageText)
+{
+  const ParViewUsages &vu = createViewParseNode->getViewUsages();
+  const ParViewColTableColsUsageList &vctcul = vu.getViewColTableColsUsageList();
+  BindWA bindWA(ActiveSchemaDB(),CmpCommon::context(),FALSE/*inDDL*/);
+
+  for (size_t i = 0; i < vctcul.entries(); i++)
+  {
+     const ParViewColTableColsUsage &vctcu = vctcul[i];
+     int32_t usingColNum = vctcu.getUsingViewColumnNumber();
+
+     // Get column number for referenced table
+     const ColRefName &usedColRef = vctcu.getUsedObjectColumnName();
+     ComObjectName usedObjName;
+     usedObjName = usedColRef.getCorrNameObj().getQualifiedNameObj().
+                   getQualifiedNameAsAnsiString();
+
+     const NAString catalogNamePart = usedObjName.getCatalogNamePartAsAnsiString();
+     const NAString schemaNamePart = usedObjName.getSchemaNamePartAsAnsiString(TRUE);
+     const NAString objectNamePart = usedObjName.getObjectNamePartAsAnsiString(TRUE);
+     CorrName cn(objectNamePart,STMTHEAP,schemaNamePart,catalogNamePart);
+
+     NATable *naTable = bindWA.getNATable(cn);
+     if (naTable == NULL)
+     {
+        SEABASEDDL_INTERNAL_ERROR("Bad NATable pointer in createSeabaseView");
+        return -1;
+     }
+
+     const NAColumnArray &nacolArr = naTable->getNAColumnArray();
+     ComString usedObjColName(usedColRef.getColName());
+     const NAColumn * naCol = nacolArr.getColumn(usedObjColName);
+     if (naCol == NULL)
+     {
+       *CmpCommon::diags() << DgSqlCode(-CAT_COLUMN_DOES_NOT_EXIST_ERROR)
+                           << DgColumnName(usedObjColName);
+        return -1;
+     }
+
+     ComViewColUsage colUsage(objUID, usingColNum, 
+                              naTable->objectUid().get_value(),
+                              naCol->getPosition(),
+                              naTable->getObjectType());
+     NAString viewColUsageStr;
+     colUsage.packUsage(viewColUsageStr);
+     viewColUsageText += viewColUsageStr;
+  }
+  return 0;
+}
+
 const char *
 CmpSeabaseDDL::computeCheckOption(StmtDDLCreateView * createViewParseNode) 
 {
@@ -367,6 +423,8 @@ short CmpSeabaseDDL::updateViewUsage(StmtDDLCreateView * createViewParseNode,
 //    createViewNode - for list of objects and isUpdatable/isInsertable flags
 //    cliInterface - used to get UID of referenced object
 //    viewCreator - determines which authID to use to gather privs
+//    userID - userID to use when root is performing operations on behalf 
+//      of another user.
 //    privilegeBitmap - returns privileges this user has on the view
 //    grantableBitmap - returns privileges this user can grant
 //
@@ -377,6 +435,7 @@ short CmpSeabaseDDL::updateViewUsage(StmtDDLCreateView * createViewParseNode,
 short CmpSeabaseDDL::gatherViewPrivileges (const StmtDDLCreateView * createViewNode,
 				           ExeCliInterface * cliInterface,
                                            NABoolean viewCreator,
+                                           Int32 userID,
                                            PrivMgrBitmap &privilegesBitmap,
                                            PrivMgrBitmap &grantableBitmap)
 {
@@ -394,8 +453,7 @@ short CmpSeabaseDDL::gatherViewPrivileges (const StmtDDLCreateView * createViewN
   const ParViewColTableColsUsageList &vctcul = vu.getViewColTableColsUsageList();
 
   // If DB__ROOT, no need to gather privileges
-  if (!ComUser::isRootUserID() && 
-      !checkAccessPrivileges(vtul,vctcul,viewCreator,privilegesBitmap,grantableBitmap))
+  if (!checkAccessPrivileges(vtul,vctcul,viewCreator,userID,privilegesBitmap,grantableBitmap))
     return -1;
 
   // If view is not updatable or insertable, turn off privs in bitmaps
@@ -725,11 +783,17 @@ void CmpSeabaseDDL::createSeabaseView(
     ((schemaClass == COM_SCHEMA_CLASS_SHARED) ? TRUE : 
       ((ComUser::getCurrentUser() == schemaOwnerID) ? TRUE : FALSE));
  
+  // If DB ROOT is running command on behalf of another user, then the view
+  // owner is the same of the view creator
+  if (ComUser::isRootUserID() && (ComUser::getRootUserID() != schemaOwnerID))
+    viewOwnerIsViewCreator = TRUE;
+
   // Gather privileges for the view creator
   NABoolean viewCreator = TRUE;
   if (gatherViewPrivileges(createViewNode, 
                            &cliInterface, 
                            viewCreator,
+                           schemaOwnerID,
                            privilegesBitmap, 
                            grantableBitmap))
     {
@@ -745,7 +809,7 @@ void CmpSeabaseDDL::createSeabaseView(
 
   // If view owner is the same as view creator, owner and creator privileges
   // are the same
-  if (viewOwnerIsViewCreator)
+  if (viewOwnerIsViewCreator) 
     {
       ownerPrivBitmap = privilegesBitmap;
       ownerGrantableBitmap = grantableBitmap; 
@@ -758,6 +822,7 @@ void CmpSeabaseDDL::createSeabaseView(
       if (gatherViewPrivileges(createViewNode, 
                                &cliInterface, 
                                !viewCreator,
+                               schemaOwnerID,
                                ownerPrivBitmap, 
                                ownerGrantableBitmap))
         {
@@ -831,6 +896,14 @@ void CmpSeabaseDDL::createSeabaseView(
         return;
       }
 
+  NAString viewColUsageText;
+  if (buildViewTblColUsage(createViewNode, colInfoArray, objUID,  viewColUsageText))
+    {
+      deallocEHI(ehi); 
+      processReturn();
+      return;
+    }
+
   // grant privileges for view
   if (isAuthorizationEnabled())
     {
@@ -843,6 +916,8 @@ void CmpSeabaseDDL::createSeabaseView(
       // Calculate the view owner (grantee)
       int32_t grantee = (viewOwnerIsViewCreator) 
          ? ComUser::getCurrentUser() : schemaOwnerID;
+      if (ComUser::isRootUserID() && (ComUser::getRootUserID() != schemaOwnerID))
+        grantee = schemaOwnerID;
       
       // Grant view ownership - grantor is the SYSTEM
       retcode = privInterface.grantObjectPrivilege 
@@ -920,6 +995,18 @@ void CmpSeabaseDDL::createSeabaseView(
       return;
     }
 
+  // Views that contain UNION clauses do not have col usages available so 
+  // viewColUsageText could be null - see TRAFODION-2153
+  if (!viewColUsageText.isNull())
+    {
+      if (updateTextTable(&cliInterface, objUID, COM_VIEW_REF_COLS_TEXT, 0, viewColUsageText))
+        {
+          deallocEHI(ehi);
+          processReturn();
+          return;
+        }
+    }
+
   if (updateViewUsage(createViewNode, objUID, &cliInterface))
     {
       deallocEHI(ehi); 
@@ -1457,6 +1544,10 @@ short CmpSeabaseDDL::dropMetadataViews(ExeCliInterface * cliInterface)
 // *    If TRUE, gather privileges for the view creator, if FALSE,             *
 // *    gather privileges for the view owner                                   *
 // *                                                                           *
+// *  <userID>               Int32                                  In         *
+// *     userID to use when root is performing operations on behalf            *
+// *     of another user.                                                      *
+// *                                                                           *
 // *  <privilegesBitmap>       PrivMgrBitmap &                        Out      *
 // *    passes back the union of privileges the user has on the referenced     *
 // *    objects.                                                               *
@@ -1478,20 +1569,20 @@ static bool checkAccessPrivileges(
    const ParTableUsageList & vtul,
    const ParViewColTableColsUsageList & vctcul,
    NABoolean viewCreator,
+   Int32 userID,
    PrivMgrBitmap & privilegesBitmap,
    PrivMgrBitmap & grantableBitmap)
    
 {
   BindWA bindWA(ActiveSchemaDB(),CmpCommon::context(),FALSE/*inDDL*/);
-  bool missingPrivilege = false;
-  NAString extUsedObjName;
+  PrivStatus retcode = STATUS_GOOD;
 
   NAString privMgrMDLoc;
   CONCAT_CATSCH(privMgrMDLoc,CmpSeabaseDDL::getSystemCatalogStatic(),SEABASE_PRIVMGR_SCHEMA);
   PrivMgrCommands privInterface(std::string(privMgrMDLoc.data()),
                                 CmpCommon::diags());
 
-  // generate the lists of privileges and grantable privileges
+  // generate the list of privileges and grantable privileges to assign to the view
   // a side effect is to return an error if basic privileges are not granted
    for (CollIndex i = 0; i < vtul.entries(); i++)
    {
@@ -1501,7 +1592,7 @@ static bool checkAccessPrivileges(
       const NAString catalogNamePart = usedObjName.getCatalogNamePartAsAnsiString();
       const NAString schemaNamePart = usedObjName.getSchemaNamePartAsAnsiString(TRUE);
       const NAString objectNamePart = usedObjName.getObjectNamePartAsAnsiString(TRUE);
-      NAString extUsedObjName = usedObjName.getExternalName(TRUE);
+      NAString refdUsedObjName = usedObjName.getExternalName(TRUE);
       CorrName cn(objectNamePart,STMTHEAP, schemaNamePart,catalogNamePart);
  
       // If a sequence, set correct type to get a valid NATable entry
@@ -1512,7 +1603,7 @@ static bool checkAccessPrivileges(
       NATable *naTable = bindWA.getNATable(cn);
       if (naTable == NULL)
       {
-          SEABASEDDL_INTERNAL_ERROR("Bad NATable pointer in checkAccessPrivileges");
+         SEABASEDDL_INTERNAL_ERROR("Bad NATable pointer in checkAccessPrivileges");
          return false; 
       }
 
@@ -1523,8 +1614,28 @@ static bool checkAccessPrivileges(
       // contains the privileges we want to use to create bitmaps
       if (viewCreator)
       {
-        pPrivInfo = naTable->getPrivInfo();
-        CMPASSERT(pPrivInfo != NULL);
+        // If the viewCreator is not the current user (DB__ROOT running request)
+        // on behalf of the schema owner), get actual owner privs.
+        if (ComUser::isRootUserID() &&
+            ComUser::getRootUserID() != naTable->getSchemaOwner())
+        {
+          retcode = privInterface.getPrivileges((int64_t)naTable->objectUid().get_value(),
+                                                 naTable->getObjectType(),
+                                                 userID,
+                                                 privs);
+
+          if (retcode == STATUS_ERROR)
+          {         
+             *CmpCommon::diags() << DgSqlCode(-CAT_UNABLE_TO_RETRIEVE_PRIVS);
+             return false;
+          }
+          pPrivInfo = &privs;
+        }
+        else
+        {
+          pPrivInfo = naTable->getPrivInfo();
+          CMPASSERT(pPrivInfo != NULL);
+        }
       }
       
       // If the view owner is not the view creator, then we need to get schema
@@ -1546,119 +1657,78 @@ static bool checkAccessPrivileges(
 
       // Requester must have at least select privilege
       // For sequence generators USAGE is needed instead of SELECT
+      bool noObjRequiredPriv = true;
       if  (isSeq)
-        missingPrivilege = !pPrivInfo->hasUsagePriv() ? true : false;
+        noObjRequiredPriv = !pPrivInfo->hasUsagePriv() ? true : false;
       else  
-        missingPrivilege = !pPrivInfo->hasSelectPriv() ? true : false; 
+        noObjRequiredPriv = !pPrivInfo->hasSelectPriv() ? true : false; 
 
       // Summarize privileges
       privilegesBitmap &= pPrivInfo->getObjectBitmap();
       grantableBitmap &= pPrivInfo->getGrantableBitmap();
-   }
    
-   //  To create a view you need at least select privilege, noSelectPriv
-   //  is true if the auth ID does not have select privilege at the object
-   //  level.  The view can still be created if select exists at the column
-   //  level.
-   bool noObjPriv = missingPrivilege;
-   missingPrivilege = false;   
-      
-   // Gather column level privs to attach to the bitmap.
-   // Even though privileges are granted on the column, they show up as
-   // object privileges on the view.
-   PrivColumnBitmap colPrivBitmap;
-   PrivColumnBitmap colGrantableBitmap;
-
-   PrivMgrPrivileges::setColumnPrivs(colPrivBitmap);
-   PrivMgrPrivileges::setColumnPrivs(colGrantableBitmap);
-
-   for (size_t i = 0; i < vctcul.entries(); i++)
-   {
-      const ParViewColTableColsUsage &vctcu = vctcul[i];
-      int32_t usingColNum = vctcu.getUsingViewColumnNumber();
-      const ColRefName &usedColRef = vctcu.getUsedObjectColumnName();
-      
-      ComObjectName usedObjName;
-
-      usedObjName = usedColRef.getCorrNameObj().getQualifiedNameObj().
-                    getQualifiedNameAsAnsiString();
-
-      const NAString catalogNamePart = usedObjName.getCatalogNamePartAsAnsiString();
-      const NAString schemaNamePart = usedObjName.getSchemaNamePartAsAnsiString(TRUE);
-      const NAString objectNamePart = usedObjName.getObjectNamePartAsAnsiString(TRUE);
-      extUsedObjName = usedObjName.getExternalName(TRUE);
-      CorrName cn(objectNamePart,STMTHEAP,schemaNamePart,catalogNamePart);
-
-      NATable *naTable = bindWA.getNATable(cn);
-      if (naTable == NULL)
-      {
-         SEABASEDDL_INTERNAL_ERROR("Bad NATable pointer in checkAccessPrivileges");
-         return -1; 
-      }
-
-      const NAColumnArray &nacolArr = naTable->getNAColumnArray();
-      ComString usedObjColName(usedColRef.getColName());
-      const NAColumn * naCol = nacolArr.getColumn(usedObjColName);
-      if (naCol == NULL)
+      // Gather column level privs to attach to the bitmap.
+      // Even though privileges are granted on the column, they show up as
+      // object privileges on the view.
+      PrivColumnBitmap colPrivBitmap;
+      PrivColumnBitmap colGrantableBitmap;
+
+      PrivMgrPrivileges::setColumnPrivs(colPrivBitmap);
+      PrivMgrPrivileges::setColumnPrivs(colGrantableBitmap);
+
+      // Check for column privileges on each view column 
+      // This loop is performed for each object referenced by the view.
+      // Only those columns that belong to the referenced object have their
+      // privileges summarized.
+      for (size_t i = 0; i < vctcul.entries(); i++)
       {
-         *CmpCommon::diags() << DgSqlCode(-CAT_COLUMN_DOES_NOT_EXIST_ERROR)
-                             << DgColumnName(usedObjColName);
-         return false;
-      }
-      int32_t usedColNumber = naCol->getPosition();
+         const ParViewColTableColsUsage &vctcu = vctcul[i];
+         const ColRefName &usedColRef = vctcu.getUsedObjectColumnName();
+         ComObjectName usedObjName = 
+            usedColRef.getCorrNameObj().getQualifiedNameObj().getQualifiedNameAsAnsiString();
+         NAString colUsedObjName = usedObjName.getExternalName(TRUE);
+
+         // If column is part of the used object, summarize column privs
+         if (colUsedObjName == refdUsedObjName)
+         {
+            // Get the refd object details
+            const NAColumnArray &nacolArr = naTable->getNAColumnArray();
+            ComString usedObjColName(usedColRef.getColName());
+            const NAColumn * naCol = nacolArr.getColumn(usedObjColName);
+            if (naCol == NULL)
+            {
+               *CmpCommon::diags() << DgSqlCode(-CAT_COLUMN_DOES_NOT_EXIST_ERROR)
+                                   << DgColumnName(usedObjColName);
+               return false;
+            }
+            int32_t usedColNumber = naCol->getPosition();
      
-      PrivMgrUserPrivs privs;
-      PrivMgrUserPrivs *pPrivInfo = NULL;
-      if (viewCreator)
-        pPrivInfo = naTable->getPrivInfo();
-      else
-      {
-        PrivStatus retcode = privInterface.getPrivileges((int64_t)naTable->objectUid().get_value(),
-                                                           naTable->getObjectType(),
-                                                           naTable->getOwner(),
-                                                           privs);
-
-        if (retcode == STATUS_ERROR)
-        {
-           *CmpCommon::diags() << DgSqlCode(-CAT_UNABLE_TO_RETRIEVE_PRIVS);
-           return false;
-        }
-        pPrivInfo = &privs;
-      }
-
-      if (pPrivInfo == NULL) 
-      {         
-         *CmpCommon::diags() << DgSqlCode(-CAT_UNABLE_TO_RETRIEVE_PRIVS);
-         return false;
-      }
-
-      // If the user is missing SELECT at the object level and on at least one 
-      // column-level privilege, view cannot be created.  No need to proceed.
-      if (noObjPriv && !pPrivInfo->hasColSelectPriv(usedColNumber))
-      {
-         missingPrivilege = true;
-         break;
-      }        
+            // If the user is missing SELECT at the object level and on at least one 
+            // column, view cannot be created.  No need to proceed.
+            // Can't have sequences on views, so only need to check for SELECT
+            if (noObjRequiredPriv && !pPrivInfo->hasColSelectPriv(usedColNumber))
+            {
+              *CmpCommon::diags() << DgSqlCode(-4481)
+                                  << DgString0("SELECT")
+                                  << DgString1(colUsedObjName.data());
+              return false;
+            }        
       
-      colPrivBitmap &= pPrivInfo->getColumnPrivBitmap(usedColNumber);
-      colGrantableBitmap &= pPrivInfo->getColumnGrantableBitmap(usedColNumber);
-   }
-  
-   if (noObjPriv && missingPrivilege)
-     {
-        *CmpCommon::diags() << DgSqlCode(-4481)
-                            << DgString0("SELECT")
-                            << DgString1(extUsedObjName.data());
-        return false;
-     }
-  
-   for (size_t i = FIRST_DML_COL_PRIV; i <= LAST_DML_COL_PRIV; i++ )
-   {
-      if (colPrivBitmap.test(PrivType(i)))
-         privilegesBitmap.set(PrivType(i));   
+            colPrivBitmap &= pPrivInfo->getColumnPrivBitmap(usedColNumber);
+            colGrantableBitmap &= pPrivInfo->getColumnGrantableBitmap(usedColNumber);
+         } // done with current view col 
+      } // done checking privs for all view cols
+
+      // Add summarize column privileges to the official bitmaps, bit is only
+      // set if all cols have priv set.
+      for (size_t i = FIRST_DML_COL_PRIV; i <= LAST_DML_COL_PRIV; i++ )
+      {
+         if (colPrivBitmap.test(PrivType(i)))
+            privilegesBitmap.set(PrivType(i));   
  
-      if (colGrantableBitmap.test(PrivType(i)))
-         grantableBitmap.set(PrivType(i));   
+         if (colGrantableBitmap.test(PrivType(i)))
+            grantableBitmap.set(PrivType(i));   
+      }
    }
    
    return true;
diff --git a/core/sql/sqlcomp/PrivMgr.h b/core/sql/sqlcomp/PrivMgr.h
index da7145e1df..e7f412e735 100644
--- a/core/sql/sqlcomp/PrivMgr.h
+++ b/core/sql/sqlcomp/PrivMgr.h
@@ -68,11 +68,27 @@ class PrivMgr
                           };
 
     enum PrivCommand { GRANT_OBJECT           = 30,
-                       REVOKE_OBJECT_RESTRICT = 31,
-                       REVOKE_OBJECT_CASCADE  = 32,
-                       UNKNOWN_PRIV_COMMAND   = 33
+                       GRANT_COLUMN           = 31,
+                       REVOKE_OBJECT_RESTRICT = 32,
+                       REVOKE_OBJECT_CASCADE  = 33,
+                       REVOKE_COLUMN_RESTRICT = 34,
+                       REVOKE_COLUMN_CASCADE  = 35,
+                       UNKNOWN_PRIV_COMMAND   = 36
                      };
 
+    bool isRevokeCommand (const PrivCommand command)
+    {
+      return (command == REVOKE_OBJECT_RESTRICT ||
+              command == REVOKE_OBJECT_CASCADE ||
+              command == REVOKE_COLUMN_RESTRICT ||
+              command == REVOKE_COLUMN_CASCADE);
+    }
+
+    bool isGrantCommand (const PrivCommand command)
+    {
+      return (command == GRANT_OBJECT || command == GRANT_COLUMN);
+    }
+
     // -------------------------------------------------------------------
     // Static functions:
     // -------------------------------------------------------------------
diff --git a/core/sql/sqlcomp/PrivMgrMD.cpp b/core/sql/sqlcomp/PrivMgrMD.cpp
index df0ca1c79b..4af666cbeb 100644
--- a/core/sql/sqlcomp/PrivMgrMD.cpp
+++ b/core/sql/sqlcomp/PrivMgrMD.cpp
@@ -629,6 +629,130 @@ bool PrivMgrMDAdmin::isAuthorized (void)
   return ComUser::isRootUserID();
 }
 
+// ****************************************************************************
+// method:  getColumnReferences
+//
+//  This method stores the list of columns for the object in the 
+//  ObjectReference. 
+// **************************************************************************** 
+PrivStatus PrivMgrMDAdmin::getColumnReferences (ObjectReference *objectRef)
+{
+  std::string colMDTable = trafMetadataLocation_ + ".COLUMNS c";
+
+  // Select column details for object 
+  std::string selectStmt = "select c.column_number from ";
+  selectStmt += colMDTable;
+  selectStmt += " where c.object_uid = ";
+  selectStmt += UIDToString(objectRef->objectUID);
+  selectStmt += " order by column_number";
+
+  ExeCliInterface cliInterface(STMTHEAP, NULL, NULL,
+  CmpCommon::context()->sqlSession()->getParentQid());
+  Queue * objectsQueue = NULL;
+
+  int32_t cliRC =  cliInterface.fetchAllRows(objectsQueue, (char *)selectStmt.c_str(), 0, FALSE, FALSE, TRUE);
+  if (cliRC < 0)
+  {
+    cliInterface.retrieveSQLDiagnostics(pDiags_);
+    return STATUS_ERROR;
+  }
+
+  if (cliRC == 100) // did not find the row
+  {
+    std::string message ("No columns found for referenced object");
+    PRIVMGR_INTERNAL_ERROR(message.c_str());
+    return STATUS_ERROR;
+  }
+
+  char * ptr = NULL;
+  Int32 len = 0;
+
+  objectRef->columnReferences = new std::vector<ColumnReference *>;
+
+  // For each row, create a ColumnReference and add it to the objectRef
+  objectsQueue->position();
+  for (int idx = 0; idx < objectsQueue->numEntries(); idx++)
+  {
+    OutputInfo * pCliRow = (OutputInfo*)objectsQueue->getNext();
+    ColumnReference *columnReference = new ColumnReference;
+
+    // column 0:  columnNumber
+    pCliRow->get(0,ptr,len);
+    columnReference->columnOrdinal = *(reinterpret_cast<int32_t*>(ptr));
+
+    objectRef->columnReferences->push_back(columnReference);
+  }
+  return STATUS_GOOD;
+}
+
+// ****************************************************************************
+// method:  getViewColUsages
+//
+//  This method reads the TEXT table to obtain the view-col <=> referenced-col
+//  relationship.
+//
+//  This relationship is stored in one or more text records with the text_type
+//  COM_VIEW_REF_COLS_TEXT (8) see ComSmallDefs.h 
+//
+//  The text rows are concatenated together and saved in the ViewUsage.
+// **************************************************************************** 
+PrivStatus PrivMgrMDAdmin::getViewColUsages (ViewUsage &viewUsage)
+{
+  std::string textMDTable = trafMetadataLocation_ + ".TEXT t";
+
+  // Select text rows describing view <=> object column relationships
+  std::string selectStmt = "select text from ";
+  selectStmt += textMDTable;
+  selectStmt += " where t.text_uid = ";
+  selectStmt += UIDToString(viewUsage.viewUID);
+  selectStmt += "and t.text_type = 8";
+  selectStmt += " order by seq_num";
+  
+  ExeCliInterface cliInterface(STMTHEAP, NULL, NULL,
+  CmpCommon::context()->sqlSession()->getParentQid());
+  Queue * objectsQueue = NULL;
+  
+  int32_t cliRC =  cliInterface.fetchAllRows(objectsQueue, (char *)selectStmt.c_str(), 0, FALSE, FALSE, TRUE);
+  if (cliRC < 0)
+  { 
+    cliInterface.retrieveSQLDiagnostics(pDiags_);
+    return STATUS_ERROR;
+  }
+  
+  // View prior to column privilege support do not store view <=> object column
+  // relationships.  These views were not created based on column privileges
+  // so just return.
+  if (cliRC == 100) // did not find the row
+  { 
+    return STATUS_NOTFOUND;
+  }
+  
+  char * ptr = NULL;
+  Int32 len = 0;
+
+  // the text column length in the TEXT table is 10000
+  char value[10000 + 1];
+  
+  // For each row, add it to the existing viewColUsages string
+  objectsQueue->position();
+  for (int idx = 0; idx < objectsQueue->numEntries(); idx++)
+  { 
+    OutputInfo * pCliRow = (OutputInfo*)objectsQueue->getNext();
+
+    // column 0: text 
+    pCliRow->get(0,ptr,len);
+    strncpy(value, ptr, len);
+    value[len] = 0;
+    viewUsage.viewColUsagesStr += value;
+  }
+
+  return STATUS_GOOD;
+} 
+
+
+
+
+
 // ****************************************************************************
 // method:  getViewsThatReferenceObject
 //
@@ -665,6 +789,12 @@ PrivStatus PrivMgrMDAdmin::getViewsThatReferenceObject (
   selectStmt += " where grantee_id = ";
   selectStmt += UIDToString(objectUsage.granteeID);
 
+  // for role owners, get list of users granted role
+  selectStmt += " ) or o.object_owner in (select grantee_id from ";
+  selectStmt += roleUsageMDTable;
+  selectStmt += " where role_id = ";
+  selectStmt += UIDToString(objectUsage.granteeID);
+
   selectStmt += ")) order by o.create_time ";
 
   ExeCliInterface cliInterface(STMTHEAP, NULL, NULL, 
@@ -732,7 +862,7 @@ int32_t diagsMark = pDiags_->mark();
 
     // column 5: is insertable
     pCliRow->get(5,ptr,len);
-    viewUsage.isInsertable = (ptr == 0) ? false : true;
+    viewUsage.isInsertable = (*ptr == 0) ? false : true;
 
     // column 6: is updatable
     pCliRow->get(6,ptr,len);
diff --git a/core/sql/sqlcomp/PrivMgrMD.h b/core/sql/sqlcomp/PrivMgrMD.h
index c52a6351c8..4180db173b 100644
--- a/core/sql/sqlcomp/PrivMgrMD.h
+++ b/core/sql/sqlcomp/PrivMgrMD.h
@@ -31,6 +31,7 @@
 #include "PrivMgrDesc.h"
 #include "PrivMgrMDTable.h"
 #include "ComSmallDefs.h"
+#include "ComViewColUsage.h"
 #include "CmpSeabaseDDLauth.h"
 
 // following includes needed for cli interface
@@ -73,6 +74,15 @@ struct ColumnReference {
     originalPrivs(),
     updatedPrivs(){};
 
+  ColumnReference & operator=(const ColumnReference& other)
+  {
+    columnOrdinal = other.columnOrdinal;
+    originalPrivs = other.originalPrivs;
+    updatedPrivs = other.updatedPrivs;
+
+    return *this;
+  }
+
   void describe (std::string &details) const
   {
     details = "column usage - column number is ";
@@ -87,6 +97,7 @@ typedef struct {
   std::string viewName;
   bool isUpdatable;
   bool isInsertable;
+  std::string viewColUsagesStr;
   PrivMgrDesc originalPrivs;
   PrivMgrDesc updatedPrivs;
 
@@ -99,6 +110,8 @@ typedef struct {
     details += viewName;
     details += ", viewOwner is ";
     details += to_string((long long int) viewOwner);
+    details += ", viewColUsagesStr is ";
+    details += viewColUsagesStr;
     details += (isUpdatable) ? ", isUpdatable is Y " : "isUpdateable is N"; 
     details += (isInsertable) ? ", isInsertable is Y " : "isInsertable is N"; 
   }
@@ -138,6 +151,17 @@ class ObjectReference
   std::vector<ColumnReference *> *columnReferences;
   PrivMgrDesc updatedPrivs;
 
+  ColumnReference * find (int32_t columnOrdinal)
+  {
+    for (size_t i = 0; i < columnReferences->size(); i++)
+    {
+      ColumnReference *pColRef = (*columnReferences)[i];
+      if (pColRef->columnOrdinal == columnOrdinal)
+        return pColRef;
+    }
+    return NULL;
+  }
+
   void describe (std::string &details) const
   {
     details = "object reference - type is ";
@@ -176,6 +200,7 @@ class ObjectUsage
         delete columnReferences->back(), columnReferences->pop_back();
       delete columnReferences;
     }
+    columnReferences = NULL;
   }
 
   int64_t objectUID;
@@ -187,6 +212,26 @@ class ObjectUsage
   PrivMgrDesc originalPrivs;
   PrivMgrDesc updatedPrivs;
 
+  void copyColumnReferences(const std::vector<ColumnReference *> *refsToCopy)
+  {
+    if (columnReferences != NULL)
+      delete columnReferences;
+
+    if (refsToCopy == NULL)
+      columnReferences = NULL;
+    else
+    {
+      columnReferences = new std::vector<ColumnReference *>;
+      for (int i = 0; i < refsToCopy->size(); i++)
+      {
+        ColumnReference *newRef = new ColumnReference;
+        ColumnReference *copyRef = (*refsToCopy)[i];
+        newRef->operator=(*copyRef);
+        columnReferences->push_back(newRef);
+      }
+    }
+  }
+
   ColumnReference * findColumn (int32_t columnOrdinal)
   {
     if (columnReferences == NULL)
@@ -260,6 +305,8 @@ class PrivMgrMDAdmin : public PrivMgr
     inline void setMetadataLocation (const std::string metadataLocation)
       {metadataLocation_ = metadataLocation;};
 
+    PrivStatus getColumnReferences (ObjectReference *objectRef);
+
     bool getConstraintName(
       const int64_t referencedTableUID,
       const int64_t referencingTableUID, 
@@ -278,6 +325,8 @@ class PrivMgrMDAdmin : public PrivMgr
       const ObjectUsage &objectUsage,
       std::vector<ObjectReference *> &objectReferences );
 
+    PrivStatus getViewColUsages (ViewUsage &viewUsage);
+
     PrivStatus getViewsThatReferenceObject(
       const ObjectUsage &objectUsage, 
       std::vector<ViewUsage> &viewUsages);
diff --git a/core/sql/sqlcomp/PrivMgrPrivileges.cpp b/core/sql/sqlcomp/PrivMgrPrivileges.cpp
index 335f736f5d..a1af7cbad1 100644
--- a/core/sql/sqlcomp/PrivMgrPrivileges.cpp
+++ b/core/sql/sqlcomp/PrivMgrPrivileges.cpp
@@ -36,6 +36,7 @@
 #include <cstdio>
 #include <algorithm>
 #include <iterator>
+#include <vector>
 #include "sqlcli.h"
 #include "ComSmallDefs.h"
 #include "ExExeUtilCli.h"
@@ -618,6 +619,7 @@ PrivStatus PrivMgrPrivileges::getColPrivsForUser(
 //                                                                         
 //  <granteeID> is the authID granted the privileges.                              
 //  <columnOrdinal> is the column number to gather privileges
+//  <columnRowList> is the list of column privs for the object
 //  <roleIDs> is the list of roles assigned the granteeID
 //  <rowList> the privileges granted to <granteeID> on <columnOrdinal>.  
 //                                                                          
@@ -625,24 +627,28 @@ PrivStatus PrivMgrPrivileges::getColPrivsForUser(
 void PrivMgrPrivileges::getColRowsForGranteeOrdinal(
   const int32_t granteeID,
   const int32_t columnOrdinal,
+  const std::vector <PrivMgrMDRow *> &columnRowList,
   const std::vector<int32_t> &roleIDs,
   std::vector<PrivMgrMDRow *> &rowList)
 {
-  for (size_t i = 0; i < columnRowList_.size(); ++i)
+  for (size_t i = 0; i < columnRowList.size(); ++i)
   {
-    ColumnPrivsMDRow &row = static_cast<ColumnPrivsMDRow &> (*columnRowList_[i]);
+    ColumnPrivsMDRow &row = static_cast<ColumnPrivsMDRow &> (*columnRowList[i]);
     ColPrivEntry colPrivGrant;
 
-    if (row.granteeID_ == granteeID && row.columnOrdinal_ == columnOrdinal)
+    if (row.columnOrdinal_ == columnOrdinal)
     {
-       ColumnPrivsMDRow *pRow = new ColumnPrivsMDRow();
-       *pRow = row;
-       rowList.push_back(pRow);
+      if (row.granteeID_ == granteeID || 
+          std::find(roleIDs.begin(), roleIDs.end(), row.granteeID_) != roleIDs.end()) 
+      {
+         ColumnPrivsMDRow *pRow = new ColumnPrivsMDRow();
+         *pRow = row;
+         rowList.push_back(pRow);
+      }
     }
   }
 }
 
-
 // *****************************************************************************
 // * Method: getPrivRowsForObject                                
 // *                                                       
@@ -1050,18 +1056,12 @@ PrivStatus PrivMgrPrivileges::grantColumnPrivileges(
   
   log (__FILE__, "Checking column privileges", -1);
 
-  // generate the list of column privileges granted to the object and store in 
-  // class (columnRowList_)
-  if (generateColumnRowList() == STATUS_ERROR)
-   return STATUS_ERROR;
-
   // get roleIDs for the grantor
   std::vector<int_32> roleIDs;
   privStatus = getRoleIDsForUserID(grantorID_,roleIDs);
   if (privStatus == STATUS_ERROR)
     return privStatus;
 
-
   // Grantor may have WGO from two sources, object-level grants on the object,
   // and column-level grants.  hasColumnWGO checks both
   if (!hasColumnWGO(colPrivsArrayIn,roleIDs,privStatus))
@@ -1076,6 +1076,14 @@ PrivStatus PrivMgrPrivileges::grantColumnPrivileges(
   // Grantor has authority to grant all privileges requested.  See if some of
   // the grants are already present. (may be adding WGO)
    
+  // Note, object level grants goes ahead and grants privileges on those object
+  // that the grantor has WGO.  Column level grants return an error if the
+  // grantor does not have WGO on all columns - this is different behavior and
+  // should confer with ANSI SQL standard for which is correct.
+
+  // Object level grants check for a circular dependency.  Should column level
+  // grants to the same? Or should the check be removed from object grants.
+
   // Get existing column grants from grantor to the specified grantee.
   std::vector<ColPrivEntry> grantedColPrivs;
   getColRowsForGranteeGrantor(columnRowList_,
@@ -1119,6 +1127,22 @@ PrivStatus PrivMgrPrivileges::grantColumnPrivileges(
     }
   }
 
+  // Verify that view-col <=> referenced_col relationship exists
+  if (objectType == COM_VIEW_OBJECT)
+  {
+    ViewUsage myUsage;
+    myUsage.viewUID = objectUID_;
+    PrivMgrMDAdmin admin(trafMetadataLocation_, metadataLocation_, pDiags_);
+    if (admin.getViewColUsages(myUsage) == STATUS_ERROR)
+      return STATUS_ERROR;
+    if (myUsage.viewColUsagesStr.empty())
+    {
+      *pDiags_ << DgSqlCode (-CAT_COLUMN_PRIVILEGE_NOT_ALLOWED)
+               << DgTableName (objectName_.c_str());
+       return STATUS_ERROR;
+    }
+  }
+
   // Walk the list of column privileges to grant, and either insert a new
   // row in the COLUMN_PRIVILEGES table or update an existing row.  
 
@@ -1135,6 +1159,12 @@ PrivStatus PrivMgrPrivileges::grantColumnPrivileges(
     
   ColumnPrivsMDTable columnPrivsTable(columnTableName_,pDiags_);
 
+  // Get privileges on the object - needed for checks later
+  ObjectPrivsMDRow objRow;
+  privStatus = getGrantedPrivs(granteeID, objRow);
+ if (privStatus == STATUS_ERROR)
+    return privStatus;
+
   for (size_t i = 0; i < colPrivsToGrant.size(); i++)
   {
     ColPrivEntry &colPrivToGrant = colPrivsToGrant[i];
@@ -1193,23 +1223,44 @@ PrivStatus PrivMgrPrivileges::grantColumnPrivileges(
     if (skipOperation)
       continue;
       
-    // TBD:  need to get the list of referencing views that need to have this
-    // privilege progated.
-    //
-    // SQL ANSI general rules state 
-    // 
-    // - When granting INSERT, UPDATE, or DELETE object or column privilege to
-    //   a table that is referenced by one or more views, then the privilege  
-    //   should be propagated to any updatable views that reference the table. 
-    //   The grant request to the these views should be executed as though the 
-    //   current user is _SYSTEM.
-    //
-    // - If the table already has SELECT privilege and a new grant is 
-    //   performed that adds the WITH GRANT OPTION, then the WITH GRANT OPTION 
-    //   is to be propagated to referencing views.  The grant request should
-    //   be executed as though the current user is _SYSTEM.
+    // Create an ObjectUsage to propagate the privilege change to dependent
+    // objects
+    ObjectUsage objectUsage;
+    objectUsage.objectUID = objectUID_;
+    objectUsage.granteeID = granteeID;
+    objectUsage.objectName = objectName_;
+    objectUsage.objectType = objectType;
+
+    PrivMgrCoreDesc currentPrivs; // creates an empty descriptor
+    PrivMgrCoreDesc tempPrivs(objRow.privsBitmap_, objRow.grantableBitmap_);
+    objectUsage.originalPrivs.setTablePrivs(tempPrivs);
+    objectUsage.updatedPrivs.setTablePrivs(tempPrivs); 
+
+    // Create list of ColumnReferences
+    objectUsage.columnReferences = new std::vector<ColumnReference *>;
+    for (size_t i = 0; i < colPrivsToGrant.size(); i++)
+    {
+       ColPrivEntry &colPrivToGrant = colPrivsToGrant[i];
+       ColPrivEntry *grantedColPriv = findColumnEntry(grantedColPrivs, colPrivToGrant.getColumnOrdinal());
+
+       ColumnReference *adjustedCol = new ColumnReference;
+       adjustedCol->columnOrdinal = colPrivToGrant.getColumnOrdinal();
 
+       PrivMgrCoreDesc adjustedPrivs;
+       if (grantedColPriv)
+          adjustedPrivs = grantedColPriv->getPrivDesc();
+
+       adjustedCol->originalPrivs = adjustedPrivs;
+       adjustedPrivs.unionOfPrivs(colPrivToGrant.getPrivDesc());
+       adjustedCol->updatedPrivs = adjustedPrivs;
+       objectUsage.columnReferences->push_back(adjustedCol);
+    }
 
+    // Propagate the privilege change to dependent objects
+    if (updateDependentObjects(objectUsage, PrivCommand::GRANT_COLUMN) == STATUS_ERROR)
+      return STATUS_ERROR;
+
+    // Update the COLUMN_PRIVILEGES table with new privileges
     // Prepare for the insert or update request
     ColumnPrivsMDRow row;  
        
@@ -1449,20 +1500,23 @@ PrivStatus PrivMgrPrivileges::grantObjectPriv(
 
   // There is something to grant, update/insert metadata
 
-  // set up row if it does not exist
+  // set up row if it does not exist and add it to the objectRowList
   if (!foundRow)
   {
-    row.objectUID_ = objectUID_;
-    row.objectName_ = objectName_;
-    row.objectType_ = objectType;
-    row.granteeID_ = granteeID;
-    row.granteeName_ = granteeName;
-    row.granteeType_ = USER_GRANTEE_LIT;
-    row.grantorID_ = grantorID_;
-    row.grantorName_ = grantorName;
-    row.grantorType_ = USER_GRANTOR_LIT;
-    row.privsBitmap_ = privsToGrant.getTablePrivs().getPrivBitmap();
-    row.grantableBitmap_ = privsToGrant.getTablePrivs().getWgoBitmap();
+    ObjectPrivsMDRow *pRow = new ObjectPrivsMDRow();
+    pRow->objectUID_ = objectUID_;
+    pRow->objectName_ = objectName_;
+    pRow->objectType_ = objectType;
+    pRow->granteeID_ = granteeID;
+    pRow->granteeName_ = granteeName;
+    pRow->granteeType_ = USER_GRANTEE_LIT;
+    pRow->grantorID_ = grantorID_;
+    pRow->grantorName_ = grantorName;
+    pRow->grantorType_ = USER_GRANTOR_LIT;
+    pRow->privsBitmap_.reset();
+    pRow->grantableBitmap_.reset(); 
+    objectRowList_.push_back(pRow);
+    row = *pRow;
   }
 
   // combine privsToGrant with existing privs
@@ -1473,89 +1527,37 @@ PrivStatus PrivMgrPrivileges::grantObjectPriv(
     row.grantableBitmap_ = privsToGrant.getTablePrivs().getWgoBitmap();
   }
 
-  ObjectPrivsMDTable objectPrivsTable (objectTableName_, pDiags_);
-  ColumnPrivsMDTable columnPrivsTable(columnTableName_,pDiags_);
-  char buf[1000];
+  // Update dependent objects
+  ObjectUsage objectUsage;
+  objectUsage.objectUID = objectUID_;
+  objectUsage.granteeID = granteeID;
+  objectUsage.grantorIsSystem = false;
+  objectUsage.objectName = row.objectName_;
+  objectUsage.objectType = row.objectType_;
+  objectUsage.columnReferences = NULL;
 
-  if (foundRow)
-  {
-    ObjectUsage objectUsage;
-    objectUsage.objectUID = objectUID_;
-    objectUsage.granteeID = granteeID;
-    objectUsage.grantorIsSystem = false;
-    objectUsage.objectName = row.objectName_;
-    objectUsage.objectType = row.objectType_;
-    objectUsage.columnReferences = NULL;
-
-    PrivMgrDesc originalPrivs (row.granteeID_);
-    originalPrivs.setTablePrivs(savedOriginalPrivs);
-    objectUsage.originalPrivs = originalPrivs;
-    objectUsage.updatedPrivs = privsToGrant;
+  PrivMgrDesc originalPrivs (row.granteeID_);
+  originalPrivs.setTablePrivs(savedOriginalPrivs);
+  objectUsage.originalPrivs = originalPrivs;
+  objectUsage.updatedPrivs = privsToGrant;
   
-    // get list of all objects that need to change, the table object and 
-    // views
-    std::vector<ObjectUsage *> listOfObjects;
-    PrivCommand command = PrivCommand::GRANT_OBJECT;
-    retcode = getAffectedObjects(objectUsage, command, listOfObjects);
-    if (retcode == STATUS_ERROR)
-    {
-      deleteListOfAffectedObjects(listOfObjects);
-      return retcode;
-    }
+  if (updateDependentObjects(objectUsage, PrivCommand::GRANT_OBJECT) == STATUS_ERROR)
+    return STATUS_ERROR;
 
-    traceMsg = "updating all affected objects, number of objects is ";
-    traceMsg += to_string((long long int)listOfObjects.size());
+  ObjectPrivsMDTable objectPrivsTable (objectTableName_, pDiags_);
+  if (foundRow)
+  {
+    row.describeRow(traceMsg);
+    traceMsg.insert(0, "updating existing privilege row ");
     log (__FILE__, traceMsg, -1);
 
-    // update the OBJECT_PRIVILEGES row for each effected object
-    for (size_t i = 0; i < listOfObjects.size(); i++)
-    {
-      ObjectUsage *pObjectUsage = listOfObjects[i];
-
-      pObjectUsage->describe(traceMsg);
-      log (__FILE__, traceMsg, i);
-
-      // Determine the grantor:
-      // SQL ANSI general rules state 
-      // 
-      // - When granting INSERT, UPDATE, or DELETE object or column privilege to
-      //   a table that is referenced by one or more views, then the privilege  
-      //   should be propagated to any updatable views that reference the table. 
-      //   The grant request to the these views should be executed as though the 
-      //   current user is _SYSTEM.
-      //
-      // - If the table already has SELECT privilege and a new grant is 
-      //   performed that adds the WITH GRANT OPTION, then the WITH GRANT OPTION 
-      //   is to be propagated to referencing views.  The grant request should
-      //   be executed as though the current user is _SYSTEM.
-      //
-      //  The listOfObjects contains referencing views that meet the above 
-      //  criteria.
-      int32_t theGrantor = (pObjectUsage->grantorIsSystem) ? SYSTEM_USER : grantorID_;
-      int32_t theGrantee = pObjectUsage->granteeID;
-      int64_t theUID = pObjectUsage->objectUID;
-      PrivMgrCoreDesc thePrivs = pObjectUsage->updatedPrivs.getTablePrivs();
-  
-      sprintf(buf, "where grantee_id = %d and grantor_id =  %d and object_uid = %ld",
-              theGrantee, theGrantor, theUID);
-      std::string whereClause (buf);
-
-      sprintf(buf, "set privileges_bitmap  = %ld, grantable_bitmap =  %ld",
-              thePrivs.getPrivBitmap().to_ulong(),
-              thePrivs.getWgoBitmap().to_ulong());
-      std::string setClause (buf);
-      // update the row
-      retcode = objectPrivsTable.updateWhere(setClause, whereClause);
-      if (retcode == STATUS_ERROR)
-      {
-        deleteListOfAffectedObjects(listOfObjects);
-        return retcode;
-      }
-    }
-    deleteListOfAffectedObjects(listOfObjects);
+    // update the row
+    retcode = objectPrivsTable.updateRow(row);
   }
   else
   {
+    row.privsBitmap_ = privsToGrant.getTablePrivs().getPrivBitmap();
+    row.grantableBitmap_ = privsToGrant.getTablePrivs().getWgoBitmap();
     row.describeRow(traceMsg);
     traceMsg.insert(0, "adding new privilege row ");
     log (__FILE__, traceMsg, -1);
@@ -1851,8 +1853,9 @@ PrivStatus PrivMgrPrivileges::dealWithConstraints(
 
     // get the summarized original and current privs for the referencing table 
     // current privs contains any adjustments due to the privilege change
-    retcode = summarizeCurrentAndOriginalPrivs(pObjectRef->objectUID,
+    retcode = summarizeCurrentAndOriginalPrivs(objectUsage.objectUID,
                                                pObjectRef->objectOwner,
+                                               grantorID_,
                                                roleIDs,
                                                listOfAffectedObjects,
                                                originalPrivs,
@@ -1868,7 +1871,12 @@ PrivStatus PrivMgrPrivileges::dealWithConstraints(
       // no longer have REFERENCES privilege on the table, 
       // see if privileges are granted on all required columns
       std::vector<ColumnReference *> summarizedColRefs;
-      summarizeColPrivs(*pObjectRef, roleIDs, listOfAffectedObjects, summarizedColRefs);
+      summarizeColPrivs(*pObjectRef, 
+                        pObjectRef->objectOwner, 
+                        grantorID_,
+                        roleIDs, 
+                        listOfAffectedObjects, 
+                        summarizedColRefs); 
 
       // check summarized privileges to see if still have priv through other privs
       std::vector<ColumnReference *> neededColRefs = *pObjectRef->columnReferences;
@@ -1983,6 +1991,7 @@ PrivStatus PrivMgrPrivileges::dealWithUdrs(
     // current privs contains any adjustments
     retcode = summarizeCurrentAndOriginalPrivs(objectUsage.objectUID,
                                                objectUsage.granteeID,
+                                               grantorID_,
                                                roleIDs,
                                                listOfAffectedObjects,
                                                originalPrivs,
@@ -2030,6 +2039,7 @@ PrivStatus PrivMgrPrivileges::dealWithUdrs(
 PrivStatus PrivMgrPrivileges::dealWithViews(
   const ObjectUsage &objectUsage,
   const PrivCommand command,
+  const int32_t grantorID,
   std::vector<ObjectUsage *> &listOfAffectedObjects)
 {
   PrivStatus retcode = STATUS_GOOD;
@@ -2053,40 +2063,38 @@ PrivStatus PrivMgrPrivileges::dealWithViews(
   if (retcode != STATUS_GOOD && retcode != STATUS_WARNING)
     return retcode;
 
-  // for each entry in the viewUsages list calculate the changed
-  // privileges and call dealWithViews recursively
+  // for each entry in the viewUsages list calculate the changed privileges
+  // if privileges change, add viewUsage to listOfAffectedObjects 
   for (size_t i = 0; i < viewUsages.size(); i++)
   {
-   
     ViewUsage viewUsage = viewUsages[i];
 
     viewUsage.describe(traceMsg);
     log (__FILE__, traceMsg, i);
 
-    // this method recreates privileges for the view based on the original
-    // and the current.  Updated descriptors are stored in the viewUsage
-    // structure.
-    retcode = gatherViewPrivileges(viewUsage, listOfAffectedObjects);
+    // gatherViewPrivileges recreates privileges for the view based on changes
+    // requested by the current grant/revoke request
+    // Updated priv descriptors are stored in the viewUsage structure.
+    retcode = gatherViewPrivileges(viewUsage, command, grantorID, listOfAffectedObjects);
     traceMsg = "gathered view privs: retcode is ";
     traceMsg += privStatusEnumToLit(retcode);
     log (__FILE__, traceMsg, -1);
 
     if (retcode != STATUS_GOOD && retcode != STATUS_WARNING)
-    {
       return retcode;
-    }
 
     // check to see if privileges changed
     if (viewUsage.originalPrivs == viewUsage.updatedPrivs)
-    {}
+      continue;
     else
     {
-      // this view is affected by the grant/revoke request, add to list
-      // and check to see if anything down stream needs to change
-      // We already have select privilege on the view.  So only adjust
-      // view for other privileges if it is updatable and insertable
-      if (viewUsage.isUpdatable && viewUsage.isInsertable)
+      // This view privs have been changed by the grant/revoke request
+      // However, only INSERT, DELETE, and UPDATE privs can be propagated
+      // If the view is not updatable or insertable then, we are done with
+      // this viewUsage
+      if (viewUsage.isUpdatable || viewUsage.isInsertable)
       {
+        // Add viewUsage to list of affected objects
         ObjectUsage *pUsage = new (ObjectUsage);
         pUsage->objectUID = viewUsage.viewUID;
         pUsage->granteeID = viewUsage.viewOwner;
@@ -2101,16 +2109,114 @@ PrivStatus PrivMgrPrivileges::dealWithViews(
         pUsage->describe(traceMsg);
         log (__FILE__, traceMsg, i);
 
-        retcode = dealWithViews(*pUsage, command, listOfAffectedObjects);
-        if (retcode != STATUS_GOOD && retcode != STATUS_WARNING)
-          return retcode;
-      }
-    }
-  } 
+#if 0
+        // When cascade is supported, the list of down stream views must be 
+        // included in the list of affected objects.
+        // Also, need to understand ANSI SQL rules for propagating view privs,
+        // that is, should down stream views be updated if it parent view
+        // privs are changed  and the parent has WGO specified.
+
+        // get list of grantee ID's that have been granted privileges on the
+        // current view.  
+        std::set<int32_t> granteeList;
+        if (getGranteesForViewUsage(viewUsage, granteeList) == STATUS_ERROR)
+        {
+          PRIVMGR_INTERNAL_ERROR("Error while getting grantees for down stream views");
+          return STATUS_ERROR;
+        }
+
+        // Call dealWithViews to see if the down stream views should be adjusted.
+        for (std::set<int32_t>::iterator it = granteeList.begin(); it!= granteeList.end(); ++it)
+        {
+          pUsage->granteeID = *it;
+          retcode = dealWithViews(*pUsage, command, viewUsage.viewOwner, listOfAffectedObjects);
+          if (retcode != STATUS_GOOD && retcode != STATUS_WARNING)
+            return retcode;
+        }
+        pUsage->granteeID = viewUsage.viewOwner;
+#endif
+      } // updatable views 
+    } // view privs changed
+  } // list of view usages
   
   return STATUS_GOOD;
 }
 
+// ----------------------------------------------------------------------------
+// method: gatherViewColUsages
+//
+// This method gathers the view-col <=> referenced-col usages and creates a
+// list of ComViewColUsage's for the referenced object. Each ComViewColUsage 
+// is identified the view column number, and the related UID and column number 
+// of the referenced object.
+//
+// parameters:
+//   objectRef - description of the referenced object 
+//   viewUsage - description of the view
+//   viewColUsages - list of view column, referenced column usages
+//
+// Returns: PrivStatus                                               
+//                                                                    
+// STATUS_GOOD: Operation successful
+//           *: Unable to gather usages, see diags.     
+//                                                                 
+// ----------------------------------------------------------------------------
+PrivStatus PrivMgrPrivileges::gatherViewColUsages(
+  ObjectReference *objectRef,
+  ViewUsage &viewUsage,
+  std::vector<ComViewColUsage> &viewColUsages)
+{
+  std::string traceMsg;
+  PrivStatus retcode;
+
+  PrivMgrMDAdmin admin(trafMetadataLocation_, metadataLocation_, pDiags_);
+
+  // Get columns for referenced object if they are  not already present
+  if (objectRef->columnReferences == NULL)
+  {
+    retcode = admin.getColumnReferences(objectRef);
+    if (objectRef->columnReferences)
+    {
+      traceMsg += "getting column references: number references found ";
+      traceMsg += to_string((long long int)objectRef->columnReferences->size());
+      traceMsg += ", ";
+    }
+    traceMsg += "retcode is ";
+    traceMsg += privStatusEnumToLit(retcode);
+    log (__FILE__, traceMsg, -1);
+    if (retcode == STATUS_ERROR)
+      return retcode;
+  }
+
+  // Extract view <=> object column relationship from the TEXT table 
+  // and add it to the viewUsage
+  if (viewUsage.viewColUsagesStr.empty())
+  {
+    retcode = admin.getViewColUsages(viewUsage);
+    traceMsg = "getting view column usages";
+    traceMsg += ", retcode is ";
+    traceMsg += privStatusEnumToLit(retcode);
+    log (__FILE__, traceMsg, -1);
+    if (retcode != STATUS_GOOD)
+      return retcode;
+  }
+
+  // Setup the view column to referenced column relationship
+  char * beginStr  = (char *)viewUsage.viewColUsagesStr.c_str();
+  char * endStr = strchr(beginStr, ';');
+  while (endStr != NULL)
+  {
+    ComViewColUsage colUsage;
+    std::string currentUsage(beginStr, endStr - beginStr + 1);
+    colUsage.unpackUsage (currentUsage.c_str());
+    viewColUsages.push_back(colUsage);
+    beginStr = endStr+1;
+    endStr = strchr(beginStr, ';');
+  }
+ 
+  return STATUS_GOOD;
+}
+
 // ----------------------------------------------------------------------------
 // method: gatherViewPrivileges
 //
@@ -2128,6 +2234,8 @@ PrivStatus PrivMgrPrivileges::dealWithViews(
 // ----------------------------------------------------------------------------
 PrivStatus PrivMgrPrivileges::gatherViewPrivileges(
   ViewUsage &viewUsage,
+  const PrivCommand command,
+  const int32_t grantorID,
   const std::vector<ObjectUsage *> listOfAffectedObjects)
 {
   PrivStatus retcode = STATUS_GOOD;
@@ -2154,34 +2262,31 @@ PrivStatus PrivMgrPrivileges::gatherViewPrivileges(
   if (retcode == STATUS_ERROR)
     return retcode;
 
-
   // For each referenced object, summarize the original and current
   // privileges
   PrivMgrDesc originalPrivs;
   PrivMgrDesc currentPrivs;
   int32_t lastObjectOwnerID = 0;
+
   std::vector<int32_t> roleIDs;
+  retcode = getRoleIDsForUserID(viewUsage.viewOwner,roleIDs);
+  if (retcode == STATUS_ERROR)
+    return retcode;
  
+  // First gather privileges on the object
   for (size_t i = 0; i < objectList.size(); i++)
   {
     ObjectReference *pObjectRef = objectList[i];
-
     pObjectRef->describe(traceMsg);
     log (__FILE__, traceMsg, i);
 
-    if (lastObjectOwnerID != pObjectRef->objectOwner)
-    {
-      roleIDs.clear();
-      retcode = getRoleIDsForUserID(pObjectRef->objectOwner,roleIDs);
-      if (retcode == STATUS_ERROR)
-        return retcode;
-    }
     // get the summarized original and current privs for the 
     // referenced object that have been granted to the view owner
     // listOfAffectedObjects contain the privilege adjustments needed
     //   to generate the current privs
     retcode = summarizeCurrentAndOriginalPrivs(pObjectRef->objectUID,
                                                viewUsage.viewOwner, 
+                                               grantorID,
                                                roleIDs,
                                                listOfAffectedObjects,
                                                originalPrivs,
@@ -2189,29 +2294,176 @@ PrivStatus PrivMgrPrivileges::gatherViewPrivileges(
     if (retcode != STATUS_GOOD)
       return retcode;
 
-    // If user no longer has select privilege on referenced object
-    // returns an error
-    // When cascade is supported, then referenced objects will be removed
-    //if (command == PrivCommand::REVOKE_OBJECT_RESTRICT )
-    //{
-      PrivMgrCoreDesc thePrivs = currentPrivs.getTablePrivs();
-      if (!thePrivs.getPriv(SELECT_PRIV))
+    // If the referenced object is a sequence generator, then the grantee
+    // must still have the USAGE_PRIV.  The USAGE_PRIV is not a column
+    // level privilege so no column level check is necessary.
+    if (isRevokeCommand(command))
+    {
+      if (pObjectRef->objectType == COM_SEQUENCE_GENERATOR_OBJECT)
       {
-         *pDiags_ << DgSqlCode (-CAT_DEPENDENT_OBJECTS_EXIST)
-                  << DgString0 (viewUsage.viewName.c_str());
-         return STATUS_ERROR;
+        PrivMgrCoreDesc thePrivs = currentPrivs.getTablePrivs();
+        if (!thePrivs.getPriv(USAGE_PRIV))
+        {
+           *pDiags_ << DgSqlCode (-CAT_DEPENDENT_OBJECTS_EXIST)
+                    << DgString0 (viewUsage.viewName.c_str());
+           return STATUS_ERROR;
+        }
       }
-    //}
+    }
 
-    // add the returned privilege to the summarized privileges
+    // "and" the returned privilege to the summarized privileges
     // for all objects
     summarizedOriginalPrivs.intersectionOfPrivs(originalPrivs);
     summarizedCurrentPrivs.intersectionOfPrivs(currentPrivs);
 
+    // reset to prepare for next object
     originalPrivs.resetTablePrivs();
     currentPrivs.resetTablePrivs();
   }
 
+  // If view has all grantable col privs already, no need to check further
+  bool checkCols = false;
+  PrivMgrCoreDesc thePrivs = summarizedCurrentPrivs.getTablePrivs();
+  for (size_t i = FIRST_DML_COL_PRIV; i <= LAST_DML_COL_PRIV; i++ )
+  {
+    PrivType privType = PrivType(i);
+    if (thePrivs.getPriv(privType) && thePrivs.getWgo(privType))
+      continue;
+    checkCols = true;
+    break;
+  }
+
+  // No need to check col privs, return with summarized privs
+  if (!checkCols)
+  {
+    // Update view usage with summarized privileges
+    viewUsage.originalPrivs = summarizedOriginalPrivs;
+    viewUsage.updatedPrivs = summarizedCurrentPrivs;
+    return STATUS_GOOD;
+  }
+
+  // Turn on bits to prepare for intersecting with object privileges
+  originalPrivs.setAllTableGrantPrivileges(setWGOtrue);
+  currentPrivs.setAllTableGrantPrivileges(setWGOtrue);
+
+  std::vector<ColumnReference *> summarizedColRefs;
+
+  // Gather column privileges on all objects referencing the view.
+  //   for grants, a view might gain privs 
+  //   for revokes, a view might lose privs
+  // For example:
+  //   as user1:
+  //     create table sch1.t1 (c1 int, c2 int, ....);
+  //     grant select on sch1.t1 to user2;
+  //     grant insert (c1) on sch1.t1 to user2
+  //   as user2:
+  //     create view sch2.v1 as select c1 from sch1.t1;
+  //   view sch2.v1 gains the insert privilege since all columns that 
+  //     sch2.v1 references have granted user2 the insert privilege.
+  for (size_t i = 0; i < objectList.size(); i++)
+  {
+    ObjectReference *pObjectRef = objectList[i];
+
+    // gather the view-col <=> referenced-col usages
+    std::vector <ComViewColUsage> viewColUsages;
+    retcode = gatherViewColUsages(pObjectRef, viewUsage, viewColUsages);
+    if (retcode == STATUS_ERROR)
+      return retcode;
+
+    // The view-col <=> referenced_col relationship is not found
+    // No need to proceed further.
+    // If this is a grant of a column privilege, return an error
+    // User needs to drop and recreate view
+    // The view-col <=> referenced-col usages are only being started in 
+    // metadata after column privileges are officially supported.  Any views
+    // create before this time, do not have this information, so column privs
+    // either do not exist (revoke) or cannot be added (grant).  The view needs
+    // to be dropped and recreated (or add a fixup procedure).
+    if (retcode == STATUS_NOTFOUND)
+    {
+      if (command == GRANT_COLUMN) 
+      {
+         *pDiags_ << DgSqlCode (-CAT_COLUMN_PRIVILEGE_NOT_ALLOWED)
+                  << DgTableName (viewUsage.viewName.c_str());
+         return STATUS_ERROR;
+       }
+       return STATUS_GOOD;
+    }
+
+    
+    // gather the updated summarized column privileges on the referenced object
+    summarizeColPrivs(*pObjectRef, 
+                      viewUsage.viewOwner, 
+                      grantorID,
+                      roleIDs, 
+                      listOfAffectedObjects, 
+                      summarizedColRefs); 
+
+    // For each view column, get the corresponding referenced column priv
+    for (size_t j = 0; j < viewColUsages.size(); j++)
+    {
+      ComViewColUsage colUsage = viewColUsages[j];
+
+      // See if the referenced object contains the associated view column
+      if (colUsage.getRefdUID() != pObjectRef->objectUID) 
+        continue;
+
+      // Get the referenced column, if NULL then something is wrong
+      ColumnReference *neededColRef = pObjectRef->find(colUsage.getRefdColNumber());
+      if (neededColRef == NULL)
+      {
+         PRIVMGR_INTERNAL_ERROR("View column to referenced column relationship wrong");
+         return STATUS_ERROR;
+      }
+
+      // Find and update the current bitmaps for column
+      for (size_t k = 0; k < summarizedColRefs.size(); k++)
+      {
+        ColumnReference *existingRef = summarizedColRefs[k];
+        if (existingRef->columnOrdinal == neededColRef->columnOrdinal)
+        {
+          originalPrivs.intersectionOfPrivs(existingRef->originalPrivs);
+          currentPrivs.intersectionOfPrivs(existingRef->updatedPrivs);
+          break;
+        }
+      }
+    }
+  }
+
+  // Union or "or" the returned privileges to the summarized privileges
+  // for all columns. The privilege is set in currentPrivs only if all
+  // columns in the view have the privilege.
+  summarizedOriginalPrivs.unionOfPrivs(originalPrivs);
+  summarizedCurrentPrivs.unionOfPrivs(currentPrivs);
+
+  // If user no longer has select privilege on referenced object
+  // returns an error
+  // When cascade is supported, then referenced objects will be removed
+  if (isRevokeCommand(command))
+  {
+    if (!summarizedCurrentPrivs.getTablePrivs().getPriv(SELECT_PRIV))
+    {
+      *pDiags_ << DgSqlCode (-CAT_DEPENDENT_OBJECTS_EXIST)
+               << DgString0 (viewUsage.viewName.c_str());
+      return STATUS_ERROR;
+    }
+  }
+
+  // If view is not updatable or insertable, turn off privs in bitmaps
+  if (!viewUsage.isUpdatable)
+    {
+      summarizedCurrentPrivs.getTablePrivs().setPriv(UPDATE_PRIV,false);
+      summarizedCurrentPrivs.getTablePrivs().setPriv(UPDATE_PRIV, false);
+      summarizedCurrentPrivs.getTablePrivs().setPriv(DELETE_PRIV,false);
+      summarizedCurrentPrivs.getTablePrivs().setPriv(DELETE_PRIV, false);
+    }
+
+  if (!viewUsage.isInsertable)
+    {
+      summarizedCurrentPrivs.getTablePrivs().setPriv(INSERT_PRIV,false);
+      summarizedCurrentPrivs.getTablePrivs().setPriv(INSERT_PRIV, false);
+    }
+
   // Update view usage with summarized privileges
   viewUsage.originalPrivs = summarizedOriginalPrivs;
   viewUsage.updatedPrivs = summarizedCurrentPrivs;
@@ -2225,29 +2477,54 @@ PrivStatus PrivMgrPrivileges::gatherViewPrivileges(
 // generate the list of privileges granted to columns of the object and 
 // store in columnRowList_ class member
 //
-// The list is ordered by grantor/grantee/column_number
-//
 // Returns:
 //   STATUS_GOOD     - list of rows was generated
 //   STATUS_NOTFOUND - no column privileges were found
 //   STATUS_ERROR    - the diags area is populated with any errors
 // ****************************************************************************
 PrivStatus PrivMgrPrivileges::generateColumnRowList()
+{
+  PrivStatus privStatus = getColumnRowList(objectUID_, columnRowList_);
+  if (privStatus == STATUS_ERROR)
+    return privStatus;
+  return STATUS_GOOD;
+}
+ 
+// ****************************************************************************
+// method: getColumnRowList
+//
+// generate the list of privileges granted to the passed in objectUID and 
+// returns in the columnRowList parameter
+//
+// The list is ordered by grantor/grantee/column_number
+//
+// Returns:
+//   STATUS_GOOD     - list of rows was generated
+//   STATUS_NOTFOUND - in most cases, there should be at least one row in the
+//                     OBJECT_PRIVILEGES table.  But there is at least one case
+//                     where this is not true - trying to get privilege info
+//                     for indexes when using the table (index_table) syntax.
+//   STATUS_ERROR    - the diags area is populated with any errors
+// ****************************************************************************
+
+PrivStatus PrivMgrPrivileges::getColumnRowList(
+   const int64_t objectUID,
+   std::vector<PrivMgrMDRow *> &columnRowList)
 {
   std::string whereClause ("where object_uid = ");
-  whereClause += UIDToString(objectUID_);
+  whereClause += UIDToString(objectUID);
   std::string orderByClause (" order by grantor_id, grantee_id, column_number ");
 
   ColumnPrivsMDTable columnPrivsTable(columnTableName_,pDiags_);
   PrivStatus privStatus = 
-   columnPrivsTable.selectWhere(whereClause, orderByClause, columnRowList_);
+   columnPrivsTable.selectWhere(whereClause, orderByClause, columnRowList);
 
   std::string traceMsg ("getting column privileges, number privileges is ");
-  traceMsg += to_string((long long int)columnRowList_.size());
+  traceMsg += to_string((long long int)columnRowList.size());
   log (__FILE__, traceMsg, -1);
-  for (size_t i = 0; i < columnRowList_.size(); i++)
+  for (size_t i = 0; i < columnRowList.size(); i++)
   {
-    ColumnPrivsMDRow privRow = static_cast<ColumnPrivsMDRow &> (*columnRowList_[i]);
+    ColumnPrivsMDRow privRow = static_cast<ColumnPrivsMDRow &> (*columnRowList[i]);
     privRow.describeRow(traceMsg);
     log (__FILE__, traceMsg, i);
   }
@@ -2261,8 +2538,6 @@ PrivStatus PrivMgrPrivileges::generateColumnRowList()
 // generate the list of privileges granted to the object and 
 // store in objectRowList_ class member
 //
-// The list is ordered by grantor/grantee
-//
 // Returns:
 //   STATUS_GOOD     - list of rows was generated
 //   STATUS_NOTFOUND - in most cases, there should be at least one row in the
@@ -2273,23 +2548,52 @@ PrivStatus PrivMgrPrivileges::generateColumnRowList()
 // ****************************************************************************
 PrivStatus PrivMgrPrivileges::generateObjectRowList()
 {
+  PrivStatus privStatus = getObjectRowList(objectUID_, objectRowList_);
+  if (privStatus == STATUS_ERROR)
+    return privStatus;
+  return STATUS_GOOD;
+}
+
+// ****************************************************************************
+// method: getObjectRowList
+//
+// generate the list of privileges granted to the passed in objectUID and 
+// returns in the objectRowList parameter
+//
+// The list is ordered by grantor/grantee
+//
+// Returns:
+//   STATUS_GOOD     - list of rows was generated
+//   STATUS_NOTFOUND - in most cases, there should be at least one row in the
+//                     OBJECT_PRIVILEGES table.  But there is at least one case
+//                     where this is not true - trying to get privilege info
+//                     for indexes when using the table (index_table) syntax.
+//   STATUS_ERROR    - the diags area is populated with any errors
+// ****************************************************************************
+PrivStatus PrivMgrPrivileges::getObjectRowList(
+   const int64_t objectUID, 
+   std::vector<PrivMgrMDRow *> &objectRowList)
+{ 
   std::string whereClause ("where object_uid = ");
-  whereClause += UIDToString(objectUID_);
+  whereClause += UIDToString(objectUID);
   std::string orderByClause(" order by grantor_id, grantee_id ");
 
   ObjectPrivsMDTable objectPrivsTable(objectTableName_,pDiags_);
   PrivStatus privStatus = 
-    objectPrivsTable.selectWhere(whereClause, orderByClause, objectRowList_);
+    objectPrivsTable.selectWhere(whereClause, orderByClause, objectRowList);
+  if (privStatus == STATUS_ERROR)
+    return privStatus;
+
   std::string traceMsg ("getting object privileges, number privleges is ");
-  traceMsg += to_string((long long int)objectRowList_.size());
+  traceMsg += to_string((long long int)objectRowList.size());
   log (__FILE__, traceMsg, -1);
-  for (size_t i = 0; i < objectRowList_.size(); i++)
+  for (size_t i = 0; i < objectRowList.size(); i++)
   {
-    ObjectPrivsMDRow privRow = static_cast<ObjectPrivsMDRow &> (*objectRowList_[i]);
+    ObjectPrivsMDRow privRow = static_cast<ObjectPrivsMDRow &> (*objectRowList[i]);
     privRow.describeRow(traceMsg);
     log (__FILE__, traceMsg, i);
   }
-  return privStatus;
+  return STATUS_GOOD;
 }
 
 
@@ -2322,13 +2626,13 @@ PrivStatus PrivMgrPrivileges::getAffectedObjects(
   pUsage->objectType = objectUsage.objectType;
   pUsage->originalPrivs = objectUsage.originalPrivs;
   pUsage->updatedPrivs = objectUsage.updatedPrivs;
-  pUsage->columnReferences = objectUsage.columnReferences;
+  pUsage->copyColumnReferences(objectUsage.columnReferences);
 
   listOfAffectedObjects.push_back(pUsage); 
 
 
   // Find list of affected constraints
-  if (command != PrivCommand::GRANT_OBJECT)  
+  if (isRevokeCommand(command))
   {
     // TBD optimization: if no "references" privilege has been revoked, skip
     retcode = dealWithConstraints (objectUsage, listOfAffectedObjects);
@@ -2343,7 +2647,7 @@ PrivStatus PrivMgrPrivileges::getAffectedObjects(
   }
 
   // Find list of affected views
-  retcode = dealWithViews (objectUsage, command, listOfAffectedObjects);
+  retcode = dealWithViews (objectUsage, command, grantorID_, listOfAffectedObjects);
   if (retcode != STATUS_GOOD && retcode != STATUS_WARNING)
     return retcode;
 
@@ -2383,6 +2687,66 @@ PrivStatus PrivMgrPrivileges::getGrantedPrivs(
   return STATUS_NOTFOUND;
 }
  
+// ----------------------------------------------------------------------------
+// method: getGranteesForViewUsage
+//
+// returns the list of grantees that have been granted privileges by the view
+// owner
+//
+// input:  viewUsage
+// output: a unique list of grantees
+//
+//  Returns: PrivStatus                                               
+//                                                                   
+//   STATUS_GOOD: list was generated
+//  STATUS_ERROR: unexpected error occurred
+// ----------------------------------------------------------------------------
+PrivStatus PrivMgrPrivileges::getGranteesForViewUsage (
+  const ViewUsage &viewUsage,
+  std::set<int32_t> &granteeList)
+{
+  PrivStatus privStatus = STATUS_GOOD;
+
+  std::string whereClause ("where object_uid = ");
+  whereClause += UIDToString(viewUsage.viewUID);
+  whereClause += " and grantor_id <> -2 ";
+  std::string orderByClause("order by grantee_id");
+  std::vector<PrivMgrMDRow *> rowList;
+  
+  // get list of grantees from object_privileges
+  ObjectPrivsMDTable objectPrivsTable(objectTableName_,pDiags_);
+  privStatus = objectPrivsTable.selectWhere(whereClause,orderByClause,rowList);
+  if (privStatus == STATUS_ERROR)
+  {
+    deleteRowList(rowList);
+    return privStatus;
+  }
+
+  for (size_t i = 0; i < rowList.size(); i++)
+  {
+    ObjectPrivsMDRow &currentRow = static_cast<ObjectPrivsMDRow &> (*rowList[i]);
+    granteeList.insert(currentRow.granteeID_);
+  }
+  deleteRowList(rowList);
+    
+  // get list of grantees for column_privileges
+  ColumnPrivsMDTable columnPrivsTable(columnTableName_,pDiags_);
+  privStatus = columnPrivsTable.selectWhere(whereClause, orderByClause, rowList);
+  if (privStatus == STATUS_ERROR)
+  {
+    deleteRowList(rowList);
+    return privStatus;
+  }
+
+  for (size_t i = 0; i < rowList.size(); i++)
+  {
+    ColumnPrivsMDRow &currentRow = static_cast<ColumnPrivsMDRow &> (*rowList[i]);
+    granteeList.insert(currentRow.granteeID_);
+  }
+  deleteRowList(rowList);
+  return STATUS_GOOD;
+}
+
 // ----------------------------------------------------------------------------
 // method: getGrantorDetailsForObject
 //
@@ -2614,11 +2978,18 @@ PrivStatus PrivMgrPrivileges::revokeColumnPrivileges(
          ColPrivEntry colPrivToRevoke;
          
          colPrivToRevoke.setColumnOrdinal(columnOrdinal);   
-         colPrivToRevoke.setPriv(privType,true);
-        
-         // if revoking a privilege and auth ID has WGO, then revoke 
-         // the WGO bit also
-         colPrivToRevoke.setGrantable(privType, metadataEntry->getGrantableBitmap().test(privType));
+         if (isWGOSpecified)
+         {
+           colPrivToRevoke.setPriv(privType,false);
+           colPrivToRevoke.setGrantable(privType, true);
+         }
+         else
+         {
+           colPrivToRevoke.setPriv(privType,true);
+           // if revoking a privilege and auth ID has WGO, then revoke 
+           // the WGO bit also
+           colPrivToRevoke.setGrantable(privType, metadataEntry->getGrantableBitmap().test(privType));
+         }
 
          colPrivsToRevoke.push_back(colPrivToRevoke);
       }
@@ -2661,16 +3032,8 @@ PrivStatus PrivMgrPrivileges::revokeColumnPrivileges(
      objectUsage.updatedPrivs.setTablePrivs(coreDesc); 
    }
    
-   std::vector<ObjectUsage *> listOfObjects;
-   privStatus = getAffectedObjects(objectUsage,
-                                PrivCommand::REVOKE_OBJECT_RESTRICT,
-                                listOfObjects);
-   if (privStatus == STATUS_ERROR)
-   {
-     deleteListOfAffectedObjects(listOfObjects);
-     return privStatus;
-   }
-
+   if ( updateDependentObjects(objectUsage, PrivCommand::REVOKE_COLUMN_RESTRICT) == STATUS_ERROR)
+     return STATUS_ERROR;
    
    // At this point we have an array of privsToRevoke with column ordinal and 
    // priv bitmap.
@@ -2720,7 +3083,8 @@ PrivStatus PrivMgrPrivileges::revokeColumnPrivileges(
          // Found row with grant for this column.
          
          // Verify privilege(s) being revoked was/were granted.  If not, internal error.
-         if ((colPrivToRevoke.getPrivBitmap() & grantedColPriv->getPrivBitmap()) == 0)
+         if (!isWGOSpecified && 
+             ((colPrivToRevoke.getPrivBitmap() & grantedColPriv->getPrivBitmap()) == 0))
          {
             PRIVMGR_INTERNAL_ERROR("Privilege to revoke not found");
             return STATUS_ERROR;
@@ -3005,94 +3369,40 @@ PrivStatus PrivMgrPrivileges::revokeObjectPriv (const ComObjectType objectType,
   objectUsage.grantorIsSystem = false;
   objectUsage.objectName = row.objectName_;
   objectUsage.objectType = row.objectType_;
+  objectUsage.columnReferences = NULL;
 
   PrivMgrDesc originalPrivs (row.granteeID_);
   originalPrivs.setTablePrivs(savedOriginalPrivs);
   objectUsage.originalPrivs = originalPrivs;
   objectUsage.updatedPrivs = privsToRevoke;
 
-  // get list of dependent objects that need to change 
-  std::vector<ObjectUsage *> listOfObjects;
-  retcode = getAffectedObjects(objectUsage, 
-                               PrivCommand::REVOKE_OBJECT_RESTRICT, 
-                               listOfObjects);
-  if (retcode == STATUS_ERROR)
-  {
-    deleteListOfAffectedObjects(listOfObjects);
-    return retcode;
-  }
+  if (updateDependentObjects(objectUsage, PrivCommand::REVOKE_OBJECT_RESTRICT) == STATUS_ERROR)
+    return STATUS_ERROR;
 
-  char buf[1000];
-  ObjectPrivsMDTable objectPrivsTable (objectTableName_, pDiags_);
-  ColumnPrivsMDTable columnPrivsTable(columnTableName_,pDiags_);
+  // Go rebuild the privilege tree to see if it is broken
+  // If it is broken, return an error
+  if (checkRevokeRestrict (row, objectRowList_))
+    return STATUS_ERROR;
 
-  // update the OBJECT_PRIVILEGES row for each effected object
-  for (size_t i = 0; i < listOfObjects.size(); i++)
+  ObjectPrivsMDTable objectPrivsTable (objectTableName_, pDiags_);
+  if (privsToRevoke.isNull())
   {
-    ObjectUsage *pObjectUsage = listOfObjects[i];
-    PrivMgrCoreDesc thePrivs = pObjectUsage->updatedPrivs.getTablePrivs();
-
-    // Determine the grantor:
-    // SQL ANSI general rules state 
-    // 
-    // - When revoking INSERT, UPDATE, or DELETE object or column privilege from
-    //   a table that is referenced by one or more views, then the privilege  
-    //   should be revoked on any updatable views that reference the table. 
-    //   The revoke request to the these views should be executed as though the 
-    //   current user is _SYSTEM.
-    //
-    // - If the revoke is performed that removes the WITH GRANT OPTION, then 
-    //   the WITH GRANT OPTION is to be removed frome referencing views.  The 
-    //   revoke request should be executed as though the current user is _SYSTEM.
-    //
-    //  The listOfObjects contains referencing views that meet the above 
-    //  criteria.
-    int32_t theGrantor = (pObjectUsage->grantorIsSystem) ? SYSTEM_USER : grantorID_;
-    int32_t theGrantee = pObjectUsage->granteeID;
-    int64_t theUID = pObjectUsage->objectUID;
-
-    sprintf(buf, "where grantee_id = %d and grantor_id =  %d and object_uid = %ld",
-            theGrantee, theGrantor, theUID);
-    std::string whereClause (buf);
-
-    if (thePrivs.isNull())
-    {
-      pObjectUsage->describe(traceMsg);
-      traceMsg.insert (0, "deleted object usage ");
+    row.describeRow(traceMsg);
+    traceMsg.insert(0, "deleting privilege row ");
+    log (__FILE__, traceMsg, -1);
 
-      // delete the row
-      retcode = objectPrivsTable.deleteWhere(whereClause);
-      if (retcode == STATUS_ERROR)
-      {
-        deleteListOfAffectedObjects(listOfObjects);
-        return retcode;
-      }
-    }
-    else
-    {
-      sprintf(buf, "set privileges_bitmap  = %ld, grantable_bitmap =  %ld",
-              thePrivs.getPrivBitmap().to_ulong(),
-              thePrivs.getWgoBitmap().to_ulong());
-      std::string setClause (buf);
+    // delete the row
+    retcode = objectPrivsTable.deleteRow(row);
+  }
+  else
+  {
+    row.describeRow(traceMsg);
+    traceMsg.insert(0, "updating existing privilege row ");
+    log (__FILE__, traceMsg, -1);
 
-      pObjectUsage->describe(traceMsg);
-      traceMsg.insert (0, "updated object usage ");
-      // update the row
-      retcode = objectPrivsTable.updateWhere(setClause, whereClause);
-      if (retcode == STATUS_ERROR)
-      {
-        deleteListOfAffectedObjects(listOfObjects);
-        return retcode;
-      }
-    }
+    // update the row
+    retcode = objectPrivsTable.updateRow(row);
   }
-  
-  deleteListOfAffectedObjects(listOfObjects);
-  
-  // Go rebuild the privilege tree to see if it is broken
-  // If it is broken, return an error
-  if (checkRevokeRestrict (row, objectRowList_))
-    return STATUS_ERROR;
 
   // Send a message to the Trafodion RMS process about the revoke operation.
   // RMS will contact all master executors and ask that cached privilege 
@@ -3140,6 +3450,8 @@ PrivStatus PrivMgrPrivileges::revokeObjectPriv ()
   // delete all the rows for this object
   ObjectPrivsMDTable objectPrivsTable (objectTableName_, pDiags_);
   retcode = objectPrivsTable.deleteWhere(whereClause);
+  ColumnPrivsMDTable columnPrivsTable (objectTableName_, pDiags_);
+  retcode = columnPrivsTable.deleteWhere(whereClause);
 
   return retcode;
 }
@@ -4132,14 +4444,23 @@ PrivStatus PrivMgrPrivileges::getRowsForGrantee(
   }
 #endif
 
-  // create the list of row pointers from the cached list
+  // create the list of row pointers 
   std::vector<int32_t> authIDs = roleIDs;
   authIDs.push_back(granteeID);
   authIDs.push_back(PUBLIC_USER);
   std::vector<int32_t>::iterator it;
   std::vector<PrivMgrMDRow *> privRowList;
   if (isObjectTable)
-    privRowList = objectRowList_;
+  {
+    if (objectUID == objectUID_)
+      privRowList = objectRowList_;
+    else
+    {
+      retcode = getObjectRowList(objectUID, privRowList);
+      if (retcode == STATUS_ERROR)
+        return retcode;
+    }
+  }
   else
     privRowList = columnRowList_;
 
@@ -4187,6 +4508,8 @@ PrivStatus PrivMgrPrivileges::getRowsForGrantee(
 // ****************************************************************************
 void PrivMgrPrivileges::summarizeColPrivs(
   const ObjectReference &objReference,
+  const int32_t granteeID,
+  const int32_t grantorID,
   const std::vector<int32_t> &roleIDs,
   const std::vector<ObjectUsage *> &listOfAffectedObjects,
   std::vector<ColumnReference *> &summarizedColRefs)
@@ -4196,7 +4519,7 @@ void PrivMgrPrivileges::summarizeColPrivs(
   traceMsg.insert (0, "summarizing column privileges ");
   log (__FILE__, traceMsg, -1);
 
-  // objReference.columnReferences is the list of columns for RI constraints
+  // objReference.columnReferences is the list of columns 
   // referencing the referenced table
   std::vector<ColumnReference *> *colRefs = objReference.columnReferences;
   for (size_t i = 0; i < colRefs->size(); i++)
@@ -4208,8 +4531,9 @@ void PrivMgrPrivileges::summarizeColPrivs(
     // get COLUMN_PRIVILEGES rows where the grantee for the column has received 
     // privileges -  the row list is in memory so this does not require I/O
     std::vector<PrivMgrMDRow *> rowList;
-    getColRowsForGranteeOrdinal(objReference.objectOwner,
+    getColRowsForGranteeOrdinal(granteeID,
                                 colRef->columnOrdinal,
+                                columnRowList_,
                                 roleIDs,
                                 rowList);
     
@@ -4217,34 +4541,48 @@ void PrivMgrPrivileges::summarizeColPrivs(
     // We do a union operation to capture privileges from all grantors
     ColumnReference *summarized = new ColumnReference; 
     summarized->columnOrdinal = colRef->columnOrdinal;
-    for (int32_t i = 0; i < rowList.size();++i)
-    {
-      ColumnPrivsMDRow &row = static_cast<ColumnPrivsMDRow &> (*rowList[i]);
-      PrivMgrCoreDesc originalPrivs(row.privsBitmap_, row.grantableBitmap_);
 
-      ColumnReference ref;
-      ref.columnOrdinal = row.columnOrdinal_;
-      ref.originalPrivs = originalPrivs;
-      ref.updatedPrivs = originalPrivs;
-      
-      // Update if privileges have been changed by request
-      for (size_t j = 0; j < listOfAffectedObjects.size(); j++)
+    if (rowList.size() > 0)
+    {
+      for (int32_t j = 0; j < rowList.size();++j)
       {
-        ObjectUsage *currentObj = listOfAffectedObjects[j];
-        if (currentObj->objectUID == row.objectUID_ &&
-            grantorID_ == row.grantorID_ &&
-            objReference.objectOwner == row.granteeID_ )
+        ColumnPrivsMDRow &row = static_cast<ColumnPrivsMDRow &> (*rowList[j]);
+        PrivMgrCoreDesc originalPrivs(row.privsBitmap_, row.grantableBitmap_);
+        PrivMgrCoreDesc updated = originalPrivs;
+
+        // Update if privileges have been changed by request
+        for (size_t k = 0; k < listOfAffectedObjects.size(); k++)
         {
-          ColumnReference *changedRef = currentObj->findColumn(row.columnOrdinal_);
-          if (changedRef)
-            ref.updatedPrivs = changedRef->updatedPrivs;
+          ObjectUsage *currentObj = listOfAffectedObjects[k];
+          if (currentObj->objectUID == row.objectUID_ &&
+              grantorID == row.grantorID_ &&
+              currentObj->granteeID == row.granteeID_ )
+          {
+            ColumnReference *changedRef = currentObj->findColumn(row.columnOrdinal_);
+            if (changedRef)
+              updated = changedRef->updatedPrivs;
+          }
         }
+        summarized->originalPrivs.unionOfPrivs(originalPrivs);
+        summarized->updatedPrivs.unionOfPrivs(updated);
       }
-      
-      summarized->originalPrivs.unionOfPrivs(ref.originalPrivs);
-      summarized->updatedPrivs.unionOfPrivs(ref.updatedPrivs);
     }
-
+    else
+    {
+      // For grants, this may be the first column privs added, adjust to
+      // include new privs
+      PrivMgrCoreDesc updated;
+      for (size_t k = 0; k < listOfAffectedObjects.size(); k++)
+      {
+        ObjectUsage *currentObj = listOfAffectedObjects[k];
+        ColumnReference *changedRef = currentObj->findColumn(colRef->columnOrdinal);
+        if (changedRef)
+          updated = changedRef->updatedPrivs;
+      }
+      // There are no originalPrivs
+      summarized->updatedPrivs.unionOfPrivs(updated);
+    }
+      
     // Add column ref to the list
     summarizedColRefs.push_back(summarized);
   }
@@ -4272,6 +4610,7 @@ void PrivMgrPrivileges::summarizeColPrivs(
 PrivStatus PrivMgrPrivileges::summarizeCurrentAndOriginalPrivs(
    const int64_t objectUID,
    const int32_t granteeID,
+   const int32_t grantorID,
    const std::vector<int32_t> & roleIDs,
    const std::vector<ObjectUsage *> listOfChangedPrivs,
    PrivMgrDesc &summarizedOriginalPrivs,
@@ -4291,25 +4630,131 @@ PrivStatus PrivMgrPrivileges::summarizeCurrentAndOriginalPrivs(
   {
     ObjectPrivsMDRow &row = static_cast<ObjectPrivsMDRow &> (*rowList[i]);
     PrivMgrCoreDesc original(row.privsBitmap_, row.grantableBitmap_);
-    PrivMgrCoreDesc current = original;
+    PrivMgrCoreDesc updated = original;
     for (size_t j = 0; j < listOfChangedPrivs.size(); j++)
     {
       ObjectUsage *pObjectUsage = listOfChangedPrivs[j];
       if (pObjectUsage->objectUID == row.objectUID_ &&
-          grantorID_ == row.grantorID_ &&
-          pObjectUsage->granteeID == row.granteeID_ )
+        grantorID == row.grantorID_ &&
+        pObjectUsage->granteeID == row.granteeID_ )
       {
-        current = pObjectUsage->updatedPrivs.getTablePrivs();
+        updated = pObjectUsage->updatedPrivs.getTablePrivs();
       }
     }
     summarizedOriginalPrivs.unionOfPrivs(original);
-    summarizedCurrentPrivs.unionOfPrivs(current);
+    summarizedCurrentPrivs.unionOfPrivs(updated);
+  }
+
+  return STATUS_GOOD;
+}
+
+// *****************************************************************************
+// * Method: updateDependentObjects
+// *                                                       
+// * This code gets the list of dependent objects that have had their privileges
+// * changed because of the ongoing grant/revoke request.  It then updates
+// * the object privileges table to change any dependencies.
+// *
+// * SQL ANSI general rules state 
+// *
+// * - When granting INSERT, UPDATE, or DELETE object or column privilege to
+// *   a table that is referenced by one or more views, then the privilege  
+// *   should be propagated to any updatable views that reference the table. 
+// *   The grant request to the these views should be executed as though the 
+// *   current user is _SYSTEM.
+// *
+// * - If the table already has SELECT privilege and a new grant is 
+// *   performed that adds the WITH GRANT OPTION, then the WITH GRANT OPTION 
+// *   is to be propagated to referencing views.  The grant request should
+// *   be executed as though the current user is _SYSTEM.
+// *
+// * - When revoking INSERT, UPDATE, or DELETE object or column privilege from
+// *   a table that is referenced by one or more views, then the privilege  
+// *   should be revoked on any updatable views that reference the table. 
+// *   The revoke request to the these views should be executed as though the 
+// *   current user is _SYSTEM.
+// *
+// * - If the revoke is performed that removes the WITH GRANT OPTION, then 
+// *   the WITH GRANT OPTION is to be removed frome referencing views.  The 
+// *   revoke request should be executed as though the current user is _SYSTEM.
+// *
+// *****************************************************************************
+PrivStatus PrivMgrPrivileges::updateDependentObjects(
+  const ObjectUsage &objectUsage,
+  const PrivCommand command)
+{
+  std::string traceMsg;
+
+  // get list of any objects that need to change because of the grant/revoke
+  std::vector<ObjectUsage *> listOfObjects;
+  PrivStatus privStatus = getAffectedObjects(objectUsage, command, listOfObjects);
+  if (privStatus == STATUS_ERROR)
+  {
+    deleteListOfAffectedObjects(listOfObjects);
+    return privStatus;
   }
 
+  traceMsg = "list of dependent objects, number of objects is ";
+  traceMsg += to_string((long long int)listOfObjects.size());
+  log (__FILE__, traceMsg, -1);
+
+  char buf [1000];
+  ObjectPrivsMDTable objectPrivsTable (objectTableName_, pDiags_);
+
+  // update the OBJECT_PRIVILEGES row for each effected object
+  // Starting index is 1  - the first entry is the original row that is
+  // updated as part of the grant/revoke request
+  size_t i = 1;
+  for (i; i < listOfObjects.size(); i++)
+  {
+    ObjectUsage *pObjectUsage = listOfObjects[i];
+
+    pObjectUsage->describe(traceMsg);
+    log (__FILE__, traceMsg, i);
+
+    // Determine row contents
+    int32_t theGrantor = (pObjectUsage->grantorIsSystem) ? SYSTEM_USER : grantorID_;
+    int32_t theGrantee = pObjectUsage->granteeID;
+    int64_t theUID = pObjectUsage->objectUID;
+    PrivMgrCoreDesc thePrivs = pObjectUsage->updatedPrivs.getTablePrivs();
+    sprintf(buf, "where grantee_id = %d and grantor_id =  %d and object_uid = %ld",
+            theGrantee, theGrantor, theUID);
+    std::string whereClause (buf);
+
+    if (thePrivs.isNull())
+    {
+      pObjectUsage->describe(traceMsg);
+      traceMsg.insert (0, "deleted object usage ");
+
+      // delete the row
+      privStatus = objectPrivsTable.deleteWhere(whereClause);
+      if (privStatus == STATUS_ERROR)
+      {
+        deleteListOfAffectedObjects(listOfObjects);
+        return privStatus;
+      }
+    }
+    else
+    {
+      sprintf(buf, "set privileges_bitmap  = %ld, grantable_bitmap =  %ld",
+              thePrivs.getPrivBitmap().to_ulong(),
+              thePrivs.getWgoBitmap().to_ulong());
+      std::string setClause (buf);
+      privStatus = objectPrivsTable.updateWhere(setClause, whereClause);
+
+      if (privStatus == STATUS_ERROR)
+      {
+        deleteListOfAffectedObjects(listOfObjects);
+        return privStatus;
+      }
+    }
+  }
+  deleteListOfAffectedObjects(listOfObjects);
   return STATUS_GOOD;
 }
 
 
+
 // *****************************************************************************
 // * Method: isAuthIDGrantedPrivs                                
 // *                                                       
@@ -4348,8 +4793,9 @@ bool PrivMgrPrivileges::isAuthIDGrantedPrivs(const int32_t authID)
 
    if ((privStatus == STATUS_GOOD || privStatus == STATUS_WARNING) &&
         rowCount > 0)
-      return true;
+     return true;
       
+   // TBD - check for granted column level privs
    pDiags_->rewind(diagsMark);
    return false;
 
@@ -5307,13 +5753,17 @@ std::vector<ColPrivSpec> &colPrivsArray =
       // See if the grantor has been granted WGO at column-level for priv.  
       for (size_t j = 0; j < colRowList.size(); j++)
       {
-         ColumnPrivsMDRow &columnRow = static_cast<ColumnPrivsMDRow &> (*colRowList[i]);
-         if (columnRow.grantableBitmap_.test(colPrivSpec.privType))
-         {
-            colPrivSpec.grantorHasWGO = true;
-            break;
+          ColumnPrivsMDRow &columnRow = static_cast<ColumnPrivsMDRow &> (*colRowList[i]);
+          if (columnRow.columnOrdinal_ == colPrivSpec.columnOrdinal)
+          {
+             if (columnRow.grantableBitmap_.test(colPrivSpec.privType))
+             {
+                colPrivSpec.grantorHasWGO = true;
+                break;
+             }
          }
       }
+
       // If the grantor does not have an object-level or column-level WGO
       // for one of the privs to grant, return an error.
       if (!colPrivSpec.grantorHasWGO)
@@ -5329,7 +5779,6 @@ std::vector<ColPrivSpec> &colPrivsArray =
 //*************************** End of hasColumnWGO ******************************
 
 
-
    
 // *****************************************************************************
 // *                                                                           *
diff --git a/core/sql/sqlcomp/PrivMgrPrivileges.h b/core/sql/sqlcomp/PrivMgrPrivileges.h
index c62c0e47aa..1239c7ac5f 100644
--- a/core/sql/sqlcomp/PrivMgrPrivileges.h
+++ b/core/sql/sqlcomp/PrivMgrPrivileges.h
@@ -29,6 +29,7 @@
 #include "PrivMgrMDTable.h"
 #include "PrivMgrDesc.h"
 #include "ComSmallDefs.h"
+#include "ComViewColUsage.h"
 
 #include <string>
 #include <bitset>
@@ -327,6 +328,7 @@ class PrivMgrPrivileges : public PrivMgr
   PrivStatus dealWithViews (
     const ObjectUsage &objectUsage,
     const PrivCommand command,
+    const int32_t grantorID,
     std::vector<ObjectUsage *> &listOfAffectedObjects);
 
   void deleteListOfAffectedObjects(
@@ -340,8 +342,15 @@ class PrivMgrPrivileges : public PrivMgr
     ObjectUsage &constraintUsage,
     const std::vector<ObjectUsage *> listOfAffectedObjects);
 
+  PrivStatus gatherViewColUsages(
+    ObjectReference *objectRef,
+    ViewUsage &viewUsage,
+    std::vector<ComViewColUsage> &viewColUsages);
+
   PrivStatus gatherViewPrivileges(
     ViewUsage &viewUsage,
+    const PrivCommand command,
+    const int32_t grantorID,
     const std::vector<ObjectUsage *> listOfAffectedObjects);
 
   PrivStatus generateColumnRowList();
@@ -355,13 +364,26 @@ class PrivMgrPrivileges : public PrivMgr
   void getColRowsForGranteeOrdinal(
     const int32_t granteeID,
     const int32_t columnOrdinal,
+    const std::vector<PrivMgrMDRow *> &columnRows,
     const std::vector<int32_t> &roleIDs,
     std::vector<PrivMgrMDRow *> &rowList);
 
+  PrivStatus getColumnRowList(
+    const int64_t objectUID,
+   std::vector<PrivMgrMDRow *> &columnRows);
+
   PrivStatus getGrantedPrivs(
     const int32_t granteeID,
     PrivMgrMDRow &row);
 
+  PrivStatus getGranteesForViewUsage (
+    const ViewUsage &viewUsage,
+    std::set<int32_t> &granteeList);
+
+  PrivStatus getObjectRowList(
+    const int64_t objectUID, 
+    std::vector<PrivMgrMDRow *> &objectRows);
+
   PrivStatus getRoleIDsForUserID(
      int32_t userID,
      std::vector<int32_t> & roleIDs);
@@ -410,6 +432,8 @@ class PrivMgrPrivileges : public PrivMgr
 
   void summarizeColPrivs(
     const ObjectReference &objRef,
+    const int32_t granteeID,
+    const int32_t grantorID,
     const std::vector<int32_t> &roleIDs,
     const std::vector<ObjectUsage *> &listOfAffectedObjects,
     std::vector<ColumnReference *> &columnReferences);
@@ -417,11 +441,16 @@ class PrivMgrPrivileges : public PrivMgr
   PrivStatus summarizeCurrentAndOriginalPrivs(
     const int64_t objectUID,
     const int32_t granteeID,
+    const int32_t grantorID,
     const std::vector<int32_t> & roleIDs,
     const std::vector<ObjectUsage *> listOfChangedPrivs,
     PrivMgrDesc &summarizedOriginalPrivs,
     PrivMgrDesc &summarizedCurrentPrivs);
 
+  PrivStatus updateDependentObjects(
+    const ObjectUsage &objectUsage,
+    const PrivCommand command);
+
 // -------------------------------------------------------------------
 // Data Members:
 // -------------------------------------------------------------------
