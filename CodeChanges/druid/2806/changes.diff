diff --git a/docs/content/configuration/coordinator.md b/docs/content/configuration/coordinator.md
index 1461953bf0e..6f95e61bbdb 100644
--- a/docs/content/configuration/coordinator.md
+++ b/docs/content/configuration/coordinator.md
@@ -72,7 +72,8 @@ A sample coordinator dynamic config JSON object is shown below:
   "replicantLifetime": 15,
   "replicationThrottleLimit": 10,
   "emitBalancingStats": false,
-  "killDataSourceWhitelist": ["wikipedia", "testDatasource"]
+  "killDataSourceWhitelist": ["wikipedia", "testDatasource"],
+  "balancerSlope": 0
 }
 ```
 
@@ -88,6 +89,7 @@ Issuing a GET request at the same URL will return the spec that is currently in
 |`replicationThrottleLimit`|The maximum number of segments that can be replicated at one time.|10|
 |`emitBalancingStats`|Boolean flag for whether or not we should emit balancing stats. This is an expensive operation.|false|
 |`killDataSourceWhitelist`|List of dataSources for which kill tasks are sent if property `druid.coordinator.kill.on` is true.|none|
+|`balancerSlope`|The maximum gap of server balancer cost, if all server's cost between the interval, balancer will stop moving segments around.|0|
 
 To view the audit history of coordinator dynamic config issue a GET request to the URL -
 
diff --git a/server/src/main/java/io/druid/server/coordinator/BalancerStrategy.java b/server/src/main/java/io/druid/server/coordinator/BalancerStrategy.java
index 1bf3e115824..15cae4ba71c 100644
--- a/server/src/main/java/io/druid/server/coordinator/BalancerStrategy.java
+++ b/server/src/main/java/io/druid/server/coordinator/BalancerStrategy.java
@@ -25,6 +25,8 @@
 
 public interface BalancerStrategy
 {
+  public static final double DEFAULT_BALANCER_SLOPE = 0;
+
   public ServerHolder findNewSegmentHomeBalancer(final DataSegment proposalSegment, final List<ServerHolder> serverHolders);
 
   public ServerHolder findNewSegmentHomeReplicator(final DataSegment proposalSegment, final List<ServerHolder> serverHolders);
@@ -32,4 +34,6 @@
   public BalancerSegmentHolder pickSegmentToMove(final List<ServerHolder> serverHolders);
 
   public void emitStats(String tier, CoordinatorStats stats, List<ServerHolder> serverHolderList);
+
+  public boolean steady(final List<ServerHolder> serverHolders);
 }
diff --git a/server/src/main/java/io/druid/server/coordinator/CoordinatorDynamicConfig.java b/server/src/main/java/io/druid/server/coordinator/CoordinatorDynamicConfig.java
index 62f07d8474d..9677e01e7f4 100644
--- a/server/src/main/java/io/druid/server/coordinator/CoordinatorDynamicConfig.java
+++ b/server/src/main/java/io/druid/server/coordinator/CoordinatorDynamicConfig.java
@@ -36,6 +36,7 @@
   private final int balancerComputeThreads;
   private final boolean emitBalancingStats;
   private final Set<String> killDataSourceWhitelist;
+  private final double balancerSlope;
 
   @JsonCreator
   public CoordinatorDynamicConfig(
@@ -47,7 +48,8 @@ public CoordinatorDynamicConfig(
       @JsonProperty("replicationThrottleLimit") int replicationThrottleLimit,
       @JsonProperty("balancerComputeThreads") int balancerComputeThreads,
       @JsonProperty("emitBalancingStats") boolean emitBalancingStats,
-      @JsonProperty("killDataSourceWhitelist") Set<String> killDataSourceWhitelist
+      @JsonProperty("killDataSourceWhitelist") Set<String> killDataSourceWhitelist,
+      @JsonProperty("balancerSlope") double balancerSlope
   )
   {
     this.maxSegmentsToMove = maxSegmentsToMove;
@@ -62,6 +64,7 @@ public CoordinatorDynamicConfig(
         Math.max(Runtime.getRuntime().availableProcessors() - 1, 1)
     );
     this.killDataSourceWhitelist = killDataSourceWhitelist;
+    this.balancerSlope = balancerSlope;
   }
 
   @JsonProperty
@@ -118,6 +121,12 @@ public Set<String> getKillDataSourceWhitelist()
     return killDataSourceWhitelist;
   }
 
+  @JsonProperty
+  public double getBalancerSlope()
+  {
+    return balancerSlope;
+  }
+
   @Override
   public String toString()
   {
@@ -131,6 +140,7 @@ public String toString()
            ", balancerComputeThreads=" + balancerComputeThreads +
            ", emitBalancingStats=" + emitBalancingStats +
            ", killDataSourceWhitelist=" + killDataSourceWhitelist +
+           ", balancerSlope=" + balancerSlope +
            '}';
   }
 
@@ -170,6 +180,9 @@ public boolean equals(Object o)
     if (emitBalancingStats != that.emitBalancingStats) {
       return false;
     }
+    if (balancerSlope != that.balancerSlope) {
+      return false;
+    }
     return !(killDataSourceWhitelist != null
              ? !killDataSourceWhitelist.equals(that.killDataSourceWhitelist)
              : that.killDataSourceWhitelist != null);
@@ -188,6 +201,7 @@ public int hashCode()
     result = 31 * result + balancerComputeThreads;
     result = 31 * result + (emitBalancingStats ? 1 : 0);
     result = 31 * result + (killDataSourceWhitelist != null ? killDataSourceWhitelist.hashCode() : 0);
+    result = 31 * result + Double.toString(balancerSlope).hashCode();
     return result;
   }
 
@@ -202,10 +216,11 @@ public int hashCode()
     private boolean emitBalancingStats;
     private int balancerComputeThreads;
     private Set<String> killDataSourceWhitelist;
+    private double balancerSlope;
 
     public Builder()
     {
-      this(15 * 60 * 1000L, 524288000L, 100, 5, 15, 10, 1, false, null);
+      this(15 * 60 * 1000L, 524288000L, 100, 5, 15, 10, 1, false, null, BalancerStrategy.DEFAULT_BALANCER_SLOPE);
     }
 
     private Builder(
@@ -217,7 +232,8 @@ private Builder(
         int replicationThrottleLimit,
         int balancerComputeThreads,
         boolean emitBalancingStats,
-        Set<String> killDataSourceWhitelist
+        Set<String> killDataSourceWhitelist,
+        double balancerSlope
     )
     {
       this.millisToWaitBeforeDeleting = millisToWaitBeforeDeleting;
@@ -229,6 +245,7 @@ private Builder(
       this.emitBalancingStats = emitBalancingStats;
       this.balancerComputeThreads = balancerComputeThreads;
       this.killDataSourceWhitelist = killDataSourceWhitelist;
+      this.balancerSlope = balancerSlope;
     }
 
     public Builder withMillisToWaitBeforeDeleting(long millisToWaitBeforeDeleting)
@@ -279,6 +296,12 @@ public Builder withKillDataSourceWhitelist(Set<String> killDataSourceWhitelist)
       return this;
     }
 
+    public Builder withBalancerSlope(double balancerSlope)
+    {
+      this.balancerSlope = balancerSlope;
+      return this;
+    }
+
     public CoordinatorDynamicConfig build()
     {
       return new CoordinatorDynamicConfig(
@@ -290,7 +313,8 @@ public CoordinatorDynamicConfig build()
           replicationThrottleLimit,
           balancerComputeThreads,
           emitBalancingStats,
-          killDataSourceWhitelist
+          killDataSourceWhitelist,
+          balancerSlope
       );
     }
   }
diff --git a/server/src/main/java/io/druid/server/coordinator/CostBalancerStrategy.java b/server/src/main/java/io/druid/server/coordinator/CostBalancerStrategy.java
index 2a52ba16b1a..e5332ea2ec0 100644
--- a/server/src/main/java/io/druid/server/coordinator/CostBalancerStrategy.java
+++ b/server/src/main/java/io/druid/server/coordinator/CostBalancerStrategy.java
@@ -42,11 +42,13 @@ public class CostBalancerStrategy implements BalancerStrategy
   private static final long THIRTY_DAYS_IN_MILLIS = 30 * DAY_IN_MILLIS;
   private final long referenceTimestamp;
   private final int threadCount;
+  private final double balancerSlope;
 
-  public CostBalancerStrategy(DateTime referenceTimestamp, int threadCount)
+  public CostBalancerStrategy(DateTime referenceTimestamp, int threadCount, double balancerSlope)
   {
     this.referenceTimestamp = referenceTimestamp.getMillis();
     this.threadCount = threadCount;
+    this.balancerSlope = balancerSlope;
   }
 
   @Override
@@ -134,11 +136,18 @@ public double calculateInitialTotalCost(final List<ServerHolder> serverHolders)
   {
     double cost = 0;
     for (ServerHolder server : serverHolders) {
-      DataSegment[] segments = server.getServer().getSegments().values().toArray(new DataSegment[]{});
-      for (int i = 0; i < segments.length; ++i) {
-        for (int j = i; j < segments.length; ++j) {
-          cost += computeJointSegmentCosts(segments[i], segments[j]);
-        }
+      cost += calculateServerCost(server);
+    }
+    return cost;
+  }
+
+  private double calculateServerCost(final ServerHolder server)
+  {
+    double cost = 0;
+    DataSegment[] segments = server.getServer().getSegments().values().toArray(new DataSegment[]{});
+    for (int i = 0; i < segments.length; ++i) {
+      for (int j = i; j < segments.length; ++j) {
+        cost += computeJointSegmentCosts(segments[i], segments[j]);
       }
     }
     return cost;
@@ -268,5 +277,28 @@ public Pair<Double, ServerHolder> call() throws Exception
     return bestServer;
   }
 
+  @Override
+  public boolean steady(final List<ServerHolder> serverHolders)
+  {
+    if (balancerSlope <= BalancerStrategy.DEFAULT_BALANCER_SLOPE) {
+      return false;
+    }
+    double totalCost = 0;
+    double maxCost = Double.MIN_VALUE;
+    double minCost = Double.MAX_VALUE;
+    for (ServerHolder server : serverHolders) {
+      double serverCost = calculateServerCost(server);
+      totalCost += serverCost;
+      maxCost = Math.max(maxCost, serverCost);
+      minCost = Math.min(minCost, serverCost);
+    }
+    double average = totalCost / serverHolders.size();
+    double floor =  average * (1 - balancerSlope);
+    double ceiling =  average * (1 + balancerSlope);
+    if (maxCost < ceiling && minCost > floor) {
+      return true;
+    }
+    return false;
+  }
 }
 
diff --git a/server/src/main/java/io/druid/server/coordinator/CostBalancerStrategyFactory.java b/server/src/main/java/io/druid/server/coordinator/CostBalancerStrategyFactory.java
index f00b5b98e8f..24da70e095b 100644
--- a/server/src/main/java/io/druid/server/coordinator/CostBalancerStrategyFactory.java
+++ b/server/src/main/java/io/druid/server/coordinator/CostBalancerStrategyFactory.java
@@ -23,15 +23,17 @@
 public class CostBalancerStrategyFactory implements BalancerStrategyFactory
 {
   private final int threadCount;
+  private final double balancerSlope;
 
-  public CostBalancerStrategyFactory(int costBalancerStrategyThreadCount)
+  public CostBalancerStrategyFactory(int costBalancerStrategyThreadCount, double balancerSlope)
   {
     this.threadCount = costBalancerStrategyThreadCount;
+    this.balancerSlope = balancerSlope;
   }
 
   @Override
   public BalancerStrategy createBalancerStrategy(DateTime referenceTimestamp)
   {
-    return new CostBalancerStrategy(referenceTimestamp, threadCount);
+    return new CostBalancerStrategy(referenceTimestamp, threadCount, balancerSlope);
   }
 }
diff --git a/server/src/main/java/io/druid/server/coordinator/DruidCoordinator.java b/server/src/main/java/io/druid/server/coordinator/DruidCoordinator.java
index 3b2d20b9e0a..f3bd06c53f0 100644
--- a/server/src/main/java/io/druid/server/coordinator/DruidCoordinator.java
+++ b/server/src/main/java/io/druid/server/coordinator/DruidCoordinator.java
@@ -687,7 +687,10 @@ public void run()
         }
 
         BalancerStrategyFactory factory =
-            new CostBalancerStrategyFactory(getDynamicConfigs().getBalancerComputeThreads());
+            new CostBalancerStrategyFactory(
+                getDynamicConfigs().getBalancerComputeThreads(),
+                getDynamicConfigs().getBalancerSlope()
+            );
 
         // Do coordinator stuff.
         DruidCoordinatorRuntimeParams params =
diff --git a/server/src/main/java/io/druid/server/coordinator/DruidCoordinatorRuntimeParams.java b/server/src/main/java/io/druid/server/coordinator/DruidCoordinatorRuntimeParams.java
index 742999ce243..15eacfe06c6 100644
--- a/server/src/main/java/io/druid/server/coordinator/DruidCoordinatorRuntimeParams.java
+++ b/server/src/main/java/io/druid/server/coordinator/DruidCoordinatorRuntimeParams.java
@@ -21,7 +21,6 @@
 
 import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
-import com.metamx.common.guava.Comparators;
 import com.metamx.emitter.service.ServiceEmitter;
 import io.druid.client.DruidDataSource;
 import io.druid.metadata.MetadataRuleManager;
@@ -206,7 +205,7 @@ public Builder buildFromExisting()
       this.stats = new CoordinatorStats();
       this.coordinatorDynamicConfig = new CoordinatorDynamicConfig.Builder().build();
       this.balancerReferenceTimestamp = DateTime.now();
-      this.strategyFactory = new CostBalancerStrategyFactory(1);
+      this.strategyFactory = new CostBalancerStrategyFactory(1, BalancerStrategy.DEFAULT_BALANCER_SLOPE);
     }
 
     Builder(
diff --git a/server/src/main/java/io/druid/server/coordinator/RandomBalancerStrategy.java b/server/src/main/java/io/druid/server/coordinator/RandomBalancerStrategy.java
index dd6255821d6..0f3e231ec5d 100644
--- a/server/src/main/java/io/druid/server/coordinator/RandomBalancerStrategy.java
+++ b/server/src/main/java/io/druid/server/coordinator/RandomBalancerStrategy.java
@@ -68,4 +68,10 @@ public void emitStats(
   )
   {
   }
+
+  @Override
+  public boolean steady(final List<ServerHolder> serverHolders)
+  {
+    return false;
+  }
 }
diff --git a/server/src/main/java/io/druid/server/coordinator/helper/DruidCoordinatorBalancer.java b/server/src/main/java/io/druid/server/coordinator/helper/DruidCoordinatorBalancer.java
index 431c89d7bca..3c68861dcec 100644
--- a/server/src/main/java/io/druid/server/coordinator/helper/DruidCoordinatorBalancer.java
+++ b/server/src/main/java/io/druid/server/coordinator/helper/DruidCoordinatorBalancer.java
@@ -120,6 +120,11 @@ public DruidCoordinatorRuntimeParams run(DruidCoordinatorRuntimeParams params)
         continue;
       }
 
+      if (strategy.steady(serverHolderList)) {
+        log.info("Druid reach steady state and stop shuffling things around");
+        continue;
+      }
+
       for (int iter = 0; iter < maxSegmentsToMove; iter++) {
         final BalancerSegmentHolder segmentToMove = strategy.pickSegmentToMove(serverHolderList);
 
@@ -134,7 +139,6 @@ public DruidCoordinatorRuntimeParams run(DruidCoordinatorRuntimeParams params)
       stats.addToTieredStat("movedCount", tier, currentlyMovingSegments.get(tier).size());
       if (params.getCoordinatorDynamicConfig().emitBalancingStats()) {
         strategy.emitStats(tier, stats, serverHolderList);
-
       }
       log.info(
           "[%s]: Segments Moved: [%d]", tier, currentlyMovingSegments.get(tier).size()
diff --git a/server/src/test/java/io/druid/server/coordination/CostBalancerStrategyTest.java b/server/src/test/java/io/druid/server/coordination/CostBalancerStrategyTest.java
index 07884b78f91..ff6c816efba 100644
--- a/server/src/test/java/io/druid/server/coordination/CostBalancerStrategyTest.java
+++ b/server/src/test/java/io/druid/server/coordination/CostBalancerStrategyTest.java
@@ -121,7 +121,7 @@ public void testCostBalancerMultiThreadedStrategy() throws InterruptedException
     DataSegment segment = getSegment(1000);
 
     final DateTime referenceTimestamp = new DateTime("2014-01-01");
-    BalancerStrategy strategy = new CostBalancerStrategy(referenceTimestamp, 4);
+    BalancerStrategy strategy = new CostBalancerStrategy(referenceTimestamp, 4, 0);
     ServerHolder holder = strategy.findNewSegmentHomeReplicator(segment, serverHolderList);
     Assert.assertNotNull("Should be able to find a place for new segment!!", holder);
     Assert.assertEquals("Best Server should be BEST_SERVER", "BEST_SERVER", holder.getServer().getName());
@@ -134,7 +134,7 @@ public void testCostBalancerSingleThreadStrategy() throws InterruptedException
     DataSegment segment = getSegment(1000);
 
     final DateTime referenceTimestamp = new DateTime("2014-01-01");
-    BalancerStrategy strategy = new CostBalancerStrategy(referenceTimestamp, 1);
+    BalancerStrategy strategy = new CostBalancerStrategy(referenceTimestamp, 1, 0);
     ServerHolder holder = strategy.findNewSegmentHomeReplicator(segment, serverHolderList);
     Assert.assertNotNull("Should be able to find a place for new segment!!", holder);
     Assert.assertEquals("Best Server should be BEST_SERVER", "BEST_SERVER", holder.getServer().getName());
@@ -147,13 +147,13 @@ public void testBenchmark() throws InterruptedException
     setupDummyCluster(100, 500);
     DataSegment segment = getSegment(1000);
 
-    BalancerStrategy singleThreadStrategy = new CostBalancerStrategy(DateTime.now(DateTimeZone.UTC), 1);
+    BalancerStrategy singleThreadStrategy = new CostBalancerStrategy(DateTime.now(DateTimeZone.UTC), 1, 0);
     long start = System.currentTimeMillis();
     singleThreadStrategy.findNewSegmentHomeReplicator(segment, serverHolderList);
     long end = System.currentTimeMillis();
     long latencySingleThread = end - start;
 
-    BalancerStrategy strategy = new CostBalancerStrategy(DateTime.now(DateTimeZone.UTC), 4);
+    BalancerStrategy strategy = new CostBalancerStrategy(DateTime.now(DateTimeZone.UTC), 4, 0);
     start = System.currentTimeMillis();
     strategy.findNewSegmentHomeReplicator(segment, serverHolderList);
     end = System.currentTimeMillis();
@@ -167,7 +167,7 @@ public void testBenchmark() throws InterruptedException
   public void testComputeJointSegmentCost()
   {
     DateTime referenceTime = new DateTime("2014-01-01T00:00:00");
-    CostBalancerStrategy strategy = new CostBalancerStrategy(referenceTime, 4);
+    CostBalancerStrategy strategy = new CostBalancerStrategy(referenceTime, 4, 0);
     double segmentCost = strategy.computeJointSegmentCosts(
         getSegment(
             100,
@@ -187,7 +187,18 @@ public void testComputeJointSegmentCost()
         )
     );
     Assert.assertEquals(138028.62811791385d, segmentCost, 0);
-
   }
 
+  @Test
+  public void testCostBalancerStrategSteady() throws InterruptedException
+  {
+    setupDummyCluster(10, 20);
+
+    final DateTime referenceTimestamp = new DateTime("2014-01-01");
+    final BalancerStrategy strategy = new CostBalancerStrategy(referenceTimestamp, 1, 0);
+    Assert.assertFalse(strategy.steady(serverHolderList));
+
+    final BalancerStrategy strategy2 = new CostBalancerStrategy(referenceTimestamp, 1, 0.3F);
+    Assert.assertTrue(strategy2.steady(serverHolderList));
+  }
 }
diff --git a/server/src/test/java/io/druid/server/coordinator/DruidCoordinatorRuleRunnerTest.java b/server/src/test/java/io/druid/server/coordinator/DruidCoordinatorRuleRunnerTest.java
index cbc59e9fda0..2e2e16b2e00 100644
--- a/server/src/test/java/io/druid/server/coordinator/DruidCoordinatorRuleRunnerTest.java
+++ b/server/src/test/java/io/druid/server/coordinator/DruidCoordinatorRuleRunnerTest.java
@@ -499,7 +499,7 @@ public void testDropRemove() throws Exception
 
     EasyMock.expect(coordinator.getDynamicConfigs()).andReturn(
         new CoordinatorDynamicConfig(
-            0, 0, 0, 0, 1, 24, 0, false, null
+            0, 0, 0, 0, 1, 24, 0, false, null, 0
         )
     ).anyTimes();
     coordinator.removeSegment(EasyMock.<DataSegment>anyObject());
@@ -1006,7 +1006,7 @@ public void testReplicantThrottleAcrossTiers() throws Exception
   {
     EasyMock.expect(coordinator.getDynamicConfigs()).andReturn(
         new CoordinatorDynamicConfig(
-            0, 0, 0, 0, 1, 7, 0, false, null
+            0, 0, 0, 0, 1, 7, 0, false, null, 0
         )
     ).atLeastOnce();
     coordinator.removeSegment(EasyMock.<DataSegment>anyObject());
@@ -1182,7 +1182,7 @@ private void mockCoordinator()
   {
     EasyMock.expect(coordinator.getDynamicConfigs()).andReturn(
         new CoordinatorDynamicConfig(
-            0, 0, 0, 0, 1, 24, 0, false, null
+            0, 0, 0, 0, 1, 24, 0, false, null, 0
         )
     ).anyTimes();
     coordinator.removeSegment(EasyMock.<DataSegment>anyObject());
diff --git a/server/src/test/java/io/druid/server/http/CoordinatorDynamicConfigTest.java b/server/src/test/java/io/druid/server/http/CoordinatorDynamicConfigTest.java
index af5bb477ecc..d626a80ddb6 100644
--- a/server/src/test/java/io/druid/server/http/CoordinatorDynamicConfigTest.java
+++ b/server/src/test/java/io/druid/server/http/CoordinatorDynamicConfigTest.java
@@ -41,7 +41,8 @@ public void testSerde() throws Exception
                      + "  \"replicantLifetime\": 1,\n"
                      + "  \"replicationThrottleLimit\": 1,\n"
                      + "  \"emitBalancingStats\": true,\n"
-                     + "  \"killDataSourceWhitelist\": [\"test\"]\n"
+                     + "  \"killDataSourceWhitelist\": [\"test\"],\n"
+                     + "  \"balancerSlope\": 0\n"
                      + "}\n";
 
     ObjectMapper mapper = TestHelper.getObjectMapper();
@@ -56,7 +57,7 @@ public void testSerde() throws Exception
     );
 
     Assert.assertEquals(
-        new CoordinatorDynamicConfig(1, 1, 1, 1, 1, 1, 1, true, ImmutableSet.of("test")),
+        new CoordinatorDynamicConfig(1, 1, 1, 1, 1, 1, 1, true, ImmutableSet.of("test"), 0),
         actual
     );
   }
@@ -65,7 +66,7 @@ public void testSerde() throws Exception
   public void testBuilderDefaults()
   {
     Assert.assertEquals(
-        new CoordinatorDynamicConfig(900000, 524288000, 100, 5, 15, 10, 1, false, null),
+        new CoordinatorDynamicConfig(900000, 524288000, 100, 5, 15, 10, 1, false, null, 0),
         new CoordinatorDynamicConfig.Builder().build()
     );
   }
@@ -73,8 +74,8 @@ public void testBuilderDefaults()
   @Test
   public void testEqualsAndHashCodeSanity()
   {
-    CoordinatorDynamicConfig config1 = new CoordinatorDynamicConfig(900000, 524288000, 100, 5, 15, 10, 1, false, null);
-    CoordinatorDynamicConfig config2 = new CoordinatorDynamicConfig(900000, 524288000, 100, 5, 15, 10, 1, false, null);
+    CoordinatorDynamicConfig config1 = new CoordinatorDynamicConfig(900000, 524288000, 100, 5, 15, 10, 1, false, null, 0);
+    CoordinatorDynamicConfig config2 = new CoordinatorDynamicConfig(900000, 524288000, 100, 5, 15, 10, 1, false, null, 0);
 
     Assert.assertEquals(config1, config2);
     Assert.assertEquals(config1.hashCode(), config2.hashCode());
