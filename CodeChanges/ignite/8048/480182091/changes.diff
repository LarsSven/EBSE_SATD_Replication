diff --git a/.gitignore b/.gitignore
index dea16dd84a58..ef98e66b5ca5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -80,3 +80,9 @@ packages
 
 #NodeJs files
 /modules/platforms/nodejs/node_modules
+
+#Python temp files
+**/.eggs
+**/venv
+**/.pytest_cache
+**/pyignite.egg-info
diff --git a/assembly/libs/README.txt b/assembly/libs/README.txt
index 8bb3bad00679..b36ab7352727 100644
--- a/assembly/libs/README.txt
+++ b/assembly/libs/README.txt
@@ -80,7 +80,6 @@ The following modules are available:
 - ignite-hibernate5 (for Hibernate5 integration)
 - ignite-indexing (for SQL querying and indexing)
 - ignite-jcl (for Apache Commons logging)
-- ignite-jms11 (for streaming messaging from JMS queue or topic into Ignite)
 - ignite-jta (for XA integration)
 - ignite-kafka (for streaming messages from Apache Kafka into Ignite)
 - ignite-logj4 (for Log4j logging)
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientServicesImpl.java b/modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientServicesImpl.java
index 5bf523408c14..7f836066f7f0 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientServicesImpl.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientServicesImpl.java
@@ -121,7 +121,7 @@ private ServiceInvocationHandler(String name, long timeout, ClientClusterGroupIm
 
                 return ch.service(ClientOperation.SERVICE_INVOKE,
                     req -> writeServiceInvokeRequest(req, nodeIds, method, args),
-                    res -> utils.readObject(res.in(), false)
+                    res -> utils.readObject(res.in(), false, method.getReturnType())
                 );
             }
             catch (ClientError e) {
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientUtils.java b/modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientUtils.java
index d59200f343d6..fe866b8b4eee 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientUtils.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/client/thin/ClientUtils.java
@@ -538,19 +538,24 @@ BinaryRawWriterEx createBinaryWriter(BinaryOutputStream out) {
 
     /** Read Ignite binary object from input stream. */
     <T> T readObject(BinaryInputStream in, boolean keepBinary) {
+        return readObject(in, keepBinary, null);
+    }
+
+    /** Read Ignite binary object from input stream. */
+    <T> T readObject(BinaryInputStream in, boolean keepBinary, Class<T> clazz) {
         if (keepBinary)
             return (T)marsh.unmarshal(in);
         else {
             BinaryReaderHandles hnds = new BinaryReaderHandles();
 
-            return (T)unwrapBinary(marsh.deserialize(in, hnds), hnds);
+            return (T)unwrapBinary(marsh.deserialize(in, hnds), hnds, clazz);
         }
     }
 
     /**
      * Unwrap binary object.
      */
-    private Object unwrapBinary(Object obj, BinaryReaderHandles hnds) {
+    private Object unwrapBinary(Object obj, BinaryReaderHandles hnds, Class<?> clazz) {
         if (obj instanceof BinaryObjectImpl) {
             BinaryObjectImpl obj0 = (BinaryObjectImpl)obj;
 
@@ -563,7 +568,7 @@ else if (BinaryUtils.knownCollection(obj))
         else if (BinaryUtils.knownMap(obj))
             return unwrapMap((Map<Object, Object>)obj, hnds);
         else if (obj instanceof Object[])
-            return unwrapArray((Object[])obj, hnds);
+            return unwrapArray((Object[])obj, hnds, clazz);
         else
             return obj;
     }
@@ -575,7 +580,7 @@ private Collection<Object> unwrapCollection(Collection<Object> col, BinaryReader
         Collection<Object> col0 = BinaryUtils.newKnownCollection(col);
 
         for (Object obj0 : col)
-            col0.add(unwrapBinary(obj0, hnds));
+            col0.add(unwrapBinary(obj0, hnds, null));
 
         return (col0 instanceof MutableSingletonList) ? U.convertToSingletonList(col0) : col0;
     }
@@ -587,7 +592,7 @@ private Map<Object, Object> unwrapMap(Map<Object, Object> map, BinaryReaderHandl
         Map<Object, Object> map0 = BinaryUtils.newMap(map);
 
         for (Map.Entry<Object, Object> e : map.entrySet())
-            map0.put(unwrapBinary(e.getKey(), hnds), unwrapBinary(e.getValue(), hnds));
+            map0.put(unwrapBinary(e.getKey(), hnds, null), unwrapBinary(e.getValue(), hnds, null));
 
         return map0;
     }
@@ -595,14 +600,18 @@ private Map<Object, Object> unwrapMap(Map<Object, Object> map, BinaryReaderHandl
     /**
      * Unwrap array with binary objects.
      */
-    private Object[] unwrapArray(Object[] arr, BinaryReaderHandles hnds) {
+    private Object[] unwrapArray(Object[] arr, BinaryReaderHandles hnds, Class<?> arrayClass) {
         if (BinaryUtils.knownArray(arr))
             return arr;
 
-        Object[] res = (Object[])Array.newInstance(arr.getClass().getComponentType(), arr.length);
+        Class<?> componentType = arrayClass != null && arrayClass.isArray()
+                ? arrayClass.getComponentType()
+                : arr.getClass().getComponentType();
+
+        Object[] res = (Object[])Array.newInstance(componentType, arr.length);
 
         for (int i = 0; i < arr.length; i++)
-            res[i] = unwrapBinary(arr[i], hnds);
+            res[i] = unwrapBinary(arr[i], hnds, null);
 
         return res;
     }
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/CachePartitionPartialCountersMap.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/CachePartitionPartialCountersMap.java
index 04a0cdcfed1d..9a549177cec6 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/CachePartitionPartialCountersMap.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/CachePartitionPartialCountersMap.java
@@ -177,6 +177,17 @@ public long initialUpdateCounterAt(int idx) {
         return initialUpdCntrs[idx];
     }
 
+    /**
+     * Update initial counter by given index.
+     * It is used when iterated by WAL with a margin.
+     *
+     * @param idx Index.
+     * @param cntr Counter.
+     */
+    public void initialUpdateCounterAt(int idx, long cntr) {
+        initialUpdCntrs[idx] = cntr;
+    }
+
     /**
      * Gets update counter saved at the given index.
      *
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/GridDhtPartitionsExchangeFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/GridDhtPartitionsExchangeFuture.java
index 0dd4b35bc291..48e1b9b2854e 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/GridDhtPartitionsExchangeFuture.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/GridDhtPartitionsExchangeFuture.java
@@ -3540,7 +3540,9 @@ private List<SupplyPartitionInfo> assignHistoricalSuppliers(
 
             long maxCntr = maxCntrObj != null ? maxCntrObj.cnt : 0;
 
-            NavigableSet<Long> nonMaxCntrs = e.getValue().headSet(maxCntr, false);
+            NavigableSet<Long> nonMaxCntrs = e.getValue().headSet(maxCntr, false)
+                // Empty partition cannot be rebalanced by history effectively.
+                .tailSet(0L, false);
 
             // If minimal counter equals maximum then historical supplier does not necessary.
             if (nonMaxCntrs.isEmpty())
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/IgniteHistoricalIteratorException.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/IgniteHistoricalIteratorException.java
index 5b641b253812..868cd55adeb2 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/IgniteHistoricalIteratorException.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/IgniteHistoricalIteratorException.java
@@ -45,4 +45,13 @@ public IgniteHistoricalIteratorException(Throwable cause) {
     public IgniteHistoricalIteratorException(String msg, Throwable cause) {
         super(msg, cause);
     }
+
+    /**
+     * Creates a new exception with the specified message.
+     *
+     * @param msg Detail message.
+     */
+    public IgniteHistoricalIteratorException(String msg) {
+        super(msg);
+    }
 }
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheDatabaseSharedManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheDatabaseSharedManager.java
index 371622613be4..3dc121a1c147 100755
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheDatabaseSharedManager.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheDatabaseSharedManager.java
@@ -1829,6 +1829,11 @@ private Map<Integer, Set<Integer>> partitionsApplicableForWalRebalance() {
         }
     }
 
+    /** {@inheritDoc} */
+    @Override public WALPointer latestWalPointerReservedForPreloading() {
+        return reservedForPreloading;
+    }
+
     /**
      *
      */
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheOffheapManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheOffheapManager.java
index ea0c7d1a9fcb..a01085d3b1d3 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheOffheapManager.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheOffheapManager.java
@@ -122,6 +122,16 @@
  * Used when persistence enabled.
  */
 public class GridCacheOffheapManager extends IgniteCacheOffheapManagerImpl implements DbCheckpointListener {
+    /**
+     * Margin for WAL iterator, that used for historical rebalance on atomic cache.
+     * It is intended for prevent  partition divergence due to reordering in WAL.
+     * <p>
+     * Default is {@code 5}. Iterator starts from 5 updates earlier than expected.
+     *
+     */
+    private final long walAtomicCacheMargin = IgniteSystemProperties.getLong(
+        "WAL_MARGIN_FOR_ATOMIC_CACHE_HISTORICAL_REBALANCE", 5);
+
     /**
      * Throttling timeout in millis which avoid excessive PendingTree access on unwind
      * if there is nothing to clean yet.
@@ -1013,6 +1023,13 @@ private Metas getOrAllocateCacheMetas() throws IgniteCheckedException {
         if (grp.mvccEnabled()) // TODO IGNITE-7384
             return super.historicalIterator(partCntrs, missing);
 
+        GridCacheDatabaseSharedManager database = (GridCacheDatabaseSharedManager)grp.shared().database();
+
+        FileWALPointer latestReservedPointer = (FileWALPointer)database.latestWalPointerReservedForPreloading();
+
+        if (latestReservedPointer == null)
+            throw new IgniteHistoricalIteratorException("Historical iterator wasn't created, because WAL isn't reserved.");
+
         Map<Integer, Long> partsCounters = new HashMap<>();
 
         for (int i = 0; i < partCntrs.size(); i++) {
@@ -1022,14 +1039,18 @@ private Metas getOrAllocateCacheMetas() throws IgniteCheckedException {
             partsCounters.put(p, initCntr);
         }
 
-        GridCacheDatabaseSharedManager database = (GridCacheDatabaseSharedManager)grp.shared().database();
+        FileWALPointer minPtr = database.checkpointHistory().searchEarliestWalPointer(grp.groupId(),
+            partsCounters, latestReservedPointer, grp.hasAtomicCaches() ? walAtomicCacheMargin : 0L);
 
-        FileWALPointer minPtr = (FileWALPointer)database.checkpointHistory().searchEarliestWalPointer(grp.groupId(), partsCounters);
+        assert latestReservedPointer.compareTo(minPtr) <= 0
+            : "Historical iterator tries to iterate WAL out of reservation [cache=" + grp.cacheOrGroupName()
+            + ", reservedPointer=" + database.latestWalPointerReservedForPreloading()
+            + ", historicalPointer=" + minPtr + ']';
 
         try {
             WALIterator it = grp.shared().wal().replay(minPtr);
 
-            WALHistoricalIterator histIt = new WALHistoricalIterator(log, grp, partCntrs, it);
+            WALHistoricalIterator histIt = new WALHistoricalIterator(log, grp, partCntrs, partsCounters, it);
 
             // Add historical partitions which are unabled to reserve to missing set.
             missing.addAll(histIt.missingParts);
@@ -1220,7 +1241,11 @@ private static class WALHistoricalIterator implements IgniteHistoricalIterator {
          * @param grp Cache context.
          * @param walIt WAL iterator.
          */
-        private WALHistoricalIterator(IgniteLogger log, CacheGroupContext grp, CachePartitionPartialCountersMap partMap,
+        private WALHistoricalIterator(
+            IgniteLogger log,
+            CacheGroupContext grp,
+            CachePartitionPartialCountersMap partMap,
+            Map<Integer, Long> updatedPartCntr,
             WALIterator walIt) {
             this.log = log;
             this.grp = grp;
@@ -1231,8 +1256,13 @@ private WALHistoricalIterator(IgniteLogger log, CacheGroupContext grp, CachePart
 
             rebalancedCntrs = new long[partMap.size()];
 
-            for (int i = 0; i < rebalancedCntrs.length; i++)
-                rebalancedCntrs[i] = partMap.initialUpdateCounterAt(i);
+            for (int i = 0; i < rebalancedCntrs.length; i++) {
+                int p = partMap.partitionAt(i);
+
+                rebalancedCntrs[i] = updatedPartCntr.get(p);
+
+                partMap.initialUpdateCounterAt(i, rebalancedCntrs[i]);
+            }
 
             reservePartitions();
 
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/IgniteCacheDatabaseSharedManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/IgniteCacheDatabaseSharedManager.java
index a147cde02429..32ed5d13b13f 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/IgniteCacheDatabaseSharedManager.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/IgniteCacheDatabaseSharedManager.java
@@ -1079,6 +1079,15 @@ public void releaseHistoryForPreloading() {
         // No-op
     }
 
+    /**
+     * Returns the latest WAL pointer that reserved for preloading or {@code null}.
+     *
+     * @return WAL pointer or {@code null} if nothing reserved.
+     */
+    public WALPointer latestWalPointerReservedForPreloading() {
+        return null;
+    }
+
     /**
      * Checks that the given {@code region} has enough space for putting a new entry.
      *
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/checkpoint/CheckpointHistory.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/checkpoint/CheckpointHistory.java
index 9a813666244e..511164ab5e2d 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/checkpoint/CheckpointHistory.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/checkpoint/CheckpointHistory.java
@@ -22,6 +22,7 @@
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.NavigableMap;
@@ -296,11 +297,7 @@ public List<CheckpointEntry> onWalTruncated(WALPointer ptr) {
 
                 CheckpointEntry oldestCpInHistory = firstCheckpoint();
 
-                Iterator<Map.Entry<GroupPartitionId, CheckpointEntry>> iter = earliestCp.entrySet().iterator();
-
-                while (iter.hasNext()) {
-                    Map.Entry<GroupPartitionId, CheckpointEntry> grpPartPerCp = iter.next();
-
+                for (Map.Entry<GroupPartitionId, CheckpointEntry> grpPartPerCp : earliestCp.entrySet()) {
                     if (grpPartPerCp.getValue() == deletedCpEntry)
                         grpPartPerCp.setValue(oldestCpInHistory);
                 }
@@ -450,9 +447,16 @@ private IgniteBiTuple<Long, Long> calculateWalSegmentsCovered() {
      *
      * @param grpId Group id.
      * @param partsCounter Partition mapped to update counter.
+     * @param latestReservedPointer Latest reserved WAL pointer.
+     * @param margin Margin pointer.
      * @return Earliest WAL pointer for group specified.
      */
-    @Nullable public WALPointer searchEarliestWalPointer(int grpId, Map<Integer, Long> partsCounter) throws IgniteCheckedException {
+    @Nullable public FileWALPointer searchEarliestWalPointer(
+        int grpId,
+        Map<Integer, Long> partsCounter,
+        FileWALPointer latestReservedPointer,
+        long margin
+    ) throws IgniteCheckedException {
         if (F.isEmpty(partsCounter))
             return null;
 
@@ -460,11 +464,17 @@ private IgniteBiTuple<Long, Long> calculateWalSegmentsCovered() {
 
         FileWALPointer minPtr = null;
 
+        LinkedList<WalPointerCandidate> historyPointerCandidate = new LinkedList<>();
+
         for (Long cpTs : checkpoints(true)) {
             CheckpointEntry cpEntry = entry(cpTs);
 
+            minPtr = getMinimalPointer(partsCounter, margin, minPtr, historyPointerCandidate, cpEntry);
+
             Iterator<Map.Entry<Integer, Long>> iter = modifiedPartsCounter.entrySet().iterator();
 
+            FileWALPointer ptr = (FileWALPointer)cpEntry.checkpointMark();
+
             while (iter.hasNext()) {
                 Map.Entry<Integer, Long> entry = iter.next();
 
@@ -473,20 +483,27 @@ private IgniteBiTuple<Long, Long> calculateWalSegmentsCovered() {
                 if (foundCntr != null && foundCntr <= entry.getValue()) {
                     iter.remove();
 
-                    FileWALPointer ptr = (FileWALPointer)cpEntry.checkpointMark();
-
                     if (ptr == null) {
                         throw new IgniteCheckedException("Could not find start pointer for partition [part="
                             + entry.getKey() + ", partCntrSince=" + entry.getValue() + "]");
                     }
 
+                    if (foundCntr + margin > entry.getValue()) {
+                        historyPointerCandidate.add(new WalPointerCandidate(grpId, entry.getKey(), entry.getValue(), ptr,
+                            foundCntr));
+
+                        continue;
+                    }
+
+                    partsCounter.put(entry.getKey(), entry.getValue() - margin);
+
                     if (minPtr == null || ptr.compareTo(minPtr) < 0)
                         minPtr = ptr;
                 }
             }
 
-            if (F.isEmpty(modifiedPartsCounter))
-                return minPtr;
+            if ((F.isEmpty(modifiedPartsCounter) && F.isEmpty(historyPointerCandidate)) || ptr.compareTo(latestReservedPointer) == 0)
+                break;
         }
 
         if (!F.isEmpty(modifiedPartsCounter)) {
@@ -496,9 +513,103 @@ private IgniteBiTuple<Long, Long> calculateWalSegmentsCovered() {
                 + entry.getKey() + ", partCntrSince=" + entry.getValue() + "]");
         }
 
+        minPtr = getMinimalPointer(partsCounter, margin, minPtr, historyPointerCandidate, null);
+
         return minPtr;
     }
 
+    /**
+     * Finds a minimal WAL pointer.
+     *
+     * @param partsCounter Partition mapped to update counter.
+     * @param margin Margin pointer.
+     * @param minPtr Minimal WAL pointer which was determined before.
+     * @param historyPointerCandidate Collection of candidates for a historical WAL pointer.
+     * @param cpEntry Checkpoint entry.
+     * @return Minimal WAL pointer.
+     */
+    private FileWALPointer getMinimalPointer(
+        Map<Integer, Long> partsCounter,
+        long margin,
+        FileWALPointer minPtr,
+        LinkedList<WalPointerCandidate> historyPointerCandidate,
+        CheckpointEntry cpEntry
+    ) {
+        while (!F.isEmpty(historyPointerCandidate)) {
+            FileWALPointer ptr = historyPointerCandidate.poll()
+                .choose(cpEntry, margin, partsCounter);
+
+            if (minPtr == null || ptr.compareTo(minPtr) < 0)
+                minPtr = ptr;
+        }
+
+        return minPtr;
+    }
+
+    /**
+     * The class is used for get a pointer with a specific margin.
+     * This stores the nearest pointer which covering a partition counter.
+     * It is able to choose between other pointer and this.
+     */
+    private class WalPointerCandidate {
+        /** Group id. */
+        private final int grpId;
+
+        /** Partition id. */
+        private final int part;
+
+        /** Partition counter. */
+        private final long partContr;
+
+        /** WAL pointer. */
+        private final FileWALPointer walPntr;
+
+        /** Partition counter at the moment of WAL pointer. */
+        private final long walPntrCntr;
+
+        /**
+         * @param grpId Group id.
+         * @param part Partition id.
+         * @param partContr Partition counter.
+         * @param walPntr WAL pointer.
+         * @param walPntrCntr Counter of WAL pointer.
+         */
+        public WalPointerCandidate(int grpId, int part, long partContr, FileWALPointer walPntr, long walPntrCntr) {
+            this.grpId = grpId;
+            this.part = part;
+            this.partContr = partContr;
+            this.walPntr = walPntr;
+            this.walPntrCntr = walPntrCntr;
+        }
+
+        /**
+         * Make a choice between stored WAL pointer and other, getting from checkpoint, with a specific margin.
+         * Updates counter in collection from parameters.
+         *
+         * @param cpEntry Checkpoint entry.
+         * @param margin Margin.
+         * @param partCntsForUpdate Collection of partition id by counter.
+         * @return Chosen WAL pointer.
+         */
+        public FileWALPointer choose(
+            CheckpointEntry cpEntry,
+            long margin,
+            Map<Integer, Long> partCntsForUpdate
+        ) {
+            Long foundCntr = cpEntry == null ? null : cpEntry.partitionCounter(cctx, grpId, part);
+
+            if (foundCntr == null || foundCntr == walPntrCntr) {
+                partCntsForUpdate.put(part, walPntrCntr);
+
+                return walPntr;
+            }
+
+            partCntsForUpdate.put(part, Math.max(foundCntr, partContr - margin));
+
+            return (FileWALPointer)cpEntry.checkpointMark();
+        }
+    }
+
     /**
      * Tries to search for a WAL pointer for the given partition counter start.
      *
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/metastorage/pendingtask/DurableBackgroundTask.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/metastorage/pendingtask/DurableBackgroundTask.java
index a9e8d9e1ecbf..355f624f527d 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/metastorage/pendingtask/DurableBackgroundTask.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/metastorage/pendingtask/DurableBackgroundTask.java
@@ -38,4 +38,21 @@ public interface DurableBackgroundTask extends Serializable {
      * @param ctx Grid kernal context.
      */
     public void execute(GridKernalContext ctx);
+
+    /**
+     * Method that marks task as complete.
+     */
+    public void complete();
+
+    /**
+     * Method that return completion flag.
+     *
+     * @return flag that task completed.
+     */
+    public boolean isCompleted();
+
+    /**
+     * Callback for task cancellation.
+     */
+    public void onCancel();
 }
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/localtask/DurableBackgroundTasksProcessor.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/localtask/DurableBackgroundTasksProcessor.java
index 05d82bfe3965..559edb8b8aae 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/localtask/DurableBackgroundTasksProcessor.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/localtask/DurableBackgroundTasksProcessor.java
@@ -26,6 +26,8 @@
 import org.apache.ignite.internal.GridKernalContext;
 import org.apache.ignite.internal.client.util.GridConcurrentHashSet;
 import org.apache.ignite.internal.processors.GridProcessorAdapter;
+import org.apache.ignite.internal.processors.cache.persistence.DbCheckpointListener;
+import org.apache.ignite.internal.processors.cache.persistence.GridCacheDatabaseSharedManager;
 import org.apache.ignite.internal.processors.cache.persistence.metastorage.MetastorageLifecycleListener;
 import org.apache.ignite.internal.processors.cache.persistence.metastorage.MetastorageTree;
 import org.apache.ignite.internal.processors.cache.persistence.metastorage.ReadOnlyMetastorage;
@@ -42,7 +44,8 @@
  * Processor that is responsible for durable background tasks that are executed on local node
  * and should be continued even after node restart.
  */
-public class DurableBackgroundTasksProcessor extends GridProcessorAdapter implements MetastorageLifecycleListener {
+public class DurableBackgroundTasksProcessor extends GridProcessorAdapter implements MetastorageLifecycleListener,
+        DbCheckpointListener {
     /** Prefix for metastorage keys for durable background tasks. */
     private static final String STORE_DURABLE_BACKGROUND_TASK_PREFIX = "durable-background-task-";
 
@@ -74,8 +77,10 @@ public DurableBackgroundTasksProcessor(GridKernalContext ctx) {
     private void asyncDurableBackgroundTasksExecution() {
         assert durableBackgroundTasks != null;
 
-        for (DurableBackgroundTask task : durableBackgroundTasks.values())
-            asyncDurableBackgroundTaskExecute(task, false);
+        for (DurableBackgroundTask task : durableBackgroundTasks.values()) {
+            if (!task.isCompleted())
+                asyncDurableBackgroundTaskExecute(task, false);
+        }
     }
 
     /**
@@ -93,9 +98,9 @@ private void asyncDurableBackgroundTaskExecute(DurableBackgroundTask task, boole
 
                     task.execute(ctx);
 
-                    log.info("Execution of durable background task completed: " + task.shortName());
+                    task.complete();
 
-                    removeDurableBackgroundTask(task);
+                    log.info("Execution of durable background task completed: " + task.shortName());
                 }
                 catch (Throwable e) {
                     log.error("Could not execute durable background task: " + task.shortName(), e);
@@ -172,6 +177,8 @@ public void onStateChangeFinish(ChangeGlobalStateFinishMessage msg) {
             }
         }
 
+        ((GridCacheDatabaseSharedManager)ctx.cache().context().database()).addCheckpointListener(this);
+
         this.metastorage = metastorage;
     }
 
@@ -262,4 +269,22 @@ public void startDurableBackgroundTask(DurableBackgroundTask task, CacheConfigur
 
         asyncDurableBackgroundTaskExecute(task, false);
     }
+
+    /** {@inheritDoc} */
+    @Override public void onMarkCheckpointBegin(Context ctx) {
+        for (DurableBackgroundTask task : durableBackgroundTasks.values()) {
+            if (task.isCompleted())
+                removeDurableBackgroundTask(task);
+        }
+    }
+
+    /** {@inheritDoc} */
+    @Override public void onCheckpointBegin(Context ctx) {
+        /* No op. */
+    }
+
+    /** {@inheritDoc} */
+    @Override public void beforeCheckpointBegin(Context ctx) {
+        /* No op. */
+    }
 }
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/platform/client/service/ClientServiceInvokeRequest.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/platform/client/service/ClientServiceInvokeRequest.java
index e51780bea678..456d077fb621 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/platform/client/service/ClientServiceInvokeRequest.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/platform/client/service/ClientServiceInvokeRequest.java
@@ -150,29 +150,33 @@ public ClientServiceInvokeRequest(BinaryReaderExImpl reader) {
 
         IgniteServices services = grp.services();
 
-        if (!keepBinary() && args.length > 0) {
-            for (int i = 0; i < args.length; i++) {
-                if (paramTypeIds != null)
-                    reader.readInt(); // Skip parameter typeId, we already read it in constructor.
-
-                args[i] = reader.readObject();
-            }
-        }
-
         try {
             Object res;
 
             if (PlatformService.class.isAssignableFrom(svcCls)) {
+                // Never deserialize platform service arguments and result: may contain platform-only types.
                 PlatformService proxy = services.serviceProxy(name, PlatformService.class, false, timeout);
 
-                res = proxy.invokeMethod(methodName, keepBinary(), !keepBinary(), args);
+                res = proxy.invokeMethod(methodName, keepBinary(), false, args);
             }
             else {
+                // Deserialize Java service arguments when not in keepBinary mode.
+                if (!keepBinary() && args.length > 0) {
+                    for (int i = 0; i < args.length; i++) {
+                        if (paramTypeIds != null)
+                            reader.readInt(); // Skip parameter typeId, we already read it in constructor.
+
+                        args[i] = reader.readObject();
+                    }
+                }
+
                 GridServiceProxy<?> proxy = new GridServiceProxy<>(grp, name, Service.class, false, timeout,
                     ctx.kernalContext());
 
                 Method method = resolveMethod(ctx, svcCls);
 
+                PlatformServices.convertArrayArgs(args, method);
+
                 res = proxy.invokeMethod(method, args);
             }
 
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/platform/services/PlatformServices.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/platform/services/PlatformServices.java
index 8e67cab2d039..21c3d722faab 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/platform/services/PlatformServices.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/platform/services/PlatformServices.java
@@ -526,6 +526,33 @@ public static Method getMethod(Class<?> clazz, String mthdName, Object[] args) t
         return ServiceProxyHolder.getMethod(clazz, mthdName, args);
     }
 
+    /**
+     * Convert Object[] to T[] when required:
+     * Ignite loses array item types when passing arguments through GridServiceProxy.
+     *
+     * @param args Service method args.
+     * @param mtd Target method.
+     */
+    public static void convertArrayArgs(Object[] args, Method mtd) {
+        for (int i = 0; i < args.length; i++) {
+            Object arg = args[i];
+
+            if (arg instanceof Object[]) {
+                Class<?> parameterType = mtd.getParameterTypes()[i];
+
+                if (parameterType.isArray() && parameterType != Object[].class) {
+                    Object[] arr = (Object[])arg;
+                    Object newArg = Array.newInstance(parameterType.getComponentType(), arr.length);
+
+                    for (int j = 0; j < arr.length; j++)
+                        Array.set(newArg, j, arr[j]);
+
+                    args[i] = newArg;
+                }
+            }
+        }
+    }
+
     /**
      * Proxy holder.
      */
@@ -593,26 +620,7 @@ public Object invoke(String mthdName, boolean srvKeepBinary, Object[] args)
                     args = PlatformUtils.unwrapBinariesInArray(args);
 
                 Method mtd = getMethod(serviceClass, mthdName, args);
-
-                // Convert Object[] to T[] when required:
-                // Ignite loses array item types when passing arguments through GridServiceProxy.
-                for (int i = 0; i < args.length; i++) {
-                    Object arg = args[i];
-
-                    if (arg instanceof Object[]) {
-                        Class<?> parameterType = mtd.getParameterTypes()[i];
-
-                        if (parameterType.isArray() && parameterType != Object[].class) {
-                            Object[] arr = (Object[])arg;
-                            Object newArg = Array.newInstance(parameterType.getComponentType(), arr.length);
-
-                            for (int j = 0; j < arr.length; j++)
-                                Array.set(newArg, j, arr[j]);
-
-                            args[i] = newArg;
-                        }
-                    }
-                }
+                convertArrayArgs(args, mtd);
 
                 try {
                     return ((GridServiceProxy)proxy).invokeMethod(mtd, args);
diff --git a/modules/core/src/test/java/org/apache/ignite/cache/ResetLostPartitionTest.java b/modules/core/src/test/java/org/apache/ignite/cache/ResetLostPartitionTest.java
index bfab17ce3fdd..3b972ef80afe 100644
--- a/modules/core/src/test/java/org/apache/ignite/cache/ResetLostPartitionTest.java
+++ b/modules/core/src/test/java/org/apache/ignite/cache/ResetLostPartitionTest.java
@@ -77,9 +77,8 @@ public class ResetLostPartitionTest extends GridCommonAbstractTest {
 
     /** {@inheritDoc} */
     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
-        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);
-
-        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());
+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName)
+            .setCommunicationSpi(new TestRecordingCommunicationSpi());
 
         cfg.setConsistentId(igniteInstanceName);
 
@@ -87,7 +86,8 @@ public class ResetLostPartitionTest extends GridCommonAbstractTest {
 
         storageCfg.setPageSize(1024).setWalMode(LOG_ONLY).setWalSegmentSize(4 * 1024 * 1024);
 
-        storageCfg.setDefaultDataRegionConfiguration(new DataRegionConfiguration().setPersistenceEnabled(true)
+        storageCfg.setDefaultDataRegionConfiguration(new DataRegionConfiguration()
+            .setPersistenceEnabled(true)
             .setMaxSize(100L * 1024 * 1024));
 
         cfg.setDataStorageConfiguration(storageCfg);
diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/CachePartitionLostAfterSupplierHasLeftTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/CachePartitionLostAfterSupplierHasLeftTest.java
index 096e5a8fe3a2..cae4974f6de7 100644
--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/CachePartitionLostAfterSupplierHasLeftTest.java
+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/CachePartitionLostAfterSupplierHasLeftTest.java
@@ -348,10 +348,24 @@ private void doTestPartitionLostWhileClearing(int cnt, int mode) throws Exceptio
             }
         });
 
-        IgniteEx g1 = startGrid(idx1);
+        IgniteConfiguration cfg = getConfiguration(getTestIgniteInstanceName(idx1));
+
+        ((TestRecordingCommunicationSpi)cfg.getCommunicationSpi()).blockMessages((node, msg) -> {
+            if (msg instanceof GridDhtPartitionDemandMessage) {
+                GridDhtPartitionDemandMessage demandMsg = (GridDhtPartitionDemandMessage)msg;
+
+                return CU.cacheId(DEFAULT_CACHE_NAME) == demandMsg.groupId();
+            }
+
+            return false;
+        });
+
+        IgniteEx g1 = startGrid(optimize(cfg));
 
         stopGrid(idx0); // Stop supplier in the middle of rebalancing.
 
+        TestRecordingCommunicationSpi.spi(g1).stopBlock();
+
         final GridDhtLocalPartition part = g1.cachex(DEFAULT_CACHE_NAME).context().topology().localPartition(partId);
 
         assertTrue("Unexpected partition state [p=" + partId +
diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/rebalancing/SupplyPartitionHistoricallyWithReorderedUpdates.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/rebalancing/SupplyPartitionHistoricallyWithReorderedUpdates.java
new file mode 100644
index 000000000000..9beb9f9489ec
--- /dev/null
+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/rebalancing/SupplyPartitionHistoricallyWithReorderedUpdates.java
@@ -0,0 +1,223 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache.distributed.rebalancing;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.ignite.IgniteCache;
+import org.apache.ignite.IgniteSystemProperties;
+import org.apache.ignite.cache.CacheAtomicityMode;
+import org.apache.ignite.cache.affinity.AffinityFunctionContext;
+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;
+import org.apache.ignite.cluster.ClusterNode;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.TestRecordingCommunicationSpi;
+import org.apache.ignite.internal.processors.cache.distributed.dht.atomic.GridDhtAtomicSingleUpdateRequest;
+import org.apache.ignite.testframework.ListeningTestLogger;
+import org.apache.ignite.testframework.LogListener;
+import org.apache.ignite.testframework.junits.WithSystemProperty;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+
+/**
+ * Checks a historical rebalance on atomic cache, when demand node has re-ordered updates.
+ */
+@WithSystemProperty(key = IgniteSystemProperties.IGNITE_PDS_WAL_REBALANCE_THRESHOLD, value = "0")
+public class SupplyPartitionHistoricallyWithReorderedUpdates extends GridCommonAbstractTest {
+    /** Historical iterator problem. */
+    private static String HISTORICAL_ITERATOR_PROBLEM = "Historical iterator tries to iterate WAL out of reservation";
+
+    /** Listening logger. */
+    private ListeningTestLogger listeningLog;
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setGridLogger(listeningLog)
+            .setCommunicationSpi(new TestRecordingCommunicationSpi())
+            .setDataStorageConfiguration(new DataStorageConfiguration()
+                .setCheckpointFrequency(600_000)
+                .setDefaultDataRegionConfiguration(new DataRegionConfiguration()
+                    .setMaxSize(200L * 1024 * 1024)
+                    .setPersistenceEnabled(true)))
+            .setConsistentId(igniteInstanceName)
+            .setCacheConfiguration(new CacheConfiguration(DEFAULT_CACHE_NAME)
+                .setAtomicityMode(CacheAtomicityMode.ATOMIC)
+                .setAffinity(new TestAffinity(getTestIgniteInstanceName(0), getTestIgniteInstanceName(1))));
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        stopAllGrids();
+
+        cleanPersistenceDir();
+
+        super.afterTest();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+
+        cleanPersistenceDir();
+
+        listeningLog = new ListeningTestLogger(log);
+    }
+
+    /**
+     * Backup node loses one entry, after this it will restore state through historical rebalance.
+     *
+     * @throws Exception If failed.
+     */
+    @Test
+    public void testLoosingCreateSupplyLatestUpdates() throws Exception {
+        restartsBackupWithReorderedUpdate(false, false);
+    }
+
+    /**
+     * Backup node loses one update entry, after this it will restore state through historical rebalance.
+     *
+     * @throws Exception If failed.
+     */
+    @Test
+    public void testLoosingUpdateSupplyLatestUpdates() throws Exception {
+        restartsBackupWithReorderedUpdate(true, false);
+    }
+
+    /**
+     * Checks scenario, where a WAL pointer with an additional margin goes out of the bound of a preloading reservation.
+     *
+     * @throws Exception If failed.
+     */
+    @Test
+    public void testMarginGoesOutOfReservation() throws Exception {
+        restartsBackupWithReorderedUpdate(true, true);
+    }
+
+    /**
+     * Starts two nodes (first primary, second backup), reorders update on a backup and after restarts the backup node.
+     *
+     * @param updateExistedKys True for reordered update existing key, false reordered creating new entries.
+     * @param isCpRequiredBeforeStopNode If the parameter is true then checkpoint required, otherwise not.
+     * @throws Exception If failed.
+     */
+    private void restartsBackupWithReorderedUpdate(boolean updateExistedKys, boolean isCpRequiredBeforeStopNode) throws Exception {
+        IgniteEx ignite0 = startGrids(2);
+
+        ignite0.cluster().state(ClusterState.ACTIVE);
+
+        IgniteCache cache = ignite0.cache(DEFAULT_CACHE_NAME);
+
+        for (int i = 0; i < 10; i++)
+            cache.put(i, i);
+
+        AtomicBoolean blocked = new AtomicBoolean();
+
+        TestRecordingCommunicationSpi.spi(ignite0).blockMessages((node, msg) ->
+            msg instanceof GridDhtAtomicSingleUpdateRequest &&
+                getTestIgniteInstanceName(1).equals(node.consistentId()) &&
+                blocked.compareAndSet(false, true));
+
+        if (updateExistedKys) {
+            for (int i = 5; i < 10; i++)
+                cache.put(i, i + 1);
+        }
+        else {
+            for (int i = 15; i < 20; i++)
+                cache.put(i, i);
+        }
+
+        TestRecordingCommunicationSpi.spi(ignite0).waitForBlocked();
+
+        if (isCpRequiredBeforeStopNode)
+            forceCheckpoint();
+
+        stopGrid(1);
+
+        TestRecordingCommunicationSpi.spi(ignite0).stopBlock();
+
+        for (int i = 20; i < 30; i++)
+            cache.put(i, i);
+
+        forceCheckpoint(ignite0);
+
+        LogListener lsnr = LogListener.matches(HISTORICAL_ITERATOR_PROBLEM).build();
+
+        listeningLog.registerListener(lsnr);
+
+        startGrid(1);
+
+        awaitPartitionMapExchange();
+
+        assertFalse(lsnr.check());
+
+        if (!isCpRequiredBeforeStopNode)
+            assertPartitionsSame(idleVerify(ignite0, DEFAULT_CACHE_NAME));
+    }
+
+    /**
+     * Tets affinity function with one partition. This implementation maps primary partition to first node and backup
+     * partition to second.
+     */
+    public static class TestAffinity extends RendezvousAffinityFunction {
+        /** Nodes consistence ids. */
+        String[] nodeConsistentIds;
+
+        /**
+         * @param nodes Nodes consistence ids.
+         */
+        public TestAffinity(String... nodes) {
+            super(false, 1);
+
+            this.nodeConsistentIds = nodes;
+        }
+
+        /** {@inheritDoc} */
+        @Override public List<List<ClusterNode>> assignPartitions(AffinityFunctionContext affCtx) {
+            int nodes = affCtx.currentTopologySnapshot().size();
+
+            if (nodes != 2)
+                return super.assignPartitions(affCtx);
+
+            List<List<ClusterNode>> assignment = new ArrayList<>();
+
+            assignment.add(new ArrayList<>(2));
+
+            assignment.get(0).add(null);
+            assignment.get(0).add(null);
+
+            for (ClusterNode node : affCtx.currentTopologySnapshot())
+                if (nodeConsistentIds[0].equals(node.consistentId()))
+                    assignment.get(0).set(0, node);
+                else if (nodeConsistentIds[1].equals(node.consistentId()))
+                    assignment.get(0).set(1, node);
+                else
+                    throw new AssertionError("Unexpected node consistent id is " + node.consistentId());
+
+            return assignment;
+        }
+    }
+}
diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/wal/WalRecoveryTxLogicalRecordsTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/wal/WalRecoveryTxLogicalRecordsTest.java
index d8a6604ad3fa..7f3847485683 100644
--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/wal/WalRecoveryTxLogicalRecordsTest.java
+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/wal/WalRecoveryTxLogicalRecordsTest.java
@@ -63,6 +63,7 @@
 import org.apache.ignite.internal.processors.cache.persistence.freelist.AbstractFreeList;
 import org.apache.ignite.internal.processors.cache.persistence.freelist.PagesList;
 import org.apache.ignite.internal.processors.cache.persistence.tree.reuse.ReuseListImpl;
+import org.apache.ignite.internal.processors.cache.persistence.wal.FileWALPointer;
 import org.apache.ignite.internal.processors.cache.transactions.TransactionProxyImpl;
 import org.apache.ignite.internal.util.typedef.F;
 import org.apache.ignite.internal.util.typedef.T2;
@@ -370,6 +371,9 @@ public void testHistoricalRebalanceIterator() throws Exception {
                 map = new IgniteDhtDemandedPartitionsMap();
                 map.addHistorical(0, i, entries, PARTS);
 
+                GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading",
+                    new FileWALPointer(0, 0, 0));
+
                 try (IgniteRebalanceIterator it = offh.rebalanceIterator(map, topVer)) {
                     assertNotNull(it);
 
@@ -386,10 +390,16 @@ public void testHistoricalRebalanceIterator() throws Exception {
 
                     assertFalse(it.hasNext());
                 }
+                finally {
+                    GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading", null);
+                }
 
                 map = new IgniteDhtDemandedPartitionsMap();
                 map.addHistorical(1, i, entries, PARTS);
 
+                GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading",
+                    new FileWALPointer(0, 0, 0));
+
                 try (IgniteRebalanceIterator it = offh.rebalanceIterator(map, topVer)) {
                     assertNotNull(it);
 
@@ -406,6 +416,9 @@ public void testHistoricalRebalanceIterator() throws Exception {
 
                     assertFalse(it.hasNext());
                 }
+                finally {
+                    GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading", null);
+                }
             }
 
             stopAllGrids();
@@ -425,6 +438,9 @@ public void testHistoricalRebalanceIterator() throws Exception {
                 map = new IgniteDhtDemandedPartitionsMap();
                 map.addHistorical(0, i, entries, PARTS);
 
+                GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading",
+                    new FileWALPointer(0, 0, 0));
+
                 try (IgniteRebalanceIterator it = offh.rebalanceIterator(map, topVer)) {
                     long end = System.currentTimeMillis();
 
@@ -451,10 +467,16 @@ public void testHistoricalRebalanceIterator() throws Exception {
 
                     assertFalse(it.hasNext());
                 }
+                finally {
+                    GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading", null);
+                }
 
                 map = new IgniteDhtDemandedPartitionsMap();
                 map.addHistorical(1, i, entries, PARTS);
 
+                GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading",
+                    new FileWALPointer(0, 0, 0));
+
                 try (IgniteRebalanceIterator it = offh.rebalanceIterator(map, topVer)) {
                     assertNotNull(it);
 
@@ -471,6 +493,9 @@ public void testHistoricalRebalanceIterator() throws Exception {
 
                     assertFalse(it.hasNext());
                 }
+                finally {
+                    GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading", null);
+                }
             }
         }
         finally {
@@ -961,12 +986,18 @@ private List<CacheDataRow> rows(Ignite ignite, int part, long from, long to) thr
 
         List<CacheDataRow> rows = new ArrayList<>();
 
+        GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading",
+            new FileWALPointer(0, 0, 0));
+
         try (IgniteRebalanceIterator it = offh.rebalanceIterator(map, topVer)) {
             assertNotNull(it);
 
             while (it.hasNextX())
                 rows.add(it.next());
         }
+        finally {
+            GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading", null);
+        }
 
         return rows;
     }
diff --git a/modules/core/src/test/java/org/apache/ignite/platform/PlatformDeployServiceTask.java b/modules/core/src/test/java/org/apache/ignite/platform/PlatformDeployServiceTask.java
index 6986ae4e80bd..c781be8a1fdc 100644
--- a/modules/core/src/test/java/org/apache/ignite/platform/PlatformDeployServiceTask.java
+++ b/modules/core/src/test/java/org/apache/ignite/platform/PlatformDeployServiceTask.java
@@ -33,6 +33,7 @@
 import org.apache.ignite.compute.ComputeJobResult;
 import org.apache.ignite.compute.ComputeTaskAdapter;
 import org.apache.ignite.internal.util.typedef.F;
+import org.apache.ignite.internal.util.typedef.internal.U;
 import org.apache.ignite.resources.IgniteInstanceResource;
 import org.apache.ignite.services.Service;
 import org.apache.ignite.services.ServiceContext;
@@ -412,5 +413,15 @@ public BinaryObject testBinaryObject(BinaryObject o) {
 
             return o.toBuilder().setField("field", 15).build();
         }
+
+        /** */
+        public void sleep(long delayMs) {
+            try {
+                U.sleep(delayMs);
+            }
+            catch (Exception e) {
+                throw new IgniteException(e);
+            }
+        }
     }
 }
diff --git a/modules/core/src/test/java/org/apache/ignite/testsuites/IgnitePdsTestSuite4.java b/modules/core/src/test/java/org/apache/ignite/testsuites/IgnitePdsTestSuite4.java
index ee76c08bb84c..dfca7461eabd 100644
--- a/modules/core/src/test/java/org/apache/ignite/testsuites/IgnitePdsTestSuite4.java
+++ b/modules/core/src/test/java/org/apache/ignite/testsuites/IgnitePdsTestSuite4.java
@@ -30,6 +30,7 @@
 import org.apache.ignite.internal.processors.cache.IgniteClusterActivateDeactivateTestWithPersistenceAndMemoryReuse;
 import org.apache.ignite.internal.processors.cache.distributed.CachePageWriteLockUnlockTest;
 import org.apache.ignite.internal.processors.cache.distributed.rebalancing.IgniteRebalanceOnCachesStoppingOrDestroyingTest;
+import org.apache.ignite.internal.processors.cache.distributed.rebalancing.SupplyPartitionHistoricallyWithReorderedUpdates;
 import org.apache.ignite.internal.processors.cache.persistence.CorruptedTreeFailureHandlingTest;
 import org.apache.ignite.internal.processors.cache.persistence.IgnitePdsCacheEntriesExpirationTest;
 import org.apache.ignite.internal.processors.cache.persistence.IgnitePdsConsistencyOnDelayedPartitionOwning;
@@ -114,6 +115,7 @@ public static List<Class<?>> suite(Collection<Class> ignoredTests) {
         GridTestUtils.addTestIfNeeded(suite, IgnitePdsCacheEntriesExpirationTest.class, ignoredTests);
 
         GridTestUtils.addTestIfNeeded(suite, IgnitePdsConsistencyOnDelayedPartitionOwning.class, ignoredTests);
+        GridTestUtils.addTestIfNeeded(suite, SupplyPartitionHistoricallyWithReorderedUpdates.class, ignoredTests);
 
         // Warm-up tests.
         GridTestUtils.addTestIfNeeded(suite, WarmUpSelfTest.class, ignoredTests);
diff --git a/modules/gce/pom.xml b/modules/gce/pom.xml
index 47250614d108..9098569bb13e 100644
--- a/modules/gce/pom.xml
+++ b/modules/gce/pom.xml
@@ -44,7 +44,7 @@
         <dependency>
             <groupId>com.google.api-client</groupId>
             <artifactId>google-api-client</artifactId>
-            <version>1.22.0</version>
+            <version>1.30.10</version>
             <exclusions>
                 <exclusion>
                     <groupId>commons-codec</groupId>
diff --git a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/DurableBackgroundCleanupIndexTreeTask.java b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/DurableBackgroundCleanupIndexTreeTask.java
index ba40a8c8fa02..23e9af7d2ee8 100644
--- a/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/DurableBackgroundCleanupIndexTreeTask.java
+++ b/modules/indexing/src/main/java/org/apache/ignite/internal/processors/query/h2/DurableBackgroundCleanupIndexTreeTask.java
@@ -47,6 +47,9 @@ public class DurableBackgroundCleanupIndexTreeTask implements DurableBackgroundT
     /** */
     private transient List<H2Tree> trees;
 
+    /** */
+    private transient volatile boolean completed;
+
     /** */
     private String cacheGrpName;
 
@@ -73,6 +76,7 @@ public DurableBackgroundCleanupIndexTreeTask(
     ) {
         this.rootPages = rootPages;
         this.trees = trees;
+        this.completed = false;
         this.cacheGrpName = cacheGrpName;
         this.cacheName = cacheName;
         this.schemaName = schemaName;
@@ -167,6 +171,21 @@ public DurableBackgroundCleanupIndexTreeTask(
         }
     }
 
+    /** {@inheritDoc} */
+    @Override public void complete() {
+        completed = true;
+    }
+
+    /** {@inheritDoc} */
+    @Override public boolean isCompleted() {
+        return completed;
+    }
+
+    /** {@inheritDoc} */
+    @Override public void onCancel() {
+        trees = null;
+    }
+
     /** {@inheritDoc} */
     @Override public String toString() {
         return S.toString(DurableBackgroundCleanupIndexTreeTask.class, this);
diff --git a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/LongDestroyDurableBackgroundTaskTest.java b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/LongDestroyDurableBackgroundTaskTest.java
index c847031111cd..fe84b788423c 100644
--- a/modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/LongDestroyDurableBackgroundTaskTest.java
+++ b/modules/indexing/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/LongDestroyDurableBackgroundTaskTest.java
@@ -16,6 +16,7 @@
  */
 package org.apache.ignite.internal.processors.cache.persistence.db;
 
+import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Deque;
@@ -46,6 +47,12 @@
 import org.apache.ignite.internal.pagemem.PageMemory;
 import org.apache.ignite.internal.pagemem.wal.IgniteWriteAheadLogManager;
 import org.apache.ignite.internal.processors.cache.GridCacheContext;
+import org.apache.ignite.internal.processors.cache.GridCacheSharedContext;
+import org.apache.ignite.internal.processors.cache.persistence.DbCheckpointListener;
+import org.apache.ignite.internal.processors.cache.persistence.GridCacheDatabaseSharedManager;
+import org.apache.ignite.internal.processors.cache.persistence.metastorage.ReadOnlyMetastorage;
+import org.apache.ignite.internal.processors.cache.persistence.metastorage.ReadWriteMetastorage;
+import org.apache.ignite.internal.processors.cache.persistence.metastorage.pendingtask.DurableBackgroundTask;
 import org.apache.ignite.internal.processors.cache.persistence.tree.reuse.LongListReuseBag;
 import org.apache.ignite.internal.processors.cache.persistence.tree.reuse.ReuseList;
 import org.apache.ignite.internal.processors.failure.FailureProcessor;
@@ -143,6 +150,9 @@ public class LongDestroyDurableBackgroundTaskTest extends GridCommonAbstractTest
     /** */
     private H2TreeIndex.H2TreeFactory regularH2TreeFactory;
 
+    /** */
+    private DurableBackgroundTaskTestListener durableBackgroundTaskTestLsnr;
+
     /** */
     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
         return super.getConfiguration(igniteInstanceName)
@@ -189,6 +199,8 @@ public class LongDestroyDurableBackgroundTaskTest extends GridCommonAbstractTest
 
         cleanPersistenceDir();
 
+        durableBackgroundTaskTestLsnr = null;
+
         super.afterTest();
     }
 
@@ -217,7 +229,7 @@ private void testLongIndexDeletion(
 
         int nodeCnt = NODES_COUNT;
 
-        Ignite ignite = prepareAndPopulateCluster(nodeCnt, multicolumn);
+        Ignite ignite = prepareAndPopulateCluster(nodeCnt, multicolumn, false);
 
         Ignite aliveNode = grid(ALWAYS_ALIVE_NODE_NUM);
 
@@ -428,9 +440,18 @@ private List<List<?>> query(IgniteCache<Integer, Integer> cache, String qry, Obj
      * @return Ignite instance.
      * @throws Exception If failed.
      */
-    private IgniteEx prepareAndPopulateCluster(int nodeCnt, boolean multicolumn) throws Exception {
+    private IgniteEx prepareAndPopulateCluster(int nodeCnt, boolean multicolumn, boolean createLsnr) throws Exception {
         IgniteEx ignite = startGrids(nodeCnt);
 
+        if (createLsnr) {
+            GridCacheSharedContext ctx = ignite.context().cache().context();
+
+            durableBackgroundTaskTestLsnr = new DurableBackgroundTaskTestListener(ctx.database().metaStorage());
+
+            ((GridCacheDatabaseSharedManager) ctx.cache().context().database())
+                    .addCheckpointListener(durableBackgroundTaskTestLsnr);
+        }
+
         ignite.cluster().active(true);
 
         ignite.cluster().baselineAutoAdjustEnabled(false);
@@ -538,7 +559,7 @@ public void testLongIndexDeletionCheckWhenOneNodeStoppedAndDropIndex() throws Ex
     public void testDestroyTaskLifecycle() throws Exception {
         taskLifecycleListener.reset();
 
-        IgniteEx ignite = prepareAndPopulateCluster(1, false);
+        IgniteEx ignite = prepareAndPopulateCluster(1, false, false);
 
         IgniteCache<Integer, Integer> cache = ignite.cache(DEFAULT_CACHE_NAME);
 
@@ -563,6 +584,22 @@ public void testDestroyTaskLifecycle() throws Exception {
         assertTrue(taskLifecycleListener.check());
     }
 
+    /**
+     * Tests that task removed from metastorage in beginning of next checkpoint.
+     *
+     * @throws Exception If failed.
+     */
+    @Test
+    public void testIndexDeletionTaskRemovedAfterCheckpointFinished() throws Exception {
+        prepareAndPopulateCluster(1, false, true);
+
+        awaitLatch(pendingDelLatch, "Test timed out: failed to await for durable background task completion.");
+
+        forceCheckpoint();
+
+        assertTrue(durableBackgroundTaskTestLsnr.check());
+    }
+
     /**
      *
      */
@@ -677,4 +714,66 @@ public H2TreeTest(
             return super.destroyDownPages(bag, pageId, lvl, c, lockHoldStartTime, lockMaxTime, lockedPages);
         }
     }
+
+    /**
+     *
+     */
+    private class DurableBackgroundTaskTestListener implements DbCheckpointListener {
+        /**
+         * Prefix for metastorage keys for durable background tasks.
+         */
+        private static final String STORE_DURABLE_BACKGROUND_TASK_PREFIX = "durable-background-task-";
+
+        /**
+         * Metastorage.
+         */
+        private volatile ReadOnlyMetastorage metastorage;
+
+        /**
+         * Task keys in metastorage.
+         */
+        private List<String> savedTasks = new ArrayList<>();
+
+        /** */
+        public DurableBackgroundTaskTestListener(ReadWriteMetastorage metastorage) {
+            this.metastorage = metastorage;
+        }
+
+        /**
+         * Checks that saved tasks from before checkpoint begin step removed from metastorage.
+         * Сall after the end of the checkpoint.
+         *
+         * @return true if check is successful.
+         */
+        public boolean check() throws IgniteCheckedException {
+            if (savedTasks.isEmpty())
+                return false;
+
+            for (String taskKey : savedTasks) {
+                DurableBackgroundTask task = (DurableBackgroundTask)metastorage.read(taskKey);
+
+                if (task != null)
+                    return false;
+            }
+
+            return true;
+        }
+
+        /** {@inheritDoc} */
+        @Override public void onMarkCheckpointBegin(Context ctx) {
+            /* No op. */
+        }
+
+        /** {@inheritDoc} */
+        @Override public void onCheckpointBegin(Context ctx) {
+            /* No op. */
+        }
+
+        /** {@inheritDoc} */
+        @Override public void beforeCheckpointBegin(Context ctx) throws IgniteCheckedException {
+            metastorage.iterate(STORE_DURABLE_BACKGROUND_TASK_PREFIX,
+                    (key, val) -> savedTasks.add(key),
+                    true);
+        }
+    }
 }
diff --git a/modules/jms11/README.txt b/modules/jms11/README.txt
deleted file mode 100644
index 3f0d2134fc76..000000000000
--- a/modules/jms11/README.txt
+++ /dev/null
@@ -1,29 +0,0 @@
-Apache Ignite JMS 1.1 Module
-----------------------------
-
-Apache Ignite JMS 1.1 module provides a streamer to consume JMS queue and topic messages into
-Apache Ignite caches.
-
-Importing Apache Ignite JMS 1.1 Module In Maven Project
---------------------------------------------------------
-
-If you are using Maven to manage dependencies of your project, you can add the JMS 1.1 module
-dependency like this (replace '${ignite.version}' with actual Ignite version you are
-interested in):
-
-<project xmlns="http://maven.apache.org/POM/4.0.0"
-    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
-    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
-                        http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    ...
-    <dependencies>
-        ...
-        <dependency>
-            <groupId>org.apache.ignite</groupId>
-            <artifactId>ignite-jms11</artifactId>
-            <version>${ignite.version}</version>
-        </dependency>
-        ...
-    </dependencies>
-    ...
-</project>
diff --git a/modules/jms11/licenses/apache-2.0.txt b/modules/jms11/licenses/apache-2.0.txt
deleted file mode 100644
index d64569567334..000000000000
--- a/modules/jms11/licenses/apache-2.0.txt
+++ /dev/null
@@ -1,202 +0,0 @@
-
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
-   APPENDIX: How to apply the Apache License to your work.
-
-      To apply the Apache License to your work, attach the following
-      boilerplate notice, with the fields enclosed by brackets "[]"
-      replaced with your own identifying information. (Don't include
-      the brackets!)  The text should be enclosed in the appropriate
-      comment syntax for the file format. We also recommend that a
-      file or class name and description of purpose be included on the
-      same "printed page" as the copyright notice for easier
-      identification within third-party archives.
-
-   Copyright [yyyy] [name of copyright owner]
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-   You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
diff --git a/modules/jms11/pom.xml b/modules/jms11/pom.xml
deleted file mode 100644
index 8ef1005a1d1d..000000000000
--- a/modules/jms11/pom.xml
+++ /dev/null
@@ -1,104 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-
-<!--
-  Licensed to the Apache Software Foundation (ASF) under one or more
-  contributor license agreements.  See the NOTICE file distributed with
-  this work for additional information regarding copyright ownership.
-  The ASF licenses this file to You under the Apache License, Version 2.0
-  (the "License"); you may not use this file except in compliance with
-  the License.  You may obtain a copy of the License at
-
-       http://www.apache.org/licenses/LICENSE-2.0
-
-  Unless required by applicable law or agreed to in writing, software
-  distributed under the License is distributed on an "AS IS" BASIS,
-  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-  See the License for the specific language governing permissions and
-  limitations under the License.
--->
-
-<!--
-    POM file.
--->
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
-    <modelVersion>4.0.0</modelVersion>
-
-    <parent>
-        <groupId>org.apache.ignite</groupId>
-        <artifactId>ignite-parent</artifactId>
-        <version>1</version>
-        <relativePath>../../parent</relativePath>
-    </parent>
-
-    <artifactId>ignite-jms11</artifactId>
-    <version>2.10.0-SNAPSHOT</version>
-    <url>http://ignite.apache.org</url>
-
-    <dependencies>
-        <dependency>
-            <groupId>org.apache.ignite</groupId>
-            <artifactId>ignite-core</artifactId>
-            <version>${project.version}</version>
-        </dependency>
-
-        <dependency>
-            <groupId>org.apache.geronimo.specs</groupId>
-            <artifactId>geronimo-jms_1.1_spec</artifactId>
-            <version>${jms.spec.version}</version>
-        </dependency>
-
-        <dependency>
-            <groupId>org.apache.activemq</groupId>
-            <artifactId>activemq-client</artifactId>
-            <version>${activemq.version}</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.apache.activemq</groupId>
-            <artifactId>activemq-broker</artifactId>
-            <version>${activemq.version}</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.apache.ignite</groupId>
-            <artifactId>ignite-log4j</artifactId>
-            <version>${project.version}</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.apache.ignite</groupId>
-            <artifactId>ignite-spring</artifactId>
-            <version>${project.version}</version>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.apache.ignite</groupId>
-            <artifactId>ignite-core</artifactId>
-            <version>${project.version}</version>
-            <type>test-jar</type>
-            <scope>test</scope>
-        </dependency>
-
-        <dependency>
-            <groupId>org.apache.ignite</groupId>
-            <artifactId>ignite-tools</artifactId>
-            <version>${project.version}</version>
-            <scope>test</scope>
-        </dependency>
-    </dependencies>
-
-    <build>
-        <plugins>
-            <!-- Generate the OSGi MANIFEST.MF for this bundle. -->
-            <plugin>
-                <groupId>org.apache.felix</groupId>
-                <artifactId>maven-bundle-plugin</artifactId>
-            </plugin>
-        </plugins>
-    </build>
-
-</project>
diff --git a/modules/jms11/src/main/java/org/apache/ignite/stream/jms11/JmsStreamer.java b/modules/jms11/src/main/java/org/apache/ignite/stream/jms11/JmsStreamer.java
deleted file mode 100644
index 6e0ce64df01a..000000000000
--- a/modules/jms11/src/main/java/org/apache/ignite/stream/jms11/JmsStreamer.java
+++ /dev/null
@@ -1,565 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.ignite.stream.jms11;
-
-import java.util.Collections;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.Executor;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-import javax.jms.Connection;
-import javax.jms.ConnectionFactory;
-import javax.jms.Destination;
-import javax.jms.ExceptionListener;
-import javax.jms.JMSException;
-import javax.jms.Message;
-import javax.jms.MessageConsumer;
-import javax.jms.MessageListener;
-import javax.jms.Queue;
-import javax.jms.Session;
-import javax.jms.Topic;
-import org.apache.ignite.IgniteDataStreamer;
-import org.apache.ignite.IgniteException;
-import org.apache.ignite.IgniteLogger;
-import org.apache.ignite.internal.util.typedef.internal.A;
-import org.apache.ignite.internal.util.typedef.internal.U;
-import org.apache.ignite.stream.StreamAdapter;
-
-/**
- * Streamer that consumes from a JMS destination and feeds key-value pairs into an {@link IgniteDataStreamer} instance.
- * <p>
- * This Streamer uses purely JMS semantics and it is not coupled with any JMS implementation. It uses {@link
- * MessageListener} to receive messages. You must provide your broker's {@link javax.jms.ConnectionFactory} when
- * creating a {@link JmsStreamer}.
- * <p>
- * You must also provide a {@link MessageTransformer} to convert the incoming message into cache entries.
- * <p>
- * This Streamer has many features:
- *
- * <ul>
- *     <li>Consumes from queues or topics.</li>
- *     <li>For topics, it supports durable subscriptions.</li>
- *     <li>Concurrent consumers are supported via the <tt>threads</tt> parameter. When consuming from queues,
- *     this component will start as many {@link Session} objects with separate {@link MessageListener} instances each,
- *     therefore achieving <i>native</i> concurrency (in terms of the JMS standard).<br>
- *     When consuming from topics, obviously we cannot start multiple threads as that would lead us to consume
- *     duplicate messages. Therefore, we achieve concurrency in a <i>virtualized</i> manner through an internal
- *     thread pool.</li>
- *     <li>Transacted sessions are supported through the <tt>transacted</tt> parameter.</li>
- *     <li>Batched consumption is possible via the <tt>batched</tt> parameter. Depending on the broker, this
- *     technique can provide a higher throughput as it decreases the amount of message acknowledgement round trips
- *     that are necessary, albeit at the expense possible duplicate messages (especially if an incident
- *     occurs in the middle of a transaction).<br>
- *     Batches are committed when the <tt>batchClosureMillis</tt> time has elapsed, or when a Session has received
- *     at least <tt>batchClosureSize</tt> messages. Time-based closure fires with the specified frequency and applies to
- *     all {@link Session}s in parallel. Size-based closure applies individually to each <tt>Session</tt> (as transactions
- *     are <tt>Session-bound</tt> in JMS, so it will fire when that {@link Session} has processed that many messages.
- *     Both options are compatible with each other, or you can disable either (see setter documentation),
- *     but not both.</li>
- *     <li>Can specify the destination with implementation-specific {@link Destination} objects or with names.</li>
- * </ul>
-
- *
- * @author Raul Kripalani
- */
-public class JmsStreamer<T extends Message, K, V> extends StreamAdapter<T, K, V> {
-
-    /** Logger. */
-    private IgniteLogger log;
-
-    /**
-     * <i>Compulsory.</i> The message transformer that converts an incoming JMS {@link Message} (or subclass) into one
-     * or multiple cache entries.
-     */
-    private MessageTransformer<T, K, V> transformer;
-
-    /** The JMS {@link ConnectionFactory} to use. */
-    private ConnectionFactory connectionFactory;
-
-    /** Whether to register or not as a durable subscription (for topic consumption). */
-    private boolean durableSubscription;
-
-    /** Name of the durable subscription, as required by the JMS specification. */
-    private String durableSubscriptionName;
-
-    /** Client ID in case we're using durable subscribers. */
-    private String clientId;
-
-    /** The JMS {@link Destination}; takes precedence over destinationName if both are set. */
-    private Destination destination;
-
-    /** Name of the destination. */
-    private String destinationName;
-
-    /** Whether to consume in a transacted manner. */
-    private boolean transacted;
-
-    /** Whether to consume messages in batches. May lead to duplicate consumption. Value <tt>true</tt> implies
-     * <tt>transacted = true</tt>. */
-    private boolean batched;
-
-    /** When using batched consumers, the amount of messages after the batch (transaction) will be committed. */
-    private int batchClosureSize = 50;
-
-    /**
-     * When using batched consumers, the amount of time to wait before the batch (transaction) will be committed. A
-     * value of 0 or -1 disables timed-based session commits.
-     */
-    private long batchClosureMillis = 1000;
-
-    /** Destination type. */
-    private Class<? extends Destination> destinationType = Queue.class;
-
-    /**
-     * Number of threads to concurrently consume JMS messages. When working with queues, we will start as many {@link
-     * javax.jms.Session} objects as indicated by this field, i.e. you will get native concurrency. On the other hand,
-     * when consuming from a topic, for obvious reason we will only start 1 message consumer but we will distribute the
-     * processing of received messages to as many concurrent threads as indicated.
-     */
-    private int threads = 1;
-
-    /** Whether we are stopped or not. */
-    private volatile boolean stopped = true;
-
-    /** JMS Connection. */
-    private Connection connection;
-
-    /** Stores the current JMS Sessions. */
-    private Set<Session> sessions = Collections.newSetFromMap(new ConcurrentHashMap<Session, Boolean>());
-
-    /** Message consumers. */
-    private Set<MessageConsumer> consumers = Collections.newSetFromMap(new ConcurrentHashMap<MessageConsumer, Boolean>());
-
-    /** Message listeners. */
-    private Set<IgniteJmsMessageListener> listeners = Collections.newSetFromMap(new ConcurrentHashMap<IgniteJmsMessageListener, Boolean>());
-
-    /** The Jms {@link ExceptionListener} to use. */
-    private ExceptionListener exceptionListener;
-
-    /** Scheduler for handling {@link #batchClosureMillis}. */
-    private ScheduledExecutorService scheduler;
-
-    /**
-     * Starts streamer.
-     *
-     * @throws IgniteException If failed.
-     */
-    public void start() throws IgniteException {
-        if (!stopped)
-            throw new IgniteException("Attempted to start an already started JMS Streamer");
-
-        try {
-            A.notNull(getStreamer(), "streamer");
-            A.notNull(getIgnite(), "ignite");
-
-            log = getIgnite().log();
-
-            A.notNull(transformer, "message transformer");
-            A.notNull(connectionFactory, "connection factory");
-            A.ensure(threads > 0, "threads > 0");
-
-            // handle batched && transacted parameter interaction
-            if (batched && !transacted) {
-                log.warning("Starting a Batched JMS Streamer without transacted flag = true. Setting it automatically.");
-                transacted = true;
-            }
-
-            // handle batch completion criteria
-            if (batched) {
-                A.ensure(batchClosureMillis > 0 || batchClosureSize > 0, "at least one of batch closure size or " +
-                    "batch closure frequency must be specified when using batch consumption");
-            }
-
-            // check the parameters needed for durable subscriptions, if enabled
-            if (durableSubscription) {
-                A.notNullOrEmpty(clientId, "client id is compulsory when using durable subscriptions");
-                A.notNullOrEmpty(durableSubscriptionName, "durable subscription name is compulsory when using " +
-                    "durable subscriptions");
-            }
-
-            // validate the destination; if we have an explicit destination, make sure it's of type Queue or Topic;
-            // else make sure that the destinationName and the destinationType are valid
-            if (destination == null) {
-                A.notNull(destinationType, "destination type");
-                A.ensure(destinationType.isAssignableFrom(Queue.class) || destinationType.isAssignableFrom(Topic.class),
-                    "this streamer can only handle Queues or Topics.");
-                A.notNullOrEmpty(destinationName, "destination or destination name");
-            }
-            else if (destination instanceof Queue) {
-                destinationType = Queue.class;
-            }
-            else if (destination instanceof Topic) {
-                destinationType = Topic.class;
-            }
-            else {
-                throw new IllegalArgumentException("Invalid destination object. Can only handle Queues or Topics.");
-            }
-
-            // create a new connection and the client iD if relevant.
-            connection = connectionFactory.createConnection();
-            if (clientId != null && clientId.trim().length() > 0) {
-                connection.setClientID(clientId.trim());
-            }
-
-            connection.setExceptionListener(new IgniteJmsExceptionListener());
-
-            // build the JMS objects
-            if (destinationType == Queue.class) {
-                initializeJmsObjectsForQueue();
-            }
-            else {
-                initializeJmsObjectsForTopic();
-            }
-
-            stopped = false;
-
-            // start the JMS connection
-            connection.start();
-
-            // set up the scheduler service for committing batches
-            if (batched && batchClosureMillis > 0) {
-                scheduler = Executors.newScheduledThreadPool(1);
-                scheduler.schedule(new Runnable() {
-                    @Override public void run() {
-                        for (Session session : sessions) {
-                            try {
-                                session.commit();
-                                if (log.isDebugEnabled()) {
-                                    log.debug("Committing session from time-based batch completion [session=" +
-                                        session + "]");
-                                }
-                            }
-                            catch (JMSException ignored) {
-                                log.warning("Error while committing session: from batch time-based completion " +
-                                    "[session=" + session + "]");
-                            }
-                        }
-                        for (IgniteJmsMessageListener ml : listeners) {
-                            ml.resetBatchCounter();
-                        }
-                    }
-                }, batchClosureMillis, TimeUnit.MILLISECONDS);
-            }
-
-        }
-        catch (Throwable t) {
-            throw new IgniteException("Exception while initializing JmsStreamer", t);
-        }
-
-    }
-
-    /**
-     * Stops streamer.
-     */
-    public void stop() throws IgniteException {
-        if (stopped)
-            throw new IgniteException("Attempted to stop an already stopped JMS Streamer");
-
-        try {
-            stopped = true;
-
-            if (scheduler != null && !scheduler.isShutdown()) {
-                scheduler.shutdown();
-                scheduler = null;
-            }
-
-            connection.stop();
-            connection.close();
-
-            for (Session s : sessions) {
-                s.close();
-            }
-
-            sessions.clear();
-            consumers.clear();
-            listeners.clear();
-        }
-        catch (Throwable t) {
-            throw new IgniteException("Exception while stopping JmsStreamer", t);
-        }
-    }
-
-    /**
-     * Sets the JMS {@link ConnectionFactory}.
-     *
-     * @param connectionFactory JMS {@link ConnectionFactory} for this streamer to use.
-     */
-    public void setConnectionFactory(ConnectionFactory connectionFactory) {
-        this.connectionFactory = connectionFactory;
-    }
-
-    /**
-     * <i>Compulsory.</i> The {@link MessageTransformer} that converts an incoming JMS {@link Message} (or subclass)
-     * into one or multiple cache entries.
-     *
-     * @param transformer The implementation of the MessageTransformer to use.
-     */
-    public void setTransformer(MessageTransformer<T, K, V> transformer) {
-        this.transformer = transformer;
-    }
-
-    /**
-     * Sets the JMS {@link Destination} explicitly. Takes precedence over destinationName if both are set.
-     *
-     * @param destination JMS {@link Destination} if setting it explicitly.
-     */
-    public void setDestination(Destination destination) {
-        this.destination = destination;
-    }
-
-    /**
-     * Sets the name of the JMS destination to consume from.
-     *
-     * @param destinationName The name of the destination; will be passed on directly to the broker.
-     */
-    public void setDestinationName(String destinationName) {
-        this.destinationName = destinationName;
-    }
-
-    /**
-     * Sets the type of the destination to create, when used in combination with {@link #setDestinationName(String)}. It
-     * can be an interface or the implementation class specific to the broker.
-     *
-     * @param destinationType The class representing the destination type. Suggested values: {@link Queue} or {@link
-     * Topic}. <i>Compulsory</i> if using {@link #destinationName}.
-     * @see Queue
-     * @see Topic
-     */
-    public void setDestinationType(Class<? extends Destination> destinationType) {
-        this.destinationType = destinationType;
-    }
-
-    /**
-     * Sets the number of threads to concurrently consume JMS messages. <p> When working with queues, we will start as
-     * many {@link javax.jms.Session} objects as indicated by this field, i.e. you will get native concurrency. <p> On
-     * the other hand, when consuming from a topic, for obvious reason we will only start 1 message consumer but we will
-     * distribute the processing of received messages to as many concurrent threads as indicated.
-     *
-     * @param threads Number of threads to use. Default: <tt>1</tt>.
-     */
-    public void setThreads(int threads) {
-        this.threads = threads;
-    }
-
-    /**
-     * Sets the client ID of the JMS {@link Connection}.
-     *
-     * @param clientId Client ID in case we're using durable subscribers. Default: none.
-     */
-    public void setClientId(String clientId) {
-        this.clientId = clientId;
-    }
-
-    /**
-     * A <tt>true</tt> value is only accepted in combination with topic consumption.
-     *
-     * @param durableSubscription Whether or not to use durable subscriptions. Default: <tt>false</tt>.
-     */
-    public void setDurableSubscription(boolean durableSubscription) {
-        this.durableSubscription = durableSubscription;
-    }
-
-    /**
-     * Instructs the streamer whether to use local JMS transactions or not.
-     *
-     * @param transacted Whether to consume or not in a transacted manner. Default: <tt>false</tt>.
-     */
-    public void setTransacted(boolean transacted) {
-        this.transacted = transacted;
-    }
-
-    /**
-     * Batch consumption leverages JMS Transactions to minimise round trips to the broker. <p> Rather than ACKing every
-     * single message received, they will be received in the context of a JMS transaction which will be committed once
-     * the indicated batch closure size or batch closure time has elapsed. <p> Warning: May lead to duplicate
-     * consumption.
-     *
-     * @param batched Whether to consume messages in batches. Value <tt>true</tt> implies <tt>transacted = true</tt>.
-     * Default: <tt>false</tt>.
-     * @see #setBatchClosureMillis(long)
-     * @see #setBatchClosureSize(int)
-     */
-    public void setBatched(boolean batched) {
-        this.batched = batched;
-    }
-
-    /**
-     * When using batched consumption, sets the amount of messages that will be received before a batch is committed.
-     *
-     * @param batchClosureSize The amount of messages processed before a batch is committed. Default: <tt>50</tt>.
-     */
-    public void setBatchClosureSize(int batchClosureSize) {
-        this.batchClosureSize = batchClosureSize;
-    }
-
-    /**
-     * When using batched consumption, sets the time in milliseconds that will elapse before a batch is committed.
-     *
-     * @param batchClosureMillis Milliseconds before a batch is committed. Default: <tt>1000ms</tt>.
-     */
-    public void setBatchClosureMillis(long batchClosureMillis) {
-        this.batchClosureMillis = batchClosureMillis;
-    }
-
-    /**
-     * When using Durable Subscribers, sets the name of the durable subscriber. It is compulsory.
-     *
-     * @param durableSubscriptionName Name of the durable subscriber. Default: none.
-     */
-    public void setDurableSubscriptionName(String durableSubscriptionName) {
-        this.durableSubscriptionName = durableSubscriptionName;
-    }
-
-    /**
-     * Exception listener for queue/topic failures.
-     *
-     * @param exceptionListener ExceptionListener interface implementation.
-     */
-    public void setExceptionListener(ExceptionListener exceptionListener) {
-        this.exceptionListener = exceptionListener;
-    }
-
-    private void initializeJmsObjectsForTopic() throws JMSException {
-        Session session = connection.createSession(transacted, Session.AUTO_ACKNOWLEDGE);
-        Topic topic = (Topic)destination;
-
-        if (destination == null)
-            topic = session.createTopic(destinationName);
-
-        MessageConsumer consumer = durableSubscription ? session.createDurableSubscriber(topic, durableSubscriptionName) :
-            session.createConsumer(topic);
-
-        IgniteJmsMessageListener messageListener = new IgniteJmsMessageListener(session, true);
-        consumer.setMessageListener(messageListener);
-
-        consumers.add(consumer);
-        sessions.add(session);
-        listeners.add(messageListener);
-    }
-
-    private void initializeJmsObjectsForQueue() throws JMSException {
-        for (int i = 0; i < threads; i++) {
-            Session session = connection.createSession(transacted, Session.AUTO_ACKNOWLEDGE);
-
-            if (destination == null)
-                destination = session.createQueue(destinationName);
-
-            MessageConsumer consumer = session.createConsumer(destination);
-
-            IgniteJmsMessageListener messageListener = new IgniteJmsMessageListener(session, false);
-            consumer.setMessageListener(messageListener);
-
-            consumers.add(consumer);
-            sessions.add(session);
-            listeners.add(messageListener);
-        }
-    }
-
-    private void processMessage(T message) {
-        final IgniteDataStreamer<K, V> streamer = getStreamer();
-
-        Map<K, V> entries = transformer.apply(message);
-
-        if (entries == null || entries.size() == 0)
-            return;
-
-        streamer.addData(entries);
-    }
-
-    /**
-     * Message listener for queues.
-     */
-    private class IgniteJmsMessageListener implements MessageListener {
-
-        private Session session;
-
-        private AtomicInteger counter = new AtomicInteger(0);
-
-        private Executor executor;
-
-        public IgniteJmsMessageListener(Session session, boolean createThreadPool) {
-            this.session = session;
-
-            // if we don't need a thread pool, create a dummy one that executes the task synchronously
-            //noinspection NullableProblems
-            this.executor = createThreadPool ? Executors.newFixedThreadPool(threads) : new Executor() {
-                @Override public void execute(Runnable command) {
-                    command.run();
-                }
-            };
-        }
-
-        @Override public void onMessage(final Message message) {
-            if (stopped) {
-                return;
-            }
-
-            executor.execute(new Runnable() {
-                @Override @SuppressWarnings("unchecked")
-                public void run() {
-                    processMessage((T)message);
-                    if (batched) {
-                        // batch completion may be handled by timer only
-                        if (batchClosureSize <= 0)
-                            return;
-
-                        else if (counter.incrementAndGet() >= batchClosureSize) {
-                            try {
-                                session.commit();
-                                counter.set(0);
-                            }
-                            catch (Exception e) {
-                                log.warning("Could not commit JMS session upon completion of batch.", e);
-                            }
-                        }
-                    }
-                    else if (transacted) {
-                        try {
-                            session.commit();
-                        }
-                        catch (JMSException e) {
-                            log.warning("Could not commit JMS session (non-batched).", e);
-                        }
-                    }
-                }
-            });
-
-        }
-
-        public void resetBatchCounter() {
-            counter.set(0);
-        }
-    }
-
-    /**
-     * Exception listener for JmsExceptions.
-     */
-    private class IgniteJmsExceptionListener implements ExceptionListener {
-        /** {@inheritDoc} */
-        @Override public void onException(JMSException e) {
-            U.error(log, "Caught JMS internal exception.", e);
-
-            if (exceptionListener != null)
-                exceptionListener.onException(e);
-        }
-    }
-}
diff --git a/modules/jms11/src/main/java/org/apache/ignite/stream/jms11/package-info.java b/modules/jms11/src/main/java/org/apache/ignite/stream/jms11/package-info.java
deleted file mode 100644
index 52aa97bd36b5..000000000000
--- a/modules/jms11/src/main/java/org/apache/ignite/stream/jms11/package-info.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-/**
- * Contains implementation of JMS queue and topic messages consumer.
- */
-
-package org.apache.ignite.stream.jms11;
diff --git a/modules/jms11/src/test/java/org/apache/ignite/stream/jms11/IgniteJmsStreamerTest.java b/modules/jms11/src/test/java/org/apache/ignite/stream/jms11/IgniteJmsStreamerTest.java
deleted file mode 100644
index ff33d09d5f95..000000000000
--- a/modules/jms11/src/test/java/org/apache/ignite/stream/jms11/IgniteJmsStreamerTest.java
+++ /dev/null
@@ -1,708 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.ignite.stream.jms11;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
-import java.util.concurrent.Callable;
-import java.util.concurrent.CountDownLatch;
-import java.util.concurrent.TimeUnit;
-import javax.jms.ConnectionFactory;
-import javax.jms.Destination;
-import javax.jms.ExceptionListener;
-import javax.jms.JMSException;
-import javax.jms.Message;
-import javax.jms.MessageProducer;
-import javax.jms.ObjectMessage;
-import javax.jms.Queue;
-import javax.jms.Session;
-import javax.jms.TextMessage;
-import javax.jms.Topic;
-import org.apache.activemq.ActiveMQConnectionFactory;
-import org.apache.activemq.broker.BrokerPlugin;
-import org.apache.activemq.broker.BrokerRegistry;
-import org.apache.activemq.broker.BrokerService;
-import org.apache.activemq.broker.region.DestinationStatistics;
-import org.apache.activemq.broker.region.Subscription;
-import org.apache.activemq.broker.region.policy.PolicyEntry;
-import org.apache.activemq.broker.region.policy.PolicyMap;
-import org.apache.activemq.command.ActiveMQQueue;
-import org.apache.activemq.command.ActiveMQTopic;
-import org.apache.activemq.security.SimpleAuthenticationPlugin;
-import org.apache.ignite.Ignite;
-import org.apache.ignite.IgniteCache;
-import org.apache.ignite.IgniteDataStreamer;
-import org.apache.ignite.IgniteException;
-import org.apache.ignite.events.CacheEvent;
-import org.apache.ignite.lang.IgniteBiPredicate;
-import org.apache.ignite.testframework.GridTestUtils;
-import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
-import org.junit.Test;
-
-import static org.apache.ignite.events.EventType.EVT_CACHE_OBJECT_PUT;
-
-/**
- * Test for {@link JmsStreamer}. Tests both queues and topics.
- *
- * @author Raul Kripalani
- */
-public class IgniteJmsStreamerTest extends GridCommonAbstractTest {
-    /** */
-    private static final int CACHE_ENTRY_COUNT = 100;
-
-    /** */
-    private static final String QUEUE_NAME = "ignite.test.queue";
-
-    /** */
-    private static final String TOPIC_NAME = "ignite.test.topic";
-
-    /** */
-    private static final Map<String, String> TEST_DATA = new HashMap<>();
-
-    static {
-        for (int i = 1; i <= CACHE_ENTRY_COUNT; i++)
-            TEST_DATA.put(Integer.toString(i), "v" + i);
-    }
-
-    /** */
-    private BrokerService broker;
-
-    /** */
-    private ConnectionFactory connFactory;
-
-    /** Constructor. */
-    public IgniteJmsStreamerTest() {
-        super(true);
-    }
-
-    /**
-     * @throws Exception If failed.
-     */
-    @SuppressWarnings("unchecked")
-    @Override public void beforeTest() throws Exception {
-        grid().<Integer, String>getOrCreateCache(defaultCacheConfiguration());
-
-        broker = new BrokerService();
-        broker.setDeleteAllMessagesOnStartup(true);
-        broker.setPersistent(false);
-        broker.setPersistenceAdapter(null);
-        broker.setPersistenceFactory(null);
-
-        PolicyMap plcMap = new PolicyMap();
-        PolicyEntry plc = new PolicyEntry();
-
-        plc.setQueuePrefetch(1);
-
-        broker.setDestinationPolicy(plcMap);
-        broker.getDestinationPolicy().setDefaultEntry(plc);
-        broker.setSchedulerSupport(false);
-
-        broker.start(true);
-
-        connFactory = new ActiveMQConnectionFactory(BrokerRegistry.getInstance().findFirst().getVmConnectorURI());
-    }
-
-    /**
-     * @throws Exception Iff ailed.
-     */
-    @Override public void afterTest() throws Exception {
-        grid().cache(DEFAULT_CACHE_NAME).clear();
-
-        broker.stop();
-        broker.deleteAllMessages();
-    }
-
-    /**
-     * @throws Exception If failed.
-     */
-    @Test
-    public void testQueueFromName() throws Exception {
-        Destination dest = new ActiveMQQueue(QUEUE_NAME);
-
-        // produce messages into the queue
-        produceObjectMessages(dest, false);
-
-        try (IgniteDataStreamer<String, String> dataStreamer = grid().dataStreamer(DEFAULT_CACHE_NAME)) {
-            JmsStreamer<ObjectMessage, String, String> jmsStreamer = newJmsStreamer(ObjectMessage.class, dataStreamer);
-            jmsStreamer.setDestinationType(Queue.class);
-            jmsStreamer.setDestinationName(QUEUE_NAME);
-
-            // subscribe to cache PUT events and return a countdown latch starting at CACHE_ENTRY_COUNT
-            CountDownLatch latch = subscribeToPutEvents(CACHE_ENTRY_COUNT);
-
-            jmsStreamer.start();
-
-            // all cache PUT events received in 10 seconds
-            latch.await(10, TimeUnit.SECONDS);
-
-            assertAllCacheEntriesLoaded();
-
-            jmsStreamer.stop();
-        }
-
-    }
-
-    /**
-     * @throws Exception If failed.
-     */
-    @Test
-    public void testTopicFromName() throws JMSException, InterruptedException {
-        Destination dest = new ActiveMQTopic(TOPIC_NAME);
-
-        // should not produced messages until subscribed to the topic; otherwise they will be missed because this is not
-        // a durable subscriber (for which a dedicated test exists)
-
-        try (IgniteDataStreamer<String, String> dataStreamer = grid().dataStreamer(DEFAULT_CACHE_NAME)) {
-            JmsStreamer<ObjectMessage, String, String> jmsStreamer = newJmsStreamer(ObjectMessage.class, dataStreamer);
-            jmsStreamer.setDestinationType(Topic.class);
-            jmsStreamer.setDestinationName(TOPIC_NAME);
-
-            // subscribe to cache PUT events and return a countdown latch starting at CACHE_ENTRY_COUNT
-            CountDownLatch latch = subscribeToPutEvents(CACHE_ENTRY_COUNT);
-
-            jmsStreamer.start();
-
-            // produce messages
-            produceObjectMessages(dest, false);
-
-            // all cache PUT events received in 10 seconds
-            latch.await(10, TimeUnit.SECONDS);
-
-            assertAllCacheEntriesLoaded();
-
-            jmsStreamer.stop();
-        }
-
-    }
-
-    /**
-     * @throws Exception If failed.
-     */
-    @Test
-    public void testQueueFromExplicitDestination() throws Exception {
-        Destination dest = new ActiveMQQueue(QUEUE_NAME);
-
-        // produce messages into the queue
-        produceObjectMessages(dest, false);
-
-        try (IgniteDataStreamer<String, String> dataStreamer = grid().dataStreamer(DEFAULT_CACHE_NAME)) {
-            JmsStreamer<ObjectMessage, String, String> jmsStreamer = newJmsStreamer(ObjectMessage.class, dataStreamer);
-            jmsStreamer.setDestination(dest);
-
-            // subscribe to cache PUT events and return a countdown latch starting at CACHE_ENTRY_COUNT
-            CountDownLatch latch = subscribeToPutEvents(CACHE_ENTRY_COUNT);
-
-            // start the streamer
-            jmsStreamer.start();
-
-            // all cache PUT events received in 10 seconds
-            latch.await(10, TimeUnit.SECONDS);
-
-            assertAllCacheEntriesLoaded();
-
-            jmsStreamer.stop();
-        }
-
-    }
-
-    /**
-     * @throws Exception If failed.
-     */
-    @Test
-    public void testTopicFromExplicitDestination() throws JMSException, InterruptedException {
-        Destination dest = new ActiveMQTopic(TOPIC_NAME);
-
-        // should not produced messages until subscribed to the topic; otherwise they will be missed because this is not
-        // a durable subscriber (for which a dedicated test exists)
-
-        try (IgniteDataStreamer<String, String> dataStreamer = grid().dataStreamer(DEFAULT_CACHE_NAME)) {
-            JmsStreamer<ObjectMessage, String, String> jmsStreamer = newJmsStreamer(ObjectMessage.class, dataStreamer);
-            jmsStreamer.setDestination(dest);
-
-            // subscribe to cache PUT events and return a countdown latch starting at CACHE_ENTRY_COUNT
-            CountDownLatch latch = subscribeToPutEvents(CACHE_ENTRY_COUNT);
-
-            jmsStreamer.start();
-
-            // produce messages
-            produceObjectMessages(dest, false);
-
-            // all cache PUT events received in 10 seconds
-            latch.await(10, TimeUnit.SECONDS);
-
-            assertAllCacheEntriesLoaded();
-
-            jmsStreamer.stop();
-        }
-
-    }
-
-    /**
-     * @throws Exception If failed.
-     */
-    @Test
-    public void testInsertMultipleCacheEntriesFromOneMessage() throws Exception {
-        Destination dest = new ActiveMQQueue(QUEUE_NAME);
-
-        // produce A SINGLE MESSAGE, containing all data, into the queue
-        produceStringMessages(dest, true);
-
-        try (IgniteDataStreamer<String, String> dataStreamer = grid().dataStreamer(DEFAULT_CACHE_NAME)) {
-            JmsStreamer<TextMessage, String, String> jmsStreamer = newJmsStreamer(TextMessage.class, dataStreamer);
-            jmsStreamer.setDestination(dest);
-
-            // subscribe to cache PUT events and return a countdown latch starting at CACHE_ENTRY_COUNT
-            CountDownLatch latch = subscribeToPutEvents(CACHE_ENTRY_COUNT);
-
-            jmsStreamer.start();
-
-            // all cache PUT events received in 10 seconds
-            latch.await(10, TimeUnit.SECONDS);
-
-            assertAllCacheEntriesLoaded();
-
-            jmsStreamer.stop();
-        }
-
-    }
-
-    /**
-     * @throws Exception If failed.
-     */
-    @Test
-    public void testDurableSubscriberStartStopStart() throws Exception {
-        Destination dest = new ActiveMQTopic(TOPIC_NAME);
-
-        try (IgniteDataStreamer<String, String> dataStreamer = grid().dataStreamer(DEFAULT_CACHE_NAME)) {
-            JmsStreamer<TextMessage, String, String> jmsStreamer = newJmsStreamer(TextMessage.class, dataStreamer);
-            jmsStreamer.setDestination(dest);
-            jmsStreamer.setDurableSubscription(true);
-            jmsStreamer.setClientId(Long.toString(System.currentTimeMillis()));
-            jmsStreamer.setDurableSubscriptionName("ignite-test-durable");
-
-            // we start the streamer so that the durable subscriber registers itself
-            jmsStreamer.start();
-
-            // we stop it immediately
-            jmsStreamer.stop();
-
-            // we assert that there are no clients of the broker (to make sure we disconnected properly)
-            assertEquals(0, broker.getCurrentConnections());
-
-            // we send messages while we're still away
-            produceStringMessages(dest, false);
-
-            // subscribe to cache PUT events and return a countdown latch starting at CACHE_ENTRY_COUNT
-            CountDownLatch latch = subscribeToPutEvents(CACHE_ENTRY_COUNT);
-
-            jmsStreamer.start();
-
-            // all cache PUT events received in 10 seconds
-            latch.await(10, TimeUnit.SECONDS);
-
-            assertAllCacheEntriesLoaded();
-
-            jmsStreamer.stop();
-        }
-
-    }
-
-    /**
-     * @throws Exception If failed.
-     */
-    @Test
-    public void testQueueMessagesConsumedInBatchesCompletionSizeBased() throws Exception {
-        Destination dest = new ActiveMQQueue(QUEUE_NAME);
-
-        // produce multiple messages into the queue
-        produceStringMessages(dest, false);
-
-        try (IgniteDataStreamer<String, String> dataStreamer = grid().dataStreamer(DEFAULT_CACHE_NAME)) {
-            JmsStreamer<TextMessage, String, String> jmsStreamer = newJmsStreamer(TextMessage.class, dataStreamer);
-            jmsStreamer.setDestination(dest);
-            jmsStreamer.setBatched(true);
-            jmsStreamer.setBatchClosureSize(99);
-
-            // disable time-based session commits
-            jmsStreamer.setBatchClosureMillis(0);
-
-            // subscribe to cache PUT events and return a countdown latch starting at CACHE_ENTRY_COUNT
-            CountDownLatch latch = subscribeToPutEvents(CACHE_ENTRY_COUNT);
-
-            jmsStreamer.start();
-
-            // all cache PUT events received in 10 seconds
-            latch.await(10, TimeUnit.SECONDS);
-
-            assertAllCacheEntriesLoaded();
-
-            // we expect all entries to be loaded, but still one (uncommitted) message should remain in the queue
-            // as observed by the broker
-            DestinationStatistics qStats = broker.getBroker().getDestinationMap().get(dest).getDestinationStatistics();
-            assertEquals(1, qStats.getMessages().getCount());
-            assertEquals(1, qStats.getInflight().getCount());
-
-            jmsStreamer.stop();
-        }
-
-    }
-
-    /**
-     * @throws Exception If failed.
-     */
-    @Test
-    public void testQueueMessagesConsumedInBatchesCompletionTimeBased() throws Exception {
-        Destination dest = new ActiveMQQueue(QUEUE_NAME);
-
-        // produce multiple messages into the queue
-        produceStringMessages(dest, false);
-
-        try (IgniteDataStreamer<String, String> dataStreamer = grid().dataStreamer(DEFAULT_CACHE_NAME)) {
-            JmsStreamer<TextMessage, String, String> jmsStreamer = newJmsStreamer(TextMessage.class, dataStreamer);
-            jmsStreamer.setDestination(dest);
-            jmsStreamer.setBatched(true);
-            jmsStreamer.setBatchClosureMillis(2000);
-            // disable size-based session commits
-            jmsStreamer.setBatchClosureSize(0);
-
-            // subscribe to cache PUT events and return a countdown latch starting at CACHE_ENTRY_COUNT
-            CountDownLatch latch = subscribeToPutEvents(CACHE_ENTRY_COUNT);
-            DestinationStatistics qStats = broker.getBroker().getDestinationMap().get(dest).getDestinationStatistics();
-
-            jmsStreamer.start();
-
-            // all messages are still inflight
-            assertEquals(CACHE_ENTRY_COUNT, qStats.getMessages().getCount());
-            assertEquals(0, qStats.getDequeues().getCount());
-
-            // wait a little bit
-            Thread.sleep(100);
-
-            // all messages are still inflight
-            assertEquals(CACHE_ENTRY_COUNT, qStats.getMessages().getCount());
-            assertEquals(0, qStats.getDequeues().getCount());
-
-            // now let the scheduler execute
-            Thread.sleep(2100);
-
-            // all messages are committed
-            assertEquals(0, qStats.getMessages().getCount());
-            assertEquals(CACHE_ENTRY_COUNT, qStats.getDequeues().getCount());
-
-            latch.await(5, TimeUnit.SECONDS);
-
-            assertAllCacheEntriesLoaded();
-
-            jmsStreamer.stop();
-        }
-
-    }
-
-    /**
-     * @throws Exception If failed.
-     */
-    @Test
-    public void testGenerateNoEntries() throws Exception {
-        Destination dest = new ActiveMQQueue(QUEUE_NAME);
-
-        // produce multiple messages into the queue
-        produceStringMessages(dest, false);
-
-        try (IgniteDataStreamer<String, String> dataStreamer = grid().dataStreamer(DEFAULT_CACHE_NAME)) {
-            JmsStreamer<TextMessage, String, String> jmsStreamer = newJmsStreamer(TextMessage.class, dataStreamer);
-            // override the transformer with one that generates no cache entries
-            jmsStreamer.setTransformer(TestTransformers.generateNoEntries());
-            jmsStreamer.setDestination(dest);
-
-            // subscribe to cache PUT events and return a countdown latch starting at CACHE_ENTRY_COUNT
-            CountDownLatch latch = subscribeToPutEvents(1);
-
-            jmsStreamer.start();
-
-            // no cache PUT events were received in 3 seconds, i.e. CountDownLatch does not fire
-            assertFalse(latch.await(3, TimeUnit.SECONDS));
-
-            jmsStreamer.stop();
-        }
-
-    }
-
-    /**
-     * @throws Exception If failed.
-     */
-    @Test
-    public void testTransactedSessionNoBatching() throws Exception {
-        Destination dest = new ActiveMQQueue(QUEUE_NAME);
-
-        // produce multiple messages into the queue
-        produceStringMessages(dest, false);
-
-        try (IgniteDataStreamer<String, String> dataStreamer = grid().dataStreamer(DEFAULT_CACHE_NAME)) {
-            JmsStreamer<TextMessage, String, String> jmsStreamer = newJmsStreamer(TextMessage.class, dataStreamer);
-            jmsStreamer.setTransacted(true);
-            jmsStreamer.setDestination(dest);
-
-            // subscribe to cache PUT events and return a countdown latch starting at CACHE_ENTRY_COUNT
-            CountDownLatch latch = subscribeToPutEvents(CACHE_ENTRY_COUNT);
-
-            jmsStreamer.start();
-
-            // all cache PUT events received in 10 seconds
-            latch.await(10, TimeUnit.SECONDS);
-
-            assertAllCacheEntriesLoaded();
-
-            jmsStreamer.stop();
-        }
-
-    }
-
-    /**
-     * @throws Exception If failed.
-     */
-    @Test
-    public void testQueueMultipleThreads() throws Exception {
-        Destination dest = new ActiveMQQueue(QUEUE_NAME);
-
-        // produce messages into the queue
-        produceObjectMessages(dest, false);
-
-        try (IgniteDataStreamer<String, String> dataStreamer = grid().dataStreamer(DEFAULT_CACHE_NAME)) {
-            JmsStreamer<ObjectMessage, String, String> jmsStreamer = newJmsStreamer(ObjectMessage.class, dataStreamer);
-            jmsStreamer.setDestination(dest);
-            jmsStreamer.setThreads(5);
-
-            // subscribe to cache PUT events and return a countdown latch starting at CACHE_ENTRY_COUNT
-            CountDownLatch latch = subscribeToPutEvents(CACHE_ENTRY_COUNT);
-
-            // start the streamer
-            jmsStreamer.start();
-
-            DestinationStatistics qStats = broker.getBroker().getDestinationMap().get(dest).getDestinationStatistics();
-            assertEquals(5, qStats.getConsumers().getCount());
-
-            // all cache PUT events received in 10 seconds
-            latch.await(10, TimeUnit.SECONDS);
-
-            // assert that all consumers received messages - given that the prefetch is 1
-            for (Subscription subscription : broker.getBroker().getDestinationMap().get(dest).getConsumers())
-                assertTrue(subscription.getDequeueCounter() > 0);
-
-            assertAllCacheEntriesLoaded();
-
-            jmsStreamer.stop();
-        }
-
-    }
-
-    /**
-     * Test for ExceptionListener functionality.
-     *
-     * @throws Exception If fails.
-     */
-    @Test
-    public void testExceptionListener() throws Exception {
-        // restart broker with auth plugin
-        if (broker.isStarted())
-            broker.stop();
-
-        broker.waitUntilStopped();
-
-        broker.setPlugins(new BrokerPlugin[]{new SimpleAuthenticationPlugin(new ArrayList())});
-
-        broker.start(true);
-
-        connFactory = new ActiveMQConnectionFactory(BrokerRegistry.getInstance().findFirst().getVmConnectorURI());
-
-        final List<Throwable> lsnrExceptions = new LinkedList<>();
-
-        final CountDownLatch latch = new CountDownLatch(1);
-
-        Destination dest = new ActiveMQQueue(QUEUE_NAME);
-
-        try (IgniteDataStreamer<String, String> dataStreamer = grid().dataStreamer(DEFAULT_CACHE_NAME)) {
-            JmsStreamer<ObjectMessage, String, String> jmsStreamer = newJmsStreamer(ObjectMessage.class, dataStreamer);
-
-            jmsStreamer.setExceptionListener(new ExceptionListener() {
-                @Override public void onException(JMSException e) {
-                    System.out.println("ERROR");
-
-                    lsnrExceptions.add(e);
-
-                    latch.countDown();
-                }
-            });
-
-            jmsStreamer.setDestination(dest);
-
-            GridTestUtils.assertThrowsWithCause(new Callable<Void>() {
-                @Override public Void call() throws Exception {
-                    jmsStreamer.start();
-
-                    return null;
-                }
-            }, SecurityException.class);
-
-            assertTrue(latch.await(10, TimeUnit.SECONDS));
-
-            assertTrue(lsnrExceptions.size() > 0);
-
-            GridTestUtils.assertThrowsWithCause(new Callable<Void>() {
-                @Override public Void call() throws Exception {
-                    jmsStreamer.stop();
-
-                    return null;
-                }
-            }, IgniteException.class);
-        }
-    }
-
-    /**
-     *
-     */
-    private void assertAllCacheEntriesLoaded() {
-        // Get the cache and check that the entries are present
-        IgniteCache<String, String> cache = grid().cache(DEFAULT_CACHE_NAME);
-        for (Map.Entry<String, String> entry : TEST_DATA.entrySet())
-            assertEquals(entry.getValue(), cache.get(entry.getKey()));
-    }
-
-    @SuppressWarnings("unchecked")
-    private <T extends Message> JmsStreamer<T, String, String> newJmsStreamer(Class<T> type,
-        IgniteDataStreamer<String, String> dataStreamer) {
-
-        JmsStreamer<T, String, String> jmsStreamer = new JmsStreamer<>();
-        jmsStreamer.setIgnite(grid());
-        jmsStreamer.setStreamer(dataStreamer);
-        jmsStreamer.setConnectionFactory(connFactory);
-
-        if (type == ObjectMessage.class)
-            jmsStreamer.setTransformer((MessageTransformer<T, String, String>) TestTransformers.forObjectMessage());
-        else
-            jmsStreamer.setTransformer((MessageTransformer<T, String, String>) TestTransformers.forTextMessage());
-
-        dataStreamer.allowOverwrite(true);
-        dataStreamer.autoFlushFrequency(10);
-        return jmsStreamer;
-    }
-
-    /**
-     * @param expect Expected events number.
-     * @return Event receive latch.
-     */
-    private CountDownLatch subscribeToPutEvents(int expect) {
-        Ignite ignite = grid();
-
-        // Listen to cache PUT events and expect as many as messages as test data items
-        final CountDownLatch latch = new CountDownLatch(expect);
-
-        @SuppressWarnings("serial") IgniteBiPredicate<UUID, CacheEvent> cb = new IgniteBiPredicate<UUID, CacheEvent>() {
-            @Override public boolean apply(UUID uuid, CacheEvent evt) {
-                latch.countDown();
-                return true;
-            }
-        };
-
-        ignite.events(ignite.cluster().forCacheNodes(DEFAULT_CACHE_NAME)).remoteListen(cb, null, EVT_CACHE_OBJECT_PUT);
-        return latch;
-    }
-
-    private void produceObjectMessages(Destination dest, boolean singleMsg) throws JMSException {
-        Session ses = connFactory.createConnection().createSession(false, Session.AUTO_ACKNOWLEDGE);
-
-        MessageProducer mp = ses.createProducer(dest);
-
-        HashSet<TestTransformers.TestObject> set = new HashSet<>();
-
-        for (String key : TEST_DATA.keySet()) {
-            TestTransformers.TestObject to = new TestTransformers.TestObject(key, TEST_DATA.get(key));
-            set.add(to);
-        }
-
-        int messagesSent;
-
-        if (singleMsg) {
-            mp.send(ses.createObjectMessage(set));
-            messagesSent = 1;
-        }
-        else {
-            for (TestTransformers.TestObject to : set)
-                mp.send(ses.createObjectMessage(to));
-
-            messagesSent = set.size();
-        }
-
-        if (dest instanceof Queue) {
-            try {
-                assertEquals(messagesSent, broker.getBroker().getDestinationMap().get(dest)
-                    .getDestinationStatistics().getMessages().getCount());
-            }
-            catch (Exception e) {
-                fail(e.toString());
-            }
-        }
-
-    }
-
-    private void produceStringMessages(Destination dest, boolean singleMsg) throws JMSException {
-        Session ses = connFactory.createConnection().createSession(false, Session.AUTO_ACKNOWLEDGE);
-
-        MessageProducer mp = ses.createProducer(dest);
-
-        HashSet<String> set = new HashSet<>();
-
-        for (String key : TEST_DATA.keySet())
-            set.add(key + "," + TEST_DATA.get(key));
-
-        int messagesSent;
-
-        if (singleMsg) {
-            StringBuilder sb = new StringBuilder();
-
-            for (String s : set)
-                sb.append(s).append("|");
-
-            sb.deleteCharAt(sb.length() - 1);
-            mp.send(ses.createTextMessage(sb.toString()));
-            messagesSent = 1;
-
-        }
-        else {
-            for (String s : set)
-                mp.send(ses.createTextMessage(s));
-
-            messagesSent = set.size();
-        }
-
-        if (dest instanceof Queue) {
-            try {
-                assertEquals(messagesSent, broker.getBroker().getDestinationMap().get(dest)
-                    .getDestinationStatistics().getMessages().getCount());
-            }
-            catch (Exception e) {
-                fail(e.toString());
-            }
-        }
-
-    }
-}
diff --git a/modules/jms11/src/test/java/org/apache/ignite/stream/jms11/TestTransformers.java b/modules/jms11/src/test/java/org/apache/ignite/stream/jms11/TestTransformers.java
deleted file mode 100644
index 16b312ae8c5a..000000000000
--- a/modules/jms11/src/test/java/org/apache/ignite/stream/jms11/TestTransformers.java
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.ignite.stream.jms11;
-
-import java.io.Serializable;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-import javax.jms.JMSException;
-import javax.jms.ObjectMessage;
-import javax.jms.TextMessage;
-
-/**
- * Test transformers for JmsStreamer tests.
- *
- * @author Raul Kripalani
- */
-public class TestTransformers {
-
-    /**
-     * Returns a transformer for JMS {@link TextMessage}s, capable of extracting many tuples from a single message,
-     * if pipe characters are encountered.
-     *
-     * @return
-     */
-    public static MessageTransformer<TextMessage, String, String> forTextMessage() {
-        return new MessageTransformer<TextMessage, String, String>() {
-            @Override public Map<String, String> apply(TextMessage message) {
-                final Map<String, String> answer = new HashMap<>();
-                String text;
-                try {
-                    text = message.getText();
-                }
-                catch (JMSException e) {
-                    e.printStackTrace();
-                    return Collections.emptyMap();
-                }
-                for (String s : text.split("\\|")) {
-                    String[] tokens = s.split(",");
-                    answer.put(tokens[0], tokens[1]);
-                }
-                return answer;
-            }
-        };
-    }
-
-    /**
-     * Returns a transformer for JMS {@link ObjectMessage}s, capable of extracting many tuples from a single message,
-     * if the payload is a {@link Collection}.
-     *
-     * @return
-     */
-    public static MessageTransformer<ObjectMessage, String, String> forObjectMessage() {
-        return new MessageTransformer<ObjectMessage, String, String>() {
-            @SuppressWarnings("unchecked")
-            @Override public Map<String, String> apply(ObjectMessage message) {
-                Object object;
-                try {
-                    object = message.getObject();
-                }
-                catch (JMSException e) {
-                    e.printStackTrace();
-                    return Collections.emptyMap();
-                }
-
-                final Map<String, String> answer = new HashMap<>();
-                if (object instanceof Collection) {
-                    for (TestObject to : (Collection<TestObject>)object)
-                        answer.put(to.getKey(), to.getValue());
-
-                }
-                else if (object instanceof TestObject) {
-                    TestObject to = (TestObject)object;
-                    answer.put(to.getKey(), to.getValue());
-                }
-                return answer;
-            }
-        };
-    }
-
-    public static MessageTransformer<TextMessage, String, String> generateNoEntries() {
-        return new MessageTransformer<TextMessage, String, String>() {
-            @Override public Map<String, String> apply(TextMessage message) {
-                return null;
-            }
-        };
-    }
-
-    public static class TestObject implements Serializable {
-        private static final long serialVersionUID = -7332027566186690945L;
-
-        private String key;
-
-        private String value;
-
-        public TestObject(String key, String value) {
-            this.key = key;
-            this.value = value;
-        }
-
-        public String getKey() {
-            return key;
-        }
-
-        public String getValue() {
-            return value;
-        }
-
-    }
-
-}
diff --git a/modules/jms11/src/test/java/org/apache/ignite/stream/jms11/package-info.java b/modules/jms11/src/test/java/org/apache/ignite/stream/jms11/package-info.java
deleted file mode 100644
index 52aa97bd36b5..000000000000
--- a/modules/jms11/src/test/java/org/apache/ignite/stream/jms11/package-info.java
+++ /dev/null
@@ -1,22 +0,0 @@
-/*
- *  Licensed to the Apache Software Foundation (ASF) under one or more
- *  contributor license agreements.  See the NOTICE file distributed with
- *  this work for additional information regarding copyright ownership.
- *  The ASF licenses this file to You under the Apache License, Version 2.0
- *  (the "License"); you may not use this file except in compliance with
- *  the License.  You may obtain a copy of the License at
- *
- *       http://www.apache.org/licenses/LICENSE-2.0
- *
- *  Unless required by applicable law or agreed to in writing, software
- *  distributed under the License is distributed on an "AS IS" BASIS,
- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- *  See the License for the specific language governing permissions and
- *  limitations under the License.
- */
-
-/**
- * Contains implementation of JMS queue and topic messages consumer.
- */
-
-package org.apache.ignite.stream.jms11;
diff --git a/modules/platforms/cpp/common/include/ignite/ignite_error.h b/modules/platforms/cpp/common/include/ignite/ignite_error.h
index 0f46d5a12d96..0c402d42b061 100644
--- a/modules/platforms/cpp/common/include/ignite/ignite_error.h
+++ b/modules/platforms/cpp/common/include/ignite/ignite_error.h
@@ -207,6 +207,12 @@ namespace ignite
 
         /** SSL/TLS error. */
         static const int IGNITE_ERR_SECURE_CONNECTION_FAILURE = 2026;
+
+        /** Transaction already started by current thread. */
+        static const int IGNITE_ERR_TX_THIS_THREAD = 2027;
+
+        /** Generic transaction error. */
+        static const int IGNITE_ERR_TX = 2028;
         
         
         /** Unknown error. */
diff --git a/modules/platforms/cpp/core/src/transactions/transactions.cpp b/modules/platforms/cpp/core/src/transactions/transactions.cpp
index 4c1ea705e70d..54a9fa2e95c6 100644
--- a/modules/platforms/cpp/core/src/transactions/transactions.cpp
+++ b/modules/platforms/cpp/core/src/transactions/transactions.cpp
@@ -16,6 +16,7 @@
  */
 
 #include "ignite/transactions/transactions.h"
+#include "ignite/transactions/transaction.h"
 
 using namespace ignite::common::concurrent;
 using namespace ignite::impl::transactions;
diff --git a/modules/platforms/cpp/thin-client-test/CMakeLists.txt b/modules/platforms/cpp/thin-client-test/CMakeLists.txt
index d0ebe58c44bc..535cb1adfe0b 100644
--- a/modules/platforms/cpp/thin-client-test/CMakeLists.txt
+++ b/modules/platforms/cpp/thin-client-test/CMakeLists.txt
@@ -33,7 +33,9 @@ set(SOURCES src/teamcity/teamcity_boost.cpp
         src/test_utils.cpp
         src/ignite_client_test.cpp
         src/auth_test.cpp
-        src/ssl_test.cpp)
+        src/tx_test.cpp
+        src/ssl_test.cpp
+        )
 
 add_executable(${TARGET} ${SOURCES})
 
diff --git a/modules/platforms/cpp/thin-client-test/config/ssl/generate_certificates.sh b/modules/platforms/cpp/thin-client-test/config/ssl/generate_certificates.sh
index 5e8303a30222..e4f41e255ef2 100755
--- a/modules/platforms/cpp/thin-client-test/config/ssl/generate_certificates.sh
+++ b/modules/platforms/cpp/thin-client-test/config/ssl/generate_certificates.sh
@@ -34,7 +34,7 @@ function generate_ca {
     $OSSL req \
         -newkey rsa:2048 -nodes -sha256 -keyout $CA_KEY \
         -subj "/C=US/ST=Massachusetts/L=Wakefield/CN=ignite.apache.org/O=The Apache Software Foundation/OU=$OU/emailAddress=dev@ignite.apache.org" \
-        -x509 -days=3650 -out $CA_CRT
+        -x509 -days 3650 -out $CA_CRT
 }
 
 function generate_client_key_and_crt {
@@ -55,10 +55,15 @@ function generate_client_key_and_crt {
     # Signing client cerificate
     $OSSL x509 -req \
         -in $CLIENT_CSR -CA $CA_CRT -CAkey $CA_KEY -CAcreateserial \
-        -days=3650 -sha256 -out $CLIENT_CRT
+        -days 3650 -sha256 -out $CLIENT_CRT
 
     # Cleaning up.
     rm -f $CLIENT_CSR
+
+    # Protecting key with the password if required
+    if [ "$4" == "1" ]; then
+      openssl rsa -aes256 -in $CLIENT_KEY -passout pass:654321 -out $CLIENT_KEY
+    fi
 }
 
 function generate_jks {
@@ -89,13 +94,15 @@ function generate_jks {
 
 CA='ca'
 CLIENT='client'
+CLIENT_WITH_PASS='client_with_pass'
 SERVER='server'
 CA_UNKNOWN='ca_unknown'
 CLIENT_UNKNOWN='client_unknown'
 
 generate_ca $CA 'Apache Ignite CA'
-generate_client_key_and_crt $CA 'client' 'Apache Ignite Client Test'
-generate_client_key_and_crt $CA 'server' 'Apache Ignite Server Test'
+generate_client_key_and_crt $CA $CLIENT 'Apache Ignite Client Test'
+generate_client_key_and_crt $CA $CLIENT_WITH_PASS 'Apache Ignite Client Test' 1
+generate_client_key_and_crt $CA $SERVER 'Apache Ignite Server Test'
 
 # We won't sign up any other certs so we do not need CA key or srl
 rm -f "$CA.key" "$CA.srl"
@@ -110,10 +117,11 @@ rm -f $CA_UNKNOWN*
 
 # Re-naming everything as needed
 cat $CLIENT.key $CLIENT.crt > "$CLIENT"_full.pem
+cat $CLIENT_WITH_PASS.key $CLIENT_WITH_PASS.crt > "$CLIENT_WITH_PASS"_full.pem
 cat $CLIENT_UNKNOWN.key $CLIENT_UNKNOWN.crt > $CLIENT_UNKNOWN.pem
 mv $CA.jks trust.jks
 mv $CA.crt ca.pem
 
-rm -f $CLIENT.crt $CLIENT.key $CLIENT_UNKNOWN.key $CLIENT_UNKNOWN.crt $SERVER_KEY $SERVER_CRT
+rm -f $CLIENT.crt $CLIENT.key $CLIENT_WITH_PASS.key $CLIENT_WITH_PASS.crt $CLIENT_UNKNOWN.key $CLIENT_UNKNOWN.crt $SERVER_KEY $SERVER_CRT
 
 
diff --git a/modules/platforms/cpp/thin-client-test/project/vs/thin-client-test.vcxproj b/modules/platforms/cpp/thin-client-test/project/vs/thin-client-test.vcxproj
index ad13f6fc1e27..118c4900bf49 100644
--- a/modules/platforms/cpp/thin-client-test/project/vs/thin-client-test.vcxproj
+++ b/modules/platforms/cpp/thin-client-test/project/vs/thin-client-test.vcxproj
@@ -26,6 +26,7 @@
     <ClCompile Include="..\..\src\teamcity\teamcity_boost.cpp" />
     <ClCompile Include="..\..\src\teamcity\teamcity_messages.cpp" />
     <ClCompile Include="..\..\src\test_utils.cpp" />
+    <ClCompile Include="..\..\src\tx_test.cpp" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\include\ignite\complex_type.h" />
diff --git a/modules/platforms/cpp/thin-client-test/src/tx_test.cpp b/modules/platforms/cpp/thin-client-test/src/tx_test.cpp
new file mode 100644
index 000000000000..19757a2b1ef3
--- /dev/null
+++ b/modules/platforms/cpp/thin-client-test/src/tx_test.cpp
@@ -0,0 +1,400 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <boost/chrono.hpp>
+#include <boost/thread.hpp>
+#include <boost/test/unit_test.hpp>
+
+#include <ignite/ignition.h>
+
+#include "ignite/thin/ignite_client_configuration.h"
+#include "ignite/thin/ignite_client.h"
+#include "ignite/thin/cache/cache_peek_mode.h"
+#include "ignite/thin/transactions/transaction_consts.h"
+
+#include <test_utils.h>
+#include <ignite/ignite_error.h>
+
+using namespace ignite::thin;
+using namespace boost::unit_test;
+using namespace ignite::thin::transactions;
+using namespace ignite::common::concurrent;
+
+class IgniteTxTestSuiteFixture
+{
+public:
+    IgniteTxTestSuiteFixture()
+    {
+        serverNode = ignite_test::StartCrossPlatformServerNode("cache.xml", "ServerNode");
+    }
+
+    ~IgniteTxTestSuiteFixture()
+    {
+        ignite::Ignition::StopAll(false);
+    }
+
+private:
+    /** Server node. */
+    ignite::Ignite serverNode;
+};
+
+BOOST_FIXTURE_TEST_SUITE(IgniteTxTestSuite, IgniteTxTestSuiteFixture)
+
+bool correctCloseMessage(const ignite::IgniteError& ex)
+{
+    BOOST_CHECK_EQUAL(ex.what(), std::string(TX_ALREADY_CLOSED));
+
+    return true;
+}
+
+bool separateThreadMessage(const ignite::IgniteError& ex)
+{
+    BOOST_CHECK_EQUAL(ex.what(), std::string(TX_DIFFERENT_THREAD));
+
+    return true;
+}
+
+bool checkTxTimeoutMessage(const ignite::IgniteError& ex)
+{
+    return std::string(ex.what()).find("Cache transaction timed out") != std::string::npos;
+}
+
+BOOST_AUTO_TEST_CASE(TestCacheOpsWithTx)
+{
+    IgniteClientConfiguration cfg;
+
+    cfg.SetEndPoints("127.0.0.1:11110");
+
+    IgniteClient client = IgniteClient::Start(cfg);
+
+    cache::CacheClient<int, int> cache =
+        client.GetCache<int, int>("partitioned");
+
+    cache.Put(1, 1);
+
+    transactions::ClientTransactions transactions = client.ClientTransactions();
+
+    transactions::ClientTransaction tx = transactions.TxStart();
+
+    cache.Put(1, 10);
+
+    BOOST_CHECK_EQUAL(10, cache.Get(1));
+
+    tx.Rollback();
+
+    BOOST_CHECK_EQUAL(1, cache.Get(1));
+
+    //---
+
+    tx = transactions.TxStart();
+
+    cache.Put(1, 10);
+
+    tx.Commit();
+
+    BOOST_CHECK_EQUAL(10, cache.Get(1));
+
+    cache.Put(1, 1);
+
+    //---
+
+    tx = transactions.TxStart();
+
+    cache.Put(1, 10);
+
+    BOOST_CHECK_EQUAL(10, cache.Get(1));
+
+    tx.Close();
+
+    BOOST_CHECK_EQUAL(1, cache.Get(1));
+
+    //---
+
+    tx = transactions.TxStart(TransactionConcurrency::OPTIMISTIC, TransactionIsolation::SERIALIZABLE);
+
+    cache.Put(1, 10);
+
+    BOOST_CHECK_EQUAL(10, cache.Get(1));
+
+    tx.Close();
+
+    BOOST_CHECK_EQUAL(1, cache.Get(1));
+
+    //---
+
+    tx = transactions.TxStart(TransactionConcurrency::OPTIMISTIC, TransactionIsolation::SERIALIZABLE, 1000, 100);
+
+    cache.Put(1, 10);
+
+    BOOST_CHECK_EQUAL(10, cache.Get(1));
+
+    tx.Close();
+
+    BOOST_CHECK_EQUAL(1, cache.Get(1));
+
+    //---
+
+    tx = transactions.TxStart();
+
+    cache.Replace(1, 10);
+
+    BOOST_CHECK_EQUAL(10, cache.Get(1));
+
+    tx.Rollback();
+
+    BOOST_CHECK_EQUAL(1, cache.Get(1));
+
+    //---
+
+    tx = transactions.TxStart();
+
+    cache.Replace(1, 1, 10);
+
+    BOOST_CHECK_EQUAL(10, cache.Get(1));
+
+    tx.Rollback();
+
+    BOOST_CHECK_EQUAL(1, cache.Get(1));
+
+    //---
+
+    tx = transactions.TxStart();
+
+    cache.Put(2, 20);
+
+    BOOST_CHECK_EQUAL(cache.ContainsKey(2), true);
+
+    tx.Rollback();
+
+    BOOST_CHECK_EQUAL(cache.ContainsKey(2), false);
+
+    //---
+
+    tx = transactions.TxStart();
+
+    cache.Put(2, 20);
+
+    tx.Rollback();
+
+    BOOST_CHECK_EQUAL(cache.GetSize(cache::CachePeekMode::ALL), 1);
+
+    //---
+
+    tx = transactions.TxStart();
+
+    int res1 = cache.GetAndPutIfAbsent(1, 10);
+
+    int res2 = cache.GetAndPutIfAbsent(2, 20);
+
+    BOOST_CHECK_EQUAL(1, res1);
+
+    BOOST_CHECK_EQUAL(cache.Get(2), 20);
+
+    BOOST_CHECK_EQUAL(0, res2);
+
+    tx.Rollback();
+
+    BOOST_CHECK_EQUAL(cache.Get(2), 0);
+
+    //---
+
+    tx = transactions.TxStart();
+
+    cache.Remove(1);
+
+    tx.Rollback();
+
+    BOOST_CHECK_EQUAL(cache.ContainsKey(1), true);
+
+    // Test transaction with a timeout.
+
+    const uint32_t TX_TIMEOUT = 200;
+
+    tx = transactions.TxStart(TransactionConcurrency::OPTIMISTIC, TransactionIsolation::SERIALIZABLE, TX_TIMEOUT);
+
+    cache.Put(1, 10);
+
+    boost::this_thread::sleep_for(boost::chrono::milliseconds(2 * TX_TIMEOUT));
+
+    BOOST_CHECK_EXCEPTION(cache.Put(1, 20), ignite::IgniteError, checkTxTimeoutMessage);
+
+    BOOST_CHECK_EXCEPTION(tx.Commit(), ignite::IgniteError, checkTxTimeoutMessage);
+
+    tx.Close();
+
+    BOOST_CHECK_EQUAL(1, cache.Get(1));
+}
+
+void startAnotherClientAndTx(SharedPointer<SingleLatch>& l)
+{
+    IgniteClientConfiguration cfg;
+
+    cfg.SetEndPoints("127.0.0.1:11110");
+
+    IgniteClient client = IgniteClient::Start(cfg);
+
+    cache::CacheClient<int, int> cache =
+        client.GetCache<int, int>("partitioned");
+
+    transactions::ClientTransactions transactions = client.ClientTransactions();
+
+    transactions::ClientTransaction tx = transactions.TxStart();
+
+    l.Get()->CountDown();
+
+    cache.Put(2, 20);
+
+    tx.Commit();
+}
+
+BOOST_AUTO_TEST_CASE(TestTxOps)
+{
+    IgniteClientConfiguration cfg;
+
+    cfg.SetEndPoints("127.0.0.1:11110");
+
+    IgniteClient client = IgniteClient::Start(cfg);
+
+    cache::CacheClient<int, int> cache =
+        client.GetCache<int, int>("partitioned");
+
+    cache.Put(1, 1);
+
+    transactions::ClientTransactions transactions = client.ClientTransactions();
+
+    transactions::ClientTransaction tx = transactions.TxStart();
+
+    BOOST_CHECK_THROW( transactions.TxStart(), ignite::IgniteError );
+
+    tx.Close();
+
+    //Test end of already completed transaction.
+
+    tx = transactions.TxStart();
+
+    tx.Close();
+
+    BOOST_CHECK_EXCEPTION(tx.Commit(), ignite::IgniteError, correctCloseMessage);
+
+    BOOST_CHECK_EXCEPTION(tx.Rollback(), ignite::IgniteError, correctCloseMessage);
+
+    // Test end of outdated transaction.
+
+    transactions::ClientTransaction tx1 = transactions.TxStart();
+
+    BOOST_CHECK_EXCEPTION(tx.Commit(), ignite::IgniteError, separateThreadMessage);
+
+    tx1.Close();
+
+    // Test end of outdated transaction.
+
+    tx = transactions.TxStart();
+
+    tx.Commit();
+
+    BOOST_CHECK_EXCEPTION(tx.Commit(), ignite::IgniteError, correctCloseMessage);
+
+    tx.Close();
+
+    // Check multi threads.
+
+    SharedPointer<SingleLatch> latch = SharedPointer<SingleLatch>(new SingleLatch());
+
+    tx = transactions.TxStart();
+
+    cache.Put(1, 10);
+
+    boost::thread t2(startAnotherClientAndTx, latch);
+
+    latch.Get()->Await();
+
+    tx.Rollback();
+
+    t2.join();
+
+    BOOST_CHECK_EQUAL(1, cache.Get(1));
+
+    BOOST_CHECK_EQUAL(20, cache.Get(2));
+}
+
+const std::string label = std::string("label_2_check");
+
+std::string label1 = std::string("label_2_check1");
+
+bool checkTxLabelMessage(const ignite::IgniteError& ex)
+{
+    return std::string(ex.what()).find(label) != std::string::npos;
+}
+
+bool checkTxLabel1Message(const ignite::IgniteError& ex)
+{
+    return std::string(ex.what()).find("label_2_check1") != std::string::npos;
+}
+
+BOOST_AUTO_TEST_CASE(TestTxWithLabel)
+{
+    IgniteClientConfiguration cfg;
+
+    cfg.SetEndPoints("127.0.0.1:11110");
+
+    IgniteClient client = IgniteClient::Start(cfg);
+
+    cache::CacheClient<int, int> cache =
+        client.GetCache<int, int>("partitioned");
+
+    const uint32_t TX_TIMEOUT = 200;
+
+    transactions::ClientTransactions transactions = client.ClientTransactions();
+
+    transactions::ClientTransaction tx = transactions.withLabel(label).TxStart(TransactionConcurrency::OPTIMISTIC, TransactionIsolation::SERIALIZABLE, TX_TIMEOUT);
+
+    cache.Put(1, 10);
+
+    boost::this_thread::sleep_for(boost::chrono::milliseconds(2 * TX_TIMEOUT));
+
+    BOOST_CHECK_EXCEPTION(tx.Commit(), ignite::IgniteError, checkTxLabelMessage);
+
+    tx.Close();
+
+    // New label
+
+    tx = transactions.TxStart(TransactionConcurrency::OPTIMISTIC, TransactionIsolation::SERIALIZABLE, TX_TIMEOUT);
+
+    cache.Put(1, 10);
+
+    boost::this_thread::sleep_for(boost::chrono::milliseconds(2 * TX_TIMEOUT));
+
+    BOOST_CHECK_EXCEPTION(tx.Commit(), ignite::IgniteError, !checkTxLabelMessage);
+
+    tx.Close();
+
+    // Label is gone
+
+    tx = transactions.withLabel(label1).TxStart(TransactionConcurrency::OPTIMISTIC, TransactionIsolation::SERIALIZABLE, TX_TIMEOUT);
+
+    label1 = "NULL";
+
+    cache.Put(1, 10);
+
+    boost::this_thread::sleep_for(boost::chrono::milliseconds(2 * TX_TIMEOUT));
+
+    BOOST_CHECK_EXCEPTION(tx.Commit(), ignite::IgniteError, checkTxLabel1Message);
+
+    tx.Close();
+}
+
+BOOST_AUTO_TEST_SUITE_END()
diff --git a/modules/platforms/cpp/thin-client/CMakeLists.txt b/modules/platforms/cpp/thin-client/CMakeLists.txt
index 5cd121f36072..988e13fb0c31 100644
--- a/modules/platforms/cpp/thin-client/CMakeLists.txt
+++ b/modules/platforms/cpp/thin-client/CMakeLists.txt
@@ -34,6 +34,8 @@ set(SOURCES src/impl/data_channel.cpp
         src/impl/message.cpp
         src/impl/cache/cache_client_proxy.cpp
         src/impl/cache/cache_client_impl.cpp
+        src/impl/transactions/transactions_impl.cpp
+        src/impl/transactions/transactions_proxy.cpp
         src/ignite_client.cpp)
 
 add_library(${TARGET} SHARED ${SOURCES})
diff --git a/modules/platforms/cpp/thin-client/include/ignite/impl/thin/transactions/transactions_proxy.h b/modules/platforms/cpp/thin-client/include/ignite/impl/thin/transactions/transactions_proxy.h
new file mode 100644
index 000000000000..ce0802cf5628
--- /dev/null
+++ b/modules/platforms/cpp/thin-client/include/ignite/impl/thin/transactions/transactions_proxy.h
@@ -0,0 +1,145 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _IGNITE_IMPL_THIN_TRANSACTIONS_PROXY
+#define _IGNITE_IMPL_THIN_TRANSACTIONS_PROXY
+
+#include "ignite/common/concurrent.h"
+#include <ignite/common/fixed_size_array.h>
+#include "ignite/thin/transactions/transaction_consts.h"
+
+namespace ignite
+{
+    namespace impl
+    {
+        namespace thin
+        {
+            namespace transactions
+            {
+                /**
+                 * Ignite transaction class proxy.
+                 */
+                class IGNITE_IMPORT_EXPORT TransactionProxy {
+
+                public:
+                    /**
+                     * Default constructor.
+                     */
+                    TransactionProxy() {}
+
+                    /**
+                     * Constructor.
+                     * @param impl Transaction implementation.
+                     */
+                    TransactionProxy(const ignite::common::concurrent::SharedPointer<void>& impl) :
+                        impl(impl)
+                    {}
+
+                    /**
+                     * Assignment operator.
+                     *
+                     * @param other Another instance.
+                     * @return *this.
+                     */
+                    TransactionProxy& operator=(const TransactionProxy& other)
+                    {
+                        impl = other.impl;
+
+                        return *this;
+                    }
+
+                    /**
+                     * Destructor.
+                     */
+                    ~TransactionProxy() {};
+
+                    /**
+                     * Commit the transaction.
+                     */
+                    void commit();
+
+                    /**
+                     * Rollback the transaction.
+                     */
+                    void rollback();
+
+                    /**
+                     * Close the transaction.
+                     */
+                    void close();
+
+                private:
+                    /** Implementation. */
+                    ignite::common::concurrent::SharedPointer<void> impl;
+                };
+
+                /**
+                 * Ignite transactions class proxy.
+                 */
+                class IGNITE_IMPORT_EXPORT TransactionsProxy
+                {
+                    #define DEFAULT_CONCURRENCY TransactionConcurrency::PESSIMISTIC
+                    #define DEFAULT_ISOLATION TransactionIsolation::READ_COMMITTED
+                    #define DEFAULT_TIMEOUT 0
+                    #define DEFAULT_TX_SIZE 0
+                public:
+                    /**
+                     * Constructor.
+                     */
+                    TransactionsProxy(const ignite::common::concurrent::SharedPointer<void>& impl) :
+                        impl(impl)
+                    {
+                        // No-op.
+                    }
+
+                    /**
+                     * Default constructor.
+                     */
+                    TransactionsProxy() {}
+
+                    /**
+                     * Destructor.
+                     */
+                    ~TransactionsProxy() {}
+
+                    /**
+                     * Start new transaction with completely clarify parameters.
+                     *
+                     * @param concurrency Transaction concurrency.
+                     * @param isolation Transaction isolation.
+                     * @param timeout Transaction timeout.
+                     * @param txSize Number of entries participating in transaction (may be approximate).
+                     * @param lbl Transaction specific label.
+                     *
+                     * @return Proxy implementation.
+                     */
+                    TransactionProxy txStart(
+                            ignite::thin::transactions::TransactionConcurrency::Type concurrency = ignite::thin::transactions::TransactionConcurrency::PESSIMISTIC,
+                            ignite::thin::transactions::TransactionIsolation::Type isolation = ignite::thin::transactions::TransactionIsolation::READ_COMMITTED,
+                            int64_t timeout = 0,
+                            int32_t txSize = 0,
+                            ignite::common::concurrent::SharedPointer<ignite::common::FixedSizeArray<char> > lbl = NULL);
+                private:
+                    /** Implementation. */
+                    ignite::common::concurrent::SharedPointer<void> impl;
+                };
+            }
+        }
+    }
+}
+
+#endif // _IGNITE_IMPL_THIN_TRANSACTIONS_PROXY
diff --git a/modules/platforms/cpp/thin-client/include/ignite/thin/ignite_client.h b/modules/platforms/cpp/thin-client/include/ignite/thin/ignite_client.h
index 245accb5ff42..b540edb5217b 100644
--- a/modules/platforms/cpp/thin-client/include/ignite/thin/ignite_client.h
+++ b/modules/platforms/cpp/thin-client/include/ignite/thin/ignite_client.h
@@ -29,6 +29,7 @@
 
 #include <ignite/thin/ignite_client_configuration.h>
 #include <ignite/thin/cache/cache_client.h>
+#include <ignite/thin/transactions/transactions.h>
 
 namespace ignite
 {
@@ -121,6 +122,14 @@ namespace ignite
              */
             void GetCacheNames(std::vector<std::string>& cacheNames);
 
+            /**
+             * Starts transactions.
+             */
+            transactions::ClientTransactions ClientTransactions()
+            {
+                return transactions::ClientTransactions(InternalTransactions());
+            }
+
         private:
             /**
              * Get cache.
@@ -149,6 +158,9 @@ namespace ignite
              */
             SP_Void InternalCreateCache(const char* name);
 
+            /** */
+            SP_Void InternalTransactions();
+
             /**
              * Constructor.
              *
diff --git a/modules/platforms/cpp/thin-client/include/ignite/thin/transactions/transaction.h b/modules/platforms/cpp/thin-client/include/ignite/thin/transactions/transaction.h
new file mode 100644
index 000000000000..97d75e667552
--- /dev/null
+++ b/modules/platforms/cpp/thin-client/include/ignite/thin/transactions/transaction.h
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _IGNITE_THIN_TRANSACTIONS_CLIENT_TRANSACTION
+#define _IGNITE_THIN_TRANSACTIONS_CLIENT_TRANSACTION
+
+#include <ignite/impl/thin/transactions/transactions_proxy.h>
+
+namespace ignite
+{
+    namespace thin
+    {
+        namespace transactions
+        {
+            /**
+             * Transaction client.
+             *
+             * Implements main transactionsl API.
+             *
+             * This class implemented as a reference to an implementation so copying of this class instance will only
+             * create another reference to the same underlying object. Underlying object released automatically once all
+             * the instances are destructed.
+             */
+            class ClientTransaction {
+
+            public:
+                /**
+                 * Constructor.
+                 *
+                 * @param impl Implementation.
+                 */
+                ClientTransaction(ignite::impl::thin::transactions::TransactionProxy impl) :
+                    proxy(impl)
+                {
+                    // No-op.
+                }
+
+                /**
+                 * Default constructor.
+                 */
+                ClientTransaction()
+                {
+                    // No-op.
+                }
+
+                /**
+                 * Destructor.
+                 */
+                ~ClientTransaction()
+                {
+                    // No-op.
+                }
+
+                /**
+                 * Commits this transaction.
+                 */
+                void Commit()
+                {
+                    proxy.commit();
+                }
+
+                /**
+                 * Rolls back this transaction.
+                 */
+                void Rollback()
+                {
+                    proxy.rollback();
+                }
+
+                /**
+                 * Ends the transaction. Transaction will be rolled back if it has not been committed.
+                 */
+                void Close()
+                {
+                    proxy.close();
+                }
+
+            private:
+                /** Implementation. */
+                ignite::impl::thin::transactions::TransactionProxy proxy;
+            };
+        }
+    }
+}
+
+#endif // _IGNITE_THIN_TRANSACTIONS_CLIENT_TRANSACTION
diff --git a/modules/platforms/cpp/thin-client/include/ignite/thin/transactions/transaction_consts.h b/modules/platforms/cpp/thin-client/include/ignite/thin/transactions/transaction_consts.h
new file mode 100644
index 000000000000..0b017631918f
--- /dev/null
+++ b/modules/platforms/cpp/thin-client/include/ignite/thin/transactions/transaction_consts.h
@@ -0,0 +1,119 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef TRANSACTION_CONSTS_H
+#define TRANSACTION_CONSTS_H
+
+namespace ignite
+{
+    namespace thin
+    {
+        namespace transactions
+        {
+            #define TX_ALREADY_CLOSED "The transaction is already closed."
+            #define TX_ALREADY_STARTED "A transaction has already been started by the current thread."
+            #define TX_DIFFERENT_THREAD "You can commit transaction only from the thread it was started."
+
+            /**
+             * Transaction concurrency control model.
+             */
+            struct TransactionConcurrency
+            {
+                enum Type
+                {
+                    /**
+                     * Optimistic concurrency model. In this mode all cache operations
+                     * are not distributed to other nodes until Transaction::Commit()
+                     * is called. In this mode one @c 'PREPARE' message will be sent to
+                     * participating cache nodes to start acquiring per-transaction
+                     * locks, and once all nodes reply @c 'OK', a one-way @c 'COMMIT'
+                     * message is sent without waiting for reply.
+                     *
+                     * Note that in this mode, optimistic failures are only possible in
+                     * conjunction with ::IGNITE_TX_ISOLATION_SERIALIZABLE isolation
+                     * level. In all other cases, optimistic transactions will never
+                     * fail optimistically and will always be identically ordered on all
+                     * participating grid nodes.
+                     */
+                    OPTIMISTIC = 0,
+
+                    /**
+                     * Pessimistic concurrency model. In this mode a lock is acquired
+                     * on all cache operations with exception of read operations in
+                     * ::IGNITE_TX_ISOLATION_READ_COMMITTED mode. All optional filters
+                     * passed into cache operations will be evaluated after successful
+                     * lock acquisition. Whenever Transaction::Commit() is called, a
+                     * single one-way @c 'COMMIT' message is sent to participating cache
+                     * nodes without waiting for reply. Note that there is no reason for
+                     * distributed @c 'PREPARE' step, as all locks have been already
+                     * acquired.
+                     */
+                    PESSIMISTIC = 1
+                };
+            };
+
+            /**
+             * Defines different cache transaction isolation levels.
+             */
+            struct TransactionIsolation
+            {
+                enum Type
+                {
+                    /**
+                     * Read committed isolation level. This isolation level means that
+                     * always a committed value will be provided for read operations.
+                     * With this isolation level values are always read from cache
+                     * global memory or persistent store every time a value is accessed.
+                     * In other words, if the same key is accessed more than once within
+                     * the same transaction, it may have different value every time
+                     * since global cache memory may be updated concurrently by other
+                     * threads.
+                     */
+                    READ_COMMITTED = 0,
+
+                    /**
+                     * Repeatable read isolation level. This isolation level means that
+                     * if a value was read once within transaction, then all consecutive
+                     * reads will provide the same in-transaction value. With this
+                     * isolation level accessed values are stored within in-transaction
+                     * memory, so consecutive access to the same key within the same
+                     * transaction will always return the value that was previously read
+                     * or updated within this transaction. If concurrency is
+                     * ::IGNITE_TX_CONCURRENCY_PESSIMISTIC, then a lock on the key will
+                     * be acquired prior to accessing the value.
+                     */
+                    REPEATABLE_READ = 1,
+
+                    /**
+                     * Serializable isolation level. This isolation level means that all
+                     * transactions occur in a completely isolated fashion, as if all
+                     * transactions in the system had executed serially, one after the
+                     * other. Read access with this level happens the same way as with
+                     * ::IGNITE_TX_ISOLATION_REPEATABLE_READ level. However, in
+                     * ::IGNITE_TX_CONCURRENCY_OPTIMISTIC mode, if some transactions
+                     * cannot be serially isolated from each other, then one winner will
+                     * be picked and the other transactions in conflict will result in
+                     * IgniteError being thrown.
+                     */
+                    SERIALIZABLE = 2
+                };
+            };
+        }
+    }
+}
+
+#endif // TRANSACTION_CONSTS_H
diff --git a/modules/platforms/cpp/thin-client/include/ignite/thin/transactions/transactions.h b/modules/platforms/cpp/thin-client/include/ignite/thin/transactions/transactions.h
new file mode 100644
index 000000000000..2b740c62d846
--- /dev/null
+++ b/modules/platforms/cpp/thin-client/include/ignite/thin/transactions/transactions.h
@@ -0,0 +1,130 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _IGNITE_THIN_TRANSACTIONS_CLIENT_TRANSACTIONS
+#define _IGNITE_THIN_TRANSACTIONS_CLIENT_TRANSACTIONS
+
+#include <string>
+
+#include <ignite/common/concurrent.h>
+#include <ignite/common/fixed_size_array.h>
+#include <ignite/impl/thin/transactions/transactions_proxy.h>
+#include "ignite/thin/transactions/transaction.h"
+
+namespace ignite
+{
+    namespace thin
+    {
+        namespace transactions
+        {
+            /**
+             * Transactions client.
+             *
+             * This is an entry point for Thin C++ Ignite transactions.
+             *
+             * This class implemented as a reference to an implementation so copying of this class instance will only
+             * create another reference to the same underlying object. Underlying object released automatically once all
+             * the instances are destructed.
+             */
+            class ClientTransactions {
+            public:
+                /**
+                 * Constructor.
+                 *
+                 * @param impl Implementation.
+                 */
+                ClientTransactions(ignite::common::concurrent::SharedPointer<void> impl) :
+                    proxy(impl),
+                    label(ignite::common::concurrent::SharedPointer<ignite::common::FixedSizeArray<char> >())
+                {
+                    // No-op.
+                }
+
+                /**
+                 * Default constructor.
+                 */
+                ClientTransactions()
+                {
+                    // No-op.
+                }
+
+                /**
+                 * Destructor.
+                 */
+                ~ClientTransactions()
+                {
+                    // No-op.
+                }
+
+                /**
+                 * Start new transaction with completely clarify parameters.
+                 *
+                 * @param concurrency Transaction concurrency.
+                 * @param isolation Transaction isolation.
+                 * @param timeout Transaction timeout.
+                 * @param txSize Number of entries participating in transaction (may be approximate).
+                 *
+                 * @return ClientTransaction implementation.
+                 */
+                ClientTransaction TxStart(
+                        TransactionConcurrency::Type concurrency = TransactionConcurrency::PESSIMISTIC,
+                        TransactionIsolation::Type isolation = TransactionIsolation::READ_COMMITTED,
+                        int64_t timeout = 0,
+                        int32_t txSize = 0)
+                {
+                    return ClientTransaction(proxy.txStart(concurrency, isolation, timeout, txSize, label));
+                }
+
+                /**
+                 * Returns instance of {@code ClientTransactions} to mark each new transaction with a specified label.
+                 *
+                 * @param label Transaction label.
+                 * @return ClientTransactions implementation.
+                 */
+                ClientTransactions withLabel(const std::string& lbl)
+                {
+                    ClientTransactions copy = ClientTransactions(proxy, lbl);
+
+                    return copy;
+                }
+            private:
+                /** Implementation. */
+                ignite::impl::thin::transactions::TransactionsProxy proxy;
+
+                /** Transaction specific label. */
+                ignite::common::concurrent::SharedPointer<ignite::common::FixedSizeArray<char> > label;
+
+                /**
+                 * Constructor.
+                 *
+                 * @param impl Implementation.
+                 */
+                ClientTransactions(ignite::impl::thin::transactions::TransactionsProxy& impl, const std::string& lbl) :
+                    proxy(impl)
+                {
+                    ignite::common::FixedSizeArray<char> *label0 = new ignite::common::FixedSizeArray<char>(lbl.size() + 1);
+
+                    strcpy(label0->GetData(), lbl.c_str());
+
+                    label = ignite::common::concurrent::SharedPointer<ignite::common::FixedSizeArray<char> >(label0);
+                }
+            };
+        }
+    }
+}
+
+#endif // _IGNITE_THIN_TRANSACTIONS_CLIENT_TRANSACTION
diff --git a/modules/platforms/cpp/thin-client/project/vs/thin-client.vcxproj b/modules/platforms/cpp/thin-client/project/vs/thin-client.vcxproj
index 629de37d610d..a4b8490ab991 100644
--- a/modules/platforms/cpp/thin-client/project/vs/thin-client.vcxproj
+++ b/modules/platforms/cpp/thin-client/project/vs/thin-client.vcxproj
@@ -167,6 +167,8 @@
     <ClCompile Include="..\..\src\impl\protocol_version.cpp" />
     <ClCompile Include="..\..\src\impl\remote_type_updater.cpp" />
     <ClCompile Include="..\..\src\impl\utility.cpp" />
+    <ClCompile Include="..\..\src\impl\transactions\transactions_impl.cpp" />
+    <ClCompile Include="..\..\src\impl\transactions\transactions_proxy.cpp" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\include\ignite\impl\thin\cache\cache_client_proxy.h" />
@@ -194,6 +196,11 @@
     <ClInclude Include="..\..\src\impl\remote_type_updater.h" />
     <ClInclude Include="..\..\src\impl\response_status.h" />
     <ClInclude Include="..\..\src\impl\utility.h" />
+    <ClInclude Include="..\..\include\ignite\thin\transactions\transactions.h" />
+    <ClInclude Include="..\..\include\ignite\thin\transactions\transaction.h" />
+    <ClInclude Include="..\..\include\ignite\thin\transactions\transaction_consts.h" />
+    <ClInclude Include="..\..\include\ignite\thin\transactions\transactions_proxy.h" />
+    <ClInclude Include="..\..\src\impl\transactions\transactions_impl.h" />
   </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="..\..\..\binary\project\vs\binary.vcxproj">
diff --git a/modules/platforms/cpp/thin-client/src/ignite_client.cpp b/modules/platforms/cpp/thin-client/src/ignite_client.cpp
index 57909e4b0d43..79d29875397b 100644
--- a/modules/platforms/cpp/thin-client/src/ignite_client.cpp
+++ b/modules/platforms/cpp/thin-client/src/ignite_client.cpp
@@ -77,6 +77,11 @@ namespace ignite
             return static_cast<SP_Void>(GetClientImpl(impl).CreateCache(name));
         }
 
+        IgniteClient::SP_Void IgniteClient::InternalTransactions()
+        {
+            return static_cast<SP_Void>(GetClientImpl(impl).ClientTransactions());
+        }
+
         IgniteClient::IgniteClient(SP_Void& impl)
         {
             this->impl.Swap(impl);
diff --git a/modules/platforms/cpp/thin-client/src/impl/cache/cache_client_impl.cpp b/modules/platforms/cpp/thin-client/src/impl/cache/cache_client_impl.cpp
index 1422707831d6..b128cc010a5b 100644
--- a/modules/platforms/cpp/thin-client/src/impl/cache/cache_client_impl.cpp
+++ b/modules/platforms/cpp/thin-client/src/impl/cache/cache_client_impl.cpp
@@ -20,6 +20,10 @@
 #include "impl/response_status.h"
 #include "impl/message.h"
 #include "impl/cache/cache_client_impl.h"
+#include "impl/transactions/transactions_impl.h"
+
+using namespace ignite::impl::thin::transactions;
+using namespace ignite::common::concurrent;
 
 namespace ignite
 {
@@ -29,11 +33,15 @@ namespace ignite
         {
             namespace cache
             {
+                typedef SharedPointer<TransactionImpl> SP_TransactionImpl;
+
                 CacheClientImpl::CacheClientImpl(
                         const SP_DataRouter& router,
+                        const transactions::SP_TransactionsImpl& tx,
                         const std::string& name,
                         int32_t id) :
                     router(router),
+                    tx(tx),
                     name(name),
                     id(id),
                     binary(false)
@@ -91,9 +99,24 @@ namespace ignite
                         throw IgniteError(IgniteError::IGNITE_ERR_CACHE, rsp.GetError().c_str());
                 }
 
+                template<typename ReqT>
+                void CacheClientImpl::checkTransactional(ReqT& req)
+                {
+                    SP_TransactionImpl activeTx = tx.Get()->GetCurrent();
+
+                    bool isUnderTx = activeTx.IsValid();
+
+                    int32_t txId = isUnderTx ? activeTx.Get()->TxId() : 0;
+
+                    req.activeTx(isUnderTx, txId);
+                }
+
                 void CacheClientImpl::Put(const WritableKey& key, const Writable& value)
                 {
                     Cache2ValueRequest<RequestType::CACHE_PUT> req(id, binary, key, value);
+
+                    checkTransactional(req);
+
                     Response rsp;
 
                     SyncCacheKeyMessage(key, req, rsp);
@@ -102,6 +125,9 @@ namespace ignite
                 void CacheClientImpl::Get(const WritableKey& key, Readable& value)
                 {
                     CacheValueRequest<RequestType::CACHE_GET> req(id, binary, key);
+
+                    checkTransactional(req);
+
                     CacheValueResponse rsp(value);
 
                     SyncCacheKeyMessage(key, req, rsp);
@@ -110,6 +136,9 @@ namespace ignite
                 void CacheClientImpl::PutAll(const Writable & pairs)
                 {
                     CacheValueRequest<RequestType::CACHE_PUT_ALL> req(id, binary, pairs);
+
+                    checkTransactional(req);
+
                     Response rsp;
 
                     SyncMessage(req, rsp);
@@ -118,6 +147,9 @@ namespace ignite
                 void CacheClientImpl::GetAll(const Writable& keys, Readable& pairs)
                 {
                     CacheValueRequest<RequestType::CACHE_GET_ALL> req(id, binary, keys);
+
+                    checkTransactional(req);
+
                     CacheValueResponse rsp(pairs);
 
                     SyncMessage(req, rsp);
@@ -126,6 +158,9 @@ namespace ignite
                 bool CacheClientImpl::Replace(const WritableKey& key, const Writable& value)
                 {
                     Cache2ValueRequest<RequestType::CACHE_REPLACE> req(id, binary, key, value);
+
+                    checkTransactional(req);
+
                     BoolResponse rsp;
 
                     SyncCacheKeyMessage(key, req, rsp);
@@ -136,6 +171,9 @@ namespace ignite
                 bool CacheClientImpl::ContainsKey(const WritableKey& key)
                 {
                     CacheValueRequest<RequestType::CACHE_CONTAINS_KEY> req(id, binary, key);
+
+                    checkTransactional(req);
+
                     BoolResponse rsp;
 
                     SyncCacheKeyMessage(key, req, rsp);
@@ -146,6 +184,9 @@ namespace ignite
                 bool CacheClientImpl::ContainsKeys(const Writable& keys)
                 {
                     CacheValueRequest<RequestType::CACHE_CONTAINS_KEYS> req(id, binary, keys);
+
+                    checkTransactional(req);
+
                     BoolResponse rsp;
 
                     SyncMessage(req, rsp);
@@ -156,6 +197,9 @@ namespace ignite
                 int64_t CacheClientImpl::GetSize(int32_t peekModes)
                 {
                     CacheGetSizeRequest req(id, binary, peekModes);
+
+                    checkTransactional(req);
+
                     Int64Response rsp;
 
                     SyncMessage(req, rsp);
@@ -166,6 +210,9 @@ namespace ignite
                 bool CacheClientImpl::Remove(const WritableKey& key)
                 {
                     CacheValueRequest<RequestType::CACHE_REMOVE_KEY> req(id, binary, key);
+
+                    checkTransactional(req);
+
                     BoolResponse rsp;
 
                     SyncCacheKeyMessage(key, req, rsp);
@@ -176,6 +223,9 @@ namespace ignite
                 bool CacheClientImpl::Remove(const WritableKey& key, const Writable& val)
                 {
                     Cache2ValueRequest<RequestType::CACHE_REMOVE_IF_EQUALS> req(id, binary, key, val);
+
+                    checkTransactional(req);
+
                     BoolResponse rsp;
 
                     SyncCacheKeyMessage(key, req, rsp);
@@ -186,6 +236,9 @@ namespace ignite
                 void CacheClientImpl::RemoveAll(const Writable& keys)
                 {
                     CacheValueRequest<RequestType::CACHE_REMOVE_KEYS> req(id, binary, keys);
+
+                    checkTransactional(req);
+
                     Response rsp;
 
                     SyncMessage(req, rsp);
@@ -194,6 +247,9 @@ namespace ignite
                 void CacheClientImpl::RemoveAll()
                 {
                     CacheRequest<RequestType::CACHE_REMOVE_ALL> req(id, binary);
+
+                    checkTransactional(req);
+
                     Response rsp;
 
                     SyncMessage(req, rsp);
@@ -202,6 +258,9 @@ namespace ignite
                 void CacheClientImpl::Clear(const WritableKey& key)
                 {
                     CacheValueRequest<RequestType::CACHE_CLEAR_KEY> req(id, binary, key);
+
+                    checkTransactional(req);
+
                     Response rsp;
 
                     SyncCacheKeyMessage(key, req, rsp);
@@ -210,6 +269,9 @@ namespace ignite
                 void CacheClientImpl::Clear()
                 {
                     CacheRequest<RequestType::CACHE_CLEAR> req(id, binary);
+
+                    checkTransactional(req);
+
                     Response rsp;
 
                     SyncMessage(req, rsp);
@@ -218,6 +280,9 @@ namespace ignite
                 void CacheClientImpl::ClearAll(const Writable& keys)
                 {
                     CacheValueRequest<RequestType::CACHE_CLEAR_KEYS> req(id, binary, keys);
+
+                    checkTransactional(req);
+
                     Response rsp;
 
                     SyncMessage(req, rsp);
@@ -226,6 +291,9 @@ namespace ignite
                 void CacheClientImpl::LocalPeek(const WritableKey& key, Readable& value)
                 {
                     CacheValueRequest<RequestType::CACHE_LOCAL_PEEK> req(id, binary, key);
+
+                    checkTransactional(req);
+
                     CacheValueResponse rsp(value);
 
                     SyncCacheKeyMessage(key, req, rsp);
@@ -234,6 +302,9 @@ namespace ignite
                 bool CacheClientImpl::Replace(const WritableKey& key, const Writable& oldVal, const Writable& newVal)
                 {
                     Cache3ValueRequest<RequestType::CACHE_REPLACE_IF_EQUALS> req(id, binary, key, oldVal, newVal);
+
+                    checkTransactional(req);
+
                     BoolResponse rsp;
 
                     SyncCacheKeyMessage(key, req, rsp);
@@ -244,6 +315,9 @@ namespace ignite
                 void CacheClientImpl::GetAndPut(const WritableKey& key, const Writable& valIn, Readable& valOut)
                 {
                     Cache2ValueRequest<RequestType::CACHE_GET_AND_PUT> req(id, binary, key, valIn);
+
+                    checkTransactional(req);
+
                     CacheValueResponse rsp(valOut);
 
                     SyncCacheKeyMessage(key, req, rsp);
@@ -252,6 +326,9 @@ namespace ignite
                 void CacheClientImpl::GetAndRemove(const WritableKey& key, Readable& valOut)
                 {
                     CacheValueRequest<RequestType::CACHE_GET_AND_REMOVE> req(id, binary, key);
+
+                    checkTransactional(req);
+
                     CacheValueResponse rsp(valOut);
 
                     SyncCacheKeyMessage(key, req, rsp);
@@ -260,6 +337,9 @@ namespace ignite
                 void CacheClientImpl::GetAndReplace(const WritableKey& key, const Writable& valIn, Readable& valOut)
                 {
                     Cache2ValueRequest<RequestType::CACHE_GET_AND_REPLACE> req(id, binary, key, valIn);
+
+                    checkTransactional(req);
+
                     CacheValueResponse rsp(valOut);
 
                     SyncCacheKeyMessage(key, req, rsp);
@@ -268,6 +348,9 @@ namespace ignite
                 bool CacheClientImpl::PutIfAbsent(const WritableKey& key, const Writable& val)
                 {
                     Cache2ValueRequest<RequestType::CACHE_PUT_IF_ABSENT> req(id, binary, key, val);
+
+                    checkTransactional(req);
+
                     BoolResponse rsp;
 
                     SyncCacheKeyMessage(key, req, rsp);
@@ -278,6 +361,9 @@ namespace ignite
                 void CacheClientImpl::GetAndPutIfAbsent(const WritableKey& key, const Writable& valIn, Readable& valOut)
                 {
                     Cache2ValueRequest<RequestType::CACHE_GET_AND_PUT_IF_ABSENT> req(id, binary, key, valIn);
+
+                    checkTransactional(req);
+
                     CacheValueResponse rsp(valOut);
 
                     SyncCacheKeyMessage(key, req, rsp);
diff --git a/modules/platforms/cpp/thin-client/src/impl/cache/cache_client_impl.h b/modules/platforms/cpp/thin-client/src/impl/cache/cache_client_impl.h
index 805f9e7988ba..e97fe17bef21 100644
--- a/modules/platforms/cpp/thin-client/src/impl/cache/cache_client_impl.h
+++ b/modules/platforms/cpp/thin-client/src/impl/cache/cache_client_impl.h
@@ -22,6 +22,7 @@
 #include <string>
 
 #include "impl/data_router.h"
+#include "impl/transactions/transactions_impl.h"
 
 namespace ignite
 {
@@ -58,6 +59,7 @@ namespace ignite
                      */
                     CacheClientImpl(
                         const SP_DataRouter& router,
+                        const transactions::SP_TransactionsImpl& tx,
                         const std::string& name,
                         int32_t id);
 
@@ -297,6 +299,9 @@ namespace ignite
                     template<typename ReqT, typename RspT>
                     void SyncCacheKeyMessage(const WritableKey& key, const ReqT& req, RspT& rsp);
 
+                    template<typename ReqT>
+                    void checkTransactional(ReqT& req);
+
                     /**
                      * Synchronously send message and receive response.
                      *
@@ -310,6 +315,9 @@ namespace ignite
                     /** Data router. */
                     SP_DataRouter router;
 
+                    /** Transactions. */
+                    transactions::SP_TransactionsImpl tx;
+
                     /** Cache name. */
                     std::string name;
 
diff --git a/modules/platforms/cpp/thin-client/src/impl/cache/cache_client_proxy.cpp b/modules/platforms/cpp/thin-client/src/impl/cache/cache_client_proxy.cpp
index 13c256b532fb..2caa976f1e7c 100644
--- a/modules/platforms/cpp/thin-client/src/impl/cache/cache_client_proxy.cpp
+++ b/modules/platforms/cpp/thin-client/src/impl/cache/cache_client_proxy.cpp
@@ -15,8 +15,6 @@
  * limitations under the License.
  */
 
-#include <ignite/impl/thin/cache/cache_client_proxy.h>
-
 #include <ignite/impl/thin/cache/cache_client_proxy.h>
 #include <impl/cache/cache_client_impl.h>
 
diff --git a/modules/platforms/cpp/thin-client/src/impl/ignite_client_impl.cpp b/modules/platforms/cpp/thin-client/src/impl/ignite_client_impl.cpp
index ab45047823ad..d531a4622663 100644
--- a/modules/platforms/cpp/thin-client/src/impl/ignite_client_impl.cpp
+++ b/modules/platforms/cpp/thin-client/src/impl/ignite_client_impl.cpp
@@ -21,6 +21,7 @@
 #include "impl/response_status.h"
 
 #include "impl/ignite_client_impl.h"
+#include "impl/transactions/transactions_impl.h"
 
 namespace ignite
 {
@@ -30,7 +31,8 @@ namespace ignite
         {
             IgniteClientImpl::IgniteClientImpl(const ignite::thin::IgniteClientConfiguration& cfg) :
                 cfg(cfg),
-                router(new DataRouter(cfg))
+                router(new DataRouter(cfg)),
+                txImpl(new transactions::TransactionsImpl(router))
             {
                 // No-op.
             }
@@ -51,7 +53,7 @@ namespace ignite
 
                 int32_t cacheId = utility::GetCacheId(name);
 
-                return MakeCacheImpl(router, name, cacheId);
+                return MakeCacheImpl(router, txImpl, name, cacheId);
             }
 
             cache::SP_CacheClientImpl IgniteClientImpl::GetOrCreateCache(const char* name)
@@ -68,7 +70,7 @@ namespace ignite
                 if (rsp.GetStatus() != ResponseStatus::SUCCESS)
                     throw IgniteError(IgniteError::IGNITE_ERR_GENERIC, rsp.GetError().c_str());
 
-                return MakeCacheImpl(router, name, cacheId);
+                return MakeCacheImpl(router, txImpl, name, cacheId);
             }
 
             cache::SP_CacheClientImpl IgniteClientImpl::CreateCache(const char* name)
@@ -85,7 +87,7 @@ namespace ignite
                 if (rsp.GetStatus() != ResponseStatus::SUCCESS)
                     throw IgniteError(IgniteError::IGNITE_ERR_GENERIC, rsp.GetError().c_str());
 
-                return MakeCacheImpl(router, name, cacheId);
+                return MakeCacheImpl(router, txImpl, name, cacheId);
             }
 
             void IgniteClientImpl::DestroyCache(const char* name)
@@ -116,10 +118,11 @@ namespace ignite
 
             common::concurrent::SharedPointer<cache::CacheClientImpl> IgniteClientImpl::MakeCacheImpl(
                 const SP_DataRouter& router,
+                const transactions::SP_TransactionsImpl& tx,
                 const std::string& name,
                 int32_t id)
             {
-                cache::SP_CacheClientImpl cache(new cache::CacheClientImpl(router, name, id));
+                cache::SP_CacheClientImpl cache(new cache::CacheClientImpl(router, tx, name, id));
 
                 return cache;
             }
diff --git a/modules/platforms/cpp/thin-client/src/impl/ignite_client_impl.h b/modules/platforms/cpp/thin-client/src/impl/ignite_client_impl.h
index 4ca67fe3af52..24d32a466365 100644
--- a/modules/platforms/cpp/thin-client/src/impl/ignite_client_impl.h
+++ b/modules/platforms/cpp/thin-client/src/impl/ignite_client_impl.h
@@ -23,6 +23,7 @@
 
 #include "impl/data_router.h"
 #include "impl/cache/cache_client_impl.h"
+#include "impl/transactions/transactions_impl.h"
 
 namespace ignite
 {
@@ -82,6 +83,12 @@ namespace ignite
                  */
                 common::concurrent::SharedPointer<cache::CacheClientImpl> CreateCache(const char* name);
 
+                /** */
+                transactions::SP_TransactionsImpl ClientTransactions() const
+                {
+                    return txImpl;
+                }
+
                 /**
                  * Destroy cache by name.
                  *
@@ -109,6 +116,7 @@ namespace ignite
                  */
                 static common::concurrent::SharedPointer<cache::CacheClientImpl> MakeCacheImpl(
                         const SP_DataRouter& router,
+                        const transactions::SP_TransactionsImpl& tx,
                         const std::string& name,
                         int32_t id);
 
@@ -125,6 +133,9 @@ namespace ignite
 
                 /** Data router. */
                 SP_DataRouter router;
+
+                /** Transactions. */
+                transactions::SP_TransactionsImpl txImpl;
             };
         }
     }
diff --git a/modules/platforms/cpp/thin-client/src/impl/message.cpp b/modules/platforms/cpp/thin-client/src/impl/message.cpp
index 39723bfa4882..5025f37d0f99 100644
--- a/modules/platforms/cpp/thin-client/src/impl/message.cpp
+++ b/modules/platforms/cpp/thin-client/src/impl/message.cpp
@@ -195,12 +195,12 @@ namespace ignite
                 value.Read(reader);
             }
 
-            void BinaryTypeGetRequest::Write(binary::BinaryWriterImpl& writer, const ProtocolVersion& ver) const
+            void BinaryTypeGetRequest::Write(binary::BinaryWriterImpl& writer, const ProtocolVersion&) const
             {
                 writer.WriteInt32(typeId);
             }
 
-            void BinaryTypePutRequest::Write(binary::BinaryWriterImpl& writer, const ProtocolVersion& ver) const
+            void BinaryTypePutRequest::Write(binary::BinaryWriterImpl& writer, const ProtocolVersion&) const
             {
                 writer.WriteInt32(snapshot.GetTypeId());
                 writer.WriteString(snapshot.GetTypeName());
@@ -338,6 +338,11 @@ namespace ignite
             {
                 value = reader.ReadInt64();
             }
+
+            void Int32Response::ReadOnSuccess(binary::BinaryReaderImpl& reader, const ProtocolVersion&)
+            {
+                value = reader.ReadInt32();
+            }
         }
     }
 }
diff --git a/modules/platforms/cpp/thin-client/src/impl/message.h b/modules/platforms/cpp/thin-client/src/impl/message.h
index 8fdb8672f26c..efeae2193e8b 100644
--- a/modules/platforms/cpp/thin-client/src/impl/message.h
+++ b/modules/platforms/cpp/thin-client/src/impl/message.h
@@ -28,6 +28,8 @@
 #include <ignite/impl/thin/writable.h>
 #include <ignite/impl/thin/readable.h>
 
+#include <ignite/thin/transactions/transaction_consts.h>
+
 #include "impl/protocol_version.h"
 #include "impl/affinity/affinity_topology_version.h"
 #include "impl/affinity/partition_awareness_group.h"
@@ -38,6 +40,11 @@ namespace ignite
     {
         namespace thin
         {
+            /** "Transactional" flag mask. */
+            #define TRANSACTIONAL_FLAG_MASK 0x02;
+
+            #define KEEP_BINARY_FLAG_MASK 0x01;
+
             /* Forward declaration. */
             class Readable;
 
@@ -151,6 +158,12 @@ namespace ignite
 
                     /** Put binary type info. */
                     PUT_BINARY_TYPE = 3003,
+
+                    /** Start new transaction. */
+                    OP_TX_START = 4000,
+
+                    /** Commit transaction. */
+                    OP_TX_END = 4001,
                 };
             };
 
@@ -344,7 +357,8 @@ namespace ignite
                  */
                 CacheRequest(int32_t cacheId, bool binary) :
                     cacheId(cacheId),
-                    binary(binary)
+                    binary(binary),
+                    actTx(false)
                 {
                     // No-op.
                 }
@@ -357,6 +371,17 @@ namespace ignite
                     // No-op.
                 }
 
+                /**
+                 * Sets transaction active flag and appropriate txId.
+                 * @param active Transaction activity flag.
+                 * @param id Transaction id.
+                 */
+                void activeTx(bool active, int32_t id) {
+                    actTx = active;
+
+                    txId = id;
+                }
+
                 /**
                  * Write request using provided writer.
                  * @param writer Writer.
@@ -364,7 +389,19 @@ namespace ignite
                 virtual void Write(binary::BinaryWriterImpl& writer, const ProtocolVersion&) const
                 {
                     writer.WriteInt32(cacheId);
-                    writer.WriteBool(binary);
+
+                    int8_t flags = 0;
+
+                    if (binary)
+                        flags |= KEEP_BINARY_FLAG_MASK;
+
+                    if (actTx)
+                        flags |= TRANSACTIONAL_FLAG_MASK;
+
+                    writer.WriteInt8(flags);
+
+                    if (actTx)
+                        writer.WriteInt32(txId);
                 }
 
             private:
@@ -373,6 +410,10 @@ namespace ignite
 
                 /** Binary flag. */
                 bool binary;
+
+                bool actTx;
+
+                int32_t txId;
             };
 
             /**
@@ -489,6 +530,15 @@ namespace ignite
                     // No-op.
                 }
 
+                /**
+                 * Sets transaction active flag and appropriate txId.
+                 * @param active Transaction activity flag.
+                 * @param id Transaction id.
+                 */
+                void activeTx(bool active, int32_t id) {
+                    CacheRequest<OpCode>::activeTx(active, id);
+                }
+
                 /**
                  * Write request using provided writer.
                  * @param writer Writer.
@@ -569,6 +619,108 @@ namespace ignite
                 const Writable& val3;
             };
 
+            /**
+             * Tx start request.
+             */
+            class TxStartRequest : public Request<RequestType::OP_TX_START>
+            {
+            public:
+                /**
+                 * Constructor.
+                 */
+                TxStartRequest(ignite::thin::transactions::TransactionConcurrency::Type conc,
+                               ignite::thin::transactions::TransactionIsolation::Type isolationLvl,
+                               int64_t tmOut, int32_t sz, ignite::common::concurrent::SharedPointer<common::FixedSizeArray<char> > lbl) :
+                    concurrency(conc),
+                    isolation(isolationLvl),
+                    timeout(tmOut),
+                    size(sz),
+                    label(lbl)
+                {
+                    // No-op.
+                }
+
+                /**
+                 * Destructor.
+                 */
+                virtual ~TxStartRequest()
+                {
+                    // No-op.
+                }
+
+                /**
+                 * Write request using provided writer.
+                 * @param writer Writer.
+                 * @param ver Version.
+                 */
+                virtual void Write(binary::BinaryWriterImpl& writer, const ProtocolVersion&) const {
+                    writer.WriteInt8(concurrency);
+                    writer.WriteInt8(isolation);
+                    writer.WriteInt64(timeout);
+                    label.IsValid() ? writer.WriteString(label.Get()->GetData()) : writer.WriteNull();
+                }
+
+            private:
+                /** Cncurrency. */
+                ignite::thin::transactions::TransactionConcurrency::Type concurrency;
+
+                /** Isolation. */
+                ignite::thin::transactions::TransactionIsolation::Type isolation;
+
+                /** Timeout. */
+                const int64_t timeout;
+
+                /** Size. */
+                const int32_t size;
+
+                /** Tx label. */
+                ignite::common::concurrent::SharedPointer<common::FixedSizeArray<char> > label;
+            };
+
+            /**
+             * Tx end request.
+             */
+            class TxEndRequest : public Request<RequestType::OP_TX_END>
+            {
+            public:
+                /**
+                 * Constructor.
+                 *
+                 * @param id Transaction id.
+                 * @param comm Need to commit flag.
+                 */
+                TxEndRequest(int32_t id, bool comm) :
+                    commited(comm),
+                    txId(id)
+                {
+                }
+
+                /**
+                 * Destructor.
+                 */
+                virtual ~TxEndRequest()
+                {
+                    // No-op.
+                }
+
+                /**
+                 * Write request using provided writer.
+                 * @param writer Writer.
+                 * @param ver Version.
+                 */
+                virtual void Write(binary::BinaryWriterImpl& writer, const ProtocolVersion&) const {
+                    writer.WriteInt32(txId);
+                    writer.WriteBool(commited);
+                }
+
+            private:
+                /** Tx id. */
+                const int32_t txId;
+
+                /** Need to commit flag. */
+                const bool commited;
+            };
+
             /**
              * Cache get binary type request.
              */
@@ -1010,6 +1162,51 @@ namespace ignite
                 /** Value. */
                 int64_t value;
             };
+
+            /**
+             * Get cache names response.
+             */
+            class Int32Response : public Response
+            {
+            public:
+                /**
+                 * Constructor.
+                 */
+                Int32Response() :
+                    value(0)
+                {
+                    // No-op.
+                }
+
+                /**
+                 * Destructor.
+                 */
+                virtual ~Int32Response()
+                {
+                    // No-op.
+                }
+
+                /**
+                 * Get received value.
+                 *
+                 * @return Received bool value.
+                 */
+                int32_t GetValue() const
+                {
+                    return value;
+                }
+
+                /**
+                 * Read data if response status is ResponseStatus::SUCCESS.
+                 *
+                 * @param reader Reader.
+                 */
+                virtual void ReadOnSuccess(binary::BinaryReaderImpl& reader, const ProtocolVersion&);
+
+            private:
+                /** Value. */
+                int32_t value;
+            };
         }
     }
 }
diff --git a/modules/platforms/cpp/thin-client/src/impl/transactions/transaction_impl.h b/modules/platforms/cpp/thin-client/src/impl/transactions/transaction_impl.h
new file mode 100644
index 000000000000..fc8d2b7bf158
--- /dev/null
+++ b/modules/platforms/cpp/thin-client/src/impl/transactions/transaction_impl.h
@@ -0,0 +1,183 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _IGNITE_IMPL_THIN_TRANSACTION_IMPL
+#define _IGNITE_IMPL_THIN_TRANSACTION_IMPL
+
+#include "impl/data_router.h"
+#include <ignite/common/fixed_size_array.h>
+#include "ignite/thin/transactions/transaction_consts.h"
+#include "impl/transactions/transactions_impl.h"
+
+namespace ignite
+{
+    namespace impl
+    {
+        namespace thin
+        {
+            namespace transactions
+            {
+                /* Forward declaration. */
+                class TransactionImpl;
+
+                /* Forward declaration. */
+                class TransactionsImpl;
+
+                typedef ignite::common::concurrent::SharedPointer<TransactionImpl> SP_TransactionImpl;
+
+                /**
+                 * Ignite transactions implementation.
+                 *
+                 * This is an entry point for Thin C++ Ignite transactions.
+                 */
+                class TransactionImpl
+                {
+                public:
+                    /**
+                     * Constructor.
+                     *
+                     * @param txImpl Transactions implementation.
+                     * @param txid Transaction Id.
+                     * @param concurrency Transaction concurrency.
+                     * @param isolation Transaction isolation.
+                     * @param timeout Transaction timeout.
+                     * @param size Number of entries participating in transaction (may be approximate).
+                     */
+                    TransactionImpl(
+                            TransactionsImpl& txImpl,
+                            int32_t txid,
+                            ignite::thin::transactions::TransactionConcurrency::Type concurrency,
+                            ignite::thin::transactions::TransactionIsolation::Type isolation,
+                            int64_t timeout,
+                            int32_t size) :
+                        txs(txImpl),
+                        txId(txid),
+                        concurrency(concurrency),
+                        isolation(isolation),
+                        timeout(timeout),
+                        txSize(size),
+                        closed(false)
+                    {
+                        // No-op.
+                    }
+
+                    /**
+                     * Destructor.
+                     */
+                    ~TransactionImpl()
+                    {
+                        if (!IsClosed())
+                            Close();
+                    }
+
+                    /**
+                     * Commits this transaction.
+                     */
+                    void Commit();
+
+                    /**
+                     * Rolls back this transaction.
+                     */
+                    void Rollback();
+
+                    /**
+                     * Ends the transaction. Transaction will be rolled back if it has not been committed.
+                     */
+                    void Close();
+
+                    /**
+                     * @return Current transaction Id.
+                     */
+                    int32_t TxId() const
+                    {
+                        return txId;
+                    }
+
+                    /**
+                     * Check if the transaction has been closed.
+                     *
+                     * @return True if the transaction has been closed.
+                     */
+                    bool IsClosed() const;
+
+                    /**
+                     * Sets close flag to tx.
+                     */
+                    void Closed();
+
+                    /**
+                     * @return Current transaction.
+                     */
+                    static SP_TransactionImpl GetCurrent();
+
+                    /**
+                     * Starts transaction.
+                     *
+                     * @param txs Transactions implementation.
+                     * @param concurrency Transaction concurrency.
+                     * @param isolation Transaction isolation.
+                     * @param timeout Transaction timeout.
+                     * @param txSize Number of entries participating in transaction (may be approximate).
+                     * @param label Transaction specific label.
+                     */
+                    static SP_TransactionImpl Create(
+                            TransactionsImpl& txs,
+                            ignite::thin::transactions::TransactionConcurrency::Type concurrency,
+                            ignite::thin::transactions::TransactionIsolation::Type isolation,
+                            int64_t timeout,
+                            int32_t txSize,
+                            ignite::common::concurrent::SharedPointer<common::FixedSizeArray<char> > label);
+                protected:
+                    /** Checks current thread state. */
+                    static void txThreadCheck(const TransactionImpl& tx);
+
+                    /** Completes tc and clear state from storage. */
+                    static void txThreadEnd(TransactionImpl& tx);
+
+                private:
+                    /** Transactions implementation. */
+                    TransactionsImpl& txs;
+
+                    /** Current transaction Id. */
+                    int32_t txId;
+
+                    /** Thread local instance of the transaction. */
+                    static ignite::common::concurrent::ThreadLocalInstance<SP_TransactionImpl> threadTx;
+
+                    /** Concurrency. */
+                    int concurrency;
+
+                    /** Isolation. */
+                    int isolation;
+
+                    /** Timeout in milliseconds. */
+                    int64_t timeout;
+
+                    /** Transaction size. */
+                    int32_t txSize;
+
+                    /** Closed flag. */
+                    bool closed;
+
+                    IGNITE_NO_COPY_ASSIGNMENT(TransactionImpl)
+                };
+            }
+        }
+    }
+}
+
+#endif // _IGNITE_IMPL_THIN_TRANSACTION_IMPL
diff --git a/modules/platforms/cpp/thin-client/src/impl/transactions/transactions_impl.cpp b/modules/platforms/cpp/thin-client/src/impl/transactions/transactions_impl.cpp
new file mode 100644
index 000000000000..a4ff32e520a7
--- /dev/null
+++ b/modules/platforms/cpp/thin-client/src/impl/transactions/transactions_impl.cpp
@@ -0,0 +1,214 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "impl/message.h"
+#include "impl/transactions/transactions_impl.h"
+#include "impl/transactions/transaction_impl.h"
+#include "impl/response_status.h"
+
+using namespace ignite::common::concurrent;
+using namespace ignite::impl::thin;
+using namespace ignite::thin::transactions;
+
+namespace ignite
+{
+    namespace impl
+    {
+        namespace thin
+        {
+            namespace transactions
+            {
+                ThreadLocalInstance<SP_TransactionImpl> TransactionImpl::threadTx;
+
+                TransactionsImpl::TransactionsImpl(const SP_DataRouter& router) :
+                    router(router)
+                {
+                }
+
+                template<typename ReqT, typename RspT>
+                void TransactionsImpl::SendTxMessage(const ReqT& req, RspT& rsp)
+                {
+                    router.Get()->SyncMessage(req, rsp);
+
+                    if (rsp.GetStatus() != ResponseStatus::SUCCESS)
+                        throw IgniteError(IgniteError::IGNITE_ERR_TX, rsp.GetError().c_str());
+                }
+
+                SharedPointer<TransactionImpl> TransactionsImpl::TxStart(
+                        TransactionConcurrency::Type concurrency,
+                        TransactionIsolation::Type isolation,
+                        int64_t timeout,
+                        int32_t txSize,
+                        SharedPointer<common::FixedSizeArray<char> > label)
+                {
+                    SP_TransactionImpl tx = TransactionImpl::Create(*this, concurrency, isolation, timeout, txSize, label);
+
+                    return tx;
+                }
+
+                SP_TransactionImpl TransactionImpl::Create(
+                    TransactionsImpl& txs,
+                    TransactionConcurrency::Type concurrency,
+                    TransactionIsolation::Type isolation,
+                    int64_t timeout,
+                    int32_t txSize,
+                    SharedPointer<common::FixedSizeArray<char> > label)
+                {
+                    SP_TransactionImpl tx = threadTx.Get();
+
+                    TransactionImpl* ptr = tx.Get();
+
+                    if (ptr && !ptr->IsClosed())
+                    {
+                        throw IgniteError(IgniteError::IGNITE_ERR_TX_THIS_THREAD, TX_ALREADY_STARTED);
+                    }
+
+                    TxStartRequest req(concurrency, isolation, timeout, txSize, label);
+
+                    Int32Response rsp;
+
+                    txs.SendTxMessage(req, rsp);
+
+                    int32_t curTxId = rsp.GetValue();
+
+                    tx = SP_TransactionImpl(new TransactionImpl(txs, curTxId, concurrency, isolation, timeout, txSize));
+
+                    threadTx.Set(tx);
+
+                    return tx;
+                }
+
+                SP_TransactionImpl TransactionImpl::GetCurrent()
+                {
+                    SP_TransactionImpl tx = threadTx.Get();
+
+                    TransactionImpl* ptr = tx.Get();
+
+                    if (ptr)
+                    {
+                        if (ptr->IsClosed())
+                        {
+                            tx = SP_TransactionImpl();
+
+                            threadTx.Remove();
+                        }
+                    }
+                    else
+                    {
+                        tx = SP_TransactionImpl();
+                    }
+
+                    return tx;
+                }
+
+                bool TransactionImpl::IsClosed() const
+                {
+                    return closed;
+                }
+
+                SP_TransactionImpl TransactionsImpl::GetCurrent()
+                {
+                    return TransactionImpl::GetCurrent();
+                }
+
+                int32_t TransactionsImpl::TxCommit(int32_t txId)
+                {
+                    TxEndRequest req(txId, true);
+
+                    Response rsp;
+
+                    SendTxMessage(req, rsp);
+
+                    return rsp.GetStatus();
+                }
+
+                int32_t TransactionsImpl::TxRollback(int32_t txId)
+                {
+                    TxEndRequest req(txId, false);
+
+                    Response rsp;
+
+                    SendTxMessage(req, rsp);
+
+                    return rsp.GetStatus();
+                }
+
+                int32_t TransactionsImpl::TxClose(int32_t txId)
+                {
+                    return TxRollback(txId);
+                }
+
+                void TransactionImpl::Commit()
+                {
+                    txThreadCheck(*this);
+
+                    txs.TxCommit(txId);
+
+                    txThreadEnd(*this);
+                }
+
+                void TransactionImpl::Rollback()
+                {
+                    txThreadCheck(*this);
+
+                    txs.TxRollback(txId);
+
+                    txThreadEnd(*this);
+                }
+
+                void TransactionImpl::Close()
+                {
+                    txThreadCheck(*this);
+
+                    if (IsClosed())
+                    {
+                        return;
+                    }
+
+                    txs.TxClose(txId);
+
+                    txThreadEnd(*this);
+                }
+
+                void TransactionImpl::Closed()
+                {
+                    closed = true;
+                }
+
+                void TransactionImpl::txThreadEnd(TransactionImpl& tx)
+                {
+                    tx.Closed();
+
+                    threadTx.Set(0);
+                }
+
+                void TransactionImpl::txThreadCheck(const TransactionImpl& inTx)
+                {
+                    SP_TransactionImpl tx = threadTx.Get();
+
+                    TransactionImpl* ptr = tx.Get();
+
+                    if (!ptr)
+                        throw IgniteError(IgniteError::IGNITE_ERR_TX_THIS_THREAD, TX_ALREADY_CLOSED);
+
+                    if (ptr->TxId() != inTx.TxId())
+                        throw IgniteError(IgniteError::IGNITE_ERR_TX_THIS_THREAD, TX_DIFFERENT_THREAD);
+                }
+            }
+        }
+    }
+}
diff --git a/modules/platforms/cpp/thin-client/src/impl/transactions/transactions_impl.h b/modules/platforms/cpp/thin-client/src/impl/transactions/transactions_impl.h
new file mode 100644
index 000000000000..2f5282bc5b35
--- /dev/null
+++ b/modules/platforms/cpp/thin-client/src/impl/transactions/transactions_impl.h
@@ -0,0 +1,129 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _IGNITE_IMPL_THIN_TRANSACTIONS_IMPL
+#define _IGNITE_IMPL_THIN_TRANSACTIONS_IMPL
+
+#include "impl/data_router.h"
+#include <ignite/common/fixed_size_array.h>
+#include "ignite/thin/transactions/transaction_consts.h"
+#include "impl/transactions/transaction_impl.h"
+
+namespace ignite
+{
+    namespace impl
+    {
+        namespace thin
+        {
+            namespace transactions
+            {
+                class TransactionsImpl;
+
+                typedef ignite::common::concurrent::SharedPointer<TransactionImpl> SP_TransactionImpl;
+                typedef ignite::common::concurrent::SharedPointer<TransactionsImpl> SP_TransactionsImpl;
+
+                /**
+                 * Thin client transaction.
+                 */
+                class TransactionsImpl
+                {
+                public:
+                    /**
+                     * Constructor.
+                     *
+                     * @param router Data router instance.
+                     */
+                    TransactionsImpl(const SP_DataRouter& router);
+
+                    /**
+                     * Destructor.
+                     */
+                    ~TransactionsImpl() {}
+
+                    /**
+                     * Start new transaction.
+                     *
+                     * @param concurrency Concurrency.
+                     * @param isolation Isolation.
+                     * @param timeout Timeout in milliseconds. Zero if for infinite timeout.
+                     * @param txSize Number of entries participating in transaction (may be approximate).
+                     * @param label Transaction specific label.
+                     * @return Transaction ID on success.
+                     */
+                    SP_TransactionImpl TxStart(
+                            ignite::thin::transactions::TransactionConcurrency::Type concurrency,
+                            ignite::thin::transactions::TransactionIsolation::Type isolation,
+                            int64_t timeout,
+                            int32_t txSize,
+                            ignite::common::concurrent::SharedPointer<common::FixedSizeArray<char> > label);
+
+                    /**
+                     * Commit Transaction.
+                     *
+                     * @param id Transaction ID.
+                     * @return Resulting state.
+                     */
+                    int32_t TxCommit(int32_t id);
+
+                    /**
+                     * Rollback Transaction.
+                     *
+                     * @param id Transaction ID.
+                     * @return Resulting state.
+                     */
+                    int32_t TxRollback(int32_t id);
+
+
+                    /**
+                     * Close the transaction.
+                     *
+                     * This method should only be used on the valid instance.
+                     *
+                     * @param id Transaction ID.
+                     */
+                    int32_t TxClose(int32_t id);
+
+                    /**
+                     * Get active transaction for the current thread.
+                     *
+                     * @return Active transaction implementation for current thread
+                     * or null pointer if there is no active transaction for
+                     * the thread.
+                     */
+                    SP_TransactionImpl GetCurrent();
+
+                    /**
+                     * Synchronously send message and receive response.
+                     *
+                     * @param req Request message.
+                     * @param rsp Response message.
+                     * @throw IgniteError on error.
+                     */
+                    template<typename ReqT, typename RspT>
+                    void SendTxMessage(const ReqT& req, RspT& rsp);
+                private:
+                    /** Data router. */
+                    SP_DataRouter router;
+
+                    IGNITE_NO_COPY_ASSIGNMENT(TransactionsImpl)
+                };
+            }
+        }
+    }
+}
+
+#endif // _IGNITE_IMPL_THIN_TRANSACTIONS_IMPL
diff --git a/modules/platforms/cpp/thin-client/src/impl/transactions/transactions_proxy.cpp b/modules/platforms/cpp/thin-client/src/impl/transactions/transactions_proxy.cpp
new file mode 100644
index 000000000000..e04766a26c5d
--- /dev/null
+++ b/modules/platforms/cpp/thin-client/src/impl/transactions/transactions_proxy.cpp
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "ignite/impl/thin/transactions/transactions_proxy.h"
+#include "impl/transactions/transactions_impl.h"
+
+using namespace ignite::impl::thin;
+using namespace transactions;
+using namespace ignite::thin::transactions;
+
+namespace
+{
+    using namespace ignite::common::concurrent;
+
+    TransactionsImpl& GetTxsImpl(SharedPointer<void>& ptr)
+    {
+        return *reinterpret_cast<TransactionsImpl*>(ptr.Get());
+    }
+
+    TransactionImpl& GetTxImpl(SharedPointer<void>& ptr)
+    {
+        return *reinterpret_cast<TransactionImpl*>(ptr.Get());
+    }
+}
+
+namespace ignite
+{
+    namespace impl
+    {
+        namespace thin
+        {
+            namespace transactions
+            {
+                TransactionProxy TransactionsProxy::txStart(
+                        TransactionConcurrency::Type concurrency,
+                        TransactionIsolation::Type isolation,
+                        int64_t timeout,
+                        int32_t txSize,
+                        SharedPointer<ignite::common::FixedSizeArray<char> > lbl)
+                {
+                    return TransactionProxy(GetTxsImpl(impl).TxStart(concurrency, isolation, timeout, txSize, lbl));
+                }
+
+                void TransactionProxy::commit()
+                {
+                    GetTxImpl(impl).Commit();
+                }
+
+                void TransactionProxy::rollback()
+                {
+                    GetTxImpl(impl).Rollback();
+                }
+
+                void TransactionProxy::close()
+                {
+                    try
+                    {
+                        GetTxImpl(impl).Close();
+                    }
+                    catch (...)
+                    {
+                        //No-op, we can`t throw any exceptions here.
+                    }
+                }
+            }
+        }
+    }
+}
diff --git a/modules/platforms/dotnet/Apache.Ignite.BenchmarkDotNet/Program.cs b/modules/platforms/dotnet/Apache.Ignite.BenchmarkDotNet/Program.cs
index 624f7200d8e1..d9f53d4dc572 100644
--- a/modules/platforms/dotnet/Apache.Ignite.BenchmarkDotNet/Program.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.BenchmarkDotNet/Program.cs
@@ -30,7 +30,7 @@ public static class Program
         /// </summary>
         public static void Main()
         {
-            BenchmarkRunner.Run<ThinClientCachePutBenchmark>();
+            BenchmarkRunner.Run<ThinClientServicesBenchmark>();
         }
     }
 }
diff --git a/modules/jms11/src/main/java/org/apache/ignite/stream/jms11/MessageTransformer.java b/modules/platforms/dotnet/Apache.Ignite.BenchmarkDotNet/ThinClient/Services/BenchService.cs
similarity index 51%
rename from modules/jms11/src/main/java/org/apache/ignite/stream/jms11/MessageTransformer.java
rename to modules/platforms/dotnet/Apache.Ignite.BenchmarkDotNet/ThinClient/Services/BenchService.cs
index 568040bf99e4..d5fed7a10bd6 100644
--- a/modules/jms11/src/main/java/org/apache/ignite/stream/jms11/MessageTransformer.java
+++ b/modules/platforms/dotnet/Apache.Ignite.BenchmarkDotNet/ThinClient/Services/BenchService.cs
@@ -15,27 +15,37 @@
  * limitations under the License.
  */
 
-package org.apache.ignite.stream.jms11;
+namespace Apache.Ignite.BenchmarkDotNet.ThinClient.Services
+{
+    using Apache.Ignite.Core.Services;
 
-import java.util.Map;
-import javax.jms.Message;
-import org.jetbrains.annotations.Nullable;
+    /// <summary>
+    /// Benchmark service.
+    /// </summary>
+    public class BenchService : IService, IBenchService
+    {
+        /** <inheritdoc /> */
+        public int Add(int x, int y)
+        {
+            return x + y;
+        }
 
-/**
- * Implement this interface to transform from a {@link Message} to a set of cache entries in the form of a {@link Map}.
- *
- * @param <T> The type of JMS Message.
- * @param <K> The type of the cache key.
- * @param <V> The type of the cache value.
- * @author Raul Kripalani
- */
-public interface MessageTransformer<T extends Message, K, V> {
-    /**
-     * Transformation function.
-     *
-     * @param message The message received from the JMS broker.
-     * @return Set of cache entries to add to the cache. It could be empty or null if the message should be skipped.
-     */
-    @Nullable Map<K, V> apply(T message);
+        /** <inheritdoc /> */
+        public void Init(IServiceContext context)
+        {
+            // No-op.
+        }
+
+        /** <inheritdoc /> */
+        public void Execute(IServiceContext context)
+        {
+            // No-op.
+        }
 
+        /** <inheritdoc /> */
+        public void Cancel(IServiceContext context)
+        {
+            // No-op.
+        }
+    }
 }
diff --git a/modules/jms11/src/test/java/org/apache/ignite/stream/jms11/IgniteJmsStreamerTestSuite.java b/modules/platforms/dotnet/Apache.Ignite.BenchmarkDotNet/ThinClient/Services/IBenchService.cs
similarity index 72%
rename from modules/jms11/src/test/java/org/apache/ignite/stream/jms11/IgniteJmsStreamerTestSuite.java
rename to modules/platforms/dotnet/Apache.Ignite.BenchmarkDotNet/ThinClient/Services/IBenchService.cs
index 303b6b21d919..5f780ae0ecc5 100644
--- a/modules/jms11/src/test/java/org/apache/ignite/stream/jms11/IgniteJmsStreamerTestSuite.java
+++ b/modules/platforms/dotnet/Apache.Ignite.BenchmarkDotNet/ThinClient/Services/IBenchService.cs
@@ -15,20 +15,13 @@
  * limitations under the License.
  */
 
-package org.apache.ignite.stream.jms11;
-
-import org.junit.runner.RunWith;
-import org.junit.runners.Suite;
-
-/**
- * JMS streamer tests.
- *
- * @author Raul Kripalani
- */
-@RunWith(Suite.class)
-@Suite.SuiteClasses({
-    IgniteJmsStreamerTest.class
-})
-public class IgniteJmsStreamerTestSuite {
-    // No-op.
+namespace Apache.Ignite.BenchmarkDotNet.ThinClient.Services
+{
+    /// <summary>
+    /// Benchmark service interface.
+    /// </summary>
+    public interface IBenchService
+    {
+        int Add(int x, int y);
+    }
 }
diff --git a/modules/platforms/dotnet/Apache.Ignite.BenchmarkDotNet/ThinClient/ThinClientServicesBenchmark.cs b/modules/platforms/dotnet/Apache.Ignite.BenchmarkDotNet/ThinClient/ThinClientServicesBenchmark.cs
new file mode 100644
index 000000000000..431e8e3cea95
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.BenchmarkDotNet/ThinClient/ThinClientServicesBenchmark.cs
@@ -0,0 +1,99 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.BenchmarkDotNet.ThinClient
+{
+    using System;
+    using Apache.Ignite.BenchmarkDotNet.ThinClient.Services;
+    using Apache.Ignite.Core;
+    using global::BenchmarkDotNet.Attributes;
+
+    /// <summary>
+    /// Thin client services benchmark.
+    /// <para />
+    /// |        Method  |     Mean |    Error |   StdDev |  Gen 0 | Gen 1 | Gen 2 | Allocated |
+    /// |--------------- |---------:|---------:|---------:|-------:|------:|------:|----------:|
+    /// | IntMethodThin  | 31.61 us | 0.627 us | 1.539 us | 0.3052 |     - |     - |   1.85 KB |
+    /// | IntMethodThick | 130.5 us | 27.65 us | 79.33 us | 0.1221 |     - |     - |   1.47 KB |
+    /// </summary>
+    [MemoryDiagnoser]
+    public class ThinClientServicesBenchmark : ThinClientBenchmarkBase
+    {
+        /** */
+        private const string ServiceName = nameof(BenchService);
+
+        /** */
+        private IIgnite ThickClient { get; set; }
+
+        /** */
+        private IBenchService ThickService { get; set; }
+
+        /** */
+        private IBenchService ThinService { get; set; }
+
+        /** <inheritdoc /> */
+        public override void GlobalSetup()
+        {
+            base.GlobalSetup();
+
+            var services = Ignite.GetServices();
+            services.DeployClusterSingleton(ServiceName, new BenchService());
+
+            var clientCfg = new IgniteConfiguration(Utils.GetIgniteConfiguration())
+            {
+                ClientMode = true,
+                IgniteInstanceName = "Client"
+            };
+
+            ThickClient = Ignition.Start(clientCfg);
+
+            ThickService = ThickClient.GetServices().GetServiceProxy<IBenchService>(ServiceName);
+            ThinService = Client.GetServices().GetServiceProxy<IBenchService>(ServiceName);
+        }
+
+        /** <inheritdoc /> */
+        public override void GlobalCleanup()
+        {
+            ThickClient.Dispose();
+            base.GlobalCleanup();
+        }
+
+        /** */
+        [Benchmark]
+        public void IntMethodThin()
+        {
+            var res = ThinService.Add(2, 3);
+
+            if (res != 5)
+            {
+                throw new Exception();
+            }
+        }
+
+        /** */
+        [Benchmark]
+        public void IntMethodThick()
+        {
+            var res = ThickService.Add(2, 3);
+
+            if (res != 5)
+            {
+                throw new Exception();
+            }
+        }
+    }
+}
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Apache.Ignite.Core.Tests.csproj b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Apache.Ignite.Core.Tests.csproj
index c92cd0a266b9..e4b27a9b59c0 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Apache.Ignite.Core.Tests.csproj
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Apache.Ignite.Core.Tests.csproj
@@ -188,6 +188,16 @@
     <Compile Include="Client\RawSocketTest.cs" />
     <Compile Include="Client\ClientConnectionTest.cs" />
     <Compile Include="Client\IgniteClientConfigurationTest.cs" />
+    <Compile Include="Client\Services\ITestService.cs" />
+    <Compile Include="Client\Services\ITestServiceClient.cs" />
+    <Compile Include="Client\Services\ITestServiceDataTypes.cs" />
+    <Compile Include="Client\Services\ITestServiceGenericMethods.cs" />
+    <Compile Include="Client\Services\ITestServiceOverloads.cs" />
+    <Compile Include="Client\Services\ServicesClientTest.cs" />
+    <Compile Include="Client\Services\TestService.cs" />
+    <Compile Include="Client\Services\TestServiceDataTypes.cs" />
+    <Compile Include="Client\Services\TestServiceGenericMethods.cs" />
+    <Compile Include="Client\Services\TestServiceOverloads.cs" />
     <Compile Include="Common\IgniteProductVersionTests.cs" />
     <Compile Include="Compute\ComputeApiTest.JavaTask.cs" />
     <Compile Include="Compute\ComputeWithExecutorTest.cs" />
@@ -263,6 +273,7 @@
     <Compile Include="Plugin\TestIgnitePluginConfiguration.cs" />
     <Compile Include="Plugin\TestIgnitePluginException.cs" />
     <Compile Include="Plugin\TestIgnitePluginProvider.cs" />
+    <Compile Include="Services\IJavaService.cs" />
     <Compile Include="Ssl\SslConfigurationTest.cs" />
     <Compile Include="TaskExtensions.cs" />
     <Compile Include="TestAppConfig.cs" />
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Compute/ComputeClientTests.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Compute/ComputeClientTests.cs
index f46468e6e277..b24ee58f9320 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Compute/ComputeClientTests.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Compute/ComputeClientTests.cs
@@ -315,12 +315,14 @@ public void TestExecuteJavaTaskWithClusterGroup()
             var nodeIds = Client.GetCluster().GetNodes().Select(n => n.Id).ToArray();
 
             CollectionAssert.AreEquivalent(nodeIds, getProjection(Client.GetCompute()));
+            Assert.AreSame(Client.GetCluster(), Client.GetCompute().ClusterGroup);
 
             // One node.
             var nodeId = nodeIds[1];
             var proj = Client.GetCluster().ForPredicate(n => n.Id == nodeId);
 
             Assert.AreEqual(new[]{nodeId}, getProjection(proj.GetCompute()));
+            Assert.AreEqual(new[]{nodeId}, proj.GetCompute().ClusterGroup.GetNodes().Select(n => n.Id));
 
             // Two nodes.
             proj = Client.GetCluster().ForPredicate(n => n.Id != nodeId);
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestService.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestService.cs
new file mode 100644
index 000000000000..4bfba68758d2
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestService.cs
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.Core.Tests.Client.Services
+{
+    using System;
+    using System.Threading.Tasks;
+    using Apache.Ignite.Core.Binary;
+    using Apache.Ignite.Core.Tests.Client.Cache;
+
+    /// <summary>
+    /// Test service interface.
+    /// </summary>
+    public interface ITestService
+    {
+        /** */
+        int IntProperty { get; set; }
+
+        /** */
+        Person PersonProperty { get; set; }
+
+        /** */
+        void VoidMethod();
+
+        /** */
+        int IntMethod();
+
+        /** */
+        void ExceptionalMethod();
+
+        /** */
+        Task<int> AsyncMethod();
+
+        /** */
+        Person PersonMethod(Person person);
+
+        /** */
+        IBinaryObject PersonMethodBinary(IBinaryObject person);
+
+        /** */
+        Person[] PersonArrayMethod(Person[] persons);
+
+        /** */
+        IBinaryObject[] PersonArrayMethodBinary(IBinaryObject[] persons);
+
+        /** */
+        void Sleep(TimeSpan delay);
+
+        /** */
+        Guid GetNodeId();
+    }
+}
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestServiceClient.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestServiceClient.cs
new file mode 100644
index 000000000000..50d409fd3405
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestServiceClient.cs
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.Core.Tests.Client.Services
+{
+    using Apache.Ignite.Core.Binary;
+    using Apache.Ignite.Core.Tests.Client.Cache;
+
+    /// <summary>
+    /// Client-side counterpart for <see cref="ITestService"/>.
+    /// <para />
+    /// Clients can use a different service interface. Method signatures can also differ.
+    /// </summary>
+    public interface ITestServiceClient
+    {
+        /// <summary>
+        /// Counterpart for <see cref="ITestService.PersonMethodBinary"/>.
+        /// <para />
+        /// Client-side interface operates on <see cref="Person"/>,
+        /// but server-side method uses <see cref="IBinaryObject"/>: 
+        /// </summary>
+        Person PersonMethodBinary(Person person);
+        
+        /// <summary>
+        /// Counterpart for <see cref="ITestService.PersonMethod"/>.
+        /// </summary>
+        IBinaryObject PersonMethod(IBinaryObject person);
+    }
+}
\ No newline at end of file
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestServiceDataTypes.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestServiceDataTypes.cs
new file mode 100644
index 000000000000..761bfafefdfe
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestServiceDataTypes.cs
@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.Core.Tests.Client.Services
+{
+    using System;
+    using System.Collections.Generic;
+
+    /// <summary>
+    /// Service interface for testing various data types passing.
+    /// </summary>
+    public interface ITestServiceDataTypes
+    {
+        /** */
+        byte GetByte(byte x);
+
+        /** */
+        byte[] GetByteArray(byte[] x);
+
+        /** */
+        sbyte GetSbyte(sbyte x);
+
+        /** */
+        sbyte[] GetSbyteArray(sbyte[] x);
+
+        /** */
+        char GetChar(char x);
+
+        /** */
+        char[] GetCharArray(char[] x);
+
+        /** */
+        short GetShort(short x);
+
+        /** */
+        short[] GetShortArray(short[] x);
+
+        /** */
+        ushort GetUShort(ushort x);
+
+        /** */
+        ushort[] GetUShortArray(ushort[] x);
+
+        /** */
+        int GetInt(int x);
+
+        /** */
+        int[] GetIntArray(int[] x);
+
+        /** */
+        uint GetUInt(uint x);
+
+        /** */
+        uint[] GetUIntArray(uint[] x);
+
+        /** */
+        long GetLong(long x);
+
+        /** */
+        long[] GetLongArray(long[] x);
+
+        /** */
+        ulong GetULong(ulong x);
+
+        /** */
+        ulong[] GetULongArray(ulong[] x);
+
+        /** */
+        Guid GetGuid(Guid x);
+
+        /** */
+        Guid[] GetGuidArray(Guid[] x);
+
+        /** */
+        DateTime GetDateTime(DateTime x);
+
+        /** */
+        DateTime[] GetDateTimeArray(DateTime[] x);
+
+        /** */
+        List<DateTime> GetDateTimeList(ICollection<DateTime> x);
+
+        /** */
+        TimeSpan GetTimeSpan(TimeSpan x);
+
+        /** */
+        TimeSpan[] GetTimeSpanArray(TimeSpan[] x);
+
+        /** */
+        bool GetBool(bool x);
+
+        /** */
+        bool[] GetBoolArray(bool[] x);
+
+        /** */
+        float GetFloat(float x);
+
+        /** */
+        float[] GetFloatArray(float[] x);
+
+        /** */
+        double GetDouble(double x);
+
+        /** */
+        double[] GetDoubleArray(double[] x);
+
+        /** */
+        decimal GetDecimal(decimal x);
+
+        /** */
+        decimal[] GetDecimalArray(decimal[] x);
+
+        /** */
+        string GetString(string x);
+
+        /** */
+        string[] GetStringArray(string[] x);
+    }
+}
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestServiceGenericMethods.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestServiceGenericMethods.cs
new file mode 100644
index 000000000000..2000e47f9864
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestServiceGenericMethods.cs
@@ -0,0 +1,28 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.Core.Tests.Client.Services
+{
+    /// <summary>
+    /// Test service interface with generic methods.
+    /// </summary>
+    public interface ITestServiceGenericMethods
+    {
+        /** */
+        T GetGeneric<T>(T x);
+    }
+}
\ No newline at end of file
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestServiceOverloads.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestServiceOverloads.cs
new file mode 100644
index 000000000000..a0a9d2ea20d2
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ITestServiceOverloads.cs
@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.Core.Tests.Client.Services
+{
+    using Apache.Ignite.Core.Tests.Client.Cache;
+
+    /// <summary>
+    /// Test interface for overload resolution.
+    /// </summary>
+    public interface ITestServiceOverloads
+    {
+        /** */
+        bool Foo();
+
+        /** */
+        int Foo(int x);
+        
+        /** */
+        int Foo(uint x);
+        
+        /** */
+        int Foo(byte x);
+        
+        /** */
+        int Foo(short x);
+        
+        /** */
+        int Foo(ushort x);
+        
+        /** */
+        int Foo(Person x);
+        
+        /** */
+        int Foo(int[] x);
+        
+        /** */
+        int Foo(object[] x);
+        
+        /** */
+        int Foo(Person[] x);
+    }
+}
\ No newline at end of file
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ServicesClientTest.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ServicesClientTest.cs
new file mode 100644
index 000000000000..f74b0b40d233
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/ServicesClientTest.cs
@@ -0,0 +1,588 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.Core.Tests.Client.Services
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using Apache.Ignite.Core.Binary;
+    using Apache.Ignite.Core.Client;
+    using Apache.Ignite.Core.Client.Services;
+    using Apache.Ignite.Core.Services;
+    using Apache.Ignite.Core.Tests.Client.Cache;
+    using Apache.Ignite.Core.Tests.Services;
+    using NUnit.Framework;
+
+    /// <summary>
+    /// Tests for <see cref="IServicesClient"/>.
+    /// </summary>
+    public class ServicesClientTest : ClientTestBase
+    {
+        /** */
+        private const string ServiceName = "SVC_NAME";
+
+        /// <summary>
+        /// Initializes a new instance of <see cref="ServicesClientTest"/> class.
+        /// </summary>
+        public ServicesClientTest() : base(2)
+        {
+            // No-op.
+        }
+
+        /// <summary>
+        /// Tears down the test.
+        /// </summary>
+        [TearDown]
+        public void TestTearDown()
+        {
+            ServerServices.CancelAll();
+
+            TestUtils.AssertHandleRegistryIsEmpty(1000, Ignition.GetAll().ToArray());
+        }
+
+        /// <summary>
+        /// Tests the basic success path.
+        /// </summary>
+        [Test]
+        public void TestBasicServiceCall()
+        {
+            var svc = DeployAndGetTestService();
+
+            var res = svc.IntMethod();
+
+            Assert.AreEqual(42, res);
+        }
+
+        /// <summary>
+        /// Tests that void method can be called and the lack of result is handled correctly.
+        ///
+        /// - Invoke void method
+        /// - Verify invoke count on server
+        /// </summary>
+        [Test]
+        public void TestVoidMethodCall()
+        {
+            var svc = DeployAndGetTestService();
+            var expectedCallCount = TestService.CallCount + 1;
+
+            svc.VoidMethod();
+
+            Assert.AreEqual(expectedCallCount, TestService.CallCount);
+        }
+
+        /// <summary>
+        /// Tests that objects can be passed to and from service methods.
+        /// </summary>
+        [Test]
+        public void TestObjectMethodCall()
+        {
+            var svc = DeployAndGetTestService();
+
+            var res = svc.PersonMethod(new Person(1));
+
+            Assert.AreEqual(2, res.Id);
+        }
+
+        /// <summary>
+        /// Tests that generic method can be called on a service.
+        /// </summary>
+        [Test]
+        [Ignore("IGNITE-13351")]
+        public void TestGenericMethodCall()
+        {
+            var svcName = TestUtils.TestName;
+            ServerServices.DeployClusterSingleton(svcName, new TestServiceGenericMethods());
+
+            var svc = Client.GetServices().GetServiceProxy<ITestServiceGenericMethods>(svcName);
+
+            Assert.AreEqual("1", svc.GetGeneric("1"));
+        }
+
+        /// <summary>
+        /// Tests that <see cref="IServicesClient.WithKeepBinary"/> call causes service invocation results to be
+        /// returned in serialized form.
+        ///
+        /// - Enable binary mode
+        /// - Verify that service invocation result is <see cref="IBinaryObject"/>
+        /// </summary>
+        [Test]
+        public void TestClientKeepBinaryReturnsServiceInvocationResultInBinaryMode()
+        {
+            var svc = DeployAndGetTestService<ITestServiceClient>(s => s.WithKeepBinary());
+
+            var person = Client.GetBinary().ToBinary<IBinaryObject>(new Person(5));
+            var res = svc.PersonMethod(person);
+
+            Assert.AreEqual(6, res.GetField<int>("Id"));
+        }
+
+        /// <summary>
+        /// Tests that <see cref="IServicesClient.WithServerKeepBinary"/> call causes service invocation arguments
+        /// to be passed to the service (on server node) in serialized form.
+        ///
+        /// - Enable server-side binary mode
+        /// - Check that server-side service receives <see cref="IBinaryObject"/>, modifies it and returns back
+        /// </summary>
+        [Test]
+        public void TestServerKeepBinaryPassesServerSideArgumentsInBinaryMode()
+        {
+            var svc = DeployAndGetTestService<ITestServiceClient>(s => s.WithServerKeepBinary());
+
+            var res = svc.PersonMethodBinary(new Person(1));
+
+            Assert.AreEqual(2, res.Id);
+        }
+
+        /// <summary>
+        /// Tests that <see cref="IServicesClient.WithServerKeepBinary"/> combined with
+        /// <see cref="IServicesClient.WithKeepBinary"/> uses binary objects both on client and server sides.
+        ///
+        /// - Enable server and client binary mode
+        /// - Check that both server and client operate on <see cref="IBinaryObject"/> instances
+        /// </summary>
+        [Test]
+        public void TestServerAndClientKeepBinaryPassesBinaryObjectsOnServerAndClient()
+        {
+            var svc = DeployAndGetTestService(s => s.WithKeepBinary().WithServerKeepBinary());
+
+            var person = Client.GetBinary().ToBinary<IBinaryObject>(new Person(-2));
+            var res = svc.PersonMethodBinary(person);
+
+            Assert.AreEqual(-1, res.GetField<int>("Id"));
+        }
+
+        /// <summary>
+        /// Tests that property getters/setters can be invoked on a remote service.
+        /// </summary>
+        [Test]
+        public void TestPropertyCalls()
+        {
+            var svc = DeployAndGetTestService();
+
+            // Primitive.
+            svc.IntProperty = 99;
+            Assert.AreEqual(99, svc.IntProperty);
+
+            // Object.
+            svc.PersonProperty= new Person(123);
+            Assert.AreEqual(123, svc.PersonProperty.Id);
+        }
+
+        /// <summary>
+        /// Tests that object array can be passed to and from the remote service.
+        /// </summary>
+        [Test]
+        public void TestObjectArray()
+        {
+            var svc = DeployAndGetTestService();
+
+            var res = svc.PersonArrayMethod(new[] {new Person(10), new Person(20)});
+
+            Assert.AreEqual(new[] {12, 22}, res.Select(p => p.Id));
+        }
+
+        /// <summary>
+        /// Tests that object array can be passed to and from the remote service in binary mode.
+        /// </summary>
+        [Test]
+        public void TestObjectArrayBinary()
+        {
+            var svc = DeployAndGetTestService(s => s.WithKeepBinary().WithServerKeepBinary());
+
+            var persons = new[] {new Person(10), new Person(20)}
+                .Select(p => Client.GetBinary().ToBinary<IBinaryObject>(p))
+                .ToArray();
+
+            var res = svc.PersonArrayMethodBinary(persons);
+
+            Assert.AreEqual(new[] {12, 22}, res.Select(p => p.GetField<int>("Id")));
+        }
+
+        /// <summary>
+        /// Tests all primitive and built-in types used as parameters and return values.
+        /// </summary>
+        [Test]
+        public void TestAllArgumentTypes()
+        {
+            ServerServices.DeployClusterSingleton(ServiceName, new TestServiceDataTypes());
+            var svc = Client.GetServices().GetServiceProxy<ITestServiceDataTypes>(ServiceName);
+
+            Assert.AreEqual(2, svc.GetByte(1));
+            Assert.AreEqual(new byte[] {3, 4, 5}, svc.GetByteArray(new byte[] {2, 3, 4}));
+
+            Assert.AreEqual(3, svc.GetSbyte(2));
+            Assert.AreEqual(new sbyte[] {-4, 6}, svc.GetSbyteArray(new sbyte[] {-5, 5}));
+
+            Assert.AreEqual(3, svc.GetShort(2));
+            Assert.AreEqual(new short[] {-4, 6}, svc.GetShortArray(new short[] {-5, 5}));
+
+            Assert.AreEqual(3, svc.GetUShort(2));
+            Assert.AreEqual(new ushort[] {1, 6}, svc.GetUShortArray(new ushort[] {0, 5}));
+
+            Assert.AreEqual(3, svc.GetInt(2));
+            Assert.AreEqual(new [] {-4, 6}, svc.GetIntArray(new[] {-5, 5}));
+
+            Assert.AreEqual(3, svc.GetUInt(2));
+            Assert.AreEqual(new uint[] {1, 6}, svc.GetUIntArray(new uint[] {0, 5}));
+
+            Assert.AreEqual(long.MaxValue - 9, svc.GetLong(long.MaxValue - 10));
+            Assert.AreEqual(new [] {long.MinValue + 1, 6}, svc.GetLongArray(new[] {long.MinValue, 5}));
+
+            Assert.AreEqual(ulong.MaxValue - 9, svc.GetULong(ulong.MaxValue - 10));
+            Assert.AreEqual(new ulong[] {1, 10}, svc.GetULongArray(new ulong[] {0, 9}));
+
+            Assert.AreEqual('d', svc.GetChar('c'));
+            Assert.AreEqual(new[] {'b', 'c'}, svc.GetCharArray(new[]{'a', 'b'}));
+
+            var guid = Guid.NewGuid();
+            Assert.AreEqual(guid, svc.GetGuid(guid));
+            Assert.AreEqual(new[] {guid, Guid.Empty}, svc.GetGuidArray(new[] {guid, Guid.Empty}));
+
+            var dt = DateTime.Now;
+            Assert.AreEqual(dt.AddDays(1), svc.GetDateTime(dt));
+            Assert.AreEqual(new[] {dt.AddDays(1), dt.AddDays(2)}, svc.GetDateTimeArray(new[] {dt, dt.AddDays(1)}));
+            Assert.AreEqual(new List<DateTime> {dt.AddDays(1), dt.AddDays(2)},
+                svc.GetDateTimeList(new[] {dt, dt.AddDays(1)}.ToList()));
+
+            var ts = TimeSpan.FromSeconds(25);
+            var minuteTs = TimeSpan.FromMinutes(1);
+            Assert.AreEqual(ts.Add(minuteTs), svc.GetTimeSpan(ts));
+            Assert.AreEqual(new[] {ts.Add(minuteTs), minuteTs}, svc.GetTimeSpanArray(new[] {ts, TimeSpan.Zero}));
+
+            Assert.AreEqual(true, svc.GetBool(false));
+            Assert.AreEqual(new[] {true, false}, svc.GetBoolArray(new[] {false, true}));
+
+            Assert.AreEqual(1.5f, svc.GetFloat(0.5f));
+            Assert.AreEqual(new[] {-0.5f, 1.1f}, svc.GetFloatArray(new[] {-1.5f, 0.1f}));
+
+            Assert.AreEqual(1.5d, svc.GetDouble(0.5d));
+            Assert.AreEqual(new[] {-7.02d, 1.1d}, svc.GetDoubleArray(new[] {-8.02d, 0.1d}));
+
+            Assert.AreEqual(1.666m, svc.GetDecimal(0.666m));
+            Assert.AreEqual(new[] {-7.66m, 1.33m}, svc.GetDecimalArray(new[] {-8.66m, 0.33m}));
+
+            Assert.AreEqual("foo", svc.GetString("FOO"));
+            Assert.AreEqual(new[]{"foo", "bar"}, svc.GetStringArray(new[]{"FoO", "bAr"}));
+        }
+
+        /// <summary>
+        /// Tests that overloaded methods are resolved correctly.
+        ///
+        /// - Invoke multiple overloads of the same method
+        /// - Check that correct overload is invoked based on the return value
+        /// </summary>
+        [Test]
+        public void TestOverloadResolution()
+        {
+            var svcName = TestUtils.TestName;
+            ServerServices.DeployClusterSingleton(svcName, new TestServiceOverloads());
+            var svc = Client.GetServices().GetServiceProxy<ITestServiceOverloads>(svcName);
+
+            Assert.AreEqual(true, svc.Foo());
+            Assert.AreEqual(1, svc.Foo(default(int)));
+            Assert.AreEqual(3, svc.Foo(default(byte)));
+            Assert.AreEqual(4, svc.Foo(default(short)));
+            Assert.AreEqual(6, svc.Foo(new Person()));
+            Assert.AreEqual(8, svc.Foo(new[] {1}));
+            Assert.AreEqual(9, svc.Foo(new[] {new object()}));
+
+            // Unsigned types are not preserved by the binary protocol and resolve to signed counterparts.
+            Assert.AreEqual(1, svc.Foo(default(uint)));
+            Assert.AreEqual(4, svc.Foo(default(ushort)));
+
+            // Array types are not distinguished.
+            Assert.AreEqual(9, svc.Foo(new[] {new Person(0)}));
+        }
+
+        /// <summary>
+        /// Tests that thin client can call Java services.
+        /// </summary>
+        [Test]
+        public void TestJavaServiceCall()
+        {
+            var serviceName = TestUtils.DeployJavaService(Ignition.GetIgnite());
+            var svc = Client.GetServices().GetServiceProxy<IJavaService>(serviceName);
+            var binSvc = Client.GetServices()
+                .WithKeepBinary()
+                .WithServerKeepBinary()
+                .GetServiceProxy<IJavaService>(serviceName);
+
+            Assert.IsTrue(svc.isInitialized());
+            Assert.IsTrue(svc.isExecuted());
+            Assert.IsFalse(svc.isCancelled());
+
+            // Primitives.
+            Assert.AreEqual(4, svc.test((byte) 3));
+            Assert.AreEqual(5, svc.test((short) 4));
+            Assert.AreEqual(6, svc.test(5));
+            Assert.AreEqual(6, svc.test((long) 5));
+            Assert.AreEqual(3.8f, svc.test(2.3f));
+            Assert.AreEqual(5.8, svc.test(3.3));
+            Assert.IsFalse(svc.test(true));
+            Assert.AreEqual('b', svc.test('a'));
+            Assert.AreEqual("Foo!", svc.test("Foo"));
+
+            // Nullables (Java wrapper types).
+            Assert.AreEqual(4, svc.testWrapper(3));
+            Assert.AreEqual(5, svc.testWrapper((short?) 4));
+            Assert.AreEqual(6, svc.testWrapper((int?)5));
+            Assert.AreEqual(6, svc.testWrapper((long?) 5));
+            Assert.AreEqual(3.8f, svc.testWrapper(2.3f));
+            Assert.AreEqual(5.8, svc.testWrapper(3.3));
+            Assert.AreEqual(false, svc.testWrapper(true));
+            Assert.AreEqual('b', svc.testWrapper('a'));
+
+            // Arrays.
+            Assert.AreEqual(new byte[] {2, 3, 4}, svc.testArray(new byte[] {1, 2, 3}));
+            Assert.AreEqual(new short[] {2, 3, 4}, svc.testArray(new short[] {1, 2, 3}));
+            Assert.AreEqual(new[] {2, 3, 4}, svc.testArray(new[] {1, 2, 3}));
+            Assert.AreEqual(new long[] {2, 3, 4}, svc.testArray(new long[] {1, 2, 3}));
+            Assert.AreEqual(new float[] {2, 3, 4}, svc.testArray(new float[] {1, 2, 3}));
+            Assert.AreEqual(new double[] {2, 3, 4}, svc.testArray(new double[] {1, 2, 3}));
+            Assert.AreEqual(new[] {"a1", "b1"}, svc.testArray(new [] {"a", "b"}));
+            Assert.AreEqual(new[] {'c', 'd'}, svc.testArray(new[] {'b', 'c'}));
+            Assert.AreEqual(new[] {false, true, false}, svc.testArray(new[] {true, false, true}));
+
+            // Nulls.
+            Assert.AreEqual(9, svc.testNull(8));
+            Assert.IsNull(svc.testNull(null));
+
+            // params / varargs.
+            Assert.AreEqual(5, svc.testParams(1, 2, 3, 4, "5"));
+            Assert.AreEqual(0, svc.testParams());
+
+            // Overloads.
+            Assert.AreEqual(3, svc.test(2, "1"));
+            Assert.AreEqual(3, svc.test("1", 2));
+
+            // Dates & Timestamps: not supported in Thin Client Services.
+            var ex = Assert.Throws<IgniteClientException>(() => svc.test(DateTime.UtcNow));
+            StringAssert.StartsWith("Failed to resolve .NET class 'System.DateTime' in Java", ex.Message);
+
+            // Guid.
+            var guid = Guid.NewGuid();
+
+            Assert.AreEqual(guid, svc.test(guid));
+            Assert.AreEqual(guid, svc.testNullUUID(guid));
+            Assert.IsNull(svc.testNullUUID(null));
+            Assert.AreEqual(guid, svc.testArray(new Guid?[] {guid})[0]);
+
+            // Binary object.
+            Assert.AreEqual(15,
+                binSvc.testBinaryObject(
+                    Client.GetBinary().ToBinary<IBinaryObject>(new ServicesTest.PlatformComputeBinarizable {Field = 6}))
+                    .GetField<int>("Field"));
+
+            // Binary object array.
+            var arr  = new[] {10, 11, 12}.Select(
+                x => new ServicesTest.PlatformComputeBinarizable {Field = x}).ToArray();
+
+            var binArr = arr.Select(Client.GetBinary().ToBinary<IBinaryObject>).ToArray();
+
+            Assert.AreEqual(new[] {11, 12, 13}, binSvc.testBinaryObjectArray(binArr)
+                .Select(x => x.GetField<int>("Field")));
+        }
+
+        /// <summary>
+        /// Tests that specifying custom cluster group causes service calls to be routed to selected servers.
+        ///
+        /// - Deploy the service on every server node with DeployNodeSingleton
+        /// - For every server node:
+        /// - Get a cluster group of a single node
+        /// - Invoke service method that returns local node id
+        /// - Check that specified server has been used to invoke the service
+        /// </summary>
+        [Test]
+        public void TestServicesWithCustomClusterGroupInvokeOnSpecifiedNodes()
+        {
+            ServerServices.DeployNodeSingleton(ServiceName, new TestService());
+
+            foreach (var ignite in Ignition.GetAll())
+            {
+                var node = ignite.GetCluster().GetLocalNode();
+                var clusterGroup = Client.GetCluster().ForPredicate(n => n.Id == node.Id);
+                var svc = clusterGroup.GetServices();
+
+                Assert.AreSame(clusterGroup, svc.ClusterGroup);
+                Assert.AreEqual(node.Id, clusterGroup.GetNodes().Single().Id);
+
+                var actualNodeId = svc.GetServiceProxy<ITestService>(ServiceName).GetNodeId();
+                Assert.AreEqual(node.Id, actualNodeId);
+            }
+        }
+
+        /// <summary>
+        /// Tests that empty cluster group causes exception on service call.
+        ///
+        /// - Create an empty cluster group
+        /// - Get services over that group
+        /// - Execute service method, verify exception
+        /// </summary>
+        [Test]
+        public void TestEmptyClusterGroupThrowsError()
+        {
+            ServerServices.DeployNodeSingleton(ServiceName, new TestService());
+
+            var clusterGroup = Client.GetCluster().ForPredicate(_ => false);
+            var svc = clusterGroup.GetServices().GetServiceProxy<ITestService>(ServiceName);
+
+            var ex = Assert.Throws<IgniteClientException>(() => svc.VoidMethod());
+            Assert.AreEqual("Cluster group is empty", ex.Message);
+        }
+
+        /// <summary>
+        /// Tests that a custom cluster group that does not have any server nodes with specified service produces
+        /// a correct exception.
+        ///
+        /// - Deploy the service to node X
+        /// - Create client cluster group with node Y
+        /// - Call service, verify exception
+        /// </summary>
+        [Test]
+        public void TestClusterGroupWithoutMatchingServiceNodesThrowsError()
+        {
+            var ignite = Ignition.GetIgnite();
+            var node = ignite.GetCluster().GetLocalNode();
+
+            ignite.GetCluster()
+                .ForNodes(node)
+                .GetServices()
+                .DeployClusterSingleton(ServiceName, new TestService());
+
+            var svc = Client.GetCluster()
+                .ForPredicate(n => n.Id != node.Id)
+                .GetServices()
+                .GetServiceProxy<ITestService>(ServiceName);
+
+            var ex = Assert.Throws<IgniteClientException>(() => svc.VoidMethod());
+            Assert.AreEqual("Failed to find deployed service: " + ServiceName, ex.Message);
+        }
+
+        /// <summary>
+        /// Tests that lingering service calls cause timeout exception when WithTimeout is used.
+        ///
+        /// - Deploy the service
+        /// - Get a service proxy with a timeout
+        /// - Execute a method that takes a long time, verify that timeout setting takes effect
+        /// </summary>
+        [Test]
+        [Ignore("IGNITE-13360")]
+        public void TestTimeout()
+        {
+            var svc = DeployAndGetTestService();
+
+            var ex = Assert.Throws<IgniteClientException>(() => svc.Sleep(TimeSpan.FromSeconds(3)));
+
+            Assert.AreEqual("timed out", ex.Message);
+        }
+
+        /// <summary>
+        /// Tests that lingering service calls cause timeout exception when WithTimeout is used.
+        ///
+        /// - Deploy the service
+        /// - Get a service proxy with a timeout
+        /// - Execute a method that takes a long time, verify that timeout setting takes effect
+        /// </summary>
+        [Test]
+        [Ignore("IGNITE-13360")]
+        public void TestJavaServiceTimeout()
+        {
+            var svcName = TestUtils.DeployJavaService(Ignition.GetIgnite());
+
+            var svc = Client.GetServices()
+                .GetServiceProxy<IJavaService>(svcName);
+
+            var ex = Assert.Throws<IgniteClientException>(() => svc.sleep(2000));
+
+            Assert.AreEqual("timed out", ex.Message);
+        }
+
+        /// <summary>
+        /// Tests that exception in service is propagated to the client and service is still operational.
+        /// </summary>
+        [Test]
+        public void TestExceptionInServiceIsPropagatedToClient()
+        {
+            var svc = DeployAndGetTestService();
+
+            var ex = Assert.Throws<IgniteClientException>(() => svc.ExceptionalMethod());
+
+            Assert.AreEqual("Failed to invoke platform service, see server logs for details", ex.Message);
+        }
+
+        /// <summary>
+        /// Tests that invoking a service that does not exist causes a correct exception.
+        /// </summary>
+        [Test]
+        public void TestNonExistentServiceNameCausesClientException()
+        {
+            var svc = Client.GetServices().GetServiceProxy<ITestService>(ServiceName);
+
+            var ex = Assert.Throws<IgniteClientException>(() => svc.VoidMethod());
+            Assert.AreEqual(ClientStatusCode.Fail, ex.StatusCode);
+        }
+
+        /// <summary>
+        /// Tests async method calls.
+        /// </summary>
+        [Test]
+        [Ignore("IGNITE-13343")]
+        public void TestAsyncServiceCalls()
+        {
+            var svc = DeployAndGetTestService();
+
+            var task = svc.AsyncMethod();
+            task.Wait();
+
+            Assert.AreEqual(1, task.Result);
+        }
+
+        /// <summary>
+        /// Deploys test service and returns client-side proxy.
+        /// </summary>
+        private ITestService DeployAndGetTestService(Func<IServicesClient, IServicesClient> transform = null)
+        {
+            return DeployAndGetTestService<ITestService>(transform);
+        }
+
+        /// <summary>
+        /// Deploys test service and returns client-side proxy.
+        /// </summary>
+        private T DeployAndGetTestService<T>(Func<IServicesClient, IServicesClient> transform = null) where T : class
+        {
+            ServerServices.DeployClusterSingleton(ServiceName, new TestService());
+
+            var services = Client.GetServices();
+
+            if (transform != null)
+            {
+                services = transform(services);
+            }
+
+            return services.GetServiceProxy<T>(ServiceName);
+        }
+
+        /// <summary>
+        /// Gets server-side Services.
+        /// </summary>
+        private static IServices ServerServices
+        {
+            get { return Ignition.GetIgnite().GetServices(); }
+        }
+    }
+}
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/TestService.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/TestService.cs
new file mode 100644
index 000000000000..c61b43a76968
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/TestService.cs
@@ -0,0 +1,134 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.Core.Tests.Client.Services
+{
+    using System;
+    using System.Linq;
+    using System.Threading;
+    using System.Threading.Tasks;
+    using Apache.Ignite.Core.Binary;
+    using Apache.Ignite.Core.Resource;
+    using Apache.Ignite.Core.Services;
+    using Apache.Ignite.Core.Tests.Client.Cache;
+
+    /// <summary>
+    /// Test service.
+    /// </summary>
+    public class TestService : ITestService, IService
+    {
+        /** */
+        [InstanceResource]
+        private readonly IIgnite _ignite = null;
+
+        /** */
+        public const string ExceptionText = "Some error";
+
+        /** */
+        public static int CallCount { get; set; }
+
+        /** <inheritdoc /> */
+        public int IntProperty { get; set; }
+
+        /** <inheritdoc /> */
+        public Person PersonProperty { get; set; }
+
+        /** <inheritdoc /> */
+        public void VoidMethod()
+        {
+            CallCount++;
+        }
+
+        /** <inheritdoc /> */
+        public int IntMethod()
+        {
+            return 42;
+        }
+
+        /** <inheritdoc /> */
+        public void ExceptionalMethod()
+        {
+            throw new ArithmeticException(ExceptionText);
+        }
+
+        /** <inheritdoc /> */
+        public Task<int> AsyncMethod()
+        {
+            var tcs = new TaskCompletionSource<int>();
+            new Timer(_ => tcs.SetResult(1)).Change(500, -1);
+            return tcs.Task;        }
+
+        /** <inheritdoc /> */
+        public Person PersonMethod(Person person)
+        {
+            return new Person(person.Id + 1);
+        }
+
+        /** <inheritdoc /> */
+        public IBinaryObject PersonMethodBinary(IBinaryObject person)
+        {
+            return person
+                .ToBuilder()
+                .SetField("Id", person.GetField<int>("Id") + 1)
+                .Build();
+        }
+
+        /** <inheritdoc /> */
+        public Person[] PersonArrayMethod(Person[] persons)
+        {
+            return persons.Select(p => new Person(p.Id + 2)).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public IBinaryObject[] PersonArrayMethodBinary(IBinaryObject[] persons)
+        {
+            return persons
+                .Select(p => p.ToBuilder().SetIntField("Id", p.GetField<int>("Id") + 2).Build())
+                .ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public void Sleep(TimeSpan delay)
+        {
+            Thread.Sleep(delay);
+        }
+
+        /** <inheritdoc /> */
+        public Guid GetNodeId()
+        {
+            return _ignite.GetCluster().GetLocalNode().Id;
+        }
+
+        /** <inheritdoc /> */
+        public void Init(IServiceContext context)
+        {
+            // No-op.
+        }
+
+        /** <inheritdoc /> */
+        public void Execute(IServiceContext context)
+        {
+            // No-op.
+        }
+
+        /** <inheritdoc /> */
+        public void Cancel(IServiceContext context)
+        {
+            // No-op.
+        }
+    }
+}
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/TestServiceDataTypes.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/TestServiceDataTypes.cs
new file mode 100644
index 000000000000..ae5cde9cc573
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/TestServiceDataTypes.cs
@@ -0,0 +1,258 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.Core.Tests.Client.Services
+{
+    using System;
+    using System.Collections.Generic;
+    using System.Linq;
+    using Apache.Ignite.Core.Services;
+
+    /// <summary>
+    /// Service for testing various data types passing.
+    /// </summary>
+    public class TestServiceDataTypes : ITestServiceDataTypes, IService
+    {
+        /** <inheritdoc /> */
+        public byte GetByte(byte x)
+        {
+            return ++x;
+        }
+
+        /** <inheritdoc /> */
+        public byte[] GetByteArray(byte[] x)
+        {
+            return x.Select(b => ++b).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public sbyte GetSbyte(sbyte x)
+        {
+            return ++x;
+        }
+
+        /** <inheritdoc /> */
+        public sbyte[] GetSbyteArray(sbyte[] x)
+        {
+            return x.Select(b => ++b).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public char GetChar(char x)
+        {
+            return ++x;
+        }
+
+        /** <inheritdoc /> */
+        public char[] GetCharArray(char[] x)
+        {
+            return x.Select(b => ++b).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public short GetShort(short x)
+        {
+            return ++x;
+        }
+
+        /** <inheritdoc /> */
+        public short[] GetShortArray(short[] x)
+        {
+            return x.Select(s => ++s).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public ushort GetUShort(ushort x)
+        {
+            return ++x;
+        }
+
+        /** <inheritdoc /> */
+        public ushort[] GetUShortArray(ushort[] x)
+        {
+            return x.Select(s => ++s).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public int GetInt(int x)
+        {
+            return ++x;
+        }
+
+        /** <inheritdoc /> */
+        public int[] GetIntArray(int[] x)
+        {
+            return x.Select(s => ++s).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public uint GetUInt(uint x)
+        {
+            return ++x;
+        }
+
+        /** <inheritdoc /> */
+        public uint[] GetUIntArray(uint[] x)
+        {
+            return x.Select(s => ++s).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public long GetLong(long x)
+        {
+            return ++x;
+        }
+
+        /** <inheritdoc /> */
+        public long[] GetLongArray(long[] x)
+        {
+            return x.Select(s => ++s).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public ulong GetULong(ulong x)
+        {
+            return ++x;
+        }
+
+        /** <inheritdoc /> */
+        public ulong[] GetULongArray(ulong[] x)
+        {
+            return x.Select(b => ++b).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public Guid GetGuid(Guid x)
+        {
+            return x;
+        }
+
+        /** <inheritdoc /> */
+        public Guid[] GetGuidArray(Guid[] x)
+        {
+            return x.ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public DateTime GetDateTime(DateTime x)
+        {
+            return x.AddDays(1);
+        }
+
+        /** <inheritdoc /> */
+        public DateTime[] GetDateTimeArray(DateTime[] x)
+        {
+            return x.Select(d => d.AddDays(1)).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public List<DateTime> GetDateTimeList(ICollection<DateTime> x)
+        {
+            return x.Select(d => d.AddDays(1)).ToList();
+        }
+
+        /** <inheritdoc /> */
+        public TimeSpan GetTimeSpan(TimeSpan x)
+        {
+            return x.Add(TimeSpan.FromMinutes(1));
+        }
+
+        /** <inheritdoc /> */
+        public TimeSpan[] GetTimeSpanArray(TimeSpan[] x)
+        {
+            return x.Select(b => b.Add(TimeSpan.FromMinutes(1))).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public bool GetBool(bool x)
+        {
+            return !x;
+        }
+
+        /** <inheritdoc /> */
+        public bool[] GetBoolArray(bool[] x)
+        {
+            return x.Select(b => !b).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public float GetFloat(float x)
+        {
+            return ++x;
+        }
+
+        /** <inheritdoc /> */
+        public float[] GetFloatArray(float[] x)
+        {
+            return x.Select(b => ++b).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public double GetDouble(double x)
+        {
+            return ++x;
+        }
+
+        /** <inheritdoc /> */
+        public double[] GetDoubleArray(double[] x)
+        {
+            return x.Select(b => ++b).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public decimal GetDecimal(decimal x)
+        {
+            return ++x;
+        }
+
+        /** <inheritdoc /> */
+        public decimal[] GetDecimalArray(decimal[] x)
+        {
+            return x.Select(b => ++b).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public string GetString(string x)
+        {
+            return x.ToLowerInvariant();
+        }
+
+        /** <inheritdoc /> */
+        public string[] GetStringArray(string[] x)
+        {
+            return x.Select(b => b.ToLowerInvariant()).ToArray();
+        }
+
+        /** <inheritdoc /> */
+        public void Init(IServiceContext context)
+        {
+            // No-op.
+        }
+
+        /** <inheritdoc /> */
+        public void Execute(IServiceContext context)
+        {
+            // No-op.
+        }
+
+        /** <inheritdoc /> */
+        public void Cancel(IServiceContext context)
+        {
+            // No-op.
+        }
+    }
+}
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/TestServiceGenericMethods.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/TestServiceGenericMethods.cs
new file mode 100644
index 000000000000..39464a1f1617
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/TestServiceGenericMethods.cs
@@ -0,0 +1,51 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.Core.Tests.Client.Services
+{
+    using Apache.Ignite.Core.Services;
+
+    /// <summary>
+    /// Test service with generic methods.
+    /// </summary>
+    public class TestServiceGenericMethods : ITestServiceGenericMethods, IService
+    {
+        /** <inheritdoc /> */
+        public T GetGeneric<T>(T x)
+        {
+            return x;
+        }
+
+        /** <inheritdoc /> */
+        public void Init(IServiceContext context)
+        {
+            // No-op.
+        }
+
+        /** <inheritdoc /> */
+        public void Execute(IServiceContext context)
+        {
+            // No-op.
+        }
+
+        /** <inheritdoc /> */
+        public void Cancel(IServiceContext context)
+        {
+            // No-op.
+        }
+    }
+}
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/TestServiceOverloads.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/TestServiceOverloads.cs
new file mode 100644
index 000000000000..20ee21c30c81
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Client/Services/TestServiceOverloads.cs
@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.Core.Tests.Client.Services
+{
+    using Apache.Ignite.Core.Services;
+    using Apache.Ignite.Core.Tests.Client.Cache;
+
+    /// <summary>
+    /// Tests service with overloaded methods.
+    /// </summary>
+    public class TestServiceOverloads : ITestServiceOverloads, IService
+    {
+        /** <inheritdoc /> */
+        public bool Foo()
+        {
+            return true;
+        }
+
+        /** <inheritdoc /> */
+        public int Foo(int x)
+        {
+            return 1;
+        }
+
+        /** <inheritdoc /> */
+        public int Foo(uint x)
+        {
+            return 2;
+        }
+
+        /** <inheritdoc /> */
+        public int Foo(byte x)
+        {
+            return 3;
+        }
+
+        /** <inheritdoc /> */
+        public int Foo(short x)
+        {
+            return 4;
+        }
+
+        /** <inheritdoc /> */
+        public int Foo(ushort x)
+        {
+            return 5;
+        }
+
+        /** <inheritdoc /> */
+        public int Foo(Person x)
+        {
+            return 6;
+        }
+
+        /** <inheritdoc /> */
+        public int Foo(int[] x)
+        {
+            return 8;
+        }
+
+        /** <inheritdoc /> */
+        public int Foo(object[] x)
+        {
+            return 9;
+        }
+
+        /** <inheritdoc /> */
+        public int Foo(Person[] x)
+        {
+            return 10;
+        }
+
+        /** <inheritdoc /> */
+        public void Init(IServiceContext context)
+        {
+            // No-op.
+        }
+
+        /** <inheritdoc /> */
+        public void Execute(IServiceContext context)
+        {
+            // No-op.
+        }
+
+        /** <inheritdoc /> */
+        public void Cancel(IServiceContext context)
+        {
+            // No-op.
+        }
+    }
+}
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/IgniteStartStopTest.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/IgniteStartStopTest.cs
index 9fa0afb0ad72..0c002d69f8f1 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/IgniteStartStopTest.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/IgniteStartStopTest.cs
@@ -51,7 +51,7 @@ public void TestStartDefault()
 
             Assert.IsNotNull(grid);
 
-            Assert.AreEqual(1, grid.GetCluster().GetNodes().Count);
+            Assert.AreEqual(1, grid.GetCluster().GetNodes().Count, "Unexpected number of nodes in the cluster.");
         }
 
         /// <summary>
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/ProjectFilesTest.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/ProjectFilesTest.cs
index 02c2bd45dc00..1a7625c4a221 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/ProjectFilesTest.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/ProjectFilesTest.cs
@@ -39,7 +39,7 @@ public void TestCsprojToolsVersion()
                 .GetFiles("*.csproj", SearchOption.AllDirectories)
                 .Where(x => !x.FullName.ToLower().Contains("dotnetcore") && !x.FullName.Contains("Benchmark"))
                 .ToArray();
-            
+
             Assert.GreaterOrEqual(projFiles.Length, 7);
             CheckFiles(projFiles, x => !x.Contains("ToolsVersion=\"4.0\""), "Invalid csproj files: ");
         }
@@ -50,7 +50,7 @@ public void TestCsprojToolsVersion()
         [Test]
         public void TestCsprojReleaseDocs()
         {
-            CheckFiles(GetReleaseCsprojFiles(), x => !GetReleaseSection(x).Contains("DocumentationFile"), 
+            CheckFiles(GetReleaseCsprojFiles(), x => !GetReleaseSection(x).Contains("DocumentationFile"),
                 "Missing XML doc in release mode: ");
         }
 
@@ -60,7 +60,7 @@ public void TestCsprojReleaseDocs()
         [Test]
         public void TestCsprojBuildSettings()
         {
-            CheckFiles(GetReleaseCsprojFiles(), x => GetReleaseSection(x).Contains("DefineConstants"), 
+            CheckFiles(GetReleaseCsprojFiles(), x => GetReleaseSection(x).Contains("DefineConstants"),
                 "Invalid constants in release mode: ");
         }
 
@@ -70,7 +70,7 @@ public void TestCsprojBuildSettings()
         [Test]
         public void TestCsprojPdbSettings()
         {
-            CheckFiles(GetReleaseCsprojFiles(), x => !GetReleaseSection(x).Contains("<DebugType>none</DebugType>"), 
+            CheckFiles(GetReleaseCsprojFiles(), x => !GetReleaseSection(x).Contains("<DebugType>none</DebugType>"),
                 "Invalid DebugType in release mode: ");
         }
 
@@ -80,10 +80,62 @@ public void TestCsprojPdbSettings()
         [Test]
         public void TestCsprojOptimizeCode()
         {
-            CheckFiles(GetReleaseCsprojFiles(), x => !GetReleaseSection(x).Contains("<Optimize>true</Optimize>"), 
+            CheckFiles(GetReleaseCsprojFiles(), x => !GetReleaseSection(x).Contains("<Optimize>true</Optimize>"),
                 "Invalid optimize setting in release mode: ");
         }
 
+#if NETCOREAPP
+        /// <summary>
+        /// Tests that all .cs files are included in the project.
+        /// </summary>
+        [Test]
+        public void TestAllCsharpFilesAreIncludedInProject()
+        {
+            var projFiles = TestUtils.GetDotNetSourceDir().GetFiles("*.csproj", SearchOption.AllDirectories)
+                .Where(x =>
+                    !x.Name.Contains("DotNetCore") && !x.Name.Contains("Benchmark") && !x.Name.Contains("Examples"));
+
+            var excludedFiles = new[]
+            {
+                "IgnitionStartTest.cs",
+                "Common\\TestFixtureSetUp.cs",
+                "Common\\TestFixtureTearDown.cs",
+                "Client\\Cache\\CacheTestAsyncAwait.cs"
+            };
+
+            Assert.Multiple(() =>
+            {
+                foreach (var projFile in projFiles)
+                {
+                    Assert.IsNotNull(projFile.Directory);
+
+                    var projFileText = File.ReadAllText(projFile.FullName);
+                    var csFiles = projFile.Directory.GetFiles("*.cs", SearchOption.AllDirectories);
+
+                    foreach (var csFile in csFiles)
+                    {
+                        // Csproj uses the same path separator on all platforms.
+                        var csFileRelativePath = Path.GetRelativePath(projFile.Directory.FullName, csFile.FullName)
+                            .Replace(Path.DirectorySeparatorChar, '\\');
+
+                        if (csFileRelativePath.StartsWith("bin\\") ||
+                            csFileRelativePath.StartsWith("obj\\") ||
+                            csFileRelativePath.Contains("DotNetCore") ||
+                            excludedFiles.Contains(csFileRelativePath))
+                        {
+                            continue;
+                        }
+
+                        Assert.IsTrue(
+                            projFileText.Contains(csFileRelativePath),
+                            string.Format("Project file '{0}' should contain file '{1}'", projFile.Name,
+                                csFileRelativePath));
+                    }
+                }
+            });
+        }
+#endif
+
         /// <summary>
         /// Gets the csproj files that go to the release binary package.
         /// </summary>
@@ -102,7 +154,7 @@ private static IEnumerable<FileInfo> GetReleaseCsprojFiles()
         /// </summary>
         private static string GetReleaseSection(string csproj)
         {
-            return Regex.Match(csproj, @"<PropertyGroup[^>]*Release\|AnyCPU(.*?)<\/PropertyGroup>", 
+            return Regex.Match(csproj, @"<PropertyGroup[^>]*Release\|AnyCPU(.*?)<\/PropertyGroup>",
                 RegexOptions.Singleline).Value;
         }
 
@@ -130,7 +182,7 @@ public void TestAsciiChars()
             var allowedFiles = new[]
             {
                 "BinaryStringTest.cs",
-                "BinarySelfTest.cs", 
+                "BinarySelfTest.cs",
                 "CacheDmlQueriesTest.cs",
                 "CacheTest.cs"
             };
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Services/IJavaService.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Services/IJavaService.cs
new file mode 100644
index 000000000000..ccceaf7937bb
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Services/IJavaService.cs
@@ -0,0 +1,169 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.Core.Tests.Services
+{
+    using System;
+    using System.Collections;
+    using System.Diagnostics.CodeAnalysis;
+    using Apache.Ignite.Core.Binary;
+
+    /// <summary>
+    /// Java service proxy interface.
+    /// </summary>
+    [SuppressMessage("ReSharper", "InconsistentNaming")]
+    public interface IJavaService
+    {
+        /** */
+        bool isCancelled();
+
+        /** */
+        bool isInitialized();
+
+        /** */
+        bool isExecuted();
+
+        /** */
+        byte test(byte x);
+
+        /** */
+        short test(short x);
+
+        /** */
+        int test(int x);
+
+        /** */
+        long test(long x);
+
+        /** */
+        float test(float x);
+
+        /** */
+        double test(double x);
+
+        /** */
+        char test(char x);
+
+        /** */
+        string test(string x);
+
+        /** */
+        bool test(bool x);
+
+        /** */
+        DateTime test(DateTime x);
+
+        /** */
+        Guid test(Guid x);
+
+        /** */
+        byte? testWrapper(byte? x);
+
+        /** */
+        short? testWrapper(short? x);
+
+        /** */
+        int? testWrapper(int? x);
+
+        /** */
+        long? testWrapper(long? x);
+
+        /** */
+        float? testWrapper(float? x);
+
+        /** */
+        double? testWrapper(double? x);
+
+        /** */
+        char? testWrapper(char? x);
+
+        /** */
+        bool? testWrapper(bool? x);
+
+        /** */
+        byte[] testArray(byte[] x);
+
+        /** */
+        short[] testArray(short[] x);
+
+        /** */
+        int[] testArray(int[] x);
+
+        /** */
+        long[] testArray(long[] x);
+
+        /** */
+        float[] testArray(float[] x);
+
+        /** */
+        double[] testArray(double[] x);
+
+        /** */
+        char[] testArray(char[] x);
+
+        /** */
+        string[] testArray(string[] x);
+
+        /** */
+        bool[] testArray(bool[] x);
+
+        /** */
+        DateTime?[] testArray(DateTime?[] x);
+
+        /** */
+        Guid?[] testArray(Guid?[] x);
+
+        /** */
+        int test(int x, string y);
+
+        /** */
+        int test(string x, int y);
+
+        /** */
+        int? testNull(int? x);
+
+        /** */
+        DateTime? testNullTimestamp(DateTime? x);
+
+        /** */
+        Guid? testNullUUID(Guid? x);
+
+        /** */
+        int testParams(params object[] args);
+
+        /** */
+        ServicesTest.PlatformComputeBinarizable testBinarizable(ServicesTest.PlatformComputeBinarizable x);
+
+        /** */
+        object[] testBinarizableArrayOfObjects(object[] x);
+
+        /** */
+        IBinaryObject[] testBinaryObjectArray(IBinaryObject[] x);
+
+        /** */
+        ServicesTest.PlatformComputeBinarizable[] testBinarizableArray(ServicesTest.PlatformComputeBinarizable[] x);
+
+        /** */
+        ICollection testBinarizableCollection(ICollection x);
+
+        /** */
+        IBinaryObject testBinaryObject(IBinaryObject x);
+
+        /** */
+        void sleep(long delayMs);
+    }
+}
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Services/ServicesTest.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Services/ServicesTest.cs
index 1982e2035867..ee0bdea7417c 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Services/ServicesTest.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/Services/ServicesTest.cs
@@ -18,9 +18,7 @@
 namespace Apache.Ignite.Core.Tests.Services
 {
     using System;
-    using System.Collections;
     using System.Collections.Generic;
-    using System.Diagnostics.CodeAnalysis;
     using System.IO;
     using System.Linq;
     using System.Runtime.Serialization.Formatters.Binary;
@@ -852,10 +850,9 @@ public void TestMarshalExceptionOnWrite()
         public void TestCallJavaService()
         {
             // Deploy Java service
-            const string javaSvcName = "javaService";
-            DeployJavaService(javaSvcName);
+            var javaSvcName = TestUtils.DeployJavaService(Grid1);
 
-            // Verify decriptor
+            // Verify descriptor
             var descriptor = Services.GetServiceDescriptors().Single(x => x.Name == javaSvcName);
             Assert.AreEqual(javaSvcName, descriptor.Name);
 
@@ -968,9 +965,8 @@ public void TestCallJavaService()
         [Test]
         public void TestCallJavaServiceDynamicProxy()
         {
-            const string javaSvcName = "javaService";
-            DeployJavaService(javaSvcName);
-
+            // Deploy Java service
+            var javaSvcName = TestUtils.DeployJavaService(Grid1);
             var svc = Grid1.GetServices().GetDynamicServiceProxy(javaSvcName, true);
 
             // Basics
@@ -1044,17 +1040,6 @@ public void TestCallJavaServiceDynamicProxy()
             Assert.AreEqual(guid, svc.testArray(new Guid?[] { guid })[0]);
         }
 
-        /// <summary>
-        /// Deploys the java service.
-        /// </summary>
-        private void DeployJavaService(string javaSvcName)
-        {
-            Grid1.GetCompute()
-                .ExecuteJavaTask<object>("org.apache.ignite.platform.PlatformDeployServiceTask", javaSvcName);
-
-            TestUtils.WaitForCondition(() => Services.GetServiceDescriptors().Any(x => x.Name == javaSvcName), 1000);
-        }
-
         /// <summary>
         /// Tests the footer setting.
         /// </summary>
@@ -1504,148 +1489,6 @@ private class BinarizableObject
             public int Val { get; set; }
         }
 
-        /// <summary>
-        /// Java service proxy interface.
-        /// </summary>
-        [SuppressMessage("ReSharper", "InconsistentNaming")]
-        public interface IJavaService
-        {
-            /** */
-            bool isCancelled();
-
-            /** */
-            bool isInitialized();
-
-            /** */
-            bool isExecuted();
-
-            /** */
-            byte test(byte x);
-
-            /** */
-            short test(short x);
-
-            /** */
-            int test(int x);
-
-            /** */
-            long test(long x);
-
-            /** */
-            float test(float x);
-
-            /** */
-            double test(double x);
-
-            /** */
-            char test(char x);
-
-            /** */
-            string test(string x);
-
-            /** */
-            bool test(bool x);
-
-            /** */
-            DateTime test(DateTime x);
-
-            /** */
-            Guid test(Guid x);
-
-            /** */
-            byte? testWrapper(byte? x);
-
-            /** */
-            short? testWrapper(short? x);
-
-            /** */
-            int? testWrapper(int? x);
-
-            /** */
-            long? testWrapper(long? x);
-
-            /** */
-            float? testWrapper(float? x);
-
-            /** */
-            double? testWrapper(double? x);
-
-            /** */
-            char? testWrapper(char? x);
-
-            /** */
-            bool? testWrapper(bool? x);
-
-            /** */
-            byte[] testArray(byte[] x);
-
-            /** */
-            short[] testArray(short[] x);
-
-            /** */
-            int[] testArray(int[] x);
-
-            /** */
-            long[] testArray(long[] x);
-
-            /** */
-            float[] testArray(float[] x);
-
-            /** */
-            double[] testArray(double[] x);
-
-            /** */
-            char[] testArray(char[] x);
-
-            /** */
-            string[] testArray(string[] x);
-
-            /** */
-            bool[] testArray(bool[] x);
-
-            /** */
-            DateTime?[] testArray(DateTime?[] x);
-
-            /** */
-            Guid?[] testArray(Guid?[] x);
-
-            /** */
-            int test(int x, string y);
-
-            /** */
-            int test(string x, int y);
-
-            /** */
-            int? testNull(int? x);
-
-            /** */
-            DateTime? testNullTimestamp(DateTime? x);
-
-            /** */
-            Guid? testNullUUID(Guid? x);
-
-            /** */
-            int testParams(params object[] args);
-
-            /** */
-            PlatformComputeBinarizable testBinarizable(PlatformComputeBinarizable x);
-
-            /** */
-            object[] testBinarizableArrayOfObjects(object[] x);
-
-            /** */
-            IBinaryObject[] testBinaryObjectArray(IBinaryObject[] x);
-
-            /** */
-            PlatformComputeBinarizable[] testBinarizableArray(PlatformComputeBinarizable[] x);
-
-            /** */
-            ICollection testBinarizableCollection(ICollection x);
-
-            /** */
-            IBinaryObject testBinaryObject(IBinaryObject x);
-        }
-
         /// <summary>
         /// Interop class.
         /// </summary>
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/TestUtils.cs b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/TestUtils.cs
index cb5fe50549b6..494fb13cc9d9 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core.Tests/TestUtils.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core.Tests/TestUtils.cs
@@ -649,6 +649,23 @@ public static void RunTestInNewProcess(string fixtureName, string testName)
                 }
             }
         }
+        
+        /// <summary>
+        /// Deploys the Java service.
+        /// </summary>
+        public static string DeployJavaService(IIgnite ignite)
+        {
+            const string serviceName = "javaService";
+            
+            ignite.GetCompute()
+                .ExecuteJavaTask<object>("org.apache.ignite.platform.PlatformDeployServiceTask", serviceName);
+            
+            var services = ignite.GetServices();
+
+            WaitForCondition(() => services.GetServiceDescriptors().Any(x => x.Name == serviceName), 1000);
+
+            return serviceName;
+        }
 
         /// <summary>
         /// Logs to test progress. Produces immediate console output on .NET Core.
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core/Apache.Ignite.Core.csproj b/modules/platforms/dotnet/Apache.Ignite.Core/Apache.Ignite.Core.csproj
index beb315d7a9e4..5dfc27b558cc 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core/Apache.Ignite.Core.csproj
+++ b/modules/platforms/dotnet/Apache.Ignite.Core/Apache.Ignite.Core.csproj
@@ -69,6 +69,7 @@
     <Compile Include="Client\IClientConnection.cs" />
     <Compile Include="Client\IgniteClientConfigurationSection.cs" />
     <Compile Include="Client\ISslStreamFactory.cs" />
+    <Compile Include="Client\Services\IServicesClient.cs" />
     <Compile Include="Client\SslStreamFactory.cs" />
     <Compile Include="Cluster\IBaselineNode.cs" />
     <Compile Include="Common\IgniteProductVersion.cs" />
@@ -124,6 +125,7 @@
     <Compile Include="Impl\Client\Compute\ComputeClient.cs" />
     <Compile Include="Impl\Client\Compute\ComputeClientFlags.cs" />
     <Compile Include="Impl\Client\Endpoint.cs" />
+    <Compile Include="Impl\Client\Services\ServicesClient.cs" />
     <Compile Include="Impl\Client\SocketEndpoint.cs" />
     <Compile Include="Impl\Common\PlatformType.cs" />
     <Compile Include="Impl\Common\TaskRunner.cs" />
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core/Client/Compute/IComputeClient.cs b/modules/platforms/dotnet/Apache.Ignite.Core/Client/Compute/IComputeClient.cs
index bae8c2467e43..ce85454ba096 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core/Client/Compute/IComputeClient.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core/Client/Compute/IComputeClient.cs
@@ -27,6 +27,11 @@ namespace Apache.Ignite.Core.Client.Compute
     /// </summary>
     public interface IComputeClient
     {
+        /// <summary>
+        /// Gets the cluster group for this <see cref="IComputeClient"/> instance.
+        /// </summary>
+        IClientClusterGroup ClusterGroup { get; }
+
         /// <summary>
         /// Executes Java task by class name.
         /// </summary>
@@ -61,20 +66,20 @@ public interface IComputeClient
         /// <param name="timeout">Timeout.</param>
         /// <returns>New Compute instance with timeout.</returns>
         IComputeClient WithTimeout(TimeSpan timeout);
-        
+
         /// <summary>
         /// Returns a new instance of <see cref="IComputeClient"/> with disabled failover.
         /// When failover is disabled, compute jobs won't be retried in case of node crashes.
         /// </summary>
         /// <returns>New Compute instance with disabled failover.</returns>
         IComputeClient WithNoFailover();
-        
+
         /// <summary>
         /// Returns a new instance of <see cref="IComputeClient"/> with disabled result cache.
         /// </summary>
         /// <returns>New Compute instance with disabled result cache.</returns>
         IComputeClient WithNoResultCache();
-        
+
         /// <summary>
         /// Returns a new instance of <see cref="IComputeClient"/> with binary mode enabled:
         /// Java task argument (on server side) and result (on client side) won't be deserialized.
@@ -82,4 +87,4 @@ public interface IComputeClient
         /// <returns>New Compute instance with binary mode enabled.</returns>
         IComputeClient WithKeepBinary();
     }
-}
\ No newline at end of file
+}
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core/Client/IClientClusterGroup.cs b/modules/platforms/dotnet/Apache.Ignite.Core/Client/IClientClusterGroup.cs
index 648e3dc1de74..98203deb1608 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core/Client/IClientClusterGroup.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core/Client/IClientClusterGroup.cs
@@ -21,6 +21,7 @@ namespace Apache.Ignite.Core.Client
     using System.Collections.Generic;
     using System.Diagnostics.CodeAnalysis;
     using Apache.Ignite.Core.Client.Compute;
+    using Apache.Ignite.Core.Client.Services;
 
     /// <summary>
     /// Defines grid projection which represents a common functionality over a group of nodes.
@@ -31,13 +32,13 @@ namespace Apache.Ignite.Core.Client
     /// shows how to create grid projections:
     /// <code>
     /// var g = Ignition.StartClient().GetCluster();
-    /// 
+    ///
     /// // Projection over .NET nodes.
     /// var remoteNodes = g.ForDotNet();
-    /// 
+    ///
     /// // Projection over server nodes.
     /// var randomNode = g.ForServers();
-    /// 
+    ///
     /// // Projection over all nodes that have user attribute "group" set to value "worker".
     /// var workerNodes = g.ForAttribute("group", "worker");
     /// </code>
@@ -83,7 +84,7 @@ public interface IClientClusterGroup
         /// Gets a node for given ID from this grid projection.
         /// </summary>
         /// <param name="id">Node ID.</param>
-        /// <returns>Node with given ID from this projection or null if such node does not 
+        /// <returns>Node with given ID from this projection or null if such node does not
         /// exist in this projection.</returns>
         IClientClusterNode GetNode(Guid id);
 
@@ -101,5 +102,13 @@ public interface IClientClusterGroup
         /// <returns>Compute instance over this grid projection.</returns>
         [SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Justification = "Semantics.")]
         IComputeClient GetCompute();
+
+        /// <summary>
+        /// Gets services functionality over this grid projection. All operations
+        /// on the returned services instance will only include nodes from this projection.
+        /// </summary>
+        /// <returns>Services instance over this grid projection.</returns>
+        [SuppressMessage("Microsoft.Design", "CA1024:UsePropertiesWhereAppropriate", Justification = "Semantics.")]
+        IServicesClient GetServices();
     }
 }
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core/Client/IIgniteClient.cs b/modules/platforms/dotnet/Apache.Ignite.Core/Client/IIgniteClient.cs
index 9a18d275f6dd..68a4c8269cd8 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core/Client/IIgniteClient.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core/Client/IIgniteClient.cs
@@ -24,6 +24,7 @@ namespace Apache.Ignite.Core.Client
     using Apache.Ignite.Core.Binary;
     using Apache.Ignite.Core.Client.Cache;
     using Apache.Ignite.Core.Client.Compute;
+    using Apache.Ignite.Core.Client.Services;
 
     /// <summary>
     /// Main entry point for Ignite Thin Client APIs.
@@ -98,7 +99,7 @@ public interface IIgniteClient : IDisposable
         IClientCluster GetCluster();
 
         /// <summary>
-        /// Destroys dynamically created (with <see cref="CreateCache{TK,TV}(string)"/> or 
+        /// Destroys dynamically created (with <see cref="CreateCache{TK,TV}(string)"/> or
         /// <see cref="GetOrCreateCache{TK,TV}(string)"/>) cache.
         /// </summary>
         /// <param name="name">The name of the cache to stop.</param>
@@ -141,5 +142,10 @@ public interface IIgniteClient : IDisposable
         /// Gets the compute API.
         /// </summary>
         IComputeClient GetCompute();
+
+        /// <summary>
+        /// Gets the services API.
+        /// </summary>
+        IServicesClient GetServices();
     }
 }
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core/Client/Services/IServicesClient.cs b/modules/platforms/dotnet/Apache.Ignite.Core/Client/Services/IServicesClient.cs
new file mode 100644
index 000000000000..49c64fd80ced
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.Core/Client/Services/IServicesClient.cs
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.Core.Client.Services
+{
+    /// <summary>
+    /// Ignite distributed services client.
+    /// </summary>
+    public interface IServicesClient
+    {
+        /// <summary>
+        /// Gets the cluster group for this <see cref="IServicesClient"/> instance.
+        /// </summary>
+        IClientClusterGroup ClusterGroup { get; }
+
+        /// <summary>
+        /// Gets a proxy for the service with the specified name.
+        /// <para />
+        /// Note: service proxies are not "sticky" - there is no guarantee that all calls will be made to the same
+        /// remote service instance.
+        /// </summary>
+        /// <typeparam name="T">Service type.</typeparam>
+        /// <param name="serviceName">Service name.</param>
+        /// <returns>Proxy object that forwards all member calls to a remote Ignite service.</returns>
+        T GetServiceProxy<T>(string serviceName) where T : class;
+
+        /// <summary>
+        /// Returns an instance with binary mode enabled.
+        /// Service method results will be kept in binary form.
+        /// </summary>
+        /// <returns>Instance with binary mode enabled.</returns>
+        IServicesClient WithKeepBinary();
+
+        /// <summary>
+        /// Returns an instance with server-side binary mode enabled.
+        /// Service method arguments will be kept in binary form.
+        /// </summary>
+        /// <returns>Instance with server-side binary mode enabled.</returns>
+        IServicesClient WithServerKeepBinary();
+    }
+}
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/ClientOp.cs b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/ClientOp.cs
index 486a9eb0cdf4..238058f45f00 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/ClientOp.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/ClientOp.cs
@@ -83,6 +83,9 @@ internal enum ClientOp : short
 
         // Compute.
         ComputeTaskExecute = 6000,
-        ComputeTaskFinished = 6001
+        ComputeTaskFinished = 6001,
+
+        // Services.
+        ServiceInvoke = 7000
     }
 }
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/Cluster/ClientClusterGroup.cs b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/Cluster/ClientClusterGroup.cs
index a47a694853dc..d5f9ead171ea 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/Cluster/ClientClusterGroup.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/Cluster/ClientClusterGroup.cs
@@ -27,7 +27,9 @@ namespace Apache.Ignite.Core.Impl.Client.Cluster
     using Apache.Ignite.Core.Impl.Binary;
     using System.Linq;
     using Apache.Ignite.Core.Client.Compute;
+    using Apache.Ignite.Core.Client.Services;
     using Apache.Ignite.Core.Impl.Client.Compute;
+    using Apache.Ignite.Core.Impl.Client.Services;
     using Apache.Ignite.Core.Impl.Common;
 
     /// <summary>
@@ -75,7 +77,7 @@ internal ClientClusterGroup(IgniteClient ignite)
         /// <param name="ignite">Ignite.</param>
         /// <param name="projection">Projection.</param>
         /// <param name="predicate">Predicate.</param>
-        private ClientClusterGroup(IgniteClient ignite, 
+        private ClientClusterGroup(IgniteClient ignite,
             ClientClusterGroupProjection projection, Func<IClientClusterNode, bool> predicate = null)
         {
             Debug.Assert(ignite != null);
@@ -143,6 +145,12 @@ public IComputeClient GetCompute()
             return new ComputeClient(_ignite, ComputeClientFlags.None, TimeSpan.Zero, this);
         }
 
+        /** <inheritDoc /> */
+        public IServicesClient GetServices()
+        {
+            return new ServicesClient(_ignite, this);
+        }
+
         /// <summary>
         /// Refresh projection nodes.
         /// </summary>
@@ -213,7 +221,7 @@ private static Guid[] ReadNodeIds(IBinaryRawReader reader)
 
             var nodeIds = new Guid[nodesCount];
             var stream = ((BinaryReader) reader).Stream;
-            
+
             for (int i = 0; i < nodesCount; i++)
             {
                 nodeIds[i] = BinaryUtils.ReadGuid(stream);
@@ -258,7 +266,7 @@ private void RequestNodesInfo(Guid[] nodeIds)
                     unknownNodes.Add(nodeId);
                 }
             }
-            
+
             if (unknownNodes.Count > 0)
             {
                 RequestRemoteNodesDetails(unknownNodes);
@@ -279,7 +287,7 @@ private void RequestRemoteNodesDetails(List<Guid> ids)
                     BinaryUtils.WriteGuid(id, ctx.Stream);
                 }
             };
-            
+
             Func<ClientResponseContext, bool> readFunc = ctx =>
             {
                 var cnt = ctx.Stream.ReadInt();
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/Compute/ComputeClient.cs b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/Compute/ComputeClient.cs
index 6e1fdca74bec..d052fddcaeac 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/Compute/ComputeClient.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/Compute/ComputeClient.cs
@@ -121,6 +121,12 @@ public IComputeClient WithKeepBinary()
             return SetFlag(ComputeClientFlags.KeepBinary);
         }
 
+        /** <inheritdoc /> */
+        public IClientClusterGroup ClusterGroup
+        {
+            get { return _clusterGroup ?? _ignite.GetCluster(); }
+        }
+
         /// <summary>
         /// Returns a new instance with the given flag enabled, or this instance if the flag is already present.
         /// </summary>
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/IgniteClient.cs b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/IgniteClient.cs
index 183f8f98af77..cad5ea18bf1e 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/IgniteClient.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/IgniteClient.cs
@@ -29,6 +29,7 @@ namespace Apache.Ignite.Core.Impl.Client
     using Apache.Ignite.Core.Client;
     using Apache.Ignite.Core.Client.Cache;
     using Apache.Ignite.Core.Client.Compute;
+    using Apache.Ignite.Core.Client.Services;
     using Apache.Ignite.Core.Datastream;
     using Apache.Ignite.Core.Impl.Binary;
     using Apache.Ignite.Core.Impl.Cache;
@@ -36,6 +37,7 @@ namespace Apache.Ignite.Core.Impl.Client
     using Apache.Ignite.Core.Impl.Client.Cache;
     using Apache.Ignite.Core.Impl.Client.Cluster;
     using Apache.Ignite.Core.Impl.Client.Compute;
+    using Apache.Ignite.Core.Impl.Client.Services;
     using Apache.Ignite.Core.Impl.Cluster;
     using Apache.Ignite.Core.Impl.Common;
     using Apache.Ignite.Core.Impl.Handle;
@@ -71,6 +73,9 @@ internal class IgniteClient : IIgniteInternal, IIgniteClient
         /** Compute. */
         private readonly ComputeClient _compute;
 
+        /** Services. */
+        private readonly IServicesClient _services;
+
         /// <summary>
         /// Initializes a new instance of the <see cref="IgniteClient"/> class.
         /// </summary>
@@ -95,6 +100,8 @@ public IgniteClient(IgniteClientConfiguration clientConfiguration)
             _cluster = new ClientCluster(this);
 
             _compute = new ComputeClient(this, ComputeClientFlags.None, TimeSpan.Zero, null);
+
+            _services = new ServicesClient(this);
         }
 
         /// <summary>
@@ -245,6 +252,12 @@ public IComputeClient GetCompute()
             return _compute;
         }
 
+        /** <inheritDoc /> */
+        public IServicesClient GetServices()
+        {
+            return _services;
+        }
+
         /** <inheritDoc /> */
         public IBinaryProcessor BinaryProcessor
         {
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/Services/ServicesClient.cs b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/Services/ServicesClient.cs
new file mode 100644
index 000000000000..a650b214f0c5
--- /dev/null
+++ b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Client/Services/ServicesClient.cs
@@ -0,0 +1,157 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+namespace Apache.Ignite.Core.Impl.Client.Services
+{
+    using System;
+    using System.Diagnostics;
+    using System.Reflection;
+    using Apache.Ignite.Core.Client;
+    using Apache.Ignite.Core.Client.Services;
+    using Apache.Ignite.Core.Impl.Binary;
+    using Apache.Ignite.Core.Impl.Common;
+    using Apache.Ignite.Core.Impl.Services;
+
+    /// <summary>
+    /// Services client.
+    /// </summary>
+    internal class ServicesClient : IServicesClient
+    {
+        /** */
+        [Flags]
+        private enum ServiceFlags : byte
+        {
+            KeepBinary = 1,
+
+            // ReSharper disable once UnusedMember.Local
+            HasParameterTypes = 2
+        }
+
+        /** */
+        private readonly IgniteClient _ignite;
+
+        /** */
+        private readonly IClientClusterGroup _clusterGroup;
+
+        /** */
+        private readonly bool _keepBinary;
+
+        /** */
+        private readonly bool _serverKeepBinary;
+
+        /** */
+        private readonly TimeSpan _timeout;
+
+        /// <summary>
+        /// Initializes a new instance of <see cref="ServicesClient"/> class.
+        /// </summary>
+        public ServicesClient(
+            IgniteClient ignite,
+            IClientClusterGroup clusterGroup = null,
+            bool keepBinary = false,
+            bool serverKeepBinary = false,
+            TimeSpan timeout = default(TimeSpan))
+        {
+            Debug.Assert(ignite != null);
+
+            _ignite = ignite;
+            _clusterGroup = clusterGroup;
+            _keepBinary = keepBinary;
+            _serverKeepBinary = serverKeepBinary;
+            _timeout = timeout;
+        }
+
+        /** <inheritdoc /> */
+        public IClientClusterGroup ClusterGroup
+        {
+            get { return _clusterGroup ?? _ignite.GetCluster(); }
+        }
+
+        /** <inheritdoc /> */
+        public T GetServiceProxy<T>(string serviceName) where T : class
+        {
+            IgniteArgumentCheck.NotNullOrEmpty(serviceName, "name");
+
+            return ServiceProxyFactory<T>.CreateProxy((method, args) => InvokeProxyMethod(serviceName, method, args));
+        }
+
+        /** <inheritdoc /> */
+        public IServicesClient WithKeepBinary()
+        {
+            return new ServicesClient(_ignite, _clusterGroup, true, _serverKeepBinary, _timeout);
+        }
+
+        /** <inheritdoc /> */
+        public IServicesClient WithServerKeepBinary()
+        {
+            return new ServicesClient(_ignite, _clusterGroup, _keepBinary, true, _timeout);
+        }
+
+        /// <summary>
+        /// Invokes the proxy method.
+        /// </summary>
+        private object InvokeProxyMethod(string serviceName, MethodBase method, object[] args)
+        {
+            return _ignite.Socket.DoOutInOp(
+                ClientOp.ServiceInvoke,
+                ctx =>
+                {
+                    var w = ctx.Writer;
+
+                    w.WriteString(serviceName);
+                    w.WriteByte(_serverKeepBinary ? (byte) ServiceFlags.KeepBinary : (byte) 0);
+                    w.WriteLong((long) _timeout.TotalMilliseconds);
+
+                    if (_clusterGroup != null)
+                    {
+                        var nodes = _clusterGroup.GetNodes();
+                        if (nodes.Count == 0)
+                        {
+                            throw new IgniteClientException("Cluster group is empty");
+                        }
+
+                        w.WriteInt(nodes.Count);
+
+                        foreach (var node in nodes)
+                        {
+                            BinaryUtils.WriteGuid(node.Id, ctx.Stream);
+                        }
+                    }
+                    else
+                    {
+                        w.WriteInt(0);
+                    }
+
+                    w.WriteString(method.Name);
+
+                    w.WriteInt(args.Length);
+                    foreach (var arg in args)
+                    {
+                        w.WriteObjectDetached(arg);
+                    }
+                },
+                ctx =>
+                {
+                    var reader = _keepBinary
+                        ? ctx.Marshaller.StartUnmarshal(ctx.Stream, BinaryMode.ForceBinary)
+                        : ctx.Reader;
+
+                    return reader.ReadObject<object>();
+                });
+        }
+    }
+}
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Common/DelegateConverter.cs b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Common/DelegateConverter.cs
index 6daea7c97ff3..256d3e76d589 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Common/DelegateConverter.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Common/DelegateConverter.cs
@@ -26,10 +26,12 @@ namespace Apache.Ignite.Core.Impl.Common
     using System.Reflection;
     using System.Reflection.Emit;
     using Apache.Ignite.Core.Binary;
+    using Apache.Ignite.Core.Common;
 
     /// <summary>
     /// Converts generic and non-generic delegates.
     /// </summary>
+    [CLSCompliant(false)]
     public static class DelegateConverter
     {
         /** */
@@ -39,9 +41,30 @@ public static class DelegateConverter
         private static readonly MethodInfo ReadObjectMethod = typeof (IBinaryRawReader).GetMethod("ReadObject");
 
         /** */
-        private static readonly MethodInfo ConvertArrayMethod = typeof(DelegateConverter).GetMethod("ConvertArray",
+        public static readonly MethodInfo ConvertArrayMethod = typeof(DelegateConverter).GetMethod(
+            "ConvertArray",
             BindingFlags.Static | BindingFlags.NonPublic);
 
+        /** */
+        public static readonly MethodInfo ConvertToSbyteArrayMethod = typeof(DelegateConverter).GetMethod(
+            "ConvertToSbyteArray",
+            BindingFlags.Static | BindingFlags.Public);
+
+        /** */
+        public static readonly MethodInfo ConvertToUshortArrayMethod = typeof(DelegateConverter).GetMethod(
+            "ConvertToUshortArray",
+            BindingFlags.Static | BindingFlags.Public);
+
+        /** */
+        public static readonly MethodInfo ConvertToUintArrayMethod = typeof(DelegateConverter).GetMethod(
+            "ConvertToUintArray",
+            BindingFlags.Static | BindingFlags.Public);
+
+        /** */
+        public static readonly MethodInfo ConvertToUlongArrayMethod = typeof(DelegateConverter).GetMethod(
+            "ConvertToUlongArray",
+            BindingFlags.Static | BindingFlags.Public);
+
         /// <summary>
         /// Compiles a function without arguments.
         /// </summary>
@@ -532,13 +555,61 @@ public static ConstructorInfo GetConstructorExact(Type type, Type[] types)
         /// </summary>
         private static Expression Convert(Expression value, Type targetType)
         {
-            if (targetType.IsArray && targetType.GetElementType() != typeof(object))
+            if (targetType.IsArray)
             {
-                var convertMethod = ConvertArrayMethod.MakeGenericMethod(targetType.GetElementType());
+                var elType = targetType.GetElementType();
+                Debug.Assert(elType != null);
+
+                if (elType == typeof(sbyte))
+                {
+                    return Expression.Call(null, ConvertToSbyteArrayMethod, value);
+                }
 
-                var objArray = Expression.Convert(value, typeof(object[]));
+                if (elType == typeof(ushort))
+                {
+                    return Expression.Call(null, ConvertToUshortArrayMethod, value);
+                }
 
-                return Expression.Call(null, convertMethod, objArray);
+                if (elType == typeof(uint))
+                {
+                    return Expression.Call(null, ConvertToUintArrayMethod, value);
+                }
+
+                if (elType == typeof(ulong))
+                {
+                    return Expression.Call(null, ConvertToUlongArrayMethod, value);
+                }
+
+                if (elType != typeof(object))
+                {
+                    var convertMethod = ConvertArrayMethod.MakeGenericMethod(targetType.GetElementType());
+
+                    return Expression.Call(null, convertMethod, value);
+                }
+
+                return Expression.Convert(value, targetType);
+            }
+
+            // For byte/sbyte and the like, simple Convert fails
+            // E.g. the following does not work:   (sbyte)(object)((byte)1)
+            // But this does:                      (sbyte)(byte)(object)((byte)1)
+            // So for every "unsupported" type like sbyte, ushort, uint, ulong
+            // we have to do an additional conversion
+            if (targetType == typeof(sbyte))
+            {
+                value = Expression.Convert(value, typeof(byte));
+            }
+            else if (targetType == typeof(ushort))
+            {
+                value = Expression.Convert(value, typeof(short));
+            }
+            else if (targetType == typeof(uint))
+            {
+                value = Expression.Convert(value, typeof(int));
+            }
+            else if (targetType == typeof(ulong))
+            {
+                value = Expression.Convert(value, typeof(long));
             }
 
             return Expression.Convert(value, targetType);
@@ -548,8 +619,9 @@ private static Expression Convert(Expression value, Type targetType)
         /// Converts object array to typed array.
         /// </summary>
         // ReSharper disable once UnusedMember.Local (used by reflection).
-        private static T[] ConvertArray<T>(object[] arr)
+        private static T[] ConvertArray<T>(object arrObj)
         {
+            var arr = arrObj as Array;
             if (arr == null)
             {
                 return null;
@@ -561,5 +633,64 @@ private static T[] ConvertArray<T>(object[] arr)
 
             return res;
         }
+
+        /// <summary>
+        /// Converts to sbyte array.
+        /// </summary>
+        // ReSharper disable once UnusedMember.Global
+        public static sbyte[] ConvertToSbyteArray(object arrObj)
+        {
+            return ConvertValueTypeArray<byte, sbyte>(arrObj, 1);
+        }
+
+        /// <summary>
+        /// Converts to ushort array.
+        /// </summary>
+        // ReSharper disable once UnusedMember.Global
+        public static ushort[] ConvertToUshortArray(object arrObj)
+        {
+            return ConvertValueTypeArray<short, ushort>(arrObj, 2);
+        }
+
+        /// <summary>
+        /// Converts to uint array.
+        /// </summary>
+        // ReSharper disable once UnusedMember.Global
+        public static uint[] ConvertToUintArray(object arrObj)
+        {
+            return ConvertValueTypeArray<int, uint>(arrObj, 4);
+        }
+
+        /// <summary>
+        /// Converts to ulong array.
+        /// </summary>
+        // ReSharper disable once UnusedMember.Global
+        public static ulong[] ConvertToUlongArray(object arrObj)
+        {
+            return ConvertValueTypeArray<long, ulong>(arrObj, 8);
+        }
+
+        /// <summary>
+        /// Converts value type array to another type using direct copy.
+        /// </summary>
+        private static T[] ConvertValueTypeArray<TFrom, T>(object arrObj, int elementSize)
+        {
+            if (arrObj == null)
+            {
+                return null;
+            }
+
+            var arr = arrObj as TFrom[];
+            if (arr == null)
+            {
+                throw new IgniteException(string.Format("Can't convert '{0}' to '{1}'", arrObj.GetType(), typeof(T[])));
+            }
+
+            var res = new T[arr.Length];
+
+            Buffer.BlockCopy(arr, 0, res, 0, arr.Length * elementSize);
+
+            return res;
+        }
     }
 }
diff --git a/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Services/ServiceProxyTypeGenerator.cs b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Services/ServiceProxyTypeGenerator.cs
index 8c84ccd6df74..0d332a90082b 100644
--- a/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Services/ServiceProxyTypeGenerator.cs
+++ b/modules/platforms/dotnet/Apache.Ignite.Core/Impl/Services/ServiceProxyTypeGenerator.cs
@@ -24,6 +24,7 @@ namespace Apache.Ignite.Core.Impl.Services
     using System.Reflection;
     using System.Reflection.Emit;
     using Apache.Ignite.Core.Impl.Binary;
+    using Apache.Ignite.Core.Impl.Common;
     using ProxyAction = System.Func<System.Reflection.MethodBase, object[], object>;
 
     /// <summary>
@@ -276,8 +277,7 @@ private static void GenerateMethod(ProxyBuildContext buildContext, int methodInd
             // Load result.
             if (method.ReturnType != typeof(void))
             {
-                if (method.ReturnType.IsValueType)
-                    gen.Emit(OpCodes.Unbox_Any, method.ReturnType);
+                EmitReturn(gen, method);
             }
             else
             {
@@ -288,6 +288,53 @@ private static void GenerateMethod(ProxyBuildContext buildContext, int methodInd
             gen.Emit(OpCodes.Ret);
         }
 
+        /// <summary>
+        /// Emits the returned value, converting as necessary.
+        /// </summary>
+        private static void EmitReturn(ILGenerator gen, MethodInfo method)
+        {
+            if (method.ReturnType == typeof(sbyte))
+            {
+                gen.Emit(OpCodes.Unbox_Any, typeof(byte));
+                gen.Emit(OpCodes.Conv_I1);
+            }
+            else if (method.ReturnType == typeof(ushort))
+            {
+                gen.Emit(OpCodes.Unbox_Any, typeof(short));
+                gen.Emit(OpCodes.Conv_U2);
+            }
+            else if (method.ReturnType == typeof(uint))
+            {
+                gen.Emit(OpCodes.Unbox_Any, typeof(int));
+                gen.Emit(OpCodes.Conv_U4);
+            }
+            else if (method.ReturnType == typeof(ulong))
+            {
+                gen.Emit(OpCodes.Unbox_Any, typeof(long));
+                gen.Emit(OpCodes.Conv_U8);
+            }
+            else if (method.ReturnType == typeof(sbyte[]))
+            {
+                gen.Emit(OpCodes.Call, DelegateConverter.ConvertToSbyteArrayMethod);
+            }
+            else if (method.ReturnType == typeof(ushort[]))
+            {
+                gen.Emit(OpCodes.Call, DelegateConverter.ConvertToUshortArrayMethod);
+            }
+            else if (method.ReturnType == typeof(uint[]))
+            {
+                gen.Emit(OpCodes.Call, DelegateConverter.ConvertToUintArrayMethod);
+            }
+            else if (method.ReturnType == typeof(ulong[]))
+            {
+                gen.Emit(OpCodes.Call, DelegateConverter.ConvertToUlongArrayMethod);
+            }
+            else if (method.ReturnType.IsValueType)
+            {
+                gen.Emit(OpCodes.Unbox_Any, method.ReturnType);
+            }
+        }
+
         /// <summary>
         /// Proxy build state.
         /// </summary>
diff --git a/modules/platforms/python/pyignite/api/sql.py b/modules/platforms/python/pyignite/api/sql.py
index f2f96fcbbc9e..1a184961bd39 100644
--- a/modules/platforms/python/pyignite/api/sql.py
+++ b/modules/platforms/python/pyignite/api/sql.py
@@ -441,10 +441,7 @@ def sql_fields_cursor_get_page(
         'more': value['more']
     }
     for row_dict in value['data']:
-        row = []
-        for field_key in sorted(row_dict.keys()):
-            row.append(row_dict[field_key])
-        result.value['data'].append(row)
+        result.value['data'].append(list(row_dict.values()))
     return result
 
 
diff --git a/modules/platforms/python/pyignite/connection/__init__.py b/modules/platforms/python/pyignite/connection/__init__.py
index 32decdf69dc4..1f6f0c0c55c0 100644
--- a/modules/platforms/python/pyignite/connection/__init__.py
+++ b/modules/platforms/python/pyignite/connection/__init__.py
@@ -77,6 +77,7 @@ def _check_kwargs(kwargs):
             'ssl_ciphers',
             'ssl_cert_reqs',
             'ssl_keyfile',
+            'ssl_keyfile_password',
             'ssl_certfile',
             'ssl_ca_certfile',
             'username',
@@ -118,6 +119,9 @@ def __init__(self, prefetch: bytes=b'', **kwargs):
 
         :param ssl_keyfile: (optional) a path to SSL key file to identify
          local (client) party,
+        :param ssl_keyfile_password: (optional) password for SSL key file,
+         can be provided when key file is encrypted to prevent OpenSSL
+         password prompt,
         :param ssl_certfile: (optional) a path to ssl certificate file
          to identify local (client) party,
         :param ssl_ca_certfile: (optional) a path to a trusted certificate
diff --git a/modules/platforms/python/pyignite/connection/ssl.py b/modules/platforms/python/pyignite/connection/ssl.py
index 548ca7f22520..044b103598f2 100644
--- a/modules/platforms/python/pyignite/connection/ssl.py
+++ b/modules/platforms/python/pyignite/connection/ssl.py
@@ -14,6 +14,7 @@
 # limitations under the License.
 
 import ssl
+from ssl import SSLContext
 
 from pyignite.constants import *
 
@@ -21,19 +22,28 @@
 def wrap(client, _socket):
     """ Wrap socket in SSL wrapper. """
     if client.init_kwargs.get('use_ssl', None):
-        _socket = ssl.wrap_socket(
-            _socket,
-            ssl_version=client.init_kwargs.get(
-                'ssl_version', SSL_DEFAULT_VERSION
-            ),
-            ciphers=client.init_kwargs.get(
-                'ssl_ciphers', SSL_DEFAULT_CIPHERS
-            ),
-            cert_reqs=client.init_kwargs.get(
-                'ssl_cert_reqs', ssl.CERT_NONE
-            ),
-            keyfile=client.init_kwargs.get('ssl_keyfile', None),
-            certfile=client.init_kwargs.get('ssl_certfile', None),
-            ca_certs=client.init_kwargs.get('ssl_ca_certfile', None),
-        )
+        keyfile = client.init_kwargs.get('ssl_keyfile', None)
+        certfile = client.init_kwargs.get('ssl_certfile', None)
+
+        if keyfile and not certfile:
+            raise ValueError("certfile must be specified")
+
+        password = client.init_kwargs.get('ssl_keyfile_password', None)
+        ssl_version = client.init_kwargs.get('ssl_version', SSL_DEFAULT_VERSION)
+        ciphers = client.init_kwargs.get('ssl_ciphers', SSL_DEFAULT_CIPHERS)
+        cert_reqs = client.init_kwargs.get('ssl_cert_reqs', ssl.CERT_NONE)
+        ca_certs = client.init_kwargs.get('ssl_ca_certfile', None)
+
+        context = SSLContext(ssl_version)
+        context.verify_mode = cert_reqs
+        
+        if ca_certs:
+            context.load_verify_locations(ca_certs)
+        if certfile:
+            context.load_cert_chain(certfile, keyfile, password)
+        if ciphers:
+            context.set_ciphers(ciphers)
+
+        _socket = context.wrap_socket(sock=_socket)
+
     return _socket
diff --git a/modules/platforms/python/tests/config/ssl.xml b/modules/platforms/python/tests/config/ssl.xml
new file mode 100644
index 000000000000..d9d406f61c84
--- /dev/null
+++ b/modules/platforms/python/tests/config/ssl.xml
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+
+<beans xmlns="http://www.springframework.org/schema/beans"
+       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+       xsi:schemaLocation="
+        http://www.springframework.org/schema/beans
+        http://www.springframework.org/schema/beans/spring-beans.xsd">
+
+    <!--
+        Initialize property configurer so we can reference environment variables.
+    -->
+    <bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
+        <property name="systemPropertiesModeName" value="SYSTEM_PROPERTIES_MODE_FALLBACK"/>
+        <property name="searchSystemEnvironment" value="true"/>
+    </bean>
+  
+    <bean id="test.cfg" class="org.apache.ignite.configuration.IgniteConfiguration">
+        <property name="localHost" value="127.0.0.1"/>
+        <property name="connectorConfiguration"><null/></property>
+
+        <property name="clientConnectorConfiguration">
+            <bean class="org.apache.ignite.configuration.ClientConnectorConfiguration">
+                <property name="host" value="127.0.0.1"/>
+                <property name="portRange" value="10"/>
+                <property name="sslEnabled" value="true"/>
+                <property name="useIgniteSslContextFactory" value="false"/>
+                <property name="sslClientAuth" value="true"/>
+
+                <!-- Provide Ssl context. -->
+                <property name="sslContextFactory">
+                    <bean class="org.apache.ignite.ssl.SslContextFactory">
+                        <property name="keyStoreFilePath" value="${PYTHON_TEST_CONFIG_PATH}/ssl/server.jks"/>
+                        <property name="keyStorePassword" value="123456"/>
+                        <property name="trustStoreFilePath" value="${PYTHON_TEST_CONFIG_PATH}/ssl/trust.jks"/>
+                        <property name="trustStorePassword" value="123456"/>
+                    </bean>
+                </property>
+            </bean>
+        </property>
+    </bean>
+</beans>
\ No newline at end of file
diff --git a/modules/platforms/python/tests/config/ssl/README.txt b/modules/platforms/python/tests/config/ssl/README.txt
new file mode 100644
index 000000000000..eca07eaf1ce4
--- /dev/null
+++ b/modules/platforms/python/tests/config/ssl/README.txt
@@ -0,0 +1,3 @@
+These files generated using script
+`$IGNITE_SRC/modules/platforms/cpp/thin-client-test/config/ssl/generate_certificates.sh`
+To update them just run script and move files to this folder.
\ No newline at end of file
diff --git a/modules/platforms/python/tests/config/ssl/client_full.pem b/modules/platforms/python/tests/config/ssl/client_full.pem
new file mode 100644
index 000000000000..82609284656f
--- /dev/null
+++ b/modules/platforms/python/tests/config/ssl/client_full.pem
@@ -0,0 +1,52 @@
+-----BEGIN PRIVATE KEY-----
+MIIEvwIBADANBgkqhkiG9w0BAQEFAASCBKkwggSlAgEAAoIBAQCnW8A/wVcIQL7O
+T197f6YSl572HyXZbhAMXU9CIT5Er1TDUETPHE2cslvkXSvpMkaI61ftPelEfoir
+IVyuoJb4c6rnPLtnt+LfUmN8MS8C+vsZPw6gaZW6JIKGMLsUo/nmz986C9AfuSco
+auVFQC+48pHjzXUQ+sGvnAQjSaz/U5+0pKMJBMxxmcwLSn6vopz7859X08odWdV2
+5sq6irJW+w/93vuYdBXqlFthjMSVzOBhFTeTYw6db+CmNofG+EMjqP9lB5rPGLHb
+qbOJx3jv8dvTxECtoc2myAmQrUB9+xXX6/90j2HRuNu2BauPsmpfq7lNvjV/Bea/
+hnhFl+anAgMBAAECggEBAIsACYzqZ/7Sx6dTBVrtimGmzMBe3nDYmTurxEiIk884
+UI5n/L6II24iNXBWckIdH7hYv46r/TKGZby82N2xQ7LXXvrv1jcu45/YLgjYUNOI
+4UT2uo9BIrqX2FDb6IYcK1MpE56CcTnn7j4DiqkZxok17zXlT3XqzzOrwUQNzUHC
+Oo3vPRzZBYqyLknyIqNP5fZoJbVgH469ka6s6oOyOzW5fTvPdlK/lWqAdqf7GJEV
+1xwVsDOy1NvrxXwqz3knq3yykkErYFXi7Wf4AcCMH0n42kWQwWh4w3Ug+TtcRe4c
+Y7qcQFa3GVeVDIB4komCtezOhHGG4upRuwK4fko1iwECgYEA2OCIHqjvWEmOsB3G
+2c7ci78NNjOVn12NhiX671wALnJ+IqVlHUg1TUV8lu7oK8rHLDhiQPiM9aTc1012
++3pwSn9l2z5UtEt4KxeRc14lCOMST+mZe/SDf7TLQsj26oOWJksT9UfxT2AtzcvF
+Xy51uG+0Ve32s1OZiGp04lORPtMCgYEAxYxtbxkYJsg2yXjf/d97hr+eMGoyoWxv
+TIytIWyNh8SinQdyjyPlMrMjDKXhPuMvWocAkDiLtd9wHSzgTV8VkdRuajDxptjL
+Z0Kjt9pMp1SMTNzfCMflDviWq46SXEAQkm7lAag3zqZNB34rI5WpW8dPf/gIIJCc
+zegqadYXHF0CgYAOi0g1niim6A/smaKbOrcpm/9b0ivHizORenyQjr/oXX89/Y+B
+XjVM4EsRqCXjwe6HdaSJLOHvG0ZAHg7LoJNlO5PuFwkBKkp9wU/cx8R+CxRQTZ8g
+Y+5pows6iFWetoJcQQ6ulUuGgjGwKmkrD+ePHdafKJ0xu3qBXnpGL0p/RwKBgQCm
+xDZ57EhMLQa7LBSDf88K4OZM3snhJeYLTFK3fak47RGN2ISoO9g35av3+GzfJvCJ
+zp/2IBYpMfe2WXT9PAC8fAW+FZVakXecs0/8XAgL1j8ef/K0ufMvoUGokBIUWGzl
+AULIFFcQV6l9YtBOGQDAntAJKrzJqOsGlDCB6h7WbQKBgQCnF1SuakiToiv7TQHk
+KQT6kUGqBO7hSfGG3jx2alATXww46iCj2Op8dcIYcM1vPCSFlMgI4zlgX01tap2/
++LDtehygTY11jm6q8adoplqGN8LlotXeBTwgN2COdNbhh6Nj+9M+yCl749nnBfd7
+17EiuQzTB8B4oK9dfvDK07hq3w==
+-----END PRIVATE KEY-----
+-----BEGIN CERTIFICATE-----
+MIIEBTCCAu0CCQDvTawLdBCCFDANBgkqhkiG9w0BAQsFADCBvzELMAkGA1UEBhMC
+VVMxFjAUBgNVBAgMDU1hc3NhY2h1c2V0dHMxEjAQBgNVBAcMCVdha2VmaWVsZDEa
+MBgGA1UEAwwRaWduaXRlLmFwYWNoZS5vcmcxJzAlBgNVBAoMHlRoZSBBcGFjaGUg
+U29mdHdhcmUgRm91bmRhdGlvbjEZMBcGA1UECwwQQXBhY2hlIElnbml0ZSBDQTEk
+MCIGCSqGSIb3DQEJARYVZGV2QGlnbml0ZS5hcGFjaGUub3JnMB4XDTIwMDgzMTA5
+MjgyNVoXDTMwMDgyOTA5MjgyNVowgcgxCzAJBgNVBAYTAlVTMRYwFAYDVQQIDA1N
+YXNzYWNodXNldHRzMRIwEAYDVQQHDAlXYWtlZmllbGQxGjAYBgNVBAMMEWlnbml0
+ZS5hcGFjaGUub3JnMScwJQYDVQQKDB5UaGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5k
+YXRpb24xIjAgBgNVBAsMGUFwYWNoZSBJZ25pdGUgQ2xpZW50IFRlc3QxJDAiBgkq
+hkiG9w0BCQEWFWRldkBpZ25pdGUuYXBhY2hlLm9yZzCCASIwDQYJKoZIhvcNAQEB
+BQADggEPADCCAQoCggEBAKdbwD/BVwhAvs5PX3t/phKXnvYfJdluEAxdT0IhPkSv
+VMNQRM8cTZyyW+RdK+kyRojrV+096UR+iKshXK6glvhzquc8u2e34t9SY3wxLwL6
++xk/DqBplbokgoYwuxSj+ebP3zoL0B+5Jyhq5UVAL7jykePNdRD6wa+cBCNJrP9T
+n7SkowkEzHGZzAtKfq+inPvzn1fTyh1Z1XbmyrqKslb7D/3e+5h0FeqUW2GMxJXM
+4GEVN5NjDp1v4KY2h8b4QyOo/2UHms8Ysdups4nHeO/x29PEQK2hzabICZCtQH37
+Fdfr/3SPYdG427YFq4+yal+ruU2+NX8F5r+GeEWX5qcCAwEAATANBgkqhkiG9w0B
+AQsFAAOCAQEAiE2xX2uNRmsPMfVA//nbc6Djj+a/FEqJ2OvqVTaJPw5M2Jw8F+XG
+sd09qXXCKpBtihBrbnoHQIQNUTOAkuxrCkRCubQ0w7PQTomOX/cXQdMPdgWa27Oi
+Li7Pq2FwAEwhnSfOPwrj+2XU1bzwwIMdT85XD9KQFirIzGaAnGMN08pNxRROlOyV
+bOqIptP9DGuM51lKNd+rNoBY1C29pnYoitFjarRkNfOwJqBabPacDvjZLuo/CP8Z
+KmhjH3W1AtcRNGNrlaqsaS02Ny6SgvXWKNKtp5xRpwmOZ6YT8Q2pHXPfE8mjCvl0
+Cu6HiNMP8LUdxriKDtdHZbhBCAfnjzBzUw==
+-----END CERTIFICATE-----
diff --git a/modules/platforms/python/tests/config/ssl/client_with_pass_full.pem b/modules/platforms/python/tests/config/ssl/client_with_pass_full.pem
new file mode 100644
index 000000000000..a53bc5193fff
--- /dev/null
+++ b/modules/platforms/python/tests/config/ssl/client_with_pass_full.pem
@@ -0,0 +1,54 @@
+-----BEGIN RSA PRIVATE KEY-----
+Proc-Type: 4,ENCRYPTED
+DEK-Info: AES-256-CBC,42A0C0A0F7D8E31ABF5BE4EC262E2881
+
+j6XDTAvm5OI12CmE/UlK9NTTWbvwuoKcuqaYlPxPtPdO9tZ7RxdPLX0aasi4ALPm
+WF1oe1SmPAneXQrHejxb/mw1rliqwVwEblSdXUEtq4ZFSGwy+YmYXP62XNKwColM
+BppNX87MxS5hu6wsV2cuML7e/Y5wUro04Tk2kXoraVXyxLChKffY68rzih1pv5d1
+cA4lFqvMNBbIOGIUIRX60eZSlZ6XS5oZY9pc7O+KOUH7e8Pa3dFEbdXgbSX+dGLt
+DhV7bb1sciuJDBC7F9HjZem5YkKt44AkwfL3v/m7kGTaESNN2/NYemNGsth+HmF6
+nWB5ver1dQ3iGG1gLLmLbDyXcmOHSxWIcagqN0/bX08gBdBIWiTTHx7k3ke8z5QO
+8T+Yx6O6O0ccLWYZUnA3Dw4vNEV8Xn1V2+e0Z0uhTt0kf2bu4xCwkmrlREjcqtMD
+8OAzzhiyQjJGmbQQpTrVKdIT5e3Ux+PKzaUo5U1ZP8s7b76VxjsmljXrFV9I4qLC
+/NP22GH71F+p68qaawldw/ljtx9KuVYGD3cbvN5bF3VDUSf4HoI56U/WrfM1/P+/
+27yLYGEb8g4kzIp0GjC50CkFZRTAG/C5kh5mo+L8A5kQ77z8Utn75FnnUDuL22Pa
+qnJE7IWFWITA0f3KE62oiIxx//+rxy4KneYKv9HLRjqd7p0Yzv9XhyBlXtFRX9g0
+ji8M0lvJGwDxarH6BTFozLYfjFo92FG5la0GJS/uPOXaly2DFElg71pA24xGlgr0
+u6Cprge5T95VVFKOEJ6z5M0tTtfKPXnD+vb9FfIotKWr03+palUANGuXAIf3C++a
+NfUm6R7dZ3nUGk4+L+U+NsyIGEMYnBLD5jgSVGg8q3MiUb6Zwy3lV0maoNV3pizt
+QrWWlSuo6fUAkFEADyEhy305FhjWBTsJ5ZP+D75Joh5tR7gzDhl0Xg4nyTQ+QUM+
+6E/yBsEIjunITQeDOf7Il8Jg/07T0StH9RllWnz7/UTAD4SYrrPs5Fvn1heIP/aO
+s/ER7Ip2YVhr0U4aCFzzuxSuWRRJCEE7Rb0AYT7pU4/iTu2tQYQV/VAMaK+PM0O6
+j5YwnV7fVZBjs3BgZodu+qm/8bK7fSjG8qQQ50jEcQZmkqEuBbJRIi4RNvBpm1Eo
+q79CuxhAPBM69jmJao5cxKOj3zRzI3ZamT6cMcssz/HkgEKO4H9rr2ZKB4xCeR7n
+QUo9bQbnq5W4xbei23Zk5/Tg8g0lUdfhiNTa+0mQap7Vnl7SQaaH4MfKEpdzm7eW
+73eIvl4HVOtp76SIV82wMMW+IVzcikpFwQpP8EEq+XGZFk/zY1tptsRy2USadM4Y
+Hjpyx4ZOYFg0HKI0vc2TuMo2AvmgyL1/zBB4DC44OUEW8TuUoX20rYhtq3alqlpl
+ieHAyqIDeZV+//FSMSDiHR4TAWQu4LnH/3G0MIZYnp9jyqjc7fF+uXfdSiCqGFn3
+DP9nU/PyL0fYFXnNlL8Lazyhi7ETvn694ni/HdElXnqugAIBdaRcwjqfaZ0XA0ho
+QGOSiPEYkJL19x93C96EXmBxW+Y72uxlEeEYuFafSegIypOkf4swgzlfdsaVq2uo
+-----END RSA PRIVATE KEY-----
+-----BEGIN CERTIFICATE-----
+MIIEBTCCAu0CCQDvTawLdBCCFTANBgkqhkiG9w0BAQsFADCBvzELMAkGA1UEBhMC
+VVMxFjAUBgNVBAgMDU1hc3NhY2h1c2V0dHMxEjAQBgNVBAcMCVdha2VmaWVsZDEa
+MBgGA1UEAwwRaWduaXRlLmFwYWNoZS5vcmcxJzAlBgNVBAoMHlRoZSBBcGFjaGUg
+U29mdHdhcmUgRm91bmRhdGlvbjEZMBcGA1UECwwQQXBhY2hlIElnbml0ZSBDQTEk
+MCIGCSqGSIb3DQEJARYVZGV2QGlnbml0ZS5hcGFjaGUub3JnMB4XDTIwMDgzMTA5
+MjgyNVoXDTMwMDgyOTA5MjgyNVowgcgxCzAJBgNVBAYTAlVTMRYwFAYDVQQIDA1N
+YXNzYWNodXNldHRzMRIwEAYDVQQHDAlXYWtlZmllbGQxGjAYBgNVBAMMEWlnbml0
+ZS5hcGFjaGUub3JnMScwJQYDVQQKDB5UaGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5k
+YXRpb24xIjAgBgNVBAsMGUFwYWNoZSBJZ25pdGUgQ2xpZW50IFRlc3QxJDAiBgkq
+hkiG9w0BCQEWFWRldkBpZ25pdGUuYXBhY2hlLm9yZzCCASIwDQYJKoZIhvcNAQEB
+BQADggEPADCCAQoCggEBAPXi2AbcfKK/BdGWIZZvXyICOfLXXXNezAo1fiVs5LfG
+C5v0lBSmxeu1NYRF05Wf4/mEmVZnhzoVxViQWlUbL6M6A/VrrZPOF421tloiz/1J
+hBfVI91JBji2cP78HvdPAGIHg5zLlgGUxaKxgvRfm3v43hc3YvzXo8Adg6QBMNdQ
+m3co5L887lhixCHZh/FcncbaXSwRSZJtS9B1DiCUVIlfcAIkn80xL2bJ5giS5vwH
+pKZagoykaVbwrd3ObHGQtCZ/TtLM5gseDfppEWRtZv5wmJEejcHot5nSfUIrDuuY
+7MO6flSy6yshSXbk2eAQ8YCLywwSm87uA3PrOeX77PsCAwEAATANBgkqhkiG9w0B
+AQsFAAOCAQEAI+2iiMcS1ks7YZZb9H/Oa1Il4wOOC+OEkFsVBLBKtUiEYkBJHykg
+BPguDjd/wXfCRb8FgG28JUfhzcvEIZB18tb1updKvEsLZUfPGXI89vUTshi51hy7
+VoOAJMyzJRWDP37MAtnTAu0uS205Q+8VE/adDrdjDQKBGF98OkXQVsxyfckzY2Za
+mmCmOWdJWTZH/5eh+2ogvsGDy9VXYyQlhNNl5oLVldPL4AjanKfIwaYIwYZXyKV9
+2+2lkkM7ikY6WxCHct41IuyBx5Nty2zu5tdLoQd1lII4u1c0t5AfrJYyWjeNMMnF
++e9wWnM1ivfHESAHFzhdzSbXuEFHlq3F1w==
+-----END CERTIFICATE-----
diff --git a/modules/platforms/python/tests/config/ssl/server.jks b/modules/platforms/python/tests/config/ssl/server.jks
new file mode 100644
index 000000000000..e6a9c1a42e94
Binary files /dev/null and b/modules/platforms/python/tests/config/ssl/server.jks differ
diff --git a/modules/platforms/python/tests/config/ssl/trust.jks b/modules/platforms/python/tests/config/ssl/trust.jks
new file mode 100644
index 000000000000..0bc72107444e
Binary files /dev/null and b/modules/platforms/python/tests/config/ssl/trust.jks differ
diff --git a/modules/platforms/python/tests/conftest.py b/modules/platforms/python/tests/conftest.py
index be6d02901976..f7e2e1f9b14a 100644
--- a/modules/platforms/python/tests/conftest.py
+++ b/modules/platforms/python/tests/conftest.py
@@ -66,7 +66,7 @@ def __call__(self, parser, namespace, values, option_string=None):
 
 @pytest.fixture(scope='module')
 def client(
-    ignite_host, ignite_port, timeout, use_ssl, ssl_keyfile, ssl_certfile,
+    ignite_host, ignite_port, timeout, use_ssl, ssl_keyfile, ssl_keyfile_password, ssl_certfile,
     ssl_ca_certfile, ssl_cert_reqs, ssl_ciphers, ssl_version,
     username, password,
 ):
@@ -74,6 +74,7 @@ def client(
         timeout=timeout,
         use_ssl=use_ssl,
         ssl_keyfile=ssl_keyfile,
+        ssl_keyfile_password=ssl_keyfile_password,
         ssl_certfile=ssl_certfile,
         ssl_ca_certfile=ssl_ca_certfile,
         ssl_cert_reqs=ssl_cert_reqs,
@@ -135,6 +136,13 @@ def pytest_addoption(parser):
         type=str,
         help='a path to SSL key file to identify local party'
     )
+    parser.addoption(
+        '--ssl-keyfile-password',
+        action='store',
+        default=None,
+        type=str,
+        help='password for SSL key file'
+    )
     parser.addoption(
         '--ssl-certfile',
         action='store',
@@ -199,6 +207,7 @@ def pytest_generate_tests(metafunc):
         'timeout': None,
         'use_ssl': False,
         'ssl_keyfile': None,
+        'ssl_keyfile_password': None,
         'ssl_certfile': None,
         'ssl_ca_certfile': None,
         'ssl_cert_reqs': ssl.CERT_NONE,
diff --git a/modules/platforms/python/tests/test_handshake.py b/modules/platforms/python/tests/test_handshake.py
index 54315f0edbcd..d655d941e1a9 100644
--- a/modules/platforms/python/tests/test_handshake.py
+++ b/modules/platforms/python/tests/test_handshake.py
@@ -21,13 +21,14 @@
 
 def test_handshake(
     monkeypatch,
-    ignite_host, ignite_port, use_ssl, ssl_keyfile, ssl_certfile,
+    ignite_host, ignite_port, use_ssl, ssl_keyfile, ssl_keyfile_password, ssl_certfile,
     ssl_ca_certfile, ssl_cert_reqs, ssl_ciphers, ssl_version,
     username, password,
 ):
     client = Client(
         use_ssl=use_ssl,
         ssl_keyfile=ssl_keyfile,
+        ssl_keyfile_password=ssl_keyfile_password,
         ssl_certfile=ssl_certfile,
         ssl_ca_certfile=ssl_ca_certfile,
         ssl_cert_reqs=ssl_cert_reqs,
diff --git a/modules/platforms/python/tests/test_sql.py b/modules/platforms/python/tests/test_sql.py
index d3c5f8420901..d983a2098b50 100644
--- a/modules/platforms/python/tests/test_sql.py
+++ b/modules/platforms/python/tests/test_sql.py
@@ -152,3 +152,33 @@ def test_sql_fields(client):
     # repeat cleanup
     result = sql_fields(client, 'PUBLIC', drop_query, page_size)
     assert result.status == 0
+
+
+def test_long_multipage_query(client):
+    """
+    The test creates a table with 13 columns (id and 12 enumerated columns)
+    and 20 records with id in range from 1 to 20. Values of enumerated columns
+    are = column number * id.
+
+    The goal is to ensure that all the values are selected in a right order.
+    """
+
+    fields = ["id", "abc", "ghi", "def", "jkl", "prs", "mno", "tuw", "zyz", "abc1", "def1", "jkl1", "prs1"]
+
+    client.sql('DROP TABLE LongMultipageQuery IF EXISTS')
+
+    client.sql("CREATE TABLE LongMultiPageQuery (%s, %s)" % \
+               (fields[0] + " INT(11) PRIMARY KEY", ",".join(map(lambda f: f + " INT(11)", fields[1:]))))
+
+    for id in range(1, 21):
+        client.sql(
+            "INSERT INTO LongMultipageQuery (%s) VALUES (%s)" % (",".join(fields), ",".join("?" * len(fields))),
+            query_args=[id] + list(i * id for i in range(1, len(fields))))
+
+    result = client.sql('SELECT * FROM LongMultipageQuery', page_size=1)
+    for page in result:
+        assert len(page) == len(fields)
+        for field_number, value in enumerate(page[1:], start=1):
+            assert value == field_number * page[0]
+
+    client.sql(drop_query)
diff --git a/pom.xml b/pom.xml
index f9fff5a0cc6e..4c2fd9364be6 100644
--- a/pom.xml
+++ b/pom.xml
@@ -74,7 +74,6 @@
         <module>modules/mesos</module>
         <module>modules/kafka</module>
         <module>modules/yarn</module>
-        <module>modules/jms11</module>
         <module>modules/zookeeper</module>
         <module>modules/hibernate-core</module>
         <module>modules/osgi-paxlogging</module>
