diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/CachePartitionPartialCountersMap.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/CachePartitionPartialCountersMap.java
index 04a0cdcfed1d..9a549177cec6 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/CachePartitionPartialCountersMap.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/CachePartitionPartialCountersMap.java
@@ -177,6 +177,17 @@ public long initialUpdateCounterAt(int idx) {
         return initialUpdCntrs[idx];
     }
 
+    /**
+     * Update initial counter by given index.
+     * It is used when iterated by WAL with a margin.
+     *
+     * @param idx Index.
+     * @param cntr Counter.
+     */
+    public void initialUpdateCounterAt(int idx, long cntr) {
+        initialUpdCntrs[idx] = cntr;
+    }
+
     /**
      * Gets update counter saved at the given index.
      *
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/GridDhtPartitionsExchangeFuture.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/GridDhtPartitionsExchangeFuture.java
index 0dd4b35bc291..48e1b9b2854e 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/GridDhtPartitionsExchangeFuture.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/GridDhtPartitionsExchangeFuture.java
@@ -3540,7 +3540,9 @@ private List<SupplyPartitionInfo> assignHistoricalSuppliers(
 
             long maxCntr = maxCntrObj != null ? maxCntrObj.cnt : 0;
 
-            NavigableSet<Long> nonMaxCntrs = e.getValue().headSet(maxCntr, false);
+            NavigableSet<Long> nonMaxCntrs = e.getValue().headSet(maxCntr, false)
+                // Empty partition cannot be rebalanced by history effectively.
+                .tailSet(0L, false);
 
             // If minimal counter equals maximum then historical supplier does not necessary.
             if (nonMaxCntrs.isEmpty())
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/IgniteHistoricalIteratorException.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/IgniteHistoricalIteratorException.java
index 5b641b253812..868cd55adeb2 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/IgniteHistoricalIteratorException.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/preloader/IgniteHistoricalIteratorException.java
@@ -45,4 +45,13 @@ public IgniteHistoricalIteratorException(Throwable cause) {
     public IgniteHistoricalIteratorException(String msg, Throwable cause) {
         super(msg, cause);
     }
+
+    /**
+     * Creates a new exception with the specified message.
+     *
+     * @param msg Detail message.
+     */
+    public IgniteHistoricalIteratorException(String msg) {
+        super(msg);
+    }
 }
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheDatabaseSharedManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheDatabaseSharedManager.java
index 371622613be4..3dc121a1c147 100755
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheDatabaseSharedManager.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheDatabaseSharedManager.java
@@ -1829,6 +1829,11 @@ private Map<Integer, Set<Integer>> partitionsApplicableForWalRebalance() {
         }
     }
 
+    /** {@inheritDoc} */
+    @Override public WALPointer latestWalPointerReservedForPreloading() {
+        return reservedForPreloading;
+    }
+
     /**
      *
      */
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheOffheapManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheOffheapManager.java
index ea0c7d1a9fcb..a01085d3b1d3 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheOffheapManager.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/GridCacheOffheapManager.java
@@ -122,6 +122,16 @@
  * Used when persistence enabled.
  */
 public class GridCacheOffheapManager extends IgniteCacheOffheapManagerImpl implements DbCheckpointListener {
+    /**
+     * Margin for WAL iterator, that used for historical rebalance on atomic cache.
+     * It is intended for prevent  partition divergence due to reordering in WAL.
+     * <p>
+     * Default is {@code 5}. Iterator starts from 5 updates earlier than expected.
+     *
+     */
+    private final long walAtomicCacheMargin = IgniteSystemProperties.getLong(
+        "WAL_MARGIN_FOR_ATOMIC_CACHE_HISTORICAL_REBALANCE", 5);
+
     /**
      * Throttling timeout in millis which avoid excessive PendingTree access on unwind
      * if there is nothing to clean yet.
@@ -1013,6 +1023,13 @@ private Metas getOrAllocateCacheMetas() throws IgniteCheckedException {
         if (grp.mvccEnabled()) // TODO IGNITE-7384
             return super.historicalIterator(partCntrs, missing);
 
+        GridCacheDatabaseSharedManager database = (GridCacheDatabaseSharedManager)grp.shared().database();
+
+        FileWALPointer latestReservedPointer = (FileWALPointer)database.latestWalPointerReservedForPreloading();
+
+        if (latestReservedPointer == null)
+            throw new IgniteHistoricalIteratorException("Historical iterator wasn't created, because WAL isn't reserved.");
+
         Map<Integer, Long> partsCounters = new HashMap<>();
 
         for (int i = 0; i < partCntrs.size(); i++) {
@@ -1022,14 +1039,18 @@ private Metas getOrAllocateCacheMetas() throws IgniteCheckedException {
             partsCounters.put(p, initCntr);
         }
 
-        GridCacheDatabaseSharedManager database = (GridCacheDatabaseSharedManager)grp.shared().database();
+        FileWALPointer minPtr = database.checkpointHistory().searchEarliestWalPointer(grp.groupId(),
+            partsCounters, latestReservedPointer, grp.hasAtomicCaches() ? walAtomicCacheMargin : 0L);
 
-        FileWALPointer minPtr = (FileWALPointer)database.checkpointHistory().searchEarliestWalPointer(grp.groupId(), partsCounters);
+        assert latestReservedPointer.compareTo(minPtr) <= 0
+            : "Historical iterator tries to iterate WAL out of reservation [cache=" + grp.cacheOrGroupName()
+            + ", reservedPointer=" + database.latestWalPointerReservedForPreloading()
+            + ", historicalPointer=" + minPtr + ']';
 
         try {
             WALIterator it = grp.shared().wal().replay(minPtr);
 
-            WALHistoricalIterator histIt = new WALHistoricalIterator(log, grp, partCntrs, it);
+            WALHistoricalIterator histIt = new WALHistoricalIterator(log, grp, partCntrs, partsCounters, it);
 
             // Add historical partitions which are unabled to reserve to missing set.
             missing.addAll(histIt.missingParts);
@@ -1220,7 +1241,11 @@ private static class WALHistoricalIterator implements IgniteHistoricalIterator {
          * @param grp Cache context.
          * @param walIt WAL iterator.
          */
-        private WALHistoricalIterator(IgniteLogger log, CacheGroupContext grp, CachePartitionPartialCountersMap partMap,
+        private WALHistoricalIterator(
+            IgniteLogger log,
+            CacheGroupContext grp,
+            CachePartitionPartialCountersMap partMap,
+            Map<Integer, Long> updatedPartCntr,
             WALIterator walIt) {
             this.log = log;
             this.grp = grp;
@@ -1231,8 +1256,13 @@ private WALHistoricalIterator(IgniteLogger log, CacheGroupContext grp, CachePart
 
             rebalancedCntrs = new long[partMap.size()];
 
-            for (int i = 0; i < rebalancedCntrs.length; i++)
-                rebalancedCntrs[i] = partMap.initialUpdateCounterAt(i);
+            for (int i = 0; i < rebalancedCntrs.length; i++) {
+                int p = partMap.partitionAt(i);
+
+                rebalancedCntrs[i] = updatedPartCntr.get(p);
+
+                partMap.initialUpdateCounterAt(i, rebalancedCntrs[i]);
+            }
 
             reservePartitions();
 
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/IgniteCacheDatabaseSharedManager.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/IgniteCacheDatabaseSharedManager.java
index a147cde02429..32ed5d13b13f 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/IgniteCacheDatabaseSharedManager.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/IgniteCacheDatabaseSharedManager.java
@@ -1079,6 +1079,15 @@ public void releaseHistoryForPreloading() {
         // No-op
     }
 
+    /**
+     * Returns the latest WAL pointer that reserved for preloading or {@code null}.
+     *
+     * @return WAL pointer or {@code null} if nothing reserved.
+     */
+    public WALPointer latestWalPointerReservedForPreloading() {
+        return null;
+    }
+
     /**
      * Checks that the given {@code region} has enough space for putting a new entry.
      *
diff --git a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/checkpoint/CheckpointHistory.java b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/checkpoint/CheckpointHistory.java
index 9a813666244e..511164ab5e2d 100644
--- a/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/checkpoint/CheckpointHistory.java
+++ b/modules/core/src/main/java/org/apache/ignite/internal/processors/cache/persistence/checkpoint/CheckpointHistory.java
@@ -22,6 +22,7 @@
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.NavigableMap;
@@ -296,11 +297,7 @@ public List<CheckpointEntry> onWalTruncated(WALPointer ptr) {
 
                 CheckpointEntry oldestCpInHistory = firstCheckpoint();
 
-                Iterator<Map.Entry<GroupPartitionId, CheckpointEntry>> iter = earliestCp.entrySet().iterator();
-
-                while (iter.hasNext()) {
-                    Map.Entry<GroupPartitionId, CheckpointEntry> grpPartPerCp = iter.next();
-
+                for (Map.Entry<GroupPartitionId, CheckpointEntry> grpPartPerCp : earliestCp.entrySet()) {
                     if (grpPartPerCp.getValue() == deletedCpEntry)
                         grpPartPerCp.setValue(oldestCpInHistory);
                 }
@@ -450,9 +447,16 @@ private IgniteBiTuple<Long, Long> calculateWalSegmentsCovered() {
      *
      * @param grpId Group id.
      * @param partsCounter Partition mapped to update counter.
+     * @param latestReservedPointer Latest reserved WAL pointer.
+     * @param margin Margin pointer.
      * @return Earliest WAL pointer for group specified.
      */
-    @Nullable public WALPointer searchEarliestWalPointer(int grpId, Map<Integer, Long> partsCounter) throws IgniteCheckedException {
+    @Nullable public FileWALPointer searchEarliestWalPointer(
+        int grpId,
+        Map<Integer, Long> partsCounter,
+        FileWALPointer latestReservedPointer,
+        long margin
+    ) throws IgniteCheckedException {
         if (F.isEmpty(partsCounter))
             return null;
 
@@ -460,11 +464,17 @@ private IgniteBiTuple<Long, Long> calculateWalSegmentsCovered() {
 
         FileWALPointer minPtr = null;
 
+        LinkedList<WalPointerCandidate> historyPointerCandidate = new LinkedList<>();
+
         for (Long cpTs : checkpoints(true)) {
             CheckpointEntry cpEntry = entry(cpTs);
 
+            minPtr = getMinimalPointer(partsCounter, margin, minPtr, historyPointerCandidate, cpEntry);
+
             Iterator<Map.Entry<Integer, Long>> iter = modifiedPartsCounter.entrySet().iterator();
 
+            FileWALPointer ptr = (FileWALPointer)cpEntry.checkpointMark();
+
             while (iter.hasNext()) {
                 Map.Entry<Integer, Long> entry = iter.next();
 
@@ -473,20 +483,27 @@ private IgniteBiTuple<Long, Long> calculateWalSegmentsCovered() {
                 if (foundCntr != null && foundCntr <= entry.getValue()) {
                     iter.remove();
 
-                    FileWALPointer ptr = (FileWALPointer)cpEntry.checkpointMark();
-
                     if (ptr == null) {
                         throw new IgniteCheckedException("Could not find start pointer for partition [part="
                             + entry.getKey() + ", partCntrSince=" + entry.getValue() + "]");
                     }
 
+                    if (foundCntr + margin > entry.getValue()) {
+                        historyPointerCandidate.add(new WalPointerCandidate(grpId, entry.getKey(), entry.getValue(), ptr,
+                            foundCntr));
+
+                        continue;
+                    }
+
+                    partsCounter.put(entry.getKey(), entry.getValue() - margin);
+
                     if (minPtr == null || ptr.compareTo(minPtr) < 0)
                         minPtr = ptr;
                 }
             }
 
-            if (F.isEmpty(modifiedPartsCounter))
-                return minPtr;
+            if ((F.isEmpty(modifiedPartsCounter) && F.isEmpty(historyPointerCandidate)) || ptr.compareTo(latestReservedPointer) == 0)
+                break;
         }
 
         if (!F.isEmpty(modifiedPartsCounter)) {
@@ -496,9 +513,103 @@ private IgniteBiTuple<Long, Long> calculateWalSegmentsCovered() {
                 + entry.getKey() + ", partCntrSince=" + entry.getValue() + "]");
         }
 
+        minPtr = getMinimalPointer(partsCounter, margin, minPtr, historyPointerCandidate, null);
+
         return minPtr;
     }
 
+    /**
+     * Finds a minimal WAL pointer.
+     *
+     * @param partsCounter Partition mapped to update counter.
+     * @param margin Margin pointer.
+     * @param minPtr Minimal WAL pointer which was determined before.
+     * @param historyPointerCandidate Collection of candidates for a historical WAL pointer.
+     * @param cpEntry Checkpoint entry.
+     * @return Minimal WAL pointer.
+     */
+    private FileWALPointer getMinimalPointer(
+        Map<Integer, Long> partsCounter,
+        long margin,
+        FileWALPointer minPtr,
+        LinkedList<WalPointerCandidate> historyPointerCandidate,
+        CheckpointEntry cpEntry
+    ) {
+        while (!F.isEmpty(historyPointerCandidate)) {
+            FileWALPointer ptr = historyPointerCandidate.poll()
+                .choose(cpEntry, margin, partsCounter);
+
+            if (minPtr == null || ptr.compareTo(minPtr) < 0)
+                minPtr = ptr;
+        }
+
+        return minPtr;
+    }
+
+    /**
+     * The class is used for get a pointer with a specific margin.
+     * This stores the nearest pointer which covering a partition counter.
+     * It is able to choose between other pointer and this.
+     */
+    private class WalPointerCandidate {
+        /** Group id. */
+        private final int grpId;
+
+        /** Partition id. */
+        private final int part;
+
+        /** Partition counter. */
+        private final long partContr;
+
+        /** WAL pointer. */
+        private final FileWALPointer walPntr;
+
+        /** Partition counter at the moment of WAL pointer. */
+        private final long walPntrCntr;
+
+        /**
+         * @param grpId Group id.
+         * @param part Partition id.
+         * @param partContr Partition counter.
+         * @param walPntr WAL pointer.
+         * @param walPntrCntr Counter of WAL pointer.
+         */
+        public WalPointerCandidate(int grpId, int part, long partContr, FileWALPointer walPntr, long walPntrCntr) {
+            this.grpId = grpId;
+            this.part = part;
+            this.partContr = partContr;
+            this.walPntr = walPntr;
+            this.walPntrCntr = walPntrCntr;
+        }
+
+        /**
+         * Make a choice between stored WAL pointer and other, getting from checkpoint, with a specific margin.
+         * Updates counter in collection from parameters.
+         *
+         * @param cpEntry Checkpoint entry.
+         * @param margin Margin.
+         * @param partCntsForUpdate Collection of partition id by counter.
+         * @return Chosen WAL pointer.
+         */
+        public FileWALPointer choose(
+            CheckpointEntry cpEntry,
+            long margin,
+            Map<Integer, Long> partCntsForUpdate
+        ) {
+            Long foundCntr = cpEntry == null ? null : cpEntry.partitionCounter(cctx, grpId, part);
+
+            if (foundCntr == null || foundCntr == walPntrCntr) {
+                partCntsForUpdate.put(part, walPntrCntr);
+
+                return walPntr;
+            }
+
+            partCntsForUpdate.put(part, Math.max(foundCntr, partContr - margin));
+
+            return (FileWALPointer)cpEntry.checkpointMark();
+        }
+    }
+
     /**
      * Tries to search for a WAL pointer for the given partition counter start.
      *
diff --git a/modules/core/src/test/java/org/apache/ignite/cache/ResetLostPartitionTest.java b/modules/core/src/test/java/org/apache/ignite/cache/ResetLostPartitionTest.java
index bfab17ce3fdd..3b972ef80afe 100644
--- a/modules/core/src/test/java/org/apache/ignite/cache/ResetLostPartitionTest.java
+++ b/modules/core/src/test/java/org/apache/ignite/cache/ResetLostPartitionTest.java
@@ -77,9 +77,8 @@ public class ResetLostPartitionTest extends GridCommonAbstractTest {
 
     /** {@inheritDoc} */
     @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
-        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName);
-
-        cfg.setCommunicationSpi(new TestRecordingCommunicationSpi());
+        IgniteConfiguration cfg = super.getConfiguration(igniteInstanceName)
+            .setCommunicationSpi(new TestRecordingCommunicationSpi());
 
         cfg.setConsistentId(igniteInstanceName);
 
@@ -87,7 +86,8 @@ public class ResetLostPartitionTest extends GridCommonAbstractTest {
 
         storageCfg.setPageSize(1024).setWalMode(LOG_ONLY).setWalSegmentSize(4 * 1024 * 1024);
 
-        storageCfg.setDefaultDataRegionConfiguration(new DataRegionConfiguration().setPersistenceEnabled(true)
+        storageCfg.setDefaultDataRegionConfiguration(new DataRegionConfiguration()
+            .setPersistenceEnabled(true)
             .setMaxSize(100L * 1024 * 1024));
 
         cfg.setDataStorageConfiguration(storageCfg);
diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/CachePartitionLostAfterSupplierHasLeftTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/CachePartitionLostAfterSupplierHasLeftTest.java
index 096e5a8fe3a2..cae4974f6de7 100644
--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/CachePartitionLostAfterSupplierHasLeftTest.java
+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/CachePartitionLostAfterSupplierHasLeftTest.java
@@ -348,10 +348,24 @@ private void doTestPartitionLostWhileClearing(int cnt, int mode) throws Exceptio
             }
         });
 
-        IgniteEx g1 = startGrid(idx1);
+        IgniteConfiguration cfg = getConfiguration(getTestIgniteInstanceName(idx1));
+
+        ((TestRecordingCommunicationSpi)cfg.getCommunicationSpi()).blockMessages((node, msg) -> {
+            if (msg instanceof GridDhtPartitionDemandMessage) {
+                GridDhtPartitionDemandMessage demandMsg = (GridDhtPartitionDemandMessage)msg;
+
+                return CU.cacheId(DEFAULT_CACHE_NAME) == demandMsg.groupId();
+            }
+
+            return false;
+        });
+
+        IgniteEx g1 = startGrid(optimize(cfg));
 
         stopGrid(idx0); // Stop supplier in the middle of rebalancing.
 
+        TestRecordingCommunicationSpi.spi(g1).stopBlock();
+
         final GridDhtLocalPartition part = g1.cachex(DEFAULT_CACHE_NAME).context().topology().localPartition(partId);
 
         assertTrue("Unexpected partition state [p=" + partId +
diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/rebalancing/SupplyPartitionHistoricallyWithReorderedUpdates.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/rebalancing/SupplyPartitionHistoricallyWithReorderedUpdates.java
new file mode 100644
index 000000000000..9beb9f9489ec
--- /dev/null
+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/distributed/rebalancing/SupplyPartitionHistoricallyWithReorderedUpdates.java
@@ -0,0 +1,223 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.ignite.internal.processors.cache.distributed.rebalancing;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import org.apache.ignite.IgniteCache;
+import org.apache.ignite.IgniteSystemProperties;
+import org.apache.ignite.cache.CacheAtomicityMode;
+import org.apache.ignite.cache.affinity.AffinityFunctionContext;
+import org.apache.ignite.cache.affinity.rendezvous.RendezvousAffinityFunction;
+import org.apache.ignite.cluster.ClusterNode;
+import org.apache.ignite.cluster.ClusterState;
+import org.apache.ignite.configuration.CacheConfiguration;
+import org.apache.ignite.configuration.DataRegionConfiguration;
+import org.apache.ignite.configuration.DataStorageConfiguration;
+import org.apache.ignite.configuration.IgniteConfiguration;
+import org.apache.ignite.internal.IgniteEx;
+import org.apache.ignite.internal.TestRecordingCommunicationSpi;
+import org.apache.ignite.internal.processors.cache.distributed.dht.atomic.GridDhtAtomicSingleUpdateRequest;
+import org.apache.ignite.testframework.ListeningTestLogger;
+import org.apache.ignite.testframework.LogListener;
+import org.apache.ignite.testframework.junits.WithSystemProperty;
+import org.apache.ignite.testframework.junits.common.GridCommonAbstractTest;
+import org.junit.Test;
+
+/**
+ * Checks a historical rebalance on atomic cache, when demand node has re-ordered updates.
+ */
+@WithSystemProperty(key = IgniteSystemProperties.IGNITE_PDS_WAL_REBALANCE_THRESHOLD, value = "0")
+public class SupplyPartitionHistoricallyWithReorderedUpdates extends GridCommonAbstractTest {
+    /** Historical iterator problem. */
+    private static String HISTORICAL_ITERATOR_PROBLEM = "Historical iterator tries to iterate WAL out of reservation";
+
+    /** Listening logger. */
+    private ListeningTestLogger listeningLog;
+
+    /** {@inheritDoc} */
+    @Override protected IgniteConfiguration getConfiguration(String igniteInstanceName) throws Exception {
+        return super.getConfiguration(igniteInstanceName)
+            .setGridLogger(listeningLog)
+            .setCommunicationSpi(new TestRecordingCommunicationSpi())
+            .setDataStorageConfiguration(new DataStorageConfiguration()
+                .setCheckpointFrequency(600_000)
+                .setDefaultDataRegionConfiguration(new DataRegionConfiguration()
+                    .setMaxSize(200L * 1024 * 1024)
+                    .setPersistenceEnabled(true)))
+            .setConsistentId(igniteInstanceName)
+            .setCacheConfiguration(new CacheConfiguration(DEFAULT_CACHE_NAME)
+                .setAtomicityMode(CacheAtomicityMode.ATOMIC)
+                .setAffinity(new TestAffinity(getTestIgniteInstanceName(0), getTestIgniteInstanceName(1))));
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void afterTest() throws Exception {
+        stopAllGrids();
+
+        cleanPersistenceDir();
+
+        super.afterTest();
+    }
+
+    /** {@inheritDoc} */
+    @Override protected void beforeTest() throws Exception {
+        super.beforeTest();
+
+        stopAllGrids();
+
+        cleanPersistenceDir();
+
+        listeningLog = new ListeningTestLogger(log);
+    }
+
+    /**
+     * Backup node loses one entry, after this it will restore state through historical rebalance.
+     *
+     * @throws Exception If failed.
+     */
+    @Test
+    public void testLoosingCreateSupplyLatestUpdates() throws Exception {
+        restartsBackupWithReorderedUpdate(false, false);
+    }
+
+    /**
+     * Backup node loses one update entry, after this it will restore state through historical rebalance.
+     *
+     * @throws Exception If failed.
+     */
+    @Test
+    public void testLoosingUpdateSupplyLatestUpdates() throws Exception {
+        restartsBackupWithReorderedUpdate(true, false);
+    }
+
+    /**
+     * Checks scenario, where a WAL pointer with an additional margin goes out of the bound of a preloading reservation.
+     *
+     * @throws Exception If failed.
+     */
+    @Test
+    public void testMarginGoesOutOfReservation() throws Exception {
+        restartsBackupWithReorderedUpdate(true, true);
+    }
+
+    /**
+     * Starts two nodes (first primary, second backup), reorders update on a backup and after restarts the backup node.
+     *
+     * @param updateExistedKys True for reordered update existing key, false reordered creating new entries.
+     * @param isCpRequiredBeforeStopNode If the parameter is true then checkpoint required, otherwise not.
+     * @throws Exception If failed.
+     */
+    private void restartsBackupWithReorderedUpdate(boolean updateExistedKys, boolean isCpRequiredBeforeStopNode) throws Exception {
+        IgniteEx ignite0 = startGrids(2);
+
+        ignite0.cluster().state(ClusterState.ACTIVE);
+
+        IgniteCache cache = ignite0.cache(DEFAULT_CACHE_NAME);
+
+        for (int i = 0; i < 10; i++)
+            cache.put(i, i);
+
+        AtomicBoolean blocked = new AtomicBoolean();
+
+        TestRecordingCommunicationSpi.spi(ignite0).blockMessages((node, msg) ->
+            msg instanceof GridDhtAtomicSingleUpdateRequest &&
+                getTestIgniteInstanceName(1).equals(node.consistentId()) &&
+                blocked.compareAndSet(false, true));
+
+        if (updateExistedKys) {
+            for (int i = 5; i < 10; i++)
+                cache.put(i, i + 1);
+        }
+        else {
+            for (int i = 15; i < 20; i++)
+                cache.put(i, i);
+        }
+
+        TestRecordingCommunicationSpi.spi(ignite0).waitForBlocked();
+
+        if (isCpRequiredBeforeStopNode)
+            forceCheckpoint();
+
+        stopGrid(1);
+
+        TestRecordingCommunicationSpi.spi(ignite0).stopBlock();
+
+        for (int i = 20; i < 30; i++)
+            cache.put(i, i);
+
+        forceCheckpoint(ignite0);
+
+        LogListener lsnr = LogListener.matches(HISTORICAL_ITERATOR_PROBLEM).build();
+
+        listeningLog.registerListener(lsnr);
+
+        startGrid(1);
+
+        awaitPartitionMapExchange();
+
+        assertFalse(lsnr.check());
+
+        if (!isCpRequiredBeforeStopNode)
+            assertPartitionsSame(idleVerify(ignite0, DEFAULT_CACHE_NAME));
+    }
+
+    /**
+     * Tets affinity function with one partition. This implementation maps primary partition to first node and backup
+     * partition to second.
+     */
+    public static class TestAffinity extends RendezvousAffinityFunction {
+        /** Nodes consistence ids. */
+        String[] nodeConsistentIds;
+
+        /**
+         * @param nodes Nodes consistence ids.
+         */
+        public TestAffinity(String... nodes) {
+            super(false, 1);
+
+            this.nodeConsistentIds = nodes;
+        }
+
+        /** {@inheritDoc} */
+        @Override public List<List<ClusterNode>> assignPartitions(AffinityFunctionContext affCtx) {
+            int nodes = affCtx.currentTopologySnapshot().size();
+
+            if (nodes != 2)
+                return super.assignPartitions(affCtx);
+
+            List<List<ClusterNode>> assignment = new ArrayList<>();
+
+            assignment.add(new ArrayList<>(2));
+
+            assignment.get(0).add(null);
+            assignment.get(0).add(null);
+
+            for (ClusterNode node : affCtx.currentTopologySnapshot())
+                if (nodeConsistentIds[0].equals(node.consistentId()))
+                    assignment.get(0).set(0, node);
+                else if (nodeConsistentIds[1].equals(node.consistentId()))
+                    assignment.get(0).set(1, node);
+                else
+                    throw new AssertionError("Unexpected node consistent id is " + node.consistentId());
+
+            return assignment;
+        }
+    }
+}
diff --git a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/wal/WalRecoveryTxLogicalRecordsTest.java b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/wal/WalRecoveryTxLogicalRecordsTest.java
index d8a6604ad3fa..7f3847485683 100644
--- a/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/wal/WalRecoveryTxLogicalRecordsTest.java
+++ b/modules/core/src/test/java/org/apache/ignite/internal/processors/cache/persistence/db/wal/WalRecoveryTxLogicalRecordsTest.java
@@ -63,6 +63,7 @@
 import org.apache.ignite.internal.processors.cache.persistence.freelist.AbstractFreeList;
 import org.apache.ignite.internal.processors.cache.persistence.freelist.PagesList;
 import org.apache.ignite.internal.processors.cache.persistence.tree.reuse.ReuseListImpl;
+import org.apache.ignite.internal.processors.cache.persistence.wal.FileWALPointer;
 import org.apache.ignite.internal.processors.cache.transactions.TransactionProxyImpl;
 import org.apache.ignite.internal.util.typedef.F;
 import org.apache.ignite.internal.util.typedef.T2;
@@ -370,6 +371,9 @@ public void testHistoricalRebalanceIterator() throws Exception {
                 map = new IgniteDhtDemandedPartitionsMap();
                 map.addHistorical(0, i, entries, PARTS);
 
+                GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading",
+                    new FileWALPointer(0, 0, 0));
+
                 try (IgniteRebalanceIterator it = offh.rebalanceIterator(map, topVer)) {
                     assertNotNull(it);
 
@@ -386,10 +390,16 @@ public void testHistoricalRebalanceIterator() throws Exception {
 
                     assertFalse(it.hasNext());
                 }
+                finally {
+                    GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading", null);
+                }
 
                 map = new IgniteDhtDemandedPartitionsMap();
                 map.addHistorical(1, i, entries, PARTS);
 
+                GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading",
+                    new FileWALPointer(0, 0, 0));
+
                 try (IgniteRebalanceIterator it = offh.rebalanceIterator(map, topVer)) {
                     assertNotNull(it);
 
@@ -406,6 +416,9 @@ public void testHistoricalRebalanceIterator() throws Exception {
 
                     assertFalse(it.hasNext());
                 }
+                finally {
+                    GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading", null);
+                }
             }
 
             stopAllGrids();
@@ -425,6 +438,9 @@ public void testHistoricalRebalanceIterator() throws Exception {
                 map = new IgniteDhtDemandedPartitionsMap();
                 map.addHistorical(0, i, entries, PARTS);
 
+                GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading",
+                    new FileWALPointer(0, 0, 0));
+
                 try (IgniteRebalanceIterator it = offh.rebalanceIterator(map, topVer)) {
                     long end = System.currentTimeMillis();
 
@@ -451,10 +467,16 @@ public void testHistoricalRebalanceIterator() throws Exception {
 
                     assertFalse(it.hasNext());
                 }
+                finally {
+                    GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading", null);
+                }
 
                 map = new IgniteDhtDemandedPartitionsMap();
                 map.addHistorical(1, i, entries, PARTS);
 
+                GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading",
+                    new FileWALPointer(0, 0, 0));
+
                 try (IgniteRebalanceIterator it = offh.rebalanceIterator(map, topVer)) {
                     assertNotNull(it);
 
@@ -471,6 +493,9 @@ public void testHistoricalRebalanceIterator() throws Exception {
 
                     assertFalse(it.hasNext());
                 }
+                finally {
+                    GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading", null);
+                }
             }
         }
         finally {
@@ -961,12 +986,18 @@ private List<CacheDataRow> rows(Ignite ignite, int part, long from, long to) thr
 
         List<CacheDataRow> rows = new ArrayList<>();
 
+        GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading",
+            new FileWALPointer(0, 0, 0));
+
         try (IgniteRebalanceIterator it = offh.rebalanceIterator(map, topVer)) {
             assertNotNull(it);
 
             while (it.hasNextX())
                 rows.add(it.next());
         }
+        finally {
+            GridTestUtils.setFieldValue(grp.shared().database(), "reservedForPreloading", null);
+        }
 
         return rows;
     }
diff --git a/modules/core/src/test/java/org/apache/ignite/testsuites/IgnitePdsTestSuite4.java b/modules/core/src/test/java/org/apache/ignite/testsuites/IgnitePdsTestSuite4.java
index ee76c08bb84c..dfca7461eabd 100644
--- a/modules/core/src/test/java/org/apache/ignite/testsuites/IgnitePdsTestSuite4.java
+++ b/modules/core/src/test/java/org/apache/ignite/testsuites/IgnitePdsTestSuite4.java
@@ -30,6 +30,7 @@
 import org.apache.ignite.internal.processors.cache.IgniteClusterActivateDeactivateTestWithPersistenceAndMemoryReuse;
 import org.apache.ignite.internal.processors.cache.distributed.CachePageWriteLockUnlockTest;
 import org.apache.ignite.internal.processors.cache.distributed.rebalancing.IgniteRebalanceOnCachesStoppingOrDestroyingTest;
+import org.apache.ignite.internal.processors.cache.distributed.rebalancing.SupplyPartitionHistoricallyWithReorderedUpdates;
 import org.apache.ignite.internal.processors.cache.persistence.CorruptedTreeFailureHandlingTest;
 import org.apache.ignite.internal.processors.cache.persistence.IgnitePdsCacheEntriesExpirationTest;
 import org.apache.ignite.internal.processors.cache.persistence.IgnitePdsConsistencyOnDelayedPartitionOwning;
@@ -114,6 +115,7 @@ public static List<Class<?>> suite(Collection<Class> ignoredTests) {
         GridTestUtils.addTestIfNeeded(suite, IgnitePdsCacheEntriesExpirationTest.class, ignoredTests);
 
         GridTestUtils.addTestIfNeeded(suite, IgnitePdsConsistencyOnDelayedPartitionOwning.class, ignoredTests);
+        GridTestUtils.addTestIfNeeded(suite, SupplyPartitionHistoricallyWithReorderedUpdates.class, ignoredTests);
 
         // Warm-up tests.
         GridTestUtils.addTestIfNeeded(suite, WarmUpSelfTest.class, ignoredTests);
