diff --git a/.gitignore b/.gitignore
index 286d7394f95..9a0e2751349 100644
--- a/.gitignore
+++ b/.gitignore
@@ -47,20 +47,29 @@ erl_crash.dump
 /aclocal/lt*.m4
 /autoscan.log
 /autoscan-*.log
+/compiler/cpp/test/plugin/t_cpp_generator.cc
+/compiler/cpp/src/thrift/plugin/plugin_constants.cpp
+/compiler/cpp/src/thrift/plugin/plugin_constants.h
+/compiler/cpp/src/thrift/plugin/plugin_types.cpp
+/compiler/cpp/src/thrift/plugin/plugin_types.h
+/compiler/cpp/test/*test
+/compiler/cpp/test/thrift-gen-*
+/compiler/cpp/src/thrift/thrift-bootstrap
+/compiler/cpp/src/thrift/plugin/gen.stamp
 /compiler/cpp/Debug
 /compiler/cpp/Release
-/compiler/cpp/libparse.a
-/compiler/cpp/src/thriftl.cc
-/compiler/cpp/src/thrifty.cc
-/compiler/cpp/src/thrifty.hh
-/compiler/cpp/src/windows/version.h
+/compiler/cpp/src/thrift/libparse.a
+/compiler/cpp/src/thrift/thriftl.cc
+/compiler/cpp/src/thrift/thrifty.cc
+/compiler/cpp/src/thrift/thrifty.hh
+/compiler/cpp/src/thrift/windows/version.h
 /compiler/cpp/thrift
 /compiler/cpp/thriftl.cc
 /compiler/cpp/thrifty.cc
 /compiler/cpp/lex.yythriftl.cc
 /compiler/cpp/thrifty.h
 /compiler/cpp/thrifty.hh
-/compiler/cpp/version.h
+/compiler/cpp/src/thrift/version.h
 /config.*
 /configure
 /configure.lineno
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 37e89766fd5..93ed8d2ac58 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -73,6 +73,9 @@ if(BUILD_COMPILER)
         set(THRIFT_COMPILER $<TARGET_FILE:thrift-compiler>)
     endif()
     add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/compiler/cpp)
+elseif(EXISTS ${THRIFT_COMPILER})
+    add_executable(thrift-compiler IMPORTED)
+    set_property(TARGET thrift-compiler PROPERTY IMPORTED_LOCATION ${THRIFT_COMPILER})
 endif()
 
 if(BUILD_CPP)
diff --git a/Makefile.am b/Makefile.am
index 10fe49a6c3f..48adb37ca1b 100755
--- a/Makefile.am
+++ b/Makefile.am
@@ -19,7 +19,15 @@
 
 ACLOCAL_AMFLAGS = -I ./aclocal
 
+if WITH_PLUGIN
+# To enable bootstrap, build order is lib/cpp -> compiler -> others
+SUBDIRS = lib/cpp compiler/cpp lib
+if WITH_TESTS
+SUBDIRS += lib/cpp/test
+endif
+else
 SUBDIRS = compiler/cpp lib
+endif
 
 if WITH_TESTS
 SUBDIRS += test
diff --git a/build/cmake/DefineOptions.cmake b/build/cmake/DefineOptions.cmake
index 01dae35df4a..12c3ab060c7 100644
--- a/build/cmake/DefineOptions.cmake
+++ b/build/cmake/DefineOptions.cmake
@@ -40,6 +40,13 @@ option(BUILD_LIBRARIES "Build Thrift libraries" ON)
 # and enables the library if all are found. This means the default is to build as
 # much as possible but leaving out libraries if their dependencies are not met.
 
+CMAKE_DEPENDENT_OPTION(WITH_BOOST_STATIC "Build with Boost static link library" OFF "NOT MSVC" ON)
+set(Boost_USE_STATIC_LIBS ${WITH_BOOST_STATIC})
+if (NOT WITH_BOOST_STATIC)
+    add_definitions(-DBOOST_ALL_DYN_LINK)
+    add_definitions(-DBOOST_TEST_DYN_LINK)
+endif()
+
 # C++
 option(WITH_CPP "Build C++ Thrift library" ON)
 if(WITH_CPP)
@@ -77,6 +84,8 @@ if(WITH_CPP)
 endif()
 CMAKE_DEPENDENT_OPTION(BUILD_CPP "Build C++ library" ON
                        "BUILD_LIBRARIES;WITH_CPP;Boost_FOUND" OFF)
+CMAKE_DEPENDENT_OPTION(WITH_PLUGIN "Build compiler plugin support" ON
+                       "BUILD_COMPILER;BUILD_CPP" OFF)
 
 # C GLib
 option(WITH_C_GLIB "Build C (GLib) Thrift library" ON)
@@ -86,6 +95,21 @@ endif()
 CMAKE_DEPENDENT_OPTION(BUILD_C_GLIB "Build C (GLib) library" ON
                        "BUILD_LIBRARIES;WITH_C_GLIB;GLIB_FOUND" OFF)
 
+if(BUILD_CPP)
+    set(boost_components)
+    if(WITH_BOOSTTHREADS OR BUILD_TESTING)
+        list(APPEND boost_components system thread)
+    endif()
+    if(BUILD_TESTING)
+        list(APPEND boost_components unit_test_framework filesystem chrono program_options)
+    endif()
+    if(boost_components)
+        find_package(Boost 1.53 REQUIRED COMPONENTS ${boost_components})
+    endif()
+elseif(BUILD_C_GLIB AND BUILD_TESTING)
+    find_package(Boost 1.53 REQUIRED)
+endif()
+
 # Java
 option(WITH_JAVA "Build Java Thrift library" ON)
 if(ANDROID)
@@ -121,8 +145,6 @@ if (NOT WITH_SHARED_LIB AND NOT WITH_STATIC_LIB)
     message(FATAL_ERROR "Cannot build with both shared and static outputs disabled!")
 endif()
 
-option(WITH_DYN_LINK_TEST "Build with Boost dynamic link test library" OFF)
-
 #NOTE: C++ compiler options are defined in the lib/cpp/CMakeLists.txt
 
 # Visual Studio only options
@@ -142,6 +164,7 @@ message(STATUS "Thrift version:                               ${thrift_VERSION}
 message(STATUS "Thrift package version:                       ${PACKAGE_VERSION}")
 message(STATUS "Build configuration Summary")
 message(STATUS "  Build Thrift compiler:                      ${BUILD_COMPILER}")
+message(STATUS "  Build compiler plugin support:              ${WITH_PLUGIN}")
 message(STATUS "  Build with unit tests:                      ${BUILD_TESTING}")
 MESSAGE_DEP(HAVE_COMPILER "Disabled because BUILD_THRIFT=OFF and no valid THRIFT_COMPILER is given")
 message(STATUS "  Build examples:                             ${BUILD_EXAMPLES}")
@@ -179,6 +202,9 @@ message(STATUS "  Build with Qt5 support:                     ${WITH_QT5}")
 message(STATUS "  Build with OpenSSL support:                 ${WITH_OPENSSL}")
 message(STATUS "  Build with Boost thread support:            ${WITH_BOOSTTHREADS}")
 message(STATUS "  Build with C++ std::thread support:         ${WITH_STDTHREADS}")
-message(STATUS "  Build with Boost dynamic link test library: ${WITH_DYN_LINK_TEST}")
+message(STATUS "  Build with Boost static link library:       ${WITH_BOOST_STATIC}")
+if(MSVC)
+    message(STATUS "    - Enabled for Visual C++")
+endif()
 message(STATUS "----------------------------------------------------------")
 endmacro(PRINT_CONFIG_SUMMARY)
diff --git a/build/cmake/ThriftMacros.cmake b/build/cmake/ThriftMacros.cmake
index 265659814fe..2797ef676b6 100644
--- a/build/cmake/ThriftMacros.cmake
+++ b/build/cmake/ThriftMacros.cmake
@@ -36,6 +36,7 @@ if(WITH_SHARED_LIB)
         LIBRARY DESTINATION "${LIB_INSTALL_DIR}"
         ARCHIVE DESTINATION "${LIB_INSTALL_DIR}"
         PUBLIC_HEADER DESTINATION "${INCLUDE_INSTALL_DIR}")
+    target_include_directories(${name} PUBLIC ${Boost_INCLUDE_DIRS})
 endif()
 
 if(WITH_STATIC_LIB)
@@ -50,6 +51,7 @@ if(WITH_STATIC_LIB)
         LIBRARY DESTINATION "${LIB_INSTALL_DIR}"
         ARCHIVE DESTINATION "${LIB_INSTALL_DIR}"
         PUBLIC_HEADER DESTINATION "${INCLUDE_INSTALL_DIR}")
+    target_include_directories(${name}_static PUBLIC ${Boost_INCLUDE_DIRS})
 endif()
 
 endmacro(ADD_LIBRARY_THRIFT)
diff --git a/compiler/cpp/CMakeLists.txt b/compiler/cpp/CMakeLists.txt
index b7ed6ea084f..6bf744c4bff 100644
--- a/compiler/cpp/CMakeLists.txt
+++ b/compiler/cpp/CMakeLists.txt
@@ -19,77 +19,55 @@
 
 # Windows has a different header
 if(MSVC)
-    configure_file(${CMAKE_CURRENT_SOURCE_DIR}/src/windows/version.h.in ${CMAKE_CURRENT_BINARY_DIR}/version.h)
+    configure_file(${CMAKE_CURRENT_SOURCE_DIR}/src/thrift/windows/version.h.in ${CMAKE_CURRENT_BINARY_DIR}/thrift/version.h)
 else()
-    configure_file(${CMAKE_CURRENT_SOURCE_DIR}/version.h.in ${CMAKE_CURRENT_BINARY_DIR}/version.h)
+    configure_file(${CMAKE_CURRENT_SOURCE_DIR}/src/thrift/version.h.in ${CMAKE_CURRENT_BINARY_DIR}/thrift/version.h)
 endif()
 
 find_package(FLEX REQUIRED)
 find_package(BISON REQUIRED)
 
 # Create flex and bison files and build the lib parse static library
-BISON_TARGET(thrifty ${CMAKE_CURRENT_SOURCE_DIR}/src/thrifty.yy ${CMAKE_CURRENT_BINARY_DIR}/thrifty.cc)
-FLEX_TARGET(thriftl ${CMAKE_CURRENT_SOURCE_DIR}/src/thriftl.ll ${CMAKE_CURRENT_BINARY_DIR}/thriftl.cc)
+BISON_TARGET(thrifty ${CMAKE_CURRENT_SOURCE_DIR}/src/thrift/thrifty.yy ${CMAKE_CURRENT_BINARY_DIR}/thrift/thrifty.cc)
+FLEX_TARGET(thriftl ${CMAKE_CURRENT_SOURCE_DIR}/src/thrift/thriftl.ll ${CMAKE_CURRENT_BINARY_DIR}/thrift/thriftl.cc)
 ADD_FLEX_BISON_DEPENDENCY(thriftl thrifty)
 
 # HACK: Work around the fact that bison crates a .hh file but we need a .h file
-add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/thrifty.h
-                   COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_BINARY_DIR}/thrifty.hh ${CMAKE_CURRENT_BINARY_DIR}/thrifty.h
-                   DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/thrifty.hh
+add_custom_command(OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/thrift/thrifty.h
+                   COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_BINARY_DIR}/thrift/thrifty.hh ${CMAKE_CURRENT_BINARY_DIR}/thrift/thrifty.h
+                   DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/thrift/thrifty.hh
                    )
 
 set(libparse_SOURCES
-    ${CMAKE_CURRENT_BINARY_DIR}/thrifty.cc
-    ${CMAKE_CURRENT_BINARY_DIR}/thriftl.cc
-    ${CMAKE_CURRENT_BINARY_DIR}/thrifty.h
+    ${CMAKE_CURRENT_BINARY_DIR}/thrift/thrifty.cc
+    ${CMAKE_CURRENT_BINARY_DIR}/thrift/thriftl.cc
+    ${CMAKE_CURRENT_BINARY_DIR}/thrift/thrifty.h
 )
 
 add_library(libparse STATIC ${libparse_SOURCES})
 
 # Create the thrift compiler
-set( thrift_SOURCES
-    src/main.cc
-    src/generate/t_generator.cc
-    src/generate/t_generator_registry.h
-    src/globals.h
-    src/main.h
-    src/platform.h
-    src/audit/t_audit.cpp
-    src/parse/t_doc.h
-    src/parse/t_type.h
-    src/parse/t_base_type.h
-    src/parse/t_enum.h
-    src/parse/t_enum_value.h
-    src/parse/t_typedef.h
-    src/parse/t_typedef.cc
-    src/parse/t_container.h
-    src/parse/t_list.h
-    src/parse/t_set.h
-    src/parse/t_map.h
-    src/parse/t_struct.h
-    src/parse/t_field.h
-    src/parse/t_service.h
-    src/parse/t_function.h
-    src/parse/t_program.h
-    src/parse/t_scope.h
-    src/parse/t_const.h
-    src/parse/t_const_value.h
-    src/parse/parse.cc
-    src/generate/t_generator.h
-    src/generate/t_oop_generator.h
-    src/generate/t_html_generator.h
-    src/windows/config.h
-    version.h
+set(compiler_core
+    src/thrift/common.cc
+    src/thrift/generate/t_generator.cc
+    src/thrift/parse/t_typedef.cc
+    src/thrift/parse/parse.cc
+    ${CMAKE_CURRENT_BINARY_DIR}/thrift/version.h
+)
+
+set(thrift-compiler_SOURCES
+    src/thrift/main.cc
+    src/thrift/audit/t_audit.cpp
 )
 
 # This macro adds an option THRIFT_COMPILER_${NAME}
 # that allows enabling or disabling certain languages
 macro(THRIFT_ADD_COMPILER name description initial)
     string(TOUPPER "THRIFT_COMPILER_${name}" enabler)
-    set(src "src/generate/t_${name}_generator.cc")
+    set(src "src/thrift/generate/t_${name}_generator.cc")
     option(${enabler} ${description} ${initial})
     if(${enabler})
-        list(APPEND thrift_SOURCES ${src})
+        list(APPEND thrift-compiler_SOURCES ${src})
     endif()
 endmacro()
 
@@ -127,9 +105,117 @@ THRIFT_ADD_COMPILER(xml     "Enable compiler for XML" ON)
 # we also add the current binary directory for generated files
 include_directories(${CMAKE_CURRENT_BINARY_DIR} src)
 
-add_executable(thrift-compiler ${thrift_SOURCES})
+if(NOT ${WITH_PLUGIN})
+    list(APPEND thrift-compiler_SOURCES ${compiler_core})
+endif()
+add_executable(thrift-compiler ${thrift-compiler_SOURCES})
+
+if(${WITH_PLUGIN})
+    add_executable(thrift-bootstrap ${compiler_core}
+        src/thrift/main.cc
+        src/thrift/audit/t_audit.cpp
+        src/thrift/generate/t_cpp_generator.cc
+    )
+    target_link_libraries(thrift-bootstrap libparse)
+
+    set(PLUGIN_GEN_SOURCES
+        ${CMAKE_CURRENT_BINARY_DIR}/thrift/plugin/plugin_types.h
+        ${CMAKE_CURRENT_BINARY_DIR}/thrift/plugin/plugin_types.cpp
+        ${CMAKE_CURRENT_BINARY_DIR}/thrift/plugin/plugin_constants.h
+        ${CMAKE_CURRENT_BINARY_DIR}/thrift/plugin/plugin_constants.cpp
+    )
+
+    file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/thrift/plugin)
+    add_custom_command(OUTPUT ${PLUGIN_GEN_SOURCES}
+        DEPENDS thrift-bootstrap src/thrift/plugin/plugin.thrift
+        COMMAND thrift-bootstrap -gen cpp
+        -out ${CMAKE_CURRENT_BINARY_DIR}/thrift/plugin
+        ${CMAKE_CURRENT_SOURCE_DIR}/src/thrift/plugin/plugin.thrift
+    )
+
+    include_directories(../../lib/cpp/src)
+
+    include(ThriftMacros)
+    ADD_LIBRARY_THRIFT(thriftc
+        ${compiler_core}
+        ${PLUGIN_GEN_SOURCES}
+        src/thrift/logging.cc
+        src/thrift/plugin/plugin_output.cc
+        src/thrift/plugin/plugin.cc
+    )
+    set_property(TARGET thrift-compiler APPEND
+        PROPERTY COMPILE_DEFINITIONS THRIFT_ENABLE_PLUGIN)
+    if(WITH_SHARED_LIB AND NOT MSVC)
+      target_link_libraries(thriftc thrift)
+      target_link_libraries(thrift-compiler thriftc)
+    else()
+      target_link_libraries(thrift-compiler thriftc_static thrift_static)
+    endif()
+endif()
+
 set_target_properties(thrift-compiler PROPERTIES OUTPUT_NAME thrift)
 
 target_link_libraries(thrift-compiler libparse)
 
 install(TARGETS thrift-compiler DESTINATION "${BIN_INSTALL_DIR}")
+
+if(${WITH_PLUGIN})
+  # Install the headers
+  install(FILES
+      "src/thrift/common.h"
+      "src/thrift/globals.h"
+      "src/thrift/logging.h"
+      "src/thrift/main.h"
+      "src/thrift/platform.h"
+      DESTINATION "${INCLUDE_INSTALL_DIR}/thrift")
+  install(FILES
+      "src/thrift/audit/t_audit.h"
+      DESTINATION "${INCLUDE_INSTALL_DIR}/thrift/audit")
+  install(FILES
+      "src/thrift/generate/t_generator.h"
+      "src/thrift/generate/t_generator_registry.h"
+      "src/thrift/generate/t_html_generator.h"
+      "src/thrift/generate/t_oop_generator.h"
+      DESTINATION "${INCLUDE_INSTALL_DIR}/thrift/generate")
+  install(FILES
+      "src/thrift/parse/t_base_type.h"
+      "src/thrift/parse/t_const.h"
+      "src/thrift/parse/t_const_value.h"
+      "src/thrift/parse/t_container.h"
+      "src/thrift/parse/t_doc.h"
+      "src/thrift/parse/t_enum.h"
+      "src/thrift/parse/t_enum_value.h"
+      "src/thrift/parse/t_field.h"
+      "src/thrift/parse/t_function.h"
+      "src/thrift/parse/t_list.h"
+      "src/thrift/parse/t_map.h"
+      "src/thrift/parse/t_program.h"
+      "src/thrift/parse/t_scope.h"
+      "src/thrift/parse/t_service.h"
+      "src/thrift/parse/t_set.h"
+      "src/thrift/parse/t_struct.h"
+      "src/thrift/parse/t_typedef.h"
+      "src/thrift/parse/t_type.h"
+      DESTINATION "${INCLUDE_INSTALL_DIR}/thrift/parse")
+  install(FILES
+      "src/thrift/plugin/plugin.h"
+      "src/thrift/plugin/plugin_output.h"
+      "src/thrift/plugin/type_util.h"
+      DESTINATION "${INCLUDE_INSTALL_DIR}/thrift/plugin")
+if(MSVC)
+  install(FILES
+      "src/thrift/windows/config.h"
+      DESTINATION "${INCLUDE_INSTALL_DIR}/thrift/windows")
+  install(FILES
+      "${CMAKE_BINARY_DIR}/compiler/cpp/thrift/windows/version.h"
+      DESTINATION "${INCLUDE_INSTALL_DIR}/thrift/windows")
+else()
+  install(FILES
+      "${CMAKE_BINARY_DIR}/compiler/cpp/thrift/version.h"
+      DESTINATION "${INCLUDE_INSTALL_DIR}/thrift")
+endif()
+endif()
+
+if(BUILD_TESTING)
+    add_subdirectory(test)
+endif()
diff --git a/compiler/cpp/Makefile.am b/compiler/cpp/Makefile.am
index 49ec26e3b59..9d830d7db65 100644
--- a/compiler/cpp/Makefile.am
+++ b/compiler/cpp/Makefile.am
@@ -21,90 +21,169 @@
 # Please see doc/old-thrift-license.txt in the Thrift distribution for
 # details.
 
-AM_YFLAGS = -d
-LIBS =
-BUILT_SOURCES = src/thrifty.cc
+AUTOMAKE_OPTIONS = subdir-objects
 
-bin_PROGRAMS = thrift
+# Note on why we have src/thrift and src/thrift/plugin directories:
+# Since Automake supports only one set of BUILT_SOURCES per file and does not allow
+# SUBDIRS built before BUILT_SOURCES, we end up separate Makefile.am for each source
+# code generation, i.e. lex-yacc and Thrift, to achieve stable parallel make.
+
+SUBDIRS = src src/thrift/plugin .
+if WITH_TESTS
+SUBDIRS += test
+endif
 
-noinst_LIBRARIES = libparse.a
+bin_PROGRAMS = thrift
 
 thrift_OBJDIR = obj
 
-thrift_SOURCES = src/main.cc \
-                 src/generate/t_generator.cc \
-                 src/generate/t_generator_registry.h \
-                 src/globals.h \
-                 src/main.h \
-                 src/platform.h \
-                 src/logging.h \
-                 src/audit/t_audit.cpp \
-                 src/audit/t_audit.h \
-                 src/parse/t_doc.h \
-                 src/parse/t_type.h \
-                 src/parse/t_base_type.h \
-                 src/parse/t_enum.h \
-                 src/parse/t_enum_value.h \
-                 src/parse/t_typedef.h \
-                 src/parse/t_typedef.cc \
-                 src/parse/t_container.h \
-                 src/parse/t_list.h \
-                 src/parse/t_set.h \
-                 src/parse/t_map.h \
-                 src/parse/t_struct.h \
-                 src/parse/t_field.h \
-                 src/parse/t_service.h \
-                 src/parse/t_function.h \
-                 src/parse/t_program.h \
-                 src/parse/t_scope.h \
-                 src/parse/t_const.h \
-                 src/parse/t_const_value.h \
-                 src/parse/parse.cc \
-                 src/generate/t_generator.h \
-                 src/generate/t_oop_generator.h \
-                 src/generate/t_html_generator.h \
-                 src/windows/config.h \
-                 src/windows/version.h
+plugin_gen = src/thrift/plugin/plugin_types.h \
+             src/thrift/plugin/plugin_types.cpp \
+             src/thrift/plugin/plugin_constants.h \
+             src/thrift/plugin/plugin_constants.cpp
+
+compiler_core =  src/thrift/common.h \
+                 src/thrift/common.cc \
+                 src/thrift/generate/t_generator.cc \
+                 src/thrift/generate/t_generator_registry.h \
+                 src/thrift/globals.h \
+                 src/thrift/platform.h \
+                 src/thrift/logging.h \
+                 src/thrift/parse/t_doc.h \
+                 src/thrift/parse/t_type.h \
+                 src/thrift/parse/t_base_type.h \
+                 src/thrift/parse/t_enum.h \
+                 src/thrift/parse/t_enum_value.h \
+                 src/thrift/parse/t_typedef.h \
+                 src/thrift/parse/t_typedef.cc \
+                 src/thrift/parse/t_container.h \
+                 src/thrift/parse/t_list.h \
+                 src/thrift/parse/t_set.h \
+                 src/thrift/parse/t_map.h \
+                 src/thrift/parse/t_struct.h \
+                 src/thrift/parse/t_field.h \
+                 src/thrift/parse/t_service.h \
+                 src/thrift/parse/t_function.h \
+                 src/thrift/parse/t_program.h \
+                 src/thrift/parse/t_scope.h \
+                 src/thrift/parse/t_const.h \
+                 src/thrift/parse/t_const_value.h \
+                 src/thrift/parse/parse.cc \
+                 src/thrift/generate/t_generator.h \
+                 src/thrift/generate/t_oop_generator.h \
+                 src/thrift/generate/t_html_generator.h \
+                 src/thrift/windows/config.h \
+                 src/thrift/windows/version.h
+
+thrift_SOURCES = src/thrift/main.h \
+                 src/thrift/main.cc \
+                 src/thrift/audit/t_audit.cpp \
+                 src/thrift/audit/t_audit.h
 
 # Specific client generator source
-thrift_SOURCES += src/generate/t_c_glib_generator.cc \
-                  src/generate/t_cpp_generator.cc \
-                  src/generate/t_java_generator.cc \
-                  src/generate/t_json_generator.cc \
-                  src/generate/t_as3_generator.cc \
-                  src/generate/t_dart_generator.cc \
-                  src/generate/t_haxe_generator.cc \
-                  src/generate/t_csharp_generator.cc \
-                  src/generate/t_py_generator.cc \
-                  src/generate/t_rb_generator.cc \
-                  src/generate/t_perl_generator.cc \
-                  src/generate/t_php_generator.cc \
-                  src/generate/t_erl_generator.cc \
-                  src/generate/t_cocoa_generator.cc \
-                  src/generate/t_swift_generator.cc \
-                  src/generate/t_st_generator.cc \
-                  src/generate/t_ocaml_generator.cc \
-                  src/generate/t_hs_generator.cc \
-                  src/generate/t_xsd_generator.cc \
-                  src/generate/t_xml_generator.cc \
-                  src/generate/t_html_generator.cc \
-                  src/generate/t_js_generator.cc \
-                  src/generate/t_javame_generator.cc \
-                  src/generate/t_delphi_generator.cc \
-                  src/generate/t_go_generator.cc \
-                  src/generate/t_gv_generator.cc \
-                  src/generate/t_d_generator.cc \
-                  src/generate/t_lua_generator.cc
+thrift_SOURCES += src/thrift/generate/t_c_glib_generator.cc \
+                  src/thrift/generate/t_cpp_generator.cc \
+                  src/thrift/generate/t_java_generator.cc \
+                  src/thrift/generate/t_json_generator.cc \
+                  src/thrift/generate/t_as3_generator.cc \
+                  src/thrift/generate/t_dart_generator.cc \
+                  src/thrift/generate/t_haxe_generator.cc \
+                  src/thrift/generate/t_csharp_generator.cc \
+                  src/thrift/generate/t_py_generator.cc \
+                  src/thrift/generate/t_rb_generator.cc \
+                  src/thrift/generate/t_perl_generator.cc \
+                  src/thrift/generate/t_php_generator.cc \
+                  src/thrift/generate/t_erl_generator.cc \
+                  src/thrift/generate/t_cocoa_generator.cc \
+                  src/thrift/generate/t_swift_generator.cc \
+                  src/thrift/generate/t_st_generator.cc \
+                  src/thrift/generate/t_ocaml_generator.cc \
+                  src/thrift/generate/t_hs_generator.cc \
+                  src/thrift/generate/t_xsd_generator.cc \
+                  src/thrift/generate/t_xml_generator.cc \
+                  src/thrift/generate/t_html_generator.cc \
+                  src/thrift/generate/t_js_generator.cc \
+                  src/thrift/generate/t_javame_generator.cc \
+                  src/thrift/generate/t_delphi_generator.cc \
+                  src/thrift/generate/t_go_generator.cc \
+                  src/thrift/generate/t_gv_generator.cc \
+                  src/thrift/generate/t_d_generator.cc \
+                  src/thrift/generate/t_lua_generator.cc
 
 thrift_CPPFLAGS = -I$(srcdir)/src
 thrift_CXXFLAGS = -Wall -Wextra -pedantic
-thrift_LDADD = @LEXLIB@ libparse.a
+thrift_LDADD = @LEXLIB@ src/thrift/libparse.a
+
+if !WITH_PLUGIN
+thrift_SOURCES += $(compiler_core)
+else
+
+lib_LTLIBRARIES = libthriftc.la
+
+thrift_CPPFLAGS += -DTHRIFT_ENABLE_PLUGIN=1
+thrift_LDADD += libthriftc.la
+
+nodist_libthriftc_la_SOURCES = $(plugin_gen)
+libthriftc_la_SOURCES = $(compiler_core) \
+                        src/thrift/plugin/type_util.h \
+                        src/thrift/plugin/plugin.h \
+                        src/thrift/plugin/plugin.cc \
+                        src/thrift/plugin/plugin_output.h \
+                        src/thrift/plugin/plugin_output.cc \
+                        src/thrift/plugin/plugin.thrift \
+                        src/thrift/logging.cc
+
+
+libthriftc_la_CPPFLAGS = -I$(srcdir)/src -Isrc -I$(top_builddir)/lib/cpp/src -DTHRIFT_ENABLE_PLUGIN=1
+libthriftc_la_CXXFLAGS = -Wall -Wextra -pedantic
+libthriftc_la_LIBADD = $(top_builddir)/lib/cpp/libthrift.la
+
+include_thriftdir = $(includedir)/thrift
+include_thrift_HEADERS = src/thrift/common.h \
+                         src/thrift/globals.h \
+                         src/thrift/logging.h \
+                         src/thrift/main.h \
+                         src/thrift/platform.h \
+                         src/thrift/version.h
+
+include_auditdir = $(include_thriftdir)/windows
+include_audit_HEADERS = src/thrift/audit/t_audit.h
+
+include_generatedir = $(include_thriftdir)/generate
+include_generate_HEADERS = src/thrift/generate/t_generator.h \
+                           src/thrift/generate/t_generator_registry.h \
+                           src/thrift/generate/t_oop_generator.h \
+                           src/thrift/generate/t_html_generator.h
+
+include_parsedir = $(include_thriftdir)/parse
+include_parse_HEADERS = src/thrift/parse/t_service.h \
+                        src/thrift/parse/t_program.h \
+                        src/thrift/parse/t_field.h \
+                        src/thrift/parse/t_scope.h \
+                        src/thrift/parse/t_typedef.h \
+                        src/thrift/parse/t_set.h \
+                        src/thrift/parse/t_const_value.h \
+                        src/thrift/parse/t_enum_value.h \
+                        src/thrift/parse/t_const.h \
+                        src/thrift/parse/t_list.h \
+                        src/thrift/parse/t_map.h \
+                        src/thrift/parse/t_container.h \
+                        src/thrift/parse/t_base_type.h \
+                        src/thrift/parse/t_enum.h \
+                        src/thrift/parse/t_function.h \
+                        src/thrift/parse/t_type.h \
+                        src/thrift/parse/t_doc.h \
+                        src/thrift/parse/t_struct.h
 
-libparse_a_CPPFLAGS = -I$(srcdir)/src
-libparse_a_CXXFLAGS = -Wall -Wno-sign-compare -Wno-unused
+include_plugindir = $(include_thriftdir)/plugin
+include_plugin_HEADERS = src/thrift/plugin/plugin.h \
+                         src/thrift/plugin/type_util.h \
+                         src/thrift/plugin/plugin_output.h
 
-libparse_a_SOURCES = src/thrifty.yy \
-                     src/thriftl.ll
+include_windowsdir = $(include_thriftdir)/windows
+include_windows_HEADERS = src/thrift/windows/version.h \
+                          src/thrift/windows/config.h
+endif
 
 WINDOWS_DIST = \
              compiler.sln \
@@ -118,9 +197,9 @@ EXTRA_DIST = \
              $(WINDOWS_DIST)
 
 clean-local:
-	$(RM) thriftl.cc thrifty.cc thrifty.h thrifty.hh version.h windows/version.h
+	$(RM) version.h windows/version.h $(plugin_gen)
 
-src/main.cc: version.h
+src/thrift/main.cc: src/thrift/version.h
 
 style-local:
-	$(CPPSTYLE_CMD)
+  $(CPPSTYLE_CMD)
diff --git a/compiler/cpp/compiler.vcxproj b/compiler/cpp/compiler.vcxproj
index a2548d4ab14..3dbe42c9ba2 100644
--- a/compiler/cpp/compiler.vcxproj
+++ b/compiler/cpp/compiler.vcxproj
@@ -20,6 +20,7 @@
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="src\audit\t_audit.h" />
+    <ClInclude Include="src\common.h" />
     <ClInclude Include="src\generate\t_generator.h" />
     <ClInclude Include="src\generate\t_generator_registry.h" />
     <ClInclude Include="src\generate\t_oop_generator.h" />
@@ -50,7 +51,8 @@
     <ClInclude Include="src\windows\version.h" />
   </ItemGroup>
   <ItemGroup>
-    <ClCompile Include="src\audit\t_audit.cpp" />
+    <ClCompile Include="src\audit\t_audit.cpp"/>
+    <ClCompile Include="src\common.cc" />
     <ClCompile Include="src\generate\t_as3_generator.cc" />
     <ClCompile Include="src\generate\t_cocoa_generator.cc" />
     <ClCompile Include="src\generate\t_cpp_generator.cc" />
@@ -245,4 +247,4 @@ bison -y -o "src\thrifty.cc" --defines="src/thrifty.hh" src/thrifty.yy</Command>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/compiler/cpp/src/Makefile.am b/compiler/cpp/src/Makefile.am
new file mode 100644
index 00000000000..f1863d5150d
--- /dev/null
+++ b/compiler/cpp/src/Makefile.am
@@ -0,0 +1,87 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements. See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership. The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License. You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied. See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+#
+# Contains some contributions under the Thrift Software License.
+# Please see doc/old-thrift-license.txt in the Thrift distribution for
+# details.
+
+AUTOMAKE_OPTIONS = subdir-objects
+
+AM_YFLAGS = -d
+
+BUILT_SOURCES = thrift/thrifty.cc
+
+noinst_LIBRARIES = thrift/libparse.a
+
+thrift_libparse_a_CPPFLAGS = -I$(srcdir)
+thrift_libparse_a_CXXFLAGS = -Wall -Wno-sign-compare -Wno-unused
+
+thrift_libparse_a_SOURCES = thrift/thrifty.yy \
+                     thrift/thriftl.ll
+
+clean-local:
+	$(RM) thrift/thriftl.cc thrift/thrifty.cc thrift/thrifty.h thrift/thrifty.hh
+
+if WITH_PLUGIN
+noinst_PROGRAMS = thrift/thrift-bootstrap
+
+thrift_thrift_bootstrap_SOURCES = \
+                 thrift/common.h \
+                 thrift/common.cc \
+                 thrift/audit/t_audit.h \
+                 thrift/audit/t_audit.cpp \
+                 thrift/generate/t_generator.cc \
+                 thrift/generate/t_generator_registry.h \
+                 thrift/globals.h \
+                 thrift/platform.h \
+                 thrift/logging.h \
+                 thrift/parse/t_doc.h \
+                 thrift/parse/t_type.h \
+                 thrift/parse/t_base_type.h \
+                 thrift/parse/t_enum.h \
+                 thrift/parse/t_enum_value.h \
+                 thrift/parse/t_typedef.h \
+                 thrift/parse/t_typedef.cc \
+                 thrift/parse/t_container.h \
+                 thrift/parse/t_list.h \
+                 thrift/parse/t_set.h \
+                 thrift/parse/t_map.h \
+                 thrift/parse/t_struct.h \
+                 thrift/parse/t_field.h \
+                 thrift/parse/t_service.h \
+                 thrift/parse/t_function.h \
+                 thrift/parse/t_program.h \
+                 thrift/parse/t_scope.h \
+                 thrift/parse/t_const.h \
+                 thrift/parse/t_const_value.h \
+                 thrift/parse/parse.cc \
+                 thrift/generate/t_generator.h \
+                 thrift/generate/t_oop_generator.h \
+                 thrift/generate/t_html_generator.h \
+                 thrift/windows/config.h \
+                 thrift/windows/version.h \
+                 thrift/generate/t_cpp_generator.cc \
+                 thrift/main.h \
+                 thrift/main.cc
+
+main.cc: version.h
+
+thrift_thrift_bootstrap_CXXFLAGS = -Wall -Wextra -pedantic
+thrift_thrift_bootstrap_LDADD = @LEXLIB@ thrift/libparse.a
+endif
diff --git a/compiler/cpp/src/audit/t_audit.cpp b/compiler/cpp/src/thrift/audit/t_audit.cpp
similarity index 97%
rename from compiler/cpp/src/audit/t_audit.cpp
rename to compiler/cpp/src/thrift/audit/t_audit.cpp
index afcbd5e1a27..1386f3bd1e6 100644
--- a/compiler/cpp/src/audit/t_audit.cpp
+++ b/compiler/cpp/src/thrift/audit/t_audit.cpp
@@ -12,16 +12,16 @@
 #include <limits.h>
 
 // Careful: must include globals first for extern definitions
-#include "globals.h"
+#include "thrift/globals.h"
 
-#include "parse/t_program.h"
-#include "parse/t_scope.h"
-#include "parse/t_const.h"
-#include "parse/t_field.h"
+#include "thrift/parse/t_program.h"
+#include "thrift/parse/t_scope.h"
+#include "thrift/parse/t_const.h"
+#include "thrift/parse/t_field.h"
 
-#include "version.h"
+#include "thrift/version.h"
 
-#include "t_audit.h"
+#include "thrift/audit/t_audit.h"
 
 extern int g_warn;
 extern std::string g_curpath;
@@ -85,7 +85,7 @@ void compare_enum_values(t_enum* newEnum,t_enum* oldEnum)
          if(enumName != newEnumValue->get_name())
          {
             thrift_audit_warning(1, "Name of the value %d changed in enum %s\n", enumValue, oldEnum->get_name().c_str());
-         }      
+         }
       }
       else
       {
@@ -125,7 +125,7 @@ void compare_enums(const std::vector<t_enum*>& newEnumList, const std::vector<t_
 bool compare_type(t_type* newType, t_type* oldType)
 {
    //Comparing names of two types will work when the newType and oldType are basic types or structs or enums.
-   //However, when they are containers, get_name() returns empty for which we have to compare the type of 
+   //However, when they are containers, get_name() returns empty for which we have to compare the type of
    //their elements as well.
    if((newType->get_name()).empty() && (oldType->get_name()).empty())
    {
@@ -150,7 +150,7 @@ bool compare_type(t_type* newType, t_type* oldType)
       {
          t_type* newElementType = ((t_set*)newType)->get_elem_type();
          t_type* oldElementType = ((t_set*)oldType)->get_elem_type();
-         return compare_type(newElementType, oldElementType); 
+         return compare_type(newElementType, oldElementType);
       }
       else
       {
@@ -170,7 +170,7 @@ bool compare_type(t_type* newType, t_type* oldType)
 bool compare_pair(std::pair<t_const_value*, t_const_value*> newMapPair, std::pair<t_const_value*, t_const_value*> oldMapPair)
 {
    return compare_defaults(newMapPair.first, oldMapPair.first) && compare_defaults(newMapPair.second, oldMapPair.second);
-}   
+}
 
 // This function returns 'true' if the default values are same. Returns false if they are different.
 bool compare_defaults(t_const_value* newStructDefault, t_const_value* oldStructDefault)
@@ -259,7 +259,7 @@ void compare_single_struct(t_struct* newStruct, t_struct* oldStruct, const std::
    std::vector<t_field*>::const_iterator newStructMemberIt = newStructMembersInIdOrder.begin();
 
    // Since we have the struct members in their ID order, comparing their IDs can be done by traversing the two member
-   // lists together.  
+   // lists together.
    while(!(oldStructMemberIt == oldStructMembersInIdOrder.end() && newStructMemberIt == newStructMembersInIdOrder.end()))
    {
       if(newStructMemberIt == newStructMembersInIdOrder.end() && oldStructMemberIt != oldStructMembersInIdOrder.end())
@@ -462,5 +462,3 @@ void compare_consts(const std::vector<t_const*>& newConst, const std::vector<t_c
       }
    }
 }
-
-
diff --git a/compiler/cpp/src/audit/t_audit.h b/compiler/cpp/src/thrift/audit/t_audit.h
similarity index 100%
rename from compiler/cpp/src/audit/t_audit.h
rename to compiler/cpp/src/thrift/audit/t_audit.h
diff --git a/compiler/cpp/src/thrift/common.cc b/compiler/cpp/src/thrift/common.cc
new file mode 100644
index 00000000000..3a2b9d359ec
--- /dev/null
+++ b/compiler/cpp/src/thrift/common.cc
@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include "thrift/common.h"
+#include "thrift/parse/t_base_type.h"
+
+t_type* g_type_void;
+t_type* g_type_string;
+t_type* g_type_binary;
+t_type* g_type_slist;
+t_type* g_type_bool;
+t_type* g_type_i8;
+t_type* g_type_i16;
+t_type* g_type_i32;
+t_type* g_type_i64;
+t_type* g_type_double;
+
+void initGlobals() {
+  g_type_void = new t_base_type("void", t_base_type::TYPE_VOID);
+  g_type_string = new t_base_type("string", t_base_type::TYPE_STRING);
+  g_type_binary = new t_base_type("string", t_base_type::TYPE_STRING);
+  ((t_base_type*)g_type_binary)->set_binary(true);
+  g_type_slist = new t_base_type("string", t_base_type::TYPE_STRING);
+  ((t_base_type*)g_type_slist)->set_string_list(true);
+  g_type_bool = new t_base_type("bool", t_base_type::TYPE_BOOL);
+  g_type_i8 = new t_base_type("i8", t_base_type::TYPE_I8);
+  g_type_i16 = new t_base_type("i16", t_base_type::TYPE_I16);
+  g_type_i32 = new t_base_type("i32", t_base_type::TYPE_I32);
+  g_type_i64 = new t_base_type("i64", t_base_type::TYPE_I64);
+  g_type_double = new t_base_type("double", t_base_type::TYPE_DOUBLE);
+}
+
+void clearGlobals() {
+  delete g_type_void;
+  delete g_type_string;
+  delete g_type_bool;
+  delete g_type_i8;
+  delete g_type_i16;
+  delete g_type_i32;
+  delete g_type_i64;
+  delete g_type_double;
+}
+
+/**
+ * Those are not really needed for plugins but causes link errors without
+ */
+
+/**
+ * The location of the last parsed doctext comment.
+ */
+int g_doctext_lineno;
+int g_program_doctext_lineno = 0;
+PROGDOCTEXT_STATUS g_program_doctext_status = INVALID;
diff --git a/compiler/cpp/src/thrift/common.h b/compiler/cpp/src/thrift/common.h
new file mode 100644
index 00000000000..69488463630
--- /dev/null
+++ b/compiler/cpp/src/thrift/common.h
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifndef T_COMMON_H
+#define T_COMMON_H
+
+#include "thrift/parse/t_type.h"
+
+/**
+ * Global types for the parser to be able to reference
+ */
+
+extern t_type* g_type_void;
+extern t_type* g_type_string;
+extern t_type* g_type_binary;
+extern t_type* g_type_slist;
+extern t_type* g_type_bool;
+extern t_type* g_type_i8;
+extern t_type* g_type_i16;
+extern t_type* g_type_i32;
+extern t_type* g_type_i64;
+extern t_type* g_type_double;
+
+void initGlobals();
+void clearGlobals();
+
+#endif
diff --git a/compiler/cpp/src/generate/t_as3_generator.cc b/compiler/cpp/src/thrift/generate/t_as3_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_as3_generator.cc
rename to compiler/cpp/src/thrift/generate/t_as3_generator.cc
index 67beaf640ab..5ae3f91d66d 100644
--- a/compiler/cpp/src/generate/t_as3_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_as3_generator.cc
@@ -27,8 +27,8 @@
 #include <sys/stat.h>
 #include <stdexcept>
 
-#include "platform.h"
-#include "t_oop_generator.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -57,7 +57,7 @@ class t_as3_generator : public t_oop_generator {
       if( iter->first.compare("bindable") == 0) {
         bindable_ = true;
       } else {
-        throw "unknown option as3:" + iter->first; 
+        throw "unknown option as3:" + iter->first;
       }
     }
 
diff --git a/compiler/cpp/src/generate/t_c_glib_generator.cc b/compiler/cpp/src/thrift/generate/t_c_glib_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_c_glib_generator.cc
rename to compiler/cpp/src/thrift/generate/t_c_glib_generator.cc
index 3a3fe540712..7d4e4f03dbc 100644
--- a/compiler/cpp/src/generate/t_c_glib_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_c_glib_generator.cc
@@ -29,8 +29,8 @@
 
 #include <ctype.h>
 
-#include "platform.h"
-#include "t_oop_generator.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -65,7 +65,7 @@ class t_c_glib_generator : public t_oop_generator {
 
     /* no options yet */
     for( iter = parsed_options.begin(); iter != parsed_options.end(); ++iter) {
-      throw "unknown option c_glib:" + iter->first; 
+      throw "unknown option c_glib:" + iter->first;
     }
 
     /* set the namespace */
diff --git a/compiler/cpp/src/generate/t_cocoa_generator.cc b/compiler/cpp/src/thrift/generate/t_cocoa_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_cocoa_generator.cc
rename to compiler/cpp/src/thrift/generate/t_cocoa_generator.cc
index 794fb44ed36..eba94c0a305 100644
--- a/compiler/cpp/src/generate/t_cocoa_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_cocoa_generator.cc
@@ -25,8 +25,8 @@
 #include <stdlib.h>
 #include <sys/stat.h>
 #include <sstream>
-#include "t_oop_generator.h"
-#include "platform.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ostream;
@@ -72,7 +72,7 @@ class t_cocoa_generator : public t_oop_generator {
       } else if( iter->first.compare("pods") == 0) {
         pods_ = true;
       } else {
-        throw "unknown option cocoa:" + iter->first; 
+        throw "unknown option cocoa:" + iter->first;
       }
     }
 
@@ -292,7 +292,7 @@ void t_cocoa_generator::init_generator() {
 
   f_impl_ << cocoa_imports() << cocoa_thrift_imports() << "#import \"" << f_header_name << "\""
           << endl << endl;
-  
+
   error_constant_ = 60000;
 }
 
@@ -335,9 +335,9 @@ string t_cocoa_generator::cocoa_thrift_imports() {
     }
     includes << endl;
   }
-  
+
   includes << endl;
-  
+
   if (promise_kit_) {
     includes << "#import ";
     if (pods_) {
@@ -356,7 +356,7 @@ string t_cocoa_generator::cocoa_thrift_imports() {
              << capitalize(other_includes[i]->get_name())
              << ".h\"" << endl;
   }
-  
+
   includes << endl;
 
   return includes.str();
@@ -444,7 +444,7 @@ void t_cocoa_generator::generate_consts(std::vector<t_const*> consts) {
 
   const_interface << "FOUNDATION_EXPORT NSString *" << cocoa_prefix_ << capitalize(program_name_) << "ErrorDomain;" << endl
                   << endl;
-  
+
 
   bool needs_class = false;
 
@@ -460,12 +460,12 @@ void t_cocoa_generator::generate_consts(std::vector<t_const*> consts) {
       needs_class = true;
     }
   }
-  
-  
+
+
   string constants_class_name = cocoa_prefix_ + capitalize(program_name_) + "Constants";
 
   if (needs_class) {
-    
+
     const_interface << endl;
 
     const_interface << "@interface " << constants_class_name << " : NSObject ";
@@ -487,7 +487,7 @@ void t_cocoa_generator::generate_consts(std::vector<t_const*> consts) {
 
   // this gets spit into the header file in ::close_generator
   constants_declarations_ = const_interface.str();
-  
+
   f_impl_ << "NSString *" << cocoa_prefix_ << capitalize(program_name_) << "ErrorDomain = "
           << "@\"" << cocoa_prefix_ << capitalize(program_name_) << "ErrorDomain\";" << endl << endl;
 
@@ -571,14 +571,14 @@ void t_cocoa_generator::generate_xception(t_struct* txception) {
 void t_cocoa_generator::generate_cocoa_struct_interface(ofstream& out,
                                                         t_struct* tstruct,
                                                         bool is_exception) {
-  
+
   if (is_exception) {
     out << "enum {" << endl
         << "  " << cocoa_prefix_ << capitalize(program_name_) << "Error" << tstruct->get_name() <<  " = -" << error_constant_++ << endl
         << "};" << endl
         << endl;
   }
-  
+
   out << "@interface " << cocoa_prefix_ << tstruct->get_name() << " : ";
 
   if (is_exception) {
@@ -587,7 +587,7 @@ void t_cocoa_generator::generate_cocoa_struct_interface(ofstream& out,
     out << "NSObject ";
   }
   out << "<TBase, NSCoding, NSCopying> " << endl;
-  
+
   out << endl;
 
   // properties
@@ -601,7 +601,7 @@ void t_cocoa_generator::generate_cocoa_struct_interface(ofstream& out,
       out << endl;
     }
   }
-  
+
   out << endl;
 
   // initializer for all fields
@@ -647,14 +647,14 @@ void t_cocoa_generator::generate_cocoa_struct_init_with_coder_method(ofstream& o
 
   indent(out) << "- (instancetype) initWithCoder: (NSCoder *) decoder" << endl;
   scope_up(out);
-  
+
   if (is_exception) {
     // NSExceptions conform to NSCoding, so we can call super
     indent(out) << "self = [super initWithCoder: decoder];" << endl;
   } else {
     indent(out) << "self = [super init];" << endl;
   }
-  
+
   indent(out) << "if (self) ";
   scope_up(out);
 
@@ -701,7 +701,7 @@ void t_cocoa_generator::generate_cocoa_struct_init_with_coder_method(ofstream& o
     out << indent() << "_" << (*m_iter)->get_name() << "IsSet = YES;" << endl;
     scope_down(out);
   }
-  
+
   scope_down(out);
 
   out << indent() << "return self;" << endl;
@@ -719,7 +719,7 @@ void t_cocoa_generator::generate_cocoa_struct_encode_with_coder_method(ofstream&
 
   indent(out) << "- (void) encodeWithCoder: (NSCoder *) encoder" << endl;
   scope_up(out);
-  
+
   if (is_exception) {
     // NSExceptions conform to NSCoding, so we can call super
     out << indent() << "[super encodeWithCoder: encoder];" << endl;
@@ -783,16 +783,16 @@ void t_cocoa_generator::generate_cocoa_struct_encode_with_coder_method(ofstream&
 void t_cocoa_generator::generate_cocoa_struct_copy_method(ofstream& out, t_struct* tstruct, bool is_exception) {
   out << indent() << "- (instancetype) copyWithZone:(NSZone *)zone" << endl;
   scope_up(out);
-  
+
   if (is_exception) {
     out << indent() << type_name(tstruct) << " val = [" << cocoa_prefix_ << tstruct->get_name() << " errorWithDomain: self.domain code: self.code userInfo: self.userInfo];" << endl;
   } else {
     out << indent() << type_name(tstruct) << " val = [" << cocoa_prefix_ << tstruct->get_name() << " new];" << endl;
   }
-  
+
   const vector<t_field*>& members = tstruct->get_members();
   vector<t_field*>::const_iterator m_iter;
-  
+
   for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
     t_type* t = get_true_type((*m_iter)->get_type());
     out << indent() << "if (_" << (*m_iter)->get_name() << "IsSet)" << endl;
@@ -805,9 +805,9 @@ void t_cocoa_generator::generate_cocoa_struct_copy_method(ofstream& out, t_struc
     out << endl;
     scope_down(out);
   }
-  
+
   out << indent() << "return val;" << endl;
-  
+
   scope_down(out);
   out << endl;
 }
@@ -878,7 +878,7 @@ void t_cocoa_generator::generate_cocoa_struct_is_equal_method(ofstream& out, t_s
 
   if (!members.empty()) {
     indent(out) << class_name << " *other = (" << class_name << " *)anObject;" << endl;
-    
+
     for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
       t_type* t = get_true_type((*m_iter)->get_type());
       string name = (*m_iter)->get_name();
@@ -969,7 +969,7 @@ void t_cocoa_generator::generate_cocoa_struct_implementation(ofstream& out,
     } else {
       out << indent() << "self = [super init];" << endl;
     }
-    
+
     indent(out) << "if (self)";
     scope_up(out);
     for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
@@ -1069,7 +1069,7 @@ void t_cocoa_generator::generate_cocoa_struct_reader(ofstream& out, t_struct* ts
       out << indent() << "  NSLog(@\"%s: field ID %i has unexpected type %i.  Skipping.\", "
                          "__PRETTY_FUNCTION__, (int)fieldID, (int)fieldType);" << endl;
     }
-    
+
     out << indent() << "  if (![TProtocolUtil skipType: fieldType onProtocol: inProtocol error: __thriftError]) return NO;" << endl;
     out << indent() << "}" << endl << indent() << "break;" << endl;
     indent_down();
@@ -1083,7 +1083,7 @@ void t_cocoa_generator::generate_cocoa_struct_reader(ofstream& out, t_struct* ts
   }
 
   out << indent() << "  if (![TProtocolUtil skipType: fieldType onProtocol: inProtocol error: __thriftError]) return NO;" << endl;
-  
+
   out << indent() << "  break;" << endl;
 
   scope_down(out);
@@ -1101,7 +1101,7 @@ void t_cocoa_generator::generate_cocoa_struct_reader(ofstream& out, t_struct* ts
   }
 
   indent(out) << "return YES;" << endl;
-  
+
   indent_down();
   out << indent() << "}" << endl << endl;
 }
@@ -1150,7 +1150,7 @@ void t_cocoa_generator::generate_cocoa_struct_writer(ofstream& out, t_struct* ts
       << indent() << "if (![outProtocol writeStructEnd: __thriftError]) return NO;" << endl;
 
   indent(out) << "return YES;" << endl;
-  
+
   indent_down();
   out << indent() << "}" << endl << endl;
 }
@@ -1214,7 +1214,7 @@ void t_cocoa_generator::generate_cocoa_struct_result_writer(ofstream& out, t_str
       << endl;
 
   indent(out) << "return YES;" << endl;
-  
+
   indent_down();
   out << indent() << "}" << endl << endl;
 }
@@ -1299,7 +1299,7 @@ void t_cocoa_generator::generate_cocoa_struct_field_accessor_implementations(ofs
  * @param tstruct The struct definition
  */
 void t_cocoa_generator::generate_cocoa_struct_description(ofstream& out, t_struct* tstruct) {
-  
+
   // Allow use of debugDescription so the app can add description via a cateogory/extension
   if (debug_descriptions_) {
     out << indent() << "- (NSString *) debugDescription {" << endl;
@@ -1362,11 +1362,11 @@ void t_cocoa_generator::generate_cocoa_service_helpers(t_service* tservice) {
   vector<t_function*> functions = tservice->get_functions();
   vector<t_function*>::iterator f_iter;
   for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
-    
+
     t_struct* ts = (*f_iter)->get_arglist();
-    
+
     string qname = function_args_helper_struct_type(tservice, *f_iter);
-    
+
     t_struct qname_ts = t_struct(ts->get_program(), qname);
 
     const vector<t_field*>& members = ts->get_members();
@@ -1374,7 +1374,7 @@ void t_cocoa_generator::generate_cocoa_service_helpers(t_service* tservice) {
     for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
       qname_ts.append(*m_iter);
     }
-    
+
     generate_cocoa_struct_interface(f_impl_, &qname_ts, false);
     generate_cocoa_struct_implementation(f_impl_, &qname_ts, false, false);
     generate_function_helpers(tservice, *f_iter);
@@ -1534,7 +1534,7 @@ void t_cocoa_generator::generate_cocoa_service_client_send_function_implementati
   // Open function
   indent(out) << "- (BOOL) send_" << tfunction->get_name() << argument_list(tfunction->get_arglist(), needs_protocol ? "outProtocol" : "", true) << endl;
   scope_up(out);
-  
+
   // Serialize the request
   out << indent() << "if (![outProtocol writeMessageBeginWithName: @\"" << funname << "\""
       << (tfunction->is_oneway() ? " type: TMessageTypeONEWAY" : " type: TMessageTypeCALL")
@@ -1582,7 +1582,7 @@ void t_cocoa_generator::generate_cocoa_service_client_recv_function_implementati
     t_function* tfunction,
     bool needs_protocol) {
 
-  
+
   // Open function
   indent(out) << "- (BOOL) recv_" << tfunction->get_name();
   if (!tfunction->get_returntype()->is_void()) {
@@ -1668,7 +1668,7 @@ void t_cocoa_generator::generate_cocoa_service_client_recv_function_implementati
 void t_cocoa_generator::generate_cocoa_service_client_send_function_invocation(
                                                                                ofstream& out,
                                                                                t_function* tfunction) {
-  
+
   t_struct* arg_struct = tfunction->get_arglist();
   const vector<t_field*>& fields = arg_struct->get_members();
   vector<t_field*>::const_iterator fld_iter;
@@ -1699,7 +1699,7 @@ void t_cocoa_generator::generate_cocoa_service_client_send_async_function_invoca
                                                                                      ofstream& out,
                                                                                      t_function* tfunction,
                                                                                      string failureBlockName) {
-  
+
   t_struct* arg_struct = tfunction->get_arglist();
   const vector<t_field*>& fields = arg_struct->get_members();
   vector<t_field*>::const_iterator fld_iter;
@@ -1732,9 +1732,9 @@ void t_cocoa_generator::generate_cocoa_service_client_send_async_function_invoca
  */
 void t_cocoa_generator::generate_cocoa_service_client_implementation(ofstream& out,
                                                                      t_service* tservice) {
-  
+
   string name = cocoa_prefix_ + tservice->get_name() + "Client";
-  
+
   out << "@interface " << name << " () ";
   scope_up(out);
   out << endl;
@@ -1744,7 +1744,7 @@ void t_cocoa_generator::generate_cocoa_service_client_implementation(ofstream& o
   scope_down(out);
   out << endl;
   out << "@end" << endl << endl;
-  
+
   out << "@implementation " << name << endl;
 
   // initializers
@@ -1816,7 +1816,7 @@ void t_cocoa_generator::generate_cocoa_service_client_implementation(ofstream& o
  */
 void t_cocoa_generator::generate_cocoa_service_client_async_implementation(ofstream& out,
                                                                            t_service* tservice) {
-  
+
   string name = cocoa_prefix_ + tservice->get_name() + "ClientAsync";
 
   out << "@interface " << name << " () ";
@@ -1828,8 +1828,8 @@ void t_cocoa_generator::generate_cocoa_service_client_async_implementation(ofstr
   scope_down(out);
   out << endl;
   out << "@end" << endl << endl;
-  
-  
+
+
   out << "@implementation " << name << endl
       << endl << "- (id) initWithProtocolFactory: (id <TProtocolFactory>) aProtocolFactory "
                  "transportFactory: (id <TAsyncTransportFactory>) aTransportFactory;" << endl;
@@ -1858,12 +1858,12 @@ void t_cocoa_generator::generate_cocoa_service_client_async_implementation(ofstr
     // Open function
     indent(out) << "- " << async_function_signature(*f_iter, false) << endl;
     scope_up(out);
-    
+
     out << indent() << "NSError *thriftError;" << endl
         << indent() << "id<TAsyncTransport> transport = [transportFactory newTransport];" << endl
         << indent() << "id<TProtocol> protocol = [protocolFactory newProtocolOnTransport:transport];" << endl
         << endl;
-    
+
     generate_cocoa_service_client_send_async_function_invocation(out, *f_iter, "failureBlock");
 
     out << indent() << "[transport flushWithCompletion:^{" << endl;
@@ -1871,7 +1871,7 @@ void t_cocoa_generator::generate_cocoa_service_client_async_implementation(ofstr
 
     if (!(*f_iter)->is_oneway()) {
       out << indent() << "NSError *thriftError;" << endl;
-      
+
       if (!(*f_iter)->get_returntype()->is_void()) {
         out << indent() << type_name((*f_iter)->get_returntype()) << " result;" << endl;
       }
@@ -1885,7 +1885,7 @@ void t_cocoa_generator::generate_cocoa_service_client_async_implementation(ofstr
           << indent() << "return;" << endl;
       scope_down(out);
     }
-    
+
     out << indent() << "responseBlock(";
     if (!(*f_iter)->is_oneway() && !(*f_iter)->get_returntype()->is_void()) {
       out << "result";
@@ -1893,35 +1893,35 @@ void t_cocoa_generator::generate_cocoa_service_client_async_implementation(ofstr
     out << ");" << endl;
 
     indent_down();
-    
+
     out << indent() << "} failure:failureBlock];" << endl;
-    
+
     scope_down(out);
 
     out << endl;
-    
+
     // Promise function
     if (promise_kit_) {
-      
+
       indent(out) << "- " << promise_function_signature(*f_iter) << endl;
       scope_up(out);
-      
+
       out << indent() << "return [AnyPromise promiseWithResolverBlock:^(PMKResolver resolver) {" << endl;
       indent_up();
-      
+
       out << indent() << "NSError *thriftError;" << endl
           << indent() << "id<TAsyncTransport> transport = [transportFactory newTransport];" << endl
           << indent() << "id<TProtocol> protocol = [protocolFactory newProtocolOnTransport:transport];" << endl
           << endl;
-      
+
       generate_cocoa_service_client_send_async_function_invocation(out, *f_iter, "resolver");
-      
+
       out << indent() << "[transport flushWithCompletion:^{" << endl;
       indent_up();
-      
+
       if (!(*f_iter)->is_oneway()) {
         out << indent() << "NSError *thriftError;" << endl;
-        
+
         if (!(*f_iter)->get_returntype()->is_void()) {
           out << indent() << type_name((*f_iter)->get_returntype()) << " result;" << endl;
         }
@@ -1935,7 +1935,7 @@ void t_cocoa_generator::generate_cocoa_service_client_async_implementation(ofstr
             << indent() << "return;" << endl;
         scope_down(out);
       }
-      
+
       out << indent() << "resolver(";
       if ((*f_iter)->is_oneway() || (*f_iter)->get_returntype()->is_void()) {
         out << "@YES";
@@ -1945,24 +1945,24 @@ void t_cocoa_generator::generate_cocoa_service_client_async_implementation(ofstr
         out << "@(result)";
       }
       out << ");" << endl;
-      
+
       indent_down();
-      
+
       out << indent() << "} failure:^(NSError *error) {" << endl;
       indent_up();
       out << indent() << "resolver(error);" << endl;
       indent_down();
       out << indent() << "}];" << endl;
-      
+
       indent_down();
       out << indent() << "}];" << endl;
-      
+
       scope_down(out);
-      
+
       out << endl;
-      
+
     }
-    
+
   }
 
   out << "@end" << endl << endl;
@@ -1976,18 +1976,18 @@ void t_cocoa_generator::generate_cocoa_service_client_async_implementation(ofstr
  */
 void t_cocoa_generator::generate_cocoa_service_server_implementation(ofstream& out,
                                                                      t_service* tservice) {
-  
+
   string name = cocoa_prefix_ + tservice->get_name() + "Processor";
-  
+
   out << "@interface " << name << " () ";
-  
+
   scope_up(out);
   out << indent() << "id <" << cocoa_prefix_ << tservice->get_name() << "> service;" << endl;
   out << indent() << "NSDictionary * methodMap;" << endl;
   scope_down(out);
-  
+
   out << "@end" << endl << endl;
-  
+
   out << "@implementation " << name << endl;
 
   // initializer
@@ -2125,7 +2125,7 @@ void t_cocoa_generator::generate_cocoa_service_server_implementation(ofstream& o
     if (!(*f_iter)->get_returntype()->is_void()) {
       out << indent() << "[result setSuccess: " << unbox((*f_iter)->get_returntype(), "serviceResult") << "];" << endl;
     }
-    
+
     // write out the result if not oneway
     if (!(*f_iter)->is_oneway()) {
       out << indent() << "if (![outProtocol writeMessageBeginWithName: @\"" << funname << "\"" << endl;
@@ -2340,7 +2340,7 @@ string t_cocoa_generator::unbox(t_type* ttype, string field_name) {
         break;
     }
   }
-  
+
   // do nothing
   return field_name;
 }
@@ -2627,17 +2627,17 @@ string t_cocoa_generator::type_name(t_type* ttype, bool class_ref, bool needs_mu
 
 /**
  * Returns an Objective-C type name for container types
- * 
+ *
  * @param ttype the type
  */
 string t_cocoa_generator::element_type_name(t_type* etype) {
-  
+
   t_type* ttype = etype->get_true_type();
-  
+
   if (etype->is_typedef() && type_can_be_null(ttype)) {
     return type_name(etype);
   }
-  
+
   string result;
   if (ttype->is_base_type()) {
     t_base_type* tbase = (t_base_type*)ttype;
@@ -2655,7 +2655,7 @@ string t_cocoa_generator::element_type_name(t_type* etype) {
       break;
     }
   } else if (ttype->is_enum()) {
-      result = "NSNumber *";      
+      result = "NSNumber *";
   } else if (ttype->is_map()) {
     t_map *map = (t_map *)ttype;
     result = "NSDictionary<" + element_type_name(map->get_key_type()) + ", " + element_type_name(map->get_val_type()) + "> *";
@@ -2668,7 +2668,7 @@ string t_cocoa_generator::element_type_name(t_type* etype) {
   } else if (ttype->is_struct() || ttype->is_xception()) {
     result = cocoa_prefix_ + ttype->get_name() + " *";
   }
-  
+
   return result;
 }
 
@@ -3010,16 +3010,16 @@ string t_cocoa_generator::render_const_value(string name,
 string t_cocoa_generator::declare_property(t_field* tfield) {
   std::ostringstream render;
   render << "@property (";
-  
+
   if (type_can_be_null(tfield->get_type())) {
     render << "strong, ";
   } else {
     render << "assign, ";
   }
-  
+
   render << "nonatomic) " << type_name(tfield->get_type(), false, true) << " "
   << tfield->get_name() << ";";
-  
+
   // Check if the property name is an Objective-C return +1 count signal
   if ((tfield->get_name().length() >= 3 && tfield->get_name().substr(0,3) == "new") ||
       (tfield->get_name().length() >= 6 && tfield->get_name().substr(0,6) == "create") ||
@@ -3030,7 +3030,7 @@ string t_cocoa_generator::declare_property(t_field* tfield) {
       render << "- (" + type_name(tfield->get_type()) + ") " + decapitalize(tfield->get_name()) + " __attribute__((objc_method_family(none)));";
     }
   }
-  
+
   return render.str();
 }
 
@@ -3241,7 +3241,7 @@ string t_cocoa_generator::format_string_for_type(t_type* type) {
  */
 string t_cocoa_generator::format_cast_for_type(t_type* type) {
   type = get_true_type(type);
-  
+
   if (type->is_base_type()) {
     t_base_type::t_base tbase = ((t_base_type*)type)->get_base();
     switch (tbase) {
@@ -3273,7 +3273,7 @@ string t_cocoa_generator::format_cast_for_type(t_type* type) {
   } else if (type->is_list()) {
     return ""; // "%@";
   }
-  
+
   throw "INVALID TYPE IN format_cast_for_type: " + type->get_name();
 }
 
diff --git a/compiler/cpp/src/generate/t_cpp_generator.cc b/compiler/cpp/src/thrift/generate/t_cpp_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_cpp_generator.cc
rename to compiler/cpp/src/thrift/generate/t_cpp_generator.cc
index 6c0489902a5..cbe8da2264e 100644
--- a/compiler/cpp/src/generate/t_cpp_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_cpp_generator.cc
@@ -31,8 +31,8 @@
 
 #include <sys/stat.h>
 
-#include "platform.h"
-#include "t_oop_generator.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -81,7 +81,7 @@ class t_cpp_generator : public t_oop_generator {
       } else if( iter->first.compare("moveable_types") == 0) {
         gen_moveable_ = true;
       } else {
-        throw "unknown option cpp:" + iter->first; 
+        throw "unknown option cpp:" + iter->first;
       }
     }
 
@@ -2320,10 +2320,10 @@ void t_cpp_generator::generate_service_client(t_service* tservice, string style)
                 << "boost::shared_ptr< ::apache::thrift::transport::TMemoryBuffer> otrans_;"
                 << endl;
     }
-    f_header_ << 
-      indent() << prot_ptr << " piprot_;" << endl << 
-      indent() << prot_ptr << " poprot_;" << endl << 
-      indent() << protocol_type << "* iprot_;" << endl << 
+    f_header_ <<
+      indent() << prot_ptr << " piprot_;" << endl <<
+      indent() << prot_ptr << " poprot_;" << endl <<
+      indent() << protocol_type << "* iprot_;" << endl <<
       indent() << protocol_type << "* oprot_;" << endl;
 
     if (style == "Concurrent") {
@@ -2438,7 +2438,7 @@ void t_cpp_generator::generate_service_client(t_service* tservice, string style)
         }
       }
       // Serialize the request
-      out << 
+      out <<
         indent() << "int32_t cseqid = " << cseqidVal << ";" << endl;
       if(style == "Concurrent") {
         out <<
@@ -2449,10 +2449,10 @@ void t_cpp_generator::generate_service_client(t_service* tservice, string style)
           indent() << _this << "otrans_->resetBuffer();" << endl;
       }
       out <<
-        indent() << _this << "oprot_->writeMessageBegin(\"" << 
-        (*f_iter)->get_name() << 
-        "\", ::apache::thrift::protocol::" << ((*f_iter)->is_oneway() ? "T_ONEWAY" : "T_CALL") << 
-        ", cseqid);" << endl << endl << 
+        indent() << _this << "oprot_->writeMessageBegin(\"" <<
+        (*f_iter)->get_name() <<
+        "\", ::apache::thrift::protocol::" << ((*f_iter)->is_oneway() ? "T_ONEWAY" : "T_CALL") <<
+        ", cseqid);" << endl << endl <<
         indent() << argsname << " args;" << endl;
 
       for (fld_iter = fields.begin(); fld_iter != fields.end(); ++fld_iter) {
@@ -2498,9 +2498,9 @@ void t_cpp_generator::generate_service_client(t_service* tservice, string style)
         indent(out) << function_signature(&recv_function, "", scope) << endl;
         scope_up(out);
 
-        out << endl << 
-          indent() << "int32_t rseqid = 0;" << endl << 
-          indent() << "std::string fname;" << endl << 
+        out << endl <<
+          indent() << "int32_t rseqid = 0;" << endl <<
+          indent() << "std::string fname;" << endl <<
           indent() << "::apache::thrift::protocol::TMessageType mtype;" << endl;
         if(style == "Concurrent") {
           out <<
@@ -2529,10 +2529,10 @@ void t_cpp_generator::generate_service_client(t_service* tservice, string style)
           indent_up();
         }
         out <<
-          indent() << "if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {" << endl << 
-          indent() << "  ::apache::thrift::TApplicationException x;" << endl << 
-          indent() << "  x.read(" << _this << "iprot_);" << endl << 
-          indent() << "  " << _this << "iprot_->readMessageEnd();" << endl << 
+          indent() << "if (mtype == ::apache::thrift::protocol::T_EXCEPTION) {" << endl <<
+          indent() << "  ::apache::thrift::TApplicationException x;" << endl <<
+          indent() << "  x.read(" << _this << "iprot_);" << endl <<
+          indent() << "  " << _this << "iprot_->readMessageEnd();" << endl <<
           indent() << "  " << _this << "iprot_->getTransport()->readEnd();" << endl;
         if (style == "Cob" && !gen_no_client_completion_) {
           out << indent() << "  completed = true;" << endl << indent() << "  completed__(true);"
@@ -2541,22 +2541,22 @@ void t_cpp_generator::generate_service_client(t_service* tservice, string style)
         if (style == "Concurrent") {
           out << indent() << "  sentry.commit();" << endl;
         }
-        out << 
-          indent() << "  throw x;" << endl << 
-          indent() << "}" << endl << 
-          indent() << "if (mtype != ::apache::thrift::protocol::T_REPLY) {" << endl << 
-          indent() << "  " << _this << "iprot_->skip(" << "::apache::thrift::protocol::T_STRUCT);" << endl << 
-          indent() << "  " << _this << "iprot_->readMessageEnd();" << endl << 
+        out <<
+          indent() << "  throw x;" << endl <<
+          indent() << "}" << endl <<
+          indent() << "if (mtype != ::apache::thrift::protocol::T_REPLY) {" << endl <<
+          indent() << "  " << _this << "iprot_->skip(" << "::apache::thrift::protocol::T_STRUCT);" << endl <<
+          indent() << "  " << _this << "iprot_->readMessageEnd();" << endl <<
           indent() << "  " << _this << "iprot_->getTransport()->readEnd();" << endl;
         if (style == "Cob" && !gen_no_client_completion_) {
           out << indent() << "  completed = true;" << endl << indent() << "  completed__(false);"
               << endl;
         }
-        out << 
-          indent() << "}" << endl << 
-          indent() << "if (fname.compare(\"" << (*f_iter)->get_name() << "\") != 0) {" << endl << 
-          indent() << "  " << _this << "iprot_->skip(" << "::apache::thrift::protocol::T_STRUCT);" << endl << 
-          indent() << "  " << _this << "iprot_->readMessageEnd();" << endl << 
+        out <<
+          indent() << "}" << endl <<
+          indent() << "if (fname.compare(\"" << (*f_iter)->get_name() << "\") != 0) {" << endl <<
+          indent() << "  " << _this << "iprot_->skip(" << "::apache::thrift::protocol::T_STRUCT);" << endl <<
+          indent() << "  " << _this << "iprot_->readMessageEnd();" << endl <<
           indent() << "  " << _this << "iprot_->getTransport()->readEnd();" << endl;
         if (style == "Cob" && !gen_no_client_completion_) {
           out << indent() << "  completed = true;" << endl << indent() << "  completed__(false);"
@@ -2589,7 +2589,7 @@ void t_cpp_generator::generate_service_client(t_service* tservice, string style)
         // Careful, only look for _result if not a void function
         if (!(*f_iter)->get_returntype()->is_void()) {
           if (is_complex_type((*f_iter)->get_returntype())) {
-            out << 
+            out <<
               indent() << "if (result.__isset.success) {" << endl;
             out <<
               indent() << "  // _return pointer has now been filled" << endl;
@@ -2600,8 +2600,8 @@ void t_cpp_generator::generate_service_client(t_service* tservice, string style)
             if (style == "Concurrent") {
               out << indent() << "  sentry.commit();" << endl;
             }
-            out << 
-              indent() << "  return;" << endl << 
+            out <<
+              indent() << "  return;" << endl <<
               indent() << "}" << endl;
           } else {
             out << indent() << "if (result.__isset.success) {" << endl;
diff --git a/compiler/cpp/src/generate/t_csharp_generator.cc b/compiler/cpp/src/thrift/generate/t_csharp_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_csharp_generator.cc
rename to compiler/cpp/src/thrift/generate/t_csharp_generator.cc
index d356f2616bf..ae3c48b0858 100644
--- a/compiler/cpp/src/generate/t_csharp_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_csharp_generator.cc
@@ -33,8 +33,8 @@
 #include <sys/stat.h>
 #include <sstream>
 
-#include "platform.h"
-#include "t_oop_generator.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -83,7 +83,7 @@ class t_csharp_generator : public t_oop_generator {
         wcf_ = true;
         wcf_namespace_ = iter->second;
       } else {
-        throw "unknown option csharp:" + iter->first; 
+        throw "unknown option csharp:" + iter->first;
       }
     }
 
@@ -268,7 +268,7 @@ void t_csharp_generator::init_generator() {
 
   namespace_dir_ = subdir;
   init_keywords();
-  
+
   while( ! member_mapping_scopes.empty()) {
     cleanup_member_name_mapping( member_mapping_scopes.back().scope_member);
   }
@@ -1005,7 +1005,7 @@ void t_csharp_generator::generate_csharp_struct_reader(ofstream& out, t_struct*
 void t_csharp_generator::generate_csharp_struct_writer(ofstream& out, t_struct* tstruct) {
   out << indent() << "public void Write(TProtocol oprot) {" << endl;
   indent_up();
-  
+
   out << indent() << "oprot.IncrementRecursionDepth();" << endl;
   out << indent() << "try" << endl;
   scope_up(out);
@@ -1061,7 +1061,7 @@ void t_csharp_generator::generate_csharp_struct_writer(ofstream& out, t_struct*
   scope_down(out);
 
   indent_down();
-  
+
   indent(out) << "}" << endl << endl;
 }
 
@@ -2857,7 +2857,7 @@ void t_csharp_generator::cleanup_member_name_mapping(void* scope) {
   if( member_mapping_scopes.empty()) {
     throw "internal error: cleanup_member_name_mapping() no scope active";
   }
-  
+
   member_mapping_scope& active = member_mapping_scopes.back();
   if (active.scope_member != scope) {
     throw "internal error: cleanup_member_name_mapping() called for wrong struct";
@@ -2874,7 +2874,7 @@ string t_csharp_generator::get_mapped_member_name(string name) {
       return iter->second;
     }
   }
-  
+
   pverbose("no mapping for member %s\n", name.c_str());
   return name;
 }
diff --git a/compiler/cpp/src/generate/t_d_generator.cc b/compiler/cpp/src/thrift/generate/t_d_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_d_generator.cc
rename to compiler/cpp/src/thrift/generate/t_d_generator.cc
index 1e0af7d51cb..481668146c0 100644
--- a/compiler/cpp/src/generate/t_d_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_d_generator.cc
@@ -32,8 +32,8 @@
 
 #include <sys/stat.h>
 
-#include "platform.h"
-#include "t_oop_generator.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -64,7 +64,7 @@ class t_d_generator : public t_oop_generator {
 
     /* no options yet */
     for( iter = parsed_options.begin(); iter != parsed_options.end(); ++iter) {
-      throw "unknown option d:" + iter->first; 
+      throw "unknown option d:" + iter->first;
     }
 
     out_dir_base_ = "gen-d";
diff --git a/compiler/cpp/src/generate/t_dart_generator.cc b/compiler/cpp/src/thrift/generate/t_dart_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_dart_generator.cc
rename to compiler/cpp/src/thrift/generate/t_dart_generator.cc
index bec2e47e6e0..81bf0520a96 100644
--- a/compiler/cpp/src/generate/t_dart_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_dart_generator.cc
@@ -27,8 +27,8 @@
 #include <sys/stat.h>
 #include <stdexcept>
 
-#include "platform.h"
-#include "t_oop_generator.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
diff --git a/compiler/cpp/src/generate/t_delphi_generator.cc b/compiler/cpp/src/thrift/generate/t_delphi_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_delphi_generator.cc
rename to compiler/cpp/src/thrift/generate/t_delphi_generator.cc
index fece1da9645..8b1a44520ee 100644
--- a/compiler/cpp/src/generate/t_delphi_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_delphi_generator.cc
@@ -34,8 +34,8 @@
 #include <sstream>
 #include <cctype>
 
-#include "platform.h"
-#include "t_oop_generator.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -77,7 +77,7 @@ class t_delphi_generator : public t_oop_generator {
       } else if( iter->first.compare("xmldoc") == 0) {
         xmldoc_ = true;
       } else {
-        throw "unknown option delphi:" + iter->first; 
+        throw "unknown option delphi:" + iter->first;
       }
     }
 
@@ -3601,7 +3601,7 @@ void t_delphi_generator::generate_delphi_struct_reader_impl(ostream& out,
       indent_impl(code_block) << "if not _req_isset_" << prop_name(*f_iter, is_exception) << endl;
       indent_impl(code_block)
           << "then raise TProtocolExceptionInvalidData.Create("
-          << "'required field " << prop_name(*f_iter, is_exception) << " not set');" 
+          << "'required field " << prop_name(*f_iter, is_exception) << " not set');"
           << endl;
     }
   }
@@ -3641,7 +3641,7 @@ void t_delphi_generator::generate_delphi_struct_result_writer_impl(ostream& out,
 
   indent_impl(local_vars) << "tracker : IProtocolRecursionTracker;" << endl;
   indent_impl(code_block) << "tracker := oprot.NextRecursionLevel;" << endl;
-  
+
   indent_impl(code_block) << "struc := TStructImpl.Create('" << name << "');" << endl;
   indent_impl(code_block) << "oprot.WriteStructBegin(struc);" << endl;
 
@@ -3722,7 +3722,7 @@ void t_delphi_generator::generate_delphi_struct_writer_impl(ostream& out,
       null_allowed = false;
       indent_impl(code_block) << "if (" << fieldname << " = nil)" << endl;
 	  indent_impl(code_block) << "then raise TProtocolExceptionInvalidData.Create("
-                              << "'required field " << fieldname << " not set');" 
+                              << "'required field " << fieldname << " not set');"
                               << endl;
     }
     if (null_allowed) {
diff --git a/compiler/cpp/src/generate/t_erl_generator.cc b/compiler/cpp/src/thrift/generate/t_erl_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_erl_generator.cc
rename to compiler/cpp/src/thrift/generate/t_erl_generator.cc
index 9ac908cbcb5..48694144a04 100644
--- a/compiler/cpp/src/generate/t_erl_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_erl_generator.cc
@@ -26,9 +26,9 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sstream>
-#include "t_generator.h"
-#include "platform.h"
-#include "version.h"
+#include "thrift/platform.h"
+#include "thrift/version.h"
+#include "thrift/generate/t_generator.h"
 
 using std::map;
 using std::ofstream;
diff --git a/compiler/cpp/src/generate/t_generator.cc b/compiler/cpp/src/thrift/generate/t_generator.cc
similarity index 89%
rename from compiler/cpp/src/generate/t_generator.cc
rename to compiler/cpp/src/thrift/generate/t_generator.cc
index e7760d7dca4..0c1f49daf37 100644
--- a/compiler/cpp/src/generate/t_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_generator.cc
@@ -17,7 +17,7 @@
  * under the License.
  */
 
-#include "t_generator.h"
+#include "thrift/generate/t_generator.h"
 using namespace std;
 
 /**
@@ -127,11 +127,12 @@ void t_generator_registry::register_generator(t_generator_factory* factory) {
   the_map[factory->get_short_name()] = factory;
 }
 
-t_generator* t_generator_registry::get_generator(t_program* program, const string& options) {
+void t_generator::parse_options(const string& options,
+                                string& language,
+                                map<string, string>& parsed_options) {
   string::size_type colon = options.find(':');
-  string language = options.substr(0, colon);
+  language = options.substr(0, colon);
 
-  map<string, string> parsed_options;
   if (colon != string::npos) {
     string::size_type pos = colon + 1;
     while (pos != string::npos && pos < options.size()) {
@@ -152,7 +153,12 @@ t_generator* t_generator_registry::get_generator(t_program* program, const strin
       parsed_options[key] = value;
     }
   }
+}
 
+t_generator* t_generator_registry::get_generator(t_program* program,
+                                                 const string& language,
+                                                 const map<string, string>& parsed_options,
+                                                 const std::string& options) {
   gen_map_t& the_map = get_generator_map();
   gen_map_t::iterator iter = the_map.find(language);
 
@@ -163,6 +169,13 @@ t_generator* t_generator_registry::get_generator(t_program* program, const strin
   return iter->second->get_generator(program, parsed_options, options);
 }
 
+t_generator* t_generator_registry::get_generator(t_program* program, const string& options) {
+  string language;
+  map<string, string> parsed_options;
+  t_generator::parse_options(options, language, parsed_options);
+  return get_generator(program, language, parsed_options, options);
+}
+
 t_generator_registry::gen_map_t& t_generator_registry::get_generator_map() {
   // http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.12
   static gen_map_t* the_map = new gen_map_t();
diff --git a/compiler/cpp/src/generate/t_generator.h b/compiler/cpp/src/thrift/generate/t_generator.h
similarity index 95%
rename from compiler/cpp/src/generate/t_generator.h
rename to compiler/cpp/src/thrift/generate/t_generator.h
index 4136ab66cb5..051bbc423ca 100644
--- a/compiler/cpp/src/generate/t_generator.h
+++ b/compiler/cpp/src/thrift/generate/t_generator.h
@@ -24,10 +24,10 @@
 #include <iostream>
 #include <fstream>
 #include <sstream>
-#include "parse/t_program.h"
-#include "globals.h"
-#include "t_generator_registry.h"
-#include "version.h"
+#include "thrift/common.h"
+#include "thrift/version.h"
+#include "thrift/generate/t_generator_registry.h"
+#include "thrift/parse/t_program.h"
 
 /**
  * Base class for a thrift code generator. This class defines the basic
@@ -66,6 +66,9 @@ class t_generator {
                                   const std::string& contents,
                                   const std::string& comment_end);
 
+  static void parse_options(const std::string& options, std::string& language,
+                     std::map<std::string, std::string>& parsed_options);
+
   /**
    * check whether sub-namespace declaraction is used by generator.
    * e.g. allow
@@ -257,6 +260,7 @@ class t_generator {
   /**
    * Get the true type behind a series of typedefs.
    */
+  static const t_type* get_true_type(const t_type* type) { return type->get_true_type(); }
   static t_type* get_true_type(t_type* type) { return type->get_true_type(); }
 
 protected:
diff --git a/compiler/cpp/src/generate/t_generator_registry.h b/compiler/cpp/src/thrift/generate/t_generator_registry.h
similarity index 93%
rename from compiler/cpp/src/generate/t_generator_registry.h
rename to compiler/cpp/src/thrift/generate/t_generator_registry.h
index a852385924b..1f02167bc11 100644
--- a/compiler/cpp/src/generate/t_generator_registry.h
+++ b/compiler/cpp/src/thrift/generate/t_generator_registry.h
@@ -81,6 +81,10 @@ class t_generator_registry {
   static void register_generator(t_generator_factory* factory);
 
   static t_generator* get_generator(t_program* program, const std::string& options);
+  static t_generator* get_generator(t_program* program,
+                                    const std::string& laugnage,
+                                    const std::map<std::string, std::string>& parsed_options,
+                                    const std::string& options);
 
   typedef std::map<std::string, t_generator_factory*> gen_map_t;
   static gen_map_t& get_generator_map();
diff --git a/compiler/cpp/src/generate/t_go_generator.cc b/compiler/cpp/src/thrift/generate/t_go_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_go_generator.cc
rename to compiler/cpp/src/thrift/generate/t_go_generator.cc
index f4ddfeb4e42..c8de7a87b24 100644
--- a/compiler/cpp/src/generate/t_go_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_go_generator.cc
@@ -36,9 +36,9 @@
 #include <sstream>
 #include <algorithm>
 #include <clocale>
-#include "t_generator.h"
-#include "platform.h"
-#include "version.h"
+#include "thrift/platform.h"
+#include "thrift/version.h"
+#include "thrift/generate/t_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -93,7 +93,7 @@ class t_go_generator : public t_generator {
       } else if( iter->first.compare("ignore_initialisms") == 0) {
         ignore_initialisms_ =  true;
       } else {
-        throw "unknown option go:" + iter->first; 
+        throw "unknown option go:" + iter->first;
       }
     }
 
@@ -3463,8 +3463,8 @@ string t_go_generator::module_name(t_type* ttype) {
   t_program* program = ttype->get_program();
 
   if (program != NULL && program != program_) {
-    if (program->get_namespace("go").empty() || 
-        program_->get_namespace("go").empty() || 
+    if (program->get_namespace("go").empty() ||
+        program_->get_namespace("go").empty() ||
         program->get_namespace("go") != program_->get_namespace("go")) {
       string module(get_real_go_module(program));
       // for namespaced includes, only keep part after dot.
diff --git a/compiler/cpp/src/generate/t_gv_generator.cc b/compiler/cpp/src/thrift/generate/t_gv_generator.cc
similarity index 98%
rename from compiler/cpp/src/generate/t_gv_generator.cc
rename to compiler/cpp/src/thrift/generate/t_gv_generator.cc
index 61be8e686bf..72b7c822bc7 100644
--- a/compiler/cpp/src/generate/t_gv_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_gv_generator.cc
@@ -27,8 +27,8 @@
 #include <stdlib.h>
 #include <sys/stat.h>
 #include <sstream>
-#include "t_generator.h"
-#include "platform.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -57,7 +57,7 @@ class t_gv_generator : public t_generator {
       if( iter->first.compare("exceptions") == 0) {
         exception_arrows = true;
       } else {
-        throw "unknown option gv:" + iter->first; 
+        throw "unknown option gv:" + iter->first;
       }
     }
 
diff --git a/compiler/cpp/src/generate/t_haxe_generator.cc b/compiler/cpp/src/thrift/generate/t_haxe_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_haxe_generator.cc
rename to compiler/cpp/src/thrift/generate/t_haxe_generator.cc
index d15958e59ee..e7be1a5b3b8 100644
--- a/compiler/cpp/src/generate/t_haxe_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_haxe_generator.cc
@@ -27,8 +27,8 @@
 #include <sys/stat.h>
 #include <stdexcept>
 
-#include "platform.h"
-#include "t_oop_generator.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -63,7 +63,7 @@ class t_haxe_generator : public t_oop_generator {
       } else if( iter->first.compare("buildmacro") == 0) {
         buildmacro_ = (iter->second);
       } else {
-        throw "unknown option haxe:" + iter->first; 
+        throw "unknown option haxe:" + iter->first;
       }
     }
 
@@ -1007,10 +1007,10 @@ void t_haxe_generator::generate_haxe_struct_writer(ofstream& out, t_struct* tstr
       indent(out) << "}" << endl;
     }
   }
-  
+
   indent(out) << "oprot.writeFieldStop();" << endl;
   indent(out) << "oprot.writeStructEnd();" << endl;
-  
+
   indent(out) << "oprot.DecrementRecursionDepth();" << endl;
   scope_down(out);
   indent(out) << "catch(e:Dynamic)" << endl;
@@ -1018,7 +1018,7 @@ void t_haxe_generator::generate_haxe_struct_writer(ofstream& out, t_struct* tstr
   indent(out) << "oprot.DecrementRecursionDepth();" << endl;
   indent(out) << "throw e;" << endl;
   scope_down(out);
-  
+
   indent_down();
   out << indent() << "}" << endl << endl;
 }
@@ -1042,7 +1042,7 @@ void t_haxe_generator::generate_haxe_struct_result_writer(ofstream& out, t_struc
   indent(out) << "oprot.IncrementRecursionDepth();" << endl;
   indent(out) << "try" << endl;
   scope_up(out);
-  
+
   indent(out) << "oprot.writeStructBegin(STRUCT_DESC);" << endl;
 
   bool first = true;
@@ -1070,11 +1070,11 @@ void t_haxe_generator::generate_haxe_struct_result_writer(ofstream& out, t_struc
     indent_down();
     indent(out) << "}";
   }
-  
+
   indent(out) << endl;
   indent(out) << "oprot.writeFieldStop();" << endl;
   indent(out) << "oprot.writeStructEnd();" << endl;
-  
+
   indent(out) << "oprot.DecrementRecursionDepth();" << endl;
   scope_down(out);
   indent(out) << "catch(e:Dynamic)" << endl;
@@ -1082,7 +1082,7 @@ void t_haxe_generator::generate_haxe_struct_result_writer(ofstream& out, t_struc
   indent(out) << "oprot.DecrementRecursionDepth();" << endl;
   indent(out) << "throw e;" << endl;
   scope_down(out);
-  
+
   indent_down();
   out << indent() << "}" << endl << endl;
 }
diff --git a/compiler/cpp/src/generate/t_hs_generator.cc b/compiler/cpp/src/thrift/generate/t_hs_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_hs_generator.cc
rename to compiler/cpp/src/thrift/generate/t_hs_generator.cc
index cef8cd0106f..a3ccd8d4b9f 100644
--- a/compiler/cpp/src/generate/t_hs_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_hs_generator.cc
@@ -27,10 +27,10 @@
 #include <sys/types.h>
 #include <sstream>
 
-#include "t_oop_generator.h"
+#include "thrift/platform.h"
+#include "thrift/version.h"
 
-#include "platform.h"
-#include "version.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -56,7 +56,7 @@ class t_hs_generator : public t_oop_generator {
 
     /* no options yet */
     for( iter = parsed_options.begin(); iter != parsed_options.end(); ++iter) {
-      throw "unknown option hs:" + iter->first; 
+      throw "unknown option hs:" + iter->first;
     }
 
     out_dir_base_ = "gen-hs";
diff --git a/compiler/cpp/src/generate/t_html_generator.cc b/compiler/cpp/src/thrift/generate/t_html_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_html_generator.cc
rename to compiler/cpp/src/thrift/generate/t_html_generator.cc
index 9594d390f90..ec78e10236d 100644
--- a/compiler/cpp/src/generate/t_html_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_html_generator.cc
@@ -26,9 +26,9 @@
 #include <stdlib.h>
 #include <sys/stat.h>
 #include <sstream>
-#include "t_generator.h"
-#include "t_html_generator.h"
-#include "platform.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_generator.h"
+#include "thrift/generate/t_html_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -64,7 +64,7 @@ class t_html_generator : public t_generator {
       } else if( iter->first.compare("noescape") == 0) {
         unsafe_ = true;
       } else {
-        throw "unknown option html:" + iter->first; 
+        throw "unknown option html:" + iter->first;
       }
     }
 
diff --git a/compiler/cpp/src/generate/t_html_generator.h b/compiler/cpp/src/thrift/generate/t_html_generator.h
similarity index 100%
rename from compiler/cpp/src/generate/t_html_generator.h
rename to compiler/cpp/src/thrift/generate/t_html_generator.h
diff --git a/compiler/cpp/src/generate/t_java_generator.cc b/compiler/cpp/src/thrift/generate/t_java_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_java_generator.cc
rename to compiler/cpp/src/thrift/generate/t_java_generator.cc
index 2db8cb82104..8b3c32626ad 100644
--- a/compiler/cpp/src/generate/t_java_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_java_generator.cc
@@ -31,8 +31,8 @@
 #include <sys/stat.h>
 #include <stdexcept>
 
-#include "platform.h"
-#include "t_oop_generator.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -97,10 +97,10 @@ class t_java_generator : public t_oop_generator {
         } else if(iter->second.compare("suppress") == 0) {
           suppress_generated_annotations_ = true;
         } else {
-          throw "unknown option java:" + iter->first + "=" + iter->second; 
+          throw "unknown option java:" + iter->first + "=" + iter->second;
         }
       } else {
-        throw "unknown option java:" + iter->first; 
+        throw "unknown option java:" + iter->first;
       }
     }
 
@@ -368,7 +368,7 @@ class t_java_generator : public t_oop_generator {
   bool use_option_type_;
   bool undated_generated_annotations_;
   bool suppress_generated_annotations_;
-  
+
 };
 
 /**
diff --git a/compiler/cpp/src/generate/t_javame_generator.cc b/compiler/cpp/src/thrift/generate/t_javame_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_javame_generator.cc
rename to compiler/cpp/src/thrift/generate/t_javame_generator.cc
index e9a206b39f6..aa7eccf637e 100644
--- a/compiler/cpp/src/generate/t_javame_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_javame_generator.cc
@@ -27,8 +27,8 @@
 #include <sys/stat.h>
 #include <stdexcept>
 
-#include "platform.h"
-#include "t_oop_generator.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -55,7 +55,7 @@ class t_javame_generator : public t_oop_generator {
 
     /* no options yet */
     for( iter = parsed_options.begin(); iter != parsed_options.end(); ++iter) {
-      throw "unknown option javame:" + iter->first; 
+      throw "unknown option javame:" + iter->first;
     }
 
     out_dir_base_ = "gen-javame";
diff --git a/compiler/cpp/src/generate/t_js_generator.cc b/compiler/cpp/src/thrift/generate/t_js_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_js_generator.cc
rename to compiler/cpp/src/thrift/generate/t_js_generator.cc
index af0f28426ed..b0046a0da1c 100644
--- a/compiler/cpp/src/generate/t_js_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_js_generator.cc
@@ -28,8 +28,8 @@
 #include <stdlib.h>
 #include <sys/stat.h>
 #include <sstream>
-#include "platform.h"
-#include "version.h"
+#include "thrift/platform.h"
+#include "thrift/version.h"
 
 using std::map;
 using std::ofstream;
@@ -40,7 +40,7 @@ using std::vector;
 
 static const string endl = "\n"; // avoid ostream << std::endl flushes
 
-#include "t_oop_generator.h"
+#include "thrift/generate/t_oop_generator.h"
 
 
 /**
@@ -66,7 +66,7 @@ class t_js_generator : public t_oop_generator {
       } else if( iter->first.compare("ts") == 0) {
         gen_ts_ = true;
       } else {
-        throw "unknown option js:" + iter->first; 
+        throw "unknown option js:" + iter->first;
       }
     }
 
diff --git a/compiler/cpp/src/generate/t_json_generator.cc b/compiler/cpp/src/thrift/generate/t_json_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_json_generator.cc
rename to compiler/cpp/src/thrift/generate/t_json_generator.cc
index 447bc6d0078..36e92166943 100644
--- a/compiler/cpp/src/generate/t_json_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_json_generator.cc
@@ -30,8 +30,8 @@
 #include <sys/stat.h>
 #include <sstream>
 
-#include "t_generator.h"
-#include "platform.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -61,7 +61,7 @@ class t_json_generator : public t_generator {
       if( iter->first.compare("merge") == 0) {
         should_merge_includes_ = true;
       } else {
-        throw "unknown option json:" + iter->first; 
+        throw "unknown option json:" + iter->first;
       }
     }
 
diff --git a/compiler/cpp/src/generate/t_lua_generator.cc b/compiler/cpp/src/thrift/generate/t_lua_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_lua_generator.cc
rename to compiler/cpp/src/thrift/generate/t_lua_generator.cc
index c6fb4934e35..97b8aa3efb3 100644
--- a/compiler/cpp/src/generate/t_lua_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_lua_generator.cc
@@ -18,8 +18,8 @@
  */
 
 #include <sstream>
-#include "t_oop_generator.h"
-#include "platform.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::ofstream;
 using std::string;
@@ -46,7 +46,7 @@ class t_lua_generator : public t_oop_generator {
       if( iter->first.compare("omit_requires") == 0) {
         gen_requires_ = false;
       } else {
-        throw "unknown option lua:" + iter->first; 
+        throw "unknown option lua:" + iter->first;
       }
     }
 
diff --git a/compiler/cpp/src/generate/t_ocaml_generator.cc b/compiler/cpp/src/thrift/generate/t_ocaml_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_ocaml_generator.cc
rename to compiler/cpp/src/thrift/generate/t_ocaml_generator.cc
index fc82ebca4ee..594219ae513 100644
--- a/compiler/cpp/src/generate/t_ocaml_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_ocaml_generator.cc
@@ -26,9 +26,9 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <sstream>
-#include "t_oop_generator.h"
-#include "platform.h"
-#include "version.h"
+#include "thrift/platform.h"
+#include "thrift/version.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::ios;
 using std::map;
@@ -55,7 +55,7 @@ class t_ocaml_generator : public t_oop_generator {
 
     /* no options yet */
     for( iter = parsed_options.begin(); iter != parsed_options.end(); ++iter) {
-      throw "unknown option ocaml:" + iter->first; 
+      throw "unknown option ocaml:" + iter->first;
     }
 
     out_dir_base_ = "gen-ocaml";
diff --git a/compiler/cpp/src/generate/t_oop_generator.h b/compiler/cpp/src/thrift/generate/t_oop_generator.h
similarity index 98%
rename from compiler/cpp/src/generate/t_oop_generator.h
rename to compiler/cpp/src/thrift/generate/t_oop_generator.h
index 07c9d85a38b..8fb580dfd41 100644
--- a/compiler/cpp/src/generate/t_oop_generator.h
+++ b/compiler/cpp/src/thrift/generate/t_oop_generator.h
@@ -23,8 +23,8 @@
 #include <string>
 #include <iostream>
 
-#include "globals.h"
-#include "t_generator.h"
+#include "thrift/common.h"
+#include "thrift/generate/t_generator.h"
 
 #include <algorithm>
 
diff --git a/compiler/cpp/src/generate/t_perl_generator.cc b/compiler/cpp/src/thrift/generate/t_perl_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_perl_generator.cc
rename to compiler/cpp/src/thrift/generate/t_perl_generator.cc
index 45cfe4becf5..bfe08f9f48a 100644
--- a/compiler/cpp/src/generate/t_perl_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_perl_generator.cc
@@ -26,9 +26,9 @@
 #include <stdlib.h>
 #include <sys/stat.h>
 #include <sstream>
-#include "t_oop_generator.h"
-#include "platform.h"
-#include "version.h"
+#include "thrift/platform.h"
+#include "thrift/version.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -54,7 +54,7 @@ class t_perl_generator : public t_oop_generator {
 
     /* no options yet */
     for( iter = parsed_options.begin(); iter != parsed_options.end(); ++iter) {
-      throw "unknown option perl:" + iter->first; 
+      throw "unknown option perl:" + iter->first;
     }
 
     out_dir_base_ = "gen-perl";
diff --git a/compiler/cpp/src/generate/t_php_generator.cc b/compiler/cpp/src/thrift/generate/t_php_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_php_generator.cc
rename to compiler/cpp/src/thrift/generate/t_php_generator.cc
index 9f79337bd73..c5b1cc8ab4d 100644
--- a/compiler/cpp/src/generate/t_php_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_php_generator.cc
@@ -25,8 +25,8 @@
 #include <stdlib.h>
 #include <sys/stat.h>
 #include <sstream>
-#include "t_oop_generator.h"
-#include "platform.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -78,7 +78,7 @@ class t_php_generator : public t_oop_generator {
       } else if( iter->first.compare("nsglobal") == 0) {
         nsglobal_ = iter->second;
       } else {
-        throw "unknown option php:" + iter->first; 
+        throw "unknown option php:" + iter->first;
       }
     }
 
diff --git a/compiler/cpp/src/generate/t_py_generator.cc b/compiler/cpp/src/thrift/generate/t_py_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_py_generator.cc
rename to compiler/cpp/src/thrift/generate/t_py_generator.cc
index 1ee0fcb6275..6401c283f26 100644
--- a/compiler/cpp/src/generate/t_py_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_py_generator.cc
@@ -27,9 +27,9 @@
 #include <sys/types.h>
 #include <sstream>
 #include <algorithm>
-#include "t_generator.h"
-#include "platform.h"
-#include "version.h"
+#include "thrift/platform.h"
+#include "thrift/version.h"
+#include "thrift/generate/t_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -112,7 +112,7 @@ class t_py_generator : public t_generator {
       } else if( iter->first.compare("coding") == 0) {
         coding_ = iter->second;
       } else {
-        throw "unknown option py:" + iter->first; 
+        throw "unknown option py:" + iter->first;
       }
     }
 
diff --git a/compiler/cpp/src/generate/t_rb_generator.cc b/compiler/cpp/src/thrift/generate/t_rb_generator.cc
similarity index 98%
rename from compiler/cpp/src/generate/t_rb_generator.cc
rename to compiler/cpp/src/thrift/generate/t_rb_generator.cc
index 49bf7e184dc..924f6f6eb2d 100644
--- a/compiler/cpp/src/generate/t_rb_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_rb_generator.cc
@@ -32,9 +32,9 @@
 #include <sys/types.h>
 #include <sstream>
 
-#include "t_oop_generator.h"
-#include "platform.h"
-#include "version.h"
+#include "thrift/platform.h"
+#include "thrift/version.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -91,7 +91,7 @@ class t_rb_generator : public t_oop_generator {
       } else if( iter->first.compare("namespaced") == 0) {
         namespaced_ = true;
       } else {
-        throw "unknown option ruby:" + iter->first; 
+        throw "unknown option ruby:" + iter->first;
       }
     }
 
@@ -195,14 +195,14 @@ class t_rb_generator : public t_oop_generator {
   std::string render_require_thrift();
   std::string render_includes();
   std::string declare_field(t_field* tfield);
-  std::string type_name(t_type* ttype);
-  std::string full_type_name(t_type* ttype);
+  std::string type_name(const t_type* ttype);
+  std::string full_type_name(const t_type* ttype);
   std::string function_signature(t_function* tfunction, std::string prefix = "");
   std::string argument_list(t_struct* tstruct);
   std::string type_to_enum(t_type* ttype);
   std::string rb_namespace_to_path_prefix(std::string rb_namespace);
 
-  std::vector<std::string> ruby_modules(t_program* p) {
+  std::vector<std::string> ruby_modules(const t_program* p) {
     std::string ns = p->get_namespace("rb");
     std::vector<std::string> modules;
     if (ns.empty()) {
@@ -1101,7 +1101,7 @@ string t_rb_generator::argument_list(t_struct* tstruct) {
   return result;
 }
 
-string t_rb_generator::type_name(t_type* ttype) {
+string t_rb_generator::type_name(const t_type* ttype) {
   string prefix = "";
 
   string name = ttype->get_name();
@@ -1112,7 +1112,7 @@ string t_rb_generator::type_name(t_type* ttype) {
   return prefix + name;
 }
 
-string t_rb_generator::full_type_name(t_type* ttype) {
+string t_rb_generator::full_type_name(const t_type* ttype) {
   string prefix = "::";
   vector<std::string> modules = ruby_modules(ttype->get_program());
   for (vector<std::string>::iterator m_iter = modules.begin(); m_iter != modules.end(); ++m_iter) {
diff --git a/compiler/cpp/src/generate/t_st_generator.cc b/compiler/cpp/src/thrift/generate/t_st_generator.cc
similarity index 99%
rename from compiler/cpp/src/generate/t_st_generator.cc
rename to compiler/cpp/src/thrift/generate/t_st_generator.cc
index bc15d24f3e2..ffd731820e9 100644
--- a/compiler/cpp/src/generate/t_st_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_st_generator.cc
@@ -32,9 +32,9 @@
 #include <sys/types.h>
 #include <sstream>
 
-#include "platform.h"
-#include "t_oop_generator.h"
-#include "version.h"
+#include "thrift/platform.h"
+#include "thrift/version.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -60,7 +60,7 @@ class t_st_generator : public t_oop_generator {
 
     /* no options yet */
     for( iter = parsed_options.begin(); iter != parsed_options.end(); ++iter) {
-      throw "unknown option st:" + iter->first; 
+      throw "unknown option st:" + iter->first;
     }
 
     out_dir_base_ = "gen-st";
diff --git a/compiler/cpp/src/generate/t_swift_generator.cc b/compiler/cpp/src/thrift/generate/t_swift_generator.cc
similarity index 98%
rename from compiler/cpp/src/generate/t_swift_generator.cc
rename to compiler/cpp/src/thrift/generate/t_swift_generator.cc
index 6e48bca62ee..87dd2f02076 100644
--- a/compiler/cpp/src/generate/t_swift_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_swift_generator.cc
@@ -26,8 +26,8 @@
 #include <stdlib.h>
 #include <sys/stat.h>
 #include <sstream>
-#include "t_oop_generator.h"
-#include "platform.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_oop_generator.h"
 
 using std::map;
 using std::ostream;
@@ -69,7 +69,7 @@ class t_swift_generator : public t_oop_generator {
       } else if( iter->first.compare("debug_descriptions") == 0) {
         debug_descriptions_ = true;
       } else {
-        throw "unknown option swift:" + iter->first; 
+        throw "unknown option swift:" + iter->first;
       }
     }
 
@@ -112,7 +112,7 @@ class t_swift_generator : public t_oop_generator {
                                   t_struct* tstruct,
                                   bool all,
                                   bool is_private);
-  
+
   void generate_swift_struct_implementation(ofstream& out,
                                             t_struct* tstruct,
                                             bool is_result,
@@ -183,23 +183,23 @@ class t_swift_generator : public t_oop_generator {
   void populate_reserved_words();
 
 private:
-  
+
   void block_open(ostream& out) {
     out << " {" << endl;
     indent_up();
   }
-  
+
   void block_close(ostream& out, bool end_line=true) {
     indent_down();
     indent(out) << "}";
     if (end_line) out << endl;
   }
 
-  
+
   bool field_is_optional(t_field* tfield) {
     return tfield->get_req() == t_field::T_OPTIONAL;
   }
-  
+
   bool struct_has_required_fields(t_struct* tstruct) {
     const vector<t_field*>& members = tstruct->get_members();
     vector<t_field*>::const_iterator m_iter;
@@ -210,7 +210,7 @@ class t_swift_generator : public t_oop_generator {
     }
     return false;
   }
-  
+
   bool struct_has_optional_fields(t_struct* tstruct) {
     const vector<t_field*>& members = tstruct->get_members();
     vector<t_field*>::const_iterator m_iter;
@@ -221,7 +221,7 @@ class t_swift_generator : public t_oop_generator {
     }
     return false;
   }
-  
+
   string constants_declarations_;
 
   /**
@@ -278,16 +278,16 @@ string t_swift_generator::swift_imports() {
 
   vector<string> includes_list;
   includes_list.push_back("Foundation");
-  
+
   ostringstream includes;
-  
+
   vector<string>::const_iterator i_iter;
   for (i_iter=includes_list.begin(); i_iter!=includes_list.end(); ++i_iter) {
     includes << "import " << *i_iter << endl;
   }
-  
+
   includes << endl;
-  
+
   return includes.str();
 }
 
@@ -300,7 +300,7 @@ string t_swift_generator::swift_thrift_imports() {
 
   vector<string> includes_list;
   includes_list.push_back("Thrift");
-  
+
   if (promise_kit_) {
     includes_list.push_back("PromiseKit");
   }
@@ -311,7 +311,7 @@ string t_swift_generator::swift_thrift_imports() {
   for (i_iter=includes_list.begin(); i_iter!=includes_list.end(); ++i_iter) {
     includes << "import " << *i_iter << endl;
   }
-  
+
   includes << endl;
 
   return includes.str();
@@ -358,15 +358,15 @@ void t_swift_generator::generate_enum(t_enum* tenum) {
 
   f_decl_ << endl;
   f_decl_ << indent() << "public init() { self.init(rawValue: " << constants.front()->get_value() << ")! }" << endl;
-  
+
   block_close(f_decl_);
   f_decl_ << endl;
-  
+
   f_impl_ << indent() << "extension " << tenum->get_name() << " : TEnum";
   block_open(f_impl_);
 
   f_impl_ << endl;
-  
+
   f_impl_ << indent() << "public static func readValueFromProtocol(proto: TProtocol) throws -> " << tenum->get_name();
   block_open(f_impl_);
   f_impl_ << indent() << "var raw = Int32()" << endl
@@ -374,20 +374,20 @@ void t_swift_generator::generate_enum(t_enum* tenum) {
           << indent() << "return " << tenum->get_name() << "(rawValue: raw)!" << endl;
   block_close(f_impl_);
   f_impl_ << endl;
-  
+
   f_impl_ << indent() << "public static func writeValue(value: " << tenum->get_name() << ", toProtocol proto: TProtocol) throws";
   block_open(f_impl_);
   f_impl_ << indent() << "try proto.writeI32(value.rawValue)" << endl;
   block_close(f_impl_);
   f_impl_ << endl;
-  
+
   block_close(f_impl_);
   f_impl_ << endl;
 }
 
 /**
  * Generates public constants for all Thrift constants.
- * 
+ *
  * @param consts Constants to generate
  */
 void t_swift_generator::generate_consts(vector<t_const*> consts) {
@@ -402,10 +402,10 @@ void t_swift_generator::generate_consts(vector<t_const*> consts) {
     render_const_value(const_interface, type, (*c_iter)->get_value());
     const_interface << endl << endl;
   }
-  
+
   // this gets spit into the header file in ::close_generator
   constants_declarations_ = const_interface.str();
-  
+
 }
 
 /**
@@ -413,7 +413,7 @@ void t_swift_generator::generate_consts(vector<t_const*> consts) {
  * with public members. Optional types are used for optional properties to
  * allow them to be tested for availability. Separate inits are included for
  * required properties & all properties.
- * 
+ *
  * Generates extensions to provide conformance to TStruct, TSerializable,
  * Hashable & Equatable
  *
@@ -435,7 +435,7 @@ void t_swift_generator::generate_xception(t_struct* txception) {
 }
 
 /**
- * Generate the interface for a struct. Only properties and 
+ * Generate the interface for a struct. Only properties and
  * init methods are included.
  *
  * @param tstruct The struct definition
@@ -445,36 +445,36 @@ void t_swift_generator::generate_xception(t_struct* txception) {
 void t_swift_generator::generate_swift_struct(ofstream& out,
                                               t_struct* tstruct,
                                               bool is_private) {
-  
+
   string visibility = is_private ? "private" : "public";
-  
+
   out << indent() << visibility << " final class " << tstruct->get_name();
 
   if (tstruct->is_xception()) {
     out << " : ErrorType";
   }
-  
+
   block_open(out);
 
   // properties
   const vector<t_field*>& members = tstruct->get_members();
   vector<t_field*>::const_iterator m_iter;
-  
+
   for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
     out << endl;
     out << indent() << declare_property(*m_iter, is_private) << endl;
   }
-  
+
   out << endl;
-  
+
   // init
-  
+
   indent(out) << visibility << " init()";
   block_open(out);
   block_close(out);
-  
+
   out << endl;
-  
+
   if (struct_has_required_fields(tstruct)) {
     generate_swift_struct_init(out, tstruct, false, is_private);
   }
@@ -483,7 +483,7 @@ void t_swift_generator::generate_swift_struct(ofstream& out,
   }
 
   block_close(out);
-  
+
   out << endl;
 }
 
@@ -506,7 +506,7 @@ void t_swift_generator::generate_swift_struct_init(ofstream& out,
 
   const vector<t_field*>& members = tstruct->get_members();
   vector<t_field*>::const_iterator m_iter;
-  
+
   bool first=true;
   for (m_iter = members.begin(); m_iter != members.end();) {
     if (all || !field_is_optional(*m_iter)) {
@@ -522,18 +522,18 @@ void t_swift_generator::generate_swift_struct_init(ofstream& out,
     ++m_iter;
   }
   out << ")";
-  
+
   block_open(out);
-  
+
   for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
     if (all || (*m_iter)->get_req() == t_field::T_REQUIRED || (*m_iter)->get_req() == t_field::T_OPT_IN_REQ_OUT) {
       out << indent() << "self." << maybe_escape_identifier((*m_iter)->get_name()) << " = "
           << maybe_escape_identifier((*m_iter)->get_name()) << endl;
     }
   }
-  
+
   block_close(out);
- 
+
   out << endl;
 }
 
@@ -551,23 +551,23 @@ void t_swift_generator::generate_swift_struct_hashable_extension(ofstream& out,
   string visibility = is_private ? "private" : "public";
 
   indent(out) << "extension " << tstruct->get_name() << " : Hashable";
-  
+
   block_open(out);
-  
+
   out << endl;
-  
+
   indent(out) << visibility << " var hashValue : Int";
-  
+
   block_open(out);
-  
-  
+
+
   const vector<t_field*>& members = tstruct->get_members();
   vector<t_field*>::const_iterator m_iter;
 
   if (!members.empty()) {
     indent(out) << "let prime = 31" << endl;
     indent(out) << "var result = 1" << endl;
-    
+
     for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
       t_field* tfield = *m_iter;
       string accessor = field_is_optional(tfield) ? "?." : ".";
@@ -575,7 +575,7 @@ void t_swift_generator::generate_swift_struct_hashable_extension(ofstream& out,
       indent(out) << "result = prime &* result &+ (" << maybe_escape_identifier(tfield->get_name()) << accessor
                   <<  "hashValue" << defaultor << ")" << endl;
     }
-    
+
     indent(out) << "return result" << endl;
   }
   else {
@@ -583,9 +583,9 @@ void t_swift_generator::generate_swift_struct_hashable_extension(ofstream& out,
   }
 
   block_close(out);
-  
+
   out << endl;
-  
+
   block_close(out);
 
   out << endl;
@@ -603,22 +603,22 @@ void t_swift_generator::generate_swift_struct_equatable_extension(ofstream& out,
                                                                   bool is_private) {
 
   string visibility = is_private ? "private" : "public";
-  
+
   indent(out) << visibility << " func ==(lhs: " << type_name(tstruct) << ", rhs: " << type_name(tstruct) << ") -> Bool";
-  
+
   block_open(out);
-  
+
   indent(out) << "return";
-  
+
   const vector<t_field*>& members = tstruct->get_members();
   vector<t_field*>::const_iterator m_iter;
 
   if (members.size()) {
-    
+
     out << endl;
-  
+
     indent_up();
-  
+
     for (m_iter = members.begin(); m_iter != members.end();) {
       t_field* tfield = *m_iter;
       indent(out) << "(lhs." << maybe_escape_identifier(tfield->get_name())
@@ -628,16 +628,16 @@ void t_swift_generator::generate_swift_struct_equatable_extension(ofstream& out,
       }
       out << endl;
     }
-  
+
     indent_down();
-    
+
   }
   else {
     out << " true" << endl;
   }
-  
+
   block_close(out);
-  
+
   out << endl;
 }
 
@@ -655,13 +655,13 @@ void t_swift_generator::generate_swift_struct_implementation(ofstream& out,
                                                              t_struct* tstruct,
                                                              bool is_result,
                                                              bool is_private) {
-  
+
   generate_swift_struct_equatable_extension(out, tstruct, is_private);
-  
+
   if (!is_private && !is_result) {
     generate_swift_struct_printable_extension(out, tstruct);
   }
-  
+
   generate_swift_struct_hashable_extension(out, tstruct, is_private);
   generate_swift_struct_thrift_extension(out, tstruct, is_result, is_private);
 
@@ -681,24 +681,24 @@ void t_swift_generator::generate_swift_struct_thrift_extension(ofstream& out,
                                                                t_struct* tstruct,
                                                                bool is_result,
                                                                bool is_private) {
-  
+
   indent(out) << "extension " << tstruct->get_name() << " : TStruct";
-  
+
   block_open(out);
-  
+
   out << endl;
-  
+
   generate_swift_struct_reader(out, tstruct, is_private);
-  
+
   if (is_result) {
     generate_swift_struct_result_writer(out, tstruct);
   }
   else {
     generate_swift_struct_writer(out, tstruct, is_private);
   }
-  
+
   block_close(out);
-  
+
   out << endl;
 }
 
@@ -713,46 +713,46 @@ void t_swift_generator::generate_swift_struct_thrift_extension(ofstream& out,
 void t_swift_generator::generate_swift_struct_reader(ofstream& out,
                                                      t_struct* tstruct,
                                                      bool is_private) {
-  
+
   string visibility = is_private ? "private" : "public";
-  
+
   indent(out) << visibility << " static func readValueFromProtocol(__proto: TProtocol) throws -> "
               << tstruct->get_name();
-  
+
   block_open(out);
-  
+
   out << endl;
-  
+
   indent(out) << "try __proto.readStructBegin()" << endl << endl;
 
   const vector<t_field*>& fields = tstruct->get_members();
   vector<t_field*>::const_iterator f_iter;
-  
+
   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
     bool optional = field_is_optional(*f_iter);
     indent(out) << "var " << maybe_escape_identifier((*f_iter)->get_name()) << " : "
                 << type_name((*f_iter)->get_type(), optional, !optional) << endl;
   }
-  
+
   out << endl;
-  
+
   // Loop over reading in fields
   indent(out) << "fields: while true";
-  
+
   block_open(out);
-  
+
   out << endl;
 
   indent(out) << "let (_, fieldType, fieldID) = try __proto.readFieldBegin()" << endl << endl;
   indent(out) << "switch (fieldID, fieldType)";
-  
+
   block_open(out);
-  
+
   indent(out) << "case (_, .STOP):" << endl;
   indent_up();
   indent(out) << "break fields" << endl << endl;
   indent_down();
-  
+
   // Generate deserialization code for known cases
   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
 
@@ -761,33 +761,33 @@ void t_swift_generator::generate_swift_struct_reader(ofstream& out,
     indent(out) << maybe_escape_identifier((*f_iter)->get_name()) << " = try __proto.readValue() as "
                 << type_name((*f_iter)->get_type()) << endl << endl;
     indent_down();
-    
+
   }
 
   indent(out) << "case let (_, unknownType):" << endl;
   indent_up();
   indent(out) << "try __proto.skipType(unknownType)" << endl;
   indent_down();
-  
+
   block_close(out);
-  
+
   out << endl;
 
   // Read field end marker
   indent(out) << "try __proto.readFieldEnd()" << endl;
-  
+
   block_close(out);
 
   out << endl;
-  
+
   indent(out) << "try __proto.readStructEnd()" << endl;
 
   out << endl;
-  
+
   if (struct_has_required_fields(tstruct)) {
     // performs various checks (e.g. check that all required fields are set)
     indent(out) << "// Required fields" << endl;
-    
+
     for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
       if (field_is_optional(*f_iter)) {
         continue;
@@ -796,9 +796,9 @@ void t_swift_generator::generate_swift_struct_reader(ofstream& out,
                   << "named: \"" << (*f_iter)->get_name() << "\")" << endl;
     }
   }
-  
+
   out << endl;
-    
+
   indent(out) << "return " << tstruct->get_name() << "(";
   for (f_iter = fields.begin(); f_iter != fields.end();) {
     out << (*f_iter)->get_name() << ": " << maybe_escape_identifier((*f_iter)->get_name());
@@ -824,13 +824,13 @@ void t_swift_generator::generate_swift_struct_reader(ofstream& out,
 void t_swift_generator::generate_swift_struct_writer(ofstream& out,
                                                      t_struct* tstruct,
                                                      bool is_private) {
-  
+
   string visibility = is_private ? "private" : "public";
-  
+
   indent(out) << visibility << " static func writeValue(__value: " << tstruct->get_name() << ", toProtocol __proto: TProtocol) throws";
-  
+
   block_open(out);
-  
+
   out << endl;
 
   string name = tstruct->get_name();
@@ -838,19 +838,19 @@ void t_swift_generator::generate_swift_struct_writer(ofstream& out,
   vector<t_field*>::const_iterator f_iter;
 
   indent(out) << "try __proto.writeStructBeginWithName(\"" << name << "\")" << endl;
-  
+
   out << endl;
-  
+
   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
     t_field *tfield = *f_iter;
-    
+
     bool optional = field_is_optional(tfield);
     if (optional) {
       indent(out) << "if let " << maybe_escape_identifier(tfield->get_name())
                   << " = __value." << maybe_escape_identifier(tfield->get_name());
       block_open(out);
     }
-    
+
     indent(out) << "try __proto.writeFieldValue("
                 << (optional ? "" : "__value.") << maybe_escape_identifier(tfield->get_name()) << ", "
                 << "name: \"" << tfield->get_name() << "\", "
@@ -865,7 +865,7 @@ void t_swift_generator::generate_swift_struct_writer(ofstream& out,
   }
 
   indent(out) << "try __proto.writeFieldStop()" << endl << endl;
-  
+
   indent(out) << "try __proto.writeStructEnd()" << endl;
 
   block_close(out);
@@ -883,28 +883,28 @@ void t_swift_generator::generate_swift_struct_writer(ofstream& out,
  * @param tstruct The structure definition
  */
 void t_swift_generator::generate_swift_struct_result_writer(ofstream& out, t_struct* tstruct) {
-  
+
   indent(out) << "private static func writeValue(__value: " << tstruct->get_name() << ", toProtocol __proto: TProtocol) throws";
-  
+
   block_open(out);
-  
+
   out << endl;
-  
+
   string name = tstruct->get_name();
   const vector<t_field*>& fields = tstruct->get_members();
   vector<t_field*>::const_iterator f_iter;
-  
+
   indent(out) << "try __proto.writeStructBeginWithName(\"" << name << "\")" << endl;
-  
+
   out << endl;
-  
+
   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
     t_field *tfield = *f_iter;
-    
+
     indent(out) << "if let result = __value." << (*f_iter)->get_name();
-    
+
     block_open(out);
-    
+
     indent(out) << "try __proto.writeFieldValue(result, "
                 << "name: \"" << tfield->get_name() << "\", "
                 << "type: " << type_to_enum(tfield->get_type()) << ", "
@@ -914,11 +914,11 @@ void t_swift_generator::generate_swift_struct_result_writer(ofstream& out, t_str
   }
   // Write the struct map
   indent(out) << "try __proto.writeFieldStop()" << endl << endl;
-  
+
   indent(out) << "try __proto.writeStructEnd()" << endl;
 
   block_close(out);
-  
+
   out << endl;
 }
 
@@ -928,22 +928,22 @@ void t_swift_generator::generate_swift_struct_result_writer(ofstream& out, t_str
  * @param tstruct The struct definition
  */
 void t_swift_generator::generate_swift_struct_printable_extension(ofstream& out, t_struct* tstruct) {
-  
+
   // Allow use of debugDescription so the app can add description via a cateogory/extension
 
   indent(out) << "extension " << tstruct->get_name() << " : "
               << (debug_descriptions_ ? "CustomDebugStringConvertible" : "CustomStringConvertible");
 
   block_open(out);
-  
+
   out << endl;
-  
+
   indent(out) << "public var description : String";
-  
+
   block_open(out);
-  
+
   indent(out) << "var desc = \"" << tstruct->get_name() << "(\"" << endl;
-  
+
   const vector<t_field*>& fields = tstruct->get_members();
   vector<t_field*>::const_iterator f_iter;
 
@@ -959,11 +959,11 @@ void t_swift_generator::generate_swift_struct_printable_extension(ofstream& out,
   indent(out) << "return desc" << endl;
 
   block_close(out);
-  
+
   out << endl;
-  
+
   block_close(out);
-  
+
   out << endl;
 }
 
@@ -975,7 +975,7 @@ void t_swift_generator::generate_swift_struct_printable_extension(ofstream& out,
  * @param tservice The service definition
  */
 void t_swift_generator::generate_service(t_service* tservice) {
-  
+
   generate_swift_service_protocol(f_decl_, tservice);
   generate_swift_service_client(f_decl_, tservice);
   if (async_clients_) {
@@ -985,7 +985,7 @@ void t_swift_generator::generate_service(t_service* tservice) {
   generate_swift_service_server(f_decl_, tservice);
 
   generate_swift_service_helpers(tservice);
-  
+
   generate_swift_service_client_implementation(f_impl_, tservice);
   if (async_clients_) {
     generate_swift_service_client_async_implementation(f_impl_, tservice);
@@ -1002,11 +1002,11 @@ void t_swift_generator::generate_swift_service_helpers(t_service* tservice) {
   vector<t_function*> functions = tservice->get_functions();
   vector<t_function*>::iterator f_iter;
   for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
-    
+
     t_struct* ts = (*f_iter)->get_arglist();
-    
+
     string qname = function_args_helper_struct_type(tservice, *f_iter);
-    
+
     t_struct qname_ts = t_struct(ts->get_program(), qname);
 
     const vector<t_field*>& members = ts->get_members();
@@ -1014,7 +1014,7 @@ void t_swift_generator::generate_swift_service_helpers(t_service* tservice) {
     for (m_iter = members.begin(); m_iter != members.end(); ++m_iter) {
       qname_ts.append(*m_iter);
     }
-    
+
     generate_swift_struct(f_impl_, &qname_ts, true);
     generate_swift_struct_implementation(f_impl_, &qname_ts, false, true);
     generate_function_helpers(tservice, *f_iter);
@@ -1065,7 +1065,7 @@ void t_swift_generator::generate_function_helpers(t_service *tservice, t_functio
   // generate the result struct
   generate_swift_struct(f_impl_, &result, true);
   generate_swift_struct_implementation(f_impl_, &result, true, true);
-  
+
   for (f_iter = result.get_members().begin(); f_iter != result.get_members().end(); ++f_iter) {
     delete *f_iter;
   }
@@ -1081,10 +1081,10 @@ void t_swift_generator::generate_swift_service_protocol(ofstream& out, t_service
   indent(out) << "public protocol " << tservice->get_name();
 
   block_open(out);
-  
+
   vector<t_function*> functions = tservice->get_functions();
   vector<t_function*>::iterator f_iter;
-  
+
   for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
     out << endl;
     indent(out) << function_signature(*f_iter) << "  // exceptions: ";
@@ -1096,9 +1096,9 @@ void t_swift_generator::generate_swift_service_protocol(ofstream& out, t_service
     }
     out << endl;
   }
-  
+
   block_close(out);
-  
+
   out << endl;
 }
 
@@ -1108,14 +1108,14 @@ void t_swift_generator::generate_swift_service_protocol(ofstream& out, t_service
  * @param tservice The service to generate a protocol definition for
  */
 void t_swift_generator::generate_swift_service_protocol_async(ofstream& out, t_service* tservice) {
-  
+
   indent(out) << "public protocol " << tservice->get_name() << "Async";
 
   block_open(out);
-  
+
   vector<t_function*> functions = tservice->get_functions();
   vector<t_function*>::iterator f_iter;
-  
+
   for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
     out << endl;
     indent(out) << async_function_signature(*f_iter) << endl;
@@ -1124,9 +1124,9 @@ void t_swift_generator::generate_swift_service_protocol_async(ofstream& out, t_s
     }
     out << endl;
   }
-  
+
   block_close(out);
-  
+
   out << endl;
 }
 
@@ -1137,43 +1137,43 @@ void t_swift_generator::generate_swift_service_protocol_async(ofstream& out, t_s
  */
 void t_swift_generator::generate_swift_service_client(ofstream& out,
                                                                 t_service* tservice) {
-  
+
   indent(out) << "public class " << tservice->get_name() << "Client /* : " << tservice->get_name() << " */";
-  
+
   block_open(out);
-  
+
   out << endl;
 
   indent(out) << "let __inProtocol : TProtocol" << endl << endl;
-  
+
   indent(out) << "let __outProtocol : TProtocol" << endl << endl;
-  
+
   indent(out) << "public init(inoutProtocol: TProtocol)";
-  
+
   block_open(out);
-  
+
   indent(out) << "__inProtocol = inoutProtocol" << endl;
-         
+
   indent(out) << "__outProtocol = inoutProtocol" << endl;
-                
+
   block_close(out);
-  
+
   out << endl;
-  
+
   indent(out) << "public init(inProtocol: TProtocol, outProtocol: TProtocol)";
-  
+
   block_open(out);
-  
+
   indent(out) << "__inProtocol = inProtocol" << endl;
-  
+
   indent(out) << "__outProtocol = outProtocol" << endl;
-  
+
   block_close(out);
-  
+
   out << endl;
-  
+
   block_close(out);
-  
+
   out << endl;
 }
 
@@ -1184,49 +1184,49 @@ void t_swift_generator::generate_swift_service_client(ofstream& out,
  */
 void t_swift_generator::generate_swift_service_client_async(ofstream& out,
                                                                       t_service* tservice) {
-  
+
   indent(out) << "public class " << tservice->get_name() << "AsyncClient /* : " << tservice->get_name() << " */";
-  
+
   block_open(out);
-  
+
   out << endl;
-  
+
   indent(out) << "let __protocolFactory : TProtocolFactory" << endl << endl;
-  
+
   indent(out) << "let __transportFactory : TAsyncTransportFactory" << endl << endl;
-  
+
   indent(out) << "public init(protocolFactory: TProtocolFactory, transportFactory: TAsyncTransportFactory)";
-  
+
   block_open(out);
-  
+
   indent(out) << "__protocolFactory = protocolFactory" << endl;
-  
+
   indent(out) << "__transportFactory = transportFactory" << endl;
-  
+
   block_close(out);
-  
+
   out << endl;
-  
+
   block_close(out);
-  
+
   out << endl;
 }
 
 /**
- * Generates a service server interface definition. In other words, 
+ * Generates a service server interface definition. In other words,
  * the TProcess implementation for the service definition.
  *
  * @param tservice The service to generate a client interface definition for
  */
 void t_swift_generator::generate_swift_service_server(ofstream& out,
                                                                 t_service* tservice) {
-  
+
   indent(out) << "public class " << tservice->get_name() << "Processor : NSObject /* " << tservice->get_name() << " */";
 
   block_open(out);
-  
+
   out << endl;
-  
+
   out << indent() << "typealias ProcessorHandlerDictionary = "
                   << "[String: (Int, TProtocol, TProtocol, " << tservice->get_name() << ") throws -> Void]" << endl
       << endl
@@ -1240,7 +1240,7 @@ void t_swift_generator::generate_swift_service_server(ofstream& out,
   out << endl;
 
   block_close(out);
-  
+
   out << endl;
 }
 
@@ -1258,7 +1258,7 @@ void t_swift_generator::generate_swift_service_client_send_function_implementati
                                                                                    t_service *tservice,
                                                                                    t_function* tfunction,
                                                                                    bool needs_protocol) {
-  
+
   string funname = tfunction->get_name();
 
   t_function send_function(g_type_bool,
@@ -1267,11 +1267,11 @@ void t_swift_generator::generate_swift_service_client_send_function_implementati
 
   string argsname = function_args_helper_struct_type(tservice, tfunction);
   t_struct* arg_struct = tfunction->get_arglist();
-  
+
   // Open function
   indent(out) << "private func " << send_function.get_name() << "(" << argument_list(tfunction->get_arglist(), needs_protocol ? "__outProtocol" : "", true) << ") throws";
   block_open(out);
-  
+
   out << endl;
 
   // Serialize the request
@@ -1280,14 +1280,14 @@ void t_swift_generator::generate_swift_service_client_send_function_implementati
               << "sequenceID: 0)" << endl;
 
   out << endl;
-  
+
   indent(out) << "let __args = " << argsname << "(";
-  
+
   // write out function parameters
-  
+
   const vector<t_field*>& fields = arg_struct->get_members();
   vector<t_field*>::const_iterator f_iter;
-  
+
   for (f_iter = fields.begin(); f_iter != fields.end();) {
     t_field *tfield = (*f_iter);
     out << tfield->get_name() << ": " << tfield->get_name();
@@ -1297,11 +1297,11 @@ void t_swift_generator::generate_swift_service_client_send_function_implementati
   }
   out << ")" << endl;
   indent(out) << "try " << argsname << ".writeValue(__args, toProtocol: __outProtocol)" << endl << endl;
-  
+
   indent(out) << "try __outProtocol.writeMessageEnd()" << endl;
 
   block_close(out);
-  
+
   out << endl;
 }
 
@@ -1319,35 +1319,35 @@ void t_swift_generator::generate_swift_service_client_recv_function_implementati
                                                                                    t_service* tservice,
                                                                                    t_function* tfunction,
                                                                                    bool needs_protocol) {
-  
+
   // Open function
   indent(out) << "private func recv_" << tfunction->get_name() << "(";
-  
+
   if (needs_protocol) {
     out << "__inProtocol: TProtocol";
   }
-  
+
   out << ") throws";
-  
+
   if (!tfunction->get_returntype()->is_void()) {
     out << " -> " << type_name(tfunction->get_returntype());
   }
-  
+
   block_open(out);
 
   // check for an exception
-  
+
   out << endl;
-  
+
   indent(out) << "try __inProtocol.readResultMessageBegin() " << endl << endl;
-  
+
   string resultname = function_result_helper_struct_type(tservice, tfunction);
   indent(out);
   if (!tfunction->get_returntype()->is_void() || !tfunction->get_xceptions()->get_members().empty()) {
     out << "let __result = ";
   }
   out << "try " << resultname << ".readValueFromProtocol(__inProtocol)" << endl << endl;
-  
+
   indent(out) << "try __inProtocol.readMessageEnd()" << endl << endl;
 
   // Careful, only return _result if not a void function
@@ -1361,7 +1361,7 @@ void t_swift_generator::generate_swift_service_client_recv_function_implementati
   t_struct* xs = tfunction->get_xceptions();
   const vector<t_field*>& xceptions = xs->get_members();
   vector<t_field*>::const_iterator x_iter;
-  
+
   for (x_iter = xceptions.begin(); x_iter != xceptions.end(); ++x_iter) {
     indent(out) << "if let " << (*x_iter)->get_name() << " = __result." << (*x_iter)->get_name();
     block_open(out);
@@ -1381,7 +1381,7 @@ void t_swift_generator::generate_swift_service_client_recv_function_implementati
 
   // Close function
   block_close(out);
-  
+
   out << endl;
 }
 
@@ -1393,21 +1393,21 @@ void t_swift_generator::generate_swift_service_client_recv_function_implementati
  */
 void t_swift_generator::generate_swift_service_client_send_function_invocation(ofstream& out,
                                                                                t_function* tfunction) {
-  
+
   indent(out) << "try send_" << tfunction->get_name() << "(";
-  
+
   t_struct* arg_struct = tfunction->get_arglist();
-  
+
   const vector<t_field*>& fields = arg_struct->get_members();
   vector<t_field*>::const_iterator f_iter;
-  
+
   for (f_iter = fields.begin(); f_iter != fields.end();) {
     out << (*f_iter)->get_name() << ": " << (*f_iter)->get_name();
     if (++f_iter != fields.end()) {
       out << ", ";
     }
   }
-  
+
   out << ")" << endl;
 }
 
@@ -1419,17 +1419,17 @@ void t_swift_generator::generate_swift_service_client_send_function_invocation(o
  */
 void t_swift_generator::generate_swift_service_client_send_async_function_invocation(ofstream& out,
                                                                                      t_function* tfunction) {
-  
+
   t_struct* arg_struct = tfunction->get_arglist();
   const vector<t_field*>& fields = arg_struct->get_members();
   vector<t_field*>::const_iterator f_iter;
-  
+
   indent(out) << "try send_" << tfunction->get_name() << "(__protocol";
-  
+
   for (f_iter = fields.begin(); f_iter != fields.end(); ++f_iter) {
     out << ", " << (*f_iter)->get_name() << ": " << (*f_iter)->get_name();
   }
-  
+
   out << ")" << endl;
 }
 
@@ -1440,15 +1440,15 @@ void t_swift_generator::generate_swift_service_client_send_async_function_invoca
  */
 void t_swift_generator::generate_swift_service_client_implementation(ofstream& out,
                                                                      t_service* tservice) {
-  
+
   string name = tservice->get_name() + "Client";
-  
+
   indent(out) << "extension " << name << " : " << tservice->get_name();
-  
+
   block_open(out);
-  
+
   out << endl;
-  
+
   // generate client method implementations
   vector<t_function*> functions = tservice->get_functions();
   vector<t_function*>::const_iterator f_iter;
@@ -1462,17 +1462,17 @@ void t_swift_generator::generate_swift_service_client_implementation(ofstream& o
 
     // Open function
     indent(out) << "public " << function_signature(*f_iter);
-    
+
     block_open(out);
-    
+
     out << endl;
-    
+
     generate_swift_service_client_send_function_invocation(out, *f_iter);
 
     out << endl;
 
     indent(out) << "try __outProtocol.transport().flush()" << endl << endl;
-    
+
     if (!(*f_iter)->is_oneway()) {
       if ((*f_iter)->get_returntype()->is_void()) {
         indent(out) << "try recv_" << (*f_iter)->get_name() << "()" << endl;
@@ -1480,14 +1480,14 @@ void t_swift_generator::generate_swift_service_client_implementation(ofstream& o
         indent(out) << "return try recv_" << (*f_iter)->get_name() << "()" << endl;
       }
     }
-    
+
     block_close(out);
-    
+
     out << endl;
   }
 
   block_close(out);
-  
+
   out << endl;
 }
 
@@ -1498,16 +1498,16 @@ void t_swift_generator::generate_swift_service_client_implementation(ofstream& o
  */
 void t_swift_generator::generate_swift_service_client_async_implementation(ofstream& out,
                                                                            t_service* tservice) {
-  
+
   string name = tservice->get_name() + "AsyncClient";
   string protocol_name = tservice->get_name() + "Async";
 
   indent(out) << "extension " << name << " : " << protocol_name;
-  
+
   block_open(out);
-  
+
   out << endl;
-  
+
   // generate client method implementations
   vector<t_function*> functions = tservice->get_functions();
   vector<t_function*>::const_iterator f_iter;
@@ -1518,10 +1518,10 @@ void t_swift_generator::generate_swift_service_client_async_implementation(ofstr
     if (!(*f_iter)->is_oneway()) {
       generate_swift_service_client_recv_function_implementation(out, tservice, *f_iter, true);
     }
-    
+
     indent(out) << "public " << async_function_signature(*f_iter);
     block_open(out);
-    
+
     out << endl;
 
     out << indent() << "let __transport = __transportFactory.newTransport()" << endl
@@ -1529,11 +1529,11 @@ void t_swift_generator::generate_swift_service_client_async_implementation(ofstr
         << endl;
 
     generate_swift_service_client_send_async_function_invocation(out, *f_iter);
-    
+
     out << endl;
-    
+
     indent(out) << "__transport.flushWithCompletion(";
-    
+
     if ((*f_iter)->is_oneway()) {
       out << "success, failure: failure)" << endl;
     }
@@ -1547,13 +1547,13 @@ void t_swift_generator::generate_swift_service_client_async_implementation(ofstr
         out << "let result = ";
       }
       out << "try self.recv_" << (*f_iter)->get_name() << "(__protocol)" << endl;
-      
+
       out << indent() << "success(";
       if (!(*f_iter)->get_returntype()->is_void()) {
         out << "result";
       }
       out << ")" << endl;
-      
+
       block_close(out);
       indent(out) << "catch let error";
       block_open(out);
@@ -1562,29 +1562,29 @@ void t_swift_generator::generate_swift_service_client_async_implementation(ofstr
       block_close(out);
       indent(out) << ", failure: failure)" << endl;
     }
-    
-    
+
+
     block_close(out);
-    
+
     out << endl;
 
     // Promise function
     if (promise_kit_) {
-      
+
       indent(out) << "public " << promise_function_signature(*f_iter);
       block_open(out);
-      
+
       out << indent() << "let (__promise, __fulfill, __reject) = Promise<" << type_name((*f_iter)->get_returntype()) << ">.pendingPromise()" << endl << endl
           << indent() << "let __transport = __transportFactory.newTransport()" << endl
           << indent() << "let __protocol = __protocolFactory.newProtocolOnTransport(__transport)" << endl
           << endl;
-      
+
       generate_swift_service_client_send_async_function_invocation(out, *f_iter);
-      
+
       out << endl;
-      
+
       indent(out) << "__transport.flushWithCompletion(";
-      
+
       if ((*f_iter)->is_oneway()) {
         out << "{ __fulfill() }, failure: { __reject($0) })" << endl;
       }
@@ -1592,26 +1592,26 @@ void t_swift_generator::generate_swift_service_client_async_implementation(ofstr
         block_open(out);
         indent(out) << "do";
         block_open(out);
-        
+
         indent(out);
         if (!(*f_iter)->get_returntype()->is_void()) {
           out << "let result = ";
         }
         out << "try self.recv_" << (*f_iter)->get_name() << "(__protocol)" << endl;
-        
+
         out << indent() << "__fulfill(";
         if (!(*f_iter)->get_returntype()->is_void()) {
           out << "result";
         }
         out << ")" << endl;
-        
+
         block_close(out);
         indent(out) << "catch let error";
         block_open(out);
         indent(out) << "__reject(error)" << endl;
         block_close(out);
         block_close(out);
-        
+
         indent(out) << ", failure: { error in " << endl;
         indent_up();
         indent(out) << "__reject(error)" << endl;
@@ -1622,11 +1622,11 @@ void t_swift_generator::generate_swift_service_client_async_implementation(ofstr
       indent(out) << "return __promise" << endl;
 
       block_close(out);
-      
+
       out << endl;
-      
+
     }
-    
+
   }
 
   block_close(out);
@@ -1645,52 +1645,52 @@ void t_swift_generator::generate_swift_service_client_async_implementation(ofstr
  */
 void t_swift_generator::generate_swift_service_server_implementation(ofstream& out,
                                                                      t_service* tservice) {
-  
+
   string name = tservice->get_name() + "Processor";
 
   indent(out) << "extension " << name << " : TProcessor";
   block_open(out);
-  
+
   out << endl;
-  
+
   indent(out) << "static let processorHandlers : ProcessorHandlerDictionary =";
   block_open(out);
-  
+
   out << endl;
-  
+
   out << indent() << "var processorHandlers = ProcessorHandlerDictionary()" << endl << endl;
-  
+
   // generate method map for routing incoming calls
   vector<t_function*> functions = tservice->get_functions();
   vector<t_function*>::const_iterator f_iter;
   for (f_iter = functions.begin(); f_iter != functions.end(); ++f_iter) {
-    
+
     t_function* tfunction = *f_iter;
-    
+
     string args_type = function_args_helper_struct_type(tservice, *f_iter);
-    
+
     out << indent() << "processorHandlers[\"" << tfunction->get_name() << "\"] = { sequenceID, inProtocol, outProtocol, handler in" << endl
         << endl;
-    
+
     indent_up();
     out << indent() << "let args = try " << args_type << ".readValueFromProtocol(inProtocol)" << endl
         << endl
         << indent() << "try inProtocol.readMessageEnd()" << endl
         << endl;
-    
+
     if (!tfunction->is_oneway() ) {
       string result_type = function_result_helper_struct_type(tservice, tfunction);
       indent(out) << "var result = " << result_type << "()" << endl;
-    
+
       indent(out) << "do";
       block_open(out);
-    
+
       indent(out);
       if (!tfunction->get_returntype()->is_void()) {
         out << "result.success = ";
       }
       out << "try handler." << function_name(tfunction) << "(";
-    
+
       t_struct* arg_struct = tfunction->get_arglist();
       const vector<t_field*>& fields = arg_struct->get_members();
       vector<t_field*>::const_iterator f_iter;
@@ -1705,29 +1705,29 @@ void t_swift_generator::generate_swift_service_server_implementation(ofstream& o
           out << ", ";
         }
       }
-      
+
       out << ")" << endl;
-      
+
       block_close(out);
-      
+
       t_struct* xs = tfunction->get_xceptions();
       const vector<t_field*>& xfields = xs->get_members();
       vector<t_field*>::const_iterator x_iter;
-      
+
       for (x_iter = xfields.begin(); x_iter != xfields.end(); ++x_iter) {
         indent(out) << "catch let error as " << (*x_iter)->get_type()->get_name();
         block_open(out);
         indent(out) << "result." << (*x_iter)->get_name() << " = error" << endl;
         block_close(out);
       }
-      
+
       indent(out) << "catch let error";
       block_open(out);
       out << indent() << "throw error" << endl;
       block_close(out);
-      
+
       out << endl;
-      
+
       if (!tfunction->is_oneway()) {
         out << indent() << "try outProtocol.writeMessageBeginWithName(\"" << tfunction->get_name() << "\", type: .REPLY, sequenceID: sequenceID)" << endl
             << indent() << "try " << result_type << ".writeValue(result, toProtocol: outProtocol)" << endl
@@ -1735,21 +1735,21 @@ void t_swift_generator::generate_swift_service_server_implementation(ofstream& o
       }
     }
     block_close(out);
-    
+
   }
-  
+
   indent(out) << "return processorHandlers" << endl;
-  
+
   block_close(out,false);
   out << "()" << endl;
-  
+
   out << endl;
-  
+
   indent(out) << "public func processOnInputProtocol(inProtocol: TProtocol, outputProtocol outProtocol: TProtocol) throws";
   block_open(out);
-  
+
   out << endl;
-  
+
   out << indent() << "let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()" << endl
       << endl
       << indent() << "if let processorHandler = " << name << ".processorHandlers[messageName]";
@@ -1778,9 +1778,9 @@ void t_swift_generator::generate_swift_service_server_implementation(ofstream& o
   indent_down();
   indent_down();
   block_close(out);
-  
+
   block_close(out);
-  
+
   block_close(out);
   out << endl;
 }
@@ -1809,15 +1809,15 @@ string t_swift_generator::type_name(t_type* ttype, bool is_optional, bool is_for
   else {
     result = ttype->get_name();
   }
-  
+
   if (is_optional) {
     result += "?";
   }
-  
+
   if (is_forced) {
     result += "!";
   }
-  
+
   return result;
 }
 
@@ -1863,7 +1863,7 @@ void t_swift_generator::render_const_value(ostream& out,
                                              t_type* type,
                                              t_const_value* value) {
   type = get_true_type(type);
-  
+
   if (type->is_base_type()) {
     t_base_type::t_base tbase = ((t_base_type*)type)->get_base();
     switch (tbase) {
@@ -1894,12 +1894,12 @@ void t_swift_generator::render_const_value(ostream& out,
   } else if (type->is_enum()) {
     out << value->get_identifier();
   } else if (type->is_struct() || type->is_xception()) {
-    
+
     out << type_name(type) << "(";
-    
+
     const vector<t_field*>& fields = ((t_struct*)type)->get_members();
     vector<t_field*>::const_iterator f_iter;
-    
+
     const map<t_const_value*, t_const_value*>& val = value->get_map();
     map<t_const_value*, t_const_value*>::const_iterator v_iter;
 
@@ -1911,7 +1911,7 @@ void t_swift_generator::render_const_value(ostream& out,
           value = v_iter->second;
         }
       }
-      
+
       if (value) {
         out << tfield->get_name() << ": ";
         render_const_value(out, tfield->get_type(), value);
@@ -1919,18 +1919,18 @@ void t_swift_generator::render_const_value(ostream& out,
       else if (!field_is_optional(tfield)) {
         throw "constant error: required field " + type->get_name() + "." + tfield->get_name() + " has no value";
       }
-      
+
       if (++f_iter != fields.end()) {
         out << ", ";
       }
     }
-    
+
     out << ")";
-    
+
   } else if (type->is_map()) {
-    
+
     out << "[";
-    
+
     t_type* ktype = ((t_map*)type)->get_key_type();
     t_type* vtype = ((t_map*)type)->get_val_type();
 
@@ -1938,58 +1938,58 @@ void t_swift_generator::render_const_value(ostream& out,
     map<t_const_value*, t_const_value*>::const_iterator v_iter;
 
     for (v_iter = val.begin(); v_iter != val.end();) {
-    
+
       render_const_value(out, ktype, v_iter->first);
       out << ": ";
       render_const_value(out, vtype, v_iter->second);
-      
+
       if (++v_iter != val.end()) {
         out << ", ";
       }
     }
-    
+
     out << "]";
-    
+
   } else if (type->is_list()) {
-    
+
     out << "[";
-    
+
     t_type* etype = ((t_list*)type)->get_elem_type();
-    
+
     const map<t_const_value*, t_const_value*>& val = value->get_map();
     map<t_const_value*, t_const_value*>::const_iterator v_iter;
-    
+
     for (v_iter = val.begin(); v_iter != val.end();) {
-      
+
       render_const_value(out, etype, v_iter->first);
-      
+
       if (++v_iter != val.end()) {
         out << ", ";
       }
     }
-    
+
     out << "]";
 
   } else if (type->is_set()) {
 
     out << "[";
-    
+
     t_type* etype = ((t_set*)type)->get_elem_type();
-    
+
     const map<t_const_value*, t_const_value*>& val = value->get_map();
     map<t_const_value*, t_const_value*>::const_iterator v_iter;
-    
+
     for (v_iter = val.begin(); v_iter != val.end();) {
-      
+
       render_const_value(out, etype, v_iter->first);
-      
+
       if (++v_iter != val.end()) {
         out << ", ";
       }
     }
-    
+
     out << "]";
-    
+
   } else {
     throw "compiler error: no const of type " + type->get_name();
   }
@@ -2002,20 +2002,20 @@ void t_swift_generator::render_const_value(ostream& out,
  * @param tfield The field to declare a property for
  */
 string t_swift_generator::declare_property(t_field* tfield, bool is_private) {
-  
+
   string visibility = is_private ? "private" : "public";
-  
+
   ostringstream render;
 
   render << visibility << " var " << maybe_escape_identifier(tfield->get_name());
-  
+
   if (field_is_optional(tfield)) {
     render << " : " << type_name(tfield->get_type(), true);
   }
   else {
     render << " = " << type_name(tfield->get_type(), false) << "()";
   }
-  
+
   return render.str();
 }
 
@@ -2026,16 +2026,16 @@ string t_swift_generator::declare_property(t_field* tfield, bool is_private) {
  * @return String of rendered function definition
  */
 string t_swift_generator::function_signature(t_function* tfunction) {
-  
+
   string result = "func " + function_name(tfunction);
-  
+
   result += "(" + argument_list(tfunction->get_arglist(), "", false) + ") throws";
-  
+
   t_type* ttype = tfunction->get_returntype();
   if (!ttype->is_void()) {
     result += " -> " + type_name(ttype);
   }
-  
+
   return result;
 }
 
@@ -2092,7 +2092,7 @@ string t_swift_generator::argument_list(t_struct* tstruct, string protocol_name,
 
   const vector<t_field*>& fields = tstruct->get_members();
   vector<t_field*>::const_iterator f_iter;
-  
+
   if (include_protocol) {
     result += protocol_name + ": TProtocol";
     if (!fields.empty()) {
@@ -2103,11 +2103,11 @@ string t_swift_generator::argument_list(t_struct* tstruct, string protocol_name,
     // Force first argument to be named
     result += fields.front()->get_name() + " ";
   }
-  
+
   for (f_iter = fields.begin(); f_iter != fields.end();) {
     t_field* arg = *f_iter;
     result += arg->get_name() + ": " + type_name(arg->get_type());
-    
+
     if (++f_iter != fields.end()) {
       result += ", ";
     }
@@ -2160,7 +2160,7 @@ string t_swift_generator::maybe_escape_identifier(const string& identifier) {
  */
 string t_swift_generator::type_to_enum(t_type* type, bool qualified) {
   type = get_true_type(type);
-  
+
   string result = qualified ? "TType." : ".";
 
   if (type->is_base_type()) {
diff --git a/compiler/cpp/src/generate/t_xml_generator.cc b/compiler/cpp/src/thrift/generate/t_xml_generator.cc
similarity index 98%
rename from compiler/cpp/src/generate/t_xml_generator.cc
rename to compiler/cpp/src/thrift/generate/t_xml_generator.cc
index 5465b49f78e..b35f35107ea 100644
--- a/compiler/cpp/src/generate/t_xml_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_xml_generator.cc
@@ -26,8 +26,8 @@
 #include <sys/stat.h>
 #include <sstream>
 
-#include "t_generator.h"
-#include "platform.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -72,7 +72,7 @@ class t_xml_generator : public t_generator {
       } else if( iter->first.compare("no_namespaces") == 0) {
         should_use_namespaces_ = false;
       } else {
-        throw "unknown option xml:" + iter->first; 
+        throw "unknown option xml:" + iter->first;
       }
     }
 
@@ -102,7 +102,7 @@ class t_xml_generator : public t_generator {
   bool should_use_namespaces_;
 
   std::ofstream f_xml_;
- 
+
   std::set<string> programs_;
   std::stack<string> elements_;
   bool top_element_is_empty;
@@ -188,8 +188,8 @@ void t_xml_generator::write_xml_comment(string msg) {
   close_top_element();
   // TODO: indent any EOLs that may occur with msg
   // TODO: proper msg escaping needed?
-  f_xml_ << indent() << "<!-- " << msg << " -->"  << endl;  
-  top_element_is_empty = false;  
+  f_xml_ << indent() << "<!-- " << msg << " -->"  << endl;
+  top_element_is_empty = false;
 }
 
 void t_xml_generator::close_top_element() {
@@ -238,7 +238,7 @@ void t_xml_generator::write_element_string(string name, string val) {
   }
   close_top_element();
   top_element_is_empty = false;
-  f_xml_ << indent() 
+  f_xml_ << indent()
     << "<" << name << ">" << escape_xml_string(val) << "</" << name << ">"
     << endl;
 }
@@ -287,9 +287,9 @@ void t_xml_generator::generate_program() {
   }
 
   write_xml_comment( xml_autogen_comment());
-  
+
   iterate_program(program_);
-  
+
   write_element_end();
 
   close_generator();
@@ -297,7 +297,7 @@ void t_xml_generator::generate_program() {
 }
 
 void t_xml_generator::iterate_program(t_program* program) {
-  
+
   write_element_start("document");
   write_attribute("name", program->get_name());
   if (should_use_namespaces_) {
@@ -548,7 +548,7 @@ void t_xml_generator::generate_struct(t_struct* tstruct) {
   }
 
   generate_annotations(tstruct->annotations_);
- 
+
   write_element_end();
 
 }
@@ -556,7 +556,7 @@ void t_xml_generator::generate_struct(t_struct* tstruct) {
 void t_xml_generator::generate_field(t_field* field) {
   write_attribute("name", field->get_name());
   write_int_attribute("field-id", field->get_key());
-  write_doc(field); 
+  write_doc(field);
   string requiredness;
   switch (field->get_req()) {
   case t_field::T_REQUIRED:
@@ -582,7 +582,7 @@ void t_xml_generator::generate_field(t_field* field) {
 }
 
 void t_xml_generator::generate_service(t_service* tservice) {
- 
+
   write_element_start("service");
   write_attribute("name", tservice->get_name());
 
@@ -595,7 +595,7 @@ void t_xml_generator::generate_service(t_service* tservice) {
     write_attribute("targetNamespace", tns);
     write_attribute("xmlns:tns", tns);
   }
- 
+
   if (tservice->get_extends()) {
     const t_service* extends = tservice->get_extends();
     write_attribute("parent-module", extends->get_program()->get_name());
@@ -609,15 +609,15 @@ void t_xml_generator::generate_service(t_service* tservice) {
   for (; fn_iter != functions.end(); fn_iter++) {
     generate_function(*fn_iter);
   }
-  
+
   generate_annotations(tservice->annotations_);
-  
+
   write_element_end();
 
 }
 
 void t_xml_generator::generate_function(t_function* tfunc) {
- 
+
   write_element_start("method");
 
   write_attribute("name", tfunc->get_name());
@@ -638,7 +638,7 @@ void t_xml_generator::generate_function(t_function* tfunc) {
     generate_field(*mem_iter);
     write_element_end();
   }
- 
+
   vector<t_field*> excepts = tfunc->get_xceptions()->get_members();
   vector<t_field*>::iterator ex_iter = excepts.begin();
   for (; ex_iter != excepts.end(); ex_iter++) {
@@ -648,7 +648,7 @@ void t_xml_generator::generate_function(t_function* tfunc) {
   }
 
   generate_annotations(tfunc->annotations_);
-  
+
   write_element_end();
 
 }
@@ -663,9 +663,9 @@ string t_xml_generator::get_type_name(t_type* ttype) {
   if (ttype->is_map()) {
     return "map";
   }
-  if ((ttype->is_enum()    )|| 
-      (ttype->is_struct()  )|| 
-      (ttype->is_typedef() )|| 
+  if ((ttype->is_enum()    )||
+      (ttype->is_struct()  )||
+      (ttype->is_typedef() )||
       (ttype->is_xception())){
     return "id";
   }
diff --git a/compiler/cpp/src/generate/t_xsd_generator.cc b/compiler/cpp/src/thrift/generate/t_xsd_generator.cc
similarity index 98%
rename from compiler/cpp/src/generate/t_xsd_generator.cc
rename to compiler/cpp/src/thrift/generate/t_xsd_generator.cc
index 2de860a39f5..fa51ba0a871 100644
--- a/compiler/cpp/src/generate/t_xsd_generator.cc
+++ b/compiler/cpp/src/thrift/generate/t_xsd_generator.cc
@@ -24,9 +24,9 @@
 #include <stdlib.h>
 #include <sys/stat.h>
 #include <sstream>
-#include "t_generator.h"
-#include "version.h"
-#include "platform.h"
+#include "thrift/version.h"
+#include "thrift/platform.h"
+#include "thrift/generate/t_generator.h"
 
 using std::map;
 using std::ofstream;
@@ -53,7 +53,7 @@ class t_xsd_generator : public t_generator {
 
     /* no options yet */
     for( iter = parsed_options.begin(); iter != parsed_options.end(); ++iter) {
-      throw "unknown option xsd:" + iter->first; 
+      throw "unknown option xsd:" + iter->first;
     }
 
     out_dir_base_ = "gen-xsd";
diff --git a/compiler/cpp/src/globals.h b/compiler/cpp/src/thrift/globals.h
similarity index 91%
rename from compiler/cpp/src/globals.h
rename to compiler/cpp/src/thrift/globals.h
index c5c0394687f..961c6ef8ab3 100644
--- a/compiler/cpp/src/globals.h
+++ b/compiler/cpp/src/thrift/globals.h
@@ -61,21 +61,6 @@ extern int g_strict;
  */
 extern t_program* g_program;
 
-/**
- * Global types for the parser to be able to reference
- */
-
-extern t_type* g_type_void;
-extern t_type* g_type_string;
-extern t_type* g_type_binary;
-extern t_type* g_type_slist;
-extern t_type* g_type_bool;
-extern t_type* g_type_i8;
-extern t_type* g_type_i16;
-extern t_type* g_type_i32;
-extern t_type* g_type_i64;
-extern t_type* g_type_double;
-
 /**
  * The scope that we are currently parsing into
  */
diff --git a/compiler/cpp/src/thrift/logging.cc b/compiler/cpp/src/thrift/logging.cc
new file mode 100644
index 00000000000..f821f5fc563
--- /dev/null
+++ b/compiler/cpp/src/thrift/logging.cc
@@ -0,0 +1,77 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+/**
+ * Logging functions copied from main.cc to avoid link errors for plugins
+ */
+
+#include "thrift/logging.h"
+#include "thrift/globals.h"
+#include <cstdarg>
+#include <cstdio>
+#include <cstdlib>
+
+// TODO: make plugins accept log options from main compiler
+int g_debug = 0;
+int g_warn = 1;
+int g_verbose = 0;
+
+void pdebug(const char* fmt, ...) {
+  if (g_debug == 0) {
+    return;
+  }
+  va_list args;
+  // printf("[PARSE:%d] ", yylineno);
+  va_start(args, fmt);
+  vprintf(fmt, args);
+  va_end(args);
+  printf("\n");
+}
+
+void pverbose(const char* fmt, ...) {
+  if (g_verbose == 0) {
+    return;
+  }
+  va_list args;
+  va_start(args, fmt);
+  vprintf(fmt, args);
+  va_end(args);
+}
+
+void pwarning(int level, const char* fmt, ...) {
+  if (g_warn < level) {
+    return;
+  }
+  va_list args;
+  // printf("[WARNING:%s:%d] ", g_curpath.c_str(), yylineno);
+  va_start(args, fmt);
+  vprintf(fmt, args);
+  va_end(args);
+  printf("\n");
+}
+
+void failure(const char* fmt, ...) {
+  va_list args;
+  // fprintf(stderr, "[FAILURE:%s:%d] ", g_curpath.c_str(), yylineno);
+  va_start(args, fmt);
+  vfprintf(stderr, fmt, args);
+  va_end(args);
+  printf("\n");
+  exit(1);
+}
diff --git a/compiler/cpp/src/logging.h b/compiler/cpp/src/thrift/logging.h
similarity index 95%
rename from compiler/cpp/src/logging.h
rename to compiler/cpp/src/thrift/logging.h
index 3f1fce87d02..ebefbf229bb 100644
--- a/compiler/cpp/src/logging.h
+++ b/compiler/cpp/src/thrift/logging.h
@@ -20,7 +20,9 @@
 #ifndef T_LOGGING_H
 #define T_LOGGING_H
 
-#include <string>
+extern int g_debug;
+extern int g_warn;
+extern int g_verbose;
 
 /**
  * Parse debugging output, used to print helpful info
diff --git a/compiler/cpp/src/main.cc b/compiler/cpp/src/thrift/main.cc
similarity index 96%
rename from compiler/cpp/src/main.cc
rename to compiler/cpp/src/thrift/main.cc
index 89dd9f97e54..84218405be2 100644
--- a/compiler/cpp/src/main.cc
+++ b/compiler/cpp/src/thrift/main.cc
@@ -44,16 +44,20 @@
 #endif
 
 // Careful: must include globals first for extern definitions
-#include "globals.h"
-
-#include "platform.h"
-#include "main.h"
-#include "parse/t_program.h"
-#include "parse/t_scope.h"
-#include "generate/t_generator.h"
-#include "audit/t_audit.h"
+#include "thrift/common.h"
+#include "thrift/globals.h"
+
+#include "thrift/platform.h"
+#include "thrift/main.h"
+#include "thrift/parse/t_program.h"
+#include "thrift/parse/t_scope.h"
+#include "thrift/generate/t_generator.h"
+#include "thrift/audit/t_audit.h"
+#ifdef THRIFT_ENABLE_PLUGIN
+#include "thrift/plugin/plugin_output.h"
+#endif
 
-#include "version.h"
+#include "thrift/version.h"
 
 using namespace std;
 
@@ -62,21 +66,6 @@ using namespace std;
  */
 t_program* g_program;
 
-/**
- * Global types
- */
-
-t_type* g_type_void;
-t_type* g_type_string;
-t_type* g_type_binary;
-t_type* g_type_slist;
-t_type* g_type_bool;
-t_type* g_type_i8;
-t_type* g_type_i16;
-t_type* g_type_i32;
-t_type* g_type_i64;
-t_type* g_type_double;
-
 /**
  * Global scope
  */
@@ -142,17 +131,10 @@ char* g_time_str;
  */
 char* g_doctext;
 
-/**
- * The location of the last parsed doctext comment.
- */
-int g_doctext_lineno;
-
 /**
  * The First doctext comment
  */
 char* g_program_doctext_candidate;
-int g_program_doctext_lineno = 0;
-PROGDOCTEXT_STATUS g_program_doctext_status = INVALID;
 
 /**
  * Whether or not negative field keys are accepted.
@@ -179,6 +161,7 @@ bool g_audit = false;
  */
 bool g_return_failure = false;
 bool g_audit_fatal = true;
+bool g_generator_failure = false;
 
 /**
  * Win32 doesn't have realpath, so use fallback implementation in that case,
@@ -1024,8 +1007,27 @@ void generate(t_program* program, const vector<string>& generator_strings) {
       t_generator* generator = t_generator_registry::get_generator(program, *iter);
 
       if (generator == NULL) {
+#ifdef THRIFT_ENABLE_PLUGIN
+        switch (plugin_output::delegateToPlugin(program, *iter)) {
+          case plugin_output::PLUGIN_NOT_FOUND:
+            pwarning(1, "Unable to get a generator for \"%s\".\n", iter->c_str());
+            g_generator_failure = true;
+            break;
+          case plugin_output::PLUGIN_FAILURE:
+            pwarning(1, "Plugin generator for \"%s\" failed.\n", iter->c_str());
+            g_generator_failure = true;
+            break;
+          case plugin_output::PLUGIN_SUCCEESS:
+            break;
+          default:
+            assert(false);
+            break;
+        }
+#else
         pwarning(1, "Unable to get a generator for \"%s\".\n", iter->c_str());
-      } else {
+        g_generator_failure = true;
+#endif
+      } else if (generator) {
         pverbose("Generating \"%s\"\n", iter->c_str());
         generator->generate_program();
         delete generator;
@@ -1208,18 +1210,7 @@ int main(int argc, char** argv) {
   }
 
   // Initialize global types
-  g_type_void = new t_base_type("void", t_base_type::TYPE_VOID);
-  g_type_string = new t_base_type("string", t_base_type::TYPE_STRING);
-  g_type_binary = new t_base_type("string", t_base_type::TYPE_STRING);
-  ((t_base_type*)g_type_binary)->set_binary(true);
-  g_type_slist = new t_base_type("string", t_base_type::TYPE_STRING);
-  ((t_base_type*)g_type_slist)->set_string_list(true);
-  g_type_bool = new t_base_type("bool", t_base_type::TYPE_BOOL);
-  g_type_i8 = new t_base_type("i8", t_base_type::TYPE_I8);
-  g_type_i16 = new t_base_type("i16", t_base_type::TYPE_I16);
-  g_type_i32 = new t_base_type("i32", t_base_type::TYPE_I32);
-  g_type_i64 = new t_base_type("i64", t_base_type::TYPE_I64);
-  g_type_double = new t_base_type("double", t_base_type::TYPE_DOUBLE);
+  initGlobals();
 
   if (g_audit) {
     // Audit operation
@@ -1302,20 +1293,15 @@ int main(int argc, char** argv) {
   // Clean up. Who am I kidding... this program probably orphans heap memory
   // all over the place, but who cares because it is about to exit and it is
   // all referenced and used by this wacky parse tree up until now anyways.
-
-  delete g_type_void;
-  delete g_type_string;
-  delete g_type_bool;
-  delete g_type_i8;
-  delete g_type_i16;
-  delete g_type_i32;
-  delete g_type_i64;
-  delete g_type_double;
+  clearGlobals();
 
   // Finished
   if (g_return_failure && g_audit_fatal) {
     exit(2);
   }
+  if (g_generator_failure) {
+    exit(3);
+  }
   // Finished
   return 0;
 }
diff --git a/compiler/cpp/src/main.h b/compiler/cpp/src/thrift/main.h
similarity index 96%
rename from compiler/cpp/src/main.h
rename to compiler/cpp/src/thrift/main.h
index b0af5a758d5..54abb03c351 100644
--- a/compiler/cpp/src/main.h
+++ b/compiler/cpp/src/thrift/main.h
@@ -23,10 +23,10 @@
 #include <string>
 #include <cstdio>
 
-#include "logging.h"
+#include "thrift/logging.h"
 
-#include "parse/t_const.h"
-#include "parse/t_field.h"
+#include "thrift/parse/t_const.h"
+#include "thrift/parse/t_field.h"
 
 /**
  * Defined in the flex library
diff --git a/compiler/cpp/src/parse/parse.cc b/compiler/cpp/src/thrift/parse/parse.cc
similarity index 78%
rename from compiler/cpp/src/parse/parse.cc
rename to compiler/cpp/src/thrift/parse/parse.cc
index b22ee528143..01f763751dc 100644
--- a/compiler/cpp/src/parse/parse.cc
+++ b/compiler/cpp/src/thrift/parse/parse.cc
@@ -17,10 +17,10 @@
  * under the License.
  */
 
-#include "t_type.h"
-#include "t_typedef.h"
+#include "thrift/parse/t_type.h"
+#include "thrift/parse/t_typedef.h"
 
-#include "main.h"
+#include "thrift/main.h"
 
 t_type* t_type::get_true_type() {
   t_type* type = this;
@@ -29,3 +29,11 @@ t_type* t_type::get_true_type() {
   }
   return type;
 }
+
+const t_type* t_type::get_true_type() const {
+  const t_type* type = this;
+  while (type->is_typedef()) {
+    type = ((t_typedef*)type)->get_type();
+  }
+  return type;
+}
diff --git a/compiler/cpp/src/parse/t_base_type.h b/compiler/cpp/src/thrift/parse/t_base_type.h
similarity index 98%
rename from compiler/cpp/src/parse/t_base_type.h
rename to compiler/cpp/src/thrift/parse/t_base_type.h
index 11d73e01527..32523cb9db5 100644
--- a/compiler/cpp/src/parse/t_base_type.h
+++ b/compiler/cpp/src/thrift/parse/t_base_type.h
@@ -21,7 +21,7 @@
 #define T_BASE_TYPE_H
 
 #include <cstdlib>
-#include "t_type.h"
+#include "thrift/parse/t_type.h"
 
 /**
  * A thrift base type, which must be one of the defined enumerated types inside
diff --git a/compiler/cpp/src/parse/t_const.h b/compiler/cpp/src/thrift/parse/t_const.h
similarity index 95%
rename from compiler/cpp/src/parse/t_const.h
rename to compiler/cpp/src/thrift/parse/t_const.h
index 0f64bb14aff..3c08e0dec0c 100644
--- a/compiler/cpp/src/parse/t_const.h
+++ b/compiler/cpp/src/thrift/parse/t_const.h
@@ -20,8 +20,8 @@
 #ifndef T_CONST_H
 #define T_CONST_H
 
-#include "t_type.h"
-#include "t_const_value.h"
+#include "thrift/parse/t_type.h"
+#include "thrift/parse/t_const_value.h"
 
 /**
  * A const is a constant value defined across languages that has a type and
diff --git a/compiler/cpp/src/parse/t_const_value.h b/compiler/cpp/src/thrift/parse/t_const_value.h
similarity index 94%
rename from compiler/cpp/src/parse/t_const_value.h
rename to compiler/cpp/src/thrift/parse/t_const_value.h
index 7e6e3f6b4e1..55078032871 100644
--- a/compiler/cpp/src/parse/t_const_value.h
+++ b/compiler/cpp/src/thrift/parse/t_const_value.h
@@ -20,12 +20,17 @@
 #ifndef T_CONST_VALUE_H
 #define T_CONST_VALUE_H
 
-#include "t_enum.h"
+#include "thrift/parse/t_enum.h"
 #include <stdint.h>
 #include <map>
 #include <vector>
 #include <string>
 
+namespace plugin_output {
+template <typename From, typename To>
+void convert(From*, To&);
+}
+
 /**
  * A const value is something parsed that could be a map, set, list, struct
  * or whatever.
@@ -141,6 +146,10 @@ class t_const_value {
   t_enum* enum_;
 
   t_const_value_type valType_;
+
+  // to read enum_
+  template <typename From, typename To>
+  friend void plugin_output::convert(From*, To&);
 };
 
 #endif
diff --git a/compiler/cpp/src/parse/t_container.h b/compiler/cpp/src/thrift/parse/t_container.h
similarity index 89%
rename from compiler/cpp/src/parse/t_container.h
rename to compiler/cpp/src/thrift/parse/t_container.h
index 0d992b72340..5bdab70a7af 100644
--- a/compiler/cpp/src/parse/t_container.h
+++ b/compiler/cpp/src/thrift/parse/t_container.h
@@ -20,7 +20,7 @@
 #ifndef T_CONTAINER_H
 #define T_CONTAINER_H
 
-#include "t_type.h"
+#include "thrift/parse/t_type.h"
 
 class t_container : public t_type {
 public:
@@ -33,9 +33,9 @@ class t_container : public t_type {
     has_cpp_name_ = true;
   }
 
-  bool has_cpp_name() { return has_cpp_name_; }
+  bool has_cpp_name() const { return has_cpp_name_; }
 
-  std::string get_cpp_name() { return cpp_name_; }
+  std::string get_cpp_name() const { return cpp_name_; }
 
   bool is_container() const { return true; }
 
diff --git a/compiler/cpp/src/parse/t_doc.h b/compiler/cpp/src/thrift/parse/t_doc.h
similarity index 94%
rename from compiler/cpp/src/parse/t_doc.h
rename to compiler/cpp/src/thrift/parse/t_doc.h
index 9d310b72d72..7bcb8f5e4b9 100644
--- a/compiler/cpp/src/parse/t_doc.h
+++ b/compiler/cpp/src/thrift/parse/t_doc.h
@@ -20,8 +20,8 @@
 #ifndef T_DOC_H
 #define T_DOC_H
 
-#include "globals.h"
-#include "logging.h"
+#include "thrift/globals.h"
+#include "thrift/logging.h"
 
 /**
  * Documentation stubs
@@ -31,6 +31,7 @@ class t_doc {
 
 public:
   t_doc() : has_doc_(false) {}
+  virtual ~t_doc() {}
 
   void set_doc(const std::string& doc) {
     doc_ = doc;
diff --git a/compiler/cpp/src/parse/t_enum.h b/compiler/cpp/src/thrift/parse/t_enum.h
similarity index 95%
rename from compiler/cpp/src/parse/t_enum.h
rename to compiler/cpp/src/thrift/parse/t_enum.h
index 64f4ff4c8ba..9e23780cb84 100644
--- a/compiler/cpp/src/parse/t_enum.h
+++ b/compiler/cpp/src/thrift/parse/t_enum.h
@@ -20,9 +20,11 @@
 #ifndef T_ENUM_H
 #define T_ENUM_H
 
-#include "t_enum_value.h"
 #include <vector>
 
+#include "thrift/parse/t_enum_value.h"
+#include "thrift/parse/t_type.h"
+
 /**
  * An enumerated type. A list of constant objects with a name for the type.
  *
@@ -35,7 +37,7 @@ class t_enum : public t_type {
 
   void append(t_enum_value* constant) { constants_.push_back(constant); }
 
-  const std::vector<t_enum_value*>& get_constants() { return constants_; }
+  const std::vector<t_enum_value*>& get_constants() const { return constants_; }
 
   t_enum_value* get_constant_by_name(const std::string& name) {
     const std::vector<t_enum_value*>& enum_values = get_constants();
diff --git a/compiler/cpp/src/parse/t_enum_value.h b/compiler/cpp/src/thrift/parse/t_enum_value.h
similarity index 96%
rename from compiler/cpp/src/parse/t_enum_value.h
rename to compiler/cpp/src/thrift/parse/t_enum_value.h
index 5979f06a7b7..c0bf3adfcb7 100644
--- a/compiler/cpp/src/parse/t_enum_value.h
+++ b/compiler/cpp/src/thrift/parse/t_enum_value.h
@@ -20,8 +20,9 @@
 #ifndef T_ENUM_VALUE_H
 #define T_ENUM_VALUE_H
 
+#include <map>
 #include <string>
-#include "t_doc.h"
+#include "thrift/parse/t_doc.h"
 
 /**
  * A constant. These are used inside of enum definitions. Constants are just
diff --git a/compiler/cpp/src/parse/t_field.h b/compiler/cpp/src/thrift/parse/t_field.h
similarity index 93%
rename from compiler/cpp/src/parse/t_field.h
rename to compiler/cpp/src/thrift/parse/t_field.h
index eece7bb1469..c5f1f800c73 100644
--- a/compiler/cpp/src/parse/t_field.h
+++ b/compiler/cpp/src/thrift/parse/t_field.h
@@ -20,10 +20,12 @@
 #ifndef T_FIELD_H
 #define T_FIELD_H
 
+#include <map>
 #include <string>
 #include <sstream>
 
-#include "t_doc.h"
+#include "thrift/parse/t_doc.h"
+#include "thrift/parse/t_type.h"
 
 // Forward declare for xsd_attrs
 class t_struct;
@@ -58,7 +60,9 @@ class t_field : public t_doc {
 
   ~t_field() {}
 
-  t_type* get_type() const { return type_; }
+  t_type* get_type() { return type_; }
+
+  const t_type* get_type() const { return type_; }
 
   const std::string& get_name() const { return name_; }
 
@@ -74,6 +78,8 @@ class t_field : public t_doc {
 
   t_const_value* get_value() { return value_; }
 
+  const t_const_value* get_value() const { return value_; }
+
   void set_xsd_optional(bool xsd_optional) { xsd_optional_ = xsd_optional; }
 
   bool get_xsd_optional() const { return xsd_optional_; }
diff --git a/compiler/cpp/src/parse/t_function.h b/compiler/cpp/src/thrift/parse/t_function.h
similarity index 96%
rename from compiler/cpp/src/parse/t_function.h
rename to compiler/cpp/src/thrift/parse/t_function.h
index 96886f3269c..05dc930fc62 100644
--- a/compiler/cpp/src/parse/t_function.h
+++ b/compiler/cpp/src/thrift/parse/t_function.h
@@ -21,9 +21,9 @@
 #define T_FUNCTION_H
 
 #include <string>
-#include "t_type.h"
-#include "t_struct.h"
-#include "t_doc.h"
+#include "thrift/parse/t_type.h"
+#include "thrift/parse/t_struct.h"
+#include "thrift/parse/t_doc.h"
 
 /**
  * Representation of a function. Key parts are return type, function name,
diff --git a/compiler/cpp/src/parse/t_list.h b/compiler/cpp/src/thrift/parse/t_list.h
similarity index 96%
rename from compiler/cpp/src/parse/t_list.h
rename to compiler/cpp/src/thrift/parse/t_list.h
index ac0d98152e3..acf68653b2c 100644
--- a/compiler/cpp/src/parse/t_list.h
+++ b/compiler/cpp/src/thrift/parse/t_list.h
@@ -20,7 +20,7 @@
 #ifndef T_LIST_H
 #define T_LIST_H
 
-#include "t_container.h"
+#include "thrift/parse/t_container.h"
 
 /**
  * A list is a lightweight container type that just wraps another data type.
diff --git a/compiler/cpp/src/parse/t_map.h b/compiler/cpp/src/thrift/parse/t_map.h
similarity index 97%
rename from compiler/cpp/src/parse/t_map.h
rename to compiler/cpp/src/thrift/parse/t_map.h
index 269aeab585d..dd3f089c197 100644
--- a/compiler/cpp/src/parse/t_map.h
+++ b/compiler/cpp/src/thrift/parse/t_map.h
@@ -20,7 +20,7 @@
 #ifndef T_MAP_H
 #define T_MAP_H
 
-#include "t_container.h"
+#include "thrift/parse/t_container.h"
 
 /**
  * A map is a lightweight container type that just wraps another two data
diff --git a/compiler/cpp/src/parse/t_program.h b/compiler/cpp/src/thrift/parse/t_program.h
similarity index 95%
rename from compiler/cpp/src/parse/t_program.h
rename to compiler/cpp/src/thrift/parse/t_program.h
index 812106cb432..43dd45a6183 100644
--- a/compiler/cpp/src/parse/t_program.h
+++ b/compiler/cpp/src/thrift/parse/t_program.h
@@ -25,21 +25,21 @@
 #include <vector>
 
 // For program_name()
-#include "main.h"
-
-#include "t_doc.h"
-#include "t_scope.h"
-#include "t_base_type.h"
-#include "t_typedef.h"
-#include "t_enum.h"
-#include "t_const.h"
-#include "t_struct.h"
-#include "t_service.h"
-#include "t_list.h"
-#include "t_map.h"
-#include "t_set.h"
-#include "generate/t_generator_registry.h"
-//#include "t_doc.h"
+#include "thrift/main.h"
+
+#include "thrift/parse/t_doc.h"
+#include "thrift/parse/t_scope.h"
+#include "thrift/parse/t_base_type.h"
+#include "thrift/parse/t_typedef.h"
+#include "thrift/parse/t_enum.h"
+#include "thrift/parse/t_const.h"
+#include "thrift/parse/t_struct.h"
+#include "thrift/parse/t_service.h"
+#include "thrift/parse/t_list.h"
+#include "thrift/parse/t_map.h"
+#include "thrift/parse/t_set.h"
+#include "thrift/generate/t_generator_registry.h"
+//#include "thrift/parse/t_doc.h"
 
 /**
  * Top level class representing an entire thrift program. A program consists
@@ -58,9 +58,7 @@
 class t_program : public t_doc {
 public:
   t_program(std::string path, std::string name)
-    : path_(path), name_(name), out_path_("./"), out_path_is_absolute_(false) {
-    scope_ = new t_scope();
-  }
+    : path_(path), name_(name), out_path_("./"), out_path_is_absolute_(false), scope_(new t_scope) {}
 
   t_program(std::string path) : path_(path), out_path_("./"), out_path_is_absolute_(false) {
     name_ = program_name(path);
@@ -250,6 +248,10 @@ class t_program : public t_doc {
 
   // Includes
 
+  void add_include(t_program* program) {
+    includes_.push_back(program);
+  }
+
   void add_include(std::string path, std::string include_site) {
     t_program* program = new t_program(path);
 
diff --git a/compiler/cpp/src/parse/t_scope.h b/compiler/cpp/src/thrift/parse/t_scope.h
similarity index 93%
rename from compiler/cpp/src/parse/t_scope.h
rename to compiler/cpp/src/thrift/parse/t_scope.h
index 5acb94e5b15..e1962002301 100644
--- a/compiler/cpp/src/parse/t_scope.h
+++ b/compiler/cpp/src/thrift/parse/t_scope.h
@@ -24,13 +24,18 @@
 #include <string>
 #include <sstream>
 
-#include "t_type.h"
-#include "t_service.h"
-#include "t_const.h"
-#include "t_const_value.h"
-#include "t_base_type.h"
-#include "t_map.h"
-#include "t_list.h"
+#include "thrift/parse/t_type.h"
+#include "thrift/parse/t_service.h"
+#include "thrift/parse/t_const.h"
+#include "thrift/parse/t_const_value.h"
+#include "thrift/parse/t_base_type.h"
+#include "thrift/parse/t_map.h"
+#include "thrift/parse/t_list.h"
+
+namespace plugin_output {
+template <typename From, typename To>
+void convert(From*, To&);
+}
 
 /**
  * This represents a variable scope used for looking up predefined types and
@@ -167,6 +172,10 @@ class t_scope {
 
   // Map of names to services
   std::map<std::string, t_service*> services_;
+
+  // to list map entries
+  template <typename From, typename To>
+    friend void plugin_output::convert(From*, To&);
 };
 
 #endif
diff --git a/compiler/cpp/src/parse/t_service.h b/compiler/cpp/src/thrift/parse/t_service.h
similarity index 94%
rename from compiler/cpp/src/parse/t_service.h
rename to compiler/cpp/src/thrift/parse/t_service.h
index 2b01f9c45f5..e2204caee9c 100644
--- a/compiler/cpp/src/parse/t_service.h
+++ b/compiler/cpp/src/thrift/parse/t_service.h
@@ -20,7 +20,7 @@
 #ifndef T_SERVICE_H
 #define T_SERVICE_H
 
-#include "t_function.h"
+#include "thrift/parse/t_function.h"
 #include <vector>
 
 class t_program;
@@ -51,6 +51,8 @@ class t_service : public t_type {
 
   t_service* get_extends() { return extends_; }
 
+  const t_service* get_extends() const { return extends_; }
+
 private:
   std::vector<t_function*> functions_;
   t_service* extends_;
diff --git a/compiler/cpp/src/parse/t_set.h b/compiler/cpp/src/thrift/parse/t_set.h
similarity index 96%
rename from compiler/cpp/src/parse/t_set.h
rename to compiler/cpp/src/thrift/parse/t_set.h
index 8a464805022..f913be4fa3c 100644
--- a/compiler/cpp/src/parse/t_set.h
+++ b/compiler/cpp/src/thrift/parse/t_set.h
@@ -20,7 +20,7 @@
 #ifndef T_SET_H
 #define T_SET_H
 
-#include "t_container.h"
+#include "thrift/parse/t_container.h"
 
 /**
  * A set is a lightweight container type that just wraps another data type.
diff --git a/compiler/cpp/src/parse/t_struct.h b/compiler/cpp/src/thrift/parse/t_struct.h
similarity index 91%
rename from compiler/cpp/src/parse/t_struct.h
rename to compiler/cpp/src/thrift/parse/t_struct.h
index d19447c3650..4102da7be7f 100644
--- a/compiler/cpp/src/parse/t_struct.h
+++ b/compiler/cpp/src/thrift/parse/t_struct.h
@@ -25,8 +25,8 @@
 #include <utility>
 #include <string>
 
-#include "t_type.h"
-#include "t_field.h"
+#include "thrift/parse/t_type.h"
+#include "thrift/parse/t_field.h"
 
 // Forward declare that puppy
 class t_program;
@@ -127,7 +127,7 @@ class t_struct : public t_type {
     return true;
   }
 
-  const members_type& get_members() { return members_; }
+  const members_type& get_members() const { return members_; }
 
   const members_type& get_sorted_members() { return members_in_id_order_; }
 
@@ -147,6 +147,16 @@ class t_struct : public t_type {
     return NULL;
   }
 
+  const t_field* get_field_by_name(std::string field_name) const {
+    members_type::const_iterator m_iter;
+    for (m_iter = members_in_id_order_.begin(); m_iter != members_in_id_order_.end(); ++m_iter) {
+      if ((*m_iter)->get_name() == field_name) {
+        return *m_iter;
+      }
+    }
+    return NULL;
+  }
+
 private:
   members_type members_;
   members_type members_in_id_order_;
diff --git a/compiler/cpp/src/parse/t_type.h b/compiler/cpp/src/thrift/parse/t_type.h
similarity index 97%
rename from compiler/cpp/src/parse/t_type.h
rename to compiler/cpp/src/thrift/parse/t_type.h
index 416cc6fa3d7..30f8c1f7e62 100644
--- a/compiler/cpp/src/parse/t_type.h
+++ b/compiler/cpp/src/thrift/parse/t_type.h
@@ -24,7 +24,7 @@
 #include <map>
 #include <cstring>
 #include <stdint.h>
-#include "t_doc.h"
+#include "thrift/parse/t_doc.h"
 
 class t_program;
 
@@ -63,6 +63,7 @@ class t_type : public t_doc {
   const t_program* get_program() const { return program_; }
 
   t_type* get_true_type();
+  const t_type* get_true_type() const;
 
   // This function will break (maybe badly) unless 0 <= num <= 16.
   static char nybble_to_xdigit(int num) {
diff --git a/compiler/cpp/src/parse/t_typedef.cc b/compiler/cpp/src/thrift/parse/t_typedef.cc
similarity index 93%
rename from compiler/cpp/src/parse/t_typedef.cc
rename to compiler/cpp/src/thrift/parse/t_typedef.cc
index ddbe749877d..99ffdb8bdc6 100644
--- a/compiler/cpp/src/parse/t_typedef.cc
+++ b/compiler/cpp/src/thrift/parse/t_typedef.cc
@@ -18,8 +18,8 @@
  */
 #include <cstdio>
 
-#include "t_typedef.h"
-#include "t_program.h"
+#include "thrift/parse/t_typedef.h"
+#include "thrift/parse/t_program.h"
 
 t_type* t_typedef::get_type() const {
   if (type_ == NULL) {
diff --git a/compiler/cpp/src/parse/t_typedef.h b/compiler/cpp/src/thrift/parse/t_typedef.h
similarity index 98%
rename from compiler/cpp/src/parse/t_typedef.h
rename to compiler/cpp/src/thrift/parse/t_typedef.h
index a39a246d2e8..0cccc265e52 100644
--- a/compiler/cpp/src/parse/t_typedef.h
+++ b/compiler/cpp/src/thrift/parse/t_typedef.h
@@ -21,7 +21,7 @@
 #define T_TYPEDEF_H
 
 #include <string>
-#include "t_type.h"
+#include "thrift/parse/t_type.h"
 
 /**
  * A typedef is a mapping from a symbolic name to another type. In dymanically
diff --git a/compiler/cpp/src/platform.h b/compiler/cpp/src/thrift/platform.h
similarity index 97%
rename from compiler/cpp/src/platform.h
rename to compiler/cpp/src/thrift/platform.h
index 8cbe9dbe838..7a8edaea452 100644
--- a/compiler/cpp/src/platform.h
+++ b/compiler/cpp/src/thrift/platform.h
@@ -23,7 +23,7 @@
  */
 
 #ifdef _MSC_VER
-#include "windows/config.h"
+#include "thrift/windows/config.h"
 #endif
 
 #ifdef _WIN32
diff --git a/compiler/cpp/src/thrift/plugin/Makefile.am b/compiler/cpp/src/thrift/plugin/Makefile.am
new file mode 100644
index 00000000000..e84cdbd9c0c
--- /dev/null
+++ b/compiler/cpp/src/thrift/plugin/Makefile.am
@@ -0,0 +1,47 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements. See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership. The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License. You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied. See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+#
+# Contains some contributions under the Thrift Software License.
+# Please see doc/old-thrift-license.txt in the Thrift distribution for
+# details.
+
+AUTOMAKE_OPTIONS = subdir-objects
+
+if WITH_PLUGIN
+plugin_gen = plugin_types.h \
+             plugin_types.cpp \
+             plugin_constants.h \
+             plugin_constants.cpp
+
+BUILT_SOURCES = $(plugin_gen)
+gen.stamp: plugin.thrift $(top_builddir)/compiler/cpp/src/thrift/thrift-bootstrap
+	@$(RM) -f gen.tmp
+	@touch gen.tmp
+	$(top_builddir)/compiler/cpp/src/thrift/thrift-bootstrap -gen cpp -out . $<
+	@mv -f gen.tmp $@
+
+$(plugin_gen): gen.stamp
+	@if test -f $@; then :; else \
+	$(RM) -f gen.stamp; \
+	$(MAKE) $(AM_MAKEFLAGS) gen.stamp; \
+	fi
+
+clean-local:
+	$(RM) version.h windows/version.h $(plugin_gen)
+endif
diff --git a/compiler/cpp/src/thrift/plugin/plugin.cc b/compiler/cpp/src/thrift/plugin/plugin.cc
new file mode 100644
index 00000000000..1d45d89c79b
--- /dev/null
+++ b/compiler/cpp/src/thrift/plugin/plugin.cc
@@ -0,0 +1,503 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include "thrift/plugin/plugin.h"
+
+#ifdef _WIN32
+#include <fcntl.h>
+#include <io.h>
+#endif
+
+#include <cassert>
+#include <iostream>
+
+#include <boost/bind.hpp>
+#include <boost/range/adaptor/map.hpp>
+#include <boost/range/algorithm/for_each.hpp>
+#include <boost/smart_ptr.hpp>
+
+#include "thrift/generate/t_generator.h"
+#include "thrift/plugin/type_util.h"
+#include "thrift/protocol/TBinaryProtocol.h"
+#include "thrift/transport/TBufferTransports.h"
+#include "thrift/transport/TFDTransport.h"
+
+#include "thrift/plugin/plugin_types.h"
+
+namespace apache {
+namespace thrift {
+namespace plugin {
+
+using apache::thrift::protocol::TBinaryProtocol;
+using apache::thrift::transport::TFDTransport;
+using apache::thrift::transport::TFramedTransport;
+
+#define THRIFT_CONVERT_FORWARD(from_type)                                                          \
+  template <>                                                                                      \
+  typename ToType<from_type>::type* convert_forward<from_type>(const from_type& from)
+
+#define THRIFT_CONVERT_COMPLETE_DECL(from_type)                                                    \
+  template <>                                                                                      \
+  void convert(const from_type& from, ToType<from_type>::type* to)
+
+#define THRIFT_CONVERT_UNARY_DECL(from_type)                                                       \
+  template <>                                                                                      \
+  typename ToType<from_type>::type* convert<from_type>(const from_type& from)
+
+#define THRIFT_CONVERSION_DECL(from_type)                                                          \
+  THRIFT_CONVERT_FORWARD(from_type);                                                               \
+  THRIFT_CONVERT_COMPLETE_DECL(from_type);                                                         \
+  THRIFT_CONVERT_UNARY_DECL(from_type)
+
+#define THRIFT_CONVERT_COMPLETE(from_type)                                                         \
+  THRIFT_CONVERSION_DECL(from_type) {                                                              \
+    ToType<from_type>::type* to = convert_forward(from);                                           \
+    convert(from, to);                                                                             \
+    return to;                                                                                     \
+  }                                                                                                \
+  THRIFT_CONVERT_COMPLETE_DECL(from_type)
+
+#define THRIFT_CONVERSION(from_type, ...)                                                          \
+  THRIFT_CONVERT_FORWARD(from_type) {                                                              \
+    (void)from;                                                                                    \
+    return new ToType<from_type>::type(__VA_ARGS__);                                               \
+  }                                                                                                \
+  THRIFT_CONVERT_COMPLETE(from_type)
+
+#define THRIFT_ASSIGN_DOC()                                                                        \
+  do {                                                                                             \
+    if (from.__isset.doc)                                                                          \
+      to->set_doc(from.doc);                                                                       \
+  } while (0)
+
+#define THRIFT_ASSIGN_ANNOTATIONS()                                                                \
+  THRIFT_ASSIGN_DOC();                                                                             \
+  do {                                                                                             \
+    if (from.__isset.annotations)                                                                  \
+      to->annotations_ = from.annotations;                                                         \
+  } while (0)
+
+#define THRIFT_ASSIGN_METADATA()                                                                   \
+  do {                                                                                             \
+    to->set_name(from.metadata.name);                                                              \
+    if (from.metadata.__isset.doc)                                                                 \
+      to->set_doc(from.metadata.doc);                                                              \
+    if (from.metadata.__isset.annotations)                                                         \
+      to->annotations_ = from.metadata.annotations;                                                \
+  } while (0)
+
+::t_program* g_program = 0;
+
+template <typename C, typename S>
+struct TypeCache {
+  C* operator[](const int64_t& k) {
+    typename std::map<int64_t, C*>::iterator it = cache.find(k);
+    if (it != cache.end()) {
+      return it->second;
+    } else {
+      typename std::map<int64_t, S>::const_iterator cit = source->find(k);
+      if (cit == source->end()) {
+        throw ThriftPluginError("Type not found");
+      }
+      return (cache)[k] = convert_forward(cit->second);
+    }
+  }
+
+  void compileAll() {
+    boost::for_each(*source | boost::adaptors::map_keys,
+                    boost::bind(&TypeCache::compile, this, _1));
+  }
+
+  std::map<int64_t, S> const* source;
+
+protected:
+  std::map<int64_t, C*> cache;
+
+private:
+  void compile(const int64_t& k) {
+    typename std::map<int64_t, S>::const_iterator cit = source->find(k);
+    if (cit == source->end()) {
+      throw ThriftPluginError("Type not found ");
+    }
+    convert(cit->second, (*this)[k]);
+  }
+};
+std::map<int64_t, ::t_program*> g_program_cache;
+TypeCache< ::t_type, t_type> g_type_cache;
+TypeCache< ::t_const, t_const> g_const_cache;
+TypeCache< ::t_service, t_service> g_service_cache;
+
+void set_global_cache(const TypeRegistry& from) {
+  g_type_cache.source = &from.types;
+  g_const_cache.source = &from.constants;
+  g_service_cache.source = &from.services;
+
+  g_type_cache.compileAll();
+  g_const_cache.compileAll();
+  g_service_cache.compileAll();
+}
+
+template <typename T>
+T* resolve_type(int64_t name) {
+  return reinterpret_cast<T*>(g_type_cache[name]);
+}
+
+::t_const* resolve_const(int64_t name) {
+  return g_const_cache[name];
+}
+
+::t_service* resolve_service(int64_t name) {
+  return g_service_cache[name];
+}
+
+THRIFT_CONVERT_FORWARD(t_base_type) {
+#define T_BASETYPE_CASE(type)                                                                      \
+  case t_base::TYPE_##type:                                                                        \
+    t = ::t_base_type::TYPE_##type;                                                                \
+    break
+
+  ::t_base_type::t_base t = ::t_base_type::TYPE_VOID;
+  bool is_binary = false;
+  switch (from.value) {
+    T_BASETYPE_CASE(VOID);
+    T_BASETYPE_CASE(STRING);
+    T_BASETYPE_CASE(BOOL);
+    T_BASETYPE_CASE(I8);
+    T_BASETYPE_CASE(I16);
+    T_BASETYPE_CASE(I32);
+    T_BASETYPE_CASE(I64);
+    T_BASETYPE_CASE(DOUBLE);
+  case t_base::TYPE_BINARY:
+    t = ::t_base_type::TYPE_STRING;
+    is_binary = true;
+    break;
+  }
+  ::t_base_type* to = new ::t_base_type(from.metadata.name, t);
+  to->set_binary(is_binary);
+  return to;
+#undef T_BASETYPE_CASE
+}
+THRIFT_CONVERT_COMPLETE(t_base_type) {
+  THRIFT_ASSIGN_METADATA();
+}
+
+THRIFT_CONVERT_FORWARD(t_typedef) {
+  ::t_typedef* to;
+  if (from.forward) {
+    to = new ::t_typedef(g_program_cache[from.metadata.program_id], from.symbolic, true);
+  } else {
+    to = new ::t_typedef(g_program_cache[from.metadata.program_id],
+                         resolve_type< ::t_type>(from.type), from.symbolic);
+  }
+  return to;
+}
+THRIFT_CONVERT_COMPLETE(t_typedef) {
+  THRIFT_ASSIGN_METADATA();
+}
+THRIFT_CONVERSION(t_enum_value, from.name, from.value) {
+  assert(to);
+  THRIFT_ASSIGN_ANNOTATIONS();
+}
+THRIFT_CONVERSION(t_enum, g_program_cache[from.metadata.program_id]) {
+  assert(to);
+  THRIFT_ASSIGN_METADATA();
+  boost::for_each(from.constants | boost::adaptors::transformed(convert<t_enum_value>),
+                  boost::bind(&::t_enum::append, to, _1));
+}
+THRIFT_CONVERSION(t_list, resolve_type< ::t_type>(from.elem_type)) {
+  assert(to);
+  THRIFT_ASSIGN_METADATA();
+  if (from.__isset.cpp_name)
+    to->set_cpp_name(from.cpp_name);
+}
+THRIFT_CONVERSION(t_set, resolve_type< ::t_type>(from.elem_type)) {
+  assert(to);
+  THRIFT_ASSIGN_METADATA();
+  if (from.__isset.cpp_name)
+    to->set_cpp_name(from.cpp_name);
+}
+THRIFT_CONVERSION(t_map,
+                  resolve_type< ::t_type>(from.key_type),
+                  resolve_type< ::t_type>(from.val_type)) {
+  assert(to);
+  THRIFT_ASSIGN_METADATA();
+  if (from.__isset.cpp_name)
+    to->set_cpp_name(from.cpp_name);
+}
+THRIFT_CONVERSION(t_const_value, ) {
+#define T_CONST_VALUE_CASE(type)                                                                   \
+  if (from.__isset.type##_val)                                                                     \
+  to->set_##type(from.type##_val)
+
+  assert(to);
+  if (from.__isset.map_val) {
+    to->set_map();
+    for (std::map<t_const_value, t_const_value>::const_iterator it = from.map_val.begin();
+         it != from.map_val.end(); it++) {
+      to->add_map(convert(it->first), convert(it->second));
+    }
+  } else if (from.__isset.list_val) {
+    to->set_list();
+    boost::for_each(from.list_val | boost::adaptors::transformed(&convert<t_const_value>),
+                    boost::bind(&::t_const_value::add_list, to, _1));
+  } else
+    T_CONST_VALUE_CASE(string);
+  else T_CONST_VALUE_CASE(integer);
+  else T_CONST_VALUE_CASE(double);
+  else {
+    T_CONST_VALUE_CASE(identifier);
+    if (from.__isset.enum_val)
+      to->set_enum(resolve_type< ::t_enum>(from.enum_val));
+  }
+#undef T_CONST_VALUE_CASE
+}
+THRIFT_CONVERSION(t_field, resolve_type< ::t_type>(from.type), from.name, from.key) {
+  assert(to);
+  THRIFT_ASSIGN_ANNOTATIONS();
+  to->set_reference(from.reference);
+  to->set_req(static_cast< ::t_field::e_req>(from.req));
+  if (from.__isset.value) {
+    to->set_value(convert(from.value));
+  }
+}
+THRIFT_CONVERSION(t_struct, g_program_cache[from.metadata.program_id]) {
+  assert(to);
+  THRIFT_ASSIGN_METADATA();
+  to->set_union(from.is_union);
+  to->set_xception(from.is_xception);
+  boost::for_each(from.members | boost::adaptors::transformed(convert<t_field>),
+                  boost::bind(&::t_struct::append, to, _1));
+}
+THRIFT_CONVERSION(t_const,
+                  resolve_type< ::t_type>(from.type),
+                  from.name,
+                  convert<t_const_value>(from.value)) {
+  assert(to);
+  THRIFT_ASSIGN_DOC();
+}
+
+THRIFT_CONVERSION(t_function,
+                  resolve_type< ::t_type>(from.returntype),
+                  from.name,
+                  resolve_type< ::t_struct>(from.arglist),
+                  resolve_type< ::t_struct>(from.xceptions),
+                  from.is_oneway) {
+  assert(to);
+  THRIFT_ASSIGN_DOC();
+}
+
+THRIFT_CONVERSION(t_service, g_program_cache[from.metadata.program_id]) {
+  assert(to);
+  assert(from.metadata.program_id);
+  assert(g_program_cache[from.metadata.program_id]);
+  THRIFT_ASSIGN_METADATA();
+
+  boost::for_each(from.functions | boost::adaptors::transformed(convert<t_function>),
+                  boost::bind(&::t_service::add_function, to, _1));
+
+  if (from.__isset.extends_)
+    to->set_extends(resolve_service(from.extends_));
+}
+
+THRIFT_CONVERT_FORWARD(t_type) {
+#define T_TYPE_CASE_FW_T(case, type)                                                               \
+  if (from.__isset.case##_val)                                                                     \
+  return convert_forward<type>(from.case##_val)
+#define T_TYPE_CASE_FW(case) T_TYPE_CASE_FW_T(case, t_##case)
+
+  T_TYPE_CASE_FW(base_type);
+  T_TYPE_CASE_FW(typedef);
+  T_TYPE_CASE_FW(enum);
+  T_TYPE_CASE_FW(struct);
+  T_TYPE_CASE_FW_T(xception, t_struct);
+  T_TYPE_CASE_FW(list);
+  T_TYPE_CASE_FW(set);
+  T_TYPE_CASE_FW(map);
+  T_TYPE_CASE_FW(service);
+  throw ThriftPluginError("Invalid data: Type union has no value.");
+#undef T_TYPE_CASE_FW_T
+#undef T_TYPE_CASE_FW
+}
+THRIFT_CONVERT_COMPLETE(t_type) {
+#define T_TYPE_CASE_T(case, type)                                                                  \
+  else if (from.__isset.case##_val)                                                                \
+      convert<type, ::type>(from.case##_val, reinterpret_cast< ::type*>(to))
+#define T_TYPE_CASE(case) T_TYPE_CASE_T(case, t_##case)
+
+  if (false) {
+  }
+  T_TYPE_CASE(base_type);
+  T_TYPE_CASE(typedef);
+  T_TYPE_CASE(enum);
+  T_TYPE_CASE(struct);
+  T_TYPE_CASE_T(xception, t_struct);
+  T_TYPE_CASE(list);
+  T_TYPE_CASE(set);
+  T_TYPE_CASE(map);
+  T_TYPE_CASE(service);
+  else {
+    throw ThriftPluginError("Invalid data: Type union has no value.");
+  }
+#undef T_TYPE_CASE_T
+#undef T_TYPE_CASE
+}
+
+THRIFT_CONVERSION(t_scope, ) {
+  assert(to);
+#define T_SCOPE_RESOLVE(type, name, a)                                                             \
+  for (std::vector<int64_t>::const_iterator it = from.name##s.begin(); it != from.name##s.end();   \
+       it++) {                                                                                     \
+    ::t_##type* t = resolve_##type a(*it);                                                         \
+    to->add_##name(t->get_name(), t);                                                              \
+  }
+  T_SCOPE_RESOLVE(type, type, < ::t_type>);
+  T_SCOPE_RESOLVE(const, constant, );
+  T_SCOPE_RESOLVE(service, service, );
+#undef T_SCOPE_RESOLVE
+}
+
+THRIFT_CONVERT_FORWARD(t_program) {
+  ::t_program* to = new ::t_program(from.path, from.name);
+  for (std::vector<t_program>::const_iterator it = from.includes.begin(); it != from.includes.end();
+       it++) {
+    to->add_include(convert_forward(*it));
+  }
+  g_program_cache[from.program_id] = to;
+  return to;
+}
+THRIFT_CONVERT_COMPLETE(t_program) {
+  assert(to);
+  g_program = to;
+  convert<t_scope, ::t_scope>(from.scope, to->scope());
+  THRIFT_ASSIGN_DOC();
+
+  to->set_out_path(from.out_path, from.out_path_is_absolute);
+
+  boost::for_each(from.typedefs | boost::adaptors::transformed(&resolve_type< ::t_typedef>),
+                  boost::bind(&::t_program::add_typedef, to, _1));
+  boost::for_each(from.enums | boost::adaptors::transformed(&resolve_type< ::t_enum>),
+                  boost::bind(&::t_program::add_enum, to, _1));
+  for (std::vector<int64_t>::const_iterator it = from.objects.begin(); it != from.objects.end();
+       it++) {
+    ::t_struct* t2 = resolve_type< ::t_struct>(*it);
+    if (t2->is_xception()) {
+      to->add_xception(t2);
+    } else {
+      to->add_struct(t2);
+    }
+  }
+  boost::for_each(from.consts | boost::adaptors::transformed(&resolve_const),
+                  boost::bind(&::t_program::add_const, to, _1));
+  boost::for_each(from.services | boost::adaptors::transformed(&resolve_service),
+                  boost::bind(&::t_program::add_service, to, _1));
+
+  for (std::vector<t_program>::const_iterator it = from.includes.begin(); it != from.includes.end();
+       it++) {
+    convert(*it, g_program_cache[it->program_id]);
+  }
+  std::for_each(from.c_includes.begin(), from.c_includes.end(),
+                boost::bind(&::t_program::add_c_include, to, _1));
+  std::for_each(from.cpp_includes.begin(), from.cpp_includes.end(),
+                boost::bind(&::t_program::add_cpp_include, to, _1));
+  for (std::map<std::string, std::string>::const_iterator it = from.namespaces.begin();
+       it != from.namespaces.end(); it++) {
+    to->set_namespace(it->first, it->second);
+  }
+
+  to->set_include_prefix(from.include_prefix);
+  to->set_namespace(from.namespace_);
+}
+
+int GeneratorPlugin::exec(int, char* []) {
+#ifdef _WIN32
+  _setmode(fileno(stdin), _O_BINARY);
+#endif
+  boost::shared_ptr<TFramedTransport> transport(
+      new TFramedTransport(boost::make_shared<TFDTransport>(fileno(stdin))));
+  TBinaryProtocol proto(transport);
+  GeneratorInput input;
+  try {
+    input.read(&proto);
+  } catch (std::exception& err) {
+    std::cerr << "Error while receiving plugin data: " << err.what() << std::endl;
+    return -1;
+  }
+  initGlobals();
+  ::t_program* p = g_program = convert_forward(input.program);
+  set_global_cache(input.type_registry);
+  convert(input.program, p);
+
+  int ret = generate(p, input.parsed_options);
+  clearGlobals();
+
+  return ret;
+}
+
+::t_const_value::t_const_value_type const_value_case(const t_const_value& v) {
+  if (v.__isset.map_val)
+    return ::t_const_value::CV_MAP;
+  if (v.__isset.list_val)
+    return ::t_const_value::CV_LIST;
+  if (v.__isset.string_val)
+    return ::t_const_value::CV_STRING;
+  if (v.__isset.integer_val)
+    return ::t_const_value::CV_INTEGER;
+  if (v.__isset.double_val)
+    return ::t_const_value::CV_DOUBLE;
+  if (v.__isset.identifier_val)
+    return ::t_const_value::CV_IDENTIFIER;
+  if (v.__isset.enum_val)
+    return ::t_const_value::CV_IDENTIFIER;
+  throw ThriftPluginError("Unknown const value type");
+}
+
+bool t_const_value::operator<(const t_const_value& that) const {
+  ::t_const_value::t_const_value_type t1 = const_value_case(*this);
+  ::t_const_value::t_const_value_type t2 = const_value_case(that);
+  if (t1 != t2)
+    return t1 < t2;
+  switch (t1) {
+  case ::t_const_value::CV_INTEGER:
+    return integer_val < that.integer_val;
+  case ::t_const_value::CV_DOUBLE:
+    return double_val < that.double_val;
+  case ::t_const_value::CV_STRING:
+    return string_val < that.string_val;
+  case ::t_const_value::CV_MAP:
+    if (that.map_val.empty())
+      return false;
+    else if (map_val.empty())
+      return true;
+    else
+      return map_val.begin()->first < that.map_val.begin()->first;
+  case ::t_const_value::CV_LIST:
+    if (that.list_val.empty())
+      return false;
+    else if (list_val.empty())
+      return true;
+    else
+      return list_val.front() < that.list_val.front();
+  case ::t_const_value::CV_IDENTIFIER:
+    return integer_val < that.integer_val;
+  }
+  throw ThriftPluginError("Unknown const value type");
+}
+}
+}
+}
diff --git a/compiler/cpp/src/thrift/plugin/plugin.h b/compiler/cpp/src/thrift/plugin/plugin.h
new file mode 100644
index 00000000000..705cd41ffae
--- /dev/null
+++ b/compiler/cpp/src/thrift/plugin/plugin.h
@@ -0,0 +1,44 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifndef T_PLUGIN_PLUGIN_H
+#define T_PLUGIN_PLUGIN_H
+
+#include "thrift/Thrift.h"
+
+class t_program;
+
+namespace apache {
+namespace thrift {
+namespace plugin {
+
+struct ThriftPluginError : public apache::thrift::TException {
+  ThriftPluginError(const std::string& msg) : apache::thrift::TException(msg) {}
+};
+
+class GeneratorPlugin {
+public:
+  int exec(int argc, char* argv[]);
+  virtual int generate(::t_program*, const std::map<std::string, std::string>&) = 0;
+};
+}
+}
+}
+
+#endif
diff --git a/compiler/cpp/src/thrift/plugin/plugin.thrift b/compiler/cpp/src/thrift/plugin/plugin.thrift
new file mode 100644
index 00000000000..a93873da114
--- /dev/null
+++ b/compiler/cpp/src/thrift/plugin/plugin.thrift
@@ -0,0 +1,202 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+namespace as3 org.apache.thrift.plugin
+namespace cpp apache.thrift.plugin
+namespace csharp Thrift.Plugin
+namespace d thrift.plugin
+namespace delphi Thrift.Plugin
+namespace erl thrift.plugin
+namespace go thrift
+namespace haxe org.apache.thrift.plugin
+namespace hs Thrift.Plugin
+namespace java org.apache.thrift.plugin
+namespace ocaml Thrift
+namespace perl Thrift.Plugin
+namespace php thrift.plugin
+namespace py thrift.plugin
+namespace rb Thrift
+
+typedef i64 t_program_id
+typedef i64 t_type_id
+typedef i64 t_const_id
+typedef i64 t_service_id
+
+enum t_base {
+    TYPE_VOID
+    TYPE_STRING
+    TYPE_BOOL
+    TYPE_I8
+    TYPE_I16
+    TYPE_I32
+    TYPE_I64
+    TYPE_DOUBLE
+    TYPE_BINARY
+}
+
+struct TypeMetadata {
+  1: required string name
+  2: required t_program_id program_id
+  99: optional map<string, string> annotations
+  100: optional string doc
+}
+
+struct t_base_type {
+  1: required TypeMetadata metadata
+  2: required t_base value
+}
+
+struct t_list {
+  1: required TypeMetadata metadata
+  2: optional string cpp_name
+  3: required t_type_id elem_type
+}
+
+struct t_set {
+  1: required TypeMetadata metadata
+  2: optional string cpp_name
+  3: required t_type_id elem_type
+}
+
+struct t_map {
+  1: required TypeMetadata metadata
+  2: optional string cpp_name
+  3: required t_type_id key_type
+  4: required t_type_id val_type
+}
+
+struct t_typedef {
+  1: required TypeMetadata metadata
+  2: required t_type_id type
+  3: required string symbolic
+  4: required bool forward
+}
+
+struct t_enum_value {
+  1: required string name
+  2: required i32 value
+  99: optional map<string, string> annotations
+  100: optional string doc
+}
+struct t_enum {
+  1: required TypeMetadata metadata
+  2: required list<t_enum_value> constants
+}
+
+enum Requiredness {
+  T_REQUIRED = 0
+  T_OPTIONAL = 1
+  T_OPT_IN_REQ_OUT = 2
+}
+
+union t_const_value {
+  1: optional map<t_const_value, t_const_value> map_val
+  2: optional list<t_const_value> list_val
+  3: optional string string_val
+  4: optional i64 integer_val
+  5: optional double double_val
+  6: optional string identifier_val
+  7: optional t_type_id enum_val
+}
+struct t_const {
+  1: required string name
+  2: required t_type_id type
+  3: required t_const_value value
+  100: optional string doc
+}
+struct t_struct {
+  1: required TypeMetadata metadata
+  2: required list<t_field> members
+  3: required bool is_union
+  4: required bool is_xception
+}
+struct t_field {
+  1: required string name
+  2: required t_type_id type
+  3: required i32 key
+  4: required Requiredness req
+  5: optional t_const_value value
+  10: required bool reference
+  99: optional map<string, string> annotations
+  100: optional string doc
+}
+struct t_function {
+  1: required string name
+  2: required t_type_id returntype
+  3: required t_type_id arglist
+  4: required t_type_id xceptions
+  5: required bool is_oneway
+  100: optional string doc
+}
+struct t_service {
+  1: required TypeMetadata metadata
+  2: required list<t_function> functions
+  3: optional t_service_id extends_
+}
+union t_type {
+  1: optional t_base_type base_type_val
+  2: optional t_typedef typedef_val
+  3: optional t_enum enum_val
+  4: optional t_struct struct_val
+  5: optional t_struct xception_val
+  6: optional t_list list_val
+  7: optional t_set set_val
+  8: optional t_map map_val
+  9: optional t_service service_val
+}
+struct t_scope {
+  1: required list<t_type_id> types
+  2: required list<t_const_id> constants
+  3: required list<t_service_id> services
+}
+
+struct TypeRegistry {
+  1: required map<t_type_id, t_type> types
+  2: required map<t_const_id, t_const> constants
+  3: required map<t_service_id, t_service> services
+}
+
+struct t_program {
+  1: required string name
+  2: required t_program_id program_id
+  3: required string path
+  4: required string namespace_
+  5: required string out_path
+  6: required bool out_path_is_absolute
+  8: required list<t_program> includes
+  9: required string include_prefix
+  10: required t_scope scope
+
+  11: required list<t_type_id> typedefs
+  12: required list<t_type_id> enums
+  13: required list<t_const_id> consts
+  14: required list<t_type_id> objects
+  15: required list<t_service_id> services
+
+  16: required map<string, string> namespaces
+  17: required list<string> cpp_includes
+  18: required list<string> c_includes
+  100: optional string doc
+}
+
+struct GeneratorInput {
+  1: required t_program program
+  2: required TypeRegistry type_registry
+  3: required map<string, string> parsed_options
+}
diff --git a/compiler/cpp/src/thrift/plugin/plugin_output.cc b/compiler/cpp/src/thrift/plugin/plugin_output.cc
new file mode 100644
index 00000000000..168a4a66039
--- /dev/null
+++ b/compiler/cpp/src/thrift/plugin/plugin_output.cc
@@ -0,0 +1,410 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifdef _WIN32
+#include <cstdio>
+#include <fcntl.h>
+#include <io.h>
+#include <iostream>
+#define THRIFT_POPEN(cmd) _popen(cmd, "wb")
+#define THRIFT_PCLOSE _pclose
+#else
+#define THRIFT_POPEN(cmd) popen(cmd, "w")
+#define THRIFT_PCLOSE pclose
+#endif
+
+#include "thrift/plugin/plugin_output.h"
+
+#include <boost/range/adaptor/map.hpp>
+#include <boost/range/algorithm/copy.hpp>
+#include <boost/range/algorithm/transform.hpp>
+#include <boost/smart_ptr.hpp>
+
+#include "thrift/generate/t_generator.h"
+#include "thrift/plugin/plugin.h"
+#include "thrift/plugin/type_util.h"
+#include "thrift/protocol/TBinaryProtocol.h"
+#include "thrift/transport/TBufferTransports.h"
+#include "thrift/transport/TFDTransport.h"
+
+#include "thrift/plugin/plugin_types.h"
+
+namespace plugin_output {
+
+template <typename From>
+typename apache::thrift::plugin::ToType<From>::type convert(From* from) {
+  typename apache::thrift::plugin::ToType<From>::type to;
+  convert(from, to);
+  return to;
+}
+
+using apache::thrift::protocol::TBinaryProtocol;
+using apache::thrift::transport::TFDTransport;
+using apache::thrift::transport::TFramedTransport;
+
+using namespace apache::thrift;
+
+#define THRIFT_CONVERSION_N(from_type, to_type)                                                    \
+  template <>                                                                                      \
+  void convert<from_type, to_type>(from_type * from, to_type & to)
+#define THRIFT_CONVERSION(type) THRIFT_CONVERSION_N(::type, plugin::type)
+
+#define THRIFT_ASSIGN_N(from_name, to_name, prefix)                                                \
+  do {                                                                                             \
+    if (from)                                                                                      \
+      to.__set_##to_name(prefix(from->from_name));                                                 \
+  } while (0)
+
+#define THRIFT_ASSIGN(name) THRIFT_ASSIGN_N(get_##name(), name, )
+#define THRIFT_ASSIGN_CONVERT(type, from_name, to_name)                                            \
+  do {                                                                                             \
+    if (from && from->from_name) {                                                                 \
+      to.__set_##to_name(convert(from->from_name));                                                \
+    }                                                                                              \
+  } while (0)
+
+#define THRIFT_ASSIGN_OPT(name)                                                                    \
+  do {                                                                                             \
+    if (from->has_##name())                                                                        \
+      THRIFT_ASSIGN(name);                                                                         \
+  } while (0)
+
+#define THRIFT_ASSIGN_LIST_N(type, from_name, to_name)                                             \
+  do {                                                                                             \
+    if (from && !from->from_name.empty()) {                                                        \
+      std::transform(from->from_name.begin(),                                                      \
+                     from->from_name.end(),                                                        \
+                     std::back_inserter(to.to_name),                                               \
+                     convert< ::type>);                                                            \
+    }                                                                                              \
+  } while (0)
+
+#define THRIFT_ASSIGN_METADATA() convert(reinterpret_cast<t_type*>(from), to.metadata)
+
+// To avoid multiple instances of same type, t_type, t_const and t_service are stored in one place
+// and referenced by ID.
+template <typename T>
+struct TypeCache {
+  typedef typename plugin::ToType<T>::type to_type;
+  std::map<int64_t, to_type> cache;
+
+  template <typename T2>
+  int64_t store(T2* t) {
+    intptr_t id = reinterpret_cast<intptr_t>(t);
+    if (id) {
+      typename std::map<int64_t, to_type>::iterator it = cache.find(id);
+      if (it == cache.end()) {
+        // HACK: fake resolve for recursive type
+        cache.insert(std::make_pair(id, to_type()));
+        // overwrite with true value
+        cache[id] = convert(t);
+      }
+    }
+    return static_cast<int64_t>(id);
+  }
+
+  void clear() { cache.clear(); }
+};
+
+template <typename T>
+int64_t store_type(T* t);
+
+#define T_STORE(type)                                                                              \
+  TypeCache<t_##type> type##_cache;                                                                \
+  template <>                                                                                      \
+  plugin::t_##type##_id store_type<t_##type>(t_##type * t) {                                       \
+    return type##_cache.store<t_##type>(t);                                                        \
+  }
+T_STORE(type)
+T_STORE(const)
+T_STORE(service)
+#undef T_STORE
+
+#define THRIFT_ASSIGN_ID_N(t, from_name, to_name)                                                  \
+  do {                                                                                             \
+    if (from && from->from_name)                                                                   \
+      to.__set_##to_name(store_type<t>(from->from_name));                                          \
+  } while (0)
+
+#define THRIFT_ASSIGN_ID(name) THRIFT_ASSIGN_ID_N(t_type, get_##name(), name)
+
+#define THRIFT_ASSIGN_LIST_ID(t, name)                                                             \
+  do {                                                                                             \
+    if (from && !from->get_##name##s().empty()) {                                                  \
+      std::transform(from->get_##name##s().begin(),                                                \
+                     from->get_##name##s().end(),                                                  \
+                     std::back_inserter(to.name##s),                                               \
+                     &store_type<t>);                                                              \
+    }                                                                                              \
+  } while (0)
+
+THRIFT_CONVERSION_N(::t_type, plugin::TypeMetadata) {
+  to.program_id = reinterpret_cast<int64_t>(from->get_program());
+  THRIFT_ASSIGN_N(annotations_, annotations, );
+  if (from->has_doc()) {
+    to.__set_doc(from->get_doc());
+  }
+  THRIFT_ASSIGN(name);
+}
+
+THRIFT_CONVERSION(t_typedef) {
+  THRIFT_ASSIGN_METADATA();
+  THRIFT_ASSIGN_ID(type);
+  THRIFT_ASSIGN(symbolic);
+  THRIFT_ASSIGN_N(is_forward_typedef(), forward, );
+}
+
+THRIFT_CONVERSION(t_enum_value) {
+  THRIFT_ASSIGN_OPT(doc);
+  THRIFT_ASSIGN(name);
+  THRIFT_ASSIGN(value);
+}
+
+THRIFT_CONVERSION(t_enum) {
+  THRIFT_ASSIGN_METADATA();
+  THRIFT_ASSIGN_LIST_N(t_enum_value, get_constants(), constants);
+}
+
+THRIFT_CONVERSION(t_const_value) {
+  switch (from->get_type()) {
+  case t_const_value::CV_INTEGER:
+    THRIFT_ASSIGN_N(get_integer(), integer_val, );
+    break;
+  case t_const_value::CV_DOUBLE:
+    THRIFT_ASSIGN_N(get_double(), double_val, );
+    break;
+  case t_const_value::CV_STRING:
+    THRIFT_ASSIGN_N(get_string(), string_val, );
+    break;
+  case t_const_value::CV_IDENTIFIER:
+    THRIFT_ASSIGN_ID_N(t_type, enum_, enum_val);
+    THRIFT_ASSIGN_N(get_identifier(), identifier_val, );
+    break;
+  case t_const_value::CV_MAP:
+    to.__isset.map_val = true;
+    if (from && !from->get_map().empty()) {
+      for (std::map< ::t_const_value*, ::t_const_value*>::const_iterator it
+           = from->get_map().begin();
+           it != from->get_map().end();
+           it++) {
+        to.map_val.insert(std::make_pair(convert(it->first), convert(it->second)));
+      }
+    }
+    break;
+  case t_const_value::CV_LIST:
+    to.__isset.list_val = true;
+    THRIFT_ASSIGN_LIST_N(t_const_value, get_list(), list_val);
+    break;
+  default:
+    throw plugin::ThriftPluginError("const value has no value");
+  }
+}
+THRIFT_CONVERSION(t_const) {
+  THRIFT_ASSIGN_OPT(doc);
+  THRIFT_ASSIGN(name);
+  THRIFT_ASSIGN_ID(type);
+  THRIFT_ASSIGN_CONVERT(t_const_value, get_value(), value);
+}
+THRIFT_CONVERSION(t_field) {
+  THRIFT_ASSIGN_OPT(doc);
+  THRIFT_ASSIGN(name);
+  THRIFT_ASSIGN(key);
+  THRIFT_ASSIGN_N(get_req(), req, (plugin::Requiredness::type));
+  THRIFT_ASSIGN(reference);
+  THRIFT_ASSIGN_ID(type);
+  THRIFT_ASSIGN_CONVERT(t_const_value, get_value(), value);
+}
+THRIFT_CONVERSION(t_struct) {
+  THRIFT_ASSIGN_METADATA();
+  THRIFT_ASSIGN_LIST_N(t_field, get_members(), members);
+  THRIFT_ASSIGN_N(is_union(), is_union, );
+  THRIFT_ASSIGN_N(is_xception(), is_xception, );
+}
+THRIFT_CONVERSION(t_function) {
+  THRIFT_ASSIGN_OPT(doc);
+  THRIFT_ASSIGN(name);
+  THRIFT_ASSIGN_ID(returntype);
+  THRIFT_ASSIGN_N(is_oneway(), is_oneway, );
+  THRIFT_ASSIGN_ID(arglist);
+  THRIFT_ASSIGN_ID(xceptions);
+}
+
+THRIFT_CONVERSION(t_list) {
+  THRIFT_ASSIGN_METADATA();
+  THRIFT_ASSIGN_OPT(cpp_name);
+  THRIFT_ASSIGN_ID(elem_type);
+}
+THRIFT_CONVERSION(t_set) {
+  THRIFT_ASSIGN_METADATA();
+  THRIFT_ASSIGN_OPT(cpp_name);
+  THRIFT_ASSIGN_ID(elem_type);
+}
+THRIFT_CONVERSION(t_map) {
+  THRIFT_ASSIGN_METADATA();
+  THRIFT_ASSIGN_OPT(cpp_name);
+  THRIFT_ASSIGN_ID(key_type);
+  THRIFT_ASSIGN_ID(val_type);
+}
+
+THRIFT_CONVERSION(t_service) {
+  THRIFT_ASSIGN_METADATA();
+  THRIFT_ASSIGN_LIST_N(t_function, get_functions(), functions);
+  THRIFT_ASSIGN_ID_N(t_service, get_extends(), extends_);
+}
+
+THRIFT_CONVERSION(t_base_type) {
+  THRIFT_ASSIGN_METADATA();
+  if (from->is_binary()) {
+    to.value = plugin::t_base::TYPE_BINARY;
+  } else {
+    switch (from->get_base()) {
+#define T_BASETYPE_CASE(name)                                                                      \
+  case t_base_type::TYPE_##name:                                                                   \
+    to.value = plugin::t_base::TYPE_##name;                                                        \
+    break
+      T_BASETYPE_CASE(VOID);
+      T_BASETYPE_CASE(STRING);
+      T_BASETYPE_CASE(BOOL);
+      T_BASETYPE_CASE(I8);
+      T_BASETYPE_CASE(I16);
+      T_BASETYPE_CASE(I32);
+      T_BASETYPE_CASE(I64);
+      T_BASETYPE_CASE(DOUBLE);
+    default:
+      throw plugin::ThriftPluginError("Base type union has no value");
+      break;
+#undef T_BASETYPE_CASE
+    }
+  }
+}
+THRIFT_CONVERSION(t_type) {
+#define T_CONVERT_UNION_N(name, type)                                                              \
+  else if (from->is_##name()) {                                                                    \
+    to.__isset.name##_val = true;                                                                  \
+    convert(reinterpret_cast< ::type*>(from), to.name##_val);                                      \
+  }
+#define T_CONVERT_UNION(name) T_CONVERT_UNION_N(name, t_##name)
+  if (false) {
+  }
+  T_CONVERT_UNION(base_type)
+  T_CONVERT_UNION(typedef)
+  T_CONVERT_UNION(enum)
+  T_CONVERT_UNION(struct)
+  T_CONVERT_UNION_N(xception, t_struct)
+  T_CONVERT_UNION(list)
+  T_CONVERT_UNION(set)
+  T_CONVERT_UNION(map)
+  T_CONVERT_UNION(service)
+  else {
+    throw plugin::ThriftPluginError("Type union has no value");
+  }
+#undef T_CONVERT_UNION_N
+#undef T_CONVERT_UNION
+}
+
+THRIFT_CONVERSION(t_scope) {
+#define T_SCOPE_ASSIGN(name, type)                                                                 \
+  boost::copy(from->name##s_ | boost::adaptors::map_values                                         \
+              | boost::adaptors::transformed(&store_type<type>),                                   \
+              std::back_inserter(to.name##s))
+  T_SCOPE_ASSIGN(type, t_type);
+  T_SCOPE_ASSIGN(constant, t_const);
+  T_SCOPE_ASSIGN(service, t_service);
+#undef T_SCOPE_ASSIGN
+}
+
+void get_global_cache(plugin::TypeRegistry& reg) {
+  reg.types = type_cache.cache;
+  reg.constants = const_cache.cache;
+  reg.services = service_cache.cache;
+}
+
+void clear_global_cache() {
+  type_cache.clear();
+  const_cache.clear();
+  service_cache.clear();
+}
+
+THRIFT_CONVERSION(t_program) {
+  THRIFT_ASSIGN_CONVERT(t_scope, scope(), scope);
+  THRIFT_ASSIGN(path);
+  THRIFT_ASSIGN(out_path);
+  THRIFT_ASSIGN(name);
+  THRIFT_ASSIGN(include_prefix);
+  THRIFT_ASSIGN(cpp_includes);
+  THRIFT_ASSIGN(c_includes);
+  THRIFT_ASSIGN(namespaces);
+  THRIFT_ASSIGN_N(is_out_path_absolute(), out_path_is_absolute, );
+  THRIFT_ASSIGN_N(get_namespace(), namespace_, );
+  THRIFT_ASSIGN_LIST_ID(t_type, typedef);
+  THRIFT_ASSIGN_LIST_ID(t_type, enum);
+  THRIFT_ASSIGN_LIST_ID(t_type, object);
+  THRIFT_ASSIGN_LIST_ID(t_const, const);
+  THRIFT_ASSIGN_LIST_ID(t_service, service);
+  THRIFT_ASSIGN_LIST_N(t_program, get_includes(), includes);
+  to.program_id = reinterpret_cast<plugin::t_program_id>(from);
+}
+
+PluginDelegateResult delegateToPlugin(t_program* program, const std::string& options) {
+  std::string language;
+  std::map<std::string, std::string> parsed_options;
+  t_generator::parse_options(options, language, parsed_options);
+  std::string cmd = "thrift-gen-";
+  if (language.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-0123456789")
+      != std::string::npos) {
+    std::cerr << "Invalid language name" << std::endl;
+    return PLUGIN_FAILURE;
+  }
+  cmd.append(language);
+  FILE* fd = THRIFT_POPEN(cmd.c_str());
+  if (fd) {
+#ifdef _WIN32
+    _setmode(fileno(fd), _O_BINARY);
+#endif
+    boost::shared_ptr<TFramedTransport> transport(
+        new TFramedTransport(boost::make_shared<TFDTransport>(fileno(fd))));
+    TBinaryProtocol proto(transport);
+
+    plugin::GeneratorInput input;
+    input.__set_parsed_options(parsed_options);
+    clear_global_cache();
+    convert(program, input.program);
+    get_global_cache(input.type_registry);
+    try {
+      input.write(&proto);
+      transport->flush();
+    } catch (std::exception& err) {
+      std::cerr << "Error while sending data to plugin: " << err.what() << std::endl;
+      THRIFT_PCLOSE(fd);
+      return PLUGIN_FAILURE;
+    }
+
+    // TODO: be prepared for hang or crash of child process
+    int ret = THRIFT_PCLOSE(fd);
+    if (!ret) {
+      return PLUGIN_SUCCEESS;
+    } else {
+      std::cerr << "plugin process returned non zero exit code: " << ret << std::endl;
+      return PLUGIN_FAILURE;
+    }
+  }
+  clear_global_cache();
+  return PLUGIN_NOT_FOUND;
+}
+}
diff --git a/compiler/cpp/src/thrift/plugin/plugin_output.h b/compiler/cpp/src/thrift/plugin/plugin_output.h
new file mode 100644
index 00000000000..eab2d1bfcde
--- /dev/null
+++ b/compiler/cpp/src/thrift/plugin/plugin_output.h
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifndef T_PLUGIN_PLUGIN_OUTPUT_H
+#define T_PLUGIN_PLUGIN_OUTPUT_H
+
+#include <string>
+
+class t_program;
+
+namespace plugin_output {
+
+enum PluginDelegateResult {
+  PLUGIN_NOT_FOUND,
+  PLUGIN_FAILURE,
+  PLUGIN_SUCCEESS,
+};
+
+PluginDelegateResult delegateToPlugin(t_program* program, const std::string& options);
+}
+
+#endif
diff --git a/compiler/cpp/src/thrift/plugin/type_util.h b/compiler/cpp/src/thrift/plugin/type_util.h
new file mode 100644
index 00000000000..508b7418115
--- /dev/null
+++ b/compiler/cpp/src/thrift/plugin/type_util.h
@@ -0,0 +1,94 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#ifndef T_PLUGIN_TYPE_UTIL_H
+#define T_PLUGIN_TYPE_UTIL_H
+
+namespace apache {
+namespace thrift {
+namespace plugin {
+
+template <typename From>
+struct ToType {};
+
+template <typename From>
+typename ToType<From>::type* convert_forward(const From&);
+
+template <typename From, typename To>
+void convert(const From&, To*);
+
+template <typename From>
+typename ToType<From>::type* convert(const From& from);
+
+class TypeRegistry;
+void set_global_cache(const TypeRegistry&);
+}
+}
+}
+
+// conversion from raw compiler types to plugin wire type
+namespace plugin_output {
+
+template <typename From, typename To>
+void convert(From* from, To& to);
+
+template <typename From>
+typename apache::thrift::plugin::ToType<From>::type convert(From* from);
+
+void get_global_cache(apache::thrift::plugin::TypeRegistry&);
+void clear_global_cache();
+}
+
+#define THRIFT_TYPE_MAPPING(TYPE)                                                                  \
+  class TYPE;                                                                                      \
+  namespace apache {                                                                               \
+  namespace thrift {                                                                               \
+  namespace plugin {                                                                               \
+  class TYPE;                                                                                      \
+  template <>                                                                                      \
+  struct ToType< ::TYPE> {                                                                         \
+    typedef TYPE type;                                                                             \
+  };                                                                                               \
+  template <>                                                                                      \
+  struct ToType<TYPE> {                                                                            \
+    typedef ::TYPE type;                                                                           \
+  };                                                                                               \
+  }                                                                                                \
+  }                                                                                                \
+  }
+THRIFT_TYPE_MAPPING(t_base_type)
+THRIFT_TYPE_MAPPING(t_const)
+THRIFT_TYPE_MAPPING(t_const_value)
+THRIFT_TYPE_MAPPING(t_container)
+THRIFT_TYPE_MAPPING(t_doc)
+THRIFT_TYPE_MAPPING(t_enum)
+THRIFT_TYPE_MAPPING(t_enum_value)
+THRIFT_TYPE_MAPPING(t_field)
+THRIFT_TYPE_MAPPING(t_function)
+THRIFT_TYPE_MAPPING(t_list)
+THRIFT_TYPE_MAPPING(t_map)
+THRIFT_TYPE_MAPPING(t_program)
+THRIFT_TYPE_MAPPING(t_scope)
+THRIFT_TYPE_MAPPING(t_service)
+THRIFT_TYPE_MAPPING(t_set)
+THRIFT_TYPE_MAPPING(t_struct)
+THRIFT_TYPE_MAPPING(t_type)
+THRIFT_TYPE_MAPPING(t_typedef)
+#undef THRIFT_TYPE_MAPPING
+#endif
diff --git a/compiler/cpp/src/thriftl.ll b/compiler/cpp/src/thrift/thriftl.ll
similarity index 98%
rename from compiler/cpp/src/thriftl.ll
rename to compiler/cpp/src/thrift/thriftl.ll
index 5c3187d9676..bf7e8a56ca7 100644
--- a/compiler/cpp/src/thriftl.ll
+++ b/compiler/cpp/src/thrift/thriftl.ll
@@ -53,20 +53,21 @@
 #include <stdlib.h>
 
 #ifdef _MSC_VER
-#include "windows/config.h"
+#include "thrift/windows/config.h"
 #endif
-#include "main.h"
-#include "globals.h"
-#include "parse/t_program.h"
+#include "thrift/main.h"
+#include "thrift/common.h"
+#include "thrift/globals.h"
+#include "thrift/parse/t_program.h"
 
 /**
  * Must be included AFTER parse/t_program.h, but I can't remember why anymore
  * because I wrote this a while ago.
  */
 #if defined(BISON_USE_PARSER_H_EXTENSION)
-#include "thrifty.h"
+#include "thrift/thrifty.h"
 #else
-#include "thrifty.hh"
+#include "thrift/thrifty.hh"
 #endif
 
 void thrift_reserved_keyword(char* keyword) {
@@ -222,7 +223,7 @@ literal_begin (['\"])
 "include"            { return tok_include;              }
 "void"               { return tok_void;                 }
 "bool"               { return tok_bool;                 }
-"byte"               { 
+"byte"               {
   emit_byte_type_warning();
   return tok_i8;
 }
diff --git a/compiler/cpp/src/thrifty.yy b/compiler/cpp/src/thrift/thrifty.yy
similarity index 99%
rename from compiler/cpp/src/thrifty.yy
rename to compiler/cpp/src/thrift/thrifty.yy
index 292670d5958..b7a7f72e7ec 100644
--- a/compiler/cpp/src/thrifty.yy
+++ b/compiler/cpp/src/thrift/thrifty.yy
@@ -35,12 +35,13 @@
 #endif
 #include <limits.h>
 #ifdef _MSC_VER
-#include "windows/config.h"
+#include "thrift/windows/config.h"
 #endif
-#include "main.h"
-#include "globals.h"
-#include "parse/t_program.h"
-#include "parse/t_scope.h"
+#include "thrift/main.h"
+#include "thrift/common.h"
+#include "thrift/globals.h"
+#include "thrift/parse/t_program.h"
+#include "thrift/parse/t_scope.h"
 
 #ifdef _MSC_VER
 //warning C4065: switch statement contains 'default' but no 'case' labels
diff --git a/compiler/cpp/version.h.in b/compiler/cpp/src/thrift/version.h.in
similarity index 100%
rename from compiler/cpp/version.h.in
rename to compiler/cpp/src/thrift/version.h.in
diff --git a/compiler/cpp/src/windows/config.h b/compiler/cpp/src/thrift/windows/config.h
similarity index 100%
rename from compiler/cpp/src/windows/config.h
rename to compiler/cpp/src/thrift/windows/config.h
diff --git a/compiler/cpp/src/windows/version.h.in b/compiler/cpp/src/thrift/windows/version.h.in
similarity index 100%
rename from compiler/cpp/src/windows/version.h.in
rename to compiler/cpp/src/thrift/windows/version.h.in
diff --git a/compiler/cpp/test/CMakeLists.txt b/compiler/cpp/test/CMakeLists.txt
new file mode 100644
index 00000000000..c1fe914c378
--- /dev/null
+++ b/compiler/cpp/test/CMakeLists.txt
@@ -0,0 +1,77 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements. See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership. The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License. You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied. See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+
+if(${WITH_PLUGIN})
+    include_directories(SYSTEM "${Boost_INCLUDE_DIRS}")
+
+    # Make sure gen-cpp files can be included
+    include_directories("${CMAKE_CURRENT_BINARY_DIR}")
+
+    set(plugintest_SOURCES
+        plugin/conversion_test.cc
+    )
+    add_executable(plugintest ${plugintest_SOURCES})
+    if(WITH_SHARED_LIB AND NOT MSVC)
+        target_link_libraries(plugintest
+            thriftc
+            ${Boost_LIBRARIES}
+        )
+    else()
+        target_link_libraries(plugintest
+            thriftc_static
+            thrift_static
+            ${Boost_LIBRARIES}
+        )
+    endif()
+    add_test(NAME PluginUnitTest COMMAND plugintest)
+
+    set(thrift-gen-mycpp_SOURCES
+        ../src/thrift/generate/t_cpp_generator.cc
+        plugin/cpp_plugin.cc
+    )
+    add_executable(thrift-gen-mycpp ${thrift-gen-mycpp_SOURCES})
+    if(WITH_SHARED_LIB AND NOT MSVC)
+        target_link_libraries(thrift-gen-mycpp thriftc)
+    else()
+        target_link_libraries(thrift-gen-mycpp thriftc_static thrift_static)
+    endif()
+
+    if(CMAKE_BUILD_TYPE STREQUAL "Debug")
+        set(BUILDTYPE "Debug")
+    else()
+        # RelWithDebInfo generates binaries in "Release" directory too
+        set(BUILDTYPE "Release")
+    endif()
+
+    set_directory_properties(PROPERTIES
+        ADDITIONAL_MAKE_CLEAN_FILES gen-cpp
+        ADDITIONAL_MAKE_CLEAN_FILES gen-mycpp)
+
+    file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/gen-cpp)
+    file(MAKE_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/gen-mycpp)
+    add_test(NAME PluginIntegrationTest
+             COMMAND ${CMAKE_COMMAND}
+                 -DTHRIFT_COMPILER=${THRIFT_COMPILER}
+                 -DBINDIR=${CMAKE_RUNTIME_OUTPUT_DIRECTORY}
+                 -DBUILDTYPE=${BUILDTYPE}
+                 -DCURDIR=${CMAKE_CURRENT_BINARY_DIR}
+                 -DSRCDIR=${CMAKE_CURRENT_SOURCE_DIR}
+                 -P ${CMAKE_CURRENT_SOURCE_DIR}/cpp_plugin_test.cmake)
+endif()
diff --git a/compiler/cpp/test/Makefile.am b/compiler/cpp/test/Makefile.am
new file mode 100644
index 00000000000..5a232029a00
--- /dev/null
+++ b/compiler/cpp/test/Makefile.am
@@ -0,0 +1,51 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements. See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership. The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License. You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied. See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+#
+# Contains some contributions under the Thrift Software License.
+# Please see doc/old-thrift-license.txt in the Thrift distribution for
+# details.
+
+AUTOMAKE_OPTIONS = subdir-objects serial-tests
+
+AM_CPPFLAGS = $(BOOST_CPPFLAGS) -I$(top_srcdir)/compiler/cpp/src
+AM_LDFLAGS = $(BOOST_LDFLAGS)
+AM_CXXFLAGS = -Wall -Wextra -pedantic
+
+if WITH_PLUGIN
+check_PROGRAMS = plugintest
+
+noinst_PROGRAMS = thrift-gen-mycpp
+
+AM_CPPFLAGS += -I$(top_srcdir)/lib/cpp/src -I$(top_builddir)/lib/cpp/src
+
+plugintest_SOURCES = plugin/conversion_test.cc
+plugintest_LDADD = $(top_builddir)/compiler/cpp/libthriftc.la
+
+thrift_gen_mycpp_SOURCES = plugin/cpp_plugin.cc \
+                           plugin/t_cpp_generator.cc
+thrift_gen_mycpp_CPPFLAGS = $(AM_CPPFLAGS) -I$(top_srcdir)/compiler/cpp -I$(top_srcdir)/compiler/cpp/src/generate
+thrift_gen_mycpp_LDADD = $(top_builddir)/compiler/cpp/libthriftc.la
+
+cpp_plugin_test.sh: thrift-gen-mycpp
+TESTS = $(check_PROGRAMS) cpp_plugin_test.sh
+
+clean-local:
+	$(RM) -rf gen-cpp gen-mycpp
+
+endif
diff --git a/compiler/cpp/test/cpp_plugin_test.cmake b/compiler/cpp/test/cpp_plugin_test.cmake
new file mode 100644
index 00000000000..fd182818d1b
--- /dev/null
+++ b/compiler/cpp/test/cpp_plugin_test.cmake
@@ -0,0 +1,45 @@
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements. See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership. The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License. You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied. See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+file(MAKE_DIRECTORY ${CURDIR}/gen-cpp)
+execute_process(COMMAND ${THRIFT_COMPILER} -r -out ${CURDIR}/gen-cpp -gen cpp ${SRCDIR}/../../../test/Include.thrift)
+if(EXITCODE)
+  message(FATAL_ERROR "FAILED: \"${ARGV}\": \"${EXITCODE}\"")
+endif()
+if(WIN32)
+    set(ENV{PATH} "${BINDIR}/${BUILDTYPE};${BINDIR};$ENV{PATH}")
+else()
+    set(ENV{PATH} "${BINDIR}:$ENV{PATH}")
+endif()
+
+file(MAKE_DIRECTORY ${CURDIR}/gen-mycpp)
+execute_process(COMMAND ${THRIFT_COMPILER} -r -out ${CURDIR}/gen-mycpp -gen mycpp ${SRCDIR}/../../../test/Include.thrift RESULT_VARIABLE EXITCODE)
+if(EXITCODE)
+  message(FATAL_ERROR "FAILED: \"${EXITCODE}\"")
+endif()
+
+find_program(DIFF diff)
+if(DIFF)
+  execute_process(COMMAND ${DIFF} -urN gen-cpp gen-mycpp RESULT_VARIABLE EXITCODE)
+  if(EXITCODE)
+    message(FATAL_ERROR "FAILED: \"${EXITCODE}\"")
+  endif()
+else()
+    message(WARNING "diff executable is not available. Not validating plugin-generated code.")
+endif()
diff --git a/compiler/cpp/test/cpp_plugin_test.sh b/compiler/cpp/test/cpp_plugin_test.sh
new file mode 100755
index 00000000000..ddb2e0a0923
--- /dev/null
+++ b/compiler/cpp/test/cpp_plugin_test.sh
@@ -0,0 +1,27 @@
+#!/bin/sh
+
+#
+# Licensed to the Apache Software Foundation (ASF) under one
+# or more contributor license agreements. See the NOTICE file
+# distributed with this work for additional information
+# regarding copyright ownership. The ASF licenses this file
+# to you under the Apache License, Version 2.0 (the
+# "License"); you may not use this file except in compliance
+# with the License. You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing,
+# software distributed under the License is distributed on an
+# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+# KIND, either express or implied. See the License for the
+# specific language governing permissions and limitations
+# under the License.
+#
+
+# this file is intended to be invoked by make.
+set -e
+mkdir -p gen-cpp gen-mycpp
+PATH=.:"$PATH" ../thrift -r -out gen-cpp -gen cpp ../../../test/Include.thrift
+PATH=.:"$PATH" ../thrift -r -out gen-mycpp -gen mycpp ../../../test/Include.thrift
+diff -urN gen-cpp gen-mycpp
diff --git a/compiler/cpp/test/plugin/conversion_test.cc b/compiler/cpp/test/plugin/conversion_test.cc
new file mode 100644
index 00000000000..2eba3ca1ec4
--- /dev/null
+++ b/compiler/cpp/test/plugin/conversion_test.cc
@@ -0,0 +1,496 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include "thrift/parse/t_program.h"
+#include "thrift/plugin/plugin_types.h"
+#include "thrift/plugin/type_util.h"
+
+#include <map>
+#include <vector>
+
+#include <boost/preprocessor.hpp>
+#include <boost/test/included/unit_test.hpp>
+#include <boost/test/parameterized_test.hpp>
+
+using namespace apache::thrift;
+using namespace boost::unit_test;
+
+namespace test_data {
+#define T_TEST_TYPES                                                                               \
+  BOOST_PP_TUPLE_TO_LIST(14,                                                                       \
+                         (program,                                                                 \
+                          base_type,                                                               \
+                          enum_value,                                                              \
+                          enum,                                                                    \
+                          const_value,                                                             \
+                          const,                                                                   \
+                          list,                                                                    \
+                          set,                                                                     \
+                          map,                                                                     \
+                          field,                                                                   \
+                          struct,                                                                  \
+                          typedef,                                                                 \
+                          function,                                                                \
+                          service))
+#define T_DELETE_TESTDATA(r, d, elem)                                                              \
+  for (std::vector<t_##elem*>::reverse_iterator it = elem##s.rbegin(); it != elem##s.rend(); it++) \
+    delete *it;
+#define T_DECL_TESTDATA(r, d, elem) static std::vector< ::t_##elem*> elem##s;
+BOOST_PP_LIST_FOR_EACH(T_DECL_TESTDATA, _, T_TEST_TYPES)
+#undef T_DECL_TESTDATA
+
+bool has_data = false;
+void cleanup() {
+  if (has_data) {
+    has_data = false;
+    BOOST_PP_LIST_FOR_EACH(T_DELETE_TESTDATA, _, T_TEST_TYPES)
+  }
+}
+
+void init_programs() {
+  programs.push_back(new t_program("prog path", "prog_name"));
+}
+
+void init_base_types() {
+  base_types.push_back(new ::t_base_type("name0", ::t_base_type::TYPE_VOID));
+  base_types.push_back(new ::t_base_type("name1", ::t_base_type::TYPE_STRING));
+  base_types.push_back(new ::t_base_type("name2", ::t_base_type::TYPE_BOOL));
+  base_types.push_back(new ::t_base_type("name3", ::t_base_type::TYPE_I8));
+  base_types.push_back(new ::t_base_type("name4", ::t_base_type::TYPE_I16));
+  base_types.push_back(new ::t_base_type("name5", ::t_base_type::TYPE_I32));
+  base_types.push_back(new ::t_base_type("name6", ::t_base_type::TYPE_I64));
+  base_types.push_back(new ::t_base_type("name7", ::t_base_type::TYPE_DOUBLE));
+}
+
+void init_const_values() {
+  const_values.push_back(new t_const_value(42));
+  const_values.push_back(new t_const_value("foo"));
+  {
+    t_const_value* x = new t_const_value;
+    x->set_double(3.1415);
+    const_values.push_back(x);
+  }
+  {
+    t_const_value* x = new t_const_value;
+    x->set_identifier("bar");
+    x->set_enum(enums[0]);
+    const_values.push_back(x);
+  }
+  {
+    t_const_value* x = new t_const_value;
+    x->set_map();
+    x->add_map(const_values[0], const_values[1]);
+    x->add_map(const_values[1], const_values[0]);
+    const_values.push_back(x);
+  }
+  {
+    t_const_value* x = new t_const_value;
+    x->set_list();
+    x->add_list(const_values[0]);
+    x->add_list(const_values[1]);
+    const_values.push_back(x);
+  }
+}
+
+void init_consts() {
+  // base_type/enum indexes for this and other tests are arbitrary
+  consts.push_back(new t_const(base_types[2], "aaa", const_values[0]));
+  consts.back()->set_doc("soem doc");
+  consts.push_back(new t_const(base_types[3], "bbb", const_values[1]));
+}
+
+void init_enum_values() {
+  enum_values.push_back(new t_enum_value("VAL1", 11));
+  enum_values.back()->set_doc("enum doc 1");
+  enum_values.back()->annotations_.insert(std::make_pair("anno1", "val1"));
+
+  enum_values.push_back(new t_enum_value("VAL2", 22));
+}
+
+void init_enums() {
+  enums.push_back(new t_enum(programs[0]));
+  enums.back()->set_doc("enum doc 1");
+  enums.back()->annotations_.insert(std::make_pair("anno1", "val1"));
+  enums.back()->set_name("fooo");
+  enums.back()->append(enum_values[0]);
+  enums.back()->append(enum_values[1]);
+}
+
+void init_lists() {
+  lists.push_back(new t_list(enums[0]));
+  lists.push_back(new t_list(base_types[5]));
+  lists.back()->set_cpp_name("list_cpp_name_1");
+}
+void init_sets() {
+  sets.push_back(new t_set(base_types[4]));
+  sets.push_back(new t_set(enums[0]));
+  sets.back()->set_cpp_name("set_cpp_name_1");
+}
+void init_maps() {
+  maps.push_back(new t_map(base_types[4], base_types[1]));
+  maps.push_back(new t_map(base_types[5], enums[0]));
+  maps.back()->set_cpp_name("map_cpp_name_1");
+}
+
+void init_typedefs() {
+  typedefs.push_back(new t_typedef(programs[0], base_types[3], "VAL1"));
+}
+void init_fields() {
+  fields.push_back(new t_field(base_types[1], "f1"));
+  fields.back()->set_reference(false);
+  fields.back()->set_req(t_field::T_OPTIONAL);
+  fields.push_back(new t_field(base_types[2], "f2", 9));
+  fields.back()->set_reference(true);
+  fields.push_back(new t_field(base_types[3], "f3", 11));
+  fields.back()->set_req(t_field::T_REQUIRED);
+  fields.back()->set_value(const_values[0]);
+}
+void init_structs() {
+  structs.push_back(new t_struct(programs[0], "struct1"));
+  structs.back()->append(fields[0]);
+  structs.back()->append(fields[1]);
+  structs.push_back(new t_struct(programs[0], "union1"));
+  structs.back()->append(fields[0]);
+  structs.back()->append(fields[1]);
+  structs.back()->set_union(true);
+  structs.push_back(new t_struct(programs[0], "xcept1"));
+  structs.back()->set_xception(true);
+}
+void init_functions() {
+  structs.push_back(new t_struct(programs[0], "errs1"));
+  t_struct* errors = structs.back();
+  structs.push_back(new t_struct(programs[0], "args1"));
+  t_struct* arglist = structs.back();
+  functions.push_back(new t_function(base_types[0], "func1", errors, arglist, false));
+  functions.push_back(new t_function(base_types[0], "func2", errors, arglist, true));
+}
+void init_services() {
+  services.push_back(new t_service(programs[0]));
+  services.back()->set_doc("srv1 doc");
+  services.back()->set_name("srv1");
+  services.back()->add_function(functions[0]);
+  services.back()->add_function(functions[1]);
+
+  services.push_back(new t_service(programs[0]));
+  services.back()->set_name("srv2");
+  services.back()->set_extends(services[0]);
+}
+
+std::vector<t_type*> types;
+void init_types() {
+#define T_COPY_TYPES(type) std::copy(type##s.begin(), type##s.end(), std::back_inserter(types))
+  T_COPY_TYPES(base_type);
+  T_COPY_TYPES(enum);
+  T_COPY_TYPES(typedef);
+  T_COPY_TYPES(struct);
+  T_COPY_TYPES(list);
+  T_COPY_TYPES(set);
+  T_COPY_TYPES(map);
+// T_COPY_TYPES(service);
+#undef T_COPY_TYPES
+}
+
+void init() {
+  if (!has_data) {
+    has_data = true;
+#define T_INIT_TESTDATA(r, d, elem) init_##elem##s();
+    BOOST_PP_LIST_FOR_EACH(T_INIT_TESTDATA, _, T_TEST_TYPES)
+    init_types();
+#undef T_INIT_TESTDATA
+  }
+}
+}
+struct GlobalFixture {
+  ~GlobalFixture() { test_data::cleanup(); }
+};
+#if (BOOST_VERSION >= 105900)
+BOOST_GLOBAL_FIXTURE(GlobalFixture);
+#else
+BOOST_GLOBAL_FIXTURE(GlobalFixture)
+#endif
+
+void migrate_global_cache() {
+  plugin::TypeRegistry reg;
+  plugin_output::get_global_cache(reg);
+  plugin::set_global_cache(reg);
+  plugin_output::clear_global_cache();
+}
+template <typename T>
+T* round_trip(T* t) {
+  typename plugin::ToType<T>::type p;
+  plugin_output::convert(t, p);
+  migrate_global_cache();
+  return plugin::convert(p);
+}
+
+void test_base_type(::t_base_type* sut) {
+  plugin::t_base_type p;
+  plugin_output::convert(sut, p);
+  boost::scoped_ptr< ::t_base_type> sut2(plugin::convert(p));
+
+#define THRIFT_CHECK(r, data, elem) BOOST_PP_EXPAND(BOOST_CHECK_EQUAL(data elem, sut2->elem));
+  BOOST_PP_LIST_FOR_EACH(THRIFT_CHECK,
+                         sut->,
+                         BOOST_PP_TUPLE_TO_LIST(7,
+                                                (is_void(),
+                                                 is_string(),
+                                                 is_bool(),
+                                                 is_string_list(),
+                                                 is_binary(),
+                                                 is_string_enum(),
+                                                 is_base_type())))
+}
+
+void test_const_value(t_const_value* sut) {
+  boost::scoped_ptr<t_const_value> sut2(round_trip(sut));
+
+  BOOST_CHECK_EQUAL(sut->get_type(), sut2->get_type());
+  switch (sut->get_type()) {
+#define T_CONST_VALUE_CASE(type, name)                                                             \
+  case t_const_value::type:                                                                        \
+    BOOST_CHECK_EQUAL(sut->get_##name(), sut2->get_##name());                                      \
+    break
+    T_CONST_VALUE_CASE(CV_INTEGER, integer);
+    T_CONST_VALUE_CASE(CV_DOUBLE, double);
+    T_CONST_VALUE_CASE(CV_STRING, string);
+    T_CONST_VALUE_CASE(CV_IDENTIFIER, identifier);
+#undef T_CONST_VALUE_CASE
+  case t_const_value::CV_MAP:
+    BOOST_CHECK_EQUAL(sut->get_map().size(), sut2->get_map().size());
+    {
+      std::map<t_const_value::t_const_value_type, t_const_value::t_const_value_type> sut_values;
+      for (std::map<t_const_value*, t_const_value*>::const_iterator it = sut->get_map().begin();
+           it != sut->get_map().end(); it++) {
+        sut_values[it->first->get_type()] = it->second->get_type();
+      }
+      std::map<t_const_value::t_const_value_type, t_const_value::t_const_value_type> sut2_values;
+      for (std::map<t_const_value*, t_const_value*>::const_iterator it = sut2->get_map().begin();
+           it != sut2->get_map().end(); it++) {
+        sut2_values[it->first->get_type()] = it->second->get_type();
+      }
+      BOOST_CHECK_EQUAL(sut_values.begin()->first, sut2_values.begin()->first);
+      BOOST_CHECK_EQUAL(sut_values.begin()->second, sut2_values.begin()->second);
+    }
+    break;
+  case t_const_value::CV_LIST:
+    BOOST_CHECK_EQUAL(sut->get_list().size(), sut2->get_list().size());
+    BOOST_CHECK_EQUAL(sut->get_list().front()->get_type(), sut2->get_list().front()->get_type());
+    break;
+  default:
+    BOOST_ASSERT(false);
+    break;
+  }
+}
+
+void test_const(t_const* sut) {
+  boost::scoped_ptr< ::t_const> sut2(round_trip(sut));
+
+  BOOST_PP_LIST_FOR_EACH(THRIFT_CHECK,
+                         sut->,
+                         BOOST_PP_TUPLE_TO_LIST(4,
+                                                (get_type()->get_name(),
+                                                 get_name(),
+                                                 get_value()->get_type(),
+                                                 get_doc())))
+}
+
+void test_enum_value(t_enum_value* sut) {
+  boost::scoped_ptr<t_enum_value> sut2(round_trip(sut));
+
+  BOOST_PP_LIST_FOR_EACH(THRIFT_CHECK,
+                         sut->,
+                         BOOST_PP_TUPLE_TO_LIST(3, (get_name(), get_value(), get_doc())))
+}
+
+void test_enum(t_enum* sut) {
+  boost::scoped_ptr< ::t_enum> sut2(round_trip(sut));
+
+  BOOST_PP_LIST_FOR_EACH(THRIFT_CHECK,
+                         sut->,
+                         BOOST_PP_TUPLE_TO_LIST(6,
+                                                (get_name(),
+                                                 get_min_value()->get_value(),
+                                                 get_max_value()->get_value(),
+                                                 get_constant_by_value(11)->get_value(),
+                                                 get_constant_by_name("VAL1")->get_value(),
+                                                 get_doc())))
+}
+
+void test_list(t_list* sut) {
+  boost::scoped_ptr<t_list> sut2(round_trip(sut));
+
+  BOOST_PP_LIST_FOR_EACH(THRIFT_CHECK,
+                         sut->,
+                         BOOST_PP_TUPLE_TO_LIST(4,
+                                                (get_elem_type()->get_name(),
+                                                 has_cpp_name(),
+                                                 get_doc(),
+                                                 get_name())))
+  if (sut->has_cpp_name())
+    BOOST_CHECK_EQUAL(sut->get_cpp_name(), sut2->get_cpp_name());
+}
+void test_set(t_set* sut) {
+  boost::scoped_ptr<t_set> sut2(round_trip(sut));
+
+  BOOST_PP_LIST_FOR_EACH(THRIFT_CHECK,
+                         sut->,
+                         BOOST_PP_TUPLE_TO_LIST(4,
+                                                (get_elem_type()->get_name(),
+                                                 has_cpp_name(),
+                                                 get_doc(),
+                                                 get_name())))
+  if (sut->has_cpp_name())
+    BOOST_CHECK_EQUAL(sut->get_cpp_name(), sut2->get_cpp_name());
+}
+void test_map(t_map* sut) {
+  boost::scoped_ptr<t_map> sut2(round_trip(sut));
+
+  BOOST_PP_LIST_FOR_EACH(THRIFT_CHECK,
+                         sut->,
+                         BOOST_PP_TUPLE_TO_LIST(5,
+                                                (get_key_type()->get_name(),
+                                                 get_val_type()->get_name(),
+                                                 has_cpp_name(),
+                                                 get_doc(),
+                                                 get_name())))
+  if (sut->has_cpp_name())
+    BOOST_CHECK_EQUAL(sut->get_cpp_name(), sut2->get_cpp_name());
+}
+
+void test_typedef(t_typedef* sut) {
+  boost::scoped_ptr<t_typedef> sut2(round_trip(sut));
+
+  BOOST_PP_LIST_FOR_EACH(THRIFT_CHECK,
+                         sut->,
+                         BOOST_PP_TUPLE_TO_LIST(4,
+                                                (get_doc(),
+                                                 get_name(),
+                                                 get_symbolic(),
+                                                 is_forward_typedef())))
+}
+
+void test_type(t_type* sut) {
+  boost::scoped_ptr<t_type> sut2(round_trip(sut));
+
+  BOOST_PP_LIST_FOR_EACH(THRIFT_CHECK,
+                         sut->,
+                         BOOST_PP_TUPLE_TO_LIST(15,
+                                                (is_void(),
+                                                 is_base_type(),
+                                                 is_string(),
+                                                 is_bool(),
+                                                 is_typedef(),
+                                                 is_enum(),
+                                                 is_struct(),
+                                                 is_xception(),
+                                                 is_container(),
+                                                 is_list(),
+                                                 is_set(),
+                                                 is_map(),
+                                                 is_service(),
+                                                 get_doc(),
+                                                 get_name())))
+}
+
+void test_field(t_field* sut) {
+  boost::scoped_ptr<t_field> sut2(round_trip(sut));
+
+  BOOST_PP_LIST_FOR_EACH(THRIFT_CHECK,
+                         sut->,
+                         BOOST_PP_TUPLE_TO_LIST(5,
+                                                (get_req(),
+                                                 get_reference(),
+                                                 get_key(),
+                                                 get_doc(),
+                                                 get_name())))
+  if (sut->get_value()) {
+    THRIFT_CHECK(, sut->, get_value()->get_type());
+  } else {
+    BOOST_CHECK(!sut2->get_value());
+  }
+  if (sut->get_type()) {
+    THRIFT_CHECK(, sut->, get_type()->get_name());
+  } else {
+    BOOST_CHECK(!sut2->get_type());
+  }
+}
+void test_struct(t_struct* sut) {
+  boost::scoped_ptr<t_struct> sut2(round_trip(sut));
+
+  BOOST_PP_LIST_FOR_EACH(THRIFT_CHECK,
+                         sut->,
+                         BOOST_PP_TUPLE_TO_LIST(5,
+                                                (is_union(),
+                                                 is_xception(),
+                                                 is_struct(),
+                                                 get_doc(),
+                                                 get_name())))
+}
+
+void test_function(t_function* sut) {
+  boost::scoped_ptr<t_function> sut2(round_trip(sut));
+
+  BOOST_PP_LIST_FOR_EACH(
+      THRIFT_CHECK,
+      sut->,
+      BOOST_PP_TUPLE_TO_LIST(4, (get_doc(), get_name(), get_returntype()->get_name(), is_oneway())))
+}
+void test_service(t_service* sut) {
+  boost::scoped_ptr<t_service> sut2(round_trip(sut));
+
+  BOOST_PP_LIST_FOR_EACH(THRIFT_CHECK,
+                         sut->,
+                         BOOST_PP_TUPLE_TO_LIST(3, (get_doc(), get_name(), get_functions().size())))
+  if (sut->get_extends()) {
+    THRIFT_CHECK(, sut->, get_extends()->get_name());
+  } else {
+    BOOST_CHECK(!sut2->get_extends());
+  }
+}
+
+void test_program(t_program* sut) {
+  boost::scoped_ptr<t_program> sut2(round_trip(sut));
+
+  BOOST_PP_LIST_FOR_EACH(THRIFT_CHECK, sut->, BOOST_PP_TUPLE_TO_LIST(2, (get_doc(), get_name())))
+}
+boost::unit_test::test_suite* do_init_unit_test_suite() {
+  test_data::init();
+  test_suite* ts = BOOST_TEST_SUITE("PluginConversionTest");
+
+#define T_TEST_CASE(r, d, type)                                                                    \
+  ts->add(BOOST_PARAM_TEST_CASE(test_##type, test_data::type##s.begin(), test_data::type##s.end()));
+  BOOST_PP_LIST_FOR_EACH(T_TEST_CASE, _, T_TEST_TYPES)
+  T_TEST_CASE(_, _, type)
+#undef T_TEST_CASE
+  return ts;
+}
+
+#ifdef BOOST_TEST_DYN_LINK
+bool init_unit_test_suite() {
+  framework::master_test_suite().add(do_init_unit_test_suite());
+  return true;
+}
+int main(int argc, char* argv[]) {
+  return ::boost::unit_test::unit_test_main(&init_unit_test_suite, argc, argv);
+}
+#else
+boost::unit_test::test_suite* init_unit_test_suite(int argc, char* argv[]) {
+  return do_init_unit_test_suite();
+}
+#endif
diff --git a/compiler/cpp/test/plugin/cpp_plugin.cc b/compiler/cpp/test/plugin/cpp_plugin.cc
new file mode 100644
index 00000000000..6cc19f2a3fc
--- /dev/null
+++ b/compiler/cpp/test/plugin/cpp_plugin.cc
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements. See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership. The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include "thrift/plugin/plugin.h"
+#include "thrift/generate/t_generator.h"
+
+namespace apache {
+namespace thrift {
+namespace plugin {
+
+class MyCppGenerator : public GeneratorPlugin {
+  virtual int generate(::t_program* program,
+                       const std::map<std::string, std::string>& parsed_options) {
+    t_generator* gen = t_generator_registry::get_generator(program, "cpp", parsed_options, "");
+    gen->generate_program();
+    delete gen;
+    return 0;
+  }
+};
+}
+}
+}
+
+int main(int argc, char* argv[]) {
+  apache::thrift::plugin::MyCppGenerator p;
+  return p.exec(argc, argv);
+}
diff --git a/configure.ac b/configure.ac
index c72dd435124..deee0e31bb3 100755
--- a/configure.ac
+++ b/configure.ac
@@ -511,6 +511,22 @@ if test "$enable_tests" = "no"; then
 fi
 AM_CONDITIONAL(WITH_TESTS, [test "$have_tests" = "yes"])
 
+AC_ARG_ENABLE([plugin],
+  AS_HELP_STRING([--enable-plugin], [build compiler plugin support [default=yes]]),
+  [], enable_plugin=yes
+)
+have_plugin=yes
+if test "$have_cpp" = "no" ; then
+  have_plugin="no"
+fi
+if test "$enable_plugin" = "no"; then
+  have_plugin="no"
+fi
+if test "$have_plugin" = "yes" ; then
+  AC_CONFIG_LINKS([compiler/cpp/test/plugin/t_cpp_generator.cc:compiler/cpp/src/thrift/generate/t_cpp_generator.cc])
+fi
+AM_CONDITIONAL(WITH_PLUGIN, [test "$have_plugin" = "yes"])
+
 AC_ARG_ENABLE([tutorial],
   AS_HELP_STRING([--enable-tutorial], [build tutorial [default=yes]]),
   [], enable_tutorial=yes
@@ -707,8 +723,11 @@ AH_BOTTOM([
 AC_CONFIG_FILES([
   Makefile
   compiler/cpp/Makefile
-  compiler/cpp/version.h
-  compiler/cpp/src/windows/version.h
+  compiler/cpp/src/Makefile
+  compiler/cpp/src/thrift/plugin/Makefile
+  compiler/cpp/test/Makefile
+  compiler/cpp/src/thrift/version.h
+  compiler/cpp/src/thrift/windows/version.h
   lib/Makefile
   lib/cpp/Makefile
   lib/cpp/test/Makefile
@@ -817,6 +836,7 @@ AC_OUTPUT
 echo
 echo "$PACKAGE $VERSION"
 echo
+echo "Building Plugin Support ...... : $have_plugin"
 echo "Building C++ Library ......... : $have_cpp"
 echo "Building C (GLib) Library .... : $have_c_glib"
 echo "Building Java Library ........ : $have_java"
diff --git a/debian/rules b/debian/rules
index a31881d7724..84cba1f10ca 100755
--- a/debian/rules
+++ b/debian/rules
@@ -42,12 +42,12 @@ build: build-arch build-indep
 build-arch: build-arch-stamp
 $(CURDIR)/compiler/cpp/thrift build-arch-stamp: configure-stamp
 
-	# Compile compiler
-	$(MAKE) -C $(CURDIR)/compiler/cpp
-
 	# Compile C++ library
 	$(MAKE) -C $(CURDIR)/lib/cpp
 
+	# Compile compiler
+	$(MAKE) -C $(CURDIR)/compiler/cpp
+
 	# Compile C (glib) library
 	$(MAKE) -C $(CURDIR)/lib/c_glib
 
diff --git a/lib/Makefile.am b/lib/Makefile.am
index d8d9b47878d..47af1181241 100644
--- a/lib/Makefile.am
+++ b/lib/Makefile.am
@@ -21,8 +21,11 @@ SUBDIRS = json xml
 PRECROSS_TARGET =
 
 if WITH_CPP
+# cpp dir is picked directly by plugin build
+if !WITH_PLUGIN
 SUBDIRS += cpp
 endif
+endif
 
 if WITH_C_GLIB
 SUBDIRS += c_glib
diff --git a/lib/c_glib/test/CMakeLists.txt b/lib/c_glib/test/CMakeLists.txt
index 95876ed2b1c..02956444f81 100644
--- a/lib/c_glib/test/CMakeLists.txt
+++ b/lib/c_glib/test/CMakeLists.txt
@@ -18,12 +18,12 @@
 #
 
 
-#Make sure gen-cpp and gen-c_glib files can be included
-include_directories("${CMAKE_CURRENT_BINARY_DIR}")
-
 set(TEST_PREFIX "c_glib")
 
-include_directories(${Boost_INCLUDE_DIRS})
+include_directories(SYSTEM ${Boost_INCLUDE_DIRS})
+
+#Make sure gen-cpp and gen-c_glib files can be included
+include_directories("${CMAKE_CURRENT_BINARY_DIR}")
 
 # Create the thrift C test library
 set(testgenc_SOURCES
diff --git a/lib/cpp/CMakeLists.txt b/lib/cpp/CMakeLists.txt
index 33cefcb1bd4..d07b4008c3f 100755
--- a/lib/cpp/CMakeLists.txt
+++ b/lib/cpp/CMakeLists.txt
@@ -17,13 +17,6 @@
 # under the License.
 #
 
-# Find required packages
-if(WITH_BOOSTTHREADS)
-  find_package(Boost 1.53.0 REQUIRED COMPONENTS system thread)
-else()
-  find_package(Boost 1.53.0 REQUIRED)
-endif()
-
 include_directories(SYSTEM "${Boost_INCLUDE_DIRS}")
 include_directories(src)
 
diff --git a/lib/cpp/Makefile.am b/lib/cpp/Makefile.am
index 6fd15d26e35..2a1cca8aee6 100755
--- a/lib/cpp/Makefile.am
+++ b/lib/cpp/Makefile.am
@@ -28,8 +28,12 @@ moc__%.cpp: %.h
 SUBDIRS = .
 
 if WITH_TESTS
+# This file is needed by compiler with plugin, while test/Makefile.am needs compiler
+# So test directory is directly picked by top level Makefile.am for plugin build
+if !WITH_PLUGIN
 SUBDIRS += test
 endif
+endif
 
 pkgconfigdir = $(libdir)/pkgconfig
 
diff --git a/lib/cpp/src/thrift/protocol/TJSONProtocol.cpp b/lib/cpp/src/thrift/protocol/TJSONProtocol.cpp
index 412e9277984..be37fb0f90d 100644
--- a/lib/cpp/src/thrift/protocol/TJSONProtocol.cpp
+++ b/lib/cpp/src/thrift/protocol/TJSONProtocol.cpp
@@ -523,7 +523,7 @@ namespace {
 std::string doubleToString(double d) {
   std::ostringstream str;
   str.imbue(std::locale::classic());
-  const double max_digits10 = 2 + std::numeric_limits<double>::digits10;
+  const int max_digits10 = 2 + std::numeric_limits<double>::digits10;
   str.precision(max_digits10);
   str << d;
   return str.str();
diff --git a/lib/cpp/src/thrift/protocol/TProtocol.h b/lib/cpp/src/thrift/protocol/TProtocol.h
index 1b46faf32db..448c4fe5a8b 100644
--- a/lib/cpp/src/thrift/protocol/TProtocol.h
+++ b/lib/cpp/src/thrift/protocol/TProtocol.h
@@ -20,6 +20,11 @@
 #ifndef _THRIFT_PROTOCOL_TPROTOCOL_H_
 #define _THRIFT_PROTOCOL_TPROTOCOL_H_ 1
 
+#ifdef _WIN32
+// Need to come before any Windows.h includes
+#include <Winsock2.h>
+#endif
+
 #include <thrift/transport/TTransport.h>
 #include <thrift/protocol/TProtocolException.h>
 
diff --git a/lib/cpp/src/thrift/windows/GetTimeOfDay.cpp b/lib/cpp/src/thrift/windows/GetTimeOfDay.cpp
index fba077c9553..820828f32c7 100644
--- a/lib/cpp/src/thrift/windows/GetTimeOfDay.cpp
+++ b/lib/cpp/src/thrift/windows/GetTimeOfDay.cpp
@@ -21,8 +21,6 @@
 #include <thrift/thrift-config.h>
 
 // win32
-#include <time.h>
-
 #if defined(__MINGW32__)
   #include <sys/time.h>
 #endif
diff --git a/lib/cpp/src/thrift/windows/GetTimeOfDay.h b/lib/cpp/src/thrift/windows/GetTimeOfDay.h
index 6e90ba18318..762ac5e2421 100644
--- a/lib/cpp/src/thrift/windows/GetTimeOfDay.h
+++ b/lib/cpp/src/thrift/windows/GetTimeOfDay.h
@@ -29,6 +29,7 @@
 #endif
 
 #include <thrift/thrift-config.h>
+#include <time.h>
 
 struct thrift_timespec {
   int64_t tv_sec;
diff --git a/lib/cpp/src/thrift/windows/config.h b/lib/cpp/src/thrift/windows/config.h
index 108e05b2939..8650103a8d1 100644
--- a/lib/cpp/src/thrift/windows/config.h
+++ b/lib/cpp/src/thrift/windows/config.h
@@ -30,6 +30,7 @@
 
 // use std::thread in MSVC11 (2012) or newer
 #if _MSC_VER >= 1700
+#define HAVE_STDINT_H 1
 #define USE_STD_THREAD 1
 // otherwise use boost threads
 #else
diff --git a/lib/cpp/test/CMakeLists.txt b/lib/cpp/test/CMakeLists.txt
index 7c7e32071ae..cbeff08842e 100644
--- a/lib/cpp/test/CMakeLists.txt
+++ b/lib/cpp/test/CMakeLists.txt
@@ -17,15 +17,8 @@
 # under the License.
 #
 
-# Find required packages
-set(Boost_USE_STATIC_LIBS ON) # Force the use of static boost test framework
-find_package(Boost 1.53.0 REQUIRED COMPONENTS chrono filesystem system thread unit_test_framework)
 include_directories(SYSTEM "${Boost_INCLUDE_DIRS}")
 
-if (WITH_DYN_LINK_TEST)
-    add_definitions( -DBOOST_TEST_DYN_LINK )
-endif()
-
 #Make sure gen-cpp files can be included
 include_directories("${CMAKE_CURRENT_BINARY_DIR}")
 
diff --git a/lib/cpp/test/Makefile.am b/lib/cpp/test/Makefile.am
index 4e76ce8b45b..6f46117459c 100755
--- a/lib/cpp/test/Makefile.am
+++ b/lib/cpp/test/Makefile.am
@@ -358,7 +358,7 @@ gen-cpp/SecondService.cpp gen-cpp/ThriftTest_constants.cpp gen-cpp/ThriftTest.cp
 gen-cpp/ChildService.cpp gen-cpp/ChildService.h gen-cpp/ParentService.cpp gen-cpp/ParentService.h gen-cpp/proc_types.cpp gen-cpp/proc_types.h: processor/proc.thrift
 	$(THRIFT) --gen cpp:templates,cob_style $<
 
-AM_CPPFLAGS = $(BOOST_CPPFLAGS) -I$(top_srcdir)/lib/cpp/src -D__STDC_LIMIT_MACROS
+AM_CPPFLAGS = $(BOOST_CPPFLAGS) -I$(top_srcdir)/lib/cpp/src -D__STDC_LIMIT_MACROS -I.
 AM_LDFLAGS = $(BOOST_LDFLAGS)
 AM_CXXFLAGS = -Wall -Wextra -pedantic
 
diff --git a/test/cpp/CMakeLists.txt b/test/cpp/CMakeLists.txt
index 11db68ee8a4..09850a81455 100755
--- a/test/cpp/CMakeLists.txt
+++ b/test/cpp/CMakeLists.txt
@@ -20,8 +20,6 @@
 # Contains the thrift specific LINK_AGAINST_THRIFT_LIBRARY
 include(ThriftMacros)
 
-set(Boost_USE_STATIC_LIBS ON)
-find_package(Boost 1.53.0 REQUIRED COMPONENTS program_options system filesystem)
 include_directories(SYSTEM "${Boost_INCLUDE_DIRS}")
 
 find_package(OpenSSL REQUIRED)
diff --git a/tutorial/cpp/CMakeLists.txt b/tutorial/cpp/CMakeLists.txt
index 8a3d085513b..1feec2c35e2 100644
--- a/tutorial/cpp/CMakeLists.txt
+++ b/tutorial/cpp/CMakeLists.txt
@@ -17,7 +17,6 @@
 # under the License.
 #
 
-find_package(Boost 1.53.0 REQUIRED)
 include_directories(SYSTEM "${Boost_INCLUDE_DIRS}")
 
 #Make sure gen-cpp files can be included
@@ -27,7 +26,7 @@ include_directories("${PROJECT_SOURCE_DIR}/lib/cpp/src")
 
 include(ThriftMacros)
 
-set(tutorialgencpp_SOURCES 
+set(tutorialgencpp_SOURCES
     gen-cpp/Calculator.cpp
     gen-cpp/SharedService.cpp
     gen-cpp/shared_constants.cpp
