diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dpath/Expression.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dpath/Expression.scala
index bbbc7d1b20..dc75e80044 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dpath/Expression.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dpath/Expression.scala
@@ -1695,9 +1695,14 @@ case class FunctionCallExpression(functionQNameString: String, expressions: List
           case erd: ElementRuntimeData => erd
           case _ => SDE("dfdlx:outputTypeCalcNextSibling can only be defined on an element")
         }
-        val resolver = erd.nextElementResolver
+        val resolver = erd.partialNextElementResolver
+        val followingERDs = resolver.currentPossibleNextElements.dropWhile { _ == erd }
+
+        // It is required that the next sibling be a peer "adjacent or downward", but not up-and-out
+        // from the location of the term where this resides.
+        //
         //we keep the ERD to be able to produce better error messages
-        val dstTypes: Seq[(NodeInfo.Kind, ElementRuntimeData)] = resolver.allPossibleNextElements.map(erd => {
+        val dstTypes: Seq[(NodeInfo.Kind, ElementRuntimeData)] = followingERDs.map(erd => {
           val strd = erd.optSimpleTypeRuntimeData match {
             case Some(x) => x
             case None => SDE("dfdlx:outputTypeCalcNextSibling: potential next sibling %s does not have a simple type def. This could be because it has a primitive type, or a complex type.", erd.namedQName)
@@ -1712,7 +1717,7 @@ case class FunctionCallExpression(functionQNameString: String, expressions: List
           (calc.srcType, erd)
         })
         val dstType = dstTypes match {
-          case Seq() => SDE("dfdlx:outputTypeCalcNextSibling() called where no next sibling exists")
+          case Seq() => SDE("dfdlx:outputTypeCalcNextSibling() called where no suitable next sibling exists")
           case Seq(x) => x._1
           case x +: xs => {
             val (ans, headQName) = x
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/DFDLFormatAnnotation.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/DFDLFormatAnnotation.scala
index b2b8e8ccb7..753c78db3a 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/DFDLFormatAnnotation.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/DFDLFormatAnnotation.scala
@@ -39,10 +39,9 @@ object DeprecatedProperty {
     DeprecatedProperty(XMLUtils.DFDL_NAMESPACE, "layerLengthKind", "dfdlx:layerLengthKind"),
     DeprecatedProperty(XMLUtils.DFDL_NAMESPACE, "layerLength", "dfdlx:layerLength"),
     DeprecatedProperty(XMLUtils.DFDL_NAMESPACE, "layerLengthUnits", "dfdlx:layerLengthUnits"),
-    DeprecatedProperty(XMLUtils.DFDL_NAMESPACE, "layerBoundaryMark","dfdlx:layerBoundaryMark"),
+    DeprecatedProperty(XMLUtils.DFDL_NAMESPACE, "layerBoundaryMark", "dfdlx:layerBoundaryMark"),
     DeprecatedProperty(XMLUtils.EXT_NS_APACHE, "parseUnparsePolicy", "dfdlx:parseUnparsePolicy"),
-    DeprecatedProperty(XMLUtils.EXT_NS_NCSA, "parseUnparsePolicy", "dfdlx:parseUnparsePolicy")
-  )
+    DeprecatedProperty(XMLUtils.EXT_NS_NCSA, "parseUnparsePolicy", "dfdlx:parseUnparsePolicy"))
 
   def warnIfDeprecated(
     propertyName: String,
@@ -76,7 +75,6 @@ abstract class DFDLFormatAnnotation(nodeArg: Node, annotatedSCArg: AnnotatedSche
 
   requiredEvaluations(hasConflictingPropertyError)
 
-  final lazy val ref = getLocalFormatRef()
   //
   // prefix of a QName as the value of this ref, must be referring
   // to a namespace binding that is in force right here on this object
@@ -91,7 +89,7 @@ abstract class DFDLFormatAnnotation(nodeArg: Node, annotatedSCArg: AnnotatedSche
    * form format annotation (or we ARE a long form format annotation)
    * gets the ref long form attribute.
    */
-  private def getLocalFormatRef(): Option[String] = {
+  final lazy val ref: Option[String] = {
     // We have to check if the ref exists in long form (dfdl:ref)
     // or short form (ref).
     //
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/DFDLStatementMixin.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/DFDLStatementMixin.scala
index 676c6f39ff..e8707627f5 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/DFDLStatementMixin.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/DFDLStatementMixin.scala
@@ -33,7 +33,8 @@ trait ResolvesDFDLStatementMixin
     optReferencedStatementSource.toSeq.flatMap { _.resolvedStatements } ++
       localStatements
 
-  private def getParserExprReferencedElements(s: DFDLStatement,
+  private def getParserExprReferencedElements(
+    s: DFDLStatement,
     f: ContentValueReferencedElementInfoMixin => Set[DPathElementCompileInfo]) = {
     s match {
       case a: DFDLAssertionBase if (a.testKind eq TestKind.Expression) => {
@@ -46,7 +47,8 @@ trait ResolvesDFDLStatementMixin
     }
   }
 
-  private def getUnparserExprReferencedElements(s: DFDLStatement,
+  private def getUnparserExprReferencedElements(
+    s: DFDLStatement,
     f: ContentValueReferencedElementInfoMixin => Set[DPathElementCompileInfo]) = {
     s match {
       case sv: DFDLSetVariable => {
@@ -151,7 +153,7 @@ trait ProvidesDFDLStatementMixin extends ThrowsSDE with HasTermCheck { self: Ann
    * reference.
    */
 
-  final def optReferencedStatementSource: Option[ProvidesDFDLStatementMixin] =
+  final lazy val optReferencedStatementSource: Option[ProvidesDFDLStatementMixin] =
     self.optReferredToComponent.asInstanceOf[Option[ProvidesDFDLStatementMixin]]
 
   final lazy val resolvedStatements: Seq[DFDLStatement] =
@@ -187,7 +189,8 @@ trait ProvidesDFDLStatementMixin extends ThrowsSDE with HasTermCheck { self: Ann
 
   private def checkDiscriminatorsAssertsDisjoint(discrims: Seq[DFDLDiscriminator], asserts: Seq[DFDLAssert]): (Seq[DFDLDiscriminator], Seq[DFDLAssert]) = {
     schemaDefinitionUnless(discrims.size <= 1, "At most one discriminator allowed at same location: %s", discrims)
-    schemaDefinitionUnless(asserts == Nil || discrims == Nil,
+    schemaDefinitionUnless(
+      asserts == Nil || discrims == Nil,
       "Cannot have both dfdl:discriminator annotations and dfdl:assert annotations at the same location.")
     (discrims, asserts)
   }
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/ElementBase.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/ElementBase.scala
index c6e0568613..a0b6fd689e 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/ElementBase.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/ElementBase.scala
@@ -17,32 +17,23 @@
 
 package org.apache.daffodil.dsom
 
-import scala.xml.NamespaceBinding
-import org.apache.daffodil.exceptions.Assert
-import org.apache.daffodil.grammar._
+import org.apache.daffodil.equality._
+import org.apache.daffodil.processors._
+import org.apache.daffodil.infoset._
 import org.apache.daffodil.schema.annotation.props._
-import org.apache.daffodil.schema.annotation.props.gen._
 import org.apache.daffodil.xml._
+import org.apache.daffodil.util.Maybe
+import org.apache.daffodil.grammar.ElementBaseGrammarMixin
+import org.apache.daffodil.schema.annotation.props.gen._
+import org.apache.daffodil.dsom._
 import org.apache.daffodil.util.Misc
-import org.apache.daffodil.processors._
+import scala.xml.NamespaceBinding
+import org.apache.daffodil.util.MaybeULong
 import org.apache.daffodil.dpath.NodeInfo
 import org.apache.daffodil.dpath.NodeInfo.PrimType
-import org.apache.daffodil.grammar.ElementBaseGrammarMixin
-import org.apache.daffodil.equality._
-
-import org.apache.daffodil.processors.UseNilForDefault
-import org.apache.daffodil.util.MaybeULong
-import java.lang.{ Integer => JInt }
-import org.apache.daffodil.processors._
-import org.apache.daffodil.infoset.SiblingResolver
-import org.apache.daffodil.infoset.ResolverType
-import org.apache.daffodil.infoset.SeveralPossibilitiesForNextElement
-import org.apache.daffodil.infoset.NoNextElement
-import org.apache.daffodil.infoset.OnlyOnePossibilityForNextElement
-import org.apache.daffodil.infoset.NextElementResolver
-import org.apache.daffodil.infoset.ChildResolver
+import org.apache.daffodil.exceptions.Assert
 import org.apache.daffodil.api.WarnID
-import org.apache.daffodil.util.Maybe
+import java.lang.{ Integer => JInt }
 
 /**
  * Note about DSOM design versus say XSOM or Apache XSD library.
@@ -93,7 +84,6 @@ trait ElementBase
   requiredEvaluations(if (hasMaxExclusive) maxExclusive)
   requiredEvaluations(if (hasTotalDigits) totalDigits)
   requiredEvaluations(if (hasFractionDigits) fractionDigits)
-  requiredEvaluations(erd.preSerialization)
   requiredEvaluations(checkForAlignmentAmbiguity)
   requiredEvaluations(checkFloating)
 
@@ -136,7 +126,7 @@ trait ElementBase
    * The DPathElementInfo objects referenced within an IVC
    * that calls dfdl:contentLength( thingy )
    */
-  override final protected def calcContentParserReferencedElementInfos =
+  override final protected lazy val calcContentParserReferencedElementInfos =
     if (this.inputValueCalcOption.isDefined)
       ivcCompiledExpression.contentReferencedElementInfos
     else
@@ -146,7 +136,7 @@ trait ElementBase
    * The DPathElementInfo objects referenced within an OVC
    * that calls dfdl:contentLength( thingy )
    */
-  override final protected def calcContentUnparserReferencedElementInfos =
+  override final protected lazy val calcContentUnparserReferencedElementInfos =
     if (this.outputValueCalcOption.isDefined)
       ovcCompiledExpression.contentReferencedElementInfos
     else
@@ -156,7 +146,7 @@ trait ElementBase
    * The DPathElementInfo objects referenced within an IVC
    * that calls dfdl:valueLength( thingy )
    */
-  override final protected def calcValueParserReferencedElementInfos =
+  override final protected lazy val calcValueParserReferencedElementInfos =
     if (this.inputValueCalcOption.isDefined) {
       val ivcCE = ivcCompiledExpression
       val setERs = ivcCE.valueReferencedElementInfos
@@ -168,7 +158,7 @@ trait ElementBase
    * The DPathElementInfo objects referenced within an IVC
    * that calls dfdl:valueLength( thingy )
    */
-  override final protected def calcValueUnparserReferencedElementInfos =
+  override final protected lazy val calcValueUnparserReferencedElementInfos =
     if (this.outputValueCalcOption.isDefined)
       ovcCompiledExpression.valueReferencedElementInfos
     else
@@ -374,10 +364,6 @@ trait ElementBase
 
   lazy val isQuasiElement: Boolean = false //overriden by RepTypeQuasiElementDecls
 
-  //  private lazy val mustBeAbsentFromUnparseInfoset: Boolean = {
-  //    isOutputValueCalc
-  //  }
-
   final protected lazy val optTruncateSpecifiedLengthString =
     Option(truncateSpecifiedLengthString =:= YesNo.Yes)
   // because of the way text numbers are unparsed, we don't know that
@@ -574,7 +560,7 @@ trait ElementBase
     // Also, things like packed and zoned decimal are usually fixed length, sometimes delimited.
   }
 
-  final def isImplicitLengthString = isSimpleType && primType =:= PrimType.String && lengthKind =:= LengthKind.Implicit
+  final lazy val isImplicitLengthString = isSimpleType && primType =:= PrimType.String && lengthKind =:= LengthKind.Implicit
 
   final lazy val fixedLengthValue: Long = {
     // FIXME: this calculation only good for string type.
@@ -1037,7 +1023,7 @@ trait ElementBase
       case None => true
       case Some(s: SequenceTermBase) if s.isOrdered => {
         !possibleNextSiblingTerms.exists {
-          case e: ElementBase => e.isRequiredInInfoset
+          case e: ElementBase => e.isRequiredStreamingUnparserEvent
           case mg: ModelGroup => mg.mustHaveRequiredElement
         }
       }
@@ -1046,7 +1032,7 @@ trait ElementBase
     couldBeLast
   }.value
 
-  final lazy val nextParentElements: Seq[ElementBase] =
+  final override lazy val nextParentElements: Seq[ElementBase] =
     enclosingTerms.flatMap { enclosingTerm =>
       if (couldBeLastElementInModelGroup) {
         enclosingTerm.possibleNextChildElementsInInfoset
@@ -1102,7 +1088,7 @@ trait ElementBase
    *
    * Part of the required evaluations for ElementBase.
    */
-  private def checkForAlignmentAmbiguity: Unit = {
+  private lazy val checkForAlignmentAmbiguity: Unit = {
     if (isOptional) {
       this.possibleNextTerms.filterNot(m => m == this).foreach { that =>
         val isSame = this.alignmentValueInBits == that.alignmentValueInBits
@@ -1116,7 +1102,7 @@ trait ElementBase
 
   private lazy val optionFloating = findPropertyOption("floating")
 
-  private def checkFloating = (optionFloating.isDefined, tunable.requireFloatingProperty) match {
+  private lazy val checkFloating = (optionFloating.isDefined, tunable.requireFloatingProperty) match {
     case (false, false) => SDW(WarnID.FloatingError, "Property 'dfdl:floating' is required but not defined.")
     case (false, true) => floating
     case (_, _) => this.subset((floating eq YesNo.No), "Property value floating='yes' is not supported.")
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/Facets.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/Facets.scala
index 124b0b6609..82e74491c5 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/Facets.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/Facets.scala
@@ -505,7 +505,7 @@ trait Facets { self: Restriction =>
     cValue
   }
 
-  protected def getCombinedValueEnum = {
+  protected lazy val getCombinedValueEnum = {
     val lValue = getLocalValue(Facet.enumeration)
     val rValue = getRemoteFacetValue(Facet.enumeration)
     lValue.foreach(e => {
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/GroupRef.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/GroupRef.scala
index 6b35c96789..1b15ea4f59 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/GroupRef.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/GroupRef.scala
@@ -43,7 +43,7 @@ trait GroupRef { self: ModelGroup =>
     }
   }
 
-  override protected final def emptyFormatFactory: DFDLFormatAnnotation = new DFDLGroup(newDFDLAnnotationXML("group"), this)
+  override protected final lazy val emptyFormatFactory: DFDLFormatAnnotation = new DFDLGroup(newDFDLAnnotationXML("group"), this)
 
   override protected final def isMyFormatAnnotation(a: DFDLAnnotation) = a.isInstanceOf[DFDLAnnotation]
 
@@ -75,7 +75,7 @@ final class GroupRefFactory(refXMLArg: Node, val refLexicalParent: SchemaCompone
 }
 
 final class SequenceGroupRef(
-  globalGroupDef: => GlobalSequenceGroupDef,
+  globalGroupDefArg: => GlobalSequenceGroupDef,
   refXML: Node,
   refLexicalParent: SchemaComponent,
   positionArg: Int,
@@ -83,6 +83,8 @@ final class SequenceGroupRef(
   extends SequenceGroupTermBase(refXML, refLexicalParent, positionArg)
   with GroupRef {
 
+  private lazy val globalGroupDef = globalGroupDefArg // once only
+
   override def isHidden = isHiddenArg
 
   private lazy val sgd = groupDef.asInstanceOf[GlobalSequenceGroupDef]
@@ -100,7 +102,7 @@ final class SequenceGroupRef(
 }
 
 final class ChoiceGroupRef(
-  globalGroupDef: => GlobalChoiceGroupDef,
+  globalGroupDefArg: => GlobalChoiceGroupDef,
   refXML: Node,
   refLexicalParent: SchemaComponent,
   positionArg: Int,
@@ -110,6 +112,8 @@ final class ChoiceGroupRef(
 
   requiredEvaluations(groupDef)
 
+  private lazy val globalGroupDef = globalGroupDefArg // once only
+
   override def isHidden = isHiddenArg
 
   override lazy val groupDef = globalGroupDef
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/ModelGroup.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/ModelGroup.scala
index 53acd92fdb..8982b94690 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/ModelGroup.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/ModelGroup.scala
@@ -221,7 +221,7 @@ abstract class ModelGroup(index: Int)
           val last = maybeLast.get
           val lastIsOptional = last match {
             case mg: ModelGroup => false // model group is mandatory
-            case eb: ElementBase => !eb.isRequiredInInfoset || !eb.isRepresented
+            case eb: ElementBase => !eb.isRequiredStreamingUnparserEvent || !eb.isRepresented
           }
           if (lastIsOptional) {
             val (priorSibs, optPriorElementsIncludesThisParent) = last.potentialPriorTerms
@@ -249,13 +249,13 @@ abstract class ModelGroup(index: Int)
   }
 
   /**
-   * Package private as this is for testing only
+   * Package private as this is for testing only.
    */
   private[dsom] final def allSelfContainedTermsTerminatedByRequiredElement: Seq[Term] =
     LV('allSelfContainedTermsTerminatedByRequiredElement) {
       val listOfTerms = groupMembers.map(m => {
         m match {
-          case e: ElementBase if !e.isRequiredInInfoset => (Seq(e) ++ e.possibleNextTerms) // A LocalElement or ElementRef
+          case e: ElementBase if !e.isRequiredStreamingUnparserEvent => (Seq(e) ++ e.possibleNextTerms) // A LocalElement or ElementRef
           case e: ElementBase => Seq(e)
           case mg: ModelGroup => Seq(mg)
         }
@@ -334,7 +334,7 @@ abstract class ModelGroup(index: Int)
     firstTerms
   }.value
 
-  final lazy val nextParentElements: Seq[ElementBase] = {
+  final override lazy val nextParentElements: Seq[ElementBase] = {
     Assert.invariant(enclosingTerm.isDefined)
     val et = enclosingTerm.get
     et match {
@@ -366,7 +366,7 @@ abstract class ModelGroup(index: Int)
         // required next sibling if the last sibling element is required
         possibleNextSiblingTerms.lastOption match {
           case None => false
-          case Some(e: ElementBase) => e.isRequiredInInfoset
+          case Some(e: ElementBase) => e.isRequiredStreamingUnparserEvent
           case Some(mg: ModelGroup) => mg.mustHaveRequiredElement
           case Some(_) => Assert.invariantFailed()
         }
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/ParticleMixin.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/ParticleMixin.scala
index bfe1c0c40b..f33573b91d 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/ParticleMixin.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/ParticleMixin.scala
@@ -77,20 +77,25 @@ trait RequiredOptionalMixin { self: ElementBase =>
   }
 
   /**
-   * True if the element is required to appear in the DFDL Infoset.
+   * True if the element is required to appear in the stream of unparser infoset events.
+   * False means appears "maybe", may or may not appear.
    *
    * This includes elements that have no representation in the
-   * data stream. That is, an element with dfdl:inputValueCalc will be isRequiredInInfoset true.
+   * data stream. That is, an element with dfdl:inputValueCalc will be isRequiredStreamingUnparserEvent true.
    *
-   * Takes into account that some dfdl:occursCountKind can make
-   * seemingly required elements (based on minOccurs) optional or
-   * repeating.
+   * All arrays/optionals are treated as not required because we tolerate invalidity of the
+   * data here.
+   *
+   * OutputValueCalc elements are treated as optional. If present they are supposed to get their
+   * values ignored and overwritten by the computation.
    */
-  final lazy val isRequiredInInfoset: Boolean = {
+  final lazy val isRequiredStreamingUnparserEvent: Boolean = {
     val res = {
-      if (isScalar) true
+      if (isScalar) !this.isOutputValueCalc
       else if (isOptional) false
-      else if (isArray) isArraywithAtLeastOneRequiredArrayElement
+      // Treat all arrays as non-required so that we can tolerate invalid
+      // infosets where the number of events is fewer than the array minimum occurrences.
+      else if (isArray) false
       else false
     }
     res
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SchemaComponent.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SchemaComponent.scala
index 8ac0108b51..02b229548a 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SchemaComponent.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SchemaComponent.scala
@@ -65,9 +65,10 @@ trait SchemaComponent
 
   lazy val tunable: DaffodilTunables = optLexicalParent.get.tunable
 
-  lazy val dpathCompileInfo: DPathCompileInfo =
+  lazy val dpathCompileInfo: DPathCompileInfo = {
+    lazy val parents = enclosingComponent.map { _.dpathCompileInfo }.toSeq
     new DPathCompileInfo(
-      enclosingComponents.map { _.encloser.dpathCompileInfo },
+      parents,
       variableMap,
       namespaces,
       path,
@@ -75,6 +76,7 @@ trait SchemaComponent
       tunable,
       schemaSet.typeCalcMap,
       runtimeData)
+  }
 
   /**
    * All non-terms get runtimeData from this definition. All Terms
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SchemaDocument.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SchemaDocument.scala
index 4c324b63f7..9c18bf7f69 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SchemaDocument.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SchemaDocument.scala
@@ -258,7 +258,7 @@ final class SchemaDocument(xmlSDoc: XMLSchemaDocument)
     Some(res)
   }
 
-  protected def emptyFormatFactory = new DFDLFormat(newDFDLAnnotationXML("format"), this)
+  protected lazy val emptyFormatFactory = new DFDLFormat(newDFDLAnnotationXML("format"), this)
   protected def isMyFormatAnnotation(a: DFDLAnnotation) = a.isInstanceOf[DFDLFormat]
 
   /*
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SequenceGroup.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SequenceGroup.scala
index a251e7d020..923951c2ca 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SequenceGroup.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SequenceGroup.scala
@@ -39,6 +39,7 @@ import org.apache.daffodil.processors.ModelGroupRuntimeData
 import org.apache.daffodil.schema.annotation.props.gen.LayerLengthUnits
 import org.apache.daffodil.processors.SeparatorUnparseEv
 import org.apache.daffodil.exceptions.Assert
+import org.apache.daffodil.runtime1.ChoiceBranchImpliedSequenceRuntime1Mixin
 
 /**
  * Base for anything sequence-like.
@@ -150,7 +151,7 @@ abstract class SequenceGroupTermBase(
   /**
    * Provides unordered sequence checks.  Will SDE if invalid.
    */
-  protected final def checkIfValidUnorderedSequence(): Unit = {
+  protected final lazy val checkIfValidUnorderedSequence: Unit = {
     if (!isOrdered) {
       checkMembersAreAllElementOrElementRef
       checkMembersHaveValidOccursCountKind
@@ -158,7 +159,7 @@ abstract class SequenceGroupTermBase(
     }
   }
 
-  private def checkMembersHaveValidOccursCountKind: Unit = {
+  private lazy val checkMembersHaveValidOccursCountKind: Unit = {
     val validChildren: Seq[ElementBase] =
       groupMembers.filter { m => m.isInstanceOf[LocalElementDecl] || m.isInstanceOf[ElementRef]
       }.map(_.asInstanceOf[ElementBase])
@@ -177,7 +178,7 @@ abstract class SequenceGroupTermBase(
         "\nThe offending members: %s.", this.path, invalidChildren.mkString(","))
   }
 
-  private def checkMembersAreAllElementOrElementRef: Unit = {
+  private lazy val checkMembersAreAllElementOrElementRef: Unit = {
     val invalidChildren = groupMembers.filterNot(child =>
       child.isInstanceOf[LocalElementDecl] || child.isInstanceOf[ElementRef])
     val hasInvalidChildren = invalidChildren.length > 0
@@ -186,7 +187,7 @@ abstract class SequenceGroupTermBase(
         "\nThe offending members: %s.", this.path, invalidChildren.mkString(","))
   }
 
-  private def checkMembersHaveUniqueNamesInNamespaces: Unit = {
+  private lazy val checkMembersHaveUniqueNamesInNamespaces: Unit = {
     val childrenGroupedByNamespace =
       groupMembers.filter(m => m.isInstanceOf[ElementBase]).map(_.asInstanceOf[ElementBase]).groupBy(_.targetNamespace)
 
@@ -208,7 +209,7 @@ abstract class SequenceGroupTermBase(
     }
   }
 
-  def checkHiddenSequenceIsDefaultableOrOVC: Unit = {
+  lazy val checkHiddenSequenceIsDefaultableOrOVC: Unit = {
     if (this.isHidden) {
       val nonDefaultableOrOVC =
         this.childrenInHiddenGroupNotDefaultableOrOVC
@@ -333,7 +334,8 @@ final class Sequence(xmlArg: Node, lexicalParent: SchemaComponent, position: Int
  */
 final class ChoiceBranchImpliedSequence(rawGM: Term)
   extends SequenceTermBase(rawGM.xml, rawGM.optLexicalParent, rawGM.position)
-  with SequenceDefMixin {
+  with SequenceDefMixin
+  with ChoiceBranchImpliedSequenceRuntime1Mixin {
 
   override final lazy val groupMembers: Seq[Term] = Seq(rawGM)
 
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SimpleTypes.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SimpleTypes.scala
index 8abbcb508a..c2d9d0c96e 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SimpleTypes.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/SimpleTypes.scala
@@ -265,8 +265,8 @@ abstract class SimpleTypeDefBase(xml: Node, lexicalParent: SchemaComponent)
 
   // override def name = diagnosticDebugName // don't do this. names are used by diagnosticDebugName
 
-  override final def optReferredToComponent = optRestriction.flatMap { _.optBaseDef }
-  override final def emptyFormatFactory = new DFDLSimpleType(newDFDLAnnotationXML("simpleType"), this)
+  override final lazy val optReferredToComponent = optRestriction.flatMap { _.optBaseDef }
+  override final lazy val emptyFormatFactory = new DFDLSimpleType(newDFDLAnnotationXML("simpleType"), this)
 
   override final def isMyFormatAnnotation(a: DFDLAnnotation) = a.isInstanceOf[DFDLSimpleType]
 
@@ -277,7 +277,7 @@ abstract class SimpleTypeDefBase(xml: Node, lexicalParent: SchemaComponent)
     }
   }
 
-  def primType: NodeInfo.PrimType = {
+  lazy val primType: NodeInfo.PrimType = {
     optRestriction.map { _.primType }.getOrElse {
       optUnion.map { _.primType }.getOrElse {
         Assert.invariantFailed("must be either a restriction or union")
@@ -583,7 +583,7 @@ final class EnumerationDefFactory(
   override protected val optReferredToComponent = None
 
   protected def annotationFactory(node: Node): Option[DFDLAnnotation] = Assert.invariantFailed("Should not be called")
-  protected def emptyFormatFactory: DFDLFormatAnnotation = new DFDLEnumerationFactory(newDFDLAnnotationXML("enumeration"), this)
+  protected lazy val emptyFormatFactory: DFDLFormatAnnotation = new DFDLEnumerationFactory(newDFDLAnnotationXML("enumeration"), this)
   protected def isMyFormatAnnotation(a: DFDLAnnotation): Boolean = Assert.invariantFailed("Should not be called")
 
 }
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/Term.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/Term.scala
index 42ee03a529..910523fcab 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/Term.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/Term.scala
@@ -42,6 +42,7 @@ import org.apache.daffodil.dpath.NodeInfo
 import org.apache.daffodil.schema.annotation.props.gen.OccursCountKind
 import org.apache.daffodil.schema.annotation.props.SeparatorSuppressionPolicy
 import org.apache.daffodil.api.WarnID
+import org.apache.daffodil.infoset.PartialNextElementResolver
 
 /**
  * Mixin for objects that are shared, but have consistency checks to be run
@@ -119,7 +120,7 @@ trait Term
    * (e.g. schema compilation has finished) to ensure there are no false
    * positives.
    */
-  final def checkUnusedProperties: Unit = {
+  final lazy val checkUnusedProperties: Unit = {
     // Get the properties defined on this term and what it refers to
     val localProps = formatAnnotation.justThisOneProperties
     val refProps = optReferredToComponent.map { _.formatAnnotation.justThisOneProperties }.getOrElse(Map.empty)
@@ -581,7 +582,7 @@ trait Term
         } else {
           val firstNonOptional = previousTerms.reverse.find {
             _ match {
-              case eb: ElementBase if !eb.isRequiredInInfoset || !eb.isRepresented => false
+              case eb: ElementBase if !eb.isRequiredStreamingUnparserEvent || !eb.isRepresented => false
               case _ => true
             }
           }
@@ -650,36 +651,6 @@ trait Term
     res
   }
 
-  lazy val couldHaveSuspensions: Boolean = {
-    val commonCouldHaveSuspensions =
-      !isKnownToBeAligned || // AlignmentFillUnparser
-        (if (hasDelimiters) !isDelimiterKnownToBeTextAligned else false) || // MandatoryTextAlignmentUnparser
-        needsBitOrderChange // BitOrderChangeUnparser
-
-    this match {
-      case eb: ElementBase => {
-        val elementCouldHaveSuspensions =
-          commonCouldHaveSuspensions ||
-            !isKnownToBeTextAligned || // MandatoryTextAlignmentUnparser
-            (if (eb.isSimpleType) eb.isOutputValueCalc else false) || // SimpleTypeRetryUnparser
-            eb.shouldAddFill || // ElementUnusedUnparser, RightFillUnparser
-            eb.shouldCheckExcessLength || // ElementUnusedUnparser, RightFillUnparser
-            eb.shouldAddPadding || // OnlyPaddingUnparser, RightCenteredPaddingUnparser, LeftCenteredPaddingUnparser
-            (eb.maybeUnparseTargetLengthInBitsEv.isDefined && eb.isNillable && eb.nilKind == NilKind.LiteralCharacter) || // NilLiteralCharacterUnparser
-            (if (eb.isComplexType) eb.complexType.group.couldHaveSuspensions else false)
-
-        elementCouldHaveSuspensions
-      }
-      case mg: ModelGroup => {
-        val modelGroupCouldHaveSuspensions =
-          commonCouldHaveSuspensions ||
-            mg.groupMembers.exists { _.couldHaveSuspensions }
-
-        modelGroupCouldHaveSuspensions
-      }
-    }
-  }
-
   final lazy val possibleNextTerms: Seq[Term] = LV('possibleNextTerms) {
     val es = this.nearestEnclosingSequence
     val eus = this.nearestEnclosingUnorderedSequenceBeforeSequence
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/TermEncodingMixin.scala b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/TermEncodingMixin.scala
index bf95200914..3ddc02cb20 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/dsom/TermEncodingMixin.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/dsom/TermEncodingMixin.scala
@@ -36,7 +36,7 @@ trait TermEncodingMixin extends KnownEncodingMixin { self: Term =>
 
   private lazy val optionTextBidi = findPropertyOption("textBidi")
 
-  private def checkTextBidi = (optionTextBidi.isDefined, self.tunable.requireTextBidiProperty) match {
+  private lazy val checkTextBidi = (optionTextBidi.isDefined, self.tunable.requireTextBidiProperty) match {
     case (false, false) => SDW(WarnID.TextBidiError, "Property 'dfdl:textBidi' is required but not defined.")
     case (false, true) => textBidi
     case (_, _) => this.subset((textBidi eq YesNo.No), "Property value textBidi='yes' is not supported.")
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/grammar/ElementBaseGrammarMixin.scala b/daffodil-core/src/main/scala/org/apache/daffodil/grammar/ElementBaseGrammarMixin.scala
index a75d5855b4..3e129d421e 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/grammar/ElementBaseGrammarMixin.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/grammar/ElementBaseGrammarMixin.scala
@@ -1225,7 +1225,8 @@ trait ElementBaseGrammarMixin
               schemaDefinitionUnless(impliedRepresentation != Representation.Text, "LiteralValue Nils with lengthKind='implicit' cannot have representation='text'.")
               LiteralValueNilOfSpecifiedLength(this)
             }
-            case LengthKind.Implicit if isComplexType => Assert.invariantFailed("literal nil complex types aren't handled here.")
+            case LengthKind.Implicit if isComplexType =>
+              LiteralValueNilOfSpecifiedLength(this)
             case LengthKind.Prefixed => LiteralValueNilOfSpecifiedLength(this)
             case LengthKind.EndOfParent if isComplexType => notYetImplemented("lengthKind='endOfParent' for complex type")
             case LengthKind.EndOfParent => notYetImplemented("lengthKind='endOfParent' for simple type")
@@ -1459,7 +1460,7 @@ trait ElementBaseGrammarMixin
     elem
   }
 
-  private def checkVariousPropertyconstraints {
+  private lazy val checkVariousPropertyconstraints: Unit = {
     //
     // check for consistency. If length units is bytes, and we're going to use the length facets
     // of xs:string for implicit length, the encoding must be SBCS. Otherwise validation could fail when the
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/grammar/primitives/SequenceChild.scala b/daffodil-core/src/main/scala/org/apache/daffodil/grammar/primitives/SequenceChild.scala
index abbb239ce3..fd7dd76b77 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/grammar/primitives/SequenceChild.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/grammar/primitives/SequenceChild.scala
@@ -191,7 +191,7 @@ abstract class SequenceChild(protected val sq: SequenceTermBase, child: Term, gr
     child.isLastDeclaredRepresentedInSequence
   }
 
-  final protected def isPositional: Boolean = {
+  final protected lazy val isPositional: Boolean = {
     separatedSequenceChildBehavior match {
       case _: SeparatedSequenceChildBehavior.PositionalLike => true
       case _ => false
@@ -349,7 +349,7 @@ abstract class SequenceChild(protected val sq: SequenceTermBase, child: Term, gr
 
         if (!e.isRepresented)
           NotRepresentedZeroLengthDetector
-        else if (e.isArray && !e.isRequiredInInfoset)
+        else if (e.isArray && !e.isRequiredStreamingUnparserEvent)
           PossiblyZeroArrayOccurrencesDetector
         else {
           Assert.invariant(e.isRepresented)
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/ChoiceTermRuntime1Mixin.scala b/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/ChoiceTermRuntime1Mixin.scala
index 499fda830d..17be65b815 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/ChoiceTermRuntime1Mixin.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/ChoiceTermRuntime1Mixin.scala
@@ -47,6 +47,7 @@ trait ChoiceTermRuntime1Mixin { self: ChoiceTermBase =>
   }
 
   final def choiceBranchMap: Map[ChoiceBranchEvent, RuntimeData] = LV('choiceBranchMap) {
+
     val eventTuples = groupMembers.flatMap {
       case e: ElementBase => Seq((ChoiceBranchStartEvent(e.namedQName), e))
       case mg: ModelGroup => {
@@ -107,6 +108,8 @@ trait ChoiceTermRuntime1Mixin { self: ChoiceTermBase =>
 
   final lazy val choiceRuntimeData = {
     new ChoiceRuntimeData(
+      position,
+      partialNextElementResolver,
       schemaSet.variableMap,
       encodingInfo,
       // elementChildren.map { _.elementRuntimeData.dpathElementCompileInfo },
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/ElementBaseRuntime1Mixin.scala b/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/ElementBaseRuntime1Mixin.scala
index 7e1c616dca..a3323793f4 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/ElementBaseRuntime1Mixin.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/ElementBaseRuntime1Mixin.scala
@@ -30,15 +30,11 @@ import org.apache.daffodil.processors.SimpleTypeRuntimeData
 import org.apache.daffodil.dsom.SimpleTypeDefBase
 import org.apache.daffodil.dsom.ComplexTypeBase
 import org.apache.daffodil.dsom.PrimitiveType
-import org.apache.daffodil.infoset.ResolverType
 import org.apache.daffodil.infoset.SeveralPossibilitiesForNextElement
 import org.apache.daffodil.xml.QNameBase
 import org.apache.daffodil.infoset.NoNextElement
 import org.apache.daffodil.infoset.OnlyOnePossibilityForNextElement
-import org.apache.daffodil.infoset.NextElementResolver
 import org.apache.daffodil.api.WarnID
-import org.apache.daffodil.infoset.ChildResolver
-import org.apache.daffodil.infoset.SiblingResolver
 
 trait ElementBaseRuntime1Mixin { self: ElementBase =>
 
@@ -129,11 +125,12 @@ trait ElementBaseRuntime1Mixin { self: ElementBase =>
    * This is the compile info for this element term.
    */
   lazy val dpathElementCompileInfo: DPathElementCompileInfo = {
-    val ee = enclosingElements
+    val ee = enclosingElement.toSeq
+    lazy val parents = ee.map {
+      _.dpathElementCompileInfo
+    }
     val eci = new DPathElementCompileInfo(
-      ee.map {
-        _.dpathElementCompileInfo
-      },
+      parents,
       variableMap,
       elementChildrenCompileInfo,
       namespaces,
@@ -168,8 +165,7 @@ trait ElementBaseRuntime1Mixin { self: ElementBase =>
       position,
       childrenERDs,
       schemaSet.variableMap,
-      nextElementResolver,
-      childElementResolver,
+      partialNextElementResolver,
       encodingInfo,
       dpathElementCompileInfo,
       schemaFileLocation,
@@ -182,6 +178,7 @@ trait ElementBaseRuntime1Mixin { self: ElementBase =>
       targetNamespace,
       thisElementsNamespace,
       optSimpleTypeRuntimeData,
+      optComplexTypeModelGroupRuntimeData,
       minOccurs,
       maxOccurs,
       Maybe.toMaybe(optionOccursCountKind),
@@ -192,7 +189,7 @@ trait ElementBaseRuntime1Mixin { self: ElementBase =>
       isNillable,
       isArray, // can have more than 1 occurrence
       isOptional, // can have exactly 0 or 1 occurrence
-      isRequiredInInfoset, // must have at least 1 occurrence
+      isRequiredStreamingUnparserEvent, // must have at least 1 occurrence
       namedQName,
       isRepresented,
       couldHaveText,
@@ -215,53 +212,13 @@ trait ElementBaseRuntime1Mixin { self: ElementBase =>
     newERD
   }
 
-  private lazy val optSimpleTypeRuntimeData: Option[SimpleTypeRuntimeData] =
+  private lazy val (optSimpleTypeRuntimeData,
+    optComplexTypeModelGroupRuntimeData) =
     typeDef match {
-      case _: PrimitiveType => None
-      case _: ComplexTypeBase => None
+      case _: PrimitiveType => (None, None)
+      case ctb: ComplexTypeBase => (None, Some(ctb.modelGroup.modelGroupRuntimeData))
       case s: SimpleTypeDefBase =>
-        Some(s.simpleTypeRuntimeData)
+        (Some(s.simpleTypeRuntimeData), None)
     }
 
-  /**
-   * The NextElementResolver is used to determine what infoset event comes next, and "resolves" which is to say
-   * determines the ElementRuntimeData for that infoset event. This can be used to construct the initial
-   * infoset from a stream of XML events.
-   */
-  final def computeNextElementResolver(possibles: Seq[ElementBase], resolverType: ResolverType): NextElementResolver = {
-    //
-    // Annoying, but scala's immutable Map is not covariant in its first argument
-    // the way one would normally expect a collection to be.
-    // So Map[NamedQName, ElementRuntimeData] is not a subtype of Map[QNameBase, ElementRuntimeData]
-    // So we need a cast upward to Map[QNameBase,ElementRuntimeData]
-    //
-    val eltMap = possibles.map {
-      e => (e.namedQName, e.elementRuntimeData)
-    }.toMap.asInstanceOf[Map[QNameBase, ElementRuntimeData]]
-    val resolver = eltMap.size match {
-      case 0 => new NoNextElement(schemaFileLocation, resolverType)
-      case 1 => new OnlyOnePossibilityForNextElement(schemaFileLocation, eltMap.values.head, resolverType)
-      case _ => {
-        val groupedByName = possibles.groupBy(_.namedQName.local)
-        var hasNamesDifferingOnlyByNS = false
-        groupedByName.foreach {
-          case (_, sameNamesEB) =>
-            if (sameNamesEB.length > 1) {
-              SDW(WarnID.NamespaceDifferencesOnly, "Neighboring QNames differ only by namespaces. Infoset representations that do not support namespacess cannot differentiate between these elements and may fail to unparse. QNames are: %s",
-                sameNamesEB.map(_.namedQName.toExtendedSyntax).mkString(", "))
-              hasNamesDifferingOnlyByNS = true
-            }
-        }
-        new SeveralPossibilitiesForNextElement(schemaFileLocation, eltMap, resolverType, hasNamesDifferingOnlyByNS)
-      }
-    }
-    resolver
-  }
-
-  final lazy val nextElementResolver: NextElementResolver = {
-    computeNextElementResolver(possibleNextChildElementsInInfoset, SiblingResolver)
-  }
-
-  final lazy val childElementResolver: NextElementResolver =
-    computeNextElementResolver(possibleFirstChildElementsInInfoset, ChildResolver)
 }
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/GramRuntime1Mixin.scala b/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/GramRuntime1Mixin.scala
index dd3feb0850..020f3d252f 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/GramRuntime1Mixin.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/GramRuntime1Mixin.scala
@@ -51,7 +51,7 @@ trait GramRuntime1Mixin { self: Gram =>
    */
   def unparser: Unparser
 
-  final def maybeUnparser: Maybe[Unparser] = {
+  final lazy val maybeUnparser: Maybe[Unparser] = {
     if (this.isEmpty) Maybe.Nope
     else {
       val u = this.unparser
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/SequenceTermRuntime1Mixin.scala b/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/SequenceTermRuntime1Mixin.scala
index 6e8c86bd56..234e43b570 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/SequenceTermRuntime1Mixin.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/SequenceTermRuntime1Mixin.scala
@@ -28,8 +28,10 @@ trait SequenceTermRuntime1Mixin { self: SequenceTermBase =>
 
   def modelGroupRuntimeData = sequenceRuntimeData
 
-  final lazy val sequenceRuntimeData = {
+  lazy val sequenceRuntimeData = {
     new SequenceRuntimeData(
+      position,
+      partialNextElementResolver,
       schemaSet.variableMap,
       encodingInfo,
       // elementChildren.map { _.elementRuntimeData.dpathElementCompileInfo },
@@ -56,6 +58,8 @@ trait ChoiceBranchImpliedSequenceRuntime1Mixin { self: ChoiceBranchImpliedSequen
 
   override lazy val sequenceRuntimeData: SequenceRuntimeData = {
     new SequenceRuntimeData(
+      position,
+      partialNextElementResolver,
       schemaSet.variableMap,
       encodingInfo,
       schemaFileLocation,
diff --git a/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/TermRuntime1Mixin.scala b/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/TermRuntime1Mixin.scala
index cf9cb12b80..2e65f142e9 100644
--- a/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/TermRuntime1Mixin.scala
+++ b/daffodil-core/src/main/scala/org/apache/daffodil/runtime1/TermRuntime1Mixin.scala
@@ -18,20 +18,70 @@
 package org.apache.daffodil.runtime1
 
 import org.apache.daffodil.xml.QNameBase
+
+import org.apache.daffodil.infoset.PartialNextElementResolver
 import org.apache.daffodil.infoset.SeveralPossibilitiesForNextElement
 import org.apache.daffodil.processors.ElementRuntimeData
 import org.apache.daffodil.infoset.NoNextElement
 import org.apache.daffodil.infoset.OnlyOnePossibilityForNextElement
 import org.apache.daffodil.api.WarnID
-import org.apache.daffodil.dsom.Term
-import org.apache.daffodil.dsom.ElementBase
-import org.apache.daffodil.dsom.ModelGroup
-import org.apache.daffodil.dsom.DPathElementCompileInfo
-import org.apache.daffodil.dsom.PrefixLengthQuasiElementDecl
+import org.apache.daffodil.dsom._
 import org.apache.daffodil.processors.TermRuntimeData
 import org.apache.daffodil.schema.annotation.props.gen.NilKind
 import org.apache.daffodil.schema.annotation.props.gen.Representation
 import org.apache.daffodil.schema.annotation.props.gen.LengthKind
+import org.apache.daffodil.exceptions.Assert
+
+import org.apache.daffodil.infoset.DoNotUseThisResolver
+
+/**
+ * A set of possibilities for elements that can arrive as events
+ * on the input event stream of the streaming unparser.
+ */
+sealed trait PossibleNextElements {
+  import PossibleNextElements._
+  def pnes: Seq[PossibleNextElement]
+}
+
+object PossibleNextElements {
+
+  /**
+   * PNE stands for Possible Next Element.
+   *
+   * Allows overriding the isRequiredStreamingUnparserEvent characteristic
+   * of a term.
+   *
+   * Used when a required ERD appears in a child of a choice.
+   * In that case, that ERD is optional since we could be on
+   * another choice branch.
+   */
+  case class PNE(e: ElementBase, overrideIsRequiredStreamingUnparserEvent: Boolean)
+  type PossibleNextElement = PNE
+
+  /**
+   * Indicates one of the possibilities must be found.
+   * Simplest case for this is a run of optional elements followed
+   * by a required element in a sequence. Can also occur if all
+   * branches of a choice are Closed. Then the resulting choice
+   * possibilities are also Closed.
+   */
+  case class Closed(override val pnes: Seq[PNE]) extends PossibleNextElements
+
+  /**
+   * Indicates that these are possible, but all are optional
+   * so a surrounding sequence group on the stack could also provide
+   * a matching element.
+   */
+  case class Open(override val pnes: Seq[PNE]) extends PossibleNextElements
+
+  /**
+   * Indicates that there should never be any use of possible next elements for
+   * the associated Term (QuasiElements is the use case).
+   */
+  case object DoNotUse extends PossibleNextElements {
+    override def pnes = Assert.usageError("do not use")
+  }
+}
 
 /**
  * Part of Daffodil's Runtime 1 Streaming Unparser Support.
@@ -49,6 +99,295 @@ trait TermRuntime1Mixin { self: Term =>
 
   def termRuntimeData: TermRuntimeData
 
+  import PossibleNextElements._
+
+  /*
+   * Returns a Closed or Open list of posslble elements that could follow this Term, within its
+   * lexically enclosing model group.
+   *
+   * Does not follow backpointers from group defs to group refs.
+   *
+   * It is ok, and has no negative impact on sharing for a Term to reference
+   * its lexically enclosing model group.
+   *
+   * Within the lexically enclosing model group, if that group is a sequence, then
+   * this computation involves subsequent siblings, children of those siblings.
+   */
+  lazy val possibleNextLexicalSiblingStreamingUnparserElements: PossibleNextElements = {
+    val res = this match {
+      // Quasi elements are used for type-value calc, and for prefixed lengths
+      // we never consider them for streaming unparsing. They are never present as events.
+      // Nor should they ever be used as the source of next-event information.
+      case qe: QuasiElementDeclBase =>
+        DoNotUse // never resolve siblings. These shouldn't pull unparser events ever
+      //
+      // For a sequence, the possible next siblings elements excludes children of
+      // the sequence itself. This is because we only use this list to find things that
+      // are AFTER the sequence itself. The contents of the sequence itself are
+      // going to be handled by the "self" cases for elements and choices.
+      // So we use just the following siblings.
+      //
+      // In the actual runtime, this information is never on top of the dynamic context
+      // stack. It is always down at least one on the stack. It is only used when the
+      // term itself has not provided a match to the incoming event, and we need to
+      // see if things following the term provide a match.
+      //
+      case stb: SequenceTermBase =>
+        followingLexicalSiblingStreamingUnparserElements
+      case _ =>
+        possibleSelfPlusNextLexicalSiblingStreamingUnparserElements
+    }
+    res
+  }
+
+  final protected lazy val possibleSelfPlusNextLexicalSiblingStreamingUnparserElements: PossibleNextElements =
+    LV('possibleSelfPlusNextLexicalSiblingStreamingUnparserElements) {
+      val thisItself: PossibleNextElements = this match {
+        //
+        // An array may be required in the infoset, but the array
+        // may also be terminated by finding the next element after the array,
+        // so we get closed only if required and not an array.
+        //
+        case eb: ElementBase if (eb.isRequiredStreamingUnparserEvent) =>
+          Closed(Seq(PNE(eb, true)))
+        case eb: ElementBase =>
+          Open(Seq(PNE(eb, false)))
+        case ctb: ChoiceTermBase => {
+          val individualBranchPossibles = ctb.groupMembers.map {
+            _.possibleSelfPlusNextLexicalSiblingStreamingUnparserElements
+          }
+          //
+          // If all branches are closed, then the overall set will be
+          // closed for the whole choice. Some element from the choice will
+          // have to appear next. But no specific individual one is required.
+          //
+          val allBranchesClosed =
+            individualBranchPossibles.forall {
+              case c: Closed => true
+              case o: Open => false
+              case DoNotUse => Assert.invariantFailed("should never be DoNotUse")
+            }
+          //
+          // Individual possible next elements (aka sibs) come from
+          // various branches. Within those branches they may be required to appear
+          // in the stream of events, but as alternatives of a choice, none of
+          // them are specifically required, because you could always be
+          // unparsing some other branch.
+          // So in the PNE we override them to have false for
+          // the overrideIsRequiredStreamingUnparserEvent.
+          //
+          val allSibsAsOptional = individualBranchPossibles.flatMap { poss =>
+            poss.pnes.map {
+              case PNE(eb, true) =>
+                PNE(eb, false)
+              case ok @ PNE(eb, false) =>
+                ok
+            }
+          }
+          val res: PossibleNextElements =
+            if (allBranchesClosed) {
+              Closed(allSibsAsOptional)
+            } else {
+              Open(allSibsAsOptional)
+            }
+          res
+        }
+        case stb: SequenceTermBase if !stb.isHidden => {
+          //
+          // This case only applies to when we are analyzing a sequence, but it is
+          // being considered as contributing possible elements that are after the
+          // end of a Term.
+          //
+          // In this case, we DO recursively walk into the sequence's own children
+          //
+          val subTerms = stb.groupMembers
+          val res =
+            subTerms.headOption.map { _.possibleSelfPlusNextLexicalSiblingStreamingUnparserElements }
+          res.getOrElse(Open(Nil))
+        }
+        case stb: SequenceTermBase if stb.isHidden =>
+          Open(Nil)
+      }
+      val res = thisItself match {
+        //
+        // check this case separately first to avoid evaluating
+        // followingLexicalSiblingStreamingUnparserElements unless
+        // we have to.
+        //
+        case Closed(pnes1) => thisItself // most common case - a required element.
+        case _ => {
+          val res: PossibleNextElements =
+            (thisItself, followingLexicalSiblingStreamingUnparserElements) match {
+              case (Open(pnes1), Closed(Nil)) => thisItself // case of Open(...) followed by end of complex element.
+              case (poss1, Closed(pnes2)) => Closed((poss1.pnes ++ pnes2).distinct)
+              case (poss1, poss2) => Open((poss1.pnes ++ poss2.pnes).distinct)
+            }
+          res
+        }
+      }
+      res
+    }.value
+
+  /**
+   * Computes the possible next elements after a term, not including any that
+   * the term itself may have as possibilities.
+   */
+  private lazy val followingLexicalSiblingStreamingUnparserElements: PossibleNextElements =
+    LV('followingLexicalSiblingStreamingUnparserElements) {
+      Assert.invariant(optLexicalParent.isDefined)
+      val lexicalParent = optLexicalParent.get
+      lexicalParent match {
+        case parentSeqDef: SequenceDefMixin => {
+          //
+          // start after this term in the lexically enclosing sequence siblings
+          //
+          val sibTerms = parentSeqDef.groupMembers.drop(position)
+          //
+          // compute what is possible for each of them.
+          //
+          val sibPossibles = sibTerms.map { _.possibleSelfPlusNextLexicalSiblingStreamingUnparserElements }
+          //
+          // split the possibles into the opens and closed lists
+          // Then assemble the opens plus the first closed if it exists.
+          //
+          val (opens, closedAndAfter) = sibPossibles.span { _.isInstanceOf[Open] }
+          val optFirstClosed = closedAndAfter.headOption
+          val opensPlusFirstClosed = opens ++ optFirstClosed
+          val hasClosed = optFirstClosed.isDefined
+
+          val combinedSibs = opensPlusFirstClosed.flatMap { _.pnes }.distinct
+          val res: PossibleNextElements =
+            if (hasClosed) {
+              Closed(combinedSibs)
+            } else {
+              Open(combinedSibs)
+            }
+          res
+        }
+        case c: ChoiceDefMixin => {
+          // This is a branch of a choice
+          // So what follows this branch is whatever follows the choice
+          // but we don't compute that statically, because if this
+          // is a term inside a global choice group def, then we'd have
+          // to know about the dynamic context.
+          // Instead we just leave this open
+          // and at runtime a stack will have the enclosing dynamic term's info.
+          Open(Nil)
+        }
+        case ct: ComplexTypeBase => {
+          // This is the model group of a complex type element
+          Assert.invariant(this.isInstanceOf[ModelGroup])
+          Closed(Nil)
+        }
+        case sd: SchemaDocument => {
+          // Can only happen for Root
+          Assert.invariant(this.isInstanceOf[Root])
+          Closed(Nil)
+        }
+        case _ =>
+          Assert.invariantFailed(
+            "unexpected lexical parent type for term: " + lexicalParent)
+      }
+    }.value
+
+  /**
+   * The PartialNextElementResolver is used to determine what infoset event comes next, and "resolves" which is to say
+   * determines the ElementRuntimeData for that infoset event. This can be used to construct the initial
+   * infoset from a stream of XML events.
+   */
+  final lazy val partialNextElementResolver: PartialNextElementResolver = {
+    val context = self
+    val possibles = possibleNextLexicalSiblingStreamingUnparserElements
+
+    self match {
+      case _: QuasiElementDeclBase => {
+        Assert.invariant(possibles eq PossibleNextElements.DoNotUse)
+        new DoNotUseThisResolver(termRuntimeData) // Does an assert fail if used.
+      }
+      case _ => {
+        //
+        // Annoying, but scala's immutable Map is not covariant in its first argument
+        // the way one would normally expect a collection to be.
+        // So Map[NamedQName, ElementRuntimeData] is not a subtype of Map[QNameBase, ElementRuntimeData]
+        // So we need a cast upward to Map[QNameBase,ElementRuntimeData]
+        //
+        val trd = context.termRuntimeData
+        val (sibs, isRequiredStreamingUnparserEvent) = possibles match {
+          case PossibleNextElements.Closed(sibs) => (sibs, true)
+          case PossibleNextElements.Open(sibs) => (sibs, false)
+          case PossibleNextElements.DoNotUse => Assert.invariantFailed("should never be DoNotUse")
+        }
+        val eltMap = sibs.map {
+          sib => (sib.e.namedQName, sib.e.erd)
+        }.toMap.asInstanceOf[Map[QNameBase, ElementRuntimeData]]
+        val resolver = eltMap.size match {
+          case 0 => new NoNextElement(trd, isRequiredStreamingUnparserEvent)
+          case 1 => new OnlyOnePossibilityForNextElement(
+            trd,
+            sibs.head.e.erd,
+            isRequiredStreamingUnparserEvent)
+          case _ => {
+            val groupedByName = possibles.pnes.groupBy(_.e.namedQName.local)
+            var hasNamesDifferingOnlyByNS = false
+            groupedByName.foreach {
+              case (_, sameNamesEB) =>
+                if (sameNamesEB.length > 1) {
+                  context.SDW(
+                    WarnID.NamespaceDifferencesOnly,
+                    "Neighboring QNames differ only by namespaces. " +
+                      "Infoset representations that do not support namespaces " +
+                      "cannot differentiate between these elements and " +
+                      "may fail to unparse. QNames are: %s",
+                    sameNamesEB.map(_.e.namedQName.toExtendedSyntax).mkString(", "))
+                  hasNamesDifferingOnlyByNS = true
+                }
+            }
+            new SeveralPossibilitiesForNextElement(
+              trd,
+              eltMap,
+              hasNamesDifferingOnlyByNS,
+              isRequiredStreamingUnparserEvent)
+          }
+        }
+        resolver
+      }
+    }
+  }
+
+  /**
+   * For streaming unparser, determines if this Term could
+   * have suspensions associated with it.
+   */
+  final protected lazy val couldHaveSuspensions: Boolean = {
+    val commonCouldHaveSuspensions =
+      !isKnownToBeAligned || // AlignmentFillUnparser
+        (if (hasDelimiters) !isDelimiterKnownToBeTextAligned else false) || // MandatoryTextAlignmentUnparser
+        needsBitOrderChange // BitOrderChangeUnparser
+
+    this match {
+      case eb: ElementBase => {
+        val elementCouldHaveSuspensions =
+          commonCouldHaveSuspensions ||
+            !isKnownToBeTextAligned || // MandatoryTextAlignmentUnparser
+            (if (eb.isSimpleType) eb.isOutputValueCalc else false) || // SimpleTypeRetryUnparser
+            eb.shouldAddFill || // ElementUnusedUnparser, RightFillUnparser
+            eb.shouldCheckExcessLength || // ElementUnusedUnparser, RightFillUnparser
+            eb.shouldAddPadding || // OnlyPaddingUnparser, RightCenteredPaddingUnparser, LeftCenteredPaddingUnparser
+            (eb.maybeUnparseTargetLengthInBitsEv.isDefined && eb.isNillable && eb.nilKind == NilKind.LiteralCharacter) || // NilLiteralCharacterUnparser
+            (if (eb.isComplexType) eb.complexType.group.couldHaveSuspensions else false)
+
+        elementCouldHaveSuspensions
+      }
+      case mg: ModelGroup => {
+        val modelGroupCouldHaveSuspensions =
+          commonCouldHaveSuspensions ||
+            mg.groupMembers.exists { _.couldHaveSuspensions }
+
+        modelGroupCouldHaveSuspensions
+      }
+    }
+  }
+
   /**
    * Set of elements referenced from an expression in the scope of this term.
    *
diff --git a/daffodil-core/src/test/scala/org/apache/daffodil/dpath/TestDFDLExpressionEvaluation.scala b/daffodil-core/src/test/scala/org/apache/daffodil/dpath/TestDFDLExpressionEvaluation.scala
index 5e97048039..a6c605a865 100644
--- a/daffodil-core/src/test/scala/org/apache/daffodil/dpath/TestDFDLExpressionEvaluation.scala
+++ b/daffodil-core/src/test/scala/org/apache/daffodil/dpath/TestDFDLExpressionEvaluation.scala
@@ -31,25 +31,24 @@ import org.apache.daffodil.io.InputSourceDataInputStream
 import org.apache.daffodil.infoset.DIDocument
 import org.apache.daffodil.infoset.NullInfosetOutputter
 import org.apache.daffodil.infoset.TestInfoset
+import org.apache.daffodil.processors.DataProcessor
+import org.apache.daffodil.infoset.InfosetDocument
 
 class TestDFDLExpressionEvaluation extends Parsers {
 
   def testExpr(testSchema: scala.xml.Elem, infosetAsXML: scala.xml.Elem, expr: String)(body: Any => Unit) {
     val schemaCompiler = Compiler()
+    schemaCompiler.setTunable("allowExternalPathExpressions", "true")
     val pf = schemaCompiler.compileNode(testSchema).asInstanceOf[ProcessorFactory]
-    if (pf.isError) fail("pf compile errors")
-    val dp = pf.onPath("/")
     val sset = pf.sset
-    val Seq(schema) = sset.schemas
-    val Seq(schemaDoc, _) = schema.schemaDocuments
-    val Seq(declf) = schemaDoc.globalElementDecls
-    val decl = declf.forRoot()
-    val erd = decl.elementRuntimeData
-    val infosetRootElem = TestInfoset.elem2Infoset(erd, infosetAsXML)
+    if (pf.isError) fail("pf compile errors")
+    val dp = pf.onPath("/").asInstanceOf[DataProcessor]
+    val infosetRootElem = TestInfoset.elem2Infoset(infosetAsXML, dp)
+    val erd = infosetRootElem.erd
     val qn = GlobalQName(Some("daf"), "testExpr", XMLUtils.dafintURI)
     val exprCompiler = new DFDLPathExpressionParser[AnyRef](qn, NodeInfo.AnyType, testSchema.scope, erd.dpathCompileInfo, false, sset)
     val compiledExpr = exprCompiler.compile(expr)
-    val doc = infosetRootElem.parent.asInstanceOf[DIDocument]
+    val doc = infosetRootElem.parent.asInstanceOf[InfosetDocument]
 
     val dis = InputSourceDataInputStream(java.nio.ByteBuffer.allocate(0)) // fake. Zero bits available.
     val outputter = new NullInfosetOutputter()
diff --git a/daffodil-core/src/test/scala/org/apache/daffodil/dsom/TestRefMap.scala b/daffodil-core/src/test/scala/org/apache/daffodil/dsom/TestRefMap.scala
index 9467aca363..d003fcfae3 100644
--- a/daffodil-core/src/test/scala/org/apache/daffodil/dsom/TestRefMap.scala
+++ b/daffodil-core/src/test/scala/org/apache/daffodil/dsom/TestRefMap.scala
@@ -191,7 +191,7 @@ class TestRefMap extends Logging {
       </xs:complexType>
       <xs:group name="g1">
         <xs:choice>
-          <xs:element name="e1" type="xs:int" dfdl:length="1" dfdl:lengthKind="explicit"/>
+          <xs:element name="e1" type="xs:int" dfdl:length="1" dfdl:lengthKind="explicit" dfdl:outputValueCalc="{ 0 }"/>
           <xs:element name="f1" type="xs:int" dfdl:length="1" dfdl:lengthKind="explicit"/>
         </xs:choice>
       </xs:group>)
diff --git a/daffodil-core/src/test/scala/org/apache/daffodil/dsom/TextCompileExpressionExecution.scala b/daffodil-core/src/test/scala/org/apache/daffodil/dsom/TextCompileExpressionExecution.scala
deleted file mode 100644
index 19dc1d2478..0000000000
--- a/daffodil-core/src/test/scala/org/apache/daffodil/dsom/TextCompileExpressionExecution.scala
+++ /dev/null
@@ -1,28 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.daffodil.dsom
-
-import org.apache.daffodil.xml.XMLUtils
-
-class TextCompileExpressionExecution {
-  val xsd = XMLUtils.XSD_NAMESPACE
-  val dfdl = XMLUtils.DFDL_NAMESPACE
-  val xsi = XMLUtils.XSI_NAMESPACE
-  val example = XMLUtils.EXAMPLE_NAMESPACE
-
-}
diff --git a/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfoset.scala b/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfoset.scala
index 0975815c1a..767702a055 100644
--- a/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfoset.scala
+++ b/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfoset.scala
@@ -26,6 +26,11 @@ import org.junit.Test
 import org.apache.daffodil.processors.ElementRuntimeData
 import org.apache.daffodil.exceptions.Assert
 import org.apache.daffodil.api.DaffodilTunables
+import org.apache.daffodil.io.DirectOrBufferedDataOutputStream
+import org.apache.daffodil.processors.DataProcessor
+import org.apache.daffodil.dsom.ElementBase
+import org.apache.daffodil.processors.unparsers.UStateMain
+import org.apache.commons.io.output.NullOutputStream
 
 object TestInfoset {
   /**
@@ -43,15 +48,55 @@ object TestInfoset {
 
   private val tunableForTests = DaffodilTunables("allowExternalPathExpressions", "true")
 
-  def elem2Infoset(erd: ElementRuntimeData, xmlElem: scala.xml.Node): InfosetElement = {
+  def elem2Infoset(
+    xmlElem: scala.xml.Node,
+    dp: DataProcessor): DIElement = {
     val ic = new ScalaXMLInfosetInputter(xmlElem)
-    ic.initialize(erd, tunableForTests)
-    val aacc = ic.advanceAccessor
-    Assert.invariant(ic.advance == true)
-    val infosetRootNode = aacc.node
-    while (ic.advance) {}
-    infosetRootNode.asInstanceOf[InfosetElement]
+    //
+    // A prior version of this code just pulled events to force the
+    // infoset to be constructed. That doesn't work anymore.
+    // The structure of the schema must be respected and the
+    // TermRuntimeData must be pushed/popped appropriately.
+    //
+    // Really the only way to do this is to invoke the unparser since that is
+    // what maintains the schema dynamic runtime context.
+    //
+    val inputter = new ScalaXMLInfosetInputter(xmlElem)
+    val dummyOutStream = new NullOutputStream
+    val unparseResult = dp.unparse(inputter, dummyOutStream)
+    val infosetRootNode = {
+      val ustate = unparseResult.resultState.asInstanceOf[UStateMain]
+      val diDocument: DIDocument = ustate.documentElement
+      val rootElement = diDocument.getRootElement().asInstanceOf[DIElement]
+      Assert.invariant(rootElement ne null)
+      rootElement
+    }
+    infosetRootNode
   }
+
+  /**
+   * Returns the root element of the infoset, along with
+   * the schema compiler Root object for examining schema-compiler
+   * computations for unit testing them.
+   */
+  def testInfoset(testSchema: scala.xml.Elem, infosetAsXML: scala.xml.Elem) = {
+    val schemaCompiler = Compiler()
+    schemaCompiler.setTunable("allowExternalPathExpressions", "true")
+    val pf = schemaCompiler.compileNode(testSchema).asInstanceOf[ProcessorFactory]
+    if (pf.isError) {
+      val msgs = pf.getDiagnostics.map { _.getMessage() }.mkString("\n")
+      fail("pf compile errors: " + msgs)
+    }
+    pf.rootElem.erd.preSerialization // force evaluation of all compile-time constructs
+    val dp = pf.onPath("/").asInstanceOf[DataProcessor]
+    if (dp.isError) {
+      val msgs = dp.getDiagnostics.map { _.getMessage() }.mkString("\n")
+      fail("dp compile errors: " + msgs)
+    }
+    val infosetRootElem = TestInfoset.elem2Infoset(infosetAsXML, dp)
+    (infosetRootElem, pf.rootElem)
+  }
+
 }
 
 class TestInfoset1 {
@@ -59,6 +104,7 @@ class TestInfoset1 {
   val dfdl = XMLUtils.dfdlAppinfoSource // XMLUtils.DFDL_NAMESPACE
   val xsi = XMLUtils.XSI_NAMESPACE
   val ex = XMLUtils.EXAMPLE_NAMESPACE
+  import TestInfoset._
 
   @Test def testXMLToInfoset1() {
     val testSchema = SchemaUtils.dfdlTestSchema(
@@ -73,19 +119,10 @@ class TestInfoset1 {
 
     val xmlInfoset = <list xmlns={ ex }><w>4</w></list>
 
-    val compiler = Compiler()
-    val sset = compiler.compileNode(testSchema).sset
-    val Seq(schema) = sset.schemas
-    val Seq(schemaDoc, _) = schema.schemaDocuments
-    val Seq(declf) = schemaDoc.globalElementDecls
-    val decl = declf.forRoot()
-    val list_erd = decl.elementRuntimeData
-    val Seq(w) = decl.elementChildren
-    val w_erd = w.elementRuntimeData
-    //    val wSlot = w.slotIndexInParent
-    val infoset = TestInfoset.elem2Infoset(decl.elementRuntimeData, xmlInfoset).asInstanceOf[InfosetComplexElement]
-    assertTrue(infoset.isInstanceOf[DIComplex])
+    val (infoset: DIComplex, _) = testInfoset(testSchema, xmlInfoset)
+    val list_erd = infoset.erd
     assertEquals(list_erd, infoset.runtimeData)
+    val Seq(w_erd) = list_erd.childERDs
     val wItem = infoset.getChild(w_erd).asInstanceOf[InfosetSimpleElement]
     assertEquals(infoset, wItem.parent)
     assertEquals(4, wItem.dataValue)
@@ -109,25 +146,14 @@ class TestInfoset1 {
       </xs:complexType>)
 
     val xmlInfoset = <list xmlns={ ex }><w>4</w><c>7</c></list>
-
-    val compiler = Compiler()
-    val sset = compiler.compileNode(testSchema).sset
-    val Seq(schema) = sset.schemas
-    val Seq(schemaDoc, _) = schema.schemaDocuments
-    val Seq(declf) = schemaDoc.globalElementDecls
-    val decl = declf.forRoot()
-    val list_erd = decl.elementRuntimeData
-    val Seq(w, _, _, _) = decl.elementChildren;
-    assertNotNull(w)
-    val Seq(w_erd, _, _, c_erd) = decl.elementRuntimeData.childERDs
-    //    val wSlot = w.slotIndexInParent
-    val infoset = TestInfoset.elem2Infoset(decl.elementRuntimeData, xmlInfoset).asInstanceOf[InfosetComplexElement]
-    assertTrue(infoset.isInstanceOf[DIComplex])
+    val (infoset, _) = testInfoset(testSchema, xmlInfoset)
     assertNotNull(infoset.parent)
+    val list_erd = infoset.erd
+    val Seq(w_erd, _, _, c_erd) = list_erd.childERDs
     assertEquals(list_erd, infoset.runtimeData)
-    val wItem = infoset.getChild(w_erd).asInstanceOf[InfosetSimpleElement]
+    val wItem = infoset.asComplex.getChild(w_erd).asInstanceOf[InfosetSimpleElement]
     assertEquals(4, wItem.dataValue)
-    val cItem = infoset.getChild(c_erd).asInstanceOf[InfosetSimpleElement]
+    val cItem = infoset.asComplex.getChild(c_erd).asInstanceOf[InfosetSimpleElement]
     assertEquals(7, cItem.dataValue)
     assertEquals(infoset, cItem.parent)
   }
@@ -144,19 +170,8 @@ class TestInfoset1 {
       </xs:complexType>)
 
     val xmlInfoset = <list xmlns={ ex }><w>4</w><w>5</w></list>
-
-    val compiler = Compiler()
-    val sset = compiler.compileNode(testSchema).sset
-    val Seq(schema) = sset.schemas
-    val Seq(schemaDoc, _) = schema.schemaDocuments
-    val Seq(declf) = schemaDoc.globalElementDecls
-    val decl = declf.forRoot()
-    decl.elementRuntimeData
-    val ec @ Seq(_) = decl.elementChildren; assertNotNull(ec)
-    val Seq(w_erd) = decl.elementRuntimeData.childERDs
-    //    val wSlot = w.slotIndexInParent
-    val infoset = TestInfoset.elem2Infoset(decl.elementRuntimeData, xmlInfoset).asInstanceOf[InfosetComplexElement]
-    assertTrue(infoset.isInstanceOf[DIComplex])
+    val (infoset: DIComplex, _) = testInfoset(testSchema, xmlInfoset)
+    val Seq(w_erd) = infoset.erd.childERDs
     infoset.getChildArray(w_erd) match {
       case arr: DIArray => {
         assertEquals(2, arr.length)
@@ -190,18 +205,9 @@ class TestInfoset1 {
 
     val xmlInfoset = <list xmlns={ ex }><w>4</w><w>5</w><c>7</c></list>
 
-    val compiler = Compiler()
-    val sset = compiler.compileNode(testSchema).sset
-    val Seq(schema) = sset.schemas
-    val Seq(schemaDoc, _) = schema.schemaDocuments
-    val Seq(declf) = schemaDoc.globalElementDecls
-    val decl = declf.forRoot()
-    decl.elementRuntimeData
-    val ec @ Seq(_, _, _, _) = decl.elementChildren; assertNotNull(ec)
-    val Seq(w_erd, _, _, c_erd) = decl.elementRuntimeData.childERDs
-    //    val wSlot = w.slotIndexInParent
-    val infoset = TestInfoset.elem2Infoset(decl.elementRuntimeData, xmlInfoset).asInstanceOf[InfosetComplexElement]
-    assertTrue(infoset.isInstanceOf[DIComplex])
+    val (infoset: DIComplex, _) = testInfoset(testSchema, xmlInfoset)
+    val list_erd = infoset.erd
+    val Seq(w_erd, _, _, c_erd) = list_erd.childERDs
     infoset.getChildArray(w_erd) match {
       case arr: DIArray => {
         var a = arr(1).asInstanceOf[InfosetSimpleElement]
@@ -233,17 +239,11 @@ class TestInfoset1 {
 
     val xmlInfoset = <list xmlns={ ex } xmlns:xsi={ xsi }><x xsi:nil='true'/></list>
 
-    val compiler = Compiler()
-    val sset = compiler.compileNode(testSchema).sset
-    val Seq(schema) = sset.schemas
-    val Seq(schemaDoc, _) = schema.schemaDocuments
-    val Seq(declf) = schemaDoc.globalElementDecls
-    val decl = declf.forRoot()
-    decl.elementRuntimeData
-    val ec @ Seq(_) = decl.elementChildren; assertNotNull(ec)
-    val Seq(x_erd) = decl.elementRuntimeData.childERDs
+    val (infoset: DIComplex, _) = testInfoset(testSchema, xmlInfoset)
+    val list_erd = infoset.erd
+    val Seq(x_erd) = list_erd.childERDs
     assertTrue(x_erd.isArray)
-    val infoset = TestInfoset.elem2Infoset(decl.elementRuntimeData, xmlInfoset).asInstanceOf[InfosetComplexElement]
+
     assertTrue(infoset.isInstanceOf[DIComplex])
     val xchild = infoset.getChildArray(x_erd)
     xchild match {
@@ -263,7 +263,7 @@ class TestInfoset1 {
       <xs:element name="list" type="tns:example1"/>
       <xs:complexType name="example1">
         <xs:sequence>
-          <xs:element name="x" minOccurs="0" maxOccurs="2" dfdl:occursCountKind="parsed" nillable='true' dfdl:nilKind="literalValue" dfdl:nilValue="-">
+          <xs:element name="x" minOccurs="0" maxOccurs="2" dfdl:occursCountKind="parsed" nillable='true' dfdl:nilKind="literalValue" dfdl:nilValue="%ES;">
             <xs:complexType>
               <xs:choice>
                 <xs:element name="a" type="xs:int" dfdl:length="1" dfdl:lengthKind="explicit"/>
@@ -277,20 +277,9 @@ class TestInfoset1 {
 
     val xmlInfoset = <list xmlns={ ex } xmlns:xsi={ xsi }><x xsi:nil='true'/></list>
 
-    val compiler = Compiler()
-    val sset = compiler.compileNode(testSchema).sset
-    val Seq(schema) = sset.schemas
-    val Seq(schemaDoc, _) = schema.schemaDocuments
-    val Seq(declf) = schemaDoc.globalElementDecls
-    val decl = declf.forRoot()
-    decl.elementRuntimeData
-    val ec @ Seq(_) = decl.elementChildren; assertNotNull(ec)
-    val Seq(x_erd) = decl.elementRuntimeData.childERDs
-    val Seq(_, _, c_erd) = x_erd.childERDs
-    assertTrue(x_erd.isArray)
-    assertFalse(c_erd.isArray)
-    val infoset = TestInfoset.elem2Infoset(decl.elementRuntimeData, xmlInfoset).asInstanceOf[InfosetComplexElement]
-    assertTrue(infoset.isInstanceOf[DIComplex])
+    val (infoset: DIComplex, _) = testInfoset(testSchema, xmlInfoset)
+    val list_erd = infoset.erd
+    val Seq(x_erd) = list_erd.childERDs
     infoset.getChildArray(x_erd) match {
       case xa: DIArray => {
         assertEquals(1, xa.length)
@@ -308,7 +297,7 @@ class TestInfoset1 {
       <xs:complexType name="example1">
         <xs:sequence>
           <xs:element name="w" type="xs:int" dfdl:length="1" dfdl:lengthKind="explicit" minOccurs="0" maxOccurs="2" dfdl:occursCountKind="parsed"/>
-          <xs:element name="x" minOccurs="0" maxOccurs="2" dfdl:occursCountKind="parsed" nillable='true' dfdl:nilKind="literalValue" dfdl:nilValue="-">
+          <xs:element name="x" minOccurs="0" maxOccurs="2" dfdl:occursCountKind="parsed" nillable='true' dfdl:nilKind="literalValue" dfdl:nilValue="%ES;">
             <xs:complexType>
               <xs:choice>
                 <xs:element name="a" type="xs:int" dfdl:length="1" dfdl:lengthKind="explicit"/>
@@ -322,21 +311,13 @@ class TestInfoset1 {
 
     val xmlInfoset = <list xmlns={ ex } xmlns:xsi={ xsi }><w>4</w><w>5</w><x xsi:nil='true'/><x><c>7</c></x></list>
 
-    val compiler = Compiler()
-    val sset = compiler.compileNode(testSchema).sset
-    val Seq(schema) = sset.schemas
-    val Seq(schemaDoc, _) = schema.schemaDocuments
-    val Seq(declf) = schemaDoc.globalElementDecls
-    val decl = declf.forRoot()
-    decl.elementRuntimeData
-    val ec @ Seq(_, _) = decl.elementChildren; assertNotNull(ec)
-    val Seq(w_erd, x_erd) = decl.elementRuntimeData.childERDs
-    val Seq(_, _, c_erd) = x_erd.childERDs
-    assertTrue(w_erd.isArray)
-    assertTrue(x_erd.isArray)
-    assertFalse(c_erd.isArray)
-    val infoset = TestInfoset.elem2Infoset(decl.elementRuntimeData, xmlInfoset).asInstanceOf[InfosetComplexElement]
-    assertTrue(infoset.isInstanceOf[DIComplex])
+    val (infoset: DIComplex, rootTerm) = testInfoset(testSchema, xmlInfoset)
+    val list_erd = infoset.erd
+    val rootPossibles = rootTerm.possibleNextLexicalSiblingStreamingUnparserElements
+    val Seq(wTerm: ElementBase, xTerm: ElementBase) = rootTerm.complexType.modelGroup.groupMembers
+    val xPossibles = xTerm.possibleNextLexicalSiblingStreamingUnparserElements
+    val Seq(w_erd, x_erd) = list_erd.childERDs
+    val Seq(a_erd, b_erd, c_erd) = x_erd.childERDs
     infoset.getChildArray(x_erd) match {
       case arr: DIArray => {
         assertEquals(2, arr.length)
@@ -360,7 +341,7 @@ class TestInfoset1 {
       <xs:complexType name="example1">
         <xs:sequence>
           <xs:element name="w" type="xs:int" dfdl:length="1" dfdl:lengthKind="explicit" minOccurs="0" maxOccurs="2" dfdl:occursCountKind="parsed"/>
-          <xs:element name="x" minOccurs="0" maxOccurs="2" dfdl:occursCountKind="parsed" nillable='true' dfdl:nilKind="literalValue" dfdl:nilValue="-">
+          <xs:element name="x" minOccurs="0" maxOccurs="2" dfdl:occursCountKind="parsed" nillable='true' dfdl:nilKind="literalValue" dfdl:nilValue="%ES;">
             <xs:complexType>
               <xs:choice>
                 <xs:element name="a" type="xs:int" dfdl:length="1" dfdl:lengthKind="explicit"/>
@@ -374,20 +355,10 @@ class TestInfoset1 {
 
     val xmlInfoset = <list xmlns={ ex }><x><c>7</c></x><x><b>8</b></x></list>
 
-    val compiler = Compiler()
-    val sset = compiler.compileNode(testSchema).sset
-    val Seq(schema) = sset.schemas
-    val Seq(schemaDoc, _) = schema.schemaDocuments
-    val Seq(declf) = schemaDoc.globalElementDecls
-    val decl = declf.forRoot()
-    decl.elementRuntimeData
-    val ec @ Seq(_, _) = decl.elementChildren; assertNotNull(ec)
-    val Seq(w_erd, x_erd) = decl.elementRuntimeData.childERDs
-    val Seq(_, b_erd, c_erd) = x_erd.childERDs; assertNotNull(b_erd)
-    assertTrue(w_erd.isArray)
-    assertTrue(x_erd.isArray)
-    assertFalse(c_erd.isArray)
-    val infoset = TestInfoset.elem2Infoset(decl.elementRuntimeData, xmlInfoset).asInstanceOf[InfosetComplexElement]
+    val (infoset: DIComplex, _) = testInfoset(testSchema, xmlInfoset)
+    val list_erd = infoset.erd
+    val Seq(w_erd, x_erd) = list_erd.childERDs
+    val Seq(a_erd, b_erd, c_erd) = x_erd.childERDs
 
     try {
       infoset.getChildArray(w_erd)
diff --git a/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfosetCursor.scala b/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfosetCursor.scala
index 1fb9a9a048..ff8c9535ae 100644
--- a/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfosetCursor.scala
+++ b/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfosetCursor.scala
@@ -25,18 +25,49 @@ import org.apache.daffodil.equality._
 import org.apache.daffodil.util.SchemaUtils
 import org.apache.daffodil.processors.DataProcessor
 import org.apache.daffodil.compiler.Compiler
+import org.apache.daffodil.processors.SequenceRuntimeData
+import org.apache.daffodil.processors.ChoiceRuntimeData
+
+import InfosetEventKind._
+import org.apache.daffodil.processors.ElementRuntimeData
 
 /**
  * Lets us pattern deconstruct infoset events, which is nice for unit testing
  */
 object Start {
-  def apply(node: DINode) = InfosetAccessor(StartKind, node, node.erd)
-  def unapply(ev: InfosetAccessor) = if (ev.kind eq StartKind) Some(ev.node) else None
+  def unapply(ev: InfosetAccessor) = if (ev.kind.isInstanceOf[StartKind]) Some(ev.info.element) else None
 }
 
 object End {
-  def apply(node: DINode) = InfosetAccessor(EndKind, node, node.erd)
-  def unapply(ev: InfosetAccessor) = if (ev.kind eq EndKind) Some(ev.node) else None
+  def unapply(ev: InfosetAccessor) = if (ev.kind.isInstanceOf[EndKind]) Some(ev.info.element) else None
+}
+
+object StartElement {
+  def apply(node: DIElement) = InfosetAccessor(InfosetEventKind.StartElement, node)
+  def unapply(ev: InfosetAccessor) = if (ev.kind eq InfosetEventKind.StartElement) Some(ev.info.element) else None
+}
+
+object EndElement {
+  def apply(node: DIElement) = InfosetAccessor(InfosetEventKind.EndElement, node)
+  def unapply(ev: InfosetAccessor) = if (ev.kind eq InfosetEventKind.EndElement) Some(ev.info.element) else None
+}
+
+object StartArray {
+  def apply(arrayERD: ElementRuntimeData) = InfosetAccessor(InfosetEventKind.StartArray, arrayERD)
+  def unapply(ev: InfosetAccessor) =
+    if (ev.kind eq InfosetEventKind.StartArray) {
+      assertTrue(ev.erd.isArray)
+      Some(ev.info.arrayERD)
+    } else None
+}
+
+object EndArray {
+  def apply(arrayERD: ElementRuntimeData) = InfosetAccessor(InfosetEventKind.EndArray, arrayERD)
+  def unapply(ev: InfosetAccessor) =
+    if (ev.kind eq InfosetEventKind.EndArray) {
+      assertTrue(ev.erd.isArray)
+      Some(ev.info.arrayERD)
+    } else None
 }
 
 class TestInfosetInputter {
@@ -61,7 +92,7 @@ class TestInfosetInputter {
     val rootERD = u.ssrd.elementRuntimeData
     val infosetInputter = new ScalaXMLInfosetInputter(infosetXML)
     infosetInputter.initialize(rootERD, u.getTunables())
-    infosetInputter
+    (infosetInputter, rootERD)
   }
 
   @Test def testInfosetInputterFromSimpleValue1() {
@@ -70,7 +101,7 @@ class TestInfosetInputter {
       <dfdl:format ref="tns:GeneralFormat"/>,
       <xs:element name="foo" dfdl:lengthKind="explicit" dfdl:length="5" type="xs:string"/>)
     val infosetXML = <foo xmlns={ XMLUtils.EXAMPLE_NAMESPACE }>Hello</foo>
-    val ic = infosetInputter(sch, infosetXML)
+    val (ic, rootERD) = infosetInputter(sch, infosetXML)
 
     val aacc: InfosetAccessor = ic.advanceAccessor
     val iicc: InfosetAccessor = ic.inspectAccessor
@@ -97,7 +128,7 @@ class TestInfosetInputter {
       <dfdl:format ref="tns:GeneralFormat"/>,
       <xs:element nillable="true" dfdl:nilValue="nil" dfdl:nilKind="literalValue" name="foo" dfdl:lengthKind="explicit" dfdl:length="3" type="xs:string"/>)
     val infosetXML = <foo xsi:nil="true" xmlns={ XMLUtils.EXAMPLE_NAMESPACE } xmlns:xsi={ XMLUtils.XSI_NAMESPACE }/>
-    val ic = infosetInputter(sch, infosetXML)
+    val (ic, rootERD) = infosetInputter(sch, infosetXML)
 
     val aacc = ic.advanceAccessor
     val iicc: InfosetAccessor = ic.inspectAccessor
@@ -131,14 +162,19 @@ class TestInfosetInputter {
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><foo>Hello</foo></bar>
 
-    val ic = infosetInputter(sch, infosetXML)
+    val (ic, rootERD) = infosetInputter(sch, infosetXML)
 
     val aacc = ic.advanceAccessor
     val iacc = ic.inspectAccessor
 
+    val barERD = rootERD
+    val Some(barSeqTRD) = barERD.optComplexTypeModelGroupRuntimeData
+    val Seq(fooERD) = barERD.childERDs
+    ic.pushTRD(barERD)
     assertTrue(ic.advance)
     val Start(bar: DIComplex) = aacc
-
+    ic.pushTRD(barSeqTRD)
+    ic.pushTRD(fooERD)
     assertTrue(ic.advance)
     val Start(foo: DISimple) = aacc
     assertEquals("Hello", foo.dataValue)
@@ -151,6 +187,7 @@ class TestInfosetInputter {
     val End(eFoo: DISimple) = aacc
     assertTrue(foo eq eFoo)
 
+    ic.popTRD()
     assertTrue(ic.inspect)
     val End(ibar: DIComplex) = iacc
     assertTrue(bar eq ibar)
@@ -158,7 +195,8 @@ class TestInfosetInputter {
     assertTrue(ic.advance)
     val End(bar_e: DIComplex) = aacc
     assertTrue(bar eq bar_e)
-
+    ic.popTRD()
+    ic.popTRD()
     assertFalse(ic.inspect)
     assertFalse(ic.advance)
   }
@@ -176,14 +214,26 @@ class TestInfosetInputter {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><foo>Hello</foo><baz>World</baz></bar>
-    val ic = infosetInputter(sch, infosetXML)
+    val (ic, rootERD) = infosetInputter(sch, infosetXML)
     val aacc = ic.advanceAccessor
     val Start(bar_s: DIComplex) = { assertTrue(ic.advance); aacc }
+    val barERD = bar_s.erd
+    val Some(barSeqTRD) = barERD.optComplexTypeModelGroupRuntimeData
+    val Seq(fooERD, bazERD) = barERD.childERDs
+
+    ic.pushTRD(barSeqTRD)
+    ic.pushTRD(fooERD)
     val Start(foo_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(foo_e: DISimple) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    ic.pushTRD(bazERD)
     val Start(baz_s: DISimple) = { assertTrue(ic.advance); aacc }
-    val End(baz_e: DISimple) = { assertTrue(ic.advance); aacc }; assertNotNull(baz_e)
+    val End(baz_e: DISimple) = { assertTrue(ic.advance); aacc };
+    assertNotNull(baz_e)
+    ic.popTRD()
     val End(bar_e: DIComplex) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    ic.popTRD()
     assertFalse(ic.inspect)
     assertTrue(bar_s eq bar_e) // exact same object
     assertTrue(foo_s eq foo_e)
@@ -223,21 +273,44 @@ class TestInfosetInputter {
                        <bar1><foo1>Hello</foo1><baz1>World</baz1></bar1>
                        <bar2><foo2>Hello</foo2><baz2>World</baz2></bar2>
                      </quux>
-    val ic = infosetInputter(sch, infosetXML)
+    val (ic, rootERD) = infosetInputter(sch, infosetXML)
     val aacc = ic.advanceAccessor
     val Start(quux_s: DIComplex) = { assertTrue(ic.advance); aacc }
+    val quuxERD = quux_s.erd
+    val Some(quuxSeqTRD: SequenceRuntimeData) = quuxERD.optComplexTypeModelGroupRuntimeData
+    val Seq(bar1ERD, bar2ERD) = quuxERD.childERDs
+    val Some(bar1SeqTRD: SequenceRuntimeData) = bar1ERD.optComplexTypeModelGroupRuntimeData
+    val Some(bar2SeqTRD: SequenceRuntimeData) = bar2ERD.optComplexTypeModelGroupRuntimeData
+    val Seq(foo1ERD, baz1ERD) = bar1ERD.childERDs
+    val Seq(foo2ERD, baz2ERD) = bar2ERD.childERDs
+    ic.pushTRD(quuxSeqTRD)
+    ic.pushTRD(bar1ERD)
     val Start(bar1_s: DIComplex) = { assertTrue(ic.advance); aacc }
+    ic.pushTRD(bar1SeqTRD)
+    ic.pushTRD(foo1ERD)
     val Start(foo1_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(foo1_e: DISimple) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    ic.pushTRD(baz1ERD)
     val Start(baz1_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(baz1_e: DISimple) = { assertTrue(ic.advance); aacc }; assertNotNull(baz1_e)
+    ic.popTRD()
+    ic.popTRD()
     val End(bar1_e: DIComplex) = { assertTrue(ic.advance); aacc }
+    ic.pushTRD(bar2ERD)
     val Start(bar2_s: DIComplex) = { assertTrue(ic.advance); aacc }
+    ic.pushTRD(bar2SeqTRD)
+    ic.pushTRD(foo2ERD)
     val Start(foo2_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(foo2_e: DISimple) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    ic.pushTRD(baz2ERD)
     val Start(baz2_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(baz2_e: DISimple) = { assertTrue(ic.advance); aacc }; assertNotNull(baz2_e)
+    ic.popTRD()
+    ic.popTRD()
     val End(bar2_e: DIComplex) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
     val End(quux_e: DIComplex) = { assertTrue(ic.advance); aacc }
     assertFalse(ic.inspect)
     assertTrue(bar1_s eq bar1_e) // exact same object
@@ -267,16 +340,25 @@ class TestInfosetInputter {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><foo>Hello</foo><foo>World</foo></bar>
-    val ic = infosetInputter(sch, infosetXML)
+    val (ic, rootERD) = infosetInputter(sch, infosetXML)
     val aacc = ic.advanceAccessor
+    val barERD = rootERD
+    val Some(barSeqTRD: SequenceRuntimeData) = barERD.optComplexTypeModelGroupRuntimeData
+    val Seq(fooERD) = barERD.childERDs
+    ic.pushTRD(barERD)
     val Start(bar_s: DIComplex) = { assertTrue(ic.advance); aacc }
-    val Start(foo_arr_s: DIArray) = { assertTrue(ic.advance); aacc }
+    ic.pushTRD(barSeqTRD)
+    ic.pushTRD(fooERD)
+    val StartArray(foo_arr_s) = { assertTrue(ic.advance); aacc }
     val Start(foo_1_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(foo_1_e: DISimple) = { assertTrue(ic.advance); aacc }
     val Start(foo_2_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(foo_2_e: DISimple) = { assertTrue(ic.advance); aacc }
-    val End(foo_arr_e: DIArray) = { assertTrue(ic.advance); aacc }
+    val EndArray(foo_arr_e) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
     val End(bar_e: DIComplex) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    ic.popTRD()
     assertFalse(ic.inspect)
     assertTrue(bar_s eq bar_e) // exact same object
     assertTrue(foo_arr_s eq foo_arr_e)
@@ -301,19 +383,28 @@ class TestInfosetInputter {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><foo>Hello</foo><foo>World</foo><baz>Yadda</baz></bar>
-    val ic = infosetInputter(sch, infosetXML)
+    val (ic, rootERD) = infosetInputter(sch, infosetXML)
     val aacc = ic.advanceAccessor
     val Start(bar_s: DIComplex) = { assertTrue(ic.advance); aacc }
-    val Start(foo_arr_s: DIArray) = { assertTrue(ic.advance); aacc }
+    val barERD = bar_s.erd
+    val Some(barSeqTRD: SequenceRuntimeData) = barERD.optComplexTypeModelGroupRuntimeData
+    val Seq(fooERD, bazERD) = barERD.childERDs
+    ic.pushTRD(barSeqTRD)
+    ic.pushTRD(fooERD)
+    val StartArray(foo_arr_s) = { assertTrue(ic.advance); aacc }
     val Start(foo_1_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(foo_1_e: DISimple) = { assertTrue(ic.advance); aacc }
     val Start(foo_2_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(foo_2_e: DISimple) = { assertTrue(ic.advance); aacc }
-    val End(foo_arr_e: DIArray) = { assertTrue(ic.advance); aacc }
+    val EndArray(foo_arr_e) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    ic.pushTRD(bazERD)
     val Start(baz_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(baz_e: DISimple) = { assertTrue(ic.advance); aacc }
     assertNotNull(baz_e)
     val End(bar_e: DIComplex) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    ic.popTRD()
     assertFalse(ic.inspect)
     assertTrue(bar_s eq bar_e) // exact same object
     assertTrue(foo_arr_s eq foo_arr_e)
@@ -340,20 +431,30 @@ class TestInfosetInputter {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><baz>Yadda</baz><foo>Hello</foo><foo>World</foo></bar>
-    val ic = infosetInputter(sch, infosetXML)
+    val (ic, rootERD) = infosetInputter(sch, infosetXML)
     val aacc = ic.advanceAccessor
+    val barERD = rootERD
+    val Some(barSeqTRD: SequenceRuntimeData) = barERD.optComplexTypeModelGroupRuntimeData
+    ic.pushTRD(barERD)
     val Start(bar_s: DIComplex) = { assertTrue(ic.advance); aacc }
+    val Seq(bazERD, fooERD) = barERD.childERDs
+    ic.pushTRD(barSeqTRD)
+    ic.pushTRD(bazERD)
     val Start(baz_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(baz_e: DISimple) = { assertTrue(ic.advance); aacc }
     assertNotNull(baz_e)
-    val Start(foo_arr_s: DIArray) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    ic.pushTRD(fooERD)
+    val StartArray(foo_arr_s) = { assertTrue(ic.advance); aacc }
     val Start(foo_1_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(foo_1_e: DISimple) = { assertTrue(ic.advance); aacc }
     val Start(foo_2_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(foo_2_e: DISimple) = { assertTrue(ic.advance); aacc }
-    val End(foo_arr_e: DIArray) = { assertTrue(ic.advance); aacc }
-
+    val EndArray(foo_arr_e) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
     val End(bar_e: DIComplex) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    ic.popTRD()
     assertFalse(ic.inspect)
     assertTrue(bar_s eq bar_e) // exact same object
     assertTrue(foo_arr_s eq foo_arr_e)
@@ -380,21 +481,32 @@ class TestInfosetInputter {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><baz>Yadda</baz><foo>Hello</foo><foo>World</foo></bar>
-    val ic = infosetInputter(sch, infosetXML)
+    val (ic, rootERD) = infosetInputter(sch, infosetXML)
     val aacc = ic.advanceAccessor
+    val barERD = rootERD
+    val Some(barSeqTRD: SequenceRuntimeData) = barERD.optComplexTypeModelGroupRuntimeData
+    val Seq(bazERD, fooERD) = barERD.childERDs
+    ic.pushTRD(barERD)
     val Start(bar_s: DIComplex) = { assertTrue(ic.advance); aacc }
-    val Start(baz_arr_s: DIArray) = { assertTrue(ic.advance); aacc }
+    ic.pushTRD(barSeqTRD)
+    ic.pushTRD(bazERD)
+    val StartArray(baz_arr_s) = { assertTrue(ic.advance); aacc }
     val Start(baz_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(baz_e: DISimple) = { assertTrue(ic.advance); aacc }
     assertNotNull(baz_e)
-    val End(baz_arr_e: DIArray) = { assertTrue(ic.advance); aacc }
-    val Start(foo_arr_s: DIArray) = { assertTrue(ic.advance); aacc }
+    val EndArray(baz_arr_e) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    ic.pushTRD(fooERD)
+    val StartArray(foo_arr_s) = { assertTrue(ic.advance); aacc }
     val Start(foo_1_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(foo_1_e: DISimple) = { assertTrue(ic.advance); aacc }
     val Start(foo_2_s: DISimple) = { assertTrue(ic.advance); aacc }
     val End(foo_2_e: DISimple) = { assertTrue(ic.advance); aacc }
-    val End(foo_arr_e: DIArray) = { assertTrue(ic.advance); aacc }
+    val EndArray(foo_arr_e) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
     val End(bar_e: DIComplex) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    ic.popTRD()
     assertFalse(ic.inspect)
     assertTrue(bar_s eq bar_e) // exact same object
     assertTrue(foo_arr_s eq foo_arr_e)
@@ -421,18 +533,27 @@ class TestInfosetInputter {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><foo>Hello</foo></bar>
-    val ic = infosetInputter(sch, infosetXML)
+    val (ic, rootERD) = infosetInputter(sch, infosetXML)
     val aacc = ic.advanceAccessor
     val iacc = ic.inspectAccessor
+    val barERD = rootERD
+    val Some(barSeqTRD: SequenceRuntimeData) = barERD.optComplexTypeModelGroupRuntimeData
+    val Seq(fooERD) = barERD.childERDs
+    ic.pushTRD(barERD)
     val Start(bar_s1: DIComplex) = { assertTrue(ic.inspect); iacc }
     val Start(bar_s2: DIComplex) = { assertTrue(ic.inspect); iacc }
     val Start(bar_s3: DIComplex) = { assertTrue(ic.advance); aacc }
+    ic.pushTRD(barSeqTRD)
+    ic.pushTRD(fooERD)
     val Start(foo_s1: DISimple) = { assertTrue(ic.inspect); iacc }
     val Start(foo_s2: DISimple) = { assertTrue(ic.advance); aacc }
     val End(foo_e: DISimple) = { assertTrue(ic.advance); aacc }
     val End(bar_e1: DIComplex) = { assertTrue(ic.inspect); iacc }
     assertTrue(ic.inspect)
+    ic.popTRD()
     val End(bar_e2: DIComplex) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    ic.popTRD()
     assertFalse(ic.inspect)
     assertTrue(bar_s1 eq bar_s2)
     assertTrue(bar_s2 eq bar_s3)
@@ -463,20 +584,33 @@ class TestInfosetInputter {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <e xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><s><c1>Hello</c1></s><s><c2>World</c2></s></e>
-    val ic = infosetInputter(sch, infosetXML)
+    val (ic, rootERD) = infosetInputter(sch, infosetXML)
     val aacc = ic.advanceAccessor
     val Start(e: DIComplex) = { assertTrue(ic.advance); aacc }
-    val Start(as: DIArray) = { assertTrue(ic.advance); aacc }
+    val eERD = e.erd
+    val Some(eSeqTRD: SequenceRuntimeData) = eERD.optComplexTypeModelGroupRuntimeData
+    val Seq(sERD) = eERD.childERDs
+    val Some(sChoTRD: ChoiceRuntimeData) = sERD.optComplexTypeModelGroupRuntimeData
+    val Seq(c1ERD, c2ERD) = sERD.childERDs
+    ic.pushTRD(eSeqTRD)
+    ic.pushTRD(sERD)
+    val StartArray(as) = { assertTrue(ic.advance); aacc }
     val Start(s1: DIComplex) = { assertTrue(ic.advance); aacc }; assertNotNull(s1)
+    ic.pushTRD(sChoTRD)
     val Start(c1: DISimple) = { assertTrue(ic.advance); aacc }
     val End(c1e: DISimple) = { assertTrue(ic.advance); aacc }; assertNotNull(c1e)
     val End(s1e: DIComplex) = { assertTrue(ic.advance); aacc }; assertNotNull(s1e)
+    ic.popTRD()
     val Start(s2: DIComplex) = { assertTrue(ic.advance); aacc }; assertNotNull(s2)
+    ic.pushTRD(sChoTRD)
     val Start(c2: DISimple) = { assertTrue(ic.advance); aacc }
     val End(c2e: DISimple) = { assertTrue(ic.advance); aacc }; ; assertNotNull(c2e)
     val End(s2e: DIComplex) = { assertTrue(ic.advance); aacc }; assertNotNull(s2e)
-    val End(ase: DIArray) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    val EndArray(ase) = { assertTrue(ic.advance); aacc }
     val End(ee: DIComplex) = { assertTrue(ic.advance); aacc }
+    ic.popTRD()
+    ic.popTRD()
     assertFalse(ic.inspect)
     assertTrue(as eq ase) // exact same object
     assertTrue(e eq ee)
diff --git a/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfosetCursorFromReader.scala b/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfosetCursorFromReader.scala
index 3bd2c0c3b5..1f6ae8eca8 100644
--- a/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfosetCursorFromReader.scala
+++ b/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfosetCursorFromReader.scala
@@ -27,6 +27,11 @@ import org.apache.daffodil.util.SchemaUtils
 import org.apache.daffodil.processors.DataProcessor
 import org.apache.daffodil.compiler.Compiler
 import org.apache.daffodil.util.IteratorFromCursor
+import org.apache.daffodil.processors.SequenceRuntimeData
+import org.apache.daffodil.processors.ElementRuntimeData
+import org.apache.daffodil.processors.unparsers.UnparseError
+import org.apache.daffodil.processors.ChoiceRuntimeData
+import org.apache.daffodil.processors.ErrorERD
 
 /**
  * All these tests were written for iterator style.
@@ -53,7 +58,7 @@ class TestInfosetInputterFromReader {
     val inputter = new ScalaXMLInfosetInputter(infosetXML)
     inputter.initialize(rootERD, u.getTunables())
     val is = Adapter(inputter)
-    is
+    (is, rootERD, inputter)
   }
 
   @Test def testUnparseFixedLengthString1() {
@@ -71,7 +76,8 @@ class TestInfosetInputterFromReader {
       <dfdl:format ref="tns:GeneralFormat"/>,
       <xs:element name="foo" dfdl:lengthKind="explicit" dfdl:length="5" type="xs:string"/>)
     val infosetXML = <foo xmlns={ XMLUtils.EXAMPLE_NAMESPACE }>Hello</foo>
-    val is = infosetInputter(sch, infosetXML).toStream.toList
+    val (ii, _, _) = infosetInputter(sch, infosetXML)
+    val is = ii.toStream.toList
     val List(Start(s: DISimple), End(e: DISimple)) = is
     assertTrue(s eq e) // exact same object
     assertTrue(s.dataValue.isInstanceOf[String])
@@ -84,7 +90,8 @@ class TestInfosetInputterFromReader {
       <dfdl:format ref="tns:GeneralFormat"/>,
       <xs:element nillable="true" dfdl:nilValue="nil" dfdl:nilKind="literalValue" name="foo" dfdl:lengthKind="explicit" dfdl:length="3" type="xs:string"/>)
     val infosetXML = <foo xsi:nil="true" xmlns={ XMLUtils.EXAMPLE_NAMESPACE } xmlns:xsi={ XMLUtils.XSI_NAMESPACE }/>
-    val is = infosetInputter(sch, infosetXML).toStream.toList
+    val (ii, _, _) = infosetInputter(sch, infosetXML)
+    val is = ii.toStream.toList
     val List(Start(s: DISimple), End(e: DISimple)) = is
     assertTrue(s eq e) // exact same object
     assertTrue(s.isNilled)
@@ -102,10 +109,15 @@ class TestInfosetInputterFromReader {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><foo>Hello</foo></bar>
-    val is = infosetInputter(sch, infosetXML)
+    val (is, rootERD, inp) = infosetInputter(sch, infosetXML)
+    val Seq(fooERD) = rootERD.childERDs
     val Start(bar_s: DIComplex) = is.next
+    inp.pushTRD(fooERD)
     val Start(foo_s: DISimple) = is.next
+    bar_s.addChild(foo_s)
     val End(foo_e: DISimple) = is.next
+    val poppedERD = inp.popTRD()
+    assertEquals(fooERD, poppedERD)
     val End(bar_e: DIComplex) = is.next
     assertFalse(is.hasNext)
     assertTrue(bar_s eq bar_e) // exact same object
@@ -127,12 +139,17 @@ class TestInfosetInputterFromReader {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><foo>Hello</foo><baz>World</baz></bar>
-    val is = infosetInputter(sch, infosetXML)
+    val (is, rootERD, inp) = infosetInputter(sch, infosetXML)
     val Start(bar_s: DIComplex) = is.next
+    val Seq(fooERD, bazERD) = rootERD.childERDs
+    inp.pushTRD(fooERD)
     val Start(foo_s: DISimple) = is.next
     val End(foo_e: DISimple) = is.next
+    assertEquals(fooERD, inp.popTRD())
+    inp.pushTRD(bazERD)
     val Start(baz_s: DISimple) = is.next
     val End(baz_e: DISimple) = is.next; assertNotNull(baz_e)
+    assertEquals(bazERD, inp.popTRD())
     val End(bar_e: DIComplex) = is.next
     assertFalse(is.hasNext)
     assertTrue(bar_s eq bar_e) // exact same object
@@ -173,19 +190,59 @@ class TestInfosetInputterFromReader {
                        <bar1><foo1>Hello</foo1><baz1>World</baz1></bar1>
                        <bar2><foo2>Hello</foo2><baz2>World</baz2></bar2>
                      </quux>
-    val is = infosetInputter(sch, infosetXML)
+    val (is, rootERD, inp) = infosetInputter(sch, infosetXML)
+    //
+    // Get all the ERDs and Sequence TRDs
+    //
+    val Some(seq1TRD: SequenceRuntimeData) = rootERD.optComplexTypeModelGroupRuntimeData
+    val Seq(bar1ERD: ElementRuntimeData, bar2ERD: ElementRuntimeData) = seq1TRD.groupMembers
+    val Some(bar1SeqTRD: SequenceRuntimeData) = bar1ERD.optComplexTypeModelGroupRuntimeData
+    val Seq(foo1ERD: ElementRuntimeData, baz1ERD: ElementRuntimeData) = bar1SeqTRD.groupMembers
+    val Some(bar2SeqTRD: SequenceRuntimeData) = bar2ERD.optComplexTypeModelGroupRuntimeData
+    val Seq(foo2ERD: ElementRuntimeData, baz2ERD: ElementRuntimeData) = bar2SeqTRD.groupMembers
+
+    inp.pushTRD(rootERD)
     val Start(quux_s: DIComplex) = is.next
+    inp.pushTRD(seq1TRD)
+    inp.pushTRD(bar1ERD)
     val Start(bar1_s: DIComplex) = is.next
+    //
+    // When the unparser for the bar1 element does eventually run, it will push the bar1ERD
+    // and when it runs the model group unparser it will push that sequence's TRD.
+    inp.pushTRD(bar1SeqTRD)
+    inp.pushTRD(foo1ERD)
     val Start(foo1_s: DISimple) = is.next
     val End(foo1_e: DISimple) = is.next
+    assertEquals(foo1ERD, inp.popTRD())
+    inp.pushTRD(baz1ERD)
     val Start(baz1_s: DISimple) = is.next
-    val End(baz1_e: DISimple) = is.next; assertNotNull(baz1_e)
+    val End(baz1_e: DISimple) = is.next;
+    assertNotNull(baz1_e)
+    assertEquals(baz1ERD, inp.popTRD())
+    //
+    // At the end of a complex element, it should not be expecting
+    // any other element start events
+    //
+    val badERD = inp.nextElement("notFound", XMLUtils.EXAMPLE_NAMESPACE, true)
+    assertTrue(badERD.isInstanceOf[ErrorERD])
+
     val End(bar1_e: DIComplex) = is.next
+    assertEquals(bar1SeqTRD, inp.popTRD())
+    assertEquals(bar1ERD, inp.popTRD())
+    inp.pushTRD(bar2ERD)
     val Start(bar2_s: DIComplex) = is.next
+    inp.pushTRD(bar2SeqTRD)
+    inp.pushTRD(foo2ERD)
     val Start(foo2_s: DISimple) = is.next
     val End(foo2_e: DISimple) = is.next
+    assertEquals(foo2ERD, inp.popTRD())
+    inp.pushTRD(baz2ERD)
     val Start(baz2_s: DISimple) = is.next
-    val End(baz2_e: DISimple) = is.next; assertNotNull(baz2_e)
+    val End(baz2_e: DISimple) = is.next;
+    assertNotNull(baz2_e)
+    assertEquals(baz2ERD, inp.popTRD())
+    assertEquals(bar2SeqTRD, inp.popTRD())
+    assertEquals(bar2ERD, inp.popTRD())
     val End(bar2_e: DIComplex) = is.next
     val End(quux_e: DIComplex) = is.next
     assertFalse(is.hasNext)
@@ -216,14 +273,24 @@ class TestInfosetInputterFromReader {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><foo>Hello</foo><foo>World</foo></bar>
-    val is = infosetInputter(sch, infosetXML)
+    val (is, rootERD, inp) = infosetInputter(sch, infosetXML)
+    val Some(barSeqTRD: SequenceRuntimeData) = rootERD.optComplexTypeModelGroupRuntimeData
+    val Seq(fooERD: ElementRuntimeData) = barSeqTRD.groupMembers
+    val doc = inp.documentElement
     val Start(bar_s: DIComplex) = is.next
-    val Start(foo_arr_s: DIArray) = is.next
+    doc.addChild(bar_s)
+    inp.pushTRD(barSeqTRD)
+    inp.pushTRD(fooERD)
+    val StartArray(foo_arr_s) = is.next
     val Start(foo_1_s: DISimple) = is.next
+    bar_s.addChild(foo_1_s)
     val End(foo_1_e: DISimple) = is.next
     val Start(foo_2_s: DISimple) = is.next
+    bar_s.addChild(foo_2_s)
     val End(foo_2_e: DISimple) = is.next
-    val End(foo_arr_e: DIArray) = is.next
+    val EndArray(foo_arr_e) = is.next
+    assertEquals(fooERD, inp.popTRD())
+    assertEquals(barSeqTRD, inp.popTRD())
     val End(bar_e: DIComplex) = is.next
     assertFalse(is.hasNext)
     assertTrue(bar_s eq bar_e) // exact same object
@@ -249,17 +316,29 @@ class TestInfosetInputterFromReader {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><foo>Hello</foo><foo>World</foo><baz>Yadda</baz></bar>
-    val is = infosetInputter(sch, infosetXML)
+    val (is, rootERD, inp) = infosetInputter(sch, infosetXML)
+    val Some(barSeqTRD: SequenceRuntimeData) = rootERD.optComplexTypeModelGroupRuntimeData
+    val Seq(fooERD: ElementRuntimeData, bazERD: ElementRuntimeData) = barSeqTRD.groupMembers
     val Start(bar_s: DIComplex) = is.next
-    val Start(foo_arr_s: DIArray) = is.next
+    inp.pushTRD(barSeqTRD)
+    inp.pushTRD(fooERD)
+    val StartArray(foo_arr_s) = is.next
     val Start(foo_1_s: DISimple) = is.next
     val End(foo_1_e: DISimple) = is.next
     val Start(foo_2_s: DISimple) = is.next
     val End(foo_2_e: DISimple) = is.next
-    val End(foo_arr_e: DIArray) = is.next
+    val EndArray(foo_arr_e) = is.next
+    //
+    // While fooERD is still on the stack, we should be able to resolve baz element since
+    // foo is optional
+    //
     val Start(baz_s: DISimple) = is.next
+    assertEquals(fooERD, inp.popTRD())
+    inp.pushTRD(bazERD)
     val End(baz_e: DISimple) = is.next
     assertNotNull(baz_e)
+    assertEquals(bazERD, inp.popTRD())
+    assertEquals(barSeqTRD, inp.popTRD())
     val End(bar_e: DIComplex) = is.next
     assertFalse(is.hasNext)
     assertTrue(bar_s eq bar_e) // exact same object
@@ -287,17 +366,28 @@ class TestInfosetInputterFromReader {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><baz>Yadda</baz><foo>Hello</foo><foo>World</foo></bar>
-    val is = infosetInputter(sch, infosetXML)
+    val (is, rootERD, inp) = infosetInputter(sch, infosetXML)
+    val Some(barSeqTRD: SequenceRuntimeData) = rootERD.optComplexTypeModelGroupRuntimeData
+    val Seq(bazERD: ElementRuntimeData, fooERD: ElementRuntimeData) = barSeqTRD.groupMembers
+
     val Start(bar_s: DIComplex) = is.next
+
+    inp.pushTRD(barSeqTRD)
+    inp.pushTRD(bazERD)
+
     val Start(baz_s: DISimple) = is.next
     val End(baz_e: DISimple) = is.next
     assertNotNull(baz_e)
-    val Start(foo_arr_s: DIArray) = is.next
+    inp.popTRD()
+    inp.pushTRD(fooERD)
+    val StartArray(foo_arr_s) = is.next
     val Start(foo_1_s: DISimple) = is.next
     val End(foo_1_e: DISimple) = is.next
     val Start(foo_2_s: DISimple) = is.next
     val End(foo_2_e: DISimple) = is.next
-    val End(foo_arr_e: DIArray) = is.next
+    inp.popTRD()
+    inp.popTRD()
+    val EndArray(foo_arr_e) = is.next
 
     val End(bar_e: DIComplex) = is.next
     assertFalse(is.hasNext)
@@ -326,19 +416,25 @@ class TestInfosetInputterFromReader {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><baz>Yadda</baz><foo>Hello</foo><foo>World</foo></bar>
-    val is = infosetInputter(sch, infosetXML)
+    val (is, rootERD, inp) = infosetInputter(sch, infosetXML)
+    val Some(barSeqTRD: SequenceRuntimeData) = rootERD.optComplexTypeModelGroupRuntimeData
+    val Seq(bazERD: ElementRuntimeData, fooERD: ElementRuntimeData) = barSeqTRD.groupMembers
+
     val Start(bar_s: DIComplex) = is.next
-    val Start(baz_arr_s: DIArray) = is.next
+    inp.pushTRD(barSeqTRD)
+    inp.pushTRD(bazERD)
+    val StartArray(baz_arr_s) = is.next
     val Start(baz_s: DISimple) = is.next
     val End(baz_e: DISimple) = is.next
     assertNotNull(baz_e)
-    val End(baz_arr_e: DIArray) = is.next
-    val Start(foo_arr_s: DIArray) = is.next
+    val EndArray(baz_arr_e) = is.next
+    val StartArray(foo_arr_s) = is.next
     val Start(foo_1_s: DISimple) = is.next
     val End(foo_1_e: DISimple) = is.next
     val Start(foo_2_s: DISimple) = is.next
     val End(foo_2_e: DISimple) = is.next
-    val End(foo_arr_e: DIArray) = is.next
+    val EndArray(foo_arr_e) = is.next
+    inp.popTRD()
     val End(bar_e: DIComplex) = is.next
     assertFalse(is.hasNext)
     assertTrue(bar_s eq bar_e) // exact same object
@@ -366,19 +462,25 @@ class TestInfosetInputterFromReader {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <bar xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><foo>Hello</foo></bar>
-    val is = infosetInputter(sch, infosetXML)
+    val (is, rootERD, inp) = infosetInputter(sch, infosetXML)
+    val Some(barSeqTRD: SequenceRuntimeData) = rootERD.optComplexTypeModelGroupRuntimeData
+    val Seq(fooERD: ElementRuntimeData) = barSeqTRD.groupMembers
+
     val Start(bar_s1: DIComplex) = is.peek
     val Start(bar_s2: DIComplex) = is.peek
-    val Start(bar_s3: DIComplex) = is.next
+    val Start(bar_s: DIComplex) = is.next
+    inp.pushTRD(barSeqTRD)
+    inp.pushTRD(fooERD)
     val Start(foo_s1: DISimple) = is.peek
     val Start(foo_s2: DISimple) = is.next
     val End(foo_e: DISimple) = is.next
+    inp.popTRD()
+    inp.popTRD()
     val End(bar_e1: DIComplex) = is.peek
     assertTrue(is.hasNext)
     val End(bar_e2: DIComplex) = is.next
     assertFalse(is.hasNext)
     assertTrue(bar_s1 eq bar_s2)
-    assertTrue(bar_s2 eq bar_s3)
     assertTrue(bar_e1 eq bar_e2)
     assertTrue(bar_s1 eq bar_e1) // exact same object
     assertTrue(foo_s1 eq foo_s2)
@@ -406,18 +508,31 @@ class TestInfosetInputterFromReader {
         </xs:complexType>
       </xs:element>)
     val infosetXML = <e xmlns={ XMLUtils.EXAMPLE_NAMESPACE }><s><c1>Hello</c1></s><s><c2>World</c2></s></e>
-    val is = infosetInputter(sch, infosetXML)
+    val (is, eERD, inp) = infosetInputter(sch, infosetXML)
+    val Some(eSeqTRD: SequenceRuntimeData) = eERD.optComplexTypeModelGroupRuntimeData
+    val Seq(sERD: ElementRuntimeData) = eSeqTRD.groupMembers
+    val Some(sChoTRD: ChoiceRuntimeData) = sERD.optComplexTypeModelGroupRuntimeData
+    val Seq(c1ERD: ElementRuntimeData, c2ERD: ElementRuntimeData) = sChoTRD.groupMembers
     val Start(e: DIComplex) = is.next
-    val Start(as: DIArray) = is.next
+    inp.pushTRD(eSeqTRD)
+    inp.pushTRD(sERD)
+    val StartArray(as) = is.next
     val Start(s1: DIComplex) = is.next; assertNotNull(s1)
+    inp.pushTRD(sChoTRD)
     val Start(c1: DISimple) = is.next
     val End(c1e: DISimple) = is.next; assertNotNull(c1e)
+    inp.popTRD()
+    inp.popTRD()
     val End(s1e: DIComplex) = is.next; assertNotNull(s1e)
+    inp.pushTRD(sERD)
     val Start(s2: DIComplex) = is.next; assertNotNull(s2)
+    inp.pushTRD(sChoTRD)
     val Start(c2: DISimple) = is.next
     val End(c2e: DISimple) = is.next; ; assertNotNull(c2e)
+    inp.popTRD()
     val End(s2e: DIComplex) = is.next; assertNotNull(s2e)
-    val End(ase: DIArray) = is.next
+    val EndArray(ase) = is.next
+    inp.popTRD()
     val End(ee: DIComplex) = is.next
     assertFalse(is.hasNext)
     assertTrue(as eq ase) // exact same object
diff --git a/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfosetCursorFromReader2.scala b/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfosetCursorFromReader2.scala
index f8c98e1f7e..3d62d3bf26 100644
--- a/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfosetCursorFromReader2.scala
+++ b/daffodil-core/src/test/scala/org/apache/daffodil/infoset/TestInfosetCursorFromReader2.scala
@@ -26,6 +26,8 @@ import org.apache.daffodil.processors.DataProcessor
 import org.apache.daffodil.compiler.Compiler
 import org.apache.daffodil.xml.XMLUtils
 import scala.collection.immutable.Stream.consWrapper
+import org.apache.daffodil.processors.SequenceRuntimeData
+import org.apache.daffodil.processors.ElementRuntimeData
 
 object INoWarnU1 { ImplicitsSuppressUnusedImportWarning() }
 
@@ -64,7 +66,7 @@ class TestInfosetInputterFromReader2 {
     val inputter = new XMLTextInfosetInputter(is)
     inputter.initialize(rootERD, u.getTunables())
     val ic = Adapter(inputter)
-    ic
+    (ic, rootERD, inputter)
   }
 
   class StreamInputStream(
@@ -90,9 +92,18 @@ class TestInfosetInputterFromReader2 {
 
   @Test def testStreamingBehavior1() {
     val count = 100
-    val is = infosetUnlimitedSource(count)
+    doTest(count)
+  }
+
+  def doTest(count: Int) {
+    val (is, rootERD, inp) = infosetUnlimitedSource(count)
+    val Some(barSeqTRD: SequenceRuntimeData) = rootERD.optComplexTypeModelGroupRuntimeData
+    val Seq(fooERD: ElementRuntimeData) = barSeqTRD.groupMembers
+    inp.pushTRD(rootERD)
     val Start(bar_s: DIComplex) = is.next
-    val Start(foo_arr_s: DIArray) = is.next
+    inp.pushTRD(barSeqTRD)
+    inp.pushTRD(fooERD)
+    val StartArray(foo_arr_s) = is.next
     1 to count foreach { i =>
       val Start(foo_1_s: DISimple) = is.next
       val End(foo_1_e: DISimple) = is.next
@@ -100,8 +111,11 @@ class TestInfosetInputterFromReader2 {
       assertTrue(foo_1_s.dataValue.isInstanceOf[String])
       assertEquals("Hello", foo_1_s.dataValueAsString)
     }
-    val End(foo_arr_e: DIArray) = is.next
+    val EndArray(foo_arr_e) = is.next
+    inp.popTRD()
+    inp.popTRD()
     val End(bar_e: DIComplex) = is.next
+    inp.popTRD()
     assertFalse(is.hasNext)
     assertTrue(bar_s eq bar_e) // exact same object
     assertTrue(foo_arr_s eq foo_arr_e)
@@ -110,26 +124,6 @@ class TestInfosetInputterFromReader2 {
   // @Test // uncomment to watch storage on jvisualvm to convince self of non-leaking.
   def testStreamingBehavior2() {
     val count = 100000000
-    val is = infosetUnlimitedSource(count)
-    val Start(bar_s: DIComplex) = is.next
-    val Start(foo_arr_s: DIArray) = is.next
-    1 to count foreach { i =>
-      val Start(foo_1_s: DISimple) = is.next
-      val End(foo_1_e: DISimple) = is.next
-      assertTrue(foo_1_s eq foo_1_e)
-      assertTrue(foo_1_s.dataValue.isInstanceOf[String])
-      assertTrue(foo_1_s.dataValueAsString =:= "Hello")
-      val arr = bar_s.getChildArray(foo_1_s.runtimeData)
-      if (arr.length % 100L =#= 0L) {
-        // println("array length is " + arr.length)
-        foo_arr_s.reduceToSize(0)
-      }
-      arr.asInstanceOf[DIArray].children
-    }
-    val End(foo_arr_e: DIArray) = is.next
-    val End(bar_e: DIComplex) = is.next
-    assertFalse(is.hasNext)
-    assertTrue(bar_s eq bar_e) // exact same object
-    assertTrue(foo_arr_s eq foo_arr_e)
+    doTest(count)
   }
 }
diff --git a/daffodil-core/src/test/scala/org/apache/daffodil/runtime1/TestStreamingUnparserCompilerAttributes.scala b/daffodil-core/src/test/scala/org/apache/daffodil/runtime1/TestStreamingUnparserCompilerAttributes.scala
new file mode 100644
index 0000000000..a82d59e991
--- /dev/null
+++ b/daffodil-core/src/test/scala/org/apache/daffodil/runtime1/TestStreamingUnparserCompilerAttributes.scala
@@ -0,0 +1,576 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.daffodil.runtime1
+
+import org.apache.daffodil.dsom.Choice
+import org.apache.daffodil.dsom.ChoiceGroupRef
+import org.apache.daffodil.dsom.ElementRef
+import org.apache.daffodil.dsom.LocalElementDecl
+import org.apache.daffodil.dsom.Sequence
+import org.apache.daffodil.dsom.SequenceGroupRef
+import org.apache.daffodil.dsom.Term
+import org.junit.Test
+
+class TestStreamingUnparserCompilerAttributes {
+
+  import PossibleNextElements._
+  import org.apache.daffodil.util.TestUtils._
+
+  private def poss(t: Term) = t.possibleNextLexicalSiblingStreamingUnparserElements
+  type LE = LocalElementDecl
+  type SGR = SequenceGroupRef
+  type CGR = ChoiceGroupRef
+  type S = Sequence
+  type C = Choice
+  type ER = ElementRef
+
+  @Test def testPossibleNextStreamingUnparserEvent1() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:sequence>
+            <xs:element name="a" type="xs:int"/>
+            <xs:element name="b" type="xs:int"/>
+          </xs:sequence>
+        </xs:complexType>
+      </xs:element>
+    }
+    val rg: S = r.complexType.sequence
+    val Seq(a: LE, b: LE) = rg.groupMembers
+    val Closed(Seq(PNE(`r`, true))) = poss(r)
+    val Closed(Nil) = poss(rg)
+    val Closed(Seq(PNE(`a`, true))) = poss(a)
+    val Closed(Seq(PNE(`b`, true))) = poss(b)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEvent2() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:sequence>
+            <xs:element name="a" type="xs:int" minOccurs="0"/>
+            <xs:element name="b" type="xs:int"/>
+          </xs:sequence>
+        </xs:complexType>
+      </xs:element>
+    }
+    val rg: S = r.complexType.sequence
+    val Seq(a: LE, b: LE) = rg.groupMembers
+    val Closed(Seq(PNE(`r`, true))) = poss(r)
+    val Closed(Nil) = poss(rg)
+    val Closed(Seq(PNE(`a`, false), PNE(`b`, true))) = poss(a)
+    val Closed(Seq(PNE(`b`, true))) = poss(b)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEvent2OVC() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:sequence>
+            <xs:element name="a" type="xs:int" dfdl:outputValueCalc="{ 0 }"/>
+            <xs:element name="b" type="xs:int"/>
+          </xs:sequence>
+        </xs:complexType>
+      </xs:element>
+    }
+    val rg: S = r.complexType.sequence
+    val Seq(a: LE, b: LE) = rg.groupMembers
+    val Closed(Seq(PNE(`r`, true))) = poss(r)
+    val Closed(Nil) = poss(rg)
+    val Closed(Seq(PNE(`a`, false), PNE(`b`, true))) = poss(a)
+    val Closed(Seq(PNE(`b`, true))) = poss(b)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEvent3() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:sequence>
+            <xs:element name="a" type="xs:int" minOccurs="0"/>
+            <xs:element name="b" type="xs:int" maxOccurs="unbounded"/>
+            <xs:group ref="ex:g"/>
+          </xs:sequence>
+        </xs:complexType>
+      </xs:element>
+      <xs:group name="g">
+        <xs:sequence>
+          <xs:element name="c" type="xs:int"/>
+        </xs:sequence>
+      </xs:group>
+    }
+    val rg: S = r.complexType.sequence
+    val Seq(a: LE, b: LE, gr: SGR) = rg.groupMembers
+    val Seq(c: LE) = gr.groupMembers
+    val Closed(Seq(PNE(`r`, true))) = poss(r)
+    val Closed(Nil) = poss(rg)
+    val Closed(Seq(PNE(`a`, false), PNE(`b`, false), PNE(`c`, true))) = poss(a)
+    val Closed(Seq(PNE(`b`, false), PNE(`c`, true))) = poss(b)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEvent4() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:sequence>
+            <xs:element name="a" type="xs:int" minOccurs="0"/>
+            <xs:element name="b" type="xs:int" maxOccurs="unbounded"/>
+            <xs:group ref="ex:g"/>
+          </xs:sequence>
+        </xs:complexType>
+      </xs:element>
+      <xs:group name="g">
+        <xs:choice>
+          <xs:element name="c" type="xs:int"/>
+          <xs:element name="d" type="xs:int"/>
+        </xs:choice>
+      </xs:group>
+    }
+    val rg: S = r.complexType.sequence
+    val Seq(a: LE, b: LE, gr: CGR) = rg.groupMembers
+    val Seq(c: LE, d: LE) = gr.groupMembers
+    val Closed(Seq(PNE(`a`, false), PNE(`b`, false), PNE(`c`, false), PNE(`d`, false))) = poss(a)
+    val Closed(Seq(PNE(`b`, false), PNE(`c`, false), PNE(`d`, false))) = poss(b)
+    val Closed(Seq(PNE(`c`, false), PNE(`d`, false))) = poss(gr)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+    val Closed(Seq(PNE(`d`, true))) = poss(d)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEvent5() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:sequence>
+            <xs:group ref="gab"/>
+            <xs:group ref="ex:g"/>
+          </xs:sequence>
+        </xs:complexType>
+      </xs:element>
+      <xs:group name="gab">
+        <xs:sequence>
+          <xs:element name="a" type="xs:int" minOccurs="0"/>
+          <xs:element name="b" type="xs:int" maxOccurs="unbounded"/>
+        </xs:sequence>
+      </xs:group>
+      <xs:group name="g">
+        <xs:choice>
+          <xs:element name="c" type="xs:int"/>
+          <xs:element name="d" type="xs:int"/>
+        </xs:choice>
+      </xs:group>
+    }
+    val rg: S = r.complexType.sequence
+    val Seq(sgr: SGR, cgr: CGR) = rg.groupMembers
+    val Seq(a: LE, b: LE) = sgr.groupMembers
+    val Seq(c: LE, d: LE) = cgr.groupMembers
+    val Closed(Seq(PNE(`c`, false), PNE(`d`, false))) = poss(sgr)
+    val Open(Seq(PNE(`a`, false), PNE(`b`, false))) = poss(a)
+    val Open(Seq(PNE(`b`, false))) = poss(b)
+    val Closed(Seq(PNE(`c`, false), PNE(`d`, false))) = poss(cgr)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+    val Closed(Seq(PNE(`d`, true))) = poss(d)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEvent6() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:choice>
+            <xs:element name="c" type="xs:int"/>
+            <xs:element name="d" type="xs:int"/>
+          </xs:choice>
+        </xs:complexType>
+      </xs:element>
+    }
+    val rg: C = r.complexType.choice
+    val Seq(c: LE, d: LE) = rg.groupMembers
+    val Closed(Seq(PNE(`c`, false), PNE(`d`, false))) = poss(rg)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+    val Closed(Seq(PNE(`d`, true))) = poss(d)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEvent7() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:choice>
+            <xs:element name="c" type="xs:int"/>
+            <xs:element name="d" type="xs:int"/>
+            <xs:sequence/><!-- added empty sequence as branch -->
+          </xs:choice>
+        </xs:complexType>
+      </xs:element>
+    }
+    val rg: C = r.complexType.choice
+    val Seq(c: LE, d: LE, es: S) = rg.groupMembers
+    val Open(Nil) = poss(es)
+    val Open(Seq(PNE(`c`, false), PNE(`d`, false))) = poss(rg)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+    val Closed(Seq(PNE(`d`, true))) = poss(d)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEvent8() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:choice>
+            <xs:element name="c" type="xs:int"/>
+            <xs:element name="d" type="xs:int"/>
+            <xs:group ref="g"/>
+          </xs:choice>
+        </xs:complexType>
+      </xs:element>
+      <xs:group name="g">
+        <xs:sequence/>
+      </xs:group>
+    }
+    val rg: C = r.complexType.choice
+    val Seq(c: LE, d: LE, gr: SGR) = rg.groupMembers
+    val Open(Nil) = poss(gr)
+    val Open(Seq(PNE(`c`, false), PNE(`d`, false))) = poss(rg)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+    val Closed(Seq(PNE(`d`, true))) = poss(d)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEvent9() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:choice>
+            <xs:element name="c" type="xs:int"/>
+            <xs:element name="d" type="xs:int"/>
+            <xs:group ref="g"/>
+          </xs:choice>
+        </xs:complexType>
+      </xs:element>
+      <xs:group name="g">
+        <xs:sequence>
+          <xs:element name="e" type="xs:int" maxOccurs="2"/>
+        </xs:sequence>
+      </xs:group>
+    }
+    val rg: C = r.complexType.choice
+    val Seq(c: LE, d: LE, gr: SGR) = rg.groupMembers
+    val Seq(e: LE) = gr.groupMembers
+    val Open(Nil) = poss(gr)
+    val Open(Seq(PNE(`c`, false), PNE(`d`, false), PNE(`e`, false))) = poss(rg)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+    val Closed(Seq(PNE(`d`, true))) = poss(d)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEvent9OVC() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:choice>
+            <xs:element name="c" type="xs:int"/>
+            <xs:element name="d" type="xs:int"/>
+            <xs:group ref="g"/>
+          </xs:choice>
+        </xs:complexType>
+      </xs:element>
+      <xs:group name="g">
+        <xs:sequence>
+          <xs:element name="e" type="xs:int" dfdl:outputValueCalc="{ 0 }"/>
+        </xs:sequence>
+      </xs:group>
+    }
+    val rg: C = r.complexType.choice
+    val Seq(c: LE, d: LE, gr: SGR) = rg.groupMembers
+    val Seq(e: LE) = gr.groupMembers
+    val Open(Nil) = poss(gr)
+    val Open(Seq(PNE(`c`, false), PNE(`d`, false), PNE(`e`, false))) = poss(rg)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+    val Closed(Seq(PNE(`d`, true))) = poss(d)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEvent9OVCIVC() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:choice>
+            <xs:element name="c" type="xs:int"/>
+            <xs:element name="d" type="xs:int" dfdl:inputValueCalc="{ 0 }"/><!-- IVC changes nothing as far as unparsing goes -->
+            <xs:group ref="g"/>
+          </xs:choice>
+        </xs:complexType>
+      </xs:element>
+      <xs:group name="g">
+        <xs:sequence>
+          <xs:element name="e" type="xs:int" dfdl:outputValueCalc="{ 0 }"/>
+        </xs:sequence>
+      </xs:group>
+    }
+    val rg: C = r.complexType.choice
+    val Seq(c: LE, d: LE, gr: SGR) = rg.groupMembers
+    val Seq(e: LE) = gr.groupMembers
+    val Open(Nil) = poss(gr)
+    val Open(Seq(PNE(`c`, false), PNE(`d`, false), PNE(`e`, false))) = poss(rg)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+    val Closed(Seq(PNE(`d`, true))) = poss(d)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEvent10() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:sequence>
+            <xs:sequence>
+              <xs:group ref="cg"/>
+            </xs:sequence>
+          </xs:sequence>
+        </xs:complexType>
+      </xs:element>
+      <xs:group name="cg">
+        <xs:choice>
+          <xs:element name="c" type="xs:int"/>
+          <xs:element name="d" type="xs:int"/>
+          <xs:group ref="g"/>
+        </xs:choice>
+      </xs:group>
+      <xs:group name="g">
+        <xs:sequence>
+          <xs:element name="e" type="xs:int" maxOccurs="2"/>
+        </xs:sequence>
+      </xs:group>
+    }
+    val rg: S = r.complexType.sequence
+    val Seq(s: S) = rg.groupMembers
+    val Seq(cgr: CGR) = s.groupMembers
+    val Seq(c: LE, d: LE, gr: SGR) = cgr.groupMembers
+    val Seq(e: LE) = gr.groupMembers
+    val Closed(Nil) = poss(rg)
+    val Open(Nil) = poss(s)
+    val Open(Seq(PNE(`c`, false), PNE(`d`, false), PNE(`e`, false))) = poss(cgr)
+    val Open(Nil) = poss(gr)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+    val Closed(Seq(PNE(`d`, true))) = poss(d)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEvent11() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:sequence>
+            <xs:element name="a" type="xs:int"/>
+            <xs:element name="b" type="xs:int" maxOccurs="unbounded"/>
+            <xs:element name="c" type="xs:int"/>
+          </xs:sequence>
+        </xs:complexType>
+      </xs:element>
+    }
+    val rg: S = r.complexType.sequence
+    val Seq(a: LE, b: LE, c: LE) = rg.groupMembers
+    val Closed(Seq(PNE(`a`, true))) = poss(a)
+    val Closed(Seq(PNE(`b`, false), PNE(`c`, true))) = poss(b)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEventHidden1() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:sequence>
+            <xs:element name="a" type="xs:int"/>
+            <xs:sequence dfdl:hiddenGroupRef="ex:hg"/>
+            <xs:element name="b" type="xs:int"/>
+          </xs:sequence>
+        </xs:complexType>
+      </xs:element>
+      <xs:group name="hg">
+        <xs:sequence>
+          <xs:element name="e" type="xs:int" dfdl:outputValueCalc="{ 0 }"/>
+        </xs:sequence>
+      </xs:group>
+    }
+    val rg: S = r.complexType.sequence
+    val Seq(a: LE, hgr: SGR, b: LE) = rg.groupMembers
+    val Seq(e: LE) = hgr.groupMembers
+    val Closed(Seq(PNE(`a`, true))) = poss(a)
+    val Closed(Seq(PNE(`b`, true))) = poss(b)
+    val Closed(Seq(PNE(`b`, true))) = poss(hgr)
+    val Open(Seq(PNE(`e`, false))) = poss(e)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEventHidden2() = {
+    val r = getRoot {
+      <xs:element name="r">
+        <xs:complexType>
+          <xs:sequence>
+            <xs:element name="a" type="xs:int"/>
+            <xs:choice>
+              <xs:sequence>
+                <xs:sequence dfdl:hiddenGroupRef="ex:presentBit"/>
+                <xs:element name="b" type="xs:int"/>
+              </xs:sequence>
+              <xs:sequence dfdl:hiddenGroupRef="ex:absentBit"/>
+            </xs:choice>
+            <xs:element name="c" type="xs:int"/>
+          </xs:sequence>
+        </xs:complexType>
+      </xs:element>
+      <xs:group name="presentBit">
+        <xs:sequence>
+          <xs:element name="flagBit" type="xs:int" dfdl:length="1" dfdl:lengthUnits="bits" dfdl:outputValueCalc="{ 1 }"/>
+        </xs:sequence>
+      </xs:group>
+      <xs:group name="absentBit">
+        <xs:sequence>
+          <xs:element name="flagBit" type="xs:int" dfdl:length="1" dfdl:lengthUnits="bits" dfdl:outputValueCalc="{ 0 }"/>
+        </xs:sequence>
+      </xs:group>
+    }
+    val rg: S = r.complexType.sequence
+    val Seq(a: LE, cg: C, c: LE) = rg.groupMembers
+    val Seq(s1: S, s2: SGR) = cg.groupMembers
+    val Seq(pg: SGR, b: LE) = s1.groupMembers
+    val Seq(aflag: LE) = s2.groupMembers
+    val Seq(pflag: LE) = pg.groupMembers
+    val Closed(Seq(PNE(`a`, true))) = poss(a)
+    val Closed(Seq(PNE(`b`, false), PNE(`c`, true))) = poss(cg)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+    val Open(Nil) = poss(s1)
+    val Open(Nil) = poss(s2)
+    val Closed(Seq(PNE(`b`, true))) = poss(pg)
+    val Open(Seq(PNE(`pflag`, false))) = poss(pflag)
+    val Closed(Seq(PNE(`b`, true))) = poss(b)
+    val Open(Seq(PNE(`aflag`, false))) = poss(aflag)
+  }
+
+  @Test def testPossibleNextStreamingUnparserEventHidden3() = {
+    val r = getRoot {
+      <xs:element name="r" dfdl:lengthKind="implicit">
+        <xs:complexType>
+          <xs:sequence>
+            <xs:element name="a" type="xs:string" dfdl:length="3"/>
+            <xs:choice>
+              <xs:sequence>
+                <xs:sequence dfdl:hiddenGroupRef="ex:presentBit"/>
+                <xs:element name="b" type="xs:string" dfdl:length="3"/>
+              </xs:sequence>
+              <xs:sequence dfdl:hiddenGroupRef="ex:absentBit"/>
+            </xs:choice>
+            <xs:choice>
+              <xs:sequence>
+                <xs:sequence dfdl:hiddenGroupRef="ex:presentBit"/>
+                <xs:element name="c" type="xs:string" dfdl:length="3"/>
+              </xs:sequence>
+              <xs:sequence dfdl:hiddenGroupRef="ex:absentBit"/>
+            </xs:choice>
+            <xs:element name="d" type="xs:string" dfdl:length="3"/>
+          </xs:sequence>
+        </xs:complexType>
+      </xs:element>
+      <xs:group name="presentBit">
+        <xs:sequence>
+          <xs:element name="flagBit" type="xs:int" dfdl:length="1" dfdl:outputValueCalc="{ 1 }"/>
+        </xs:sequence>
+      </xs:group>
+      <xs:group name="absentBit">
+        <xs:sequence>
+          <xs:element name="flagBit" type="xs:int" dfdl:length="1" dfdl:outputValueCalc="{ 0 }"/>
+        </xs:sequence>
+      </xs:group>
+    }
+    val rg: S = r.complexType.sequence
+    val Seq(a: LE, cg1: C, cg2: C, d: LE) = rg.groupMembers
+    val Seq(s1a: S, s1b: SGR) = cg1.groupMembers
+    val Seq(pg1: SGR, b: LE) = s1a.groupMembers
+    val Seq(aflag1: LE) = s1b.groupMembers
+    val Seq(pflag1: LE) = pg1.groupMembers
+
+    val Seq(s2a: S, s2b: SGR) = cg2.groupMembers
+    val Seq(pg2: SGR, c: LE) = s2a.groupMembers
+    val Seq(aflag2: LE) = s2b.groupMembers
+    val Seq(pflag2: LE) = pg2.groupMembers
+
+    val Closed(Seq(PNE(`a`, true))) = poss(a)
+
+    val Closed(Seq(PNE(`b`, false), PNE(`c`, false), PNE(`d`, true))) = poss(cg1)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+    val Open(Nil) = poss(s1a)
+    val Open(Nil) = poss(s1b)
+    val Closed(Seq(PNE(`b`, true))) = poss(pg1)
+    val Open(Seq(PNE(`pflag1`, false))) = poss(pflag1)
+    val Closed(Seq(PNE(`b`, true))) = poss(b)
+    val Open(Seq(PNE(`aflag1`, false))) = poss(aflag1)
+
+    val Closed(Seq(PNE(`c`, false), PNE(`d`, true))) = poss(cg2)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+    val Open(Nil) = poss(s2a)
+    val Open(Nil) = poss(s2b)
+    val Closed(Seq(PNE(`c`, true))) = poss(pg2)
+    val Open(Seq(PNE(`pflag2`, false))) = poss(pflag2)
+    val Closed(Seq(PNE(`c`, true))) = poss(c)
+    val Open(Seq(PNE(`aflag2`, false))) = poss(aflag2)
+  }
+
+  val schemaX =
+    <xs:element name="x" dfdl:lengthKind="implicit">
+      <xs:complexType>
+        <xs:sequence>
+          <xs:choice>
+            <xs:sequence>
+              <xs:sequence dfdl:hiddenGroupRef="tns:present"/>
+              <xs:element maxOccurs="2" name="b" type="xs:int" dfdl:length="1"/>
+            </xs:sequence>
+            <xs:sequence dfdl:hiddenGroupRef="tns:absent"/>
+          </xs:choice>
+          <xs:element name="y" minOccurs="0" type="xs:int" dfdl:length="1"/>
+        </xs:sequence>
+      </xs:complexType>
+    </xs:element>
+    <xs:group name="present">
+      <xs:sequence>
+        <xs:element name="present" type="xs:int" dfdl:length="1" dfdl:outputValueCalc="{ 1 }">
+          <xs:annotation>
+            <xs:appinfo source="http://www.ogf.org/dfdl/">
+              <dfdl:discriminator test="{ . eq 1 }"/>
+            </xs:appinfo>
+          </xs:annotation>
+        </xs:element>
+      </xs:sequence>
+    </xs:group>
+    <xs:group name="absent">
+      <xs:sequence>
+        <xs:element name="absent" type="xs:int" dfdl:length="1" dfdl:outputValueCalc="{ 0 }"/>
+      </xs:sequence>
+    </xs:group>
+
+  @Test def testUnparseHiddenGroupsPresenceFlags6() {
+    val r = getRoot(
+      schemaX,
+      topLevels =
+        <dfdl:format ref="tns:GeneralFormat" lengthKind="explicit"/>)
+
+    val rg: S = r.complexType.sequence
+    val Seq(ch: C, y: LE) = rg.groupMembers
+    val Seq(s1: S, ag: SGR) = ch.groupMembers
+    val Seq(pg: SGR, b: LE) = s1.groupMembers
+    val Seq(p: LE) = pg.groupMembers
+    val Seq(a: LE) = ag.groupMembers
+
+    val Open(Seq(PNE(`b`, false), PNE(`y`, false))) = poss(ch)
+    val Open(Nil) = poss(s1)
+    val Open(Seq(PNE(`y`, false))) = poss(y)
+    val Open(Seq(PNE(`b`, false))) = poss(pg)
+    val Open(Nil) = poss(ag)
+    val Open(Seq(PNE(`p`, false))) = poss(p)
+    val Open(Seq(PNE(`a`, false))) = poss(a)
+  }
+}
diff --git a/daffodil-core/src/test/scala/org/apache/daffodil/runtime1/TestUnparseHidden.scala b/daffodil-core/src/test/scala/org/apache/daffodil/runtime1/TestUnparseHidden.scala
new file mode 100644
index 0000000000..9f6df8b3ea
--- /dev/null
+++ b/daffodil-core/src/test/scala/org/apache/daffodil/runtime1/TestUnparseHidden.scala
@@ -0,0 +1,257 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.daffodil.runtime1
+
+import org.apache.daffodil.util.SchemaUtils
+import org.apache.daffodil.util.TestUtils
+import org.junit.Test
+import org.apache.daffodil.xml.XMLUtils
+
+class TestUnparseHidden {
+
+  val xsd = XMLUtils.XSD_NAMESPACE
+  val dfdl = XMLUtils.dfdlAppinfoSource // XMLUtils.DFDL_NAMESPACE
+  val xsi = XMLUtils.XSI_NAMESPACE
+  val example = XMLUtils.EXAMPLE_NAMESPACE
+
+  val schema1 =
+    <xs:element name="r" dfdl:lengthKind="implicit">
+      <xs:complexType>
+        <xs:sequence>
+          <xs:element name="a" type="xs:string" dfdl:length="3"/>
+          <xs:choice>
+            <xs:sequence>
+              <xs:sequence dfdl:hiddenGroupRef="ex:presentBit"/>
+              <xs:element name="b" type="xs:string" dfdl:length="3"/>
+            </xs:sequence>
+            <xs:sequence dfdl:hiddenGroupRef="ex:absentBit"/>
+          </xs:choice>
+          <xs:element name="c" type="xs:string" dfdl:length="3"/>
+        </xs:sequence>
+      </xs:complexType>
+    </xs:element>
+    <xs:group name="presentBit">
+      <xs:sequence>
+        <xs:element name="flagBit" type="xs:int" dfdl:length="1" dfdl:outputValueCalc="{ 1 }"/>
+      </xs:sequence>
+    </xs:group>
+    <xs:group name="absentBit">
+      <xs:sequence>
+        <xs:element name="flagBit" type="xs:int" dfdl:length="1" dfdl:outputValueCalc="{ 0 }"/>
+      </xs:sequence>
+    </xs:group>
+
+  @Test def testUnparseHiddenGroupsPresenceFlags1() {
+    val testSchema = SchemaUtils.dfdlTestSchema(
+      <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>,
+      <dfdl:format ref="tns:GeneralFormat" lengthKind="explicit"/>,
+      schema1,
+      elementFormDefault = "unqualified")
+
+    val infoset =
+      <ex:r xmlns:ex={ example }>
+        <a>abc</a>
+        <b>def</b>
+        <c>ghi</c>
+      </ex:r>
+    val data = "abc1defghi"
+    TestUtils.testUnparsing(testSchema, infoset, data)
+  }
+
+  @Test def testUnparseHiddenGroupsPresenceFlags2() {
+    val testSchema = SchemaUtils.dfdlTestSchema(
+      <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>,
+      <dfdl:format ref="tns:GeneralFormat" lengthKind="explicit"/>,
+      schema1,
+      elementFormDefault = "unqualified")
+
+    val infoset =
+      <ex:r xmlns:ex={ example }>
+        <a>abc</a>
+        <c>ghi</c>
+      </ex:r>
+    val data = "abc0ghi"
+    TestUtils.testUnparsing(testSchema, infoset, data)
+  }
+
+  val schema2 =
+    <xs:element name="r" dfdl:lengthKind="implicit">
+      <xs:complexType>
+        <xs:sequence>
+          <xs:element name="a" type="xs:string" dfdl:length="3"/>
+          <xs:choice>
+            <xs:sequence>
+              <xs:sequence dfdl:hiddenGroupRef="ex:presentBit"/>
+              <xs:element name="b" type="xs:string" dfdl:length="3"/>
+            </xs:sequence>
+            <xs:sequence dfdl:hiddenGroupRef="ex:absentBit"/>
+          </xs:choice>
+          <xs:choice>
+            <xs:sequence>
+              <xs:sequence dfdl:hiddenGroupRef="ex:presentBit"/>
+              <xs:element name="c" type="xs:string" dfdl:length="3"/>
+            </xs:sequence>
+            <xs:sequence dfdl:hiddenGroupRef="ex:absentBit"/>
+          </xs:choice>
+          <xs:element name="d" type="xs:string" dfdl:length="3"/>
+        </xs:sequence>
+      </xs:complexType>
+    </xs:element>
+    <xs:group name="presentBit">
+      <xs:sequence>
+        <xs:element name="flagBit" type="xs:int" dfdl:length="1" dfdl:outputValueCalc="{ 1 }"/>
+      </xs:sequence>
+    </xs:group>
+    <xs:group name="absentBit">
+      <xs:sequence>
+        <xs:element name="flagBit" type="xs:int" dfdl:length="1" dfdl:outputValueCalc="{ 0 }"/>
+      </xs:sequence>
+    </xs:group>
+
+  @Test def testUnparseHiddenGroupsPresenceFlags3() {
+    val testSchema = SchemaUtils.dfdlTestSchema(
+      <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>,
+      <dfdl:format ref="tns:GeneralFormat" lengthKind="explicit"/>,
+      schema2,
+      elementFormDefault = "unqualified")
+
+    val infoset =
+      <ex:r xmlns:ex={ example }>
+        <a>abc</a>
+        <b>def</b>
+        <c>ghi</c>
+        <d>jkl</d>
+      </ex:r>
+    val data = "abc1def1ghijkl"
+    TestUtils.testUnparsing(testSchema, infoset, data)
+  }
+
+  @Test def testUnparseHiddenGroupsPresenceFlags4() {
+    val testSchema = SchemaUtils.dfdlTestSchema(
+      <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>,
+      <dfdl:format ref="tns:GeneralFormat" lengthKind="explicit"/>,
+      schema2,
+      elementFormDefault = "unqualified")
+
+    val infoset =
+      <ex:r xmlns:ex={ example }>
+        <a>abc</a>
+        <d>jkl</d>
+      </ex:r>
+    val data = "abc00jkl"
+    TestUtils.testUnparsing(testSchema, infoset, data)
+  }
+
+  val schema3 =
+    <xs:element name="r" dfdl:lengthKind="implicit">
+      <xs:complexType>
+        <xs:sequence>
+          <xs:element name="a" type="xs:string" dfdl:length="3"/>
+          <xs:choice>
+            <xs:sequence>
+              <xs:sequence dfdl:hiddenGroupRef="ex:presentBit"/>
+              <xs:element name="b" type="xs:string" dfdl:length="1" dfdl:outputValueCalc="{ dfdl:valueLength(../d, 'bytes') }"/>
+            </xs:sequence>
+            <xs:sequence dfdl:hiddenGroupRef="ex:absentBit"/>
+          </xs:choice>
+          <xs:group ref="ex:arr"/>
+          <xs:element name="d" type="xs:string" dfdl:length="3"/>
+        </xs:sequence>
+      </xs:complexType>
+    </xs:element>
+    <xs:group name="arr">
+      <xs:sequence>
+        <xs:element name="arr" type="xs:string" minOccurs="0" dfdl:length="1" dfdl:occursCountKind="expression" dfdl:occursCount="{ dfdl:valueLength(../a, 'bytes') - 2 }"/>
+      </xs:sequence>
+    </xs:group>
+    <xs:group name="presentBit">
+      <xs:sequence>
+        <xs:element name="flagBit" type="xs:int" dfdl:length="1" dfdl:outputValueCalc="{ 1 }"/>
+      </xs:sequence>
+    </xs:group>
+    <xs:group name="absentBit">
+      <xs:sequence>
+        <xs:element name="flagBit" type="xs:int" dfdl:length="1" dfdl:outputValueCalc="{ 0 }"/>
+      </xs:sequence>
+    </xs:group>
+
+  @Test def testUnparseHiddenGroupsPresenceFlags5() {
+    val testSchema = SchemaUtils.dfdlTestSchema(
+      <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>,
+      <dfdl:format ref="tns:GeneralFormat" lengthKind="explicit"/>,
+      schema3,
+      elementFormDefault = "unqualified")
+
+    val infoset =
+      <ex:r xmlns:ex={ example }>
+        <a>abc</a>
+        <arr>X</arr>
+        <d>jkl</d>
+      </ex:r>
+    val data = "abc13Xjkl"
+    TestUtils.testUnparsing(testSchema, infoset, data)
+  }
+
+  val schemaX =
+    <xs:element name="x" dfdl:lengthKind="implicit">
+      <xs:complexType>
+        <xs:sequence>
+          <xs:choice>
+            <xs:sequence>
+              <xs:sequence dfdl:hiddenGroupRef="tns:present"/>
+              <xs:element maxOccurs="2" name="b" type="xs:int" dfdl:length="1"/>
+            </xs:sequence>
+            <xs:sequence dfdl:hiddenGroupRef="tns:absent"/>
+          </xs:choice>
+          <xs:element name="y" minOccurs="0" type="xs:int" dfdl:length="1"/>
+        </xs:sequence>
+      </xs:complexType>
+    </xs:element>
+    <xs:group name="present">
+      <xs:sequence>
+        <xs:element name="present" type="xs:int" dfdl:length="1" dfdl:outputValueCalc="{ 1 }">
+          <xs:annotation>
+            <xs:appinfo source="http://www.ogf.org/dfdl/">
+              <dfdl:discriminator test="{ . eq 1 }"/>
+            </xs:appinfo>
+          </xs:annotation>
+        </xs:element>
+      </xs:sequence>
+    </xs:group>
+    <xs:group name="absent">
+      <xs:sequence>
+        <xs:element name="absent" type="xs:int" dfdl:length="1" dfdl:outputValueCalc="{ 0 }"/>
+      </xs:sequence>
+    </xs:group>
+
+  @Test def testUnparseHiddenGroupsPresenceFlags6() {
+    val testSchema = SchemaUtils.dfdlTestSchema(
+      <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>,
+      <dfdl:format ref="tns:GeneralFormat" lengthKind="explicit"/>,
+      schemaX,
+      elementFormDefault = "unqualified")
+
+    val infoset =
+      <ex:x xmlns:ex={ example }>
+        <b>3</b>
+        <y>1</y>
+      </ex:x>
+    val data = "131"
+    TestUtils.testUnparsing(testSchema, infoset, data)
+  }
+}
diff --git a/daffodil-core/src/test/scala/org/apache/daffodil/util/TestUtils.scala b/daffodil-core/src/test/scala/org/apache/daffodil/util/TestUtils.scala
index c7994d40d9..9299abf562 100644
--- a/daffodil-core/src/test/scala/org/apache/daffodil/util/TestUtils.scala
+++ b/daffodil-core/src/test/scala/org/apache/daffodil/util/TestUtils.scala
@@ -96,6 +96,7 @@ object TestUtils {
 
   def testUnparsing(testSchema: scala.xml.Elem, infosetXML: Node, unparseTo: String, areTracing: Boolean = false): Seq[Diagnostic] = {
     val compiler = Compiler()
+    compiler.setTunable("allowExternalPathExpressions", "true")
     val pf = compiler.compileNode(testSchema)
     if (pf.isError) {
       val msgs = pf.getDiagnostics.map(_.getMessage()).mkString("\n")
@@ -209,6 +210,28 @@ object TestUtils {
     }
     (actual, outputter.getResult)
   }
+
+  private val defaultIncludeImports =
+     <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
+  private val defaultTopLevels =
+    <dfdl:format ref="tns:GeneralFormat" lengthKind="delimited" encoding="US-ASCII"/>
+  
+  /**
+   * For convenient unit testing of schema compiler attributes defined on Term types.
+   */
+  def getRoot(
+    contentElements: Seq[Node],
+    elementFormDefault: String = "unqualified",
+    includeImports : Seq[Node] = defaultIncludeImports,
+    topLevels: Seq[Node] = defaultTopLevels): Root = {
+    val testSchema = SchemaUtils.dfdlTestSchema(
+      includeImports,
+      topLevels,
+      contentElements,
+      elementFormDefault = elementFormDefault)
+    val sset = new SchemaSet(testSchema)
+    sset.root
+  }
 }
 /**
  * We need a schema document and such for unit testing, also our PrimType
@@ -229,7 +252,7 @@ object Fakes {
 
 class Fakes private () {
   lazy val sch = SchemaUtils.dfdlTestSchema(
-      <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>,
+    <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>,
     <dfdl:format ref="tns:GeneralFormat"/>,
     <xs:element name="fake" type="xs:string" dfdl:lengthKind="delimited"/>
     <xs:element name="fake2" type="tns:fakeCT"/>
diff --git a/daffodil-japi/src/test/java/org/apache/daffodil/example/TestJavaAPI.java b/daffodil-japi/src/test/java/org/apache/daffodil/example/TestJavaAPI.java
index 4060c7c890..1b32b8d1ad 100644
--- a/daffodil-japi/src/test/java/org/apache/daffodil/example/TestJavaAPI.java
+++ b/daffodil-japi/src/test/java/org/apache/daffodil/example/TestJavaAPI.java
@@ -852,7 +852,7 @@ public void testJavaAPI15() throws IOException, ClassNotFoundException {
         assertEquals(1, diags.size());
         Diagnostic d = diags.get(0);
         assertTrue(d.getMessage().contains("wrong"));
-        assertTrue(d.getMessage().contains("e1"));
+        assertTrue(d.getMessage().contains("e2"));
 
         // reset the global logging state
         Daffodil.setLogWriter(new ConsoleLogWriter());
diff --git a/daffodil-lib/src/main/scala/org/apache/daffodil/util/Cursor.scala b/daffodil-lib/src/main/scala/org/apache/daffodil/util/Cursor.scala
index 8f1bfe729f..28b30f3354 100644
--- a/daffodil-lib/src/main/scala/org/apache/daffodil/util/Cursor.scala
+++ b/daffodil-lib/src/main/scala/org/apache/daffodil/util/Cursor.scala
@@ -94,22 +94,10 @@ trait Cursor[AccessorType <: Accessor[AccessorType]] {
    * boolean indicates whether that happened successfully or there
    * was no more data.
    *
-   * Note that inspecting may have side effects. For instance, the InfosetInputter
-   * returns a DINode on inspection. However, in order to construct a DINode, said node
-   * must be inserted into the infoset. Therefore, in a chain with one or more calls to inspect,
-   * followed by a call to advance, the side effect of constructing the DINode will be realized on the
-   * first call to inspect.
-   *
-   * For a side-effect free variant, consider inspectPure
+   * This has no side-effects on the infoset. 
    */
   def inspect: Boolean
 
-  /**
-   * Like inspect, but only partially populates the accessor with data that can be computed without
-   * side effects
-   */
-  def inspectPure: Boolean
-
   /**
    * Convenient combinations of advance with
    * giving access to the appropriate accessor.
@@ -124,11 +112,6 @@ trait Cursor[AccessorType <: Accessor[AccessorType]] {
     else Nope
   }
 
-  final def inspectPureMaybe: Maybe[AccessorType] = {
-    if (inspectPure) One(inspectAccessor)
-    else Nope
-  }
-
   /**
    * Cause this cursor to finish and cleanup anything that may be necessary,
    * regardless of if it is complete or not
@@ -136,21 +119,20 @@ trait Cursor[AccessorType <: Accessor[AccessorType]] {
   def fini: Unit
 }
 
-trait CursorImplMixin[AccessorType <: Accessor[AccessorType]] { self: Cursor[AccessorType] =>
-
+trait CursorImplMixin[AccessorType <: Accessor[AccessorType]]
+  extends Cursor[AccessorType] {
   /*
    * We are a bit of a state machine based on what the last operation was.
-   * At all times, we have a "current" element, which is what future calls to advance/inspect/inspectPure provide information about.
+   * At all times, we have a "current" element, which is what future calls to 
+   * advance/inspect provide information about.
    *
    * Our states our as follows:
    * priorOpKind == Advance - No work has been done for the current element. All work has been done on the prior element
-   * priorOpKind == InspectPure - The input corresponding to the current element has been consumed, but no externally visable side effects have occured
    * priorOpKind == Inspect - The input corresponding to the current element has been consumed, and all exteranlly visible side effects have occured.
    */
   protected trait OpKind
   protected case object Advance extends OpKind
   protected case object Inspect extends OpKind
-  protected case object InspectPure extends OpKind
   protected case object Unsuccessful extends OpKind
   protected var priorOpKind: OpKind = Advance
 
@@ -174,10 +156,6 @@ trait CursorImplMixin[AccessorType <: Accessor[AccessorType]] { self: Cursor[Acc
     accessor = advanceAccessor
     val res = priorOpKind match {
       case Advance => doAdvance(false, advanceInput = true)
-      case InspectPure => {
-        priorOpKind = Advance
-        doAdvance(false, advanceInput = false)
-      }
       case Inspect => {
         // prior operation was inspect!
         priorOpKind = Advance
@@ -198,10 +176,6 @@ trait CursorImplMixin[AccessorType <: Accessor[AccessorType]] { self: Cursor[Acc
         priorOpKind = Inspect
         doAdvance(true, true)
       }
-      case InspectPure => {
-        priorOpKind = Inspect
-        doAdvance(true, advanceInput = false)
-      }
       case Inspect => true // inspect again does nothing.
       case Unsuccessful => return false
     }
@@ -210,14 +184,12 @@ trait CursorImplMixin[AccessorType <: Accessor[AccessorType]] { self: Cursor[Acc
     res
   }
 
-  //inpsectPure implemented in InfosetInputter.scala
-
   /*
    * Logically speaking, a Cursor may have 2 "streams": an input stream and an output stream.
    *
-   * When calling inspect/inspectPure/advance, we observe the current element of the output stream.
+   * When calling inspect/advance, we observe the current element of the output stream.
    * We advance the input stream the first time we observe an element, but do not advance the output
-   * stream until the last time we observe an element (eg. until we observe an elemnt through the advance() method).
+   * stream until the last time we observe an element (eg. until we observe an element through the advance() method).
    *
    * The advanceInput flag is needed so that calls to advance() can keep track if they are also the
    * first observations of the element, and therefore need to advance both the input stream and the output stream.
diff --git a/daffodil-lib/src/main/scala/org/apache/daffodil/util/MStack.scala b/daffodil-lib/src/main/scala/org/apache/daffodil/util/MStack.scala
index 53d86daaf4..37463e091b 100644
--- a/daffodil-lib/src/main/scala/org/apache/daffodil/util/MStack.scala
+++ b/daffodil-lib/src/main/scala/org/apache/daffodil/util/MStack.scala
@@ -149,7 +149,9 @@ final class MStackOf[T <: AnyRef] {
   def clear() = delegate.clear()
   def toList = delegate.toList
 
-  def iterator = delegate.iterator.asInstanceOf[Iterator[T]]
+  def iterator = delegate.iterator.asInstanceOf[ResettableIterator[T]]
+
+  lazy val iter = delegate.iter.asInstanceOf[ResettableIterator[T]]
 
 }
 
@@ -279,12 +281,25 @@ protected abstract class MStack[@specialized T] private[util] (
   def toList = iterator.toList
 
   /**
-   * Creates and iterator over the stack in LIFO order.
+   * Creates an iterator over the stack in LIFO order.
    *  @return an iterator over the elements of the stack.
    */
-  def iterator: Iterator[T] = new Iterator[T] {
+  def iterator: Iterator[T] = new ResettableIterator[T] {
+    //
+    // index is the state of the stack, telling where top is.
+    //
+    // currentIndex and initialIndex are state of this iterator
+    //
+
+    /**
+     * Holds the current stack position we're iterating at.
+     */
     private var currentIndex = index
-    private val initialIndex = index
+
+    /**
+     * Holds the position of the top of stack
+     */
+    private var initialIndex = index
 
     def hasNext = currentIndex > 0
     def next() = {
@@ -293,6 +308,21 @@ protected abstract class MStack[@specialized T] private[util] (
       currentIndex -= 1
       table(currentIndex).asInstanceOf[T]
     }
+
+    /**
+     * Reset the iterator to start again at the current top of stack.
+     */
+    def reset() = {
+      currentIndex = index
+      initialIndex = index // top of stack for our iteration
+    }
   }
 
+  lazy val iter = iterator
+
+}
+
+abstract class ResettableIterator[@specialized T]
+  extends Iterator[T] {
+  def reset(): Unit
 }
diff --git a/daffodil-lib/src/main/scala/org/apache/daffodil/util/SchemaUtils.scala b/daffodil-lib/src/main/scala/org/apache/daffodil/util/SchemaUtils.scala
index a9c8a7290a..59d59934c4 100644
--- a/daffodil-lib/src/main/scala/org/apache/daffodil/util/SchemaUtils.scala
+++ b/daffodil-lib/src/main/scala/org/apache/daffodil/util/SchemaUtils.scala
@@ -40,13 +40,15 @@ object SchemaUtils {
    * Constructs a DFDL schema more conveniently than having to specify all those xmlns attributes.
    */
 
-  def dfdlTestSchemaUnqualified(includeImports: Seq[Node],
+  def dfdlTestSchemaUnqualified(
+    includeImports: Seq[Node],
     topLevelAnnotations: Seq[Node],
     contentElements: Seq[Node],
     fileName: String = ""): Elem =
     dfdlTestSchema(includeImports, topLevelAnnotations, contentElements, fileName = fileName, elementFormDefault = "unqualified")
 
-  def dfdlTestSchemaWithTarget(includeImports: Seq[Node],
+  def dfdlTestSchemaWithTarget(
+    includeImports: Seq[Node],
     topLevelAnnotations: Seq[Node],
     contentElements: Seq[Node],
     theTargetNS: String,
@@ -68,7 +70,8 @@ object SchemaUtils {
    * as those were aggravating a xerces bug that we might as well avoid.
    * This also makes these much more readable.
    */
-  def dfdlTestSchema(includeImports: Seq[Node],
+  def dfdlTestSchema(
+    includeImports: Seq[Node],
     topLevelAnnotations: Seq[Node],
     contentElements: Seq[Node],
     schemaScope: NamespaceBinding = TopScope, // from the defineSchema node
@@ -122,5 +125,4 @@ object SchemaUtils {
     val res = XMLUtils.collapseScopes(schemaNode, TopScope).asInstanceOf[Elem]
     res
   }
-
 }
diff --git a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/ChoiceAndOtherVariousUnparsers.scala b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/ChoiceAndOtherVariousUnparsers.scala
index dd36f7bf43..5790855225 100644
--- a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/ChoiceAndOtherVariousUnparsers.scala
+++ b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/ChoiceAndOtherVariousUnparsers.scala
@@ -27,24 +27,6 @@ import org.apache.daffodil.util.Maybe
 import org.apache.daffodil.util.MaybeInt
 import org.apache.daffodil.util.Maybe._
 
-class ComplexTypeUnparser(rd: RuntimeData, bodyUnparser: Unparser)
-  extends CombinatorUnparser(rd) {
-
-  override lazy val runtimeDependencies = Vector()
-
-  override def nom = "ComplexType"
-
-  override def isEmpty = bodyUnparser.isEmpty
-
-  override lazy val childProcessors = Vector(bodyUnparser)
-
-  def unparse(start: UState): Unit = {
-    start.childIndexStack.push(1L) // one-based indexing
-    bodyUnparser.unparse1(start)
-    start.childIndexStack.pop()
-  }
-}
-
 class ChoiceCombinatorUnparser(
   mgrd: ModelGroupRuntimeData,
   eventUnparserMap: Map[ChoiceBranchEvent, Unparser],
@@ -58,7 +40,7 @@ class ChoiceCombinatorUnparser(
   override lazy val childProcessors = eventUnparserMap.map { case (k, v) => v }.toSeq.toVector
 
   def unparse(state: UState): Unit = {
-
+    state.pushTRD(mgrd)
     val event: InfosetAccessor = state.inspectOrError
     val key: ChoiceBranchEvent = event match {
       //
@@ -66,17 +48,20 @@ class ChoiceCombinatorUnparser(
       // hash-table lookup for a cached value. This avoids constructing these
       // objects over and over again.
       //
-      case e if e.isStart && e.isElement => ChoiceBranchStartEvent(e.asElement.runtimeData.namedQName)
-      case e if e.isEnd && e.isElement => ChoiceBranchEndEvent(e.asElement.runtimeData.namedQName)
-      case e if e.isStart && e.isArray => ChoiceBranchStartEvent(e.asArray.erd.namedQName)
-      case e if e.isEnd && e.isArray => ChoiceBranchEndEvent(e.asArray.erd.namedQName)
+      case e if e.isStart && e.isElement => ChoiceBranchStartEvent(e.erd.namedQName)
+      case e if e.isEnd && e.isElement => ChoiceBranchEndEvent(e.erd.namedQName)
+      case e if e.isStart && e.isArray => ChoiceBranchStartEvent(e.erd.namedQName)
+      case e if e.isEnd && e.isArray => ChoiceBranchEndEvent(e.erd.namedQName)
     }
 
     val childUnparser = eventUnparserMap.get(key).getOrElse {
-      UnparseError(One(mgrd.schemaFileLocation), One(state.currentLocation), "Encountered event %s. Expected one of %s.",
-        key, eventUnparserMap.keys.mkString(", "))
+      UnparseError(One(mgrd.schemaFileLocation), One(state.currentLocation),
+        "Found next element %s, but expected one of %s.",
+        key.qname.toExtendedSyntax,
+        eventUnparserMap.keys.map { _.qname.toExtendedSyntax }.mkString(", "))
     }
-
+    state.popTRD(mgrd)
+    state.pushTRD(childUnparser.context.asInstanceOf[TermRuntimeData])
     if (choiceLengthInBits.isDefined) {
       val suspendableOp = new ChoiceUnusedUnparserSuspendableOperation(mgrd, choiceLengthInBits.get)
       val choiceUnusedUnparser = new ChoiceUnusedUnparser(mgrd, choiceLengthInBits.get, suspendableOp)
@@ -88,6 +73,7 @@ class ChoiceCombinatorUnparser(
     } else {
       childUnparser.unparse1(state)
     }
+    state.popTRD(childUnparser.context.asInstanceOf[TermRuntimeData])
   }
 }
 
@@ -171,4 +157,3 @@ class DynamicEscapeSchemeUnparser(escapeScheme: EscapeSchemeUnparseEv, ctxt: Ter
     escapeScheme.invalidateCache(state)
   }
 }
-
diff --git a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/ElementUnparser.scala b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/ElementUnparser.scala
index c41b3018c2..8cd11e3439 100644
--- a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/ElementUnparser.scala
+++ b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/ElementUnparser.scala
@@ -29,6 +29,7 @@ import org.apache.daffodil.util.MaybeULong
 import org.apache.daffodil.processors.Evaluatable
 import org.apache.daffodil.infoset.RetryableException
 import org.apache.daffodil.processors.TypeCalculator
+import org.apache.daffodil.util.MaybeBoolean
 
 /**
  * Elements that, when unparsing, have no length specified.
@@ -143,7 +144,7 @@ sealed abstract class ElementUnparserBase(
     if (depthLimit == 0) "..." else
       "<Element name='" + name + "'>" +
         (if (eBeforeUnparser.isDefined) eBeforeUnparser.value.toBriefXML(depthLimit - 1) else "") +
-        (if (eReptypeUnparser.isDefined) eReptypeUnparser.value.toBriefXML(depthLimit -1) else "") +
+        (if (eReptypeUnparser.isDefined) eReptypeUnparser.value.toBriefXML(depthLimit - 1) else "") +
         (if (eUnparser.isDefined) eUnparser.value.toBriefXML(depthLimit - 1) else "") +
         (if (eAfterUnparser.isDefined) eAfterUnparser.value.toBriefXML(depthLimit - 1) else "") +
         setVarUnparsers.map { _.toBriefXML(depthLimit - 1) }.mkString +
@@ -190,8 +191,19 @@ sealed abstract class ElementUnparserBase(
 
     doBeforeContentUnparser(state)
 
+    //
+    // We must push the TermRuntimeData for all model-groups.
+    // The starting point for this is the model-group of a complex type.
+    // Simple types don't have model groups, so no pushing those.
+    //
+    if (erd.isComplexType)
+      state.pushTRD(erd.optComplexTypeModelGroupRuntimeData.get)
+
     runContentUnparser(state)
 
+    if (erd.isComplexType)
+      state.popTRD(erd.optComplexTypeModelGroupRuntimeData.get)
+
     doAfterContentUnparser(state)
 
     computeSetVariables(state)
@@ -403,13 +415,32 @@ sealed trait RegularElementUnparserStartEndStrategy
           if (!event.isStart || event.erd != erd) {
             // it's not a start element event, or it's a start element event, but for a different element.
             // this indicates that the incoming infoset (as events) doesn't match the schema
-            UnparseError(Nope, One(state.currentLocation), "Expected element start event for %s, but received %s.", erd.namedQName, event)
+            UnparseError(Nope, One(state.currentLocation), "Expected element start event for %s, but received %s.",
+              erd.namedQName.toExtendedSyntax, event)
           }
-          event.asElement
+          val res = event.info.element
+          val mCurNode = state.currentInfosetNodeMaybe
+          if (mCurNode.isDefined) {
+            val c = mCurNode.get.asComplex
+            Assert.invariant(!c.isFinal)
+            if (c.maybeIsNilled == MaybeBoolean.True) {
+              // cannot add content to a nilled complex element
+              UnparseError(One(erd.schemaFileLocation), Nope, "Nilled complex element %s has content from %s",
+                c.erd.namedQName.toExtendedSyntax,
+                res.erd.namedQName.toExtendedSyntax)
+            }
+            c.addChild(res)
+          } else {
+            val doc = state.documentElement
+            doc.addChild(res) // DIDocument, which is never a current node, must have the child added
+            doc.setFinal() // that's the only child.
+          }
+          res
         } else {
+          Assert.invariant(erd.isHidden)
           // Since we never get events for hidden elements, their infoset elements
           // will have never been created. This means we need to manually create them
-          val e = if (erd.isComplexType) new DIComplex(erd, state.tunable) else new DISimple(erd)
+          val e = if (erd.isComplexType) new DIComplex(erd) else new DISimple(erd)
           state.currentInfosetNode.asComplex.addChild(e)
           e
         }
@@ -440,10 +471,13 @@ sealed trait RegularElementUnparserStartEndStrategy
         if (!event.isEnd || event.erd != erd) {
           // it's not an end-element event, or it's an end element event, but for a different element.
           // this indicates that the incoming infoset (as events) doesn't match the schema
-          UnparseError(Nope, One(state.currentLocation), "Expected element end event for %s, but received %s.", erd.namedQName, event)
+          UnparseError(Nope, One(state.currentLocation), "Expected element end event for %s, but received %s.",
+            erd.namedQName.toExtendedSyntax, event)
         }
       }
-
+      val cur = state.currentInfosetNode
+      if (cur.isComplex)
+        cur.asComplex.setFinal()
       state.currentInfosetNodeStack.pop
 
       move(state)
@@ -468,7 +502,7 @@ trait OVCStartEndStrategy
         // Otherwise, the next event is for a following element, and we do not want
         // to consume it. Don't even bother checking all this if it's hidden. It
         // definitely won't be in the infoset in that case.
-        val eventMaybe = state.inspectPureMaybe
+        val eventMaybe = state.inspectMaybe
         if (eventMaybe.isDefined && eventMaybe.get.erd == erd) {
           // Event existed for this OVC element, should be a start and end events
           val startEv = state.advanceOrError // Consume the start event
@@ -476,7 +510,8 @@ trait OVCStartEndStrategy
           val endEv = state.advanceOrError // Consume the end event
           Assert.invariant(endEv.isEnd && endEv.erd == erd)
 
-          val e = startEv.asSimple
+          val e = new DISimple(erd)
+          state.currentInfosetNode.asComplex.addChild(e)
           // Remove any state that was set by what created this event. Later
           // code asserts that OVC elements do not have a value
           e.resetValue
diff --git a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/ExpressionEvaluatingUnparsers.scala b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/ExpressionEvaluatingUnparsers.scala
index 262a6c2270..50ffbabbf9 100644
--- a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/ExpressionEvaluatingUnparsers.scala
+++ b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/ExpressionEvaluatingUnparsers.scala
@@ -31,7 +31,6 @@ import org.apache.daffodil.util.Maybe
 import org.apache.daffodil.processors.Success
 import org.apache.daffodil.infoset.Infoset
 import org.apache.daffodil.infoset.DISimple
-import org.apache.daffodil.infoset.EndElement
 
 final class SetVariableSuspendableExpression(
   override val expr: CompiledExpression[AnyRef],
@@ -121,31 +120,21 @@ class TypeValueCalcUnparser(typeCalculator: TypeCalculator[AnyRef, AnyRef], repT
     Assert.invariant(ustate.currentInfosetNode.isSimple)
 
     val currentSimple = ustate.currentInfosetNode.asSimple
-    
+
     val logicalValue: AnyRef = currentSimple.dataValue
     val logicalValueType = currentSimple.erd.optPrimType.get
     val repTypeValue: Maybe[AnyRef] = typeCalculator.outputTypeCalcUnparse(ustate, e, logicalValue, logicalValueType)
 
     val origInfosetElement = ustate.currentInfosetNode
-    val tmpInfosetElement = Infoset.newElement(repTypeRuntimeData, repTypeRuntimeData.tunable).asInstanceOf[DISimple]
+    val tmpInfosetElement = Infoset.newElement(repTypeRuntimeData).asInstanceOf[DISimple]
 
     if (ustate.processorStatus == Success) {
 
       Assert.invariant(repTypeValue.isDefined)
       tmpInfosetElement.setDataValue(repTypeValue.get)
       ustate.currentInfosetNodeStack.push(Maybe(tmpInfosetElement))
-
-      try {
-        repTypeUnparser.unparse1(ustate)
-      } catch {
-        case e: Throwable => {
-          e.printStackTrace()
-        }
-      } finally {
-        ustate.currentInfosetNodeStack.pop
-      }
+      repTypeUnparser.unparse1(ustate)
+      ustate.currentInfosetNodeStack.pop
     }
-
   }
-
 }
diff --git a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/NilEmptyCombinatorUnparsers.scala b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/NilEmptyCombinatorUnparsers.scala
index 6aeb5013a7..d1146f5ffb 100644
--- a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/NilEmptyCombinatorUnparsers.scala
+++ b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/NilEmptyCombinatorUnparsers.scala
@@ -21,7 +21,8 @@ import org.apache.daffodil.processors.ElementRuntimeData
 import org.apache.daffodil.exceptions.Assert
 import org.apache.daffodil.util.Maybe
 
-case class SimpleNilOrValueUnparser(ctxt: ElementRuntimeData,
+case class SimpleNilOrValueUnparser(
+  ctxt: ElementRuntimeData,
   nilUnparser: Unparser, valueUnparser: Unparser) extends CombinatorUnparser(ctxt) {
 
   override lazy val runtimeDependencies = Vector()
@@ -43,7 +44,8 @@ case class SimpleNilOrValueUnparser(ctxt: ElementRuntimeData,
   }
 }
 
-case class ComplexNilOrContentUnparser(ctxt: ElementRuntimeData,
+case class ComplexNilOrContentUnparser(
+  ctxt: ElementRuntimeData,
   nilUnparser: Unparser, contentUnparser: Unparser) extends CombinatorUnparser(ctxt) {
 
   override lazy val runtimeDependencies = Vector()
@@ -53,7 +55,10 @@ case class ComplexNilOrContentUnparser(ctxt: ElementRuntimeData,
   def unparse(state: UState): Unit = {
     Assert.invariant(Maybe.WithNulls.isDefined(state.currentInfosetNode))
     val inode = state.currentInfosetNode.asComplex
-    if (inode.isNilled) nilUnparser.unparse1(state)
-    else contentUnparser.unparse1(state)
+    val maybeIsNilled = inode.maybeIsNilled
+    if (maybeIsNilled.isDefined && maybeIsNilled.get)
+      nilUnparser.unparse1(state)
+    else
+      contentUnparser.unparse1(state)
   }
 }
diff --git a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/SeparatedSequenceUnparsers.scala b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/SeparatedSequenceUnparsers.scala
index 43c5912ab0..8132aafbcc 100644
--- a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/SeparatedSequenceUnparsers.scala
+++ b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/SeparatedSequenceUnparsers.scala
@@ -252,6 +252,7 @@ class OrderedSeparatedSequenceUnparser(
     while (index < limit) {
       val childUnparser = childUnparsers(index)
       val trd = childUnparser.trd
+      state.pushTRD(trd) // because we inspect before we call the unparse1 for the child unparser.
       val zlDetector = childUnparser.zeroLengthDetector
       childUnparser match {
         case unparser: RepOrderedSeparatedSequenceChildUnparser => {
@@ -276,8 +277,7 @@ class OrderedSeparatedSequenceUnparser(
             val ev = state.inspectAccessor
             val isArr = erd.isArray
             if (ev.isStart && (isArr || erd.isOptional)) {
-              val eventNQN = ev.node.namedQName
-              if (eventNQN =:= erd.namedQName) {
+              if (ev.erd eq erd) {
 
                 //
                 // Note: leaving in some of these println, since debugger for unparsing is so inadequate currently.
@@ -306,13 +306,11 @@ class OrderedSeparatedSequenceUnparser(
                   Assert.invariant(erd.isRepresented) // since this is an array, can't have inputValueCalc
 
                   if (isArr) if (state.dataProc.isDefined) state.dataProc.get.beforeRepetition(state, this)
-                  // System.err.println("Starting unparse of occurrence of %s. Array Index Stack is: %s".format(
-                  //   erd.namedQName, state.arrayIndexStack))
 
                   if (unparser.isKnownStaticallyNotToSuppressSeparator ||
                     {
                       val isKnownNonZeroLength =
-                        zlDetector.isKnownNonZeroLength(state.inspectAccessor.asElement)
+                        zlDetector.isKnownNonZeroLength(state.inspectAccessor.info.element)
                       isKnownNonZeroLength
                     }) {
                     unparseOne(unparser, erd, state)
@@ -324,8 +322,6 @@ class OrderedSeparatedSequenceUnparser(
                   Assert.invariant(state.arrayIndexStack.length == arrayIndexStackDepthBefore)
                   state.moveOverOneArrayIndexOnly()
                   Assert.invariant(state.arrayPos == arrayIndexBefore + 1)
-                  // System.err.println("Finished unparse of occurrence of %s. Array Index Stack is: %s".format(
-                  //   erd.namedQName, state.arrayIndexStack))
 
                   Assert.invariant(state.groupIndexStack.length == groupIndexStackDepthBefore)
                   state.moveOverOneGroupIndexOnly() // array elements are always represented.
@@ -334,8 +330,6 @@ class OrderedSeparatedSequenceUnparser(
                   if (isArr) if (state.dataProc.isDefined) state.dataProc.get.afterRepetition(state, this)
 
                 }
-                // System.err.println("Finished unparse of array/opt %s. Array Index Stack is: %s, maxReps %s, numOccurrences %s".format(
-                //   erd.namedQName, state.arrayIndexStack, maxReps, numOccurrences))
                 numOccurrences = unparsePositionallyRequiredSeps(unparser, erd, state, numOccurrences, trailingSuspendedOps)
                 unparser.checkFinalOccursCountBetweenMinAndMaxOccurs(state, unparser, numOccurrences, maxReps, state.arrayPos - 1)
                 unparser.endArrayOrOptional(erd, state)
@@ -349,7 +343,7 @@ class OrderedSeparatedSequenceUnparser(
 
             } else if (ev.isStart) {
               Assert.invariant(!ev.erd.isArray && !erd.isOptional)
-              val eventNQN = ev.node.namedQName
+              val eventNQN = ev.erd.namedQName
               Assert.invariant(eventNQN != erd.namedQName)
               //
               // start of scalar.
@@ -358,7 +352,7 @@ class OrderedSeparatedSequenceUnparser(
               //
               numOccurrences = unparsePositionallyRequiredSeps(unparser, erd, state, numOccurrences, trailingSuspendedOps)
             } else {
-              Assert.invariant(ev.isEnd && ev.isComplex)
+              Assert.invariant(ev.isEnd && ev.erd.isComplexType)
               unparser.checkFinalOccursCountBetweenMinAndMaxOccurs(state, unparser, numOccurrences, maxReps, 0)
               numOccurrences = unparsePositionallyRequiredSeps(unparser, erd, state, numOccurrences, trailingSuspendedOps)
             }
@@ -400,6 +394,7 @@ class OrderedSeparatedSequenceUnparser(
           }
         }
       }
+      state.popTRD(trd)
       index += 1
     }
     ssp match {
@@ -463,7 +458,7 @@ class OrderedSeparatedSequenceUnparser(
     while (index < limit) {
       val childUnparser = childUnparsers(index)
       val trd = childUnparser.trd
-
+      state.pushTRD(trd) // because we inspect before we invoke child unparser
       //
       // Unparsing an ordered sequence depends on the incoming
       // stream of infoset events matching up with the order that
@@ -489,17 +484,8 @@ class OrderedSeparatedSequenceUnparser(
             val ev = state.inspectAccessor
             val isArr = erd.isArray
             if (ev.isStart && (isArr || erd.isOptional)) {
-              val eventNQN = ev.node.namedQName
-              if (eventNQN =:= erd.namedQName) {
-
-                //
-                // Note: leaving in some of these println, since debugger for unparsing is so inadequate currently.
-                // This is the only way to figure out what is going on.
+              if (ev.erd eq erd) {
                 //
-                // System.err.println("Starting unparse of array/opt %s. Array Index Stack is: %s".format(
-                //   erd.namedQName, state.arrayIndexStack))
-                //
-
                 // StartArray for this unparser's array element
                 //
                 unparser.startArrayOrOptional(state)
@@ -508,15 +494,11 @@ class OrderedSeparatedSequenceUnparser(
                   doUnparser
                 }) {
                   if (isArr) if (state.dataProc.isDefined) state.dataProc.get.beforeRepetition(state, this)
-                  // System.err.println("Starting unparse of occurrence of %s. Array Index Stack is: %s".format(
-                  //   erd.namedQName, state.arrayIndexStack))
 
                   unparseOne(unparser, erd, state)
                   numOccurrences += 1
 
                   state.moveOverOneArrayIndexOnly()
-                  // System.err.println("Finished unparse of occurrence of %s. Array Index Stack is: %s".format(
-                  //   erd.namedQName, state.arrayIndexStack))
 
                   state.moveOverOneGroupIndexOnly() // array elements are always represented.
 
@@ -532,8 +514,6 @@ class OrderedSeparatedSequenceUnparser(
                     numExtraSeps -= 1
                   }
                 }
-                // System.err.println("Finished unparse of array/opt %s. Array Index Stack is: %s, maxReps %s, numOccurrences %s".format(
-                //   erd.namedQName, state.arrayIndexStack, maxReps, numOccurrences))
                 unparser.checkFinalOccursCountBetweenMinAndMaxOccurs(state, unparser, numOccurrences, maxReps, state.arrayPos - 1)
                 unparser.endArrayOrOptional(erd, state)
               } else {
@@ -550,10 +530,11 @@ class OrderedSeparatedSequenceUnparser(
               // start of scalar.
               // That has to be for a different element later in the sequence
               // since this one has a RepUnparser (i.e., is NOT scalar)
-              val eventNQN = ev.node.namedQName
+              //
+              val eventNQN = ev.erd.namedQName
               Assert.invariant(eventNQN != erd.namedQName)
             } else {
-              Assert.invariant(ev.isEnd && ev.isComplex)
+              Assert.invariant(ev.isEnd && ev.erd.isComplexType)
               unparser.checkFinalOccursCountBetweenMinAndMaxOccurs(state, unparser, numOccurrences, maxReps, 0)
             }
           } else {
@@ -571,6 +552,7 @@ class OrderedSeparatedSequenceUnparser(
           }
         }
       }
+      state.popTRD(trd)
       index += 1
     }
     state.groupIndexStack.pop()
diff --git a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/SequenceChildUnparsers.scala b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/SequenceChildUnparsers.scala
index 8777709e33..5558b0c5ac 100644
--- a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/SequenceChildUnparsers.scala
+++ b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/SequenceChildUnparsers.scala
@@ -88,7 +88,7 @@ abstract class RepeatingChildUnparser(
     if (ev.erd.isArray) {
       // only pull start array event for a true array, not an optional.
       val event = state.advanceOrError
-      Assert.invariant(event.isStart && event.node.isInstanceOf[DIArray])
+      Assert.invariant(event.isStart && event.isArray)
       // pull the next event, so that nothing else sees or deals with array start events
       state.inspect
     }
@@ -102,8 +102,9 @@ abstract class RepeatingChildUnparser(
     if (currentArrayERD.isArray) {
       // only pull end array event for a true array, not an optional
       val event = state.advanceOrError
-      if (!(event.isEnd && event.node.isInstanceOf[DIArray])) {
-        UE(state, "Expected array end event for %s, but received %s.", erd.namedQName, event)
+      if (!(event.isEnd && event.isArray)) {
+        UE(state, "Expected array end event for %s, but received %s.",
+          erd.namedQName.toExtendedSyntax, event)
       }
     }
 
@@ -154,8 +155,7 @@ abstract class RepeatingChildUnparser(
           if (state.inspect) {
             val ev = state.inspectAccessor
             if (ev.isStart) {
-              val eventNQN = ev.node.namedQName
-              if (eventNQN =:= erd.namedQName) {
+              if (ev.erd eq erd) {
                 true
               } else {
                 // System.err.println("Stopping occurrences(1) of %s due to event %s".format(erd.namedQName, ev))
@@ -249,7 +249,7 @@ abstract class RepeatingChildUnparser(
       (ock ne Implicit)) {
       if (state.inspect) {
         val ev = state.inspectAccessor
-        if (ev.isStart && ev.node.namedQName == erd)
+        if (ev.isStart && ev.erd.namedQName == erd)
           // This is the error we get if there are more events in the infoset event stream
           // for an array, than are allowed by maxOccurs.
           UE(state, "More than maxOccurs %s occurrences of %s in Infoset input: Expected no more events for %s, but received %s.", maxReps, erd.namedQName, ev)
diff --git a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/SpecifiedLengthUnparsers.scala b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/SpecifiedLengthUnparsers.scala
index 1803851428..edf31170ae 100644
--- a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/SpecifiedLengthUnparsers.scala
+++ b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/SpecifiedLengthUnparsers.scala
@@ -335,7 +335,7 @@ trait KnownPrefixedLengthUnparserMixin {
     val adjustedLenInUnits = lenInUnits + prefixedLengthAdjustmentInUnits
 
     // create a "detached" element that the prefix length will be parsed to.
-    val plElement = Infoset.newElement(prefixedLengthERD, state.tunable).asInstanceOf[DISimple]
+    val plElement = Infoset.newElement(prefixedLengthERD).asInstanceOf[DISimple]
     plElement.setDataValue(java.lang.Integer.valueOf(adjustedLenInUnits.toInt))
 
     // unparse the prefixed length element
@@ -391,7 +391,7 @@ class SpecifiedLengthPrefixedUnparser(
 
   override def unparse(state: UState): Unit = {
     // create a "detached" element that the prefix length will be used to unparse
-    val plElem = Infoset.newElement(prefixedLengthERD, state.tunable).asInstanceOf[DISimple]
+    val plElem = Infoset.newElement(prefixedLengthERD).asInstanceOf[DISimple]
 
     // The prefixedLengthUnparser is going to end up creating a suspension
     // because plElem does not have a value yet. We will temporary push the
diff --git a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/UnseparatedSequenceUnparsers.scala b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/UnseparatedSequenceUnparsers.scala
index d120f2c71b..f545138faf 100644
--- a/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/UnseparatedSequenceUnparsers.scala
+++ b/daffodil-runtime1-unparser/src/main/scala/org/apache/daffodil/processors/unparsers/UnseparatedSequenceUnparsers.scala
@@ -81,6 +81,7 @@ class OrderedUnseparatedSequenceUnparser(rd: SequenceRuntimeData, childUnparsers
     while (index < limit) {
       val childUnparser = childUnparsers(index)
       val trd = childUnparser.trd
+      state.pushTRD(trd) // because we inspect before we invoke the unparser
 
       //
       // Unparsing an ordered sequence depends on the incoming
@@ -109,8 +110,8 @@ class OrderedUnseparatedSequenceUnparser(rd: SequenceRuntimeData, childUnparsers
             val ev = state.inspectAccessor
             val isArr = ev.isArray
             if (ev.isStart && (isArr || ev.erd.isOptional)) {
-              val eventNQN = ev.node.namedQName
-              if (eventNQN =:= erd.namedQName) {
+              val eventNQN = ev.namedQName
+              if (ev.erd eq erd) {
                 //
                 // StartArray for this unparser's array element
                 //
@@ -150,16 +151,17 @@ class OrderedUnseparatedSequenceUnparser(rd: SequenceRuntimeData, childUnparsers
               // start of scalar.
               // That has to be for a different element later in the sequence
               // since this one has a RepUnparser (i.e., is NOT scalar)
-              val eventNQN = ev.node.namedQName
+              val eventNQN = ev.namedQName
               Assert.invariant(eventNQN != erd.namedQName)
             } else {
-              Assert.invariant(ev.isEnd && ev.isComplex)
+              Assert.invariant(ev.isEnd && ev.erd.isComplexType)
               unparser.checkFinalOccursCountBetweenMinAndMaxOccurs(state, unparser, numOccurrences, maxReps, 0)
             }
           } else {
             // no event (state.inspect returned false)
             Assert.invariantFailed("No event for unparing.")
           }
+
           state.arrayIndexStack.pop()
         }
         //
@@ -173,6 +175,8 @@ class OrderedUnseparatedSequenceUnparser(rd: SequenceRuntimeData, childUnparsers
           }
         }
       }
+
+      state.popTRD(trd)
       index += 1
       //
       // Note: the invariant is that unparsers move over 1 within their group themselves
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/dsom/CompiledExpression1.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/dsom/CompiledExpression1.scala
index f7ee1dd5c4..97bdb2b76d 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/dsom/CompiledExpression1.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/dsom/CompiledExpression1.scala
@@ -240,7 +240,7 @@ class DPathCompileInfo(
    * Then we move outward to the enclosing element - and if there
    * isn't one we return None. (Which most likely will lead to an SDE.)
    */
-  final def enclosingElementCompileInfos: Seq[DPathElementCompileInfo] = {
+  final lazy val enclosingElementCompileInfos: Seq[DPathElementCompileInfo] = {
     val eci = elementCompileInfos.flatMap { _.parents }
     val res = eci.flatMap { _.elementCompileInfos }
     res
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/InfosetImpl.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/InfosetImpl.scala
index eacbe2bd21..12ff7cf491 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/InfosetImpl.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/InfosetImpl.scala
@@ -61,7 +61,7 @@ sealed trait DINode {
     this match {
       case diSimple: DISimple => diSimple
       case _ => {
-        throw new InfosetWrongNodeType("simpleType", this) // see comment with exception class definition for why this can happen
+        erd.toss(new InfosetWrongNodeType("simpleType", this)) // see comment with exception class definition for why this can happen
       }
     }
   }
@@ -71,12 +71,16 @@ sealed trait DINode {
     this match {
       case diComplex: DIComplex => diComplex
       case _ => {
-        throw new InfosetWrongNodeType("complexType", this) // see comment with exception class definition for why this can happen
+        erd.toss(new InfosetWrongNodeType("complexType", this)) // see comment with exception class definition for why this can happen
       }
     }
   }
   def isComplex: Boolean
 
+  def asElement: DIElement =
+    if (isSimple) asSimple
+    else asComplex
+
   def isDefaulted: Boolean
 
   def children: Stream[DINode]
@@ -554,7 +558,7 @@ class ContentLengthState(ie: DIElement) extends LengthState(ie) {
 
   override def throwUnknown = {
     Assert.invariant(ie ne null)
-    throw new InfosetContentLengthUnknownException(this, ie, ie.runtimeData)
+    ie.erd.toss(new InfosetContentLengthUnknownException(this, ie, ie.runtimeData))
   }
 
 }
@@ -565,7 +569,7 @@ class ValueLengthState(ie: DIElement) extends LengthState(ie) {
 
   override def throwUnknown = {
     Assert.invariant(ie ne null)
-    throw new InfosetValueLengthUnknownException(this, ie, ie.runtimeData)
+    ie.erd.toss(new InfosetValueLengthUnknownException(this, ie, ie.runtimeData))
   }
 
 }
@@ -844,17 +848,17 @@ sealed trait DIElement
     else {
       parent match {
         case null =>
-          throw new InfosetNoRootException(orig, erd)
+          orig.erd.toss(new InfosetNoRootException(orig, erd))
         case elt: DIElement => elt.toRootDoc1(orig)
         case _ =>
-          throw new InfosetNoRootException(orig, erd)
+          orig.erd.toss(new InfosetNoRootException(orig, erd))
       }
     }
   }
 
   def toParent = {
     if (parent eq null)
-      throw new InfosetNoParentException(this, erd)
+      erd.toss(new InfosetNoParentException(this, erd))
     diParent
   }
 
@@ -993,9 +997,9 @@ final class DIArray(
    */
   def getOccurrence(occursIndex1b: Long) = {
     if (occursIndex1b < 1)
-      throw new InfosetFatalArrayIndexOutOfBoundsException(this, occursIndex1b, length) // no blocking.
+      erd.toss(new InfosetFatalArrayIndexOutOfBoundsException(this, occursIndex1b, length)) // no blocking.
     if (occursIndex1b > length)
-      throw new InfosetArrayIndexOutOfBoundsException(this, occursIndex1b, length) // can be retried after blocking.
+      erd.toss(new InfosetArrayIndexOutOfBoundsException(this, occursIndex1b, length)) // can be retried after blocking.
     _contents(occursIndex1b.toInt - 1)
   }
 
@@ -1008,7 +1012,7 @@ final class DIArray(
 
   def concat(array: DIArray) = {
     val newContents = array.contents
-    newContents.foreach( ie => {
+    newContents.foreach(ie => {
       ie.asInstanceOf[InfosetElement].setArray(this)
       append(ie.asInstanceOf[InfosetElement])
     })
@@ -1173,7 +1177,7 @@ sealed class DISimple(override val erd: ElementRuntimeData)
     else if (_isNilledSet) {
       _isNilled
     } else {
-      throw new InfosetNoDataException(this, erd)
+      erd.toss(InfosetNoDataException(this, erd))
     }
   }
 
@@ -1218,7 +1222,7 @@ sealed class DISimple(override val erd: ElementRuntimeData)
         }
         _isDefaulted = true
       } else {
-        throw new InfosetNoDataException(this, erd)
+        erd.toss(new InfosetNoDataException(this, erd))
       }
     if (_value == null) {
       this.erd.schemaDefinitionError("Value has not been set.")
@@ -1345,13 +1349,15 @@ sealed trait DIFinalizable {
  * One[DIArray] means the slot is for a recurring element which can have 2+ instances.
  * The DIArray object's length gives the number of occurrences.
  */
-sealed class DIComplex(override val erd: ElementRuntimeData, val tunable: DaffodilTunables)
+sealed class DIComplex(override val erd: ElementRuntimeData)
   extends DIElement
   with DIComplexSharedImplMixin
   with InfosetComplexElement
   with DIFinalizable // with HasModelGroupMixin
   { diComplex =>
 
+  def tunable: DaffodilTunables = toRootDoc.tunable
+
   final override def isSimple = false
   final override def isComplex = true
 
@@ -1384,7 +1390,7 @@ sealed class DIComplex(override val erd: ElementRuntimeData, val tunable: Daffod
       // TODO: should we check that there are no children?
       false
     } else {
-      throw new InfosetNoDataException(this, erd)
+      erd.toss(new InfosetNoDataException(this, erd))
     }
   }
 
@@ -1423,7 +1429,7 @@ sealed class DIComplex(override val erd: ElementRuntimeData, val tunable: Daffod
     if (maybeNode.isDefined)
       maybeNode.get.asInstanceOf[InfosetElement]
     else
-      throw new InfosetNoSuchChildElementException(this, nqn)
+      erd.toss(new InfosetNoSuchChildElementException(this, nqn))
   }
 
   final def getChildArray(childERD: ElementRuntimeData): InfosetArray = {
@@ -1437,7 +1443,7 @@ sealed class DIComplex(override val erd: ElementRuntimeData, val tunable: Daffod
     if (maybeNode.isDefined) {
       maybeNode.get.asInstanceOf[InfosetArray]
     } else {
-      throw new InfosetNoSuchChildElementException(this, nqn)
+      erd.toss(new InfosetNoSuchChildElementException(this, nqn))
     }
   }
 
@@ -1463,7 +1469,7 @@ sealed class DIComplex(override val erd: ElementRuntimeData, val tunable: Daffod
         // Flatten multiple DIArrays into the first one
         if (erd.isArray) {
           val a = nodes(0).asInstanceOf[DIArray]
-          nodes.tail.foreach( b => a.concat(b.asInstanceOf[DIArray]))
+          nodes.tail.foreach(b => a.concat(b.asInstanceOf[DIArray]))
           nodes.reduceToSize(1)
 
           // Need to also remove duplicates from fastLookup
@@ -1636,8 +1642,10 @@ sealed class DIComplex(override val erd: ElementRuntimeData, val tunable: Daffod
  * Making this extend DIComplex eliminates a bunch of boundary
  * conditions having to do with the document root element.
  */
-final class DIDocument(erd: ElementRuntimeData, tunable: DaffodilTunables)
-  extends DIComplex(erd, tunable)
+final class DIDocument(
+  erd: ElementRuntimeData,
+  override val tunable: DaffodilTunables)
+  extends DIComplex(erd)
   with InfosetDocument {
   var root: DIElement = null
 
@@ -1686,9 +1694,9 @@ final class DIDocument(erd: ElementRuntimeData, tunable: DaffodilTunables)
 
 object Infoset {
 
-  def newElement(erd: ElementRuntimeData, tunable: DaffodilTunables): InfosetElement = {
+  def newElement(erd: ElementRuntimeData): InfosetElement = {
     if (erd.isSimpleType) new DISimple(erd)
-    else new DIComplex(erd, tunable)
+    else new DIComplex(erd)
   }
 
   def newDocument(erd: ElementRuntimeData, tunable: DaffodilTunables): InfosetDocument = {
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/InfosetInputter.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/InfosetInputter.scala
index 04749eaca5..1a538b2ae7 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/InfosetInputter.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/InfosetInputter.scala
@@ -26,34 +26,70 @@ import org.apache.daffodil.util.Accessor
 import org.apache.daffodil.util.Misc
 import org.apache.daffodil.exceptions.Assert
 import org.apache.daffodil.util.CursorImplMixin
-import org.apache.daffodil.util.MStackOf
+import org.apache.daffodil.util.MStack
 import org.apache.daffodil.processors.unparsers.UnparseError
 import org.apache.daffodil.dpath.NodeInfo
 import org.apache.daffodil.api.DaffodilTunables
 import org.apache.daffodil.processors.ElementRuntimeData
+import org.apache.daffodil.processors.ErrorERD
+import org.apache.daffodil.util.MStackOfAnyRef
 
-class InfosetError(kind: String, args: String*) extends ProcessingError("Infoset", Nope, Nope, kind, args: _*)
+class InfosetError(kind: String, args: String*)
+  extends ProcessingError("Infoset", Nope, Nope, kind, args: _*)
 
+/**
+ * These are the events that a derived specific InfosetInputter
+ * creates.
+ *
+ * The InfosetInputter base class figures out Daffodil InfosetEvents from
+ * the call-backs providing these derived-class events types.
+ */
 sealed trait InfosetInputterEventType
-case object StartDocument extends InfosetInputterEventType
-case object EndDocument extends InfosetInputterEventType
-case object StartElement extends InfosetInputterEventType
-case object EndElement extends InfosetInputterEventType
-
-trait InfosetInputterCursor extends Cursor[InfosetAccessor] {
-  /**
-   * Override these further only if you want to say, delegate from one cursor implemtation
-   * to another one.
-   */
-  override lazy val advanceAccessor = InfosetAccessor(null, null, null)
-  override lazy val inspectAccessor = InfosetAccessor(null, null, null)
-
-  def initialize(rootElement: ElementRuntimeData, tunable: DaffodilTunables)
+object InfosetInputterEventType {
+  case object StartDocument extends InfosetInputterEventType
+  case object EndDocument extends InfosetInputterEventType
+  case object StartElement extends InfosetInputterEventType
+  case object EndElement extends InfosetInputterEventType
 }
 
+/**
+ * Base class for objects that create Unparser infoset events from
+ * some representation/source of infoset information like
+ * XML objects, DOM trees, or XML text, or JSON text, etc.
+ *
+ * Events are pulled from this object via the usual iterator
+ * hasNext()/next() idiom.
+ *
+ * However, next() does not return an object, but rather populates
+ * an accessor by side effect, so this is a Cursor-style API.
+ * You advance the cursor by calling next(), and the data appears under
+ * the accessor.
+ *
+ * Supports a peek-style of operation by having two ways of advancing
+ * and two accessors.
+ *
+ * Method advance is normal, and the advanceAccessor then has the data
+ * of the event.
+ *
+ * Method inspect is a "peek", and the inspectAccessor then has the data
+ * of the event, but the same data will be provided via the advanceAccessor
+ * after the next advance call.
+ *
+ * Besides pulling events via inspect or advance,
+ * the caller is responsible to maintain the TRD (TermRuntimeData) stack by
+ * calling pushTRD and popTRD for all Terms (model-groups, and elements).
+ * This is necessary so that the infoset inputter can resolve element
+ * name + namespace into the proper ERD based on the proper dynamic context.
+ */
 abstract class InfosetInputter
-  extends InfosetInputterCursor
-  with CursorImplMixin[InfosetAccessor] {
+  extends CursorImplMixin[InfosetAccessor]
+  with NextElementResolver {
+
+  type ERD = ElementRuntimeData
+
+  private var isInitialized_ : Boolean = false
+
+  def isInitialized = isInitialized_
 
   var tunable = DaffodilTunables()
 
@@ -112,83 +148,61 @@ abstract class InfosetInputter
    */
   val supportsNamespaces: Boolean
 
+  final override lazy val advanceAccessor = InfosetAccessor()
+  final override lazy val inspectAccessor = InfosetAccessor()
+
+  private var documentElement_ : DIDocument = _
+
+  /**
+   * Mostly this is for unit testing where we want to inspect
+   * the infoset the unparser constructed, as well as looking at
+   * the data that was output.
+   */
+  def documentElement = {
+    Assert.usage(isInitialized, "Must be initialized")
+    documentElement_
+  }
+
+  /**
+   * Initialize the infoset inputter, given the ERD of the root element, and
+   * the tunables.
+   */
   def initialize(rootElementInfo: ElementRuntimeData, tunableArg: DaffodilTunables): Unit = {
     tunable = tunableArg
-    nextElementResolver =
-      new OnlyOnePossibilityForNextElement(rootElementInfo.schemaFileLocation, rootElementInfo, RootResolver) // bootstrap
+    isInitialized_ = true
 
-    val diDoc = new DIDocument(rootElementInfo, tunable)
-    nodeStack.push(diDoc)
+    documentElement_ = new DIDocument(rootElementInfo, tunable)
+    infoStack.push(documentElement_)
 
     try {
-      if (!hasNext() || getEventType() != StartDocument) {
-        UnparseError(One(nodeStack.top.erd.schemaFileLocation), Nope, "Infoset does not start with StartDocument event")
+      if (!hasNext() || getEventType() != InfosetInputterEventType.StartDocument) {
+        UnparseError(One(infoStack.top.erd.schemaFileLocation), Nope, "Infoset does not start with StartDocument event")
       }
     } catch {
       case e: InvalidInfosetException =>
-        UnparseError(One(nodeStack.top.erd.schemaFileLocation), Nope, "Infoset does not start with StartDocument event: " + e.getMessage)
+        UnparseError(One(infoStack.top.erd.schemaFileLocation), Nope, "Infoset does not start with StartDocument event: " + e.getMessage)
     }
-  }
 
-  private type NodeStack = MStackOf[DINode]
-  private val nodeStack: NodeStack = new MStackOf[DINode]
+    this.pushTRD(rootElementInfo) // TRD stack holds TRDs of model groups
+  }
 
-  private var nextElementResolver: NextElementResolver = null
+  private val infoStack = new Info.InfoStack
 
-  private def level = nodeStack.length
+  private def level = infoStack.length
 
   private def indent = ("  " * level) + "|"
 
   override def toString() = {
     indent + "************* STATE ************************\n" +
-      indent + "nextElementResolver = " + nextElementResolver + "\n" +
-      indent + "nodeStack = " + nodeStack + "\n" +
+      indent + "infoStack = " + infoStack + "\n" +
       indent + "********************************************"
   }
 
-  override def inspectPure: Boolean = {
-    accessor = inspectAccessor
-
-    val res = priorOpKind match {
-      case Advance => {
-        priorOpKind = InspectPure
-        if (isPending) {
-          accessor.kind = pendingStartOrEnd(pendingCurIndex)
-          accessor.node = pendingNodes(pendingCurIndex)
-          accessor.erd = accessor.node.erd
-        } else {
-          next() //advance the input stream so nextElementErd is pointing to the correct place
-          val eventKind = getEventType() match {
-            case StartElement => StartKind
-            case EndElement => EndKind
-            case StartDocument => StartKind
-            case EndDocument => EndKind
-          }
-          accessor.kind = eventKind
-          if (eventKind == StartKind) {
-            accessor.erd = nextElementErd()
-            accessor.node = null
-          } else {
-            //accessor.kind == EndKind
-            val node = nodeStack.top
-            accessor.node = node
-            accessor.erd = node.erd
-          }
-        }
-        true
-      }
-      case InspectPure => true
-      case Inspect => true
-      case Unsuccessful => false
-    }
-
-    res
-  }
-
   /**
    * Queues used to hold additional events, thereby allowing a single pull to result
    * in multiple infoset events. For each pull, the first event coming back is not
-   * queued. Only additional extra events are queued.
+   * queued, it is placed directly into the accessor for that type of pull.
+   * Only additional extra events are queued.
    *
    * Note that there should never be more than 2 events in the queue. This
    * occurs when ending an array following by a new array of simple elements.
@@ -203,31 +217,38 @@ abstract class InfosetInputter
    * an array of pairs.
    */
   final private val MaxPendingQueueSize = 2
-  private val pendingNodes = new Array[DINode](MaxPendingQueueSize)
+  private val pendingInfos = new Array[Info](MaxPendingQueueSize)
   private val pendingStartOrEnd = new Array[InfosetEventKind](MaxPendingQueueSize)
   private var pendingCurIndex: Int = 0
   private var pendingLength: Int = 0
 
-  private def queueAnotherEvent(kind: InfosetEventKind, node: DINode) {
+  private def queueElementStart(element: DIElement) =
+    queueEventInfo_(InfosetEventKind.StartElement, Info(element))
+  private def queueElementEnd(element: DIElement) =
+    queueEventInfo_(InfosetEventKind.EndElement, Info(element))
+
+  private def queueArrayStart(arrayERD: ERD) =
+    queueEventInfo_(InfosetEventKind.StartArray, Info(arrayERD))
+
+  private def queueEventInfo_(kind: InfosetEventKind, info: Info) {
     Assert.invariant(pendingLength < MaxPendingQueueSize)
-    pendingNodes(pendingLength) = node
+    pendingInfos(pendingLength) = info
     pendingStartOrEnd(pendingLength) = kind
     pendingLength += 1
-    if (kind eq EndKind) {
-      node match {
-        case f: DIFinalizable => f.setFinal()
-        case _ => // ok
-      }
-    }
   }
 
   private def isPending: Boolean = pendingCurIndex < pendingLength
 
-  private def dequeuePending(): (InfosetEventKind, DINode) = {
+  /**
+   * Scala compiler seems to avoid tuple allocation for 2-tuples
+   * that are directly deconstructed by the caller. So this shouldn't
+   * cause allocation of objects.
+   */
+  private def dequeuePending(): (InfosetEventKind, Info) = {
     Assert.invariant(pendingCurIndex >= 0)
     Assert.invariant(pendingCurIndex < pendingLength)
     Assert.usage(isPending)
-    val p = (pendingStartOrEnd(pendingCurIndex), pendingNodes(pendingCurIndex))
+    val p = (pendingStartOrEnd(pendingCurIndex), pendingInfos(pendingCurIndex))
     pendingCurIndex += 1
     if (pendingCurIndex == pendingLength) {
       // the last element of the queue has been removed. The queue is now
@@ -246,9 +267,12 @@ abstract class InfosetInputter
   protected final def fill(advanceInput: Boolean): Boolean = {
     if (isPending) {
       val (kind, n) = dequeuePending()
+      import InfosetEventKind._
       kind match {
-        case StartKind => start(n)
-        case EndKind => end(n)
+        case StartElement => startElement(n.element)
+        case EndElement => endElement(n.element)
+        case StartArray => startArray(n.arrayERD)
+        case EndArray => endArray(n.arrayERD)
       }
       true
     } else {
@@ -256,7 +280,7 @@ abstract class InfosetInputter
         reallyFill(advanceInput)
       } catch {
         case ex: InvalidInfosetException => {
-          UnparseError(One(nodeStack.top.erd.schemaFileLocation), Nope, ex.getMessage())
+          UnparseError(One(infoStack.top.erd.schemaFileLocation), Nope, ex.getMessage())
         }
       }
     }
@@ -266,7 +290,7 @@ abstract class InfosetInputter
     if (advanceInput) {
       next()
     }
-
+    import InfosetInputterEventType._
     getEventType() match {
       case StartElement => handleStartElement()
       case EndElement => handleEndElement()
@@ -276,95 +300,98 @@ abstract class InfosetInputter
 
     if (!hasNext()) {
       Assert.invariant(getEventType() == EndDocument)
-      Assert.invariant(nodeStack.top.isInstanceOf[DIDocument])
       fini
       false
     } else
       true
   }
 
-  private def handleStartElement() {
-    val e = createElement()
+  private def handleStartElement(): Unit = {
+    val erd = nextElementErd()
+    val node = createElement(erd)
     //
-    // There's state changes to the parent (which is complex or array)
-    // and to the nodeStack to be done, and we have to either
-    // populate the accessor with this node, or populate based on
-    // an array transition.
+    // An ERD can come back that indicates an error.
+    // We still want to create an infoset event, so that the consuming
+    // unparsers can look at it to see if it is a start/end and possibly
+    // correct the diagnostic from invalid element received, to
+    // "expected an end, but got a start".
     //
-    if (nodeStack.top.isInstanceOf[DIComplex]) {
-      val c = nodeStack.top.asInstanceOf[DIComplex]
+    // Furthermore, an ERD can come back from inspect, where we're not
+    // ready yet to attach to the infoset, because the ERD is for an
+    // element that is later, and in the mean time we have to augment
+    // the infoset with OutputValueCalc elements, or with defaultable
+    // required elements that have no corresponding events in the
+    // event stream.
+
+    val top = infoStack.top
+    if (top.isComplexElement) {
+      // An open complex element is on top of stack.
+      // This start event must be for a child element
+      val c = top.asComplex
       val optNilled = c.maybeIsNilled
       if (optNilled.isDefined && optNilled.get) {
         // cannot add content to a nilled complex element
-        UnparseError(One(c.erd.schemaFileLocation), Nope, "Nilled complex element %s has content", c.erd.namedQName.toExtendedSyntax)
+        UnparseError(One(c.erd.schemaFileLocation), Nope, "Nilled complex element %s has content %s.",
+          c.erd.namedQName.toExtendedSyntax,
+          erd.namedQName.toExtendedSyntax)
       }
-      if (!e.erd.isArray) {
-        c.addChild(e)
-        start(e)
+      if (erd.isArray) {
+        // start of child which is an array
+        startArray(erd)
+        infoStack.push(erd)
+        queueElementStart(node)
+        infoStack.push(node)
       } else {
-        c.addChild(e) // addChild here sets the 'array' value
-        val a = e.array.get.asInstanceOf[DIArray]
-        nodeStack.push(a)
-        //
-        // The first event is created (and passed back) via the start method
-        // Subsequent events that also need to be generated are queued by
-        // way of calling queueAnotherEvent.
-        //
-        // The queue is not used for the first event.
-        //
-        start(a)
-        queueAnotherEvent(StartKind, e)
+        Assert.invariant(!erd.isArray)
+        // start of child which is a scalar element
+        startElement(node)
+        infoStack.push(node)
       }
+    } else if (top.isSimpleElement) {
+      // If a simple element is top of stack, we can't start another simple element
+      // because that would be nesting them. We need an end-element first, which would pop the stack.
+      UnparseError(One(top.erd.schemaFileLocation), Nope, "Simple type element %s cannot have children elements %s.",
+        top.erd.namedQName.toExtendedSyntax,
+        node.erd.namedQName.toExtendedSyntax)
     } else {
-      // top must be an array
-      val a = nodeStack.top.asInstanceOf[DIArray]
-      if (!e.erd.isArray) {
-        //
-        // not an element of this array so we have to end this
-        // array, and then see what this element requires
-        //
-        end(a)
-        nodeStack.pop
-        // top of stack now has to be a DIComplex since it held an array
-        val c = nodeStack.top.asInstanceOf[DIComplex]
-        c.addChild(e)
-        queueAnotherEvent(StartKind, e)
-      } else {
-        // could be an element of this array, or start of the next one
-        if (a.erd eq e.erd) {
-          // same array
-          a.append(e)
-          start(e)
-          e.setParent(a.parent)
+      // Top of stack indicates an array
+      Assert.invariant(top.isArrayERD)
+      // This start event must be for this array, or a subsequent element after the array
+      if (erd.isArray) {
+        // start event is for an array element
+        if (top.erd eq erd) {
+          // another peer occurrence in same array
+          // leave the array on top of stack
+          startElement(node)
+          infoStack.push(node)
         } else {
-          // start of a different array
-          end(a)
-          nodeStack.pop
-          val c = nodeStack.top.asInstanceOf[DIComplex]
-          c.addChild(e) // addChild here sets the 'array' value
-          val nextA = e.array.get.asInstanceOf[DIArray]
-          nodeStack.push(nextA)
-          queueAnotherEvent(StartKind, nextA)
-          queueAnotherEvent(StartKind, e)
+          // end of current array, start of next array
+          endArray(top.erd)
+          val inv = infoStack.pop.isArrayERD
+          Assert.invariant(inv)
+          queueArrayStart(erd)
+          infoStack.push(erd)
+          queueElementStart(node)
+          infoStack.push(node)
         }
+      } else {
+        // array being ended by a scalar element after it.
+        Assert.invariant(!erd.isArray)
+        Assert.invariant(top.erd ne erd) // can't be same element
+        // end of current array, start of a scalar element
+        endArray(top.erd)
+        val inv = infoStack.pop().isArrayERD
+        Assert.invariant(inv)
+        queueElementStart(node)
+        infoStack.push(node)
       }
     }
-
-    nodeStack.push(e)
-
-    Assert.invariant(e.parent ne null)
-    nextElementResolver =
-      if (e.erd.isSimpleType)
-        e.erd.nextElementResolver
-      else
-        e.erd.childElementResolver
   }
 
-  private def nextElementErd() = nextElementResolver.nextElement(getLocalName(), getNamespaceURI(), supportsNamespaces)
+  private def nextElementErd() = nextElement(getLocalName(), getNamespaceURI(), supportsNamespaces)
 
-  private def createElement() = {
-    val erd = nextElementErd()
-    val elem = if (erd.isSimpleType) new DISimple(erd) else new DIComplex(erd, tunable)
+  private def createElement(erd: ERD) = {
+    val elem = if (erd.isSimpleType) new DISimple(erd) else new DIComplex(erd)
 
     val optNilled = isNilled()
 
@@ -400,114 +427,280 @@ abstract class InfosetInputter
   }
 
   private def handleEndElement() {
-    nodeStack.top match {
-      case e: DIElement => {
-        end(e)
-        nodeStack.pop
-        nextElementResolver = e.erd.nextElementResolver
-      }
-      case a: DIArray => {
-        end(a)
-        nodeStack.pop
-        val parent = nodeStack.top.asInstanceOf[DIComplex]
-        queueAnotherEvent(EndKind, parent)
-        nodeStack.pop
-        nextElementResolver = parent.erd.nextElementResolver
-      }
-      case node =>
-        Assert.invariantFailed("Unexpected end element: " + node)
+    val top = infoStack.top
+
+    if (top.isSimpleElement) {
+      endElement(top.element)
+      val inv = infoStack.pop().erd.isSimpleType
+      Assert.invariant(inv)
+      //
+      // Can't check that end matches start because getLocalName() and getNamespaceURI() are
+      // supposed to only be called during startElement(). Some/most infoset external representations
+      // aren't like XML, and don't repeat name+namespace on end indications.
+      //
+    } else if (top.isComplexElement) {
+      // This has to be end event for the current element
+      endElement(top.element)
+      val inv = infoStack.pop().erd.isComplexType
+      Assert.invariant(inv)
+    } else {
+      // Top is an array
+      Assert.invariant(top.isArrayERD)
+      // This end event must be for the enclosing complex element
+      val a = top.arrayERD
+      endArray(a)
+      val inv1 = infoStack.pop().isArrayERD
+      Assert.invariant(inv1)
+      Assert.invariant(infoStack.top.erd.isComplexType)
+      val c = infoStack.top.asComplex
+      queueElementEnd(c)
+      infoStack.pop()
     }
   }
 
-  private def start(node: DINode) {
-    accessor.kind = StartKind
-    accessor.node = node
-    accessor.erd = node.erd
+  /**
+   * Fill current accessor with appropriate event information
+   */
+  private def startElement(node: DIElement) {
+    accessor.kind = InfosetEventKind.StartElement
+    accessor.info = Info(node)
   }
 
-  private def end(node: DINode) {
-    accessor.kind = EndKind
-    accessor.node = node
-    accessor.erd = node.erd
-    node match {
-      case f: DIFinalizable => f.setFinal()
-      case _ => // ok
-    }
+  /**
+   * Fill current accessor with appropriate event information
+   */
+  private def endElement(node: DIElement) {
+    accessor.kind = InfosetEventKind.EndElement
+    accessor.info = Info(node)
   }
 
-}
+  /**
+   * Fill current accessor with appropriate event information
+   */
+  private def startArray(arrayERD: ERD) {
+    accessor.kind = InfosetEventKind.StartArray
+    accessor.info = Info(arrayERD)
+  }
+
+  /**
+   * Fill current accessor with appropriate event information
+   */
+  private def endArray(arrayERD: ERD) {
+    accessor.kind = InfosetEventKind.EndArray
+    accessor.info = Info(arrayERD)
+  }
 
-object NonUsableInfosetInputter extends InfosetInputterCursor {
-  private def doNotUse = Assert.usageError("Not to be called on " + Misc.getNameFromClass(this))
-  override lazy val advanceAccessor = doNotUse
-  override lazy val inspectAccessor = doNotUse
-  override def advance = doNotUse
-  override def inspect = doNotUse
-  override def inspectPure = doNotUse
-  override def fini = doNotUse
-  override def initialize(rootElement: ElementRuntimeData, tunable: DaffodilTunables) = doNotUse
 }
 
 // Performance Note - It's silly to use both a StartKind and EndKind accessor when
 // delivering a simple type node. Separate start/end for XML makes sense because there
 // are separate events for the contents between those tags, which can be widely separated.
-// In Daffodil, the two events will always be back-to-back.... except....
-// NOTE: for large blob/clob objects there's a reason for a start/end event
-// because we may want to open a stream to get the contents in between without
-// allocating a string to hold it.
+// In Daffodil, the two events will always be back-to-back.
 //
-sealed trait InfosetEventKind
-case object StartKind extends InfosetEventKind { override def toString = "start" }
-case object EndKind extends InfosetEventKind { override def toString = "end" }
+sealed trait InfosetEventKind {
+
+  /**
+   * Converts name like StartArray into "array start"
+   *
+   * Error messages depend on this word order.
+   */
+  override def toString() = {
+    val cn = Misc.getNameFromClass(this)
+    val initialLC = Misc.initialLowerCase(cn)
+    val (se, ea) = initialLC.span(_.isLower)
+    val res = ea.toLowerCase() + " " + se
+    res
+  }
+}
+
+/**
+ * InfosetEvents are of these kinds.
+ */
+object InfosetEventKind {
+  sealed trait StartKind extends InfosetEventKind
+  sealed trait EndKind extends InfosetEventKind
+  sealed trait ArrayKind extends InfosetEventKind
+  sealed trait ElementKind extends InfosetEventKind
+  case object StartElement extends StartKind with ElementKind
+  case object EndElement extends EndKind with ElementKind
+  case object StartArray extends StartKind with ArrayKind
+  case object EndArray extends EndKind with ArrayKind
+}
 
 /**
  * An infoset event accessor.
  *
  * Not a case class because we don't want pattern matching on this. (It allocates to pattern match)
  *
- * We have erd as a seperate field (instead of just using node.erd) since
- * the inspectPure method finds an erd without constructing the corresponding DINode (so as to avoid side effects)
+ * The info associated with an infoset event is either a DIElement (for elements), or
+ * an ElementRuntimeData for arrays. We don't want to use a DIArray object because those
+ * are the private managed storage of DIComplex elements.
+ *
+ * At the time these info DIElements are created they are only to carry the infoset event information
+ * they are not attached to parents/children in the infoset.
+ *
+ * We are effectively just using them as event "tuples" to carry the ERD and simple value
+ * information after having resolved the incoming event's local name + namespace (if we're using those)
+ * to get the ERD.
+ *
+ * By using our DIElement objects as the "tuples" of event information, we avoid having to
+ * allocate yet another separate object to represent events.
  *
- * We maintaint the invariant that node==null || node.erd==erd
+ * The Unparsers will examine the incoming DIElement, and attach child to parent if
+ * they decide to keep them.
  *
+ * Unparsers are also responsible for looking at the incoming event, and deciding if we
+ * should first fill in any defaultable elements, or compute any dfdl:outputValueCalc elements.
+ *
+ * The advance/inspect change the state of the infoset inputter itself, but have no side-effects
+ * on the Unparser's UState infoset.
  */
-class InfosetAccessor private (var kind: InfosetEventKind, var node: DINode, var erd: ElementRuntimeData) extends Accessor[InfosetAccessor] {
-  def namedQName = erd.namedQName
+class InfosetAccessor private (
+  var kind: InfosetEventKind,
+  var info: Info)
+  extends Accessor[InfosetAccessor] {
 
-  Assert.invariant(node == null || node.erd == erd)
+  def erd = info.erd
+
+  def namedQName = erd.namedQName
 
+  /**
+   * This toString syntax is depended upon by diagnostic
+   * messages, and many tests verify that.
+   */
   override def toString = {
     val evLbl = if (kind eq null) "NullKind" else kind.toString
-    val nodeKind = node match {
-      case null => "?"
-      case _: DIArray => "array"
-      case _: DIElement => "element"
+    val erdString = erd match {
+      case errERD: ErrorERD => "(invalid) " + erd.namedQName.toExtendedSyntax
+      case _ => erd.namedQName.toExtendedSyntax
     }
-    nodeKind + " " + evLbl + " event for " + erd.namedQName
+    evLbl + " event for " + erdString
   }
 
   /*
    * Methods to use instead of pattern matching
    */
-  def isStart = kind == StartKind
-  def isEnd = kind == EndKind
-  def isElement = node.isInstanceOf[DIElement]
-  def asElement: DIElement = node.asInstanceOf[DIElement]
-  def isArray = node.isInstanceOf[DIArray]
-  def asArray: DIArray = node.asInstanceOf[DIArray]
-  def isComplex = node.isInstanceOf[DIComplex]
-  def asComplex: DIComplex = node.asInstanceOf[DIComplex]
-  def isSimple = node.isInstanceOf[DISimple]
-  def asSimple: DISimple = node.asInstanceOf[DISimple]
-
-  override def cpy() = new InfosetAccessor(kind, node, erd)
+  def isStart = kind.isInstanceOf[InfosetEventKind.StartKind]
+  def isEnd = kind.isInstanceOf[InfosetEventKind.EndKind]
+  def isElement = info.isElement
+  def isArray = erd.isArray
+
+  override def cpy() = new InfosetAccessor(kind, info)
   override def assignFrom(other: InfosetAccessor) {
     kind = other.kind
-    node = other.node
-    erd = other.erd
+    info = other.info
   }
 }
 
 object InfosetAccessor {
-  def apply(kind: InfosetEventKind, node: DINode, erd: ElementRuntimeData) = new InfosetAccessor(kind, node, erd)
+
+  /**
+   * Create an infoset accessor initialized to an element.
+   */
+  def apply(kind: InfosetEventKind.ElementKind, element: DIElement) =
+    new InfosetAccessor(kind, Info(element))
+
+  /**
+   * Create an infoset accessor initialized to an array ERD.
+   */
+  def apply(kind: InfosetEventKind.ArrayKind, arrayERD: ElementRuntimeData) =
+    new InfosetAccessor(kind, Info(arrayERD))
+
+  /**
+   * Construct an infoset accessor that is yet to be filled in.
+   */
+  def apply() =
+    new InfosetAccessor(null, Info())
+}
+
+/**
+ * AnyVal class that acts like a union type of DIElement and ERD.
+ *
+ * For arrays we just store an ERD. For elements we store the DIElement node
+ * as a way of capturing the event information.
+ */
+final class Info private (val v: AnyRef) extends AnyVal with Serializable {
+  def node = element
+  def element = {
+    Assert.usage(v ne null)
+    v.asInstanceOf[DIElement]
+  }
+  def isComplexElement = isElement && element.isInstanceOf[DIComplex]
+  def isSimpleElement = isElement && !isComplexElement
+  def asComplex = element.asInstanceOf[DIComplex]
+  def asSimple = element.asInstanceOf[DISimple]
+
+  def isNode = isElement
+  def isElement = {
+    Assert.usage(v ne null)
+    v.isInstanceOf[DIElement]
+  }
+  def arrayERD = {
+    Assert.usage(v ne null)
+    v.asInstanceOf[ElementRuntimeData]
+  }
+  def isArrayERD = {
+    Assert.usage(v ne null)
+    v.isInstanceOf[ElementRuntimeData]
+  }
+  def erd = v match {
+    case null => Assert.usageError("v ne null")
+    case arrayERD: ElementRuntimeData => arrayERD
+    case diElement: DIElement => diElement.erd
+  }
+
+}
+
+object Info {
+
+  /**
+   * Strongly typed stack that uses an AnyRef underneath.
+   *
+   * You can only store DIElement or ERD on this stack.
+   */
+  class InfoStack {
+    private val delegate = MStackOfAnyRef()
+
+    def push(e: DIElement): Unit = delegate.push(e)
+
+    def push(arrayERD: ElementRuntimeData): Unit = {
+      Assert.usage(arrayERD.isArray)
+      delegate.push(arrayERD)
+    }
+
+    def pop() = Info.fromAnyRef(delegate.pop)
+
+    def top() = Info.fromAnyRef(delegate.top)
+
+    def length = delegate.length
+
+    override def toString() = delegate.toString()
+  }
+
+  /**
+   * Creates an unusable Info. Used to initialize
+   * unpopulated accessors.
+   */
+  def apply() = nullValue
+
+  /**
+   * Create an ArrayERD Info
+   */
+  def apply(arrayERD: ElementRuntimeData): Info = {
+    Assert.usage(arrayERD.isArray)
+    new Info(arrayERD)
+  }
+
+  /**
+   * Create a DIElement Info
+   */
+  def apply(element: DIElement): Info = new Info(element)
+
+  private def fromAnyRef(anyRef: AnyRef): Info = anyRef match {
+    case erd: ElementRuntimeData => Info(erd)
+    case e: DIElement => Info(e)
+    case _ => Assert.usageError("not called on ERD or DIElement")
+  }
+
+  private val nullValue = new Info(null)
 }
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/JDOMInfosetInputter.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/JDOMInfosetInputter.scala
index 0b6cf86fd1..0fe481f9fc 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/JDOMInfosetInputter.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/JDOMInfosetInputter.scala
@@ -55,7 +55,7 @@ class JDOMInfosetInputter(doc: Document)
    * Element.
    */
   private val stack = {
-    val s = new MStackOf[(Element,Iterator[Content])]
+    val s = new MStackOf[(Element, Iterator[Content])]
     val docChildren = doc.getContent.iterator
     if (!docChildren.hasNext) {
       throw new InvalidInfosetException("Document does not contain a root element")
@@ -67,6 +67,7 @@ class JDOMInfosetInputter(doc: Document)
   private var doStartEvent = true
 
   override def getEventType(): InfosetInputterEventType = {
+    import InfosetInputterEventType._
     if (stack.top._1 == null) {
       if (doStartEvent) StartDocument else EndDocument
     } else {
@@ -75,11 +76,11 @@ class JDOMInfosetInputter(doc: Document)
   }
 
   override def getLocalName(): String = stack.top._1.getName
-  
+
   override val supportsNamespaces = true
 
   override def getNamespaceURI(): String = stack.top._1.getNamespace.getURI
-  
+
   override def getSimpleText(primType: NodeInfo.Kind): String = {
     val text =
       if (stack.top._2.hasNext) {
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/JsonInfosetInputter.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/JsonInfosetInputter.scala
index cd10594105..0367c641d4 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/JsonInfosetInputter.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/JsonInfosetInputter.scala
@@ -84,6 +84,7 @@ class JsonInfosetInputter private (input: Either[java.io.Reader, java.io.InputSt
   }
 
   override def getEventType(): InfosetInputterEventType = {
+    import InfosetInputterEventType._
     if (fakeElementEndEvent) {
       EndElement
     } else {
@@ -168,8 +169,10 @@ class JsonInfosetInputter private (input: Either[java.io.Reader, java.io.InputSt
           case JsonToken.END_ARRAY => arrayNameStack.pop
 
           // start end of a complex type
-          case JsonToken.START_OBJECT => objectDepth += 1; exitNow = true
-          case JsonToken.END_OBJECT => objectDepth -= 1; exitNow = true
+          case JsonToken.START_OBJECT =>
+            objectDepth += 1; exitNow = true
+          case JsonToken.END_OBJECT =>
+            objectDepth -= 1; exitNow = true
 
           // start of a simple type or null
           case JsonToken.VALUE_STRING | JsonToken.VALUE_NULL => exitNow = true
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/NextElementResolver.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/NextElementResolver.scala
deleted file mode 100644
index e79ae9302e..0000000000
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/NextElementResolver.scala
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.daffodil.infoset
-
-import org.apache.daffodil.processors.ElementRuntimeData
-import org.apache.daffodil.processors.unparsers.UnparseError
-import org.apache.daffodil.util.Maybe._
-import org.apache.daffodil.xml.NS
-import org.apache.daffodil.xml.StepQName
-import org.apache.daffodil.xml.QNameBase
-import org.apache.daffodil.exceptions.Assert
-import org.apache.daffodil.exceptions.SchemaFileLocation
-import org.apache.daffodil.util.Maybe._
-import org.apache.daffodil.xml.NamedQName
-
-/**
- * The schema compiler computes this for each element.
- *
- * This is for use assembling the Daffodil Infoset from an InfosetInputter.
- * Note that not all InfosetInputter's have a concept of namespaces (json is a
- * prime example of this). In order to support this, each nextElement method
- * has a variable called hasNamespace, which is used to specify whether or not
- * the InfosetInputter supports namespaces. If it does not support namespaces,
- * then the namespace parameter should be ignored. This may affect how the next
- * element is determined, and may result in an UnparseError in some cases.
- */
-
-trait NextElementResolver extends Serializable {
-
-  def nextElement(name: String, nameSpace: String, hasNamespace: Boolean): ElementRuntimeData
-
-  // TODO: PERFORMANCE: We really should be interning all QNames so that comparison of QNames can be pointer equality
-  // or nearly so. We're going to do tons of lookups in hash tables, which will compute the hash code, find it is equal,
-  // compare the entire namespace string character by character, only to say yes, and yes will be by far the vast
-  // bulk of the lookup results.  Pointer equality would be so much faster....
-  //
-  def nextElement(nqn: NamedQName, hasNamespace: Boolean): ElementRuntimeData =
-    nextElement(nqn.local, if (hasNamespace) nqn.namespace.toStringOrNullIfNoNS else null, hasNamespace)
-    
-  def allPossibleNextElements: Seq[ElementRuntimeData]
-}
-
-sealed abstract class ResolverType(val name: String) extends Serializable
-case object SiblingResolver extends ResolverType("next")
-case object ChildResolver extends ResolverType("child")
-case object RootResolver extends ResolverType("root")
-
-class NoNextElement(schemaFileLocation: SchemaFileLocation, resolverType: ResolverType) extends NextElementResolver {
-
-  override def nextElement(local: String, namespace: String, hasNamespace: Boolean): ElementRuntimeData = {
-    val sqn = StepQName(None, local, NS(namespace))
-    UnparseError(One(schemaFileLocation), Nope, "Found %s element %s, but no element is expected.", resolverType.name, sqn)
-  }
-
-  override def toString() = "NoNextElement"
-  
-  override val allPossibleNextElements = Seq()
-
-}
-
-class OnlyOnePossibilityForNextElement(schemaFileLocation: SchemaFileLocation, val nextERD: ElementRuntimeData, resolverType: ResolverType)
-  extends NextElementResolver {
-
-  override def nextElement(local: String, namespace: String, hasNamespace: Boolean): ElementRuntimeData = {
-    val nqn = nextERD.namedQName
-    val matches =
-      if (hasNamespace) {
-        val sqn = StepQName(None, local, NS(namespace))
-        sqn.matches(nqn)
-      } else {
-        // namespace is ignored since the InfosetInputter does not support
-        // them. Since there is only one possible match, the local name only
-        // has to match the nextERD local name to be a match.
-        local == nextERD.namedQName.local
-      }
-
-    if (!matches) {
-      val sqn = StepQName(None, local, NS(namespace))
-      UnparseError(One(schemaFileLocation), Nope, "Found %s element %s, but expected %s.", resolverType.name,
-        sqn.toExtendedSyntax, nqn.toExtendedSyntax)
-    }
-
-    nextERD
-  }
-
-  override def toString() = "OnlyOne(" + nextERD.namedQName + ")"
-  
-  override lazy val allPossibleNextElements = Seq(nextERD)
-}
-
-/**
- * Schema compiler computes the map here, and then attaches this object to the
- * ERD of each element.
- */
-class SeveralPossibilitiesForNextElement(loc: SchemaFileLocation, nextERDMap: Map[QNameBase, ElementRuntimeData], resolverType: ResolverType, hasDuplicateLocalNames: Boolean)
-  extends NextElementResolver {
-  Assert.usage(nextERDMap.size > 1, "should be more than one mapping")
-
-  /**
-   * Annoying, but scala's immutable Map is not covariant in its first argument
-   * the way one would normally expect a collection to be.
-   *
-   * So Map[StepQName, ElementRuntimeData] is not a subtype of Map[QNameBase, ElementRuntimeData]
-   * which means when we construct a Map using the NamedQName of the elements,
-   * we can't use that with StepQNames as the query items. But QName comparisons
-   * are carefully strongly typed to prevent you from comparing the wrong kinds.
-   * For example, you can check if a StepQName matches a NamedQName, but you can't compare
-   * two NamedQNames together (because, generally, that would be a mistake.)
-   *
-   * So we need a cast upward to QNameBase
-   */
-  override def nextElement(local: String, namespace: String, hasNamespace: Boolean): ElementRuntimeData = {
-    val optNextERD =
-      if (hasNamespace) {
-        val sqn = StepQName(None, local, NS(namespace)) // these will match in a hash table of NamedQNames.
-        nextERDMap.get(sqn.asInstanceOf[QNameBase])
-      } else {
-        // The InfosetInputter does not support namespaces, so we must find an
-        // element in the nextERDMap with the same local name. The keys in the
-        // map are QNameBase's, so we must instead use a linear search to find
-        // the right key
-        if (!hasDuplicateLocalNames) {
-          // It was statically determined at compile time that this
-          // NextElementResolver does not have any possible NextERDs with the
-          // same local name. Because of this, just find the first thing that
-          // matches and return it it is was found.
-          nextERDMap.find(_._1.local == local).map(_._2)
-        } else {
-          // It was statically determined at compile time that some nextERDs
-          // have duplicate local names with differing namespaces. Since this
-          // InfosetInputter does not support namespaces, we might not be able
-          // to determine which is the right next ERD. So find all nextERDs
-          // with a matching local name, and error if we found more than one.
-          // If we only found one we found it. If we didn't find any, there was
-          // no match.
-          val localMatches = nextERDMap.filterKeys(_.local == local)
-          if (localMatches.size > 1) {
-            val sqn = StepQName(None, local, NS(namespace))
-            val keys = localMatches.keys.toSeq
-            UnparseError(One(loc), Nope, "Found multiple matches for %s element %s because infoset implementation ignores namespaces. Matches are %s",
-              resolverType.name, sqn.toExtendedSyntax, keys.mkString(", "))
-          }
-          localMatches.headOption.map(_._2)
-        }
-      }
-
-    val res = optNextERD.getOrElse {
-      val keys = nextERDMap.keys.toSeq
-      val sqn = StepQName(None, local, NS(namespace))
-      UnparseError(One(loc), Nope, "Found %s element %s, but expected one of %s.",
-        resolverType.name, sqn.toExtendedSyntax, keys.mkString(", "))
-    }
-    res
-  }
-
-  override def toString() = "Several(" + nextERDMap.keySet.mkString(", ") + ")"
-  
-  override lazy val allPossibleNextElements = nextERDMap.values.toSeq
-}
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/PartialNextElementResolver.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/PartialNextElementResolver.scala
new file mode 100644
index 0000000000..f7c51ce315
--- /dev/null
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/PartialNextElementResolver.scala
@@ -0,0 +1,323 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.daffodil.infoset
+
+import org.apache.daffodil.processors.ElementRuntimeData
+import org.apache.daffodil.processors.unparsers.UnparseError
+import org.apache.daffodil.util.Maybe
+import org.apache.daffodil.util.Maybe._
+import org.apache.daffodil.xml.NS
+import org.apache.daffodil.xml.StepQName
+import org.apache.daffodil.xml.QNameBase
+import org.apache.daffodil.exceptions.Assert
+import org.apache.daffodil.exceptions.SchemaFileLocation
+import org.apache.daffodil.xml.NamedQName
+import org.apache.daffodil.processors.ElementRuntimeData
+import org.apache.daffodil.util.MStackOf
+import org.apache.daffodil.processors.TermRuntimeData
+import org.apache.daffodil.util.ResettableIterator
+import scala.language.implicitConversions
+import org.apache.daffodil.processors.UnexpectedElementErrorERD
+import org.apache.daffodil.processors.NamespaceAmbiguousElementErrorERD
+import org.apache.daffodil.processors.ErrorERD
+
+/**
+ * Mixin for InfosetInputter
+ */
+trait NextElementResolver { self: InfosetInputter =>
+
+  /**
+   * Resolves the next element, or fails with an Unparse Error if there is
+   * no mapping.
+   */
+  final def nextElement(name: String, nameSpace: String, hasNamespace: Boolean): ElementRuntimeData = {
+    val iter = trdStack.iter
+    iter.reset()
+    var firstOne: Boolean = true
+    var maybeERD: Maybe[ElementRuntimeData] = Nope
+    var breakOut: Boolean = false
+
+    while (iter.hasNext && maybeERD.isEmpty && !breakOut) {
+      val trd = iter.next
+      trd match {
+        case complexElementERD: ElementRuntimeData if (complexElementERD.isComplexType) && !firstOne => {
+          //
+          // We iterated down to a complex type.
+          // That means we can't be expecting another child element
+          // as we're expecting an end-of element event instead
+          //
+          maybeERD = error(iter, name, nameSpace, Some(complexElementERD))
+          breakOut = true
+        }
+        case _ => // ok. Term is not a ERD for a complex type. Carry on.
+      }
+      if (!breakOut) {
+        firstOne = false
+        val resolver = trd.partialNextElementResolver
+        //
+        // This resolver will either resolve, pass on resolving (return Nope),
+        // in which case we go around the loop and move down the stack,
+        // or it will issue an UnparseError if there are required elements in the
+        // set of possible elements.
+        //
+        maybeERD = resolver.maybeNextElement(name, nameSpace, hasNamespace)
+        //
+        // If the ERD is marked hidden, then we never expect any events corresponding
+        // to its elements.
+        //
+        if (maybeERD.isDefined && maybeERD.get.isHidden)
+          maybeERD = Nope // clobber it back to Nope
+      }
+    } // end while
+    //
+    // We exited the loop, meaning either we have an ERD that is the resolution
+    // or the stack of TRDs is empty.
+    //
+    // The latter is a boundary case that comes up
+    // only in unit tests where we use a root element that is a simple type.
+    // In that case, the loop above won't run into an ERD for a complex type element
+    // and fail due to that, so we have to fail here.
+    //
+    if (maybeERD.isEmpty) {
+      error(iter, name, nameSpace, None).get
+    } else {
+      maybeERD.get
+    }
+  }
+
+  private val trdStack = new MStackOf[TermRuntimeData]
+
+  final def pushTRD(trd: TermRuntimeData): Unit = {
+    trdStack.push(trd)
+  }
+
+  final def maybeTopTRD(): Maybe[TermRuntimeData] = {
+    if (!trdStack.isEmpty) One(trdStack.top)
+    else Nope
+  }
+
+  final def popTRD(): TermRuntimeData = {
+    val res = trdStack.pop
+    res
+  }
+
+  private def error(
+    iter: ResettableIterator[TermRuntimeData],
+    name: String,
+    namespace: String,
+    optTRD: Option[TermRuntimeData]): Maybe[ElementRuntimeData] = {
+    val allTRDs = {
+      iter.reset()
+      iter.toStream.takeWhile {
+        stackTRD => optTRD.map { _ ne stackTRD }.getOrElse(true)
+      }
+    }
+    //
+    // Gather up all possible elements it could be from
+    // all stack entries up to, not including this one.
+    //
+    // We only get here if all the TRDs on stack had nextElementResolvers
+    // which passed (returning Nope) to indicate that the elements they
+    // had as possibilities are all optional.
+    //
+    // If we get here, we're at the end of a complex element, and we
+    // only get here when the current incoming event was a start element
+    //
+    // So we have a candidate start element, but it wasn't a match anything
+    // possible, and we're expecting an end element for the complex type
+    // at this point.
+    //
+    val allPossibles =
+      allTRDs.flatMap {
+        _.partialNextElementResolver.currentPossibleNamedQNames
+      }
+    One(new UnexpectedElementErrorERD(optTRD, name, namespace, allPossibles))
+  }
+}
+
+/**
+ * The schema compiler computes this for each Term in a Sequence.
+ *
+ * This is for use assembling the Daffodil Infoset from an InfosetInputter.
+ * Note that not all InfosetInputter's have a concept of namespaces (json is a
+ * prime example of this). In order to support this, each nextElement method
+ * has a variable called hasNamespace, which is used to specify whether or not
+ * the InfosetInputter supports namespaces. If it does not support namespaces,
+ * then the namespace parameter should be ignored. This may affect how the next
+ * element is determined, and may result in an UnparseError in some cases.
+ */
+sealed trait PartialNextElementResolver extends Serializable {
+
+  /**
+   * Returns One(ElementRuntimeData) if the arguments are associated with
+   * such definition.
+   *
+   * Returns Nope if there is no such mapping.
+   */
+  def maybeNextElement(name: String, nameSpace: String, hasNamespace: Boolean): Maybe[ElementRuntimeData]
+
+  // TODO: PERFORMANCE: We really should be interning all QNames so that comparison of QNames can be pointer equality
+  // or nearly so. We're going to do tons of lookups in hash tables, which will compute the hash code, find it is equal,
+  // compare the entire namespace string character by character, only to say yes, and yes will be by far the vast
+  // bulk of the lookup results.  Pointer equality would be so much faster....
+  //
+  def maybeNextElement(nqn: NamedQName, hasNamespace: Boolean): Maybe[ElementRuntimeData] =
+    maybeNextElement(nqn.local, if (hasNamespace) nqn.namespace.toStringOrNullIfNoNS else null, hasNamespace)
+
+  def currentPossibleNextElements: Seq[ElementRuntimeData]
+
+  final def currentPossibleNamedQNames = currentPossibleNextElements.map { _.namedQName }
+}
+
+/**
+ * This resolver exists to allow the ERD of a quasi-element to have a resolver, but
+ * it should never actually be used, so this just fails if it is.
+ */
+class DoNotUseThisResolver(trd: TermRuntimeData) extends PartialNextElementResolver {
+
+  override def maybeNextElement(local: String, namespace: String, hasNamespace: Boolean): Maybe[ElementRuntimeData] =
+    Assert.invariantFailed("This resolver should never be used.")
+
+  override def toString() = "DoNotUseThisResolver"
+
+  override val currentPossibleNextElements = Seq()
+}
+
+class NoNextElement(
+  trd: TermRuntimeData,
+  isRequiredStreamingUnparserEvent: Boolean)
+  extends PartialNextElementResolver {
+
+  override def maybeNextElement(local: String, namespace: String, hasNamespace: Boolean): Maybe[ElementRuntimeData] = {
+    if (isRequiredStreamingUnparserEvent)
+      One(new UnexpectedElementErrorERD(Some(trd), local, namespace, currentPossibleNamedQNames))
+    else
+      Nope
+  }
+
+  override def toString() = "NoNextElement"
+
+  override val currentPossibleNextElements = Seq()
+
+}
+
+class OnlyOnePossibilityForNextElement(
+  trd: TermRuntimeData,
+  val nextERD: ElementRuntimeData,
+  isRequiredStreamingUnparserEvent: Boolean)
+  extends PartialNextElementResolver {
+
+  val nqn = nextERD.namedQName
+
+  override def maybeNextElement(local: String, namespace: String, hasNamespace: Boolean): Maybe[ElementRuntimeData] = {
+    val matches =
+      if (hasNamespace) {
+        val sqn = StepQName(None, local, NS(namespace))
+        sqn.matches(nqn)
+      } else {
+        // namespace is ignored since the InfosetInputter does not support
+        // them. Since there is only one possible match, the local name only
+        // has to match the nextERD local name to be a match.
+        local == nqn.local
+      }
+
+    if (!matches) {
+      if (isRequiredStreamingUnparserEvent) {
+        One(new UnexpectedElementErrorERD(Some(trd), local, namespace, currentPossibleNamedQNames))
+      } else {
+        Nope
+      }
+    } else {
+      Maybe(nextERD)
+    }
+  }
+
+  override def toString() = "OnlyOne(" + nqn + ")"
+
+  override lazy val currentPossibleNextElements = Seq(nextERD)
+}
+
+class SeveralPossibilitiesForNextElement(
+  trd: TermRuntimeData,
+  nextERDMap: Map[QNameBase, ElementRuntimeData],
+  hasDuplicateLocalNames: Boolean,
+  isRequiredStreamingUnparserEvent: Boolean)
+  extends PartialNextElementResolver {
+  Assert.usage(nextERDMap.size > 1, "should be more than one mapping")
+
+  /**
+   * Annoying, but scala's immutable Map is not covariant in its first argument
+   * the way one would normally expect a collection to be.
+   *
+   * So Map[StepQName, ElementRuntimeData] is not a subtype of Map[QNameBase, ElementRuntimeData]
+   * which means when we construct a Map using the NamedQName of the elements,
+   * we can't use that with StepQNames as the query items. But QName comparisons
+   * are carefully strongly typed to prevent you from comparing the wrong kinds.
+   * For example, you can check if a StepQName matches a NamedQName, but you can't compare
+   * two NamedQNames together (because, generally, that would be a mistake.)
+   *
+   * So we need a cast upward to QNameBase
+   */
+  override def maybeNextElement(local: String, namespace: String, hasNamespace: Boolean): Maybe[ElementRuntimeData] = {
+    val optnextERD =
+      if (hasNamespace) {
+        val sqn = StepQName(None, local, NS(namespace)) // these will match in a hash table of NamedQNames.
+        nextERDMap.get(sqn.asInstanceOf[QNameBase])
+      } else {
+        // The InfosetInputter does not support namespaces, so we must find an
+        // element in the nextERDMap with the same local name. The keys in the
+        // map are QNameBase's, so we must instead use a linear search to find
+        // the right key
+        if (!hasDuplicateLocalNames) {
+          // It was statically determined at compile time that this
+          // NextElementResolver does not have any possible NextERDs with the
+          // same local name. Because of this, just find the first thing that
+          // matches and return it it is was found.
+          nextERDMap.find(_._1.local == local).map(_._2)
+        } else {
+          // It was statically determined at compile time that some nextERDs
+          // have duplicate local names with differing namespaces. Since this
+          // InfosetInputter does not support namespaces, we might not be able
+          // to determine which is the right next ERD. So find all nextERDs
+          // with a matching local name, and error if we found more than one.
+          // If we only found one we found it. If we didn't find any, there was
+          // no match.
+          val localMatches = nextERDMap.filterKeys(_.local == local)
+          if (localMatches.size > 1) {
+            val sqn = StepQName(None, local, NS(namespace))
+            val keys = localMatches.keys.toSeq
+            val errERD = new NamespaceAmbiguousElementErrorERD(Some(trd), local, namespace, keys)
+            errERD.toUnparseError(false)
+          } else {
+            localMatches.headOption.map(_._2)
+          }
+        }
+      }
+
+    val res = optnextERD
+    if (isRequiredStreamingUnparserEvent && res.isEmpty) {
+      One(new UnexpectedElementErrorERD(Some(trd), local, namespace, currentPossibleNamedQNames))
+    } else {
+      toMaybe(res)
+    }
+  }
+
+  override def toString() = "Several(" + nextERDMap.keySet.mkString(", ") + ")"
+
+  override lazy val currentPossibleNextElements = nextERDMap.values.toSeq
+}
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/ScalaXMLInfosetInputter.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/ScalaXMLInfosetInputter.scala
index a6dded6174..26cc17aac4 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/ScalaXMLInfosetInputter.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/ScalaXMLInfosetInputter.scala
@@ -60,6 +60,7 @@ class ScalaXMLInfosetInputter(rootNode: Node)
   private var doStartEvent = true
 
   override def getEventType(): InfosetInputterEventType = {
+    import InfosetInputterEventType._
     if (stack.top._1 == null) {
       if (doStartEvent) StartDocument else EndDocument
     } else {
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/W3CDOMInfosetInputter.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/W3CDOMInfosetInputter.scala
index f99d842d53..fbeb76c531 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/W3CDOMInfosetInputter.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/W3CDOMInfosetInputter.scala
@@ -50,7 +50,7 @@ class W3CDOMInfosetInputter(doc: Document)
    * Element.
    */
   private val stack = {
-    val s = new MStackOf[(Element,Iterator[Node])]
+    val s = new MStackOf[(Element, Iterator[Node])]
     val iterator = new IterableNodeList(doc.getChildNodes)
     if (!iterator.hasNext) {
       throw new InvalidInfosetException("Document does not contain a root element")
@@ -62,6 +62,7 @@ class W3CDOMInfosetInputter(doc: Document)
   private var doStartEvent = true
 
   override def getEventType(): InfosetInputterEventType = {
+    import InfosetInputterEventType._
     if (stack.top._1 == null) {
       if (doStartEvent) StartDocument else EndDocument
     } else {
@@ -78,11 +79,11 @@ class W3CDOMInfosetInputter(doc: Document)
       stack.top._1.getLocalName
     }
   }
-  
+
   override val supportsNamespaces = true
 
   override def getNamespaceURI(): String = stack.top._1.getNamespaceURI
-  
+
   override def getSimpleText(primType: NodeInfo.Kind): String = {
     val text =
       if (stack.top._2.hasNext) {
@@ -190,7 +191,7 @@ class W3CDOMInfosetInputter(doc: Document)
 
 }
 
-class IterableNodeList (n: NodeList) extends Iterator[Node] {
+class IterableNodeList(n: NodeList) extends Iterator[Node] {
 
   private var index = 0
 
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/XMLTextInfosetInputter.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/XMLTextInfosetInputter.scala
index 24c2ea332e..3f66f2ad05 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/XMLTextInfosetInputter.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/infoset/XMLTextInfosetInputter.scala
@@ -91,6 +91,7 @@ class XMLTextInfosetInputter private (input: Either[java.io.Reader, java.io.Inpu
   private var fakeStartEvent = false
 
   override def getEventType(): InfosetInputterEventType = {
+    import InfosetInputterEventType._
     if (fakeStartEvent) {
       StartElement
     } else {
@@ -104,7 +105,7 @@ class XMLTextInfosetInputter private (input: Either[java.io.Reader, java.io.Inpu
   }
 
   override def getLocalName: String = {
-    xsr.getLocalName()  
+    xsr.getLocalName()
   }
 
   override val supportsNamespaces = true
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/DataProcessor.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/DataProcessor.scala
index be01e392bb..759baff8b3 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/DataProcessor.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/DataProcessor.scala
@@ -300,7 +300,12 @@ class DataProcessor(val ssrd: SchemaSetRuntimeData)
   def unparse(inputter: InfosetInputter, output: DFDL.Output): DFDL.UnparseResult = {
     Assert.usage(!this.isError)
     val outStream = java.nio.channels.Channels.newOutputStream(output)
+    unparse(inputter, outStream)
+  }
+
+  def unparse(inputter: InfosetInputter, outStream: java.io.OutputStream) = {
     val out = DirectOrBufferedDataOutputStream(outStream, null) // null means no other stream created this one.
+    inputter.initialize(ssrd.elementRuntimeData, getTunables())
     val unparserState =
       UState.createInitialUState(
         out,
@@ -312,7 +317,6 @@ class DataProcessor(val ssrd: SchemaSetRuntimeData)
         addEventHandler(debugger)
         unparserState.notifyDebugging(true)
       }
-      inputter.initialize(ssrd.elementRuntimeData, unparserState.tunable)
       unparserState.dataProc.get.init(ssrd.unparser)
       out.setPriorBitOrder(ssrd.elementRuntimeData.defaultBitOrder)
       doUnparse(unparserState)
@@ -366,8 +370,15 @@ class DataProcessor(val ssrd: SchemaSetRuntimeData)
 
   private def doUnparse(state: UState): Unit = {
     val rootUnparser = ssrd.unparser
-    // LoggingDefaults.setLoggingLevel(LogLevel.Debug)
+
+    Assert.invariant {
+      // rootERD is pushed when the state is constructed and initialized.
+      val mtrd = state.maybeTopTRD()
+      mtrd.isDefined &&
+        (mtrd.get eq rootUnparser.context)
+    }
     rootUnparser.unparse1(state)
+    state.popTRD(rootUnparser.context.asInstanceOf[TermRuntimeData])
 
     // Restore invariant that there is always a processor.
     // Later when suspensions get evaluated, there are still times when
@@ -380,12 +391,14 @@ class DataProcessor(val ssrd: SchemaSetRuntimeData)
     //
     state.setProcessor(rootUnparser)
 
-    /* Verify that all stacks are empty */
+    // Verify that all stacks are empty
     Assert.invariant(state.arrayIndexStack.length == 1)
     Assert.invariant(state.groupIndexStack.length == 1)
     Assert.invariant(state.childIndexStack.length == 1)
     Assert.invariant(state.currentInfosetNodeMaybe.isEmpty)
     Assert.invariant(state.escapeSchemeEVCache.isEmpty)
+    Assert.invariant(state.maybeTopTRD().isEmpty) // dynamic TRD stack is empty
+
     //
     // All the DOS that precede the last one
     // will get setFinished by the suspension that created them. The last one after the
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/RuntimeData.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/RuntimeData.scala
index 90cb6b5ba0..1b03abbd09 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/RuntimeData.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/RuntimeData.scala
@@ -45,7 +45,7 @@ import org.apache.daffodil.dsom.CompiledExpression
 import org.apache.daffodil.schema.annotation.props.gen.Representation
 import org.apache.daffodil.exceptions.SchemaFileLocation
 import org.apache.daffodil.dpath.NodeInfo.PrimType
-import org.apache.daffodil.infoset.NextElementResolver
+import org.apache.daffodil.infoset.PartialNextElementResolver
 import org.apache.daffodil.util.TransientParam
 import org.apache.daffodil.schema.annotation.props.gen.YesNo
 import org.apache.daffodil.exceptions._
@@ -56,6 +56,9 @@ import org.apache.daffodil.util.OKOrError
 import java.util.regex.Matcher
 import org.apache.daffodil.api.DaffodilTunables
 import org.apache.daffodil.schema.annotation.props.gen.OccursCountKind
+import org.apache.daffodil.xml.NamedQName
+import org.apache.daffodil.processors.unparsers.UnparseError
+import org.apache.daffodil.util.Misc
 
 /*
  * NOTE: Any time you add a member to one of these objects, you must modify at least 3 places.
@@ -102,6 +105,8 @@ sealed abstract class TermRuntimeData(
    * hook these objects into a parent-child tree without
    * having to use an assignment to a var.
    */
+  @TransientParam positionArg: => Int,
+  @TransientParam partialNextElementResolverArg: => PartialNextElementResolver,
   @TransientParam encodingInfoArg: => EncodingRuntimeData,
   @TransientParam dpathCompileInfoArg: => DPathCompileInfo,
   @TransientParam isRepresentedArg: => Boolean,
@@ -144,6 +149,8 @@ sealed abstract class TermRuntimeData(
    */
   def tunable = dpathCompileInfo.tunable
 
+  lazy val position = positionArg
+  lazy val partialNextElementResolver = partialNextElementResolverArg
   lazy val encodingInfo = encodingInfoArg
   lazy val dpathCompileInfo = dpathCompileInfoArg
   lazy val isRepresented = isRepresentedArg
@@ -158,6 +165,8 @@ sealed abstract class TermRuntimeData(
 
   override def preSerialization: Unit = {
     super.preSerialization
+    position
+    partialNextElementResolver
     encodingInfo
     dpathCompileInfo
     isRepresented
@@ -240,10 +249,10 @@ final class SimpleTypeRuntimeData(
   @TransientParam tunableArg: => DaffodilTunables,
   @TransientParam repTypeRuntimeDataArg: => Option[SimpleTypeRuntimeData],
   @TransientParam repValueSetArg: => Option[RepValueSet[AnyRef]],
-  @TransientParam typeCalculatorArg: => Option[TypeCalculator[AnyRef,AnyRef]],
-  @TransientParam optRepPrimTypeArg: => Option[PrimType]
-) extends NonTermRuntimeData(variableMapArg, schemaFileLocationArg, diagnosticDebugNameArg,
-  pathArg, namespacesArg, tunableArg) {
+  @TransientParam typeCalculatorArg: => Option[TypeCalculator[AnyRef, AnyRef]],
+  @TransientParam optRepPrimTypeArg: => Option[PrimType])
+  extends NonTermRuntimeData(variableMapArg, schemaFileLocationArg, diagnosticDebugNameArg,
+    pathArg, namespacesArg, tunableArg) {
 
   import OKOrError._
 
@@ -596,7 +605,7 @@ final class SimpleTypeRuntimeData(
  * providing diagnostics.
  */
 
-final class ElementRuntimeData(
+sealed class ElementRuntimeData(
   /**
    * These transient by-name args are part of how we hook these objects into a
    * parent-child tree without having to use an assignment to a var. Note that
@@ -606,8 +615,7 @@ final class ElementRuntimeData(
   @TransientParam positionArg: => Int,
   @TransientParam childrenArg: => Seq[ElementRuntimeData],
   @TransientParam variableMapArg: => VariableMap,
-  @TransientParam nextElementResolverArg: => NextElementResolver,
-  @TransientParam childElementResolverArg: => NextElementResolver,
+  @TransientParam partialNextElementResolverArg: => PartialNextElementResolver,
   @TransientParam encInfoArg: => EncodingRuntimeData,
   @TransientParam dpathElementCompileInfoArg: => DPathElementCompileInfo,
   @TransientParam schemaFileLocationArg: => SchemaFileLocation,
@@ -620,6 +628,7 @@ final class ElementRuntimeData(
   @TransientParam targetNamespaceArg: => NS,
   @TransientParam thisElementsNamespaceArg: => NS,
   @TransientParam optSimpleTypeRuntimeDataArg: => Option[SimpleTypeRuntimeData],
+  @TransientParam optComplexTypeModelGroupRuntimeDataArg: => Option[ModelGroupRuntimeData],
   @TransientParam minOccursArg: => Long,
   @TransientParam maxOccursArg: => Long,
   @TransientParam maybeOccursCountKindArg: => Maybe[OccursCountKind],
@@ -630,7 +639,7 @@ final class ElementRuntimeData(
   @TransientParam isNillableArg: => Boolean,
   @TransientParam isArrayArg: => Boolean, // can have more than 1 occurrence
   @TransientParam isOptionalArg: => Boolean, // can have only 0 or 1 occurrence
-  @TransientParam isRequiredOrOptionalArg: => Boolean, // must have at least 1 occurrence
+  @TransientParam isRequiredInUnparseInfosetArg: => Boolean, // must have at least 1 occurrence
   /**
    * This is the properly qualified name for recognizing this
    * element.
@@ -658,18 +667,16 @@ final class ElementRuntimeData(
   @TransientParam maybeCheckByteAndBitOrderEvArg: => Maybe[CheckByteAndBitOrderEv],
   @TransientParam maybeCheckBitOrderAndCharsetEvArg: => Maybe[CheckBitOrderAndCharsetEv],
   @TransientParam isQuasiElementArg: => Boolean)
-  extends TermRuntimeData(encInfoArg, dpathElementCompileInfoArg, isRepresentedArg, couldHaveTextArg, alignmentValueInBitsArg, hasNoSkipRegionsArg,
+  extends TermRuntimeData(positionArg, partialNextElementResolverArg,
+    encInfoArg, dpathElementCompileInfoArg, isRepresentedArg, couldHaveTextArg, alignmentValueInBitsArg, hasNoSkipRegionsArg,
     defaultBitOrderArg, optIgnoreCaseArg, maybeFillByteEvArg,
     maybeCheckByteAndBitOrderEvArg,
     maybeCheckBitOrderAndCharsetEvArg) {
 
-  override def isRequiredScalar = !isArray && isRequiredOrOptional
+  override def isRequiredScalar = !isArray && isRequiredInUnparseInfoset
 
-  lazy val position = positionArg
   lazy val children = childrenArg
   lazy val variableMap = variableMapArg
-  lazy val nextElementResolver = nextElementResolverArg
-  lazy val childElementResolver = childElementResolverArg
   lazy val encInfo = encInfoArg
   lazy val dpathElementCompileInfo = dpathElementCompileInfoArg
   lazy val schemaFileLocation = schemaFileLocationArg
@@ -681,6 +688,7 @@ final class ElementRuntimeData(
   lazy val targetNamespace = targetNamespaceArg
   lazy val thisElementsNamespace = thisElementsNamespaceArg
   lazy val optSimpleTypeRuntimeData = optSimpleTypeRuntimeDataArg
+  lazy val optComplexTypeModelGroupRuntimeData = optComplexTypeModelGroupRuntimeDataArg
   lazy val minOccurs = minOccursArg
   lazy val maxOccurs = maxOccursArg
   lazy val maybeOccursCountKind = maybeOccursCountKindArg
@@ -691,7 +699,7 @@ final class ElementRuntimeData(
   lazy val isNillable = isNillableArg
   override lazy val isArray = isArrayArg
   lazy val isOptional = isOptionalArg
-  lazy val isRequiredOrOptional = isRequiredOrOptionalArg // if true, no uncertainty about number of occurrences.
+  lazy val isRequiredInUnparseInfoset = isRequiredInUnparseInfosetArg // if true, no uncertainty about number of occurrences.
   lazy val namedQName = namedQNameArg
   lazy val impliedRepresentation = impliedRepresentationArg
   lazy val optDefaultValue = optDefaultValueArg
@@ -703,11 +711,8 @@ final class ElementRuntimeData(
 
   override def preSerialization: Unit = {
     super.preSerialization
-    position
     children
     variableMap
-    nextElementResolver
-    childElementResolver
     encInfo
     dpathElementCompileInfo
     schemaFileLocation
@@ -719,6 +724,7 @@ final class ElementRuntimeData(
     targetNamespace
     thisElementsNamespace
     optSimpleTypeRuntimeData
+    optComplexTypeModelGroupRuntimeData
     minOccurs
     maxOccurs
     maybeOccursCountKind
@@ -729,7 +735,7 @@ final class ElementRuntimeData(
     isNillable
     isArray
     isOptional
-    isRequiredOrOptional
+    isRequiredInUnparseInfoset
     namedQName
     impliedRepresentation
     optDefaultValue
@@ -741,7 +747,7 @@ final class ElementRuntimeData(
   }
 
   @throws(classOf[java.io.IOException])
-  final private def writeObject(out: java.io.ObjectOutputStream): Unit = serializeObject(out)
+  private def writeObject(out: java.io.ObjectOutputStream): Unit = serializeObject(out)
 
   final def childERDs = children
 
@@ -763,12 +769,148 @@ final class ElementRuntimeData(
 
 }
 
+/**
+ * Used when unparsing to indicate that an expected ERD could not be created.
+ *
+ * Subclasses of this are for specific reasons why.
+ *
+ * The purposes of this is to allow the InfosetInputter to actually construct an
+ * infoset event including a full infoset DIElement node, yet indicating that the
+ * event is invalid.
+ *
+ * This enables improved diagnostic behavior. For example, a StartElement event
+ * can be created for a name and namespace where that name + namespace are not
+ * expected, the resulting infoset event will contain a DIElement having an
+ * ErrorERD. The unparser can then inspect the infoset event, and
+ * if it is expecting an EndElement event, it can issue a UnparseError that
+ * correctly identifies that an expected EndElement event was not received.
+ *
+ * In all cases, there is no recovering from these errors in the Unparser; hence,
+ * we don't really care if these bogus DIElement nodes having these Error ERDs are
+ * spliced into the infoset or not.
+ */
+sealed abstract class ErrorERD(local: String, namespaceURI: String)
+  extends ElementRuntimeData(
+    0, // position
+    Nil, // children
+    null, // VariableMap
+    null, // PartialNextElementResolver
+    null, // EncodingRuntimeData
+    new DPathElementCompileInfo(
+      Nil, // parentsArg: => Seq[DPathElementCompileInfo],
+      null, // variableMap: => VariableMap,
+      Nil, // elementChildrenCompileInfoArg: => Seq[DPathElementCompileInfo],
+      null, // namespaces: scala.xml.NamespaceBinding,
+      local, // path: String,
+      local, // val name: String,
+      false, // val isArray: Boolean,
+      LocalDeclQName(None, local, NS(namespaceURI)), // val namedQName: NamedQName,
+      None, // val optPrimType: Option[PrimType],
+      null, // sfl: SchemaFileLocation,
+      null, // override val tunable: DaffodilTunables,
+      null, // typeCalcMap: TypeCalcMap,
+      null, // lexicalContextRuntimeData: RuntimeData,
+      null), // val sscd: String),
+    null, // SchemaFileLocation
+    local, // diagnosticDebugName: String,
+    local, // pathArg: => String,
+    null, //  namespacesArg: => NamespaceBinding,
+    null, // minimizedScopeArg: => NamespaceBinding,
+    null, //defaultBitOrderArg: => BitOrder,
+    None, // optPrimTypeArg: => Option[PrimType],
+    null, // targetNamespaceArg: => NS,
+    NS(namespaceURI), // thisElementsNamespaceArg: => NS,
+    null, // optSimpleTypeRuntimeDataArg: => Option[SimpleTypeRuntimeData],
+    null, // optComplexTypeModelGroupRuntimeDataArg: => Option[ModelGroupRuntimeData],
+    0L, // minOccursArg: => Long,
+    0L, // maxOccursArg: => Long,
+    Nope, // maybeOccursCountKindArg: => Maybe[OccursCountKind],
+    local, // nameArg: => String,
+    null, // targetNamespacePrefixArg: => String,
+    null, // thisElementsNamespacePrefixArg: => String,
+    false, // isHiddenArg: => Boolean,
+    false, // isNillableArg: => Boolean,
+    false, // isArrayArg: => Boolean, // can have more than 1 occurrence
+    false, // isOptionalArg: => Boolean, // can have only 0 or 1 occurrence
+    false, // isRequiredInUnparseInfosetArg: => Boolean, // must have at least 1 occurrence
+    LocalDeclQName(None, local, NS(namespaceURI)), // namedQNameArg: => NamedQName,
+    false, // isRepresentedArg: => Boolean,
+    false, // couldHaveTextArg: => Boolean,
+    0, // alignmentValueInBitsArg: => Int,
+    false, // hasNoSkipRegionsArg: => Boolean,
+    null, // impliedRepresentationArg: => Representation,
+    null, // optIgnoreCaseArg: => Option[YesNo],
+    null, // optDefaultValueArg: => Option[AnyRef],
+    null, // optTruncateSpecifiedLengthStringArg: => Option[Boolean],
+    null, // outputValueCalcExprArg: => Option[CompiledExpression[AnyRef]],
+    Nope, // maybeBinaryFloatRepEvArg: => Maybe[BinaryFloatRepEv],
+    Nope, // maybeByteOrderEvArg: => Maybe[ByteOrderEv],
+    Nope, // maybeFillByteEvArg: => Maybe[FillByteEv],
+    Nope, // maybeCheckByteAndBitOrderEvArg: => Maybe[CheckByteAndBitOrderEv],
+    Nope, // maybeCheckBitOrderAndCharsetEvArg: => Maybe[CheckBitOrderAndCharsetEv],
+    false // isQuasiElementArg: => Boolean
+  ) {
+
+  override def toString() = Misc.getNameFromClass(this) + "(" + this.namedQName.toExtendedSyntax + ")"
+
+  @throws(classOf[java.io.IOException])
+  private def writeObject(out: java.io.ObjectOutputStream): Unit =
+    Assert.usageError("Not for serialization")
+}
+
+/**
+ * Used when unparsing to indicate that a next element event was detected that is
+ * unexpected.
+ */
+final class UnexpectedElementErrorERD(
+  optTRD: Option[TermRuntimeData],
+  local: String,
+  namespaceURI: String,
+  val allPossibleNQNs: Seq[QNameBase])
+  extends ErrorERD(local, namespaceURI) {
+}
+
+/**
+ * Used when unparsing to indicate that multiple elements could be next that
+ * differ only by namespace. This means for some event sources (like JSON) we
+ * don't know which element to create.
+ */
+final class NamespaceAmbiguousElementErrorERD(
+  optTRD: Option[TermRuntimeData],
+  local: String,
+  namespaceURI: String,
+  val allPossibleNQNs: Seq[QNameBase])
+  extends ErrorERD(local, namespaceURI) {
+
+  /**
+   * Causes unparse error with diagnostic about unexpected element.
+   *
+   * Pass argument true if the context is one where no element was expected
+   * (e.g., because an EndElement was expected.)
+   *
+   * Pass false if the Term's ordinary nextElementResolver list of possibilities
+   * is what was expected.
+   */
+  def toUnparseError(nothingWasExpected: Boolean = false) = {
+    val sqn = StepQName(None, name, thisElementsNamespace)
+    val sqnx = sqn.toExtendedSyntax
+    val allPossiblesString =
+      allPossibleNQNs.map { _.toExtendedSyntax }.mkString(", ")
+    val maybeLoc: Maybe[SchemaFileLocation] = Maybe.toMaybe(optTRD.map { _.schemaFileLocation })
+    UnparseError(maybeLoc, Nope,
+      "Found multiple matches for element %s because infoset implementation ignores namespaces. Matches are %s",
+      sqnx, allPossiblesString)
+  }
+}
+
 sealed abstract class ModelGroupRuntimeData(
   /**
    * These transient by-name args are part of how we
    * hook these objects into a parent-child tree without
    * having to use an assignment to a var.
    */
+  @TransientParam positionArg: => Int,
+  @TransientParam partialNextElementResolverArg: => PartialNextElementResolver,
   @TransientParam variableMapArg: => VariableMap,
   @TransientParam encInfoArg: => EncodingRuntimeData,
   @TransientParam schemaFileLocationArg: => SchemaFileLocation,
@@ -787,6 +929,7 @@ sealed abstract class ModelGroupRuntimeData(
   @TransientParam maybeCheckByteAndBitOrderEvArg: => Maybe[CheckByteAndBitOrderEv],
   @TransientParam maybeCheckBitOrderAndCharsetEvArg: => Maybe[CheckBitOrderAndCharsetEv])
   extends TermRuntimeData(
+    positionArg, partialNextElementResolverArg,
     encInfoArg, ciArg, isRepresentedArg, couldHaveTextArg, alignmentValueInBitsArg, hasNoSkipRegionsArg,
     defaultBitOrderArg, optIgnoreCaseArg, maybeFillByteEvArg,
     maybeCheckByteAndBitOrderEvArg,
@@ -825,6 +968,8 @@ final class SequenceRuntimeData(
    * hook these objects into a parent-child tree without
    * having to use an assignment to a var.
    */
+  @TransientParam positionArg: => Int,
+  @TransientParam partialNextElementResolverArg: => PartialNextElementResolver,
   @TransientParam variableMapArg: => VariableMap,
   @TransientParam encInfoArg: => EncodingRuntimeData,
   @TransientParam schemaFileLocationArg: => SchemaFileLocation,
@@ -842,7 +987,8 @@ final class SequenceRuntimeData(
   @TransientParam maybeFillByteEvArg: => Maybe[FillByteEv],
   @TransientParam maybeCheckByteAndBitOrderEvArg: => Maybe[CheckByteAndBitOrderEv],
   @TransientParam maybeCheckBitOrderAndCharsetEvArg: => Maybe[CheckBitOrderAndCharsetEv])
-  extends ModelGroupRuntimeData(variableMapArg, encInfoArg, schemaFileLocationArg, ciArg, diagnosticDebugNameArg, pathArg, namespacesArg, defaultBitOrderArg, groupMembersArg,
+  extends ModelGroupRuntimeData(positionArg, partialNextElementResolverArg,
+    variableMapArg, encInfoArg, schemaFileLocationArg, ciArg, diagnosticDebugNameArg, pathArg, namespacesArg, defaultBitOrderArg, groupMembersArg,
     isRepresentedArg, couldHaveTextArg, alignmentValueInBitsArg, hasNoSkipRegionsArg, optIgnoreCaseArg,
     maybeFillByteEvArg,
     maybeCheckByteAndBitOrderEvArg,
@@ -854,6 +1000,8 @@ final class ChoiceRuntimeData(
    * hook these objects into a parent-child tree without
    * having to use an assignment to a var.
    */
+  @TransientParam positionArg: => Int,
+  @TransientParam partialNextElementResolverArg: => PartialNextElementResolver,
   @TransientParam variableMapArg: => VariableMap,
   @TransientParam encInfoArg: => EncodingRuntimeData,
   @TransientParam schemaFileLocationArg: => SchemaFileLocation,
@@ -871,7 +1019,8 @@ final class ChoiceRuntimeData(
   @TransientParam maybeFillByteEvArg: => Maybe[FillByteEv],
   @TransientParam maybeCheckByteAndBitOrderEvArg: => Maybe[CheckByteAndBitOrderEv],
   @TransientParam maybeCheckBitOrderAndCharsetEvArg: => Maybe[CheckBitOrderAndCharsetEv])
-  extends ModelGroupRuntimeData(variableMapArg, encInfoArg, schemaFileLocationArg, ciArg, diagnosticDebugNameArg, pathArg, namespacesArg, defaultBitOrderArg, groupMembersArg,
+  extends ModelGroupRuntimeData(positionArg, partialNextElementResolverArg,
+    variableMapArg, encInfoArg, schemaFileLocationArg, ciArg, diagnosticDebugNameArg, pathArg, namespacesArg, defaultBitOrderArg, groupMembersArg,
     isRepresentedArg, couldHaveTextArg, alignmentValueInBitsArg, hasNoSkipRegionsArg, optIgnoreCaseArg, maybeFillByteEvArg,
     maybeCheckByteAndBitOrderEvArg,
     maybeCheckBitOrderAndCharsetEvArg)
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/parsers/BinaryNumberTraits.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/parsers/BinaryNumberTraits.scala
index e11661d7e9..00d0421f08 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/parsers/BinaryNumberTraits.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/parsers/BinaryNumberTraits.scala
@@ -75,7 +75,7 @@ trait PrefixedLengthParserMixin {
 
     // create a "detached" element that the prefix length will be parsed to.
     // This temporarily removes to infoset.
-    val plElement = Infoset.newElement(prefixedLengthERD, state.tunable).asInstanceOf[DISimple]
+    val plElement = Infoset.newElement(prefixedLengthERD).asInstanceOf[DISimple]
     state.infoset = plElement
 
     val parsedLen: JLong = try {
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/parsers/ElementCombinator1.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/parsers/ElementCombinator1.scala
index 4eba42da34..d094e1a27b 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/parsers/ElementCombinator1.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/parsers/ElementCombinator1.scala
@@ -142,12 +142,12 @@ abstract class ElementParserBase(
       // debugger of this so it can do things like check for break points
       if (pstate.dataProc.isDefined) pstate.dataProc.value.startElement(pstate, this)
 
-      if(eRepTypeParser.isDefined){
+      if (eRepTypeParser.isDefined) {
         eRepTypeParser.get.parse1(pstate)
-      }  else if (eParser.isDefined){
+      } else if (eParser.isDefined) {
         eParser.get.parse1(pstate)
       }
-      
+
       Assert.invariant(pstate.hasInfoset)
 
       var setVarFailureDiags: Seq[Diagnostic] = Nil
@@ -223,8 +223,7 @@ class ElementParser(
   eBeforeParser: Maybe[Parser],
   eParser: Maybe[Parser],
   eAfterParser: Maybe[Parser],
-  eRepTypeParser: Maybe[Parser]
-  )
+  eRepTypeParser: Maybe[Parser])
   extends ElementParserBase(
     erd,
     name,
@@ -236,8 +235,7 @@ class ElementParser(
     eBeforeParser,
     eParser,
     eAfterParser,
-    eRepTypeParser  
-  ) {
+    eRepTypeParser) {
 
   def move(start: PState) {
     start.mpstate.moveOverOneElementChildOnly
@@ -245,7 +243,7 @@ class ElementParser(
   }
 
   def parseBegin(pstate: PState): Unit = {
-    val currentElement = Infoset.newElement(erd, pstate.tunable).asInstanceOf[DIElement]
+    val currentElement = Infoset.newElement(erd).asInstanceOf[DIElement]
 
     log(LogLevel.Debug, "currentElement = %s", currentElement)
     val priorElement = pstate.infoset
@@ -260,6 +258,9 @@ class ElementParser(
         // a simple element.
         currentElement.setParent(st.parent)
       }
+      case _ => {
+        Assert.invariantFailed("Unknown priorElement: " + priorElement)
+      }
     }
     log(LogLevel.Debug, "priorElement = %s", priorElement)
     pstate.setParent(currentElement)
@@ -312,8 +313,7 @@ class ElementParserNoRep(
     eBeforeParser,
     eParser,
     eAfterParser,
-    Maybe.Nope  
-  ) {
+    Maybe.Nope) {
 
   // if there is no rep (inputValueCalc), then we do create a new child so that index must advance,
   // but we don't create anything new as far as the group is concerned, and we don't want
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/parsers/ParseErrors.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/parsers/ParseErrors.scala
index 25684afd43..3077ce9a23 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/parsers/ParseErrors.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/parsers/ParseErrors.scala
@@ -100,7 +100,7 @@ trait DoSDEMixin {
       case other => {
         val sde = new RuntimeSchemaDefinitionError(state.getContext().schemaFileLocation, state, Maybe(e), Nope)
         state.setFailed(sde)
-        throw sde
+        state.toss(sde)
       }
     }
   }
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/unparsers/UState.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/unparsers/UState.scala
index 41379b9381..d908659142 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/unparsers/UState.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/unparsers/UState.scala
@@ -25,6 +25,7 @@ import scala.Left
 import scala.collection.mutable
 
 import org.apache.daffodil.api.DFDL
+import org.apache.daffodil.api.DaffodilTunables
 import org.apache.daffodil.api.DataLocation
 import org.apache.daffodil.api.Diagnostic
 import org.apache.daffodil.dpath.UnparserBlocking
@@ -34,8 +35,11 @@ import org.apache.daffodil.exceptions.Assert
 import org.apache.daffodil.exceptions.SavesErrorsAndWarnings
 import org.apache.daffodil.exceptions.ThrowsSDE
 import org.apache.daffodil.infoset.DIArray
+import org.apache.daffodil.infoset.DIDocument
 import org.apache.daffodil.infoset.DIElement
 import org.apache.daffodil.infoset.DINode
+import org.apache.daffodil.infoset.InfosetAccessor
+import org.apache.daffodil.infoset.InfosetInputter
 import org.apache.daffodil.io.DirectOrBufferedDataOutputStream
 import org.apache.daffodil.io.StringDataInputStreamForUnparse
 import org.apache.daffodil.processors.DataLoc
@@ -43,11 +47,17 @@ import org.apache.daffodil.processors.DataProcessor
 import org.apache.daffodil.processors.DelimiterStackUnparseNode
 import org.apache.daffodil.processors.EscapeSchemeUnparserHelper
 import org.apache.daffodil.processors.Failure
+import org.apache.daffodil.processors.NonTermRuntimeData
 import org.apache.daffodil.processors.ParseOrUnparseState
+import org.apache.daffodil.processors.RuntimeData
 import org.apache.daffodil.processors.Suspension
+import org.apache.daffodil.processors.TermRuntimeData
 import org.apache.daffodil.processors.UnparseResult
 import org.apache.daffodil.processors.VariableBox
 import org.apache.daffodil.processors.VariableMap
+import org.apache.daffodil.processors.charset.BitsCharset
+import org.apache.daffodil.processors.charset.BitsCharsetDecoder
+import org.apache.daffodil.processors.charset.BitsCharsetEncoder
 import org.apache.daffodil.processors.dfa.DFADelimiter
 import org.apache.daffodil.util.Cursor
 import org.apache.daffodil.util.LocalStack
@@ -57,15 +67,6 @@ import org.apache.daffodil.util.MStackOfMaybe
 import org.apache.daffodil.util.Maybe
 import org.apache.daffodil.util.Maybe.Nope
 import org.apache.daffodil.util.Maybe.One
-import org.apache.daffodil.infoset.InfosetAccessor
-import org.apache.daffodil.infoset.InfosetInputter
-import org.apache.daffodil.processors.ParseOrUnparseState
-import org.apache.daffodil.api.DaffodilTunables
-import org.apache.daffodil.processors.NonTermRuntimeData
-import org.apache.daffodil.processors.TermRuntimeData
-import org.apache.daffodil.processors.charset.BitsCharsetDecoder
-import org.apache.daffodil.processors.charset.BitsCharsetEncoder
-import org.apache.daffodil.processors.charset.BitsCharset
 
 object ENoWarn { EqualitySuppressUnusedImportWarning() }
 
@@ -78,6 +79,22 @@ abstract class UState(
   extends ParseOrUnparseState(vbox, diagnosticsArg, dataProcArg, tunable)
   with Cursor[InfosetAccessor] with ThrowsSDE with SavesErrorsAndWarnings {
 
+  /**
+   * Push onto the dynamic TRD context stack
+   */
+  def pushTRD(trd: TermRuntimeData): Unit
+
+  /**
+   * Returns the top of the stack if it exists. No state change to stack contents.
+   */
+  def maybeTopTRD(): Maybe[TermRuntimeData]
+
+  /**
+   * Pop the dynamic TRD context stack. The popped TRD should be the same as the argument rd.
+   * The popped TRD is returned.
+   */
+  def popTRD(trd: TermRuntimeData): TermRuntimeData
+
   // def unparse1(unparser: Unparser): Unit
 
   override def toString = {
@@ -323,6 +340,8 @@ abstract class UState(
 
   def regexMatchBuffer: CharBuffer = Assert.usageError("Not to be used.")
   def regexMatchBitPositionBuffer: LongBuffer = Assert.usageError("Not to be used.")
+
+  def documentElement: DIDocument
 }
 
 /**
@@ -333,7 +352,7 @@ abstract class UState(
  * information isn't used and there's no need to copy it/take up valuable
  * memory.
  */
-class UStateForSuspension(
+final class UStateForSuspension(
   val mainUState: UStateMain,
   dos: DirectOrBufferedDataOutputStream,
   vbox: VariableBox,
@@ -363,7 +382,6 @@ class UStateForSuspension(
   override def advance: Boolean = die
   override def advanceAccessor: InfosetAccessor = die
   override def inspect: Boolean = die
-  override def inspectPure: Boolean = die
   override def inspectAccessor: InfosetAccessor = die
   override def fini: Unit = {}
   override def inspectOrError = die
@@ -397,6 +415,13 @@ class UStateForSuspension(
   override def escapeSchemeEVCache: MStackOfMaybe[EscapeSchemeUnparserHelper] = escapeSchemeEVCacheMaybe.get
 
   override def setVariables(newVariableMap: VariableMap) = die
+
+  override def pushTRD(trd: TermRuntimeData): Unit = die
+  override def maybeTopTRD() = die
+  override def popTRD(trd: TermRuntimeData): TermRuntimeData = die
+
+  override def documentElement = mainUState.documentElement
+
 }
 
 final class UStateMain private (
@@ -483,7 +508,6 @@ final class UStateMain private (
   override def advance: Boolean = inputter.advance
   override def advanceAccessor: InfosetAccessor = inputter.advanceAccessor
   override def inspect: Boolean = inputter.inspect
-  override def inspectPure: Boolean = inputter.inspectPure
   override def inspectAccessor: InfosetAccessor = inputter.inspectAccessor
   override def fini: Unit = { inputter.fini }
 
@@ -604,6 +628,20 @@ final class UStateMain private (
     }
   }
 
+  final override def pushTRD(trd: TermRuntimeData) =
+    inputter.pushTRD(trd)
+
+  final override def maybeTopTRD(): Maybe[TermRuntimeData] =
+    inputter.maybeTopTRD()
+
+  final override def popTRD(trd: TermRuntimeData) = {
+    val poppedTRD = inputter.popTRD()
+    if (poppedTRD ne trd)
+      Assert.invariantFailed("TRDs do not match. Expected: " + trd + " got " + poppedTRD)
+    poppedTRD
+  }
+
+  final override def documentElement = inputter.documentElement
 }
 
 class SuspensionDeadlockException(suspExprs: Seq[Suspension])
@@ -619,6 +657,7 @@ object UState {
     out: DirectOrBufferedDataOutputStream,
     dataProc: DFDL.DataProcessor,
     inputter: InfosetInputter): UStateMain = {
+    Assert.invariant(inputter.isInitialized)
 
     val variables = dataProc.getVariables
     val diagnostics = Nil
diff --git a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/unparsers/Unparser.scala b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/unparsers/Unparser.scala
index af49da1298..cb4c723244 100644
--- a/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/unparsers/Unparser.scala
+++ b/daffodil-runtime1/src/main/scala/org/apache/daffodil/processors/unparsers/Unparser.scala
@@ -60,9 +60,10 @@ sealed trait Unparser
       case af: AlignmentPrimUnparser => // ok. Don't check bitOrder before Aligning.
       case u: PrimUnparser => {
         u.context match {
-          case trd: TermRuntimeData =>
+          case trd: TermRuntimeData => {
             ustate.bitOrder // asking for bitOrder checks bit order changes.
-          // this splits DOS on bitOrder changes if absoluteBitPos not known
+            // this splits DOS on bitOrder changes if absoluteBitPos not known
+          }
           case rd: RuntimeData => Assert.invariantFailed("Primitive unparser " + u + " has non-Term runtime data: " + rd)
         }
       }
@@ -70,7 +71,6 @@ sealed trait Unparser
     }
     try {
       unparse(ustate)
-
     } finally {
       ustate.resetFormatInfoCaches()
     }
diff --git a/daffodil-sapi/src/test/scala/org/apache/daffodil/example/TestScalaAPI.scala b/daffodil-sapi/src/test/scala/org/apache/daffodil/example/TestScalaAPI.scala
index b9b09d6f0e..eb7a3758f3 100644
--- a/daffodil-sapi/src/test/scala/org/apache/daffodil/example/TestScalaAPI.scala
+++ b/daffodil-sapi/src/test/scala/org/apache/daffodil/example/TestScalaAPI.scala
@@ -75,30 +75,30 @@ class TestScalaAPI {
    * as one would normally do with a standard Object{Input,Output}Stream.
    */
   private def reserializeDataProcessor(dp: DataProcessor): DataProcessor = {
-      val baos = new ByteArrayOutputStream()
-      val oos = new ObjectOutputStream(baos)
-      oos.writeObject(dp)
-      oos.close()
-
-      val bais = new ByteArrayInputStream(baos.toByteArray())
-      val ois = new ObjectInputStream(bais) {
-        /**
-         * This override is here because of a bug in sbt where the wrong class loader is being
-         * used when deserializing an object.
-         * For more information, see https://github.com/sbt/sbt/issues/163
-         */
-        override protected def resolveClass(desc: java.io.ObjectStreamClass): Class[_] = {
-          try {
-            Class.forName(desc.getName, false, getClass.getClassLoader)
-          } catch {
-            case e: ClassNotFoundException => super.resolveClass(desc);
-          }
+    val baos = new ByteArrayOutputStream()
+    val oos = new ObjectOutputStream(baos)
+    oos.writeObject(dp)
+    oos.close()
+
+    val bais = new ByteArrayInputStream(baos.toByteArray())
+    val ois = new ObjectInputStream(bais) {
+      /**
+       * This override is here because of a bug in sbt where the wrong class loader is being
+       * used when deserializing an object.
+       * For more information, see https://github.com/sbt/sbt/issues/163
+       */
+      override protected def resolveClass(desc: java.io.ObjectStreamClass): Class[_] = {
+        try {
+          Class.forName(desc.getName, false, getClass.getClassLoader)
+        } catch {
+          case e: ClassNotFoundException => super.resolveClass(desc);
         }
       }
-
-      ois.readObject().asInstanceOf[DataProcessor]
     }
 
+    ois.readObject().asInstanceOf[DataProcessor]
+  }
+
   @Test
   def testScalaAPI1() {
     val lw = new LogWriterForSAPITest()
@@ -830,7 +830,7 @@ class TestScalaAPI {
     assertEquals(1, diags.size)
     val d = diags(0);
     assertTrue(d.getMessage().contains("wrong"))
-    assertTrue(d.getMessage().contains("e1"))
+    assertTrue(d.getMessage().contains("e2"))
 
     // reset the global logging and debugger state
     Daffodil.setLogWriter(new ConsoleLogWriter())
diff --git a/daffodil-test-ibm1/src/test/resources/test-suite/ibm-contributed/dpaext2.tdml b/daffodil-test-ibm1/src/test/resources/test-suite/ibm-contributed/dpaext2.tdml
index dc6ecb7b45..0436a6b8b7 100644
--- a/daffodil-test-ibm1/src/test/resources/test-suite/ibm-contributed/dpaext2.tdml
+++ b/daffodil-test-ibm1/src/test/resources/test-suite/ibm-contributed/dpaext2.tdml
@@ -22,7 +22,18 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xmlns:xs="http://www.w3.org/2001/XMLSchema"
 	defaultRoundTrip="true"
-    defaultImplementations="ibm daffodil">
+    defaultImplementations="ibm daffodil"
+    defaultConfig="nowarn">
+    
+  <tdml:defineConfig name="nowarn"
+    xmlns:daf="urn:ogf:dfdl:2013:imp:daffodil.apache.org:2018:ext">
+    <daf:tunables>
+      <daf:suppressSchemaDefinitionWarnings>
+        encodingErrorPolicyError
+        unsupportedAttributeFormDefault
+      </daf:suppressSchemaDefinitionWarnings>
+    </daf:tunables>
+  </tdml:defineConfig>
 
 <!-- Section 13 - Simple Types
     First, some tests for padding/trimming, with properties common to simple types with Text representation
diff --git a/daffodil-test/src/test/resources/org/apache/daffodil/extensions/type_calc/typeCalcFunctionErrors.tdml b/daffodil-test/src/test/resources/org/apache/daffodil/extensions/type_calc/typeCalcFunctionErrors.tdml
index e5b2dc65a8..fc43f14dc5 100644
--- a/daffodil-test/src/test/resources/org/apache/daffodil/extensions/type_calc/typeCalcFunctionErrors.tdml
+++ b/daffodil-test/src/test/resources/org/apache/daffodil/extensions/type_calc/typeCalcFunctionErrors.tdml
@@ -502,7 +502,7 @@
     </tdml:infoset>
     <tdml:errors>
       <tdml:error>Schema Definition Error</tdml:error>
-      <tdml:error>dfdlx:outputTypeCalcNextSibling() called where no next sibling exists</tdml:error>
+      <tdml:error>dfdlx:outputTypeCalcNextSibling() called where no suitable next sibling exists</tdml:error>
     </tdml:errors>
   </tdml:unparserTestCase>
 
diff --git a/daffodil-test/src/test/resources/org/apache/daffodil/section00/general/testElementFormDefault.tdml b/daffodil-test/src/test/resources/org/apache/daffodil/section00/general/testElementFormDefault.tdml
index 75c87a643d..0340b1b287 100644
--- a/daffodil-test/src/test/resources/org/apache/daffodil/section00/general/testElementFormDefault.tdml
+++ b/daffodil-test/src/test/resources/org/apache/daffodil/section00/general/testElementFormDefault.tdml
@@ -108,10 +108,9 @@
     </tdml:infoset>
     <tdml:errors>
       <tdml:error>Unparse Error</tdml:error>
-      <tdml:error>found</tdml:error>
       <tdml:error>{}opt</tdml:error>
-      <tdml:error>expected</tdml:error>
-      <tdml:error>{http://example.com}opt</tdml:error>
+      <tdml:error>expected element end</tdml:error>
+      <tdml:error>{http://example.com}r1</tdml:error>
     </tdml:errors>
 
   </tdml:unparserTestCase>
@@ -180,9 +179,8 @@
     </tdml:infoset>
     <tdml:errors>
       <tdml:error>Unparse Error</tdml:error>
-      <tdml:error>found</tdml:error>
       <tdml:error>{}e1</tdml:error>
-      <tdml:error>expected</tdml:error>
+      <tdml:error>expected element start</tdml:error>
       <tdml:error>{http://example.com}e1</tdml:error>
     </tdml:errors>
 
@@ -206,9 +204,8 @@
     </tdml:infoset>
     <tdml:errors>
       <tdml:error>Error</tdml:error>
-      <tdml:error>found</tdml:error>
       <tdml:error>{}e0</tdml:error>
-      <tdml:error>expected</tdml:error>
+      <tdml:error>expected element start</tdml:error>
       <tdml:error>{http://example.com}e0</tdml:error>
     </tdml:errors>
 
@@ -256,10 +253,9 @@
     </tdml:infoset>
     <tdml:errors>
       <tdml:error>Unparse Error</tdml:error>
-      <tdml:error>Found</tdml:error>
-      <tdml:error>opt</tdml:error>
-      <tdml:error>expected</tdml:error>
-      <tdml:error>{}opt</tdml:error>
+      <tdml:error>{http://example.com}r1</tdml:error>
+      <tdml:error>expected element end</tdml:error>
+      <tdml:error>{http://example.com}opt</tdml:error>
     </tdml:errors>
 
   </tdml:unparserTestCase>
@@ -328,10 +324,9 @@
     </tdml:infoset>
     <tdml:errors>
       <tdml:error>Unparse Error</tdml:error>
-      <tdml:error>found</tdml:error>
-      <tdml:error>e1</tdml:error>
-      <tdml:error>expected</tdml:error>
       <tdml:error>{}e1</tdml:error>
+      <tdml:error>expected element start</tdml:error>
+      <tdml:error>{http://example.com}e1</tdml:error>
     </tdml:errors>
 
   </tdml:unparserTestCase>
@@ -373,9 +368,8 @@
     </tdml:infoset>
     <tdml:errors>
       <tdml:error>Unparse Error</tdml:error>
-      <tdml:error>Found</tdml:error>
       <tdml:error>{}e0</tdml:error>
-      <tdml:error>expected</tdml:error>
+      <tdml:error>expected element start</tdml:error>
       <tdml:error>{http://example.com}e0</tdml:error>
     </tdml:errors>
   </tdml:unparserTestCase>
diff --git a/daffodil-test/src/test/resources/org/apache/daffodil/section00/general/testUnparserGeneral.tdml b/daffodil-test/src/test/resources/org/apache/daffodil/section00/general/testUnparserGeneral.tdml
index b5f6380a98..36fac816d7 100644
--- a/daffodil-test/src/test/resources/org/apache/daffodil/section00/general/testUnparserGeneral.tdml
+++ b/daffodil-test/src/test/resources/org/apache/daffodil/section00/general/testUnparserGeneral.tdml
@@ -462,9 +462,9 @@
     </tdml:infoset>
     <tdml:errors>
       <tdml:error>Unparse Error</tdml:error>
-      <tdml:error>Found next element</tdml:error>
-      <tdml:error>s2</tdml:error>
-      <tdml:error>no element is expected</tdml:error>
+      <tdml:error>{http://example.com}s2</tdml:error>
+      <tdml:error>expected element end</tdml:error>
+      <tdml:error>{http://example.com}e1</tdml:error>
     </tdml:errors>
 
   </tdml:unparserTestCase>
diff --git a/daffodil-test/src/test/resources/org/apache/daffodil/section02/processing_errors/ProcessingErrorsUnparse.tdml b/daffodil-test/src/test/resources/org/apache/daffodil/section02/processing_errors/ProcessingErrorsUnparse.tdml
index e5e80e34d3..92520a6ac5 100644
--- a/daffodil-test/src/test/resources/org/apache/daffodil/section02/processing_errors/ProcessingErrorsUnparse.tdml
+++ b/daffodil-test/src/test/resources/org/apache/daffodil/section02/processing_errors/ProcessingErrorsUnparse.tdml
@@ -178,8 +178,9 @@
     
     <tdml:errors>
       <tdml:error>Unparse Error</tdml:error>
-      <tdml:error>Found root element {}root</tdml:error>
+      <tdml:error>expected element start</tdml:error>
       <tdml:error>{http://example.com}root</tdml:error>
+      <tdml:error>{}root</tdml:error>
     </tdml:errors>
 
   </tdml:unparserTestCase>
diff --git a/daffodil-test/src/test/resources/org/apache/daffodil/section16/array_optional_elem/ArrayComb.tdml b/daffodil-test/src/test/resources/org/apache/daffodil/section16/array_optional_elem/ArrayComb.tdml
index 87e2994cee..d569a5898d 100644
--- a/daffodil-test/src/test/resources/org/apache/daffodil/section16/array_optional_elem/ArrayComb.tdml
+++ b/daffodil-test/src/test/resources/org/apache/daffodil/section16/array_optional_elem/ArrayComb.tdml
@@ -97,9 +97,9 @@
     <tdml:errors>
       <tdml:error>Unparse Error</tdml:error>
       <tdml:error>Expected 1 additional</tdml:error>
-      <tdml:error>bar</tdml:error>
-      <tdml:error>received element end event</tdml:error>
-      <tdml:error>ex:root1</tdml:error>
+      <tdml:error>{}bar</tdml:error>
+      <tdml:error>received element end</tdml:error>
+      <tdml:error>{http://example.com}root1</tdml:error>
     </tdml:errors>        
   </tdml:unparserTestCase>
   
diff --git a/daffodil-test/src/test/resources/org/apache/daffodil/section16/array_optional_elem/UnparseArrayDelimitedOptionalElem.tdml b/daffodil-test/src/test/resources/org/apache/daffodil/section16/array_optional_elem/UnparseArrayDelimitedOptionalElem.tdml
index 47283dc324..5310a2fda2 100644
--- a/daffodil-test/src/test/resources/org/apache/daffodil/section16/array_optional_elem/UnparseArrayDelimitedOptionalElem.tdml
+++ b/daffodil-test/src/test/resources/org/apache/daffodil/section16/array_optional_elem/UnparseArrayDelimitedOptionalElem.tdml
@@ -25,7 +25,7 @@
   <tdml:defineSchema name="s1">
     <xs:include schemaLocation="org/apache/daffodil/xsd/DFDLGeneralFormat.dfdl.xsd"/>
 
-    <dfdl:format lengthKind="explicit" length="1" ref="ex:GeneralFormatPortable"
+    <dfdl:format lengthKind="explicit" length="1" ref="ex:GeneralFormatPortable" encodingErrorPolicy="replace"
       separator="" initiator="" terminator="" occursCountKind="implicit"
       ignoreCase="no" textNumberRep="standard" representation="text" separatorSuppressionPolicy="anyEmpty" textPadKind="padChar" textStringPadCharacter="."/>
     <dfdl:defineFormat name="root">
diff --git a/daffodil-test/src/test/resources/org/apache/daffodil/section16/array_optional_elem/UnparseArrayFixedOptionalElem.tdml b/daffodil-test/src/test/resources/org/apache/daffodil/section16/array_optional_elem/UnparseArrayFixedOptionalElem.tdml
index aa7b28a9d4..3be5595afb 100644
--- a/daffodil-test/src/test/resources/org/apache/daffodil/section16/array_optional_elem/UnparseArrayFixedOptionalElem.tdml
+++ b/daffodil-test/src/test/resources/org/apache/daffodil/section16/array_optional_elem/UnparseArrayFixedOptionalElem.tdml
@@ -129,8 +129,9 @@
     </tdml:infoset>
     <tdml:errors>
       <tdml:error>Unparse Error</tdml:error>
-      <tdml:error>no element is expected</tdml:error>
-      <tdml:error>opt</tdml:error>
+      <tdml:error>expected element end</tdml:error>
+      <tdml:error>{http://example.com}r1</tdml:error>
+      <tdml:error>{http://example.com}opt</tdml:error>
     </tdml:errors>
 
   </tdml:unparserTestCase>
diff --git a/daffodil-test/src/test/resources/org/apache/daffodil/section23/dfdl_expressions/expressions.tdml b/daffodil-test/src/test/resources/org/apache/daffodil/section23/dfdl_expressions/expressions.tdml
index 402819df69..0b091ea528 100644
--- a/daffodil-test/src/test/resources/org/apache/daffodil/section23/dfdl_expressions/expressions.tdml
+++ b/daffodil-test/src/test/resources/org/apache/daffodil/section23/dfdl_expressions/expressions.tdml
@@ -2064,7 +2064,7 @@
           </xs:element>
           <xs:element name="cnt2" type="xs:int"
             dfdl:lengthKind="delimited" />
-          <xs:element name="a" minOccurs="0" maxOccurs="unbounded"
+          <xs:element name="b" minOccurs="0" maxOccurs="unbounded"
             dfdl:occursCountKind="expression" dfdl:occursCount="{ xs:int(../ex:cnt2) }">
             <xs:complexType>
               <xs:sequence>
@@ -2229,12 +2229,12 @@
             <v>2</v>
           </a>
           <cnt2>2</cnt2>
-          <a>
+          <b>
             <v>1</v>
-          </a>
-          <a>
+          </b>
+          <b>
             <v>2</v>
-          </a>
+          </b>
         </f>
       </tdml:dfdlInfoset>
     </tdml:infoset>
diff --git a/daffodil-test/src/test/resources/org/apache/daffodil/unparser/unparseNegInfosetTest.tdml b/daffodil-test/src/test/resources/org/apache/daffodil/unparser/unparseNegInfosetTest.tdml
index 4ed3a2203f..009f708677 100644
--- a/daffodil-test/src/test/resources/org/apache/daffodil/unparser/unparseNegInfosetTest.tdml
+++ b/daffodil-test/src/test/resources/org/apache/daffodil/unparser/unparseNegInfosetTest.tdml
@@ -110,9 +110,10 @@
       </tdml:dfdlInfoset>
     </tdml:infoset>
     <tdml:errors>
-      <tdml:error>Found next element</tdml:error>
+      <tdml:error>Unparse Error</tdml:error>
       <tdml:error>foo</tdml:error>
-      <tdml:error>no element is expected</tdml:error>
+      <tdml:error>expected element end</tdml:error>
+      <tdml:error>root1</tdml:error>
     </tdml:errors>
   </tdml:unparserTestCase>
 
@@ -126,9 +127,9 @@
       </tdml:dfdlInfoset>
     </tdml:infoset>
     <tdml:errors>
-      <tdml:error>Found next element</tdml:error>
+      <tdml:error>Unparse Error</tdml:error>
       <tdml:error>foo</tdml:error>
-      <tdml:error>expected</tdml:error>
+      <tdml:error>expected element start</tdml:error>
       <tdml:error>two</tdml:error>
     </tdml:errors>
   </tdml:unparserTestCase>
@@ -183,9 +184,9 @@
       </tdml:dfdlInfoset>
     </tdml:infoset>
     <tdml:errors>
-      <tdml:error>Found child element</tdml:error>
+      <tdml:error>Unparse Error</tdml:error>
       <tdml:error>foo</tdml:error>
-      <tdml:error>expected</tdml:error>
+      <tdml:error>expected element start</tdml:error>
       <tdml:error>one</tdml:error>
     </tdml:errors>
   </tdml:unparserTestCase>
@@ -216,7 +217,7 @@
       </tdml:dfdlInfoset>
     </tdml:infoset>
     <tdml:errors>
-      <tdml:error>Found child element</tdml:error>
+      <tdml:error>Found next element</tdml:error>
       <tdml:error>foo</tdml:error>
       <tdml:error>expected one of</tdml:error>
       <tdml:error>c1</tdml:error>
diff --git a/daffodil-test/src/test/scala/org/apache/daffodil/section16/array_optional_elem/TestUnparseArrayFixedOptionalElemNew.scala b/daffodil-test/src/test/scala/org/apache/daffodil/section16/array_optional_elem/TestUnparseArrayFixedOptionalElemNew.scala
deleted file mode 100644
index 7f6a43b3da..0000000000
--- a/daffodil-test/src/test/scala/org/apache/daffodil/section16/array_optional_elem/TestUnparseArrayFixedOptionalElemNew.scala
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.daffodil.section16.array_optional_elem
-
-import org.junit.Test
-import org.apache.daffodil.tdml.Runner
-import org.junit.AfterClass
-
-object TestUnparseArrayFixedOptionalElemNew {
-  val testDir = "/org/apache/daffodil/section16/array_optional_elem/"
-
-  val runner_fixed = Runner(testDir, "UnparseArrayFixedOptionalElem.tdml")
-
-  val runner_imp = Runner(testDir, "UnparseArrayImplicitOptionalElem.tdml")
-
-  val runner_parsed = Runner(testDir, "UnparseArrayParsedOptionalElem.tdml")
-
-  val runner_expr = Runner(testDir, "UnparseArrayExpressionConstant.tdml")
-
-  /**
-   * Avoid memory leak of adding more and more test suites to static objects as we run more and more test suites.
-   */
-  @AfterClass def tearDown() {
-    runner_fixed.reset
-    runner_imp.reset
-    runner_parsed.reset
-    runner_expr.reset
-  }
-}
-class TestUnparseArrayFixedOptionalElemNew {
-  import TestUnparseArrayFixedOptionalElemNew._
-
-  //DFDL-1301
-  @Test def test_fixedUnparseArrayTooManyElements01() { runner_fixed.runOneTest("fixedUnparseArrayTooManyElements01") }
-
-  @Test def test_impOptArrayThenScalar02parse() { runner_imp.runOneTest("impOptArrayThenScalar02parse") }
-}
diff --git a/daffodil-test/src/test/scala/org/apache/daffodil/section23/dfdl_expressions/TestDFDLExpressions3.scala b/daffodil-test/src/test/scala/org/apache/daffodil/section23/dfdl_expressions/TestDFDLExpressions3.scala
index 71f9d42858..0368415662 100644
--- a/daffodil-test/src/test/scala/org/apache/daffodil/section23/dfdl_expressions/TestDFDLExpressions3.scala
+++ b/daffodil-test/src/test/scala/org/apache/daffodil/section23/dfdl_expressions/TestDFDLExpressions3.scala
@@ -34,13 +34,16 @@ object TestDFDLExpressions3 {
 class TestDFDLExpressions3 {
   import TestDFDLExpressions3._
 
-  @Test def test_polymorphic_expr_1() { runner.runOneTest("test_polymorphic_expr_1") }
-  @Test def test_polymorphic_expr_2a() { runner.runOneTest("test_polymorphic_expr_2a") }
-  @Test def test_polymorphic_expr_2b() { runner.runOneTest("test_polymorphic_expr_2b") }
-  @Test def test_polymorphic_expr_3() { runner.runOneTest("test_polymorphic_expr_3") }
-  @Test def test_polymorphic_expr_4() { runner.runOneTest("test_polymorphic_expr_4") }
-  @Test def test_polymorphic_expr_5() { runner.runOneTest("test_polymorphic_expr_5") }
-  @Test def test_polymorphic_expr_6() { runner.runOneTest("test_polymorphic_expr_6") }
+  // Fix to DAFFODIL-2192 removed the sharing of expression compilation across
+  // multiple points of use. So these polymorphic situations no longer cause errors.
+  //
+  //  @Test def test_polymorphic_expr_1() { runner.runOneTest("test_polymorphic_expr_1") }
+  //  @Test def test_polymorphic_expr_2a() { runner.runOneTest("test_polymorphic_expr_2a") }
+  //  @Test def test_polymorphic_expr_2b() { runner.runOneTest("test_polymorphic_expr_2b") }
+  //  @Test def test_polymorphic_expr_3() { runner.runOneTest("test_polymorphic_expr_3") }
+  //  @Test def test_polymorphic_expr_4() { runner.runOneTest("test_polymorphic_expr_4") }
+  //  @Test def test_polymorphic_expr_5() { runner.runOneTest("test_polymorphic_expr_5") }
+  //  @Test def test_polymorphic_expr_6() { runner.runOneTest("test_polymorphic_expr_6") }
 
   // DAFFODIL-2182
   // @Test def test_array_self_expr1() { runner.runOneTest("test_array_self_expr1") }
