diff --git a/common/src/main/java/org/apache/drill/common/types/Types.java b/common/src/main/java/org/apache/drill/common/types/Types.java
index 942b27c81e3..692d8f5650b 100644
--- a/common/src/main/java/org/apache/drill/common/types/Types.java
+++ b/common/src/main/java/org/apache/drill/common/types/Types.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -27,10 +27,14 @@
 import org.apache.drill.common.types.TypeProtos.MinorType;
 
 import com.google.protobuf.TextFormat;
+import org.apache.drill.common.util.CoreDecimalUtility;
 
 public class Types {
   static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(Types.class);
 
+  public static final int MAX_VARCHAR_LENGTH = 65535;
+  public static final int UNDEFINED = 0;
+
   public static final MajorType NULL = required(MinorType.NULL);
   public static final MajorType LATE_BIND_TYPE = optional(MinorType.LATE);
   public static final MajorType REQUIRED_BIT = required(MinorType.BIT);
@@ -41,8 +45,8 @@ public static boolean isUnion(MajorType toType) {
     return toType.getMinorType() == MinorType.UNION;
   }
 
-  public static enum Comparability {
-    UNKNOWN, NONE, EQUAL, ORDERED;
+  public enum Comparability {
+    UNKNOWN, NONE, EQUAL, ORDERED
   }
 
   public static boolean isComplex(final MajorType type) {
@@ -282,80 +286,79 @@ public static boolean isJdbcSignedType( final MajorType type ) {
 
   public static int getJdbcDisplaySize(MajorType type) {
     if (type.getMode() == DataMode.REPEATED || type.getMinorType() == MinorType.LIST) {
-      return 0;
+      return UNDEFINED;
     }
 
     final int precision = getPrecision(type);
-
     switch(type.getMinorType()) {
-    case BIT:             return 1; // 1 digit
-
-    case TINYINT:         return 4; // sign + 3 digit
-    case SMALLINT:        return 6; // sign + 5 digits
-    case INT:             return 11; // sign + 10 digits
-    case BIGINT:          return 20; // sign + 19 digits
-
-    case UINT1:          return 3; // 3 digits
-    case UINT2:          return 5; // 5 digits
-    case UINT4:          return 10; // 10 digits
-    case UINT8:          return 19; // 19 digits
+      case BIT:             return 1; // 1 digit
 
-    case FLOAT4:          return 14; // sign + 7 digits + decimal point + E + 2 digits
-    case FLOAT8:          return 24; // sign + 15 digits + decimal point + E + 3 digits
-
-    case DECIMAL9:
-    case DECIMAL18:
-    case DECIMAL28DENSE:
-    case DECIMAL28SPARSE:
-    case DECIMAL38DENSE:
-    case DECIMAL38SPARSE:
-    case MONEY:           return 2 + precision; // precision of the column plus a sign and a decimal point
+      case TINYINT:         return 4; // sign + 3 digit
+      case SMALLINT:        return 6; // sign + 5 digits
+      case INT:             return 11; // sign + 10 digits
+      case BIGINT:          return 20; // sign + 19 digits
 
-    case VARCHAR:
-    case FIXEDCHAR:
-    case VAR16CHAR:
-    case FIXED16CHAR:     return precision; // number of characters
+      case UINT1:          return 3; // 3 digits
+      case UINT2:          return 5; // 5 digits
+      case UINT4:          return 10; // 10 digits
+      case UINT8:          return 19; // 19 digits
 
-    case VARBINARY:
-    case FIXEDBINARY:     return 2 * precision; // each binary byte is represented as a 2digit hex number
+      case FLOAT4:          return 14; // sign + 7 digits + decimal point + E + 2 digits
+      case FLOAT8:          return 24; // sign + 15 digits + decimal point + E + 3 digits
 
-    case DATE:            return 10; // yyyy-mm-dd
-    case TIME:
-      return precision > 0
-        ? 9 + precision // hh-mm-ss.SSS
-        : 8; // hh-mm-ss
-    case TIMETZ:
-      return precision > 0
-        ? 15 + precision // hh-mm-ss.SSS-zz:zz
-        : 14; // hh-mm-ss-zz:zz
-    case TIMESTAMP:
-      return precision > 0
-         ? 20 + precision // yyyy-mm-ddThh:mm:ss.SSS
-         : 19; // yyyy-mm-ddThh:mm:ss
-    case TIMESTAMPTZ:
-      return precision > 0
-        ? 26 + precision // yyyy-mm-ddThh:mm:ss.SSS:ZZ-ZZ
-        : 25; // yyyy-mm-ddThh:mm:ss-ZZ:ZZ
+      case DECIMAL9:
+      case DECIMAL18:
+      case DECIMAL28DENSE:
+      case DECIMAL28SPARSE:
+      case DECIMAL38DENSE:
+      case DECIMAL38SPARSE:
+      case MONEY:           return 2 + precision; // precision of the column plus a sign and a decimal point
 
-    case INTERVALYEAR:
-      return precision > 0
-          ? 5 + precision // P..Y12M
-          : 0; // if precision is not set, return 0 because there's not enough info
+      case VARCHAR:
+      case FIXEDCHAR:
+      case VAR16CHAR:
+      case FIXED16CHAR:     return precision; // number of characters
 
-    case INTERVALDAY:
-      return precision > 0
-          ? 12 + precision // P..DT12H60M60S assuming fractional seconds precision is not supported
-          : 0; // if precision is not set, return 0 because there's not enough info
+      case VARBINARY:
+      case FIXEDBINARY:     return 2 * precision; // each binary byte is represented as a 2digit hex number
 
-    case INTERVAL:
-    case MAP:
-    case LATE:
-    case NULL:
-    case UNION:           return 0;
+      case DATE:            return 10; // yyyy-mm-dd
+      case TIME:
+        return precision > 0
+            ? 9 + precision // hh-mm-ss.SSS
+            : 8; // hh-mm-ss
+      case TIMETZ:
+        return precision > 0
+            ? 15 + precision // hh-mm-ss.SSS-zz:zz
+            : 14; // hh-mm-ss-zz:zz
+      case TIMESTAMP:
+        return precision > 0
+            ? 20 + precision // yyyy-mm-ddThh:mm:ss.SSS
+            : 19; // yyyy-mm-ddThh:mm:ss
+      case TIMESTAMPTZ:
+        return precision > 0
+            ? 26 + precision // yyyy-mm-ddThh:mm:ss.SSS:ZZ-ZZ
+            : 25; // yyyy-mm-ddThh:mm:ss-ZZ:ZZ
+
+      case INTERVALYEAR:
+        return precision > 0
+            ? 5 + precision // P..Y12M
+            : 9; // we assume max is P9999Y12M
+
+      case INTERVALDAY:
+        return precision > 0
+            ? 12 + precision // P..DT12H60M60S assuming fractional seconds precision is not supported
+            : 22; // the first 4 bytes give the number of days, so we assume max is P2147483648DT12H60M60S
+
+      case INTERVAL:
+      case MAP:
+      case LATE:
+      case NULL:
+      case UNION:
+        return UNDEFINED;
 
-    default:
-      throw new UnsupportedOperationException(
-          "Unexpected/unhandled MinorType value " + type.getMinorType() );
+      default:
+        throw new UnsupportedOperationException("Unexpected/unhandled MinorType value " + type.getMinorType());
     }
   }
   public static boolean usesHolderForGet(final MajorType type) {
@@ -399,7 +402,13 @@ public static boolean isFixedWidthType(final MajorType type) {
   }
 
 
-  public static boolean isStringScalarType(final MajorType type) {
+  /**
+   * Checks if given major type is string scalar type.
+   *
+   * @param type major type
+   * @return true if given major type is scalar string, false otherwise
+   */
+  public static boolean isScalarStringType(final MajorType type) {
     if (type.getMode() == REPEATED) {
       return false;
     }
@@ -475,6 +484,18 @@ public static MajorType withMode(final MinorType type, final DataMode mode) {
     return MajorType.newBuilder().setMode(mode).setMinorType(type).build();
   }
 
+  /**
+   * Builds major type using given minor type, data mode and precision.
+   *
+   * @param type minor type
+   * @param mode data mode
+   * @param precision precision value
+   * @return major type
+   */
+  public static MajorType withPrecision(final MinorType type, final DataMode mode, final int precision) {
+    return MajorType.newBuilder().setMinorType(type).setMode(mode).setPrecision(precision).build();
+  }
+
   public static MajorType withScaleAndPrecision(final MinorType type, final DataMode mode, final int scale, final int precision) {
     return MajorType.newBuilder().setMinorType(type).setMode(mode).setScale(scale).setPrecision(precision).build();
   }
@@ -636,43 +657,66 @@ public static String toString(final MajorType type) {
 
   /**
    * Get the <code>precision</code> of given type.
-   * @param majorType
-   * @return
+   *
+   * @param majorType major type
+   * @return precision value
    */
   public static int getPrecision(MajorType majorType) {
-    MinorType type = majorType.getMinorType();
-
-    if (type == MinorType.VARBINARY || type == MinorType.VARCHAR) {
-      return 65536;
-    }
-
     if (majorType.hasPrecision()) {
       return majorType.getPrecision();
     }
 
-    return 0;
+    return isScalarStringType(majorType) ? MAX_VARCHAR_LENGTH : UNDEFINED;
   }
 
   /**
    * Get the <code>scale</code> of given type.
-   * @param majorType
-   * @return
+   *
+   * @param majorType major type
+   * @return scale value
    */
   public static int getScale(MajorType majorType) {
     if (majorType.hasScale()) {
       return majorType.getScale();
     }
 
-    return 0;
+    return UNDEFINED;
   }
 
   /**
-   * Is the given type column be used in ORDER BY clause?
-   * @param type
-   * @return
+   * Checks if the given type column can be used in ORDER BY clause.
+   *
+   * @param type minor type
+   * @return true if type can be used in ORDER BY clause
    */
   public static boolean isSortable(MinorType type) {
     // Currently only map and list columns are not sortable.
     return type != MinorType.MAP && type != MinorType.LIST;
   }
+
+  /**
+   * Sets max precision from both types if these types are string scalar types.
+   * Sets max precision and scale from both types if these types are decimal types.
+   * Both types should be of the same minor type.
+   *
+   * @param leftType type from left side
+   * @param rightType type from right side
+   * @param typeBuilder type builder
+   * @return type builder
+   */
+  public static MajorType.Builder calculateTypePrecisionAndScale(MajorType leftType, MajorType rightType, MajorType.Builder typeBuilder) {
+    if (leftType.getMinorType().equals(rightType.getMinorType())) {
+      boolean isScalarString = Types.isScalarStringType(leftType) && Types.isScalarStringType(rightType);
+      boolean isDecimal = CoreDecimalUtility.isDecimalType(leftType);
+
+      if ((isScalarString || isDecimal) && leftType.hasPrecision() && rightType.hasPrecision()) {
+        typeBuilder.setPrecision(Math.max(leftType.getPrecision(), rightType.getPrecision()));
+      }
+
+      if (isDecimal && leftType.hasScale() && rightType.hasScale()) {
+        typeBuilder.setScale(Math.max(leftType.getScale(), rightType.getScale()));
+      }
+    }
+    return typeBuilder;
+  }
 }
diff --git a/contrib/native/client/src/clientlib/fieldmeta.cpp b/contrib/native/client/src/clientlib/fieldmeta.cpp
index d9d6bd182d6..13e11348d4b 100644
--- a/contrib/native/client/src/clientlib/fieldmeta.cpp
+++ b/contrib/native/client/src/clientlib/fieldmeta.cpp
@@ -247,12 +247,12 @@ static uint32_t getColumnSize(const std::string& type, uint32_t precision) {
 	else if (type == SQLIntervalYearMonth) {
 		return (precision > 0)
 				? 5 + precision // P..M31
-				: 0; // if precision is not set, return 0 because there's not enough info
+				: 9; // we assume max is P9999Y12M
 	}
 	else if (type == SQLIntervalDaySecond) {
 		return (precision > 0)
 			? 12 + precision // P..DT12H60M60....S
-			: 0; // if precision is not set, return 0 because there's not enough info
+			: 22; // the first 4 bytes give the number of days, so we assume max is P2147483648DT12H60M60S
 	}
 	else {
 		return 0;
@@ -267,7 +267,7 @@ static uint32_t getPrecision(const ::common::MajorType& type) {
 	}
 
 	if (minor_type == ::common::VARBINARY || minor_type == ::common::VARCHAR) {
-		return 65536;
+		return 65535;
 	}
 
 	return 0;
@@ -336,12 +336,12 @@ static uint32_t getDisplaySize(const ::common::MajorType& type) {
     case ::common::INTERVALYEAR:
       return precision > 0
           ? 5 + precision // P..Y12M
-          : 0; // if precision is not set, return 0 because there's not enough info
+          : 9; // we assume max is P9999Y12M
 
     case ::common::INTERVALDAY:
       return precision > 0
           ? 12 + precision // P..DT12H60M60S assuming fractional seconds precision is not supported
-          : 0; // if precision is not set, return 0 because there's not enough info
+          : 22; // the first 4 bytes give the number of days, so we assume max is P2147483648DT12H60M60S
 
     default:
     	// We don't know how to compute a display size, let's return 0 (unknown)
diff --git a/contrib/storage-hive/core/src/main/java/org/apache/drill/exec/store/hive/HiveUtilities.java b/contrib/storage-hive/core/src/main/java/org/apache/drill/exec/store/hive/HiveUtilities.java
index 1d5e6bf70ed..1e5ea6c5014 100644
--- a/contrib/storage-hive/core/src/main/java/org/apache/drill/exec/store/hive/HiveUtilities.java
+++ b/contrib/storage-hive/core/src/main/java/org/apache/drill/exec/store/hive/HiveUtilities.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -51,6 +51,7 @@
 import org.apache.drill.exec.work.ExecErrorConstants;
 
 import org.apache.hadoop.hive.common.type.HiveDecimal;
+import org.apache.hadoop.hive.common.type.HiveVarchar;
 import org.apache.hadoop.hive.metastore.MetaStoreUtils;
 import org.apache.hadoop.hive.metastore.api.Partition;
 import org.apache.hadoop.hive.metastore.api.StorageDescriptor;
@@ -59,6 +60,7 @@
 import org.apache.hadoop.hive.ql.metadata.HiveUtils;
 import org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector.Category;
 import org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector.PrimitiveCategory;
+import org.apache.hadoop.hive.serde2.typeinfo.BaseCharTypeInfo;
 import org.apache.hadoop.hive.serde2.typeinfo.DecimalTypeInfo;
 import org.apache.hadoop.hive.serde2.typeinfo.HiveDecimalUtils;
 import org.apache.hadoop.hive.serde2.typeinfo.PrimitiveTypeInfo;
@@ -294,10 +296,18 @@ public static MajorType getMajorTypeFromHiveTypeInfo(final TypeInfo typeInfo, fi
         MajorType.Builder typeBuilder = MajorType.newBuilder().setMinorType(minorType)
             .setMode(DataMode.OPTIONAL); // Hive columns (both regular and partition) could have null values
 
-        if (primitiveTypeInfo.getPrimitiveCategory() == PrimitiveCategory.DECIMAL) {
-          DecimalTypeInfo decimalTypeInfo = (DecimalTypeInfo) primitiveTypeInfo;
-          typeBuilder.setPrecision(decimalTypeInfo.precision())
-              .setScale(decimalTypeInfo.scale()).build();
+        switch (primitiveTypeInfo.getPrimitiveCategory()) {
+          case CHAR:
+          case VARCHAR:
+            BaseCharTypeInfo baseCharTypeInfo = (BaseCharTypeInfo) primitiveTypeInfo;
+            typeBuilder.setPrecision(baseCharTypeInfo.getLength());
+            break;
+          case DECIMAL:
+            DecimalTypeInfo decimalTypeInfo = (DecimalTypeInfo) primitiveTypeInfo;
+            typeBuilder.setPrecision(decimalTypeInfo.getPrecision()).setScale(decimalTypeInfo.getScale());
+            break;
+          default:
+            // do nothing, other primitive categories do not have precision or scale
         }
 
         return typeBuilder.build();
diff --git a/contrib/storage-hive/core/src/test/java/org/apache/drill/exec/hive/TestHiveStorage.java b/contrib/storage-hive/core/src/test/java/org/apache/drill/exec/hive/TestHiveStorage.java
index 46691fbb7db..e00314d940d 100644
--- a/contrib/storage-hive/core/src/test/java/org/apache/drill/exec/hive/TestHiveStorage.java
+++ b/contrib/storage-hive/core/src/test/java/org/apache/drill/exec/hive/TestHiveStorage.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -18,10 +18,13 @@
 package org.apache.drill.exec.hive;
 
 import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.Maps;
 import org.apache.drill.common.exceptions.UserRemoteException;
 import org.apache.drill.exec.ExecConstants;
 import org.apache.drill.exec.planner.physical.PlannerSettings;
+import org.apache.drill.exec.proto.UserProtos;
 import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.hive.common.type.HiveVarchar;
 import org.joda.time.DateTime;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
@@ -30,11 +33,15 @@
 import java.math.BigDecimal;
 import java.sql.Date;
 import java.sql.Timestamp;
+import java.util.List;
 import java.util.Map;
 
 import static org.hamcrest.CoreMatchers.containsString;
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertThat;
+import static org.junit.Assert.assertTrue;
 
 public class TestHiveStorage extends HiveTestBase {
   @BeforeClass
@@ -510,6 +517,38 @@ public void testIgnoreSkipHeaderFooterForSequencefile() throws Exception {
         .go();
   }
 
+  @Test
+  public void testStringColumnsMetadata() throws Exception {
+    String query = "select varchar_field, char_field, string_field from hive.readtest";
+
+    Map<String, Integer> expectedResult = Maps.newHashMap();
+    expectedResult.put("varchar_field", 50);
+    expectedResult.put("char_field", 10);
+    expectedResult.put("string_field", HiveVarchar.MAX_VARCHAR_LENGTH);
+
+    verifyColumnsMetadata(client.createPreparedStatement(query).get()
+        .getPreparedStatement().getColumnsList(), expectedResult);
+
+    try {
+      test("alter session set `%s` = true", ExecConstants.EARLY_LIMIT0_OPT_KEY);
+      verifyColumnsMetadata(client.createPreparedStatement(String.format("select * from (%s) t limit 0", query)).get()
+              .getPreparedStatement().getColumnsList(), expectedResult);
+    } finally {
+      test("alter session reset `%s`", ExecConstants.EARLY_LIMIT0_OPT_KEY);
+    }
+  }
+
+  private void verifyColumnsMetadata(List<UserProtos.ResultColumnMetadata> columnsList, Map<String, Integer> expectedResult) {
+    for (UserProtos.ResultColumnMetadata columnMetadata : columnsList) {
+      assertTrue("Column should be present in result set", expectedResult.containsKey(columnMetadata.getColumnName()));
+      Integer expectedSize = expectedResult.get(columnMetadata.getColumnName());
+      assertNotNull("Expected size should not be null", expectedSize);
+      assertEquals("Display size should match", expectedSize.intValue(), columnMetadata.getDisplaySize());
+      assertEquals("Precision should match", expectedSize.intValue(), columnMetadata.getPrecision());
+      assertTrue("Column should be nullable", columnMetadata.getIsNullable());
+    }
+  }
+
   @AfterClass
   public static void shutdownOptions() throws Exception {
     test(String.format("alter session set `%s` = false", PlannerSettings.ENABLE_DECIMAL_DATA_TYPE_KEY));
diff --git a/contrib/storage-hive/core/src/test/java/org/apache/drill/exec/hive/TestInfoSchemaOnHiveStorage.java b/contrib/storage-hive/core/src/test/java/org/apache/drill/exec/hive/TestInfoSchemaOnHiveStorage.java
index fb4bb174bca..72bb8100ac4 100644
--- a/contrib/storage-hive/core/src/test/java/org/apache/drill/exec/hive/TestInfoSchemaOnHiveStorage.java
+++ b/contrib/storage-hive/core/src/test/java/org/apache/drill/exec/hive/TestInfoSchemaOnHiveStorage.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -19,6 +19,7 @@
 
 import com.google.common.base.Strings;
 import org.apache.drill.TestBuilder;
+import org.apache.hadoop.hive.common.type.HiveVarchar;
 import org.junit.Test;
 
 public class TestInfoSchemaOnHiveStorage extends HiveTestBase {
@@ -195,7 +196,7 @@ public void varCharMaxLengthAndDecimalPrecisionInInfoSchema() throws Exception{
                          "NUMERIC_SCALE")
         .baselineValues("inttype",     "INTEGER",            null,    2,   32,    0)
         .baselineValues("decimaltype", "DECIMAL",            null,   10,   38,    2)
-        .baselineValues("stringtype",  "CHARACTER VARYING", 65535, null, null, null)
+        .baselineValues("stringtype",  "CHARACTER VARYING", HiveVarchar.MAX_VARCHAR_LENGTH, null, null, null)
         .baselineValues("varchartype", "CHARACTER VARYING",    20, null, null, null)
         .baselineValues("chartype", "CHARACTER", 10, null, null, null)
         .go();
diff --git a/exec/java-exec/src/main/codegen/templates/CastDateVarChar.java b/exec/java-exec/src/main/codegen/templates/CastDateVarChar.java
index 70059776bc6..891666a0f97 100644
--- a/exec/java-exec/src/main/codegen/templates/CastDateVarChar.java
+++ b/exec/java-exec/src/main/codegen/templates/CastDateVarChar.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -52,8 +52,11 @@
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.SIMPLE, nulls=NullHandling.NULL_IF_NULL, 
-  costCategory = FunctionCostCategory.COMPLEX)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.STRING_CAST,
+    nulls = NullHandling.NULL_IF_NULL,
+    costCategory = FunctionCostCategory.COMPLEX)
 public class Cast${type.from}To${type.to} implements DrillSimpleFunc {
 
   @Param ${type.from}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/CastFunctionsSrcVarLenTargetVarLen.java b/exec/java-exec/src/main/codegen/templates/CastFunctionsSrcVarLenTargetVarLen.java
index 4524f5bcc70..a017614a2e4 100644
--- a/exec/java-exec/src/main/codegen/templates/CastFunctionsSrcVarLenTargetVarLen.java
+++ b/exec/java-exec/src/main/codegen/templates/CastFunctionsSrcVarLenTargetVarLen.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -46,7 +46,10 @@
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.SIMPLE, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    <#if type.to == 'VarChar'>returnType = FunctionTemplate.ReturnType.STRING_CAST,</#if>
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc{
 
   @Param ${type.from}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/CastFunctionsTargetVarLen.java b/exec/java-exec/src/main/codegen/templates/CastFunctionsTargetVarLen.java
index 2a318a63de6..9228f340245 100644
--- a/exec/java-exec/src/main/codegen/templates/CastFunctionsTargetVarLen.java
+++ b/exec/java-exec/src/main/codegen/templates/CastFunctionsTargetVarLen.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -46,7 +46,10 @@
  * This class is generated using freemarker and the ${.template_name} template.
  */
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.SIMPLE, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    <#if type.to == 'VarChar'>returnType = FunctionTemplate.ReturnType.STRING_CAST,</#if>
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc{
 
   @Param ${type.from}Holder in;
@@ -58,11 +61,11 @@ public void setup() {
   }
 
   public void eval() {
-    buffer = buffer.reallocIfNeeded((int) len.value);
+    buffer = buffer.reallocIfNeeded((int)len.value);
     String istr = (new ${type.javaType}(in.value)).toString();
     out.buffer = buffer;
     out.start = 0;
-    out.end = Math.min((int)len.value, istr.length()); // truncate if target type has length smaller than that of input's string     
+    out.end = Math.min((int)len.value, istr.length()); // truncate if target type has length smaller than that of input's string
     out.buffer.setBytes(0, istr.substring(0,out.end).getBytes());      
   }
 }
diff --git a/exec/java-exec/src/main/codegen/templates/CastIntervalVarChar.java b/exec/java-exec/src/main/codegen/templates/CastIntervalVarChar.java
index 6dedca77c27..43f9303c195 100644
--- a/exec/java-exec/src/main/codegen/templates/CastIntervalVarChar.java
+++ b/exec/java-exec/src/main/codegen/templates/CastIntervalVarChar.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -50,7 +50,10 @@
  * This class is generated using freemarker and the ${.template_name} template.
  */
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.SIMPLE, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.STRING_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}To${type.to} implements DrillSimpleFunc {
 
   @Param ${type.from}Holder in;
@@ -124,7 +127,10 @@ public void eval() {
 import org.apache.drill.exec.expr.fn.impl.DateUtility;
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.SIMPLE, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.STRING_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}To${type.to} implements DrillSimpleFunc {
 
   @Param ${type.from}Holder in;
@@ -183,8 +189,11 @@ public void eval() {
 import io.netty.buffer.DrillBuf;
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.SIMPLE, nulls=NullHandling.NULL_IF_NULL, 
-  costCategory = FunctionCostCategory.COMPLEX)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.STRING_CAST,
+    nulls = NullHandling.NULL_IF_NULL,
+    costCategory = FunctionCostCategory.COMPLEX)
 public class Cast${type.from}To${type.to} implements DrillSimpleFunc {
 
   @Param ${type.from}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/ConvertToNullableHolder.java b/exec/java-exec/src/main/codegen/templates/ConvertToNullableHolder.java
index cb672515076..7615bc5def8 100644
--- a/exec/java-exec/src/main/codegen/templates/ConvertToNullableHolder.java
+++ b/exec/java-exec/src/main/codegen/templates/ConvertToNullableHolder.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -35,12 +35,14 @@
  * This class is generated using freemarker and the ${.template_name} template.
  */
 
-
-<#if minor.class.startsWith("Decimal")>
-@FunctionTemplate(name = "convertToNullable${minor.class?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE, nulls = FunctionTemplate.NullHandling.INTERNAL)
-<#else>
-@FunctionTemplate(name = "convertToNullable${minor.class?upper_case}", scope = FunctionTemplate.FunctionScope.SIMPLE, nulls = FunctionTemplate.NullHandling.INTERNAL)
-</#if>
+@FunctionTemplate(name = "convertToNullable${minor.class?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    <#if minor.class.startsWith("Decimal")>
+    returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+    <#elseif minor.class.startsWith("Var")>
+    returnType = FunctionTemplate.ReturnType.SAME_IN_OUT_LENGTH,
+    </#if>
+    nulls = FunctionTemplate.NullHandling.INTERNAL)
 public class ${className} implements DrillSimpleFunc {
 
   @Param ${minor.class}Holder input;
diff --git a/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalDenseDecimalSparse.java b/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalDenseDecimalSparse.java
index dc26889afc6..d637dde651b 100644
--- a/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalDenseDecimalSparse.java
+++ b/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalDenseDecimalSparse.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -46,7 +46,10 @@
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc{
 
     @Param ${type.from}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalSimilar.java b/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalSimilar.java
index e0fba0ac9c3..8b97b1a814a 100644
--- a/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalSimilar.java
+++ b/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalSimilar.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -49,7 +49,10 @@
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc{
 
     @Param ${type.from}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalSparseDecimalDense.java b/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalSparseDecimalDense.java
index 5ea8a8db850..69010efcc30 100644
--- a/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalSparseDecimalDense.java
+++ b/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalSparseDecimalDense.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -47,7 +47,10 @@
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc{
 
     @Param ${type.from}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalVarchar.java b/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalVarchar.java
index c5ca782901f..239ea282da6 100644
--- a/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalVarchar.java
+++ b/exec/java-exec/src/main/codegen/templates/Decimal/CastDecimalVarchar.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -51,7 +51,10 @@
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.SIMPLE, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.STRING_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc {
 
     @Param ${type.from}Holder in;
@@ -136,7 +139,10 @@ public void eval() {
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.SIMPLE, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.STRING_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc {
 
     @Param ${type.from}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/Decimal/CastDownwardDecimal.java b/exec/java-exec/src/main/codegen/templates/Decimal/CastDownwardDecimal.java
index 467405e35cd..a1ed7c8d7f7 100644
--- a/exec/java-exec/src/main/codegen/templates/Decimal/CastDownwardDecimal.java
+++ b/exec/java-exec/src/main/codegen/templates/Decimal/CastDownwardDecimal.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -48,7 +48,10 @@
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc {
 
     @Param ${type.from}Holder in;
@@ -125,7 +128,10 @@ public void eval() {
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc {
 
     @Param ${type.from}Holder in;
@@ -172,7 +178,10 @@ public void eval() {
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc {
 
     @Param ${type.from}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/Decimal/CastFloatDecimal.java b/exec/java-exec/src/main/codegen/templates/Decimal/CastFloatDecimal.java
index 7d7ec35f059..95508a1ed78 100644
--- a/exec/java-exec/src/main/codegen/templates/Decimal/CastFloatDecimal.java
+++ b/exec/java-exec/src/main/codegen/templates/Decimal/CastFloatDecimal.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -51,7 +51,10 @@
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc {
 
 @Param ${type.from}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/Decimal/CastIntDecimal.java b/exec/java-exec/src/main/codegen/templates/Decimal/CastIntDecimal.java
index eb01566d96c..abacf49005a 100644
--- a/exec/java-exec/src/main/codegen/templates/Decimal/CastIntDecimal.java
+++ b/exec/java-exec/src/main/codegen/templates/Decimal/CastIntDecimal.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -47,7 +47,10 @@
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc {
 
     @Param ${type.from}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/Decimal/CastSrcDecimalSimple.java b/exec/java-exec/src/main/codegen/templates/Decimal/CastSrcDecimalSimple.java
index fca6e99fe67..541b40a3e43 100644
--- a/exec/java-exec/src/main/codegen/templates/Decimal/CastSrcDecimalSimple.java
+++ b/exec/java-exec/src/main/codegen/templates/Decimal/CastSrcDecimalSimple.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -49,7 +49,10 @@
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc {
 
     @Param ${type.from}Holder in;
@@ -157,7 +160,10 @@ public void eval() {
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc{
 
     @Param ${type.from}Holder in;
@@ -261,7 +267,10 @@ public void eval() {
  */
 
 @SuppressWarnings("unused")
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc {
 
     @Param ${type.from}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/Decimal/CastVarCharDecimal.java b/exec/java-exec/src/main/codegen/templates/Decimal/CastVarCharDecimal.java
index bb011cbb50d..a4341e98ca6 100644
--- a/exec/java-exec/src/main/codegen/templates/Decimal/CastVarCharDecimal.java
+++ b/exec/java-exec/src/main/codegen/templates/Decimal/CastVarCharDecimal.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -54,10 +54,16 @@
 
 @SuppressWarnings("unused")
 <#if type.major == "VarCharDecimalSimple">
-@FunctionTemplate(name ="cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc {
 <#elseif type.major == "EmptyStringVarCharDecimalSimple">
-@FunctionTemplate(name ="castEmptyString${type.from}To${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.INTERNAL)
+@FunctionTemplate(name ="castEmptyString${type.from}To${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.INTERNAL)
 public class CastEmptyString${type.from}To${type.to} implements DrillSimpleFunc {
 </#if>
     @Param ${type.from}Holder in;
@@ -231,10 +237,16 @@ public void eval() {
 
 @SuppressWarnings("unused")
 <#if type.major == "VarCharDecimalComplex">
-@FunctionTemplate(name = "cast${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.NULL_IF_NULL)
+@FunctionTemplate(name = "cast${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.NULL_IF_NULL)
 public class Cast${type.from}${type.to} implements DrillSimpleFunc {
 <#elseif type.major == "EmptyStringVarCharDecimalComplex">
-@FunctionTemplate(name = "castEmptyString${type.from}To${type.to?upper_case}", scope = FunctionTemplate.FunctionScope.DECIMAL_CAST, nulls=NullHandling.INTERNAL)
+@FunctionTemplate(name = "castEmptyString${type.from}To${type.to?upper_case}",
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_CAST,
+    nulls = NullHandling.INTERNAL)
 public class CastEmptyString${type.from}To${type.to} implements DrillSimpleFunc {
 </#if>
     @Param ${type.from}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/Decimal/DecimalAggrTypeFunctions1.java b/exec/java-exec/src/main/codegen/templates/Decimal/DecimalAggrTypeFunctions1.java
index 7737356a0e1..8e85777008c 100644
--- a/exec/java-exec/src/main/codegen/templates/Decimal/DecimalAggrTypeFunctions1.java
+++ b/exec/java-exec/src/main/codegen/templates/Decimal/DecimalAggrTypeFunctions1.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -60,7 +60,10 @@
 
 <#list aggrtype.types as type>
 
-@FunctionTemplate(name = "${aggrtype.funcName}", <#if aggrtype.funcName == "sum"> scope = FunctionTemplate.FunctionScope.DECIMAL_SUM_AGGREGATE <#else>scope = FunctionTemplate.FunctionScope.DECIMAL_AGGREGATE</#if>)
+@FunctionTemplate(name = "${aggrtype.funcName}",
+    scope = FunctionTemplate.FunctionScope.POINT_AGGREGATE,
+    <#if aggrtype.funcName == "sum"> returnType = FunctionTemplate.ReturnType.DECIMAL_SUM_AGGREGATE
+    <#else>returnType = FunctionTemplate.ReturnType.DECIMAL_AGGREGATE</#if>)
 public static class ${type.inputType}${aggrtype.className} implements DrillAggFunc{
 
   @Param ${type.inputType}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/Decimal/DecimalAggrTypeFunctions2.java b/exec/java-exec/src/main/codegen/templates/Decimal/DecimalAggrTypeFunctions2.java
index f885e082161..8729a3116d0 100644
--- a/exec/java-exec/src/main/codegen/templates/Decimal/DecimalAggrTypeFunctions2.java
+++ b/exec/java-exec/src/main/codegen/templates/Decimal/DecimalAggrTypeFunctions2.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -59,7 +59,9 @@
 public class Decimal${aggrtype.className}Functions {
 <#list aggrtype.types as type>
 
-@FunctionTemplate(name = "${aggrtype.funcName}", scope = FunctionTemplate.FunctionScope.DECIMAL_SUM_AGGREGATE)
+@FunctionTemplate(name = "${aggrtype.funcName}",
+    scope = FunctionTemplate.FunctionScope.POINT_AGGREGATE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_SUM_AGGREGATE)
 public static class ${type.inputType}${aggrtype.className} implements DrillAggFunc{
 
   @Param ${type.inputType}Holder in;
diff --git a/exec/java-exec/src/main/codegen/templates/Decimal/DecimalFunctions.java b/exec/java-exec/src/main/codegen/templates/Decimal/DecimalFunctions.java
index a4bf06ab834..6197b06232a 100644
--- a/exec/java-exec/src/main/codegen/templates/Decimal/DecimalFunctions.java
+++ b/exec/java-exec/src/main/codegen/templates/Decimal/DecimalFunctions.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -133,7 +133,11 @@
 @SuppressWarnings("unused")
 public class ${type.name}Functions {
 
-    @FunctionTemplate(name = "subtract", scope = FunctionTemplate.FunctionScope.DECIMAL_ADD_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "subtract",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_ADD_SCALE,
+        nulls = NullHandling.NULL_IF_NULL,
+        checkPrecisionRange = true)
     public static class ${type.name}SubtractFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -171,7 +175,11 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "add", scope = FunctionTemplate.FunctionScope.DECIMAL_ADD_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "add",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_ADD_SCALE,
+        nulls = NullHandling.NULL_IF_NULL,
+        checkPrecisionRange = true)
     public static class ${type.name}AddFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -209,7 +217,11 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "multiply", scope = FunctionTemplate.FunctionScope.DECIMAL_MUL_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "multiply",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_SUM_SCALE,
+        nulls = NullHandling.NULL_IF_NULL,
+        checkPrecisionRange = true)
     public static class ${type.name}MultiplyFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -379,7 +391,11 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "exact_divide", scope = FunctionTemplate.FunctionScope.DECIMAL_DIV_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "exact_divide",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_DIV_SCALE,
+        nulls = NullHandling.NULL_IF_NULL,
+        checkPrecisionRange = true)
     public static class ${type.name}DivideFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -416,7 +432,11 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "mod", scope = FunctionTemplate.FunctionScope.DECIMAL_MOD_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "mod",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MOD_SCALE,
+        nulls = NullHandling.NULL_IF_NULL,
+        checkPrecisionRange = true)
     public static class ${type.name}ModFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -454,7 +474,10 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "abs", scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "abs",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}AbsFunction implements DrillSimpleFunc {
 
         @Param  ${type.name}Holder in;
@@ -500,7 +523,10 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(names = {"ceil", "ceiling"}, scope = FunctionTemplate.FunctionScope.DECIMAL_ZERO_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(names = {"ceil", "ceiling"},
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_ZERO_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}CeilFunction implements DrillSimpleFunc {
 
         @Param  ${type.name}Holder in;
@@ -566,7 +592,10 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "floor", scope = FunctionTemplate.FunctionScope.DECIMAL_ZERO_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "floor",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_ZERO_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}FloorFunction implements DrillSimpleFunc {
 
         @Param  ${type.name}Holder in;
@@ -631,7 +660,10 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(names = {"trunc", "truncate"}, scope = FunctionTemplate.FunctionScope.DECIMAL_ZERO_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(names = {"trunc", "truncate"},
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_ZERO_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}TruncateFunction implements DrillSimpleFunc {
 
         @Param  ${type.name}Holder in;
@@ -665,7 +697,10 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(names = {"trunc", "truncate"}, scope = FunctionTemplate.FunctionScope.DECIMAL_SET_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(names = {"trunc", "truncate"},
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_SET_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}TruncateScaleFunction implements DrillSimpleFunc {
 
         @Param  ${type.name}Holder left;
@@ -742,7 +777,10 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "round", scope = FunctionTemplate.FunctionScope.DECIMAL_ZERO_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "round",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_ZERO_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}RoundFunction implements DrillSimpleFunc {
 
         @Param  ${type.name}Holder in;
@@ -804,7 +842,10 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "round", scope = FunctionTemplate.FunctionScope.DECIMAL_SET_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "round",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_SET_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}RoundScaleFunction implements DrillSimpleFunc {
 
         @Param  ${type.name}Holder left;
@@ -834,8 +875,9 @@ public void eval() {
   <#-- Comparison function for sorting and grouping relational operators
        (not for comparison expression operators (=, <, etc.)). -->
   @FunctionTemplate(name = FunctionGenerationHelper.COMPARE_TO_NULLS_HIGH,
-                    scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                    nulls = NullHandling.INTERNAL)
+      scope = FunctionTemplate.FunctionScope.SIMPLE,
+      returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+      nulls = NullHandling.INTERNAL)
   public static class GCompare${leftType}Vs${rightType}NullHigh implements DrillSimpleFunc {
 
     @Param ${leftType}Holder left;
@@ -854,8 +896,9 @@ public void eval() {
   <#-- Comparison function for sorting and grouping relational operators
         (not for comparison expression operators (=, <, etc.)). -->
   @FunctionTemplate(name = FunctionGenerationHelper.COMPARE_TO_NULLS_LOW,
-                    scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                    nulls = NullHandling.INTERNAL)
+      scope = FunctionTemplate.FunctionScope.SIMPLE,
+      returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+      nulls = NullHandling.INTERNAL)
   public static class GCompare${leftType}Vs${rightType}NullLow implements DrillSimpleFunc {
 
     @Param ${leftType}Holder left;
@@ -876,8 +919,9 @@ public void eval() {
     <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
          not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "less than",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}LessThan implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -898,8 +942,9 @@ public void eval() {
     <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
          not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "less than or equal to",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}LessThanEq implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -918,8 +963,9 @@ public void eval() {
     <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
          not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "greater than",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}GreaterThan implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -938,8 +984,9 @@ public void eval() {
     <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
          not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "greater than or equal to",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}GreaterThanEq implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -958,8 +1005,9 @@ public void eval() {
     <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
          not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "Equal",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}Equal implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -978,8 +1026,9 @@ public void eval() {
     <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
          not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "not equal",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}NotEqual implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1033,8 +1082,9 @@ public void eval() {
   <#-- Comparison function for sorting and grouping relational operators
        (not for comparison expression operators (=, <, etc.)). -->
   @FunctionTemplate(name = FunctionGenerationHelper.COMPARE_TO_NULLS_HIGH,
-                    scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                    nulls = NullHandling.INTERNAL)
+      scope = FunctionTemplate.FunctionScope.SIMPLE,
+      returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+      nulls = NullHandling.INTERNAL)
   public static class GCompare${leftType}Vs${rightType}NullHigh implements DrillSimpleFunc {
 
     @Param ${leftType}Holder left;
@@ -1056,8 +1106,9 @@ public void eval() {
   <#-- Comparison function for sorting and grouping relational operators
        (not for comparison expression operators (=, <, etc.)). -->
   @FunctionTemplate(name = FunctionGenerationHelper.COMPARE_TO_NULLS_LOW,
-                    scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                    nulls = NullHandling.INTERNAL)
+      scope = FunctionTemplate.FunctionScope.SIMPLE,
+      returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+      nulls = NullHandling.INTERNAL)
   public static class GCompare${leftType}Vs${rightType}NullLow implements DrillSimpleFunc {
 
     @Param ${leftType}Holder left;
@@ -1083,8 +1134,9 @@ public void eval() {
     <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
          not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "less than",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}LessThan implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1101,8 +1153,9 @@ public void eval() {
     <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
          not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "less than or equal to",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}LessThanEq implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1119,8 +1172,9 @@ public void eval() {
     <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
          not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "greater than",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}GreaterThan implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1137,8 +1191,9 @@ public void eval() {
     <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
          not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "greater than or equal to",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}GreaterThanEq implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1155,8 +1210,9 @@ public void eval() {
     <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
          not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "Equal",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}Equal implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1174,8 +1230,9 @@ public void eval() {
     <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
          not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "not equal",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}NotEqual implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1218,7 +1275,11 @@ public void eval() {
 @SuppressWarnings("unused")
 public class ${type.name}Functions {
 
-    @FunctionTemplate(name = "add", scope = FunctionTemplate.FunctionScope.DECIMAL_ADD_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "add",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_ADD_SCALE,
+        nulls = NullHandling.NULL_IF_NULL,
+        checkPrecisionRange = true)
     public static class ${type.name}AddFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1247,7 +1308,11 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "subtract", scope = FunctionTemplate.FunctionScope.DECIMAL_ADD_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "subtract",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_ADD_SCALE,
+        nulls = NullHandling.NULL_IF_NULL,
+        checkPrecisionRange = true)
     public static class ${type.name}SubtractFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1274,7 +1339,12 @@ public void eval() {
             result.scale = outputScale;
         }
     }
-    @FunctionTemplate(name = "multiply", scope = FunctionTemplate.FunctionScope.DECIMAL_MUL_SCALE, nulls = NullHandling.NULL_IF_NULL)
+
+    @FunctionTemplate(name = "multiply",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_SUM_SCALE,
+        nulls = NullHandling.NULL_IF_NULL,
+        checkPrecisionRange = true)
     public static class ${type.name}MultiplyFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1300,7 +1370,10 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "abs", scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "abs",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}AbsFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder in;
@@ -1320,7 +1393,11 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "exact_divide", scope = FunctionTemplate.FunctionScope.DECIMAL_DIV_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "exact_divide",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_DIV_SCALE,
+        nulls = NullHandling.NULL_IF_NULL,
+        checkPrecisionRange = true)
     public static class ${type.name}DivideFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1353,7 +1430,11 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "mod", scope = FunctionTemplate.FunctionScope.DECIMAL_MOD_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "mod",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MOD_SCALE,
+        nulls = NullHandling.NULL_IF_NULL,
+        checkPrecisionRange = true)
     public static class ${type.name}ModFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1399,7 +1480,10 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(names = {"trunc", "truncate"}, scope = FunctionTemplate.FunctionScope.DECIMAL_ZERO_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(names = {"trunc", "truncate"},
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_ZERO_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}TruncFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder in;
@@ -1415,7 +1499,10 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(names = {"trunc", "truncate"}, scope = FunctionTemplate.FunctionScope.DECIMAL_SET_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(names = {"trunc", "truncate"},
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_SET_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}TruncateScaleFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1432,7 +1519,10 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(names = {"ceil", "ceiling"}, scope = FunctionTemplate.FunctionScope.DECIMAL_ZERO_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(names = {"ceil", "ceiling"},
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_ZERO_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}CeilFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder in;
@@ -1459,7 +1549,10 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "floor", scope = FunctionTemplate.FunctionScope.DECIMAL_ZERO_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "floor",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_ZERO_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}FloorFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder in;
@@ -1484,7 +1577,10 @@ public void eval() {
         }
     }
 
-    @FunctionTemplate(name = "round", scope = FunctionTemplate.FunctionScope.DECIMAL_ZERO_SCALE, nulls = NullHandling.NULL_IF_NULL)
+    @FunctionTemplate(name = "round",
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_ZERO_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}RoundFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder in;
@@ -1518,8 +1614,9 @@ public void eval() {
     }
 
     @FunctionTemplate(name = "round",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_SET_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_SET_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}RoundScaleFunction implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1577,8 +1674,9 @@ public void eval() {
   <#-- Comparison function for sorting and grouping relational operators
        (not for comparison expression operators (=, <, etc.)). -->
   @FunctionTemplate(name = FunctionGenerationHelper.COMPARE_TO_NULLS_HIGH,
-                    scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                    nulls = NullHandling.INTERNAL)
+      scope = FunctionTemplate.FunctionScope.SIMPLE,
+      returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+      nulls = NullHandling.INTERNAL)
   public static class GCompare${leftType}Vs${rightType}NullHigh implements DrillSimpleFunc {
 
     @Param ${leftType}Holder left;
@@ -1601,8 +1699,9 @@ public void eval() {
   <#-- Comparison function for sorting and grouping relational operators
        (not for comparison expression operators (=, <, etc.)). -->
   @FunctionTemplate(name = FunctionGenerationHelper.COMPARE_TO_NULLS_LOW,
-                    scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                    nulls = NullHandling.INTERNAL)
+    scope = FunctionTemplate.FunctionScope.SIMPLE,
+    returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+    nulls = NullHandling.INTERNAL)
   public static class GCompare${leftType}Vs${rightType}NullLow implements DrillSimpleFunc {
 
     @Param ${leftType}Holder left;
@@ -1627,8 +1726,9 @@ public void eval() {
     <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
          not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "less than",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}LessThan implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1645,8 +1745,9 @@ public void eval() {
      <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
           not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "less than or equal to",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}LessThanEq implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1663,8 +1764,9 @@ public void eval() {
      <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
           not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "greater than",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+        scope = FunctionTemplate.FunctionScope.SIMPLE,
+        returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+        nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}GreaterThan implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1681,8 +1783,9 @@ public void eval() {
      <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
           not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "greater than or equal to",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+            scope = FunctionTemplate.FunctionScope.SIMPLE,
+            returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+            nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}GreaterThanEq implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1699,8 +1802,9 @@ public void eval() {
      <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
           not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "Equal",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+            scope = FunctionTemplate.FunctionScope.SIMPLE,
+            returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+            nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}Equal implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
@@ -1718,8 +1822,9 @@ public void eval() {
      <#-- Comparison function for comparison expression operator (=, &lt;, etc.),
           not for sorting and grouping relational operators.) -->
     @FunctionTemplate(name = "not equal",
-                      scope = FunctionTemplate.FunctionScope.DECIMAL_MAX_SCALE,
-                      nulls = NullHandling.NULL_IF_NULL)
+            scope = FunctionTemplate.FunctionScope.SIMPLE,
+            returnType = FunctionTemplate.ReturnType.DECIMAL_MAX_SCALE,
+            nulls = NullHandling.NULL_IF_NULL)
     public static class ${type.name}NotEqual implements DrillSimpleFunc {
 
         @Param ${type.name}Holder left;
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/ClassGenerator.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/ClassGenerator.java
index c2ca4928e51..c94bed57224 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/ClassGenerator.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/ClassGenerator.java
@@ -36,7 +36,7 @@
 import org.apache.drill.exec.compile.sig.MappingSet;
 import org.apache.drill.exec.compile.sig.SignatureHolder;
 import org.apache.drill.exec.exception.SchemaChangeException;
-import org.apache.drill.exec.expr.fn.DrillFuncHolder.WorkspaceReference;
+import org.apache.drill.exec.expr.fn.WorkspaceReference;
 import org.apache.drill.exec.record.TypedFieldId;
 
 import com.google.common.base.Preconditions;
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/EvaluationVisitor.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/EvaluationVisitor.java
index 73a03632bbf..f299df210bc 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/EvaluationVisitor.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/EvaluationVisitor.java
@@ -572,7 +572,7 @@ private HoldingContainer visitReturnValueExpression(ReturnValueExpression e, Cla
     @Override
     public HoldingContainer visitQuotedStringConstant(QuotedString e, ClassGenerator<?> generator)
         throws RuntimeException {
-      MajorType majorType = Types.required(MinorType.VARCHAR);
+      MajorType majorType = e.getMajorType();
       JBlock setup = generator.getBlock(BlockType.SETUP);
       JType holderType = generator.getHolderType(majorType);
       JVar var = generator.declareClassField("string", holderType);
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/ExpressionTreeMaterializer.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/ExpressionTreeMaterializer.java
index b461b5cfa29..f14d81676a4 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/ExpressionTreeMaterializer.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/ExpressionTreeMaterializer.java
@@ -216,7 +216,7 @@ public static LogicalExpression addCastExpression(LogicalExpression fromExpr, Ma
        * using an arbitrary value. We trim down the size of the stored bytes
        * to the actual size so this size doesn't really matter.
        */
-      castArgs.add(new ValueExpressions.LongExpression(TypeHelper.VARCHAR_DEFAULT_CAST_LEN, null));
+      castArgs.add(new ValueExpressions.LongExpression(Types.MAX_VARCHAR_LENGTH, null));
     }
     else if (CoreDecimalUtility.isDecimalType(toType)) {
       // Add the scale and precision to the arguments of the implicit cast
@@ -573,7 +573,7 @@ private LogicalExpression rewriteUnionFunction(FunctionCall call, FunctionLookup
      * @return
      */
     private LogicalExpression getExceptionFunction(String message) {
-      QuotedString msg = new QuotedString(message, ExpressionPosition.UNKNOWN);
+      QuotedString msg = new QuotedString(message, message.length(), ExpressionPosition.UNKNOWN);
       List<LogicalExpression> args = Lists.newArrayList();
       args.add(msg);
       FunctionCall call = new FunctionCall(ExceptionFunction.EXCEPTION_FUNCTION_NAME, args, ExpressionPosition.UNKNOWN);
@@ -855,8 +855,9 @@ public LogicalExpression visitCastExpression(CastExpression e, FunctionLookupCon
         // if the type still isn't fully bound, leave as cast expression.
         return new CastExpression(input, e.getMajorType(), e.getPosition());
       } else if (newMinor == MinorType.NULL) {
-        // if input is a NULL expression, remove cast expression and return a TypedNullConstant directly.
-        return new TypedNullConstant(Types.optional(e.getMajorType().getMinorType()));
+        // if input is a NULL expression, remove cast expression and return a TypedNullConstant directly
+        // preserve original precision and scale if present
+        return new TypedNullConstant(e.getMajorType().toBuilder().setMode(DataMode.OPTIONAL).build());
       } else {
         // if the type is fully bound, convert to functioncall and materialze the function.
         MajorType type = e.getMajorType();
@@ -869,11 +870,12 @@ public LogicalExpression visitCastExpression(CastExpression e, FunctionLookupCon
 
         //VarLen type
         if (!Types.isFixedWidthType(type)) {
-          newArgs.add(new ValueExpressions.LongExpression(type.getWidth(), null));
+          newArgs.add(new ValueExpressions.LongExpression(type.getPrecision(), null));
         }  if (CoreDecimalUtility.isDecimalType(type)) {
             newArgs.add(new ValueExpressions.LongExpression(type.getPrecision(), null));
             newArgs.add(new ValueExpressions.LongExpression(type.getScale(), null));
         }
+
         FunctionCall fc = new FunctionCall(castFuncWithType, newArgs, e.getPosition());
         return fc.accept(this, functionLookupContext);
       }
@@ -930,11 +932,7 @@ private boolean castEqual(ExpressionPosition pos, MajorType from, MajorType to)
         // 2) or "to" length is unknown (0 means unknown length?).
         // Case 1 and case 2 mean that cast will do nothing.
         // In other cases, cast is required to trim the "from" according to "to" length.
-        if ( (to.getWidth() >= from.getWidth() && from.getWidth() > 0) || to.getWidth() == 0) {
-          return true;
-        } else {
-          return false;
-        }
+        return (to.getPrecision() >= from.getPrecision() && from.getPrecision() > 0) || to.getPrecision() == 0;
 
       default:
         errorCollector.addGeneralError(pos, String.format("Casting rules are unknown for type %s.", from));
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/annotations/FunctionTemplate.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/annotations/FunctionTemplate.java
index f43b25341bf..ac4ba07bb16 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/annotations/FunctionTemplate.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/annotations/FunctionTemplate.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -17,10 +17,23 @@
  */
 package org.apache.drill.exec.expr.annotations;
 
+import org.apache.drill.common.expression.LogicalExpression;
+import org.apache.drill.common.types.TypeProtos;
+import org.apache.drill.exec.expr.fn.FunctionAttributes;
+import org.apache.drill.exec.expr.fn.FunctionInitializer;
+import org.apache.drill.exec.expr.fn.output.ConcatReturnTypeInference;
+import org.apache.drill.exec.expr.fn.output.DecimalReturnTypeInference;
+import org.apache.drill.exec.expr.fn.output.DefaultReturnTypeInference;
+import org.apache.drill.exec.expr.fn.output.PadReturnTypeInference;
+import org.apache.drill.exec.expr.fn.output.ReturnTypeInference;
+import org.apache.drill.exec.expr.fn.output.SameInOutLengthReturnTypeInference;
+import org.apache.drill.exec.expr.fn.output.StringCastReturnTypeInference;
+
 import java.lang.annotation.ElementType;
 import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.lang.annotation.Target;
+import java.util.List;
 
 
 @Retention(RetentionPolicy.RUNTIME)
@@ -36,7 +49,7 @@
    *   to resolve the current issue of spaces vs. underlines in names (e.g., we
    *   have both "less_than" and "less than".
    * </p>
-   * @return
+   * @return function name
    */
   String name() default "";
 
@@ -49,11 +62,12 @@
    *   to resolve the current issue of spaces vs. underlines in names (e.g., we
    *   have both "less_than" and "less than".
    * </p>
-   * @return
+   * @return list of function names
    */
   String[] names() default {};
 
   FunctionScope scope();
+  ReturnType returnType() default ReturnType.DEFAULT;
   NullHandling nulls() default NullHandling.INTERNAL;
   boolean isBinaryCommutative() default false;
   boolean isRandom()  default false;
@@ -61,22 +75,21 @@
   FunctionCostCategory costCategory() default FunctionCostCategory.SIMPLE;
 
   /**
-   * Set Operand type-checking strategy for an operator which takes no operands and need to be invoked
-   * without parentheses. E.g.: session_id is a niladic function.
+   * <p>Set Operand type-checking strategy for an operator which takes no operands and need to be invoked
+   * without parentheses. E.g.: session_id is a niladic function.</p>
    *
-   * Niladic functions override columns that have names same as any niladic function. Such columns cannot be
+   * <p>Niladic functions override columns that have names same as any niladic function. Such columns cannot be
    * queried without the table qualification. Value of the niladic function is returned when table
-   * qualification is not used.
-   *
-   * For e.g. in the case of session_id:
-   *
-   * select session_id from <table> -> returns the value of niladic function session_id
-   * select t1.session_id from <table> t1 -> returns session_id column value from <table>
+   * qualification is not used.</p>
    *
+   * <p>For e.g. in the case of session_id:<br/>
+   * select session_id from table -> returns the value of niladic function session_id<br/>
+   * select t1.session_id from table t1 -> returns session_id column value from table<p>
    */
   boolean isNiladic() default false;
+  boolean checkPrecisionRange() default false;
 
-  public static enum NullHandling {
+  public enum NullHandling {
     /**
      * Method handles nulls.
      */
@@ -88,33 +101,61 @@ public static enum NullHandling {
      * either input is NULL, and therefore that the method must not be called
      * with null inputs.  (The calling framework must handle NULLs.)
      */
-    NULL_IF_NULL;
+    NULL_IF_NULL
   }
 
-  public static enum FunctionScope {
+  /**
+   * Function scope is used to indicate function output rows relation:
+   * simple / scalar (1 -> 1) or aggregate (n -> 1).
+   */
+  public enum FunctionScope {
     SIMPLE,
     POINT_AGGREGATE,
-    DECIMAL_AGGREGATE,
-    DECIMAL_SUM_AGGREGATE,
     HOLISTIC_AGGREGATE,
-    RANGE_AGGREGATE,
-    DECIMAL_MAX_SCALE,
-    DECIMAL_MUL_SCALE,
-    DECIMAL_CAST,
-    DECIMAL_DIV_SCALE,
-    DECIMAL_MOD_SCALE,
-    DECIMAL_ADD_SCALE,
-    DECIMAL_SET_SCALE,
-    DECIMAL_ZERO_SCALE,
-    SC_BOOLEAN_OPERATOR
+    RANGE_AGGREGATE
+  }
+
+  /**
+   * Return type enum is used to indicate which return type calculation logic
+   * should be used for functions.
+   */
+  public enum ReturnType {
+    DEFAULT(DefaultReturnTypeInference.INSTANCE),
+
+    STRING_CAST(StringCastReturnTypeInference.INSTANCE),
+    CONCAT(ConcatReturnTypeInference.INSTANCE),
+    PAD(PadReturnTypeInference.INSTANCE),
+    SAME_IN_OUT_LENGTH(SameInOutLengthReturnTypeInference.INSTANCE),
+
+    DECIMAL_AGGREGATE(DecimalReturnTypeInference.DecimalAggReturnTypeInference.INSTANCE),
+    DECIMAL_SUM_AGGREGATE(DecimalReturnTypeInference.DecimalSumAggReturnTypeInference.INSTANCE),
+    DECIMAL_MAX_SCALE(DecimalReturnTypeInference.DecimalMaxScaleReturnTypeInference.INSTANCE),
+    DECIMAL_SUM_SCALE(DecimalReturnTypeInference.DecimalSumScaleReturnTypeInference.INSTANCE),
+    DECIMAL_CAST(DecimalReturnTypeInference.DecimalCastReturnTypeInference.INSTANCE),
+    DECIMAL_DIV_SCALE(DecimalReturnTypeInference.DecimalDivScaleReturnTypeInference.INSTANCE),
+    DECIMAL_MOD_SCALE(DecimalReturnTypeInference.DecimalModScaleReturnTypeInference.INSTANCE),
+    DECIMAL_ADD_SCALE(DecimalReturnTypeInference.DecimalAddReturnTypeInference.INSTANCE),
+    DECIMAL_SET_SCALE(DecimalReturnTypeInference.DecimalSetScaleReturnTypeInference.INSTANCE),
+    DECIMAL_ZERO_SCALE(DecimalReturnTypeInference.DecimalZeroScaleReturnTypeInference.INSTANCE);
+
+    private final ReturnTypeInference inference;
+
+    ReturnType(ReturnTypeInference inference) {
+      this.inference = inference;
+    }
+
+    public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+      return inference.getType(logicalExpressions, attributes);
+    }
+
   }
 
-  public static enum FunctionCostCategory {
+  public enum FunctionCostCategory {
     SIMPLE(1), MEDIUM(20), COMPLEX(50);
 
     private final int value;
 
-    private FunctionCostCategory(int value) {
+    FunctionCostCategory(int value) {
       this.value = value;
     }
 
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillAggFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillAggFuncHolder.java
index 9493b4dc4e7..a52cc165440 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillAggFuncHolder.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillAggFuncHolder.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -18,10 +18,6 @@
 package org.apache.drill.exec.expr.fn;
 
 import static com.google.common.base.Preconditions.checkArgument;
-import static com.google.common.base.Preconditions.checkNotNull;
-
-import java.util.List;
-import java.util.Map;
 
 import org.apache.drill.common.exceptions.DrillRuntimeException;
 import org.apache.drill.common.types.TypeProtos.DataMode;
@@ -30,8 +26,6 @@
 import org.apache.drill.exec.expr.ClassGenerator;
 import org.apache.drill.exec.expr.ClassGenerator.BlockType;
 import org.apache.drill.exec.expr.ClassGenerator.HoldingContainer;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.FunctionCostCategory;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.FunctionScope;
 import org.apache.drill.exec.expr.annotations.FunctionTemplate.NullHandling;
 import org.apache.drill.exec.record.TypedFieldId;
 
@@ -44,7 +38,6 @@
 import com.sun.codemodel.JForLoop;
 import com.sun.codemodel.JInvocation;
 import com.sun.codemodel.JMod;
-import com.sun.codemodel.JType;
 import com.sun.codemodel.JVar;
 
 class DrillAggFuncHolder extends DrillFuncHolder {
@@ -98,15 +91,15 @@ public JVar[] renderStart(ClassGenerator<?> g, HoldingContainer[] inputVariables
         //Loop through all workspace vectors, to get the minimum of size of all workspace vectors.
         JVar sizeVar = setupBlock.decl(g.getModel().INT, "vectorSize", JExpr.lit(Integer.MAX_VALUE));
         JClass mathClass = g.getModel().ref(Math.class);
-        for (int id = 0; id<workspaceVars.length; id ++) {
-          if (!workspaceVars[id].isInject()) {
-            setupBlock.assign(sizeVar,mathClass.staticInvoke("min").arg(sizeVar).arg(g.getWorkspaceVectors().get(workspaceVars[id]).invoke("getValueCapacity")));
+        for (int id = 0; id < getWorkspaceVars().length; id ++) {
+          if (!getWorkspaceVars()[id].isInject()) {
+            setupBlock.assign(sizeVar,mathClass.staticInvoke("min").arg(sizeVar).arg(g.getWorkspaceVectors().get(getWorkspaceVars()[id]).invoke("getValueCapacity")));
           }
         }
 
-        for(int i =0 ; i < workspaceVars.length; i++) {
-          if (!workspaceVars[i].isInject()) {
-            setupBlock.assign(workspaceJVars[i], JExpr._new(g.getHolderType(workspaceVars[i].majorType)));
+        for(int i =0 ; i < getWorkspaceVars().length; i++) {
+          if (!getWorkspaceVars()[i].isInject()) {
+            setupBlock.assign(workspaceJVars[i], JExpr._new(g.getHolderType(getWorkspaceVars()[i].getMajorType())));
           }
         }
 
@@ -133,10 +126,10 @@ public void renderMiddle(ClassGenerator<?> g, HoldingContainer[] inputVariables,
 
   @Override
   public HoldingContainer renderEnd(ClassGenerator<?> g, HoldingContainer[] inputVariables, JVar[]  workspaceJVars) {
-    HoldingContainer out = g.declare(returnValue.type, false);
+    HoldingContainer out = g.declare(getReturnType(), false);
     JBlock sub = new JBlock();
     g.getEvalBlock().add(sub);
-    JVar internalOutput = sub.decl(JMod.FINAL, g.getHolderType(returnValue.type), returnValue.name, JExpr._new(g.getHolderType(returnValue.type)));
+    JVar internalOutput = sub.decl(JMod.FINAL, g.getHolderType(getReturnType()), getReturnValue().getName(), JExpr._new(g.getHolderType(getReturnType())));
     addProtectedBlock(g, sub, output(), null, workspaceJVars, false);
     sub.assign(out.getHolder(), internalOutput);
         //hash aggregate uses workspace vectors. Initialization is done in "setup" and does not require "reset" block.
@@ -150,25 +143,27 @@ public HoldingContainer renderEnd(ClassGenerator<?> g, HoldingContainer[] inputV
 
 
   private JVar[] declareWorkspaceVectors(ClassGenerator<?> g) {
-    JVar[] workspaceJVars = new JVar[workspaceVars.length];
+    JVar[] workspaceJVars = new JVar[getWorkspaceVars().length];
 
-    for(int i =0 ; i < workspaceVars.length; i++){
-      if (workspaceVars[i].isInject() == true) {
-        workspaceJVars[i] = g.declareClassField("work", g.getModel()._ref(workspaceVars[i].type));
+    for(int i =0 ; i < getWorkspaceVars().length; i++){
+      if (getWorkspaceVars()[i].isInject()) {
+        workspaceJVars[i] = g.declareClassField("work", g.getModel()._ref(getWorkspaceVars()[i].getType()));
         g.getBlock(BlockType.SETUP).assign(workspaceJVars[i], g.getMappingSet().getIncoming().invoke("getContext").invoke("getManagedBuffer"));
       } else {
-        Preconditions.checkState(Types.isFixedWidthType(workspaceVars[i].majorType), String.format("Workspace variable '%s' in aggregation function '%s' is not allowed to have variable length type.", workspaceVars[i].name, registeredNames[0]));
-        Preconditions.checkState(workspaceVars[i].majorType.getMode()==DataMode.REQUIRED, String.format("Workspace variable '%s' in aggregation function '%s' is not allowed to have null or repeated type.", workspaceVars[i].name, registeredNames[0]));
+        Preconditions.checkState(Types.isFixedWidthType(getWorkspaceVars()[i].getMajorType()), String.format("Workspace variable '%s' in aggregation function '%s' is not allowed to " +
+            "have variable length type.", getWorkspaceVars()[i].getName(), getRegisteredNames()[0]));
+        Preconditions.checkState(getWorkspaceVars()[i].getMajorType().getMode()==DataMode.REQUIRED, String.format("Workspace variable '%s' in aggregation function '%s' is not allowed" +
+            " to have null or repeated type.", getWorkspaceVars()[i].getName(), getRegisteredNames()[0]));
 
         //workspaceJVars[i] = g.declareClassField("work", g.getHolderType(workspaceVars[i].majorType), JExpr._new(g.getHolderType(workspaceVars[i].majorType)));
-        workspaceJVars[i] = g.declareClassField("work", g.getHolderType(workspaceVars[i].majorType));
+        workspaceJVars[i] = g.declareClassField("work", g.getHolderType(getWorkspaceVars()[i].getMajorType()));
 
         //Declare a workspace vector for the workspace var.
-        TypedFieldId typedFieldId = new TypedFieldId(workspaceVars[i].majorType, g.getWorkspaceTypes().size());
+        TypedFieldId typedFieldId = new TypedFieldId(getWorkspaceVars()[i].getMajorType(), g.getWorkspaceTypes().size());
         JVar vv  = g.declareVectorValueSetupAndMember(g.getMappingSet().getWorkspace(), typedFieldId);
 
         g.getWorkspaceTypes().add(typedFieldId);
-        g.getWorkspaceVectors().put(workspaceVars[i], vv);
+        g.getWorkspaceVectors().put(getWorkspaceVars()[i], vv);
       }
     }
     return workspaceJVars;
@@ -179,9 +174,9 @@ private JBlock generateInitWorkspaceBlockHA(ClassGenerator<?> g, BlockType bt, S
     if(!Strings.isNullOrEmpty(body) && !body.trim().isEmpty()){
       JBlock sub = new JBlock(true, true);
       addProtectedBlockHA(g, sub, body, null, workspaceJVars, wsIndexVariable);
-      initBlock.directStatement(String.format("/** start %s for function %s **/ ", bt.name(), registeredNames[0]));
+      initBlock.directStatement(String.format("/** start %s for function %s **/ ", bt.name(), getRegisteredNames()[0]));
       initBlock.add(sub);
-      initBlock.directStatement(String.format("/** end %s for function %s **/ ", bt.name(), registeredNames[0]));
+      initBlock.directStatement(String.format("/** end %s for function %s **/ ", bt.name(), getRegisteredNames()[0]));
     }
     return initBlock;
   }
@@ -202,28 +197,28 @@ protected void addProtectedBlock(ClassGenerator<?> g, JBlock sub, String body, H
   private void addProtectedBlockHA(ClassGenerator<?> g, JBlock sub, String body, HoldingContainer[] inputVariables, JVar[] workspaceJVars, JExpression wsIndexVariable){
     if (inputVariables != null){
       for(int i =0; i < inputVariables.length; i++){
-        ValueReference parameter = parameters[i];
+        ValueReference parameter = getParameters()[i];
         HoldingContainer inputVariable = inputVariables[i];
-        sub.decl(inputVariable.getHolder().type(), parameter.name, inputVariable.getHolder());
+        sub.decl(inputVariable.getHolder().type(), parameter.getName(), inputVariable.getHolder());
       }
     }
 
     JVar[] internalVars = new JVar[workspaceJVars.length];
     for(int i =0; i < workspaceJVars.length; i++){
 
-      if (workspaceVars[i].isInject()) {
-        internalVars[i] = sub.decl(g.getModel()._ref(workspaceVars[i].type), workspaceVars[i].name, workspaceJVars[i]);
+      if (getWorkspaceVars()[i].isInject()) {
+        internalVars[i] = sub.decl(g.getModel()._ref(getWorkspaceVars()[i].getType()), getWorkspaceVars()[i].getName(), workspaceJVars[i]);
         continue;
       }
       //sub.assign(workspaceJVars[i], JExpr._new(g.getHolderType(workspaceVars[i].majorType)));
       //Access workspaceVar through workspace vector.
-      JInvocation getValueAccessor = g.getWorkspaceVectors().get(workspaceVars[i]).invoke("getAccessor").invoke("get");
-      if (Types.usesHolderForGet(workspaceVars[i].majorType)) {
+      JInvocation getValueAccessor = g.getWorkspaceVectors().get(getWorkspaceVars()[i]).invoke("getAccessor").invoke("get");
+      if (Types.usesHolderForGet(getWorkspaceVars()[i].getMajorType())) {
         sub.add(getValueAccessor.arg(wsIndexVariable).arg(workspaceJVars[i]));
       } else {
         sub.assign(workspaceJVars[i].ref("value"), getValueAccessor.arg(wsIndexVariable));
       }
-      internalVars[i] = sub.decl(g.getHolderType(workspaceVars[i].majorType),  workspaceVars[i].name, workspaceJVars[i]);
+      internalVars[i] = sub.decl(g.getHolderType(getWorkspaceVars()[i].getMajorType()),  getWorkspaceVars()[i].getName(), workspaceJVars[i]);
     }
 
     Preconditions.checkNotNull(body);
@@ -234,19 +229,19 @@ private void addProtectedBlockHA(ClassGenerator<?> g, JBlock sub, String body, H
       sub.assign(workspaceJVars[i], internalVars[i]);
 
       // Injected buffers are not stored as vectors skip storing them in vectors
-      if (workspaceVars[i].isInject()) {
+      if (getWorkspaceVars()[i].isInject()) {
         continue;
       }
       //Change workspaceVar through workspace vector.
       JInvocation setMeth;
-      MajorType type = workspaceVars[i].majorType;
+      MajorType type = getWorkspaceVars()[i].getMajorType();
       if (Types.usesHolderForGet(type)) {
-          setMeth = g.getWorkspaceVectors().get(workspaceVars[i]).invoke("getMutator").invoke("setSafe").arg(wsIndexVariable).arg(workspaceJVars[i]);
+          setMeth = g.getWorkspaceVectors().get(getWorkspaceVars()[i]).invoke("getMutator").invoke("setSafe").arg(wsIndexVariable).arg(workspaceJVars[i]);
       }else{
         if (!Types.isFixedWidthType(type) || Types.isRepeated(type)) {
-          setMeth = g.getWorkspaceVectors().get(workspaceVars[i]).invoke("getMutator").invoke("setSafe").arg(wsIndexVariable).arg(workspaceJVars[i].ref("value"));
+          setMeth = g.getWorkspaceVectors().get(getWorkspaceVars()[i]).invoke("getMutator").invoke("setSafe").arg(wsIndexVariable).arg(workspaceJVars[i].ref("value"));
         } else {
-          setMeth = g.getWorkspaceVectors().get(workspaceVars[i]).invoke("getMutator").invoke("set").arg(wsIndexVariable).arg(workspaceJVars[i].ref("value"));
+          setMeth = g.getWorkspaceVectors().get(getWorkspaceVars()[i]).invoke("getMutator").invoke("set").arg(wsIndexVariable).arg(workspaceJVars[i].ref("value"));
         }
       }
 
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillBooleanOPHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillBooleanOPHolder.java
deleted file mode 100644
index af1d84f30c6..00000000000
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillBooleanOPHolder.java
+++ /dev/null
@@ -1,27 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.drill.exec.expr.fn;
-
-public class DrillBooleanOPHolder extends DrillSimpleFuncHolder{
-
-  public DrillBooleanOPHolder(FunctionAttributes functionAttributes, FunctionInitializer initializer) {
-    super(functionAttributes, initializer);
-  }
-
-}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillComplexWriterFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillComplexWriterFuncHolder.java
index a0bf134b987..2488e41b26d 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillComplexWriterFuncHolder.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillComplexWriterFuncHolder.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -32,7 +32,7 @@
 import com.sun.codemodel.JInvocation;
 import com.sun.codemodel.JVar;
 
-public class DrillComplexWriterFuncHolder extends DrillSimpleFuncHolder{
+public class DrillComplexWriterFuncHolder extends DrillSimpleFuncHolder {
 
   private FieldReference ref;
 
@@ -51,7 +51,7 @@ public FieldReference getReference() {
   @Override
   protected HoldingContainer generateEvalBody(ClassGenerator<?> g, HoldingContainer[] inputVariables, String body, JVar[] workspaceJVars) {
 
-    g.getEvalBlock().directStatement(String.format("//---- start of eval portion of %s function. ----//", registeredNames[0]));
+    g.getEvalBlock().directStatement(String.format("//---- start of eval portion of %s function. ----//", getRegisteredNames()[0]));
 
     JBlock sub = new JBlock(true, true);
     JBlock topSub = sub;
@@ -75,7 +75,7 @@ protected HoldingContainer generateEvalBody(ClassGenerator<?> g, HoldingContaine
 
     g.getEvalBlock().add(complexWriter.invoke("setPosition").arg(g.getMappingSet().getValueWriteIndex()));
 
-    sub.decl(g.getModel()._ref(ComplexWriter.class), returnValue.name, complexWriter);
+    sub.decl(g.getModel()._ref(ComplexWriter.class), getReturnValue().getName(), complexWriter);
 
     // add the subblock after the out declaration.
     g.getEvalBlock().add(topSub);
@@ -91,7 +91,7 @@ protected HoldingContainer generateEvalBody(ClassGenerator<?> g, HoldingContaine
 
     //jc._else().directStatement("System.out.println(\"debug : write successful, inIndex = \" + inIndex);");
 
-    g.getEvalBlock().directStatement(String.format("//---- end of eval portion of %s function. ----//", registeredNames[0]));
+    g.getEvalBlock().directStatement(String.format("//---- end of eval portion of %s function. ----//", getRegisteredNames()[0]));
 
     return null;
   }
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalAddFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalAddFuncHolder.java
deleted file mode 100644
index 00ad1f5597d..00000000000
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalAddFuncHolder.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.drill.exec.expr.fn;
-
-import java.util.List;
-import java.util.Map;
-
-import org.apache.drill.common.expression.LogicalExpression;
-import org.apache.drill.common.types.TypeProtos;
-import org.apache.drill.common.types.TypeProtos.MajorType;
-import org.apache.drill.common.util.DecimalScalePrecisionAddFunction;
-import org.apache.drill.exec.expr.DrillSimpleFunc;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.FunctionScope;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.NullHandling;
-import org.apache.drill.exec.util.DecimalUtility;
-
-public class DrillDecimalAddFuncHolder extends DrillSimpleFuncHolder{
-
-  public DrillDecimalAddFuncHolder(FunctionAttributes functionAttributes, FunctionInitializer initializer) {
-    super(functionAttributes, initializer);
-  }
-
-  /*
-   * This function scope is used by add and subtract functions for decimal data type.
-   * DecimalScalePrecisionAddFunction is used to compute the output types'
-   * scale and precision
-   */
-  @Override
-  public MajorType getReturnType(List<LogicalExpression> args) {
-
-    TypeProtos.DataMode mode = returnValue.type.getMode();
-
-    if (nullHandling == NullHandling.NULL_IF_NULL) {
-      // if any one of the input types is nullable, then return nullable return type
-      for (LogicalExpression e : args) {
-        if (e.getMajorType().getMode() == TypeProtos.DataMode.OPTIONAL) {
-          mode = TypeProtos.DataMode.OPTIONAL;
-          break;
-        }
-      }
-    }
-
-
-    /* Get the result's scale and precision. This is a function scope for add function, assert we have
-     * only two inputs
-     */
-    assert args.size() == 2;
-
-    DecimalScalePrecisionAddFunction outputScalePrec =
-        new DecimalScalePrecisionAddFunction(args.get(0).getMajorType().getPrecision(), args.get(0).getMajorType().getScale(),
-            args.get(1).getMajorType().getPrecision(), args.get(1).getMajorType().getScale());
-    return (TypeProtos.MajorType.newBuilder().setMinorType(DecimalUtility.getDecimalDataType(outputScalePrec.getOutputPrecision()))
-        .setScale(outputScalePrec.getOutputScale()).setPrecision(outputScalePrec.getOutputPrecision()).setMode(mode).build());
-  }
-
-  @Override
-  public boolean checkPrecisionRange() {
-    return true;
-  }
-}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalAggFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalAggFuncHolder.java
deleted file mode 100644
index 78d865c6bc1..00000000000
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalAggFuncHolder.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.drill.exec.expr.fn;
-
-import java.util.List;
-
-import org.apache.drill.common.expression.LogicalExpression;
-import org.apache.drill.common.types.TypeProtos;
-
-public class DrillDecimalAggFuncHolder extends DrillAggFuncHolder {
-
-  public DrillDecimalAggFuncHolder(FunctionAttributes attributes, FunctionInitializer initializer) {
-    super(attributes, initializer);
-  }
-
-  @Override
-  public TypeProtos.MajorType getReturnType(List<LogicalExpression> args) {
-
-    int scale = 0;
-    int precision = 0;
-
-    // Get the max scale and precision from the inputs
-    for (LogicalExpression e : args) {
-      scale = Math.max(scale, e.getMajorType().getScale());
-      precision = Math.max(precision, e.getMajorType().getPrecision());
-    }
-
-    return (TypeProtos.MajorType.newBuilder().setMinorType(returnValue.type.getMinorType()).setScale(scale).setPrecision(precision).setMode(TypeProtos.DataMode.REQUIRED).build());
-  }
-}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalCastFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalCastFuncHolder.java
deleted file mode 100644
index 2fb9e288cad..00000000000
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalCastFuncHolder.java
+++ /dev/null
@@ -1,62 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.drill.exec.expr.fn;
-
-import java.util.List;
-
-import org.apache.drill.common.exceptions.DrillRuntimeException;
-import org.apache.drill.common.expression.LogicalExpression;
-import org.apache.drill.common.expression.ValueExpressions;
-import org.apache.drill.common.types.TypeProtos;
-import org.apache.drill.common.types.TypeProtos.MajorType;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.NullHandling;
-
-public class DrillDecimalCastFuncHolder extends DrillSimpleFuncHolder {
-
-  public DrillDecimalCastFuncHolder(FunctionAttributes functionAttributes, FunctionInitializer initializer) {
-    super(functionAttributes, initializer);
-  }
-
-    @Override
-    public MajorType getReturnType(List<LogicalExpression> args) {
-
-        TypeProtos.DataMode mode = returnValue.type.getMode();
-
-        if (nullHandling == NullHandling.NULL_IF_NULL) {
-            // if any one of the input types is nullable, then return nullable return type
-            for (LogicalExpression e : args) {
-                if (e.getMajorType().getMode() == TypeProtos.DataMode.OPTIONAL) {
-                    mode = TypeProtos.DataMode.OPTIONAL;
-                    break;
-                }
-            }
-        }
-
-        if (args.size() != 3) {
-            StringBuilder err = new StringBuilder();
-            for (int i = 0; i < args.size(); i++) {
-                err.append("arg" + i + ": " + args.get(i).getMajorType().getMinorType());
-            }
-            throw new DrillRuntimeException("Decimal cast function invoked with incorect arguments" + err);
-        }
-
-        int scale = (int) ((ValueExpressions.LongExpression)(args.get(args.size() - 1))).getLong();
-        int precision = (int) ((ValueExpressions.LongExpression)(args.get(args.size() - 2))).getLong();
-        return (TypeProtos.MajorType.newBuilder().setMinorType(returnValue.type.getMinorType()).setScale(scale).setPrecision(precision).setMode(mode).build());
-    }
-}
\ No newline at end of file
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalDivScaleFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalDivScaleFuncHolder.java
deleted file mode 100644
index c867890f489..00000000000
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalDivScaleFuncHolder.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.drill.exec.expr.fn;
-
-import java.util.List;
-
-import org.apache.drill.common.expression.LogicalExpression;
-import org.apache.drill.common.types.TypeProtos;
-import org.apache.drill.common.types.TypeProtos.MajorType;
-import org.apache.drill.common.util.DecimalScalePrecisionDivideFunction;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.NullHandling;
-import org.apache.drill.exec.util.DecimalUtility;
-
-public class DrillDecimalDivScaleFuncHolder extends DrillSimpleFuncHolder{
-
-  public DrillDecimalDivScaleFuncHolder(FunctionAttributes functionAttributes, FunctionInitializer initializer) {
-    super(functionAttributes, initializer);
-  }
-
-  /*
-   * This function scope is used by divide functions for decimal data type.
-   * DecimalScalePrecisionDivideFunction is used to compute the output types'
-   * scale and precision
-   */
-  @Override
-  public MajorType getReturnType(List<LogicalExpression> args) {
-
-    TypeProtos.DataMode mode = returnValue.type.getMode();
-
-    if (nullHandling == NullHandling.NULL_IF_NULL) {
-      // if any one of the input types is nullable, then return nullable return type
-      for (LogicalExpression e : args) {
-        if (e.getMajorType().getMode() == TypeProtos.DataMode.OPTIONAL) {
-          mode = TypeProtos.DataMode.OPTIONAL;
-          break;
-        }
-      }
-    }
-
-
-    /* Get the result's scale and precision. This is a function scope for Divide function, assert we have
-     * only two inputs
-     */
-    assert args.size() == 2;
-
-    DecimalScalePrecisionDivideFunction outputScalePrec =
-      new DecimalScalePrecisionDivideFunction(args.get(0).getMajorType().getPrecision(), args.get(0).getMajorType().getScale(),
-                                              args.get(1).getMajorType().getPrecision(), args.get(1).getMajorType().getScale());
-    return (TypeProtos.MajorType.newBuilder().setMinorType(DecimalUtility.getDecimalDataType(outputScalePrec.getOutputPrecision()))
-        .setScale(outputScalePrec.getOutputScale()).setPrecision(outputScalePrec.getOutputPrecision()).setMode(mode).build());
-  }
-
-  @Override
-  public boolean checkPrecisionRange() {
-    return true;
-  }
-}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalMaxScaleFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalMaxScaleFuncHolder.java
deleted file mode 100644
index e0b8f9aefbb..00000000000
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalMaxScaleFuncHolder.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.drill.exec.expr.fn;
-
-import java.util.List;
-import java.util.Map;
-
-import org.apache.drill.common.expression.LogicalExpression;
-import org.apache.drill.common.types.TypeProtos;
-import org.apache.drill.common.types.TypeProtos.MajorType;
-import org.apache.drill.exec.expr.DrillSimpleFunc;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.FunctionScope;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.NullHandling;
-
-public class DrillDecimalMaxScaleFuncHolder extends DrillSimpleFuncHolder {
-
-  public DrillDecimalMaxScaleFuncHolder(FunctionAttributes functionAttributes, FunctionInitializer initializer) {
-    super(functionAttributes, initializer);
-  }
-
-    @Override
-    public MajorType getReturnType(List<LogicalExpression> args) {
-
-        TypeProtos.DataMode mode = returnValue.type.getMode();
-        boolean nullInput = false;
-        int scale = 0;
-        int precision = 0;
-
-        for (LogicalExpression e : args) {
-            if (e.getMajorType().getMode() == TypeProtos.DataMode.OPTIONAL) {
-                nullInput = true;
-            }
-            scale = Math.max(scale, e.getMajorType().getScale());
-            precision = Math.max(precision, e.getMajorType().getPrecision());
-        }
-
-        if (nullHandling == NullHandling.NULL_IF_NULL && nullInput) {
-            mode = TypeProtos.DataMode.OPTIONAL;
-        }
-
-        return (TypeProtos.MajorType.newBuilder().setMinorType(returnValue.type.getMinorType()).setScale(scale).setPrecision(precision).setMode(mode).build());
-    }
-}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalModScaleFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalModScaleFuncHolder.java
deleted file mode 100644
index b373fa9d2e5..00000000000
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalModScaleFuncHolder.java
+++ /dev/null
@@ -1,76 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.drill.exec.expr.fn;
-
-import java.util.List;
-import java.util.Map;
-
-import org.apache.drill.common.expression.LogicalExpression;
-import org.apache.drill.common.types.TypeProtos;
-import org.apache.drill.common.types.TypeProtos.MajorType;
-import org.apache.drill.common.util.DecimalScalePrecisionModFunction;
-import org.apache.drill.exec.expr.DrillSimpleFunc;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.FunctionScope;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.NullHandling;
-import org.apache.drill.exec.util.DecimalUtility;
-
-public class DrillDecimalModScaleFuncHolder extends DrillSimpleFuncHolder{
-
-  public DrillDecimalModScaleFuncHolder(FunctionAttributes functionAttributes, FunctionInitializer initializer) {
-    super(functionAttributes, initializer);
-  }
-
-  /*
-   * This function scope is used by divide functions for decimal data type.
-   * DecimalScalePrecisionDivideFunction is used to compute the output types'
-   * scale and precision
-   */
-  @Override
-  public MajorType getReturnType(List<LogicalExpression> args) {
-
-    TypeProtos.DataMode mode = returnValue.type.getMode();
-
-    if (nullHandling == NullHandling.NULL_IF_NULL) {
-      // if any one of the input types is nullable, then return nullable return type
-      for (LogicalExpression e : args) {
-        if (e.getMajorType().getMode() == TypeProtos.DataMode.OPTIONAL) {
-          mode = TypeProtos.DataMode.OPTIONAL;
-          break;
-        }
-      }
-    }
-
-
-    /* Get the result's scale and precision. This is a function scope for Divide function, assert we have
-     * only two inputs
-     */
-    assert args.size() == 2;
-
-    DecimalScalePrecisionModFunction outputScalePrec =
-        new DecimalScalePrecisionModFunction(args.get(0).getMajorType().getPrecision(), args.get(0).getMajorType().getScale(),
-            args.get(1).getMajorType().getPrecision(), args.get(1).getMajorType().getScale());
-    return (TypeProtos.MajorType.newBuilder().setMinorType(DecimalUtility.getDecimalDataType(outputScalePrec.getOutputPrecision()))
-        .setScale(outputScalePrec.getOutputScale()).setPrecision(outputScalePrec.getOutputPrecision()).setMode(mode).build());
-  }
-
-  @Override
-  public boolean checkPrecisionRange() {
-    return true;
-  }
-}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalSetScaleFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalSetScaleFuncHolder.java
deleted file mode 100644
index a10d6eacc0b..00000000000
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalSetScaleFuncHolder.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.drill.exec.expr.fn;
-
-import java.util.List;
-
-import org.apache.drill.common.expression.LogicalExpression;
-import org.apache.drill.common.expression.ValueExpressions;
-import org.apache.drill.common.types.TypeProtos;
-import org.apache.drill.common.types.TypeProtos.MajorType;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.NullHandling;
-
-public class DrillDecimalSetScaleFuncHolder extends DrillSimpleFuncHolder{
-
-  public DrillDecimalSetScaleFuncHolder(FunctionAttributes functionAttributes, FunctionInitializer initializer) {
-    super(functionAttributes, initializer);
-  }
-
-  @Override
-  public MajorType getReturnType(List<LogicalExpression> args) {
-
-    TypeProtos.DataMode mode = returnValue.type.getMode();
-    int scale = 0;
-    int precision = 0;
-    int i = 0;
-
-    if (nullHandling == NullHandling.NULL_IF_NULL) {
-      // if any one of the input types is nullable, then return nullable return type
-      for (LogicalExpression e : args) {
-
-        precision = Math.max(precision, e.getMajorType().getPrecision());
-        if (e.getMajorType().getMode() == TypeProtos.DataMode.OPTIONAL) {
-          mode = TypeProtos.DataMode.OPTIONAL;
-        }
-      }
-
-      /* Used by functions like round, truncate which specify the scale for
-       * the output as the second argument
-       */
-      assert (args.size() == 2) && (args.get(1) instanceof ValueExpressions.IntExpression);
-
-      // Get the scale from the second argument which should be a constant
-      scale = ((ValueExpressions.IntExpression) args.get(1)).getInt();
-    }
-
-    return (TypeProtos.MajorType.newBuilder().setMinorType(returnValue.type.getMinorType()).setScale(scale).setPrecision(precision).setMode(mode).build());
-  }
-}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalSumAggFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalSumAggFuncHolder.java
deleted file mode 100644
index 89ea7cc1b18..00000000000
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalSumAggFuncHolder.java
+++ /dev/null
@@ -1,45 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.drill.exec.expr.fn;
-
-import java.util.List;
-
-import org.apache.drill.common.expression.LogicalExpression;
-import org.apache.drill.common.types.TypeProtos;
-
-public class DrillDecimalSumAggFuncHolder extends DrillAggFuncHolder {
-
-  public DrillDecimalSumAggFuncHolder(FunctionAttributes attributes, FunctionInitializer initializer) {
-    super(attributes, initializer);
-  }
-
-  @Override
-  public TypeProtos.MajorType getReturnType(List<LogicalExpression> args) {
-
-    int scale = 0;
-    int precision = 0;
-
-    // Get the max scale and precision from the inputs
-    for (LogicalExpression e : args) {
-      scale = Math.max(scale, e.getMajorType().getScale());
-      precision = Math.max(precision, e.getMajorType().getPrecision());
-    }
-
-    return (TypeProtos.MajorType.newBuilder().setMinorType(returnValue.type.getMinorType()).setScale(scale).setPrecision(38).setMode(TypeProtos.DataMode.REQUIRED).build());
-  }
-}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalSumScaleFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalSumScaleFuncHolder.java
deleted file mode 100644
index d45e67490b3..00000000000
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalSumScaleFuncHolder.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.drill.exec.expr.fn;
-
-import java.util.List;
-
-import org.apache.drill.common.expression.LogicalExpression;
-import org.apache.drill.common.types.TypeProtos;
-import org.apache.drill.common.types.TypeProtos.MajorType;
-import org.apache.drill.common.util.DecimalScalePrecisionMulFunction;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.NullHandling;
-import org.apache.drill.exec.util.DecimalUtility;
-
-public class DrillDecimalSumScaleFuncHolder extends DrillSimpleFuncHolder{
-
-
-  public DrillDecimalSumScaleFuncHolder(FunctionAttributes functionAttributes, FunctionInitializer initializer) {
-    super(functionAttributes, initializer);
-  }
-
-    @Override
-    public MajorType getReturnType(List<LogicalExpression> args) {
-
-        TypeProtos.DataMode mode = returnValue.type.getMode();
-
-        if (nullHandling == NullHandling.NULL_IF_NULL) {
-            // if any one of the input types is nullable, then return nullable return type
-            for (LogicalExpression e : args) {
-                if (e.getMajorType().getMode() == TypeProtos.DataMode.OPTIONAL) {
-                    mode = TypeProtos.DataMode.OPTIONAL;
-                    break;
-                }
-            }
-        }
-
-    /* Get the result's scale and precision. This is a function scope for Multiply function, assert we have
-     * only two inputs
-     */
-    assert args.size() == 2;
-
-    DecimalScalePrecisionMulFunction outputScalePrec =
-      new DecimalScalePrecisionMulFunction(args.get(0).getMajorType().getPrecision(), args.get(0).getMajorType().getScale(),
-                                              args.get(1).getMajorType().getPrecision(), args.get(1).getMajorType().getScale());
-        return (TypeProtos.MajorType.newBuilder().setMinorType(DecimalUtility.getDecimalDataType(outputScalePrec.getOutputPrecision()))
-            .setScale(outputScalePrec.getOutputScale()).setPrecision(outputScalePrec.getOutputPrecision()).setMode(mode).build());
-    }
-
-    @Override
-    public boolean checkPrecisionRange() {
-        return true;
-    }
-
-}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalZeroScaleFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalZeroScaleFuncHolder.java
deleted file mode 100644
index f941750b2bc..00000000000
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillDecimalZeroScaleFuncHolder.java
+++ /dev/null
@@ -1,58 +0,0 @@
-/**
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.drill.exec.expr.fn;
-
-import java.util.List;
-import java.util.Map;
-
-import org.apache.drill.common.expression.LogicalExpression;
-import org.apache.drill.common.types.TypeProtos;
-import org.apache.drill.common.types.TypeProtos.MajorType;
-import org.apache.drill.exec.expr.DrillSimpleFunc;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.FunctionScope;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate.NullHandling;
-
-public class DrillDecimalZeroScaleFuncHolder extends DrillSimpleFuncHolder{
-
-  public DrillDecimalZeroScaleFuncHolder(FunctionAttributes functionAttributes, FunctionInitializer initializer) {
-    super(functionAttributes, initializer);
-  }
-
-  /* This function scope is used when we need to remove the scale part.
-   * trunc and round functions with single argument use this
-   */
-  @Override
-  public MajorType getReturnType(List<LogicalExpression> args) {
-
-    int precision = 0;
-    TypeProtos.DataMode mode = returnValue.type.getMode();
-
-    if (nullHandling == NullHandling.NULL_IF_NULL) {
-      // if any one of the input types is nullable, then return nullable return type
-      for (LogicalExpression e : args) {
-        if (e.getMajorType().getMode() == TypeProtos.DataMode.OPTIONAL) {
-          mode = TypeProtos.DataMode.OPTIONAL;
-        }
-        precision = Math.max(precision, e.getMajorType().getPrecision());
-      }
-    }
-
-    return (TypeProtos.MajorType.newBuilder().setMinorType(returnValue.type.getMinorType()).setScale(0).setPrecision(precision).setMode(mode).build());
-  }
-}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillFuncHolder.java
index a8598892f1e..b25aa43c3f2 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillFuncHolder.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillFuncHolder.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -19,16 +19,12 @@
 
 import java.util.Arrays;
 import java.util.List;
-import java.util.Set;
 
-import com.google.common.collect.Sets;
 import org.apache.drill.common.exceptions.DrillRuntimeException;
 import org.apache.drill.common.exceptions.UserException;
 import org.apache.drill.common.expression.ExpressionPosition;
 import org.apache.drill.common.expression.FunctionHolderExpression;
 import org.apache.drill.common.expression.LogicalExpression;
-import org.apache.drill.common.types.TypeProtos;
-import org.apache.drill.common.types.TypeProtos.DataMode;
 import org.apache.drill.common.types.TypeProtos.MajorType;
 import org.apache.drill.common.types.TypeProtos.MinorType;
 import org.apache.drill.common.types.Types;
@@ -39,7 +35,6 @@
 import org.apache.drill.exec.expr.ClassGenerator.HoldingContainer;
 import org.apache.drill.exec.expr.DrillFuncHolderExpr;
 import org.apache.drill.exec.expr.TypeHelper;
-import org.apache.drill.exec.expr.annotations.FunctionTemplate;
 import org.apache.drill.exec.expr.annotations.FunctionTemplate.NullHandling;
 import org.apache.drill.exec.ops.UdfUtilities;
 import org.apache.drill.exec.vector.complex.reader.FieldReader;
@@ -56,33 +51,12 @@ public abstract class DrillFuncHolder extends AbstractFuncHolder {
   static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(DrillFuncHolder.class);
 
   private final FunctionAttributes attributes;
-  protected final FunctionTemplate.FunctionScope scope;
-  protected final FunctionTemplate.NullHandling nullHandling;
-  protected final FunctionTemplate.FunctionCostCategory costCategory;
-  protected final boolean isNiladic;
-  protected final boolean isBinaryCommutative;
-  protected final boolean isDeterministic;
-  protected final String[] registeredNames;
-  protected final WorkspaceReference[] workspaceVars;
-  protected final ValueReference[] parameters;
-  protected final ValueReference returnValue;
   private final FunctionInitializer initializer;
 
   public DrillFuncHolder(
       FunctionAttributes attributes,
       FunctionInitializer initializer) {
-    super();
     this.attributes = attributes;
-    this.scope = attributes.getScope();
-    this.nullHandling = attributes.getNullHandling();
-    this.costCategory = attributes.getCostCategory();
-    this.isNiladic = attributes.isNiladic();
-    this.isBinaryCommutative = attributes.isBinaryCommutative();
-    this.isDeterministic = attributes.isDeterministic();
-    this.registeredNames = attributes.getRegisteredNames();
-    this.workspaceVars = attributes.getWorkspaceVars();
-    this.parameters = attributes.getParameters();
-    this.returnValue = attributes.getReturnValue();
     this.initializer = initializer;
   }
 
@@ -108,11 +82,11 @@ protected String meth(String methodName, boolean required) {
   @Override
   public JVar[] renderStart(ClassGenerator<?> g, HoldingContainer[] inputVariables) {
     return declareWorkspaceVariables(g);
-  };
+  }
 
   @Override
   public void renderMiddle(ClassGenerator<?> g, HoldingContainer[] inputVariables, JVar[] workspaceJVars) {
-  };
+  }
 
   @Override
   public abstract HoldingContainer renderEnd(ClassGenerator<?> g, HoldingContainer[] inputVariables,
@@ -149,7 +123,7 @@ public boolean isNiladic() {
   public String getInputParameters() {
     StringBuilder builder = new StringBuilder();
     builder.append("");
-    for (ValueReference ref : parameters) {
+    for (ValueReference ref : attributes.getParameters()) {
       final MajorType type = ref.getType();
       builder.append(",");
       builder.append(type.getMinorType().toString());
@@ -167,12 +141,12 @@ public ClassLoader getClassLoader() {
   }
 
   protected JVar[] declareWorkspaceVariables(ClassGenerator<?> g) {
-    JVar[] workspaceJVars = new JVar[workspaceVars.length];
-    for (int i = 0; i < workspaceVars.length; i++) {
-      WorkspaceReference ref = workspaceVars[i];
-      JType jtype = g.getModel()._ref(ref.type);
+    JVar[] workspaceJVars = new JVar[attributes.getWorkspaceVars().length];
+    for (int i = 0; i < attributes.getWorkspaceVars().length; i++) {
+      WorkspaceReference ref = attributes.getWorkspaceVars()[i];
+      JType jtype = g.getModel()._ref(ref.getType());
 
-      if (ScalarReplacementTypes.CLASSES.contains(ref.type)) {
+      if (ScalarReplacementTypes.CLASSES.contains(ref.getType())) {
         workspaceJVars[i] = g.declareClassField("work", jtype);
         JBlock b = g.getBlock(SignatureHolder.DRILL_INIT_METHOD);
         b.assign(workspaceJVars[i], JExpr._new(jtype));
@@ -207,9 +181,9 @@ protected void generateBody(ClassGenerator<?> g, BlockType bt, String body, Hold
       } else {
         addProtectedBlock(g, sub, body, null, workspaceJVars, false);
       }
-      g.getBlock(bt).directStatement(String.format("/** start %s for function %s **/ ", bt.name(), registeredNames[0]));
+      g.getBlock(bt).directStatement(String.format("/** start %s for function %s **/ ", bt.name(), attributes.getRegisteredNames()[0]));
       g.getBlock(bt).add(sub);
-      g.getBlock(bt).directStatement(String.format("/** end %s for function %s **/ ", bt.name(), registeredNames[0]));
+      g.getBlock(bt).directStatement(String.format("/** end %s for function %s **/ ", bt.name(), attributes.getRegisteredNames()[0]));
     }
   }
 
@@ -221,15 +195,15 @@ protected void addProtectedBlock(ClassGenerator<?> g, JBlock sub, String body, H
           continue;
         }
 
-        ValueReference parameter = parameters[i];
+        ValueReference parameter = attributes.getParameters()[i];
         HoldingContainer inputVariable = inputVariables[i];
-        if (parameter.isFieldReader && ! inputVariable.isReader() && ! Types.isComplex(inputVariable.getMajorType()) && inputVariable.getMinorType() != MinorType.UNION) {
+        if (parameter.isFieldReader() && ! inputVariable.isReader() && ! Types.isComplex(inputVariable.getMajorType()) && inputVariable.getMinorType() != MinorType.UNION) {
           JType singularReaderClass = g.getModel()._ref(TypeHelper.getHolderReaderImpl(inputVariable.getMajorType().getMinorType(),
               inputVariable.getMajorType().getMode()));
           JType fieldReadClass = g.getModel()._ref(FieldReader.class);
-          sub.decl(fieldReadClass, parameter.name, JExpr._new(singularReaderClass).arg(inputVariable.getHolder()));
+          sub.decl(fieldReadClass, parameter.getName(), JExpr._new(singularReaderClass).arg(inputVariable.getHolder()));
         } else {
-          sub.decl(inputVariable.getHolder().type(), parameter.name, inputVariable.getHolder());
+          sub.decl(inputVariable.getHolder().type(), parameter.getName(), inputVariable.getHolder());
         }
       }
     }
@@ -237,9 +211,9 @@ protected void addProtectedBlock(ClassGenerator<?> g, JBlock sub, String body, H
     JVar[] internalVars = new JVar[workspaceJVars.length];
     for (int i = 0; i < workspaceJVars.length; i++) {
       if (decConstInputOnly) {
-        internalVars[i] = sub.decl(g.getModel()._ref(workspaceVars[i].type), workspaceVars[i].name, workspaceJVars[i]);
+        internalVars[i] = sub.decl(g.getModel()._ref(attributes.getWorkspaceVars()[i].getType()), attributes.getWorkspaceVars()[i].getName(), workspaceJVars[i]);
       } else {
-        internalVars[i] = sub.decl(g.getModel()._ref(workspaceVars[i].type), workspaceVars[i].name, workspaceJVars[i]);
+        internalVars[i] = sub.decl(g.getModel()._ref(attributes.getWorkspaceVars()[i].getType()), attributes.getWorkspaceVars()[i].getName(), workspaceJVars[i]);
       }
 
     }
@@ -255,20 +229,20 @@ protected void addProtectedBlock(ClassGenerator<?> g, JBlock sub, String body, H
 
   public boolean matches(MajorType returnType, List<MajorType> argTypes) {
 
-    if (!softCompare(returnType, returnValue.type)) {
+    if (!softCompare(returnType, attributes.getReturnValue().getType())) {
       // logger.debug(String.format("Call [%s] didn't match as return type [%s] was different than expected [%s]. ",
       // call.getDefinition().getName(), returnValue.type, call.getMajorType()));
       return false;
     }
 
-    if (argTypes.size() != parameters.length) {
+    if (argTypes.size() != attributes.getParameters().length) {
       // logger.debug(String.format("Call [%s] didn't match as the number of arguments provided [%d] were different than expected [%d]. ",
       // call.getDefinition().getName(), parameters.length, call.args.size()));
       return false;
     }
 
-    for (int i = 0; i < parameters.length; i++) {
-      if (!softCompare(parameters[i].type, argTypes.get(i))) {
+    for (int i = 0; i < attributes.getParameters().length; i++) {
+      if (!softCompare(attributes.getParameters()[i].getType(), argTypes.get(i))) {
         // logger.debug(String.format("Call [%s] didn't match as the argument [%s] didn't match the expected type [%s]. ",
         // call.getDefinition().getName(), arg.getMajorType(), param.type));
         return false;
@@ -280,48 +254,24 @@ public boolean matches(MajorType returnType, List<MajorType> argTypes) {
 
   @Override
   public MajorType getParmMajorType(int i) {
-    return this.parameters[i].type;
+    return attributes.getParameters()[i].getType();
   }
 
   @Override
   public int getParamCount() {
-    return this.parameters.length;
+    return attributes.getParameters().length;
   }
 
   public boolean isConstant(int i) {
-    return this.parameters[i].isConstant;
+    return attributes.getParameters()[i].isConstant();
   }
 
   public boolean isFieldReader(int i) {
-    return this.parameters[i].isFieldReader;
+    return attributes.getParameters()[i].isFieldReader();
   }
 
   public MajorType getReturnType(final List<LogicalExpression> logicalExpressions) {
-    if (returnValue.type.getMinorType() == MinorType.UNION) {
-      final Set<MinorType> subTypes = Sets.newHashSet();
-      for(final ValueReference ref : parameters) {
-        subTypes.add(ref.getType().getMinorType());
-      }
-
-      final MajorType.Builder builder = MajorType.newBuilder()
-          .setMinorType(MinorType.UNION)
-          .setMode(DataMode.OPTIONAL);
-
-      for(final MinorType subType : subTypes) {
-        builder.addSubType(subType);
-      }
-      return builder.build();
-    }
-
-    if(nullHandling == NullHandling.NULL_IF_NULL) {
-      // if any one of the input types is nullable, then return nullable return type
-      for(final LogicalExpression logicalExpression : logicalExpressions) {
-        if(logicalExpression.getMajorType().getMode() == TypeProtos.DataMode.OPTIONAL) {
-          return Types.optional(returnValue.type.getMinorType());
-        }
-      }
-    }
-    return returnValue.type;
+    return attributes.getReturnType().getType(logicalExpressions, attributes);
   }
 
   public NullHandling getNullHandling() {
@@ -340,118 +290,36 @@ public int getCostCategory() {
     return attributes.getCostCategory().getValue();
   }
 
-  @Override
-  public String toString() {
-    final int maxLen = 10;
-    return this.getClass().getSimpleName()
-        + " [functionNames=" + Arrays.toString(registeredNames)
-        + ", returnType=" + Types.toString(returnValue.type)
-        + ", nullHandling=" + nullHandling
-        + ", parameters=" + (parameters != null ? Arrays.asList(parameters).subList(0, Math.min(parameters.length, maxLen)) : null) + "]";
+  public ValueReference[] getParameters() {
+    return attributes.getParameters();
   }
 
-  public WorkspaceReference[] getWorkspaceVars() {
-    return this.workspaceVars;
+  public boolean checkPrecisionRange() {
+    return attributes.checkPrecisionRange();
   }
 
-  public ValueReference[] getParameters() {
-    return this.parameters;
+  public MajorType getReturnType() {
+    return attributes.getReturnValue().getType();
   }
 
-  public static class ValueReference {
-    MajorType type;
-    String name;
-    boolean isConstant = false;
-    boolean isFieldReader = false;
-    boolean isComplexWriter = false;
-
-    public ValueReference(MajorType type, String name) {
-      super();
-      Preconditions.checkNotNull(type);
-      Preconditions.checkNotNull(name);
-      this.type = type;
-      this.name = name;
-    }
-
-    public MajorType getType() {
-      return type;
-    }
-
-    public String getName() {
-      return name;
-    }
-
-    public void setConstant(boolean isConstant) {
-      this.isConstant = isConstant;
-    }
-
-    @Override
-    public String toString() {
-      return "ValueReference [type=" + Types.toString(type) + ", name=" + name + "]";
-    }
-
-    public static ValueReference createFieldReaderRef(String name) {
-      MajorType type = Types.required(MinorType.LATE);
-      ValueReference ref = new ValueReference(type, name);
-      ref.isFieldReader = true;
-
-      return ref;
-    }
-
-    public static ValueReference createComplexWriterRef(String name) {
-      MajorType type = Types.required(MinorType.LATE);
-      ValueReference ref = new ValueReference(type, name);
-      ref.isComplexWriter = true;
-      return ref;
-    }
-
-    public boolean isComplexWriter() {
-      return isComplexWriter;
-    }
-
+  public ValueReference getReturnValue() {
+    return attributes.getReturnValue();
   }
 
-  public static class WorkspaceReference {
-    Class<?> type;
-    String name;
-    MajorType majorType;
-    boolean inject;
-
-    public WorkspaceReference(Class<?> type, String name, boolean inject) {
-      super();
-      Preconditions.checkNotNull(type);
-      Preconditions.checkNotNull(name);
-      this.type = type;
-      this.name = name;
-      this.inject = inject;
-    }
-
-    void setMajorType(MajorType majorType) {
-      this.majorType = majorType;
-    }
-
-    public boolean isInject() {
-      return inject;
-    }
-
-    public Class<?> getType() {
-      return type;
-    }
-
-    public String getName() {
-      return name;
-    }
+  public WorkspaceReference[] getWorkspaceVars() {
+    return attributes.getWorkspaceVars();
   }
 
-  public boolean checkPrecisionRange() {
-    return false;
+  @Override
+  public String toString() {
+    final int maxLen = 10;
+    return this.getClass().getSimpleName()
+        + " [functionNames=" + Arrays.toString(attributes.getRegisteredNames())
+        + ", returnType=" + Types.toString(attributes.getReturnValue().getType())
+        + ", nullHandling=" + attributes.getNullHandling()
+        + ", parameters=" + (attributes.getParameters() != null ?
+        Arrays.asList(attributes.getParameters()).subList(0, Math.min(attributes.getParameters().length, maxLen)) : null) + "]";
   }
 
-  public MajorType getReturnType() {
-    return returnValue.type;
-  }
 
-  public ValueReference getReturnValue() {
-    return returnValue;
-  }
 }
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillSimpleFuncHolder.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillSimpleFuncHolder.java
index 655f5712cee..8f0591f8983 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillSimpleFuncHolder.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/DrillSimpleFuncHolder.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -77,8 +77,8 @@ public HoldingContainer renderEnd(ClassGenerator<?> g, HoldingContainer[] inputV
     //If the function's annotation specifies a parameter has to be constant expression, but the HoldingContainer
     //for the argument is not, then raise exception.
     for (int i =0; i < inputVariables.length; i++) {
-      if (parameters[i].isConstant && !inputVariables[i].isConstant()) {
-        throw new DrillRuntimeException(String.format("The argument '%s' of Function '%s' has to be constant!", parameters[i].name, this.getRegisteredNames()[0]));
+      if (getParameters()[i].isConstant() && !inputVariables[i].isConstant()) {
+        throw new DrillRuntimeException(String.format("The argument '%s' of Function '%s' has to be constant!", getParameters()[i].getName(), this.getRegisteredNames()[0]));
       }
     }
     generateBody(g, BlockType.SETUP, setupBody(), inputVariables, workspaceJVars, true);
@@ -90,15 +90,15 @@ public HoldingContainer renderEnd(ClassGenerator<?> g, HoldingContainer[] inputV
 
   protected HoldingContainer generateEvalBody(ClassGenerator<?> g, HoldingContainer[] inputVariables, String body, JVar[] workspaceJVars) {
 
-    g.getEvalBlock().directStatement(String.format("//---- start of eval portion of %s function. ----//", registeredNames[0]));
+    g.getEvalBlock().directStatement(String.format("//---- start of eval portion of %s function. ----//", getRegisteredNames()[0]));
 
     JBlock sub = new JBlock(true, true);
     JBlock topSub = sub;
     HoldingContainer out = null;
-    MajorType returnValueType = returnValue.type;
+    MajorType returnValueType = getReturnType();
 
     // add outside null handling if it is defined.
-    if (nullHandling == NullHandling.NULL_IF_NULL) {
+    if (getNullHandling() == NullHandling.NULL_IF_NULL) {
       JExpression e = null;
       for (HoldingContainer v : inputVariables) {
         if (v.isOptional()) {
@@ -118,7 +118,7 @@ protected HoldingContainer generateEvalBody(ClassGenerator<?> g, HoldingContaine
 
       if (e != null) {
         // if at least one expression must be checked, set up the conditional.
-        returnValueType = returnValue.type.toBuilder().setMode(DataMode.OPTIONAL).build();
+        returnValueType = getReturnType().toBuilder().setMode(DataMode.OPTIONAL).build();
         out = g.declare(returnValueType);
         e = e.eq(JExpr.lit(0));
         JConditional jc = sub._if(e);
@@ -135,7 +135,7 @@ protected HoldingContainer generateEvalBody(ClassGenerator<?> g, HoldingContaine
     g.getEvalBlock().add(topSub);
 
 
-    JVar internalOutput = sub.decl(JMod.FINAL, g.getHolderType(returnValueType), returnValue.name, JExpr._new(g.getHolderType(returnValueType)));
+    JVar internalOutput = sub.decl(JMod.FINAL, g.getHolderType(returnValueType), getReturnValue().getName(), JExpr._new(g.getHolderType(returnValueType)));
     addProtectedBlock(g, sub, body, inputVariables, workspaceJVars, false);
     if (sub != topSub) {
       sub.assign(internalOutput.ref("isSet"),JExpr.lit(1));// Assign null if NULL_IF_NULL mode
@@ -145,7 +145,7 @@ protected HoldingContainer generateEvalBody(ClassGenerator<?> g, HoldingContaine
       sub.assign(internalOutput.ref("isSet"),JExpr.lit(1));// Assign null if NULL_IF_NULL mode
     }
 
-    g.getEvalBlock().directStatement(String.format("//---- end of eval portion of %s function. ----//", registeredNames[0]));
+    g.getEvalBlock().directStatement(String.format("//---- end of eval portion of %s function. ----//", getRegisteredNames()[0]));
 
     return out;
   }
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/FunctionAttributes.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/FunctionAttributes.java
index df8876df5b9..4fd5be77b74 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/FunctionAttributes.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/FunctionAttributes.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -17,63 +17,58 @@
  */
 package org.apache.drill.exec.expr.fn;
 
+import org.apache.drill.exec.expr.annotations.FunctionTemplate;
 import org.apache.drill.exec.expr.annotations.FunctionTemplate.FunctionCostCategory;
 import org.apache.drill.exec.expr.annotations.FunctionTemplate.FunctionScope;
 import org.apache.drill.exec.expr.annotations.FunctionTemplate.NullHandling;
-import org.apache.drill.exec.expr.fn.DrillFuncHolder.ValueReference;
-import org.apache.drill.exec.expr.fn.DrillFuncHolder.WorkspaceReference;
 
 /**
  * Attributes of a function
  * Those are used in code generation and optimization.
  */
 public class FunctionAttributes {
-  private final FunctionScope scope;
-  private final NullHandling nullHandling;
-  private final boolean isBinaryCommutative;
-  private final boolean isDeterministic;
+
+  private final FunctionTemplate template;
   private final String[] registeredNames;
   private final ValueReference[] parameters;
   private final ValueReference returnValue;
   private final WorkspaceReference[] workspaceVars;
-  private final FunctionCostCategory costCategory;
-  private final boolean isNiladic;
-
-  public FunctionAttributes(FunctionScope scope, NullHandling nullHandling, boolean isBinaryCommutative,
-      boolean isDeteministic, String[] registeredNames, ValueReference[] parameters, ValueReference returnValue,
-      WorkspaceReference[] workspaceVars, FunctionCostCategory costCategory, boolean isNiladic) {
-    super();
-    this.scope = scope;
-    this.nullHandling = nullHandling;
-    this.isBinaryCommutative = isBinaryCommutative;
-    this.isDeterministic = isDeteministic;
-    this.registeredNames = registeredNames;
+
+
+  public FunctionAttributes (FunctionTemplate template,
+                             ValueReference[] parameters,
+                             ValueReference returnValue,
+                             WorkspaceReference[] workspaceVars) {
+    this.template = template;
+    this.registeredNames = ((template.name().isEmpty()) ? template.names() : new String[] {template.name()});
     this.parameters = parameters;
     this.returnValue = returnValue;
     this.workspaceVars = workspaceVars;
-    this.costCategory = costCategory;
-    this.isNiladic = isNiladic;
   }
 
   public FunctionScope getScope() {
-    return scope;
+    return template.scope();
+  }
+
+  public FunctionTemplate.ReturnType getReturnType() {
+    return template.returnType();
   }
 
   public NullHandling getNullHandling() {
-    return nullHandling;
+    return template.nulls();
   }
 
   public boolean isBinaryCommutative() {
-    return isBinaryCommutative;
+    return template.isBinaryCommutative();
   }
 
   @Deprecated
   public boolean isRandom() {
-    return !isDeterministic;
+    return template.isRandom();
   }
 
   public boolean isDeterministic() {
-    return isDeterministic;
+    return !template.isRandom();
   }
 
   public String[] getRegisteredNames() {
@@ -93,10 +88,12 @@ public WorkspaceReference[] getWorkspaceVars() {
   }
 
   public FunctionCostCategory getCostCategory() {
-    return costCategory;
+    return template.costCategory();
   }
 
   public boolean isNiladic() {
-    return isNiladic;
+    return template.isNiladic();
   }
+
+  public boolean checkPrecisionRange() { return template.checkPrecisionRange(); }
 }
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/FunctionConverter.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/FunctionConverter.java
index b79309508b3..ca5605a5821 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/FunctionConverter.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/FunctionConverter.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -34,8 +34,6 @@
 import org.apache.drill.exec.expr.annotations.Output;
 import org.apache.drill.exec.expr.annotations.Param;
 import org.apache.drill.exec.expr.annotations.Workspace;
-import org.apache.drill.exec.expr.fn.DrillFuncHolder.ValueReference;
-import org.apache.drill.exec.expr.fn.DrillFuncHolder.WorkspaceReference;
 import org.apache.drill.exec.expr.holders.ValueHolder;
 import org.apache.drill.exec.ops.UdfUtilities;
 import org.apache.drill.exec.vector.complex.reader.FieldReader;
@@ -174,54 +172,24 @@ public <T extends DrillFunc> DrillFuncHolder getHolder(AnnotatedClassDescriptor
     }
 
     FunctionInitializer initializer = new FunctionInitializer(func.getClassName(), classLoader);
-    try{
+    try {
       // return holder
       ValueReference[] ps = params.toArray(new ValueReference[params.size()]);
       WorkspaceReference[] works = workspaceFields.toArray(new WorkspaceReference[workspaceFields.size()]);
 
+      FunctionAttributes functionAttributes = new FunctionAttributes(template, ps, outputField, works);
 
-      String[] registeredNames = ((template.name().isEmpty()) ? template.names() : new String[] {template.name()} );
-      boolean isDeteministic = ! template.isRandom();
-      FunctionAttributes functionAttributes = new FunctionAttributes(
-          template.scope(),
-          template.nulls(),
-          template.isBinaryCommutative(),
-          isDeteministic, registeredNames, ps, outputField, works, template.costCategory(), template.isNiladic());
       switch (template.scope()) {
-      case POINT_AGGREGATE:
-        return new DrillAggFuncHolder(functionAttributes, initializer);
-      case DECIMAL_AGGREGATE:
-        return new DrillDecimalAggFuncHolder(functionAttributes, initializer);
-      case DECIMAL_SUM_AGGREGATE:
-        return new DrillDecimalSumAggFuncHolder(functionAttributes, initializer);
-      case SIMPLE:
-        if (outputField.isComplexWriter) {
-          return new DrillComplexWriterFuncHolder(functionAttributes, initializer);
-        } else {
-          return new DrillSimpleFuncHolder(functionAttributes, initializer);
-        }
-      case SC_BOOLEAN_OPERATOR:
-        return new DrillBooleanOPHolder(functionAttributes, initializer);
-      case DECIMAL_MAX_SCALE:
-          return new DrillDecimalMaxScaleFuncHolder(functionAttributes, initializer);
-      case DECIMAL_MUL_SCALE:
-          return new DrillDecimalSumScaleFuncHolder(functionAttributes, initializer);
-      case DECIMAL_ADD_SCALE:
-          return new DrillDecimalAddFuncHolder(functionAttributes, initializer);
-      case DECIMAL_CAST:
-          return new DrillDecimalCastFuncHolder(functionAttributes, initializer);
-      case DECIMAL_DIV_SCALE:
-          return new DrillDecimalDivScaleFuncHolder(functionAttributes, initializer);
-      case DECIMAL_MOD_SCALE:
-          return new DrillDecimalModScaleFuncHolder(functionAttributes, initializer);
-      case DECIMAL_SET_SCALE:
-          return new DrillDecimalSetScaleFuncHolder(functionAttributes, initializer);
-      case DECIMAL_ZERO_SCALE:
-          return new DrillDecimalZeroScaleFuncHolder(functionAttributes, initializer);
-      case HOLISTIC_AGGREGATE:
-      case RANGE_AGGREGATE:
-      default:
-        return failure("Unsupported Function Type.", func);
+        case POINT_AGGREGATE:
+          return new DrillAggFuncHolder(functionAttributes, initializer);
+        case SIMPLE:
+          return outputField.isComplexWriter() ?
+              new DrillComplexWriterFuncHolder(functionAttributes, initializer) :
+              new DrillSimpleFuncHolder(functionAttributes, initializer);
+        case HOLISTIC_AGGREGATE:
+        case RANGE_AGGREGATE:
+        default:
+          return failure("Unsupported Function Type.", func);
       }
     } catch (Exception | NoSuchFieldError | AbstractMethodError ex) {
       return failure("Failure while creating function holder.", ex, func);
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/FunctionUtils.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/FunctionUtils.java
new file mode 100644
index 00000000000..f565b675f00
--- /dev/null
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/FunctionUtils.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to you under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.drill.exec.expr.fn;
+
+import org.apache.drill.common.expression.LogicalExpression;
+import org.apache.drill.common.types.TypeProtos;
+import org.apache.drill.exec.expr.annotations.FunctionTemplate;
+
+import java.util.List;
+
+public class FunctionUtils {
+
+  /**
+   * Calculates return type data mode based on give logical expressions.
+   * If null handling strategy is internal, returns return value data mode.
+   * If null handling strategy is null if null and at least one of the input types are nullable,
+   * return nullable data mode.
+   *
+   * @param logicalExpressions logical expressions
+   * @param attributes function attributes
+   * @return data mode
+   */
+  public static TypeProtos.DataMode getReturnTypeDataMode(final List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+    if (attributes.getNullHandling() == FunctionTemplate.NullHandling.NULL_IF_NULL) {
+      for (final LogicalExpression logicalExpression : logicalExpressions) {
+        if (logicalExpression.getMajorType().getMode() == TypeProtos.DataMode.OPTIONAL) {
+          return TypeProtos.DataMode.OPTIONAL;
+        }
+      }
+    }
+    return attributes.getReturnValue().getType().getMode();
+  }
+
+}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/ValueReference.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/ValueReference.java
new file mode 100644
index 00000000000..9fc2151be59
--- /dev/null
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/ValueReference.java
@@ -0,0 +1,81 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.drill.exec.expr.fn;
+
+import com.google.common.base.Preconditions;
+import org.apache.drill.common.types.TypeProtos.MajorType;
+import org.apache.drill.common.types.TypeProtos.MinorType;
+import org.apache.drill.common.types.Types;
+
+public class ValueReference {
+  private final MajorType type;
+  private final String name;
+  private boolean isConstant = false;
+  private boolean isFieldReader = false;
+  private boolean isComplexWriter = false;
+
+  public ValueReference(MajorType type, String name) {
+    Preconditions.checkNotNull(type);
+    Preconditions.checkNotNull(name);
+    this.type = type;
+    this.name = name;
+  }
+
+  public void setConstant(boolean isConstant) {
+    this.isConstant = isConstant;
+  }
+
+  public MajorType getType() {
+    return type;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public boolean isConstant() {
+    return isConstant;
+  }
+
+  public boolean isFieldReader() {
+    return isFieldReader;
+  }
+
+  public boolean isComplexWriter() {
+    return isComplexWriter;
+  }
+
+  @Override
+  public String toString() {
+    return "ValueReference [type=" + Types.toString(type) + ", name=" + name + "]";
+  }
+
+  public static ValueReference createFieldReaderRef(String name) {
+    MajorType type = Types.required(MinorType.LATE);
+    ValueReference ref = new ValueReference(type, name);
+    ref.isFieldReader = true;
+    return ref;
+  }
+
+  public static ValueReference createComplexWriterRef(String name) {
+    MajorType type = Types.required(MinorType.LATE);
+    ValueReference ref = new ValueReference(type, name);
+    ref.isComplexWriter = true;
+    return ref;
+  }
+}
\ No newline at end of file
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/WorkspaceReference.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/WorkspaceReference.java
new file mode 100644
index 00000000000..e2ba449b99f
--- /dev/null
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/WorkspaceReference.java
@@ -0,0 +1,64 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.drill.exec.expr.fn;
+
+import com.google.common.base.Preconditions;
+import org.apache.drill.common.types.TypeProtos.MajorType;
+import org.apache.drill.common.types.Types;
+
+public class WorkspaceReference {
+
+  private final Class<?> type;
+  private final String name;
+  private final boolean inject;
+  private MajorType majorType;
+
+  public WorkspaceReference(Class<?> type, String name, boolean inject) {
+    Preconditions.checkNotNull(type);
+    Preconditions.checkNotNull(name);
+    this.type = type;
+    this.name = name;
+    this.inject = inject;
+  }
+
+  void setMajorType(MajorType majorType) {
+    this.majorType = majorType;
+  }
+
+  public String getName() {
+    return name;
+  }
+
+  public boolean isInject() {
+    return inject;
+  }
+
+  public Class<?> getType() {
+    return type;
+  }
+
+  public MajorType getMajorType() {
+    return majorType;
+  }
+
+  @Override
+  public String toString() {
+    return "WorkspaceReference [type= " + type +", major type=" + Types.toString(majorType) + ", name=" + name + "]";
+  }
+
+}
\ No newline at end of file
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/impl/BitFunctions.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/impl/BitFunctions.java
index e19f284b6d5..4930aef75eb 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/impl/BitFunctions.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/impl/BitFunctions.java
@@ -35,7 +35,7 @@
 public class BitFunctions {
 
   @FunctionTemplate(names = {"booleanOr", "or", "||", "orNoShortCircuit"},
-                    scope = FunctionScope.SC_BOOLEAN_OPERATOR,
+                    scope = FunctionScope.SIMPLE,
                     nulls = NullHandling.NULL_IF_NULL)
   public static class BitOr implements DrillSimpleFunc {
 
@@ -51,7 +51,7 @@ public void eval() {
   }
 
   @FunctionTemplate(names = {"booleanAnd", "and", "&&"},
-                    scope = FunctionScope.SC_BOOLEAN_OPERATOR,
+                    scope = FunctionScope.SIMPLE,
                     nulls = NullHandling.NULL_IF_NULL)
   public static class BitAnd implements DrillSimpleFunc {
 
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/impl/SimpleCastFunctions.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/impl/SimpleCastFunctions.java
index 346190a000d..807fbb9181c 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/impl/SimpleCastFunctions.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/impl/SimpleCastFunctions.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -51,7 +51,10 @@ public void eval() {
     }
   }
 
-  @FunctionTemplate(name = "castVARCHAR", scope = FunctionTemplate.FunctionScope.SIMPLE, nulls=NullHandling.NULL_IF_NULL)
+  @FunctionTemplate(name = "castVARCHAR",
+      scope = FunctionTemplate.FunctionScope.SIMPLE,
+      returnType = FunctionTemplate.ReturnType.STRING_CAST,
+      nulls = NullHandling.NULL_IF_NULL)
   public static class CastBooleanVarChar implements DrillSimpleFunc {
 
     @Param BitHolder in;
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/impl/StringFunctions.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/impl/StringFunctions.java
index d90581eba65..a6fa25551b2 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/impl/StringFunctions.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/impl/StringFunctions.java
@@ -29,6 +29,7 @@
 import org.apache.drill.exec.expr.annotations.FunctionTemplate;
 import org.apache.drill.exec.expr.annotations.FunctionTemplate.FunctionScope;
 import org.apache.drill.exec.expr.annotations.FunctionTemplate.NullHandling;
+import org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType;
 import org.apache.drill.exec.expr.annotations.Output;
 import org.apache.drill.exec.expr.annotations.Param;
 import org.apache.drill.exec.expr.annotations.Workspace;
@@ -483,7 +484,10 @@ public void eval() {
   /*
    * Convert string to lower case.
    */
-  @FunctionTemplate(name = "lower", scope = FunctionScope.SIMPLE, nulls = NullHandling.NULL_IF_NULL)
+  @FunctionTemplate(name = "lower",
+      scope = FunctionScope.SIMPLE,
+      returnType = ReturnType.SAME_IN_OUT_LENGTH,
+      nulls = NullHandling.NULL_IF_NULL)
   public static class LowerCase implements DrillSimpleFunc {
     @Param VarCharHolder input;
     @Output VarCharHolder out;
@@ -515,7 +519,10 @@ public void eval() {
   /*
    * Convert string to upper case.
    */
-  @FunctionTemplate(name = "upper", scope = FunctionScope.SIMPLE, nulls = NullHandling.NULL_IF_NULL)
+  @FunctionTemplate(name = "upper",
+      scope = FunctionScope.SIMPLE,
+      returnType = ReturnType.SAME_IN_OUT_LENGTH,
+      nulls = NullHandling.NULL_IF_NULL)
   public static class UpperCase implements DrillSimpleFunc {
 
     @Param VarCharHolder input;
@@ -775,7 +782,10 @@ public void eval() {
   }
 
 
-  @FunctionTemplate(name = "initcap", scope = FunctionScope.SIMPLE, nulls = NullHandling.NULL_IF_NULL)
+  @FunctionTemplate(name = "initcap",
+      scope = FunctionScope.SIMPLE,
+      returnType = ReturnType.SAME_IN_OUT_LENGTH,
+      nulls = NullHandling.NULL_IF_NULL)
   public static class InitCap implements DrillSimpleFunc {
     @Param VarCharHolder input;
     @Output VarCharHolder out;
@@ -860,7 +870,10 @@ public void eval() {
    * Fill up the string to length 'length' by prepending the characters 'fill' in the beginning of 'text'.
    * If the string is already longer than length, then it is truncated (on the right).
    */
-  @FunctionTemplate(name = "lpad", scope = FunctionScope.SIMPLE, nulls = NullHandling.NULL_IF_NULL)
+  @FunctionTemplate(name = "lpad",
+      scope = FunctionScope.SIMPLE,
+      returnType = ReturnType.PAD,
+      nulls = NullHandling.NULL_IF_NULL)
   public static class Lpad implements DrillSimpleFunc {
     @Param  VarCharHolder text;
     @Param  BigIntHolder length;
@@ -935,7 +948,10 @@ public void eval() {
    * Fill up the string to length 'length' by prepending the character ' ' in the beginning of 'text'.
    * If the string is already longer than length, then it is truncated (on the right).
    */
-  @FunctionTemplate(name = "lpad", scope = FunctionScope.SIMPLE, nulls = NullHandling.NULL_IF_NULL)
+  @FunctionTemplate(name = "lpad",
+      scope = FunctionScope.SIMPLE,
+      returnType = ReturnType.PAD,
+      nulls = NullHandling.NULL_IF_NULL)
   public static class LpadTwoArg implements DrillSimpleFunc {
     @Param  VarCharHolder text;
     @Param  BigIntHolder length;
@@ -994,7 +1010,10 @@ public void eval() {
    * Fill up the string to length "length" by appending the characters 'fill' at the end of 'text'
    * If the string is already longer than length then it is truncated.
    */
-  @FunctionTemplate(name = "rpad", scope = FunctionScope.SIMPLE, nulls = NullHandling.NULL_IF_NULL)
+  @FunctionTemplate(name = "rpad",
+      scope = FunctionScope.SIMPLE,
+      returnType = ReturnType.PAD,
+      nulls = NullHandling.NULL_IF_NULL)
   public static class Rpad implements DrillSimpleFunc {
     @Param  VarCharHolder text;
     @Param  BigIntHolder length;
@@ -1072,7 +1091,10 @@ public void eval() {
    * Fill up the string to length "length" by appending the characters ' ' at the end of 'text'
    * If the string is already longer than length then it is truncated.
    */
-  @FunctionTemplate(name = "rpad", scope = FunctionScope.SIMPLE, nulls = NullHandling.NULL_IF_NULL)
+  @FunctionTemplate(name = "rpad",
+      scope = FunctionScope.SIMPLE,
+      returnType = ReturnType.PAD,
+      nulls = NullHandling.NULL_IF_NULL)
   public static class RpadTwoArg implements DrillSimpleFunc {
     @Param  VarCharHolder text;
     @Param  BigIntHolder length;
@@ -1389,7 +1411,10 @@ public void eval() {
 
   }
 
-  @FunctionTemplate(name = "concatOperator", scope = FunctionScope.SIMPLE, nulls = NullHandling.NULL_IF_NULL)
+  @FunctionTemplate(name = "concatOperator",
+      scope = FunctionScope.SIMPLE,
+      returnType = ReturnType.CONCAT,
+      nulls = NullHandling.NULL_IF_NULL)
   public static class ConcatOperator implements DrillSimpleFunc {
     @Param  VarCharHolder left;
     @Param  VarCharHolder right;
@@ -1418,7 +1443,10 @@ public void eval() {
 
   //Concatenate the text representations of the arguments. NULL arguments are ignored.
   //TODO: NullHanding.INTERNAL for DrillSimpleFunc requires change in code generation.
-  @FunctionTemplate(name = "concat", scope = FunctionScope.SIMPLE, nulls = NullHandling.INTERNAL)
+  @FunctionTemplate(name = "concat",
+      scope = FunctionScope.SIMPLE,
+      returnType = ReturnType.CONCAT,
+      nulls = NullHandling.INTERNAL)
   public static class Concat implements DrillSimpleFunc {
     @Param  VarCharHolder left;
     @Param  VarCharHolder right;
@@ -1445,7 +1473,10 @@ public void eval() {
     }
   }
 
-  @FunctionTemplate(name = "concat", scope = FunctionScope.SIMPLE, nulls = NullHandling.INTERNAL)
+  @FunctionTemplate(name = "concat",
+      scope = FunctionScope.SIMPLE,
+      returnType = ReturnType.CONCAT,
+      nulls = NullHandling.INTERNAL)
   public static class ConcatRightNullInput implements DrillSimpleFunc {
     @Param  VarCharHolder left;
     @Param  NullableVarCharHolder right;
@@ -1474,7 +1505,10 @@ public void eval() {
     }
   }
 
-  @FunctionTemplate(name = "concat", scope = FunctionScope.SIMPLE, nulls = NullHandling.INTERNAL)
+  @FunctionTemplate(name = "concat",
+      scope = FunctionScope.SIMPLE,
+      returnType = ReturnType.CONCAT,
+      nulls = NullHandling.INTERNAL)
   public static class ConcatLeftNullInput implements DrillSimpleFunc {
     @Param  NullableVarCharHolder left;
     @Param  VarCharHolder right;
@@ -1503,7 +1537,10 @@ public void eval() {
     }
   }
 
-  @FunctionTemplate(name = "concat", scope = FunctionScope.SIMPLE, nulls = NullHandling.INTERNAL)
+  @FunctionTemplate(name = "concat",
+      scope = FunctionScope.SIMPLE,
+      returnType = ReturnType.CONCAT,
+      nulls = NullHandling.INTERNAL)
   public static class ConcatBothNullInput implements DrillSimpleFunc {
     @Param  NullableVarCharHolder left;
     @Param  NullableVarCharHolder right;
@@ -1682,7 +1719,10 @@ public void eval() {
   /**
   * Returns the reverse string for given input.
   */
-  @FunctionTemplate(name = "reverse", scope = FunctionScope.SIMPLE, nulls = NullHandling.NULL_IF_NULL)
+  @FunctionTemplate(name = "reverse",
+      scope = FunctionScope.SIMPLE,
+      returnType = ReturnType.SAME_IN_OUT_LENGTH,
+      nulls = NullHandling.NULL_IF_NULL)
   public static class ReverseString implements DrillSimpleFunc {
     @Param  VarCharHolder in;
     @Output VarCharHolder out;
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/ConcatReturnTypeInference.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/ConcatReturnTypeInference.java
new file mode 100644
index 00000000000..eea02e79925
--- /dev/null
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/ConcatReturnTypeInference.java
@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to you under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.drill.exec.expr.fn.output;
+
+import org.apache.drill.common.expression.LogicalExpression;
+import org.apache.drill.common.types.TypeProtos;
+import org.apache.drill.common.types.Types;
+import org.apache.drill.exec.expr.fn.FunctionAttributes;
+import org.apache.drill.exec.expr.fn.FunctionUtils;
+
+import java.util.List;
+
+/**
+ * Return type calculation implementation for functions with return type set as
+ * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#CONCAT}.
+ */
+public class ConcatReturnTypeInference implements ReturnTypeInference {
+
+  public static final ConcatReturnTypeInference INSTANCE = new ConcatReturnTypeInference();
+
+  /**
+   * Defines function return type and sets precision if it can be calculated.
+   * Return type precision is sum of input types precisions.
+   * If at least one input type does not have precision, return type will be without precision.
+   * If calculated precision is greater than {@link Types#MAX_VARCHAR_LENGTH},
+   * it is replaced with {@link Types#MAX_VARCHAR_LENGTH}.
+   *
+   * @param logicalExpressions logical expressions
+   * @param attributes function attributes
+   * @return return type
+   */
+  @Override
+  public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+    TypeProtos.MajorType.Builder builder = TypeProtos.MajorType.newBuilder()
+        .setMinorType(attributes.getReturnValue().getType().getMinorType())
+        .setMode(FunctionUtils.getReturnTypeDataMode(logicalExpressions, attributes));
+
+    int totalPrecision = 0;
+    for (LogicalExpression expression : logicalExpressions) {
+      if (expression.getMajorType().hasPrecision()) {
+        totalPrecision += expression.getMajorType().getPrecision();
+      } else {
+        // if at least one expression has unknown precision, return type without precision
+        return builder.build();
+      }
+    }
+    return builder.setPrecision(totalPrecision > Types.MAX_VARCHAR_LENGTH ? Types.MAX_VARCHAR_LENGTH : totalPrecision).build();
+  }
+}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/DecimalReturnTypeInference.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/DecimalReturnTypeInference.java
new file mode 100644
index 00000000000..ba43b3911b8
--- /dev/null
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/DecimalReturnTypeInference.java
@@ -0,0 +1,369 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to you under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.drill.exec.expr.fn.output;
+
+import org.apache.drill.common.exceptions.DrillRuntimeException;
+import org.apache.drill.common.expression.LogicalExpression;
+import org.apache.drill.common.expression.ValueExpressions;
+import org.apache.drill.common.types.TypeProtos;
+import org.apache.drill.common.util.DecimalScalePrecisionAddFunction;
+import org.apache.drill.common.util.DecimalScalePrecisionDivideFunction;
+import org.apache.drill.common.util.DecimalScalePrecisionModFunction;
+import org.apache.drill.common.util.DecimalScalePrecisionMulFunction;
+import org.apache.drill.exec.expr.annotations.FunctionTemplate;
+import org.apache.drill.exec.expr.fn.FunctionAttributes;
+import org.apache.drill.exec.expr.fn.FunctionUtils;
+import org.apache.drill.exec.util.DecimalUtility;
+
+import java.util.List;
+
+public class DecimalReturnTypeInference {
+
+  /**
+   * Return type calculation implementation for functions with return type set as
+   * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#DECIMAL_ADD_SCALE}.
+   */
+  public static class DecimalAddReturnTypeInference implements ReturnTypeInference {
+
+    public static final DecimalAddReturnTypeInference INSTANCE = new DecimalAddReturnTypeInference();
+
+    /**
+     * This return type is used by add and subtract functions for decimal data type.
+     * DecimalScalePrecisionAddFunction is used to compute the output types' scale and precision.
+     *
+     * @param logicalExpressions logical expressions
+     * @param attributes function attributes
+     * @return return type
+     */
+    @Override
+    public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+      TypeProtos.DataMode mode = FunctionUtils.getReturnTypeDataMode(logicalExpressions, attributes);
+
+      assert logicalExpressions.size() == 2;
+
+      DecimalScalePrecisionAddFunction outputScalePrec =
+          new DecimalScalePrecisionAddFunction(logicalExpressions.get(0).getMajorType().getPrecision(),
+              logicalExpressions.get(0).getMajorType().getScale(),
+              logicalExpressions.get(1).getMajorType().getPrecision(),
+              logicalExpressions.get(1).getMajorType().getScale());
+      return TypeProtos.MajorType.newBuilder()
+          .setMinorType(DecimalUtility.getDecimalDataType(outputScalePrec.getOutputPrecision()))
+          .setScale(outputScalePrec.getOutputScale())
+          .setPrecision(outputScalePrec.getOutputPrecision())
+          .setMode(mode)
+          .build();
+    }
+  }
+
+  /**
+   * Return type calculation implementation for functions with return type set as
+   * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#DECIMAL_AGGREGATE}.
+   */
+  public static class DecimalAggReturnTypeInference implements ReturnTypeInference {
+
+    public static final DecimalAggReturnTypeInference INSTANCE = new DecimalAggReturnTypeInference();
+
+    @Override
+    public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+      int scale = 0;
+      int precision = 0;
+
+      // Get the max scale and precision from the inputs
+      for (LogicalExpression e : logicalExpressions) {
+        scale = Math.max(scale, e.getMajorType().getScale());
+        precision = Math.max(precision, e.getMajorType().getPrecision());
+      }
+
+      return TypeProtos.MajorType.newBuilder()
+          .setMinorType(attributes.getReturnValue().getType().getMinorType())
+          .setScale(scale)
+          .setPrecision(precision)
+          .setMode(TypeProtos.DataMode.REQUIRED)
+          .build();
+    }
+  }
+
+  /**
+   * Return type calculation implementation for functions with return type set as
+   * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#DECIMAL_CAST}.
+   */
+  public static class DecimalCastReturnTypeInference implements ReturnTypeInference {
+
+    public static final DecimalCastReturnTypeInference INSTANCE = new DecimalCastReturnTypeInference();
+
+    @Override
+    public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+      TypeProtos.DataMode mode = FunctionUtils.getReturnTypeDataMode(logicalExpressions, attributes);
+
+      if (logicalExpressions.size() != 3) {
+        StringBuilder err = new StringBuilder();
+        for (int i = 0; i < logicalExpressions.size(); i++) {
+          err.append("arg").append(i).append(": ").append(logicalExpressions.get(i).getMajorType().getMinorType());
+        }
+        throw new DrillRuntimeException("Decimal cast function invoked with incorrect arguments" + err);
+      }
+
+      int scale = (int) ((ValueExpressions.LongExpression)(logicalExpressions.get(logicalExpressions.size() - 1))).getLong();
+      int precision = (int) ((ValueExpressions.LongExpression)(logicalExpressions.get(logicalExpressions.size() - 2))).getLong();
+      return TypeProtos.MajorType.newBuilder()
+          .setMinorType(attributes.getReturnValue().getType().getMinorType())
+          .setScale(scale)
+          .setPrecision(precision)
+          .setMode(mode)
+          .build();
+    }
+  }
+
+  /**
+   * Return type calculation implementation for functions with return type set as
+   * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#DECIMAL_DIV_SCALE}.
+   */
+  public static class DecimalDivScaleReturnTypeInference implements ReturnTypeInference {
+
+    public static final DecimalDivScaleReturnTypeInference INSTANCE = new DecimalDivScaleReturnTypeInference();
+
+    /**
+     * Return type is used by divide functions for decimal data type.
+     * DecimalScalePrecisionDivideFunction is used to compute the output types' scale and precision.
+     *
+     * @param logicalExpressions logical expressions
+     * @param attributes function attributes
+     * @return return type
+     */
+    @Override
+    public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+      TypeProtos.DataMode mode = FunctionUtils.getReturnTypeDataMode(logicalExpressions, attributes);
+
+      assert logicalExpressions.size() == 2;
+
+      DecimalScalePrecisionDivideFunction outputScalePrec =
+          new DecimalScalePrecisionDivideFunction(logicalExpressions.get(0).getMajorType().getPrecision(),
+              logicalExpressions.get(0).getMajorType().getScale(),
+              logicalExpressions.get(1).getMajorType().getPrecision(),
+              logicalExpressions.get(1).getMajorType().getScale());
+      return TypeProtos.MajorType.newBuilder()
+          .setMinorType(DecimalUtility.getDecimalDataType(outputScalePrec.getOutputPrecision()))
+          .setScale(outputScalePrec.getOutputScale())
+          .setPrecision(outputScalePrec.getOutputPrecision())
+          .setMode(mode)
+          .build();
+    }
+  }
+
+  /**
+   * Return type calculation implementation for functions with return type set as
+   * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#DECIMAL_MAX_SCALE}.
+   */
+  public static class DecimalMaxScaleReturnTypeInference implements ReturnTypeInference {
+
+    public static final DecimalMaxScaleReturnTypeInference INSTANCE = new DecimalMaxScaleReturnTypeInference();
+
+    @Override
+    public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+
+      TypeProtos.DataMode mode = FunctionUtils.getReturnTypeDataMode(logicalExpressions, attributes);
+      int scale = 0;
+      int precision = 0;
+
+      for (LogicalExpression e : logicalExpressions) {
+        scale = Math.max(scale, e.getMajorType().getScale());
+        precision = Math.max(precision, e.getMajorType().getPrecision());
+      }
+
+      return TypeProtos.MajorType.newBuilder()
+          .setMinorType(attributes.getReturnValue().getType().getMinorType())
+          .setScale(scale)
+          .setPrecision(precision)
+          .setMode(mode)
+          .build();
+    }
+  }
+
+  /**
+   * Return type calculation implementation for functions with return type set as
+   * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#DECIMAL_MOD_SCALE}.
+   */
+  public static class DecimalModScaleReturnTypeInference implements ReturnTypeInference {
+
+    public static final DecimalModScaleReturnTypeInference INSTANCE = new DecimalModScaleReturnTypeInference();
+
+    /**
+     * Return type is used by divide functions for decimal data type.
+     * DecimalScalePrecisionDivideFunction is used to compute the output types' scale and precision.
+     *
+     * @param logicalExpressions logical expressions
+     * @param attributes function attributes
+     * @return return type
+     */
+    @Override
+    public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+      TypeProtos.DataMode mode = FunctionUtils.getReturnTypeDataMode(logicalExpressions, attributes);
+
+      assert logicalExpressions.size() == 2;
+
+      DecimalScalePrecisionModFunction outputScalePrec =
+          new DecimalScalePrecisionModFunction(logicalExpressions.get(0).getMajorType().getPrecision(),
+              logicalExpressions.get(0).getMajorType().getScale(),
+              logicalExpressions.get(1).getMajorType().getPrecision(),
+              logicalExpressions.get(1).getMajorType().getScale());
+      return TypeProtos.MajorType.newBuilder()
+          .setMinorType(DecimalUtility.getDecimalDataType(outputScalePrec.getOutputPrecision()))
+          .setScale(outputScalePrec.getOutputScale())
+          .setPrecision(outputScalePrec.getOutputPrecision())
+          .setMode(mode)
+          .build();
+    }
+  }
+
+  /**
+   * Return type calculation implementation for functions with return type set as
+   * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#DECIMAL_SET_SCALE}.
+   */
+  public static class DecimalSetScaleReturnTypeInference implements ReturnTypeInference {
+
+    public static final DecimalSetScaleReturnTypeInference INSTANCE = new DecimalSetScaleReturnTypeInference();
+
+    @Override
+    public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+      TypeProtos.DataMode mode = attributes.getReturnValue().getType().getMode();
+      int scale = 0;
+      int precision = 0;
+
+      if (attributes.getNullHandling() == FunctionTemplate.NullHandling.NULL_IF_NULL) {
+        // if any one of the input types is nullable, then return nullable return type
+        for (LogicalExpression e : logicalExpressions) {
+
+          precision = Math.max(precision, e.getMajorType().getPrecision());
+          if (e.getMajorType().getMode() == TypeProtos.DataMode.OPTIONAL) {
+            mode = TypeProtos.DataMode.OPTIONAL;
+          }
+        }
+
+        // Used by functions like round, truncate which specify the scale for the output as the second argument
+        assert (logicalExpressions.size() == 2) && (logicalExpressions.get(1) instanceof ValueExpressions.IntExpression);
+
+        // Get the scale from the second argument which should be a constant
+        scale = ((ValueExpressions.IntExpression) logicalExpressions.get(1)).getInt();
+      }
+
+      return TypeProtos.MajorType.newBuilder()
+          .setMinorType(attributes.getReturnValue().getType().getMinorType())
+          .setScale(scale)
+          .setPrecision(precision)
+          .setMode(mode)
+          .build();
+    }
+  }
+
+  /**
+   * Return type calculation implementation for functions with return type set as
+   * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#DECIMAL_SUM_AGGREGATE}.
+   */
+  public static class DecimalSumAggReturnTypeInference implements ReturnTypeInference {
+
+    public static final DecimalSumAggReturnTypeInference INSTANCE = new DecimalSumAggReturnTypeInference();
+
+    @Override
+    public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+      int scale = 0;
+      int precision = 0;
+
+      // Get the max scale and precision from the inputs
+      for (LogicalExpression e : logicalExpressions) {
+        scale = Math.max(scale, e.getMajorType().getScale());
+        precision = Math.max(precision, e.getMajorType().getPrecision());
+      }
+
+      return (TypeProtos.MajorType.newBuilder()
+          .setMinorType(attributes.getReturnValue().getType().getMinorType())
+          .setScale(scale)
+          .setPrecision(38)
+          .setMode(TypeProtos.DataMode.REQUIRED)
+          .build());
+    }
+  }
+
+  /**
+   * Return type calculation implementation for functions with return type set as
+   * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#DECIMAL_SUM_SCALE}.
+   */
+  public static class DecimalSumScaleReturnTypeInference implements ReturnTypeInference {
+
+    public static final DecimalSumScaleReturnTypeInference INSTANCE = new DecimalSumScaleReturnTypeInference();
+
+    @Override
+    public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+
+      TypeProtos.DataMode mode = FunctionUtils.getReturnTypeDataMode(logicalExpressions, attributes);
+
+      assert logicalExpressions.size() == 2;
+
+      DecimalScalePrecisionMulFunction outputScalePrec =
+          new DecimalScalePrecisionMulFunction(logicalExpressions.get(0).getMajorType().getPrecision(),
+              logicalExpressions.get(0).getMajorType().getScale(),
+              logicalExpressions.get(1).getMajorType().getPrecision(),
+              logicalExpressions.get(1).getMajorType().getScale());
+      return TypeProtos.MajorType.newBuilder()
+          .setMinorType(DecimalUtility.getDecimalDataType(outputScalePrec.getOutputPrecision()))
+          .setScale(outputScalePrec.getOutputScale())
+          .setPrecision(outputScalePrec.getOutputPrecision())
+          .setMode(mode)
+          .build();
+    }
+  }
+
+  /**
+   * Return type calculation implementation for functions with return type set as
+   * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#DECIMAL_ZERO_SCALE}.
+   */
+  public static class DecimalZeroScaleReturnTypeInference implements ReturnTypeInference {
+
+    public static final DecimalZeroScaleReturnTypeInference INSTANCE = new DecimalZeroScaleReturnTypeInference();
+
+    /**
+     * Return type is used for functions where we need to remove the scale part.
+     * For example, truncate and round functions.
+     *
+     * @param logicalExpressions logical expressions
+     * @param attributes function attributes
+     * @return return type
+     */
+    @Override
+    public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+
+      int precision = 0;
+      TypeProtos.DataMode mode = attributes.getReturnValue().getType().getMode();
+
+      if (attributes.getNullHandling() == FunctionTemplate.NullHandling.NULL_IF_NULL) {
+        // if any one of the input types is nullable, then return nullable return type
+        for (LogicalExpression e : logicalExpressions) {
+          if (e.getMajorType().getMode() == TypeProtos.DataMode.OPTIONAL) {
+            mode = TypeProtos.DataMode.OPTIONAL;
+          }
+          precision = Math.max(precision, e.getMajorType().getPrecision());
+        }
+      }
+
+      return TypeProtos.MajorType.newBuilder()
+          .setMinorType(attributes.getReturnValue().getType().getMinorType())
+          .setScale(0)
+          .setPrecision(precision)
+          .setMode(mode)
+          .build();
+    }
+  }
+}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/DefaultReturnTypeInference.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/DefaultReturnTypeInference.java
new file mode 100644
index 00000000000..02e6b1ee8c9
--- /dev/null
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/DefaultReturnTypeInference.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to you under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.drill.exec.expr.fn.output;
+
+import com.google.common.collect.Sets;
+import org.apache.drill.common.expression.LogicalExpression;
+import org.apache.drill.common.types.TypeProtos;
+import org.apache.drill.exec.expr.fn.FunctionAttributes;
+import org.apache.drill.exec.expr.fn.FunctionUtils;
+import org.apache.drill.exec.expr.fn.ValueReference;
+
+import java.util.List;
+import java.util.Set;
+
+/**
+ * Return type calculation implementation for functions with return type set as
+ * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#DEFAULT}.
+ */
+public class DefaultReturnTypeInference implements ReturnTypeInference {
+
+  public static final DefaultReturnTypeInference INSTANCE = new DefaultReturnTypeInference();
+
+  /**
+   * Calculates return type and its nullability. Precision and scale is not included.
+   *
+   * @param logicalExpressions logical expressions
+   * @param attributes function attributes
+   * @return return type
+   */
+  @Override
+  public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+    if (attributes.getReturnValue().getType().getMinorType() == TypeProtos.MinorType.UNION) {
+      final Set<TypeProtos.MinorType> subTypes = Sets.newHashSet();
+      for (final ValueReference ref : attributes.getParameters()) {
+        subTypes.add(ref.getType().getMinorType());
+      }
+
+      final TypeProtos.MajorType.Builder builder = TypeProtos.MajorType.newBuilder()
+          .setMinorType(TypeProtos.MinorType.UNION)
+          .setMode(TypeProtos.DataMode.OPTIONAL);
+
+      for (final TypeProtos.MinorType subType : subTypes) {
+        builder.addSubType(subType);
+      }
+      return builder.build();
+    }
+    return attributes.getReturnValue().getType().toBuilder()
+        .setMode(FunctionUtils.getReturnTypeDataMode(logicalExpressions, attributes))
+        .build();
+  }
+}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/PadReturnTypeInference.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/PadReturnTypeInference.java
new file mode 100644
index 00000000000..aac470343ac
--- /dev/null
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/PadReturnTypeInference.java
@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to you under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.drill.exec.expr.fn.output;
+
+import org.apache.drill.common.expression.LogicalExpression;
+import org.apache.drill.common.expression.ValueExpressions;
+import org.apache.drill.common.types.TypeProtos;
+import org.apache.drill.exec.expr.fn.FunctionAttributes;
+import org.apache.drill.exec.expr.fn.FunctionUtils;
+
+import java.util.List;
+
+/**
+ * Return type calculation implementation for functions with return type set as
+ * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#PAD}.
+ */
+public class PadReturnTypeInference implements ReturnTypeInference {
+
+  public static final PadReturnTypeInference INSTANCE = new PadReturnTypeInference();
+
+  /**
+   * Defines function return type and sets precision if it pad length parameter is int expression.
+   * If pad length is less than zero, return type precision is 0.
+   *
+   * @param logicalExpressions logical expressions
+   * @param attributes function attributes
+   * @return return type
+   */
+  @Override
+  public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+    TypeProtos.MajorType.Builder builder = TypeProtos.MajorType.newBuilder()
+        .setMinorType(attributes.getReturnValue().getType().getMinorType())
+        .setMode(FunctionUtils.getReturnTypeDataMode(logicalExpressions, attributes));
+
+    if (logicalExpressions.get(1).iterator().hasNext() &&
+        logicalExpressions.get(1).iterator().next() instanceof ValueExpressions.IntExpression) {
+      int precision = ((ValueExpressions.IntExpression) logicalExpressions.get(1).iterator().next()).getInt();
+      // if pad length is less than zero, output length is 0
+      builder.setPrecision(Math.max(precision, 0));
+    }
+    return builder.build();
+  }
+}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/ReturnTypeInference.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/ReturnTypeInference.java
new file mode 100644
index 00000000000..05375a00660
--- /dev/null
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/ReturnTypeInference.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to you under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.drill.exec.expr.fn.output;
+
+import org.apache.drill.common.expression.LogicalExpression;
+import org.apache.drill.common.types.TypeProtos;
+import org.apache.drill.exec.expr.fn.FunctionAttributes;
+
+import java.util.List;
+
+/**
+ * Return type calculation interface for functions that have return type set as with enum
+ * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType}.
+ */
+public interface ReturnTypeInference {
+
+  TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes);
+
+}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/SameInOutLengthReturnTypeInference.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/SameInOutLengthReturnTypeInference.java
new file mode 100644
index 00000000000..92bfae16ee8
--- /dev/null
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/SameInOutLengthReturnTypeInference.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to you under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.drill.exec.expr.fn.output;
+
+import org.apache.drill.common.expression.LogicalExpression;
+import org.apache.drill.common.types.TypeProtos;
+import org.apache.drill.common.types.Types;
+import org.apache.drill.exec.expr.fn.FunctionAttributes;
+import org.apache.drill.exec.expr.fn.FunctionUtils;
+
+import java.util.List;
+
+/**
+ * Return type calculation implementation for functions with return type set as
+ * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#SAME_IN_OUT_LENGTH}.
+ */
+public class SameInOutLengthReturnTypeInference implements ReturnTypeInference {
+
+  public static final SameInOutLengthReturnTypeInference INSTANCE = new SameInOutLengthReturnTypeInference();
+
+  /**
+   * Defines function return type and sets precision and scale if input type has them.
+   *
+   * @param logicalExpressions logical expressions
+   * @param attributes function attributes
+   * @return return type
+   */
+  @Override
+  public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+    TypeProtos.MajorType majorType = logicalExpressions.get(0).getMajorType();
+
+    TypeProtos.MajorType.Builder builder = TypeProtos.MajorType.newBuilder()
+        .setMinorType(attributes.getReturnValue().getType().getMinorType())
+        .setMode(FunctionUtils.getReturnTypeDataMode(logicalExpressions, attributes));
+
+    builder = Types.calculateTypePrecisionAndScale(majorType, majorType, builder);
+    return builder.build();
+  }
+}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/StringCastReturnTypeInference.java b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/StringCastReturnTypeInference.java
new file mode 100644
index 00000000000..95c30cd970c
--- /dev/null
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/expr/fn/output/StringCastReturnTypeInference.java
@@ -0,0 +1,57 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to you under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.drill.exec.expr.fn.output;
+
+import com.google.common.primitives.Ints;
+import org.apache.drill.common.expression.LogicalExpression;
+import org.apache.drill.common.expression.ValueExpressions;
+import org.apache.drill.common.types.TypeProtos;
+import org.apache.drill.exec.expr.fn.FunctionAttributes;
+import org.apache.drill.exec.expr.fn.FunctionUtils;
+
+import java.util.List;
+
+/**
+ * Return type calculation implementation for functions with return type set as
+ * {@link org.apache.drill.exec.expr.annotations.FunctionTemplate.ReturnType#STRING_CAST}.
+ */
+public class StringCastReturnTypeInference implements ReturnTypeInference {
+
+  public static final StringCastReturnTypeInference INSTANCE = new StringCastReturnTypeInference();
+
+  /**
+   * Defines function return type and sets cast length as type precision
+   * if cast length is simple long expression.
+   *
+   * @param logicalExpressions logical expressions
+   * @param attributes function attributes
+   * @return return type
+   */
+  @Override
+  public TypeProtos.MajorType getType(List<LogicalExpression> logicalExpressions, FunctionAttributes attributes) {
+    TypeProtos.MajorType.Builder builder = TypeProtos.MajorType.newBuilder()
+        .setMinorType(attributes.getReturnValue().getType().getMinorType())
+        .setMode(FunctionUtils.getReturnTypeDataMode(logicalExpressions, attributes));
+
+    LogicalExpression logicalExpression = logicalExpressions.get(1);
+    if (logicalExpressions.get(1) instanceof ValueExpressions.LongExpression) {
+      long precision = ((ValueExpressions.LongExpression) logicalExpression).getLong();
+      builder.setPrecision(Ints.checkedCast(precision));
+    }
+    return builder.build();
+  }
+}
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/physical/impl/project/ProjectRecordBatch.java b/exec/java-exec/src/main/java/org/apache/drill/exec/physical/impl/project/ProjectRecordBatch.java
index 1ecdaf574f5..a35e3f14e6e 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/physical/impl/project/ProjectRecordBatch.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/physical/impl/project/ProjectRecordBatch.java
@@ -45,7 +45,6 @@
 import org.apache.drill.exec.expr.CodeGenerator;
 import org.apache.drill.exec.expr.DrillFuncHolderExpr;
 import org.apache.drill.exec.expr.ExpressionTreeMaterializer;
-import org.apache.drill.exec.expr.TypeHelper;
 import org.apache.drill.exec.expr.ValueVectorReadExpression;
 import org.apache.drill.exec.expr.ValueVectorWriteExpression;
 import org.apache.drill.exec.expr.fn.DrillComplexWriterFuncHolder;
@@ -517,12 +516,8 @@ private List<NamedExpression> getExpressionList() {
         final String castFuncName = CastFunctions.getCastFunc(MinorType.VARCHAR);
         final List<LogicalExpression> castArgs = Lists.newArrayList();
         castArgs.add(convertToJson);  //input_expr
-        /*
-         * We are implicitly casting to VARCHAR so we don't have a max length,
-         * using an arbitrary value. We trim down the size of the stored bytes
-         * to the actual size so this size doesn't really matter.
-         */
-        castArgs.add(new ValueExpressions.LongExpression(TypeHelper.VARCHAR_DEFAULT_CAST_LEN, null)); //
+        // implicitly casting to varchar, since we don't know actual source length, cast to undefined length, which will preserve source length
+        castArgs.add(new ValueExpressions.LongExpression(Types.MAX_VARCHAR_LENGTH, null));
         final FunctionCall castCall = new FunctionCall(castFuncName, castArgs, ExpressionPosition.UNKNOWN);
         exprs.add(new NamedExpression(castCall, new FieldReference(field.getPath())));
       } else {
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/physical/impl/union/UnionAllRecordBatch.java b/exec/java-exec/src/main/java/org/apache/drill/exec/physical/impl/union/UnionAllRecordBatch.java
index 06b7bdb07b4..985c4aef18f 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/physical/impl/union/UnionAllRecordBatch.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/physical/impl/union/UnionAllRecordBatch.java
@@ -29,13 +29,13 @@
 import org.apache.drill.common.types.TypeProtos.DataMode;
 import org.apache.drill.common.types.TypeProtos.MajorType;
 import org.apache.drill.common.types.TypeProtos.MinorType;
+import org.apache.drill.common.types.Types;
 import org.apache.drill.exec.exception.ClassTransformationException;
 import org.apache.drill.exec.exception.OutOfMemoryException;
 import org.apache.drill.exec.exception.SchemaChangeException;
 import org.apache.drill.exec.expr.ClassGenerator;
 import org.apache.drill.exec.expr.CodeGenerator;
 import org.apache.drill.exec.expr.ExpressionTreeMaterializer;
-import org.apache.drill.exec.expr.ValueVectorReadExpression;
 import org.apache.drill.exec.expr.ValueVectorWriteExpression;
 import org.apache.drill.exec.ops.FragmentContext;
 import org.apache.drill.exec.physical.config.UnionAll;
@@ -198,16 +198,14 @@ private IterOutcome doWork() throws ClassTransformationException, IOException, S
       // transfer directly,
       // rename columns or
       // cast data types (Minortype or DataMode)
-      if(hasSameTypeAndMode(outputFields.get(index), vw.getValueVector().getField())) {
+      if (hasSameTypeAndMode(outputFields.get(index), vw.getValueVector().getField())) {
         // Transfer column
-        if(outputFields.get(index).getPath().equals(inputPath)) {
-          final LogicalExpression expr = ExpressionTreeMaterializer.materialize(inputPath, current, collector, context.getFunctionRegistry());
-          if (collector.hasErrors()) {
-            throw new SchemaChangeException(String.format("Failure while trying to materialize incoming schema.  Errors:\n %s.", collector.toErrorString()));
-          }
 
-          ValueVectorReadExpression vectorRead = (ValueVectorReadExpression) expr;
-          ValueVector vvOut = container.addOrGet(MaterializedField.create(outputPath.getAsUnescapedPath(), vectorRead.getMajorType()));
+        MajorType outputFieldType = outputFields.get(index).getType();
+        MaterializedField outputField = MaterializedField.create(outputPath.getAsUnescapedPath(), outputFieldType);
+
+        if (outputFields.get(index).getPath().equals(inputPath.getAsUnescapedPath())) {
+          ValueVector vvOut = container.addOrGet(outputField);
           TransferPair tp = vvIn.makeTransferPair(vvOut);
           transfers.add(tp);
         // Copy data in order to rename the column
@@ -217,7 +215,6 @@ private IterOutcome doWork() throws ClassTransformationException, IOException, S
             throw new SchemaChangeException(String.format("Failure while trying to materialize incoming schema.  Errors:\n %s.", collector.toErrorString()));
           }
 
-          MaterializedField outputField = MaterializedField.create(outputPath.getAsUnescapedPath(), expr.getMajorType());
           ValueVector vv = container.addOrGet(outputField, callBack);
           allocationVectors.add(vv);
           TypedFieldId fid = container.getValueVectorId(SchemaPath.getSimplePath(outputField.getPath()));
@@ -571,39 +568,40 @@ private void inferOutputFieldsBothSide() {
       Iterator<MaterializedField> rightIter = rightSchema.iterator();
 
       int index = 1;
-      while(leftIter.hasNext() && rightIter.hasNext()) {
+      while (leftIter.hasNext() && rightIter.hasNext()) {
         MaterializedField leftField  = leftIter.next();
         MaterializedField rightField = rightIter.next();
 
-        if(hasSameTypeAndMode(leftField, rightField)) {
-          outputFields.add(MaterializedField.create(leftField.getPath(), leftField.getType()));
+        if (hasSameTypeAndMode(leftField, rightField)) {
+          MajorType.Builder builder = MajorType.newBuilder().setMinorType(leftField.getType().getMinorType()).setMode(leftField.getDataMode());
+          builder = Types.calculateTypePrecisionAndScale(leftField.getType(), rightField.getType(), builder);
+          outputFields.add(MaterializedField.create(leftField.getPath(), builder.build()));
         } else {
           // If the output type is not the same,
           // cast the column of one of the table to a data type which is the Least Restrictive
-          MinorType outputMinorType;
-          if(leftField.getType().getMinorType() == rightField.getType().getMinorType()) {
-            outputMinorType = leftField.getType().getMinorType();
+          MajorType.Builder builder = MajorType.newBuilder();
+          if (leftField.getType().getMinorType() == rightField.getType().getMinorType()) {
+            builder.setMinorType(leftField.getType().getMinorType());
+            builder = Types.calculateTypePrecisionAndScale(leftField.getType(), rightField.getType(), builder);
           } else {
             List<MinorType> types = Lists.newLinkedList();
             types.add(leftField.getType().getMinorType());
             types.add(rightField.getType().getMinorType());
-            outputMinorType = TypeCastRules.getLeastRestrictiveType(types);
-            if(outputMinorType == null) {
+            MinorType outputMinorType = TypeCastRules.getLeastRestrictiveType(types);
+            if (outputMinorType == null) {
               throw new DrillRuntimeException("Type mismatch between " + leftField.getType().getMinorType().toString() +
                   " on the left side and " + rightField.getType().getMinorType().toString() +
                   " on the right side in column " + index + " of UNION ALL");
             }
+            builder.setMinorType(outputMinorType);
           }
 
           // The output data mode should be as flexible as the more flexible one from the two input tables
           List<DataMode> dataModes = Lists.newLinkedList();
           dataModes.add(leftField.getType().getMode());
           dataModes.add(rightField.getType().getMode());
-          DataMode dataMode = TypeCastRules.getLeastRestrictiveDataMode(dataModes);
+          builder.setMode(TypeCastRules.getLeastRestrictiveDataMode(dataModes));
 
-          MajorType.Builder builder = MajorType.newBuilder();
-          builder.setMinorType(outputMinorType);
-          builder.setMode(dataMode);
           outputFields.add(MaterializedField.create(leftField.getPath(), builder.build()));
         }
         ++index;
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/planner/logical/DrillOptiq.java b/exec/java-exec/src/main/java/org/apache/drill/exec/planner/logical/DrillOptiq.java
index 5a907875c41..db0cfbd0187 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/planner/logical/DrillOptiq.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/planner/logical/DrillOptiq.java
@@ -294,20 +294,19 @@ public LogicalExpression visitFieldAccess(RexFieldAccess fieldAccess) {
 
     private LogicalExpression getDrillCastFunctionFromOptiq(RexCall call){
       LogicalExpression arg = call.getOperands().get(0).accept(this);
-      MajorType castType = null;
+      MajorType castType;
 
       switch(call.getType().getSqlTypeName().getName()){
       case "VARCHAR":
       case "CHAR":
-        castType = Types.required(MinorType.VARCHAR).toBuilder().setWidth(call.getType().getPrecision()).build();
+        castType = Types.required(MinorType.VARCHAR).toBuilder().setPrecision(call.getType().getPrecision()).build();
         break;
 
       case "INTEGER": castType = Types.required(MinorType.INT); break;
       case "FLOAT": castType = Types.required(MinorType.FLOAT4); break;
       case "DOUBLE": castType = Types.required(MinorType.FLOAT8); break;
       case "DECIMAL":
-        if (context.getPlannerSettings().getOptions().
-            getOption(PlannerSettings.ENABLE_DECIMAL_DATA_TYPE_KEY).bool_val == false ) {
+        if (!context.getPlannerSettings().getOptions().getOption(PlannerSettings.ENABLE_DECIMAL_DATA_TYPE_KEY).bool_val) {
           throw UserException
               .unsupportedError()
               .message(ExecErrorConstants.DECIMAL_DISABLE_ERR_MSG)
@@ -334,7 +333,7 @@ private LogicalExpression getDrillCastFunctionFromOptiq(RexCall call){
         case "INTERVAL_YEAR_MONTH": castType = Types.required(MinorType.INTERVALYEAR); break;
         case "INTERVAL_DAY_TIME": castType = Types.required(MinorType.INTERVALDAY); break;
         case "BOOLEAN": castType = Types.required(MinorType.BIT); break;
-        case "BINARY": castType = Types.required(MinorType.VARBINARY).toBuilder().setWidth(call.getType().getPrecision()).build(); break;
+        case "BINARY": castType = Types.required(MinorType.VARBINARY); break;
         case "ANY": return arg; // Type will be same as argument.
         default: castType = Types.required(MinorType.valueOf(call.getType().getSqlTypeName().getName()));
       }
@@ -422,7 +421,7 @@ private LogicalExpression getDrillFunctionFromOptiqCall(RexCall call) {
            * (empty string literal) to the list of arguments.
            */
           List<LogicalExpression> concatArgs = new LinkedList<>(args);
-          concatArgs.add(new QuotedString("", ExpressionPosition.UNKNOWN));
+          concatArgs.add(QuotedString.EMPTY_STRING);
 
           return FunctionCallFactory.createExpression(functionName, concatArgs);
 
@@ -512,9 +511,9 @@ public LogicalExpression visitLiteral(RexLiteral literal) {
         return ValueExpressions.getBit(((Boolean) literal.getValue()));
       case CHAR:
         if (isLiteralNull(literal)) {
-          return createNullExpr(MinorType.VARCHAR);
+          return createStringNullExpr(literal.getType().getPrecision());
         }
-        return ValueExpressions.getChar(((NlsString)literal.getValue()).getValue());
+        return ValueExpressions.getChar(((NlsString)literal.getValue()).getValue(), literal.getType().getPrecision());
       case DOUBLE:
         if (isLiteralNull(literal)){
           return createNullExpr(MinorType.FLOAT8);
@@ -556,14 +555,14 @@ public LogicalExpression visitLiteral(RexLiteral literal) {
         return ValueExpressions.getFloat8(dbl);
       case VARCHAR:
         if (isLiteralNull(literal)) {
-          return createNullExpr(MinorType.VARCHAR);
+          return createStringNullExpr(literal.getType().getPrecision());
         }
-        return ValueExpressions.getChar(((NlsString)literal.getValue()).getValue());
+        return ValueExpressions.getChar(((NlsString)literal.getValue()).getValue(), literal.getType().getPrecision());
       case SYMBOL:
         if (isLiteralNull(literal)) {
-          return createNullExpr(MinorType.VARCHAR);
+          return createStringNullExpr(literal.getType().getPrecision());
         }
-        return ValueExpressions.getChar(literal.getValue().toString());
+        return ValueExpressions.getChar(literal.getValue().toString(), literal.getType().getPrecision());
       case DATE:
         if (isLiteralNull(literal)) {
           return createNullExpr(MinorType.DATE);
@@ -599,10 +598,28 @@ public LogicalExpression visitLiteral(RexLiteral literal) {
         throw new UnsupportedOperationException(String.format("Unable to convert the value of %s and type %s to a Drill constant expression.", literal, literal.getType().getSqlTypeName()));
       }
     }
-  }
 
-  private static final TypedNullConstant createNullExpr(MinorType type) {
-    return new TypedNullConstant(Types.optional(type));
+    /**
+     * Create nullable major type using given minor type
+     * and wraps it in typed null constant.
+     *
+     * @param type minor type
+     * @return typed null constant instance
+     */
+    private TypedNullConstant createNullExpr(MinorType type) {
+      return new TypedNullConstant(Types.optional(type));
+    }
+
+    /**
+     * Create nullable varchar major type with given precision
+     * and wraps it in typed null constant.
+     *
+     * @param precision precision value
+     * @return typed null constant instance
+     */
+    private TypedNullConstant createStringNullExpr(int precision) {
+      return new TypedNullConstant(Types.withPrecision(MinorType.VARCHAR, TypeProtos.DataMode.OPTIONAL, precision));
+    }
   }
 
   public static boolean isLiteralNull(RexLiteral literal) {
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/planner/sql/SqlConverter.java b/exec/java-exec/src/main/java/org/apache/drill/exec/planner/sql/SqlConverter.java
index 845848c2e54..577804141b2 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/planner/sql/SqlConverter.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/planner/sql/SqlConverter.java
@@ -55,6 +55,7 @@
 import org.apache.calcite.sql2rel.SqlToRelConverter;
 import org.apache.drill.common.config.DrillConfig;
 import org.apache.drill.common.exceptions.UserException;
+import org.apache.drill.common.types.Types;
 import org.apache.drill.exec.ExecConstants;
 import org.apache.drill.exec.expr.fn.FunctionImplementationRegistry;
 import org.apache.drill.exec.ops.QueryContext;
@@ -226,7 +227,7 @@ public int getDefaultPrecision(SqlTypeName typeName) {
       case BINARY:
       case VARCHAR:
       case VARBINARY:
-        return 65536;
+        return Types.MAX_VARCHAR_LENGTH;
       default:
         return super.getDefaultPrecision(typeName);
       }
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/planner/sql/TypeInferenceUtils.java b/exec/java-exec/src/main/java/org/apache/drill/exec/planner/sql/TypeInferenceUtils.java
index b7942ed86b8..523b72196a5 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/planner/sql/TypeInferenceUtils.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/planner/sql/TypeInferenceUtils.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -30,9 +30,8 @@
 import org.apache.calcite.sql.SqlKind;
 import org.apache.calcite.sql.SqlLiteral;
 import org.apache.calcite.sql.SqlNode;
-import org.apache.calcite.sql.SqlOperator;
+import org.apache.calcite.sql.SqlNumericLiteral;
 import org.apache.calcite.sql.SqlOperatorBinding;
-import org.apache.calcite.sql.SqlRankFunction;
 import org.apache.calcite.sql.fun.SqlAvgAggFunction;
 import org.apache.calcite.sql.parser.SqlParserPos;
 import org.apache.calcite.sql.type.SqlReturnTypeInference;
@@ -46,7 +45,6 @@
 import org.apache.drill.common.exceptions.UserException;
 import org.apache.drill.common.types.TypeProtos;
 import org.apache.drill.common.types.Types;
-import org.apache.drill.exec.expr.TypeHelper;
 import org.apache.drill.exec.expr.fn.DrillFuncHolder;
 import org.apache.drill.exec.resolver.FunctionResolver;
 import org.apache.drill.exec.resolver.FunctionResolverFactory;
@@ -126,14 +124,15 @@ public class TypeInferenceUtils {
       .put("DATE_PART", DrillDatePartSqlReturnTypeInference.INSTANCE)
       .put("SUM", DrillSumSqlReturnTypeInference.INSTANCE)
       .put("COUNT", DrillCountSqlReturnTypeInference.INSTANCE)
-      .put("CONCAT", DrillConcatSqlReturnTypeInference.INSTANCE)
+      .put("CONCAT", DrillConcatSqlReturnTypeInference.INSTANCE_CONCAT)
+      .put("CONCATOPERATOR", DrillConcatSqlReturnTypeInference.INSTANCE_CONCAT_OP)
       .put("LENGTH", DrillLengthSqlReturnTypeInference.INSTANCE)
-      .put("LPAD", DrillPadTrimSqlReturnTypeInference.INSTANCE)
-      .put("RPAD", DrillPadTrimSqlReturnTypeInference.INSTANCE)
-      .put("LTRIM", DrillPadTrimSqlReturnTypeInference.INSTANCE)
-      .put("RTRIM", DrillPadTrimSqlReturnTypeInference.INSTANCE)
-      .put("BTRIM", DrillPadTrimSqlReturnTypeInference.INSTANCE)
-      .put("TRIM", DrillPadTrimSqlReturnTypeInference.INSTANCE)
+      .put("LPAD", DrillPadSqlReturnTypeInference.INSTANCE)
+      .put("RPAD", DrillPadSqlReturnTypeInference.INSTANCE)
+      .put("LTRIM", DrillTrimSqlReturnTypeInference.INSTANCE)
+      .put("RTRIM", DrillTrimSqlReturnTypeInference.INSTANCE)
+      .put("BTRIM", DrillTrimSqlReturnTypeInference.INSTANCE)
+      .put("TRIM", DrillTrimSqlReturnTypeInference.INSTANCE)
       .put("CONVERT_TO", DrillConvertToSqlReturnTypeInference.INSTANCE)
       .put("EXTRACT", DrillExtractSqlReturnTypeInference.INSTANCE)
       .put("SQRT", DrillSqrtSqlReturnTypeInference.INSTANCE)
@@ -142,6 +141,12 @@ public class TypeInferenceUtils {
       .put("KVGEN", DrillDeferToExecSqlReturnTypeInference.INSTANCE)
       .put("CONVERT_FROM", DrillDeferToExecSqlReturnTypeInference.INSTANCE)
 
+      // Functions that return the same type
+      .put("LOWER", DrillSameSqlReturnTypeInference.INSTANCE)
+      .put("UPPER", DrillSameSqlReturnTypeInference.INSTANCE)
+      .put("INITCAP", DrillSameSqlReturnTypeInference.INSTANCE)
+      .put("REVERSE", DrillSameSqlReturnTypeInference.INSTANCE)
+
       // Window Functions
       // RANKING
       .put(SqlKind.CUME_DIST.name(), DrillRankingSqlReturnTypeInference.INSTANCE_DOUBLE)
@@ -158,8 +163,8 @@ public class TypeInferenceUtils {
       .put("LAG", DrillLeadLagSqlReturnTypeInference.INSTANCE)
 
       // FIRST_VALUE, LAST_VALUE
-      .put("FIRST_VALUE", DrillFirstLastValueSqlReturnTypeInference.INSTANCE)
-      .put("LAST_VALUE", DrillFirstLastValueSqlReturnTypeInference.INSTANCE)
+      .put("FIRST_VALUE", DrillSameSqlReturnTypeInference.INSTANCE)
+      .put("LAST_VALUE", DrillSameSqlReturnTypeInference.INSTANCE)
 
       // Functions rely on DrillReduceAggregatesRule for expression simplification as opposed to getting evaluated directly
       .put(SqlAvgAggFunction.Subtype.AVG.name(), DrillAvgAggSqlReturnTypeInference.INSTANCE)
@@ -214,6 +219,16 @@ public static SqlReturnTypeInference getDrillSqlReturnTypeInference(
     }
   }
 
+  /**
+   * Checks if given type is string scalar type.
+   *
+   * @param sqlTypeName Calcite's sql type name
+   * @return true if given type is string scalar type
+   */
+  public static boolean isScalarStringType(final SqlTypeName sqlTypeName) {
+    return sqlTypeName == SqlTypeName.VARCHAR || sqlTypeName == SqlTypeName.CHAR;
+  }
+
   private static class DrillDefaultSqlReturnTypeInference implements SqlReturnTypeInference {
     private final List<DrillFuncHolder> functions;
 
@@ -394,31 +409,37 @@ public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
   }
 
   private static class DrillConcatSqlReturnTypeInference implements SqlReturnTypeInference {
-    private static final DrillConcatSqlReturnTypeInference INSTANCE = new DrillConcatSqlReturnTypeInference();
+    // Difference between concat function and concat operator ('||') is that concat function resolves nulls internally,
+    // i.e. does not return nulls at all.
+    private static final DrillConcatSqlReturnTypeInference INSTANCE_CONCAT = new DrillConcatSqlReturnTypeInference(false);
+    private static final DrillConcatSqlReturnTypeInference INSTANCE_CONCAT_OP = new DrillConcatSqlReturnTypeInference(true);
+
+    private final boolean isNullIfNull;
+
+    public DrillConcatSqlReturnTypeInference(boolean isNullIfNull) {
+      this.isNullIfNull = isNullIfNull;
+    }
 
     @Override
     public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
-      final RelDataTypeFactory factory = opBinding.getTypeFactory();
 
-      boolean isNullable = true;
-      int precision = 0;
-      for(RelDataType relDataType : opBinding.collectOperandTypes()) {
-        if(!relDataType.isNullable()) {
-          isNullable = false;
-        }
-
-        // If the underlying columns cannot offer information regarding the precision (i.e., the length) of the VarChar,
-        // Drill uses the largest to represent it
-        if(relDataType.getPrecision() == TypeHelper.VARCHAR_DEFAULT_CAST_LEN
-            || relDataType.getPrecision() == RelDataType.PRECISION_NOT_SPECIFIED) {
-          precision = TypeHelper.VARCHAR_DEFAULT_CAST_LEN;
+      // If the underlying columns cannot offer information regarding the precision of the VarChar,
+      // Drill uses the largest to represent it.
+      int totalPrecision = 0;
+      for (RelDataType relDataType : opBinding.collectOperandTypes()) {
+        if (isScalarStringType(relDataType.getSqlTypeName()) && relDataType.getPrecision() != RelDataType.PRECISION_NOT_SPECIFIED) {
+          totalPrecision += relDataType.getPrecision();
         } else {
-          precision += relDataType.getPrecision();
+          totalPrecision = Types.MAX_VARCHAR_LENGTH;
+          break;
         }
       }
 
-      return factory.createTypeWithNullability(
-          factory.createSqlType(SqlTypeName.VARCHAR, precision),
+      totalPrecision = totalPrecision > Types.MAX_VARCHAR_LENGTH ? Types.MAX_VARCHAR_LENGTH : totalPrecision;
+      boolean isNullable = isNullIfNull && isNullable(opBinding.collectOperandTypes());
+
+      return opBinding.getTypeFactory().createTypeWithNullability(
+          opBinding.getTypeFactory().createSqlType(SqlTypeName.VARCHAR, totalPrecision),
           isNullable);
     }
   }
@@ -441,23 +462,56 @@ public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
     }
   }
 
-  private static class DrillPadTrimSqlReturnTypeInference implements SqlReturnTypeInference {
-    private static final DrillPadTrimSqlReturnTypeInference INSTANCE = new DrillPadTrimSqlReturnTypeInference();
+  private static class DrillPadSqlReturnTypeInference implements SqlReturnTypeInference {
+    private static final DrillPadSqlReturnTypeInference INSTANCE = new DrillPadSqlReturnTypeInference();
 
     @Override
     public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
-      final RelDataTypeFactory factory = opBinding.getTypeFactory();
-      final SqlTypeName sqlTypeName = SqlTypeName.VARCHAR;
+      if (opBinding instanceof SqlCallBinding && (((SqlCallBinding) opBinding).operand(1) instanceof  SqlNumericLiteral)) {
+        int precision = ((SqlNumericLiteral) ((SqlCallBinding) opBinding).operand(1)).intValue(true);
+        RelDataType sqlType = opBinding.getTypeFactory().createSqlType(SqlTypeName.VARCHAR, Math.max(precision, 0));
+        return opBinding.getTypeFactory().createTypeWithNullability(sqlType, isNullable(opBinding.collectOperandTypes()));
+      }
 
-      for(int i = 0; i < opBinding.getOperandCount(); ++i) {
-        if(opBinding.getOperandType(i).isNullable()) {
-          return createCalciteTypeWithNullability(
-              factory, sqlTypeName, true);
-        }
+      return createCalciteTypeWithNullability(
+          opBinding.getTypeFactory(),
+          SqlTypeName.VARCHAR,
+          isNullable(opBinding.collectOperandTypes()));
+
+    }
+  }
+
+  private static class DrillTrimSqlReturnTypeInference implements SqlReturnTypeInference {
+    private static final DrillTrimSqlReturnTypeInference INSTANCE = new DrillTrimSqlReturnTypeInference();
+
+    @Override
+    public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
+      return createCalciteTypeWithNullability(
+          opBinding.getTypeFactory(),
+          SqlTypeName.VARCHAR,
+          isNullable(opBinding.collectOperandTypes()));
+    }
+  }
+
+  private static class DrillSubstringSqlReturnTypeInference implements SqlReturnTypeInference {
+    private static final DrillSubstringSqlReturnTypeInference INSTANCE = new DrillSubstringSqlReturnTypeInference();
+
+    @Override
+    public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
+      boolean isNullable = isNullable(opBinding.collectOperandTypes());
+
+      boolean isScalarString = isScalarStringType(opBinding.getOperandType(0).getSqlTypeName());
+      int precision = opBinding.getOperandType(0).getPrecision();
+
+      if (isScalarString && precision != RelDataType.PRECISION_NOT_SPECIFIED) {
+        RelDataType sqlType = opBinding.getTypeFactory().createSqlType(SqlTypeName.VARCHAR, precision);
+        return opBinding.getTypeFactory().createTypeWithNullability(sqlType, isNullable);
       }
 
       return createCalciteTypeWithNullability(
-          factory, sqlTypeName, false);
+          opBinding.getTypeFactory(),
+          SqlTypeName.VARCHAR,
+          isNullable);
     }
   }
 
@@ -511,21 +565,20 @@ private static class DrillDatePartSqlReturnTypeInference implements SqlReturnTyp
     @Override
     public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
       final RelDataTypeFactory factory = opBinding.getTypeFactory();
+      final boolean isNullable = opBinding.getOperandType(1).isNullable();
 
-      final SqlNode firstOperand = ((SqlCallBinding) opBinding).operand(0);
-      if(!(firstOperand instanceof SqlCharStringLiteral)) {
+      if (!(opBinding instanceof SqlCallBinding) || !(((SqlCallBinding) opBinding).operand(0) instanceof SqlCharStringLiteral)) {
         return createCalciteTypeWithNullability(factory,
             SqlTypeName.ANY,
-            opBinding.getOperandType(1).isNullable());
+            isNullable);
       }
 
-      final String part = ((SqlCharStringLiteral) firstOperand)
+      final String part = ((SqlCharStringLiteral) ((SqlCallBinding) opBinding).operand(0))
           .getNlsString()
           .getValue()
           .toUpperCase();
 
       final SqlTypeName sqlTypeName = getSqlTypeNameForTimeUnit(part);
-      final boolean isNullable = opBinding.getOperandType(1).isNullable();
       return createCalciteTypeWithNullability(
           factory,
           sqlTypeName,
@@ -598,15 +651,12 @@ private static class DrillLeadLagSqlReturnTypeInference implements SqlReturnType
     private static final DrillLeadLagSqlReturnTypeInference INSTANCE = new DrillLeadLagSqlReturnTypeInference();
     @Override
     public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
-      return createCalciteTypeWithNullability(
-          opBinding.getTypeFactory(),
-          opBinding.getOperandType(0).getSqlTypeName(),
-          true);
+      return opBinding.getTypeFactory().createTypeWithNullability(opBinding.getOperandType(0), true);
     }
   }
 
-  private static class DrillFirstLastValueSqlReturnTypeInference implements SqlReturnTypeInference {
-    private static final DrillFirstLastValueSqlReturnTypeInference INSTANCE = new DrillFirstLastValueSqlReturnTypeInference();
+  private static class DrillSameSqlReturnTypeInference implements SqlReturnTypeInference {
+    private static final DrillSameSqlReturnTypeInference INSTANCE = new DrillSameSqlReturnTypeInference();
     @Override
     public RelDataType inferReturnType(SqlOperatorBinding opBinding) {
       return opBinding.getOperandType(0);
@@ -697,7 +747,7 @@ public static RelDataType createCalciteTypeWithNullability(RelDataTypeFactory ty
               TimeUnit.MONTH,
               SqlParserPos.ZERO));
     } else if (sqlTypeName == SqlTypeName.VARCHAR) {
-      type = typeFactory.createSqlType(sqlTypeName, TypeHelper.VARCHAR_DEFAULT_CAST_LEN);
+      type = typeFactory.createSqlType(sqlTypeName, Types.MAX_VARCHAR_LENGTH);
     } else {
       type = typeFactory.createSqlType(sqlTypeName);
     }
@@ -733,6 +783,21 @@ public static FunctionCall convertSqlOperatorBindingToFunctionCall(final SqlOper
     return functionCall;
   }
 
+  /**
+   * Checks if at least one of the operand types is nullable.
+   *
+   * @param operandTypes operand types
+   * @return true if one of the operands is nullable, false otherwise
+   */
+  private static boolean isNullable(List<RelDataType> operandTypes) {
+    for (RelDataType relDataType : operandTypes) {
+      if (relDataType.isNullable()) {
+        return true;
+      }
+    }
+    return false;
+  }
+
   /**
    * This class is not intended to be instantiated
    */
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/planner/sql/handlers/FindLimit0Visitor.java b/exec/java-exec/src/main/java/org/apache/drill/exec/planner/sql/handlers/FindLimit0Visitor.java
index 6df6e0d92ef..d5216e735a5 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/planner/sql/handlers/FindLimit0Visitor.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/planner/sql/handlers/FindLimit0Visitor.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -84,23 +84,27 @@ public class FindLimit0Visitor extends RelShuttleImpl {
    */
   public static DrillRel getDirectScanRelIfFullySchemaed(RelNode rel) {
     final List<RelDataTypeField> fieldList = rel.getRowType().getFieldList();
-    final List<SqlTypeName> columnTypes = Lists.newArrayList();
-    final List<TypeProtos.DataMode> dataModes = Lists.newArrayList();
+    final List<TypeProtos.MajorType> columnTypes = Lists.newArrayList();
+
 
     for (final RelDataTypeField field : fieldList) {
       final SqlTypeName sqlTypeName = field.getType().getSqlTypeName();
       if (!TYPES.contains(sqlTypeName)) {
         return null;
       } else {
-        columnTypes.add(sqlTypeName);
-        dataModes.add(field.getType().isNullable() ?
-            TypeProtos.DataMode.OPTIONAL : TypeProtos.DataMode.REQUIRED);
+        final TypeProtos.MajorType.Builder builder = TypeProtos.MajorType.newBuilder()
+            .setMode(field.getType().isNullable() ? TypeProtos.DataMode.OPTIONAL : TypeProtos.DataMode.REQUIRED)
+            .setMinorType(TypeInferenceUtils.getDrillTypeFromCalciteType(sqlTypeName));
+
+        if (TypeInferenceUtils.isScalarStringType(sqlTypeName)) {
+          builder.setPrecision(field.getType().getPrecision());
+        }
+
+        columnTypes.add(builder.build());
       }
     }
-
     final RelTraitSet traits = rel.getTraitSet().plus(DrillRel.DRILL_LOGICAL);
-    final RelDataTypeReader reader = new RelDataTypeReader(rel.getRowType().getFieldNames(), columnTypes,
-        dataModes);
+    final RelDataTypeReader reader = new RelDataTypeReader(rel.getRowType().getFieldNames(), columnTypes);
     return new DrillDirectScanRel(rel.getCluster(), traits,
         new DirectGroupScan(reader, ScanStats.ZERO_RECORD_TABLE), rel.getRowType());
   }
@@ -197,25 +201,18 @@ public RelNode visit(LogicalUnion union) {
   public static class RelDataTypeReader extends AbstractRecordReader {
 
     public final List<String> columnNames;
-    public final List<SqlTypeName> columnTypes;
-    public final List<TypeProtos.DataMode> dataModes;
+    public final List<TypeProtos.MajorType> columnTypes;
 
-    public RelDataTypeReader(List<String> columnNames, List<SqlTypeName> columnTypes,
-        List<TypeProtos.DataMode> dataModes) {
-      Preconditions.checkArgument(columnNames.size() == columnTypes.size() &&
-          columnTypes.size() == dataModes.size());
+    public RelDataTypeReader(List<String> columnNames, List<TypeProtos.MajorType> columnTypes) {
+      Preconditions.checkArgument(columnNames.size() == columnTypes.size(), "Number of columns and their types should match");
       this.columnNames = columnNames;
       this.columnTypes = columnTypes;
-      this.dataModes = dataModes;
     }
 
     @Override
     public void setup(OperatorContext context, OutputMutator output) throws ExecutionSetupException {
       for (int i = 0; i < columnNames.size(); i++) {
-        final TypeProtos.MajorType type = TypeProtos.MajorType.newBuilder()
-            .setMode(dataModes.get(i))
-            .setMinorType(TypeInferenceUtils.getDrillTypeFromCalciteType(columnTypes.get(i)))
-            .build();
+        final TypeProtos.MajorType type = columnTypes.get(i);
         final MaterializedField field = MaterializedField.create(columnNames.get(i), type);
         final Class vvClass = TypeHelper.getValueVectorClass(type.getMinorType(), type.getMode());
         try {
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/store/mock/ColumnDef.java b/exec/java-exec/src/main/java/org/apache/drill/exec/store/mock/ColumnDef.java
index 23009903360..c1137bdfa62 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/store/mock/ColumnDef.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/store/mock/ColumnDef.java
@@ -37,9 +37,8 @@ public class ColumnDef {
   public ColumnDef(MockColumn mockCol) {
     this.mockCol = mockCol;
     name = mockCol.getName();
-    if (mockCol.getMinorType() == MinorType.VARCHAR &&
-        mockCol.getWidth() > 0) {
-      width = mockCol.getWidth();
+    if (mockCol.getMinorType() == MinorType.VARCHAR && mockCol.getPrecision() > 0) {
+      width = mockCol.getPrecision();
     } else {
       width = TypeHelper.getSize(mockCol.getMajorType());
     }
diff --git a/exec/java-exec/src/main/java/org/apache/drill/exec/work/prepare/PreparedStatementProvider.java b/exec/java-exec/src/main/java/org/apache/drill/exec/work/prepare/PreparedStatementProvider.java
index daadcfcd3fe..45b3a8d544e 100644
--- a/exec/java-exec/src/main/java/org/apache/drill/exec/work/prepare/PreparedStatementProvider.java
+++ b/exec/java-exec/src/main/java/org/apache/drill/exec/work/prepare/PreparedStatementProvider.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -99,6 +99,7 @@ public class PreparedStatementProvider {
       .put(MinorType.TIME, Time.class.getName())
       .put(MinorType.TIMESTAMP, Timestamp.class.getName())
       .put(MinorType.VARBINARY, byte[].class.getName())
+      .put(MinorType.INTERVAL, Period.class.getName())
       .put(MinorType.INTERVALYEAR, Period.class.getName())
       .put(MinorType.INTERVALDAY, Period.class.getName())
       .put(MinorType.MAP, Object.class.getName())
@@ -354,7 +355,7 @@ private static ResultColumnMetadata serializeColumn(SerializedField field) {
     /**
      * For numeric data, this is the maximum precision.
      * For character data, this is the length in characters.
-     * For datetime datatypes, this is the length in characters of the String representation
+     * For datetime data types, this is the length in characters of the String representation
      *    (assuming the maximum allowed precision of the fractional seconds component).
      * For binary data, this is the length in bytes.
      * For all other types 0 is returned where the column size is not applicable.
diff --git a/exec/java-exec/src/test/java/org/apache/drill/exec/physical/impl/limit/TestEarlyLimit0Optimization.java b/exec/java-exec/src/test/java/org/apache/drill/exec/physical/impl/limit/TestEarlyLimit0Optimization.java
index 70b0cb317f7..44035c5b2db 100644
--- a/exec/java-exec/src/test/java/org/apache/drill/exec/physical/impl/limit/TestEarlyLimit0Optimization.java
+++ b/exec/java-exec/src/test/java/org/apache/drill/exec/physical/impl/limit/TestEarlyLimit0Optimization.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -57,7 +57,7 @@ public static void createView() throws Exception {
         "CAST(salary AS FLOAT) AS fsalary, " +
         "CAST((CASE WHEN marital_status = 'S' THEN true ELSE false END) AS BOOLEAN) AS single, " +
         "CAST(education_level AS VARCHAR(60)) AS education_level," +
-        "CAST(gender AS CHAR) AS gender " +
+        "CAST(gender AS CHAR(1)) AS gender " +
         "FROM cp.`employee.json` " +
         "ORDER BY employee_id " +
         "LIMIT 1;", viewName));
@@ -121,7 +121,7 @@ public void simpleSelectLimit0() throws Exception {
     @SuppressWarnings("unchecked")
     final List<Pair<SchemaPath, TypeProtos.MajorType>> expectedSchema = Lists.newArrayList(
         Pair.of(SchemaPath.getSimplePath("employee_id"), Types.optional(TypeProtos.MinorType.INT)),
-        Pair.of(SchemaPath.getSimplePath("full_name"), Types.optional(TypeProtos.MinorType.VARCHAR)),
+        Pair.of(SchemaPath.getSimplePath("full_name"), Types.withPrecision(TypeProtos.MinorType.VARCHAR, TypeProtos.DataMode.OPTIONAL, 25)),
         Pair.of(SchemaPath.getSimplePath("position_id"), Types.optional(TypeProtos.MinorType.INT)),
         Pair.of(SchemaPath.getSimplePath("department_id"), Types.optional(TypeProtos.MinorType.BIGINT)),
         Pair.of(SchemaPath.getSimplePath("birth_date"), Types.optional(TypeProtos.MinorType.DATE)),
@@ -129,8 +129,8 @@ public void simpleSelectLimit0() throws Exception {
         Pair.of(SchemaPath.getSimplePath("salary"), Types.optional(TypeProtos.MinorType.FLOAT8)),
         Pair.of(SchemaPath.getSimplePath("fsalary"), Types.optional(TypeProtos.MinorType.FLOAT4)),
         Pair.of(SchemaPath.getSimplePath("single"), Types.required(TypeProtos.MinorType.BIT)),
-        Pair.of(SchemaPath.getSimplePath("education_level"), Types.optional(TypeProtos.MinorType.VARCHAR)),
-        Pair.of(SchemaPath.getSimplePath("gender"), Types.optional(TypeProtos.MinorType.VARCHAR)));
+        Pair.of(SchemaPath.getSimplePath("education_level"), Types.withPrecision(TypeProtos.MinorType.VARCHAR, TypeProtos.DataMode.OPTIONAL, 60)),
+        Pair.of(SchemaPath.getSimplePath("gender"), Types.withPrecision(TypeProtos.MinorType.VARCHAR, TypeProtos.DataMode.OPTIONAL, 1)));
 
     testBuilder()
         .sqlQuery(wrapLimit0(String.format("SELECT * FROM %s", viewName)))
@@ -527,10 +527,11 @@ public void cast() throws Exception {
     checkThatQueryPlanIsOptimized(query);
   }
 
-  public void concatTest(final String query) throws Exception {
+  public void concatTest(final String query, int precision, boolean isNullable) throws Exception {
     @SuppressWarnings("unchecked")
-    final List<Pair<SchemaPath, TypeProtos.MajorType>> expectedSchema = Lists.newArrayList(
-        Pair.of(SchemaPath.getSimplePath("c"), Types.optional(TypeProtos.MinorType.VARCHAR)));
+    final List<Pair<SchemaPath, TypeProtos.MajorType>> expectedSchema =
+        Lists.newArrayList(Pair.of(SchemaPath.getSimplePath("c"), Types.withPrecision(TypeProtos.MinorType.VARCHAR,
+            isNullable ? TypeProtos.DataMode.OPTIONAL : TypeProtos.DataMode.REQUIRED, precision)));
 
     testBuilder()
         .sqlQuery(query)
@@ -549,12 +550,12 @@ public void concatTest(final String query) throws Exception {
 
   @Test
   public void concat() throws Exception {
-    concatTest("SELECT CONCAT(full_name, education_level) AS c FROM " + viewName);
+    concatTest("SELECT CONCAT(full_name, education_level) AS c FROM " + viewName, 85, false);
   }
 
   @Test
   public void concatOp() throws Exception {
-    concatTest("SELECT full_name || education_level AS c FROM " + viewName);
+    concatTest("SELECT full_name || education_level AS c FROM " + viewName, 85, true);
   }
 
   @Test
@@ -601,7 +602,7 @@ public void binary() throws Exception {
     @SuppressWarnings("unchecked")
     final List<Pair<SchemaPath, TypeProtos.MajorType>> expectedSchema = Lists.newArrayList(
         Pair.of(SchemaPath.getSimplePath("b"), Types.required(TypeProtos.MinorType.BIT)),
-        Pair.of(SchemaPath.getSimplePath("c"), Types.optional(TypeProtos.MinorType.VARCHAR)),
+        Pair.of(SchemaPath.getSimplePath("c"), Types.withPrecision(TypeProtos.MinorType.VARCHAR, TypeProtos.DataMode.OPTIONAL, 85)),
         Pair.of(SchemaPath.getSimplePath("d"), Types.optional(TypeProtos.MinorType.INT)),
         Pair.of(SchemaPath.getSimplePath("e"), Types.optional(TypeProtos.MinorType.BIT)),
         Pair.of(SchemaPath.getSimplePath("g"), Types.optional(TypeProtos.MinorType.BIT)),
@@ -631,10 +632,10 @@ public void binary() throws Exception {
     checkThatQueryPlanIsOptimized(query);
   }
 
-  public void substringTest(final String query) throws Exception {
+  public void substringTest(final String query, int precision) throws Exception {
     @SuppressWarnings("unchecked")
     final List<Pair<SchemaPath, TypeProtos.MajorType>> expectedSchema = Lists.newArrayList(
-        Pair.of(SchemaPath.getSimplePath("s"), Types.optional(TypeProtos.MinorType.VARCHAR)));
+        Pair.of(SchemaPath.getSimplePath("s"), Types.withPrecision(TypeProtos.MinorType.VARCHAR, TypeProtos.DataMode.OPTIONAL, precision)));
 
     testBuilder()
         .sqlQuery(query)
@@ -653,11 +654,11 @@ public void substringTest(final String query) throws Exception {
 
   @Test
   public void substring() throws Exception {
-    substringTest("SELECT SUBSTRING(full_name, 1, 5) AS s FROM " + viewName);
+    substringTest("SELECT SUBSTRING(full_name, 1, 5) AS s FROM " + viewName, Types.MAX_VARCHAR_LENGTH);
   }
 
   @Test
   public void substr() throws Exception {
-    substringTest("SELECT SUBSTR(full_name, 1, 5) AS s FROM " + viewName);
+    substringTest("SELECT SUBSTR(full_name, 1, 5) AS s FROM " + viewName, Types.MAX_VARCHAR_LENGTH);
   }
 }
diff --git a/exec/java-exec/src/test/java/org/apache/drill/exec/work/prepare/PreparedStatementTestBase.java b/exec/java-exec/src/test/java/org/apache/drill/exec/work/prepare/PreparedStatementTestBase.java
new file mode 100644
index 00000000000..814414c4c10
--- /dev/null
+++ b/exec/java-exec/src/test/java/org/apache/drill/exec/work/prepare/PreparedStatementTestBase.java
@@ -0,0 +1,131 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to you under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.drill.exec.work.prepare;
+
+import org.apache.drill.BaseTestQuery;
+import org.apache.drill.exec.proto.UserBitShared;
+import org.apache.drill.exec.proto.UserProtos;
+import org.apache.drill.exec.store.ischema.InfoSchemaConstants;
+
+import java.util.List;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+public class PreparedStatementTestBase extends BaseTestQuery {
+
+  /* Helper method which creates a prepared statement for given query. */
+  protected UserProtos.PreparedStatement createPrepareStmt(String query,
+                                                        boolean expectFailure,
+                                                        UserBitShared.DrillPBError.ErrorType errorType) throws Exception {
+    UserProtos.CreatePreparedStatementResp resp = client.createPreparedStatement(query).get();
+
+    if (expectFailure) {
+      assertEquals(UserProtos.RequestStatus.FAILED, resp.getStatus());
+      assertEquals(errorType, resp.getError().getErrorType());
+    } else {
+      String message = resp.hasError() ? resp.getError().getMessage() : "No errors";
+      assertEquals(message, UserProtos.RequestStatus.OK, resp.getStatus());
+    }
+
+    return resp.getPreparedStatement();
+  }
+
+  protected void verifyMetadata(List<ExpectedColumnResult> expMetadata,
+                                     List<UserProtos.ResultColumnMetadata> actMetadata) {
+    assertEquals(expMetadata.size(), actMetadata.size());
+
+    int i = 0;
+    for (ExpectedColumnResult exp : expMetadata) {
+      UserProtos.ResultColumnMetadata act = actMetadata.get(i++);
+
+      assertTrue("Failed to find the expected column metadata: " + exp + ". Was: " + toString(act), exp.isEqualsTo(act));
+    }
+  }
+
+  protected static class ExpectedColumnResult {
+    final String columnName;
+    final String type;
+    final boolean nullable;
+    final int displaySize;
+    final int precision;
+    final int scale;
+    final boolean signed;
+    final String className;
+
+    ExpectedColumnResult(String columnName, String type, boolean nullable, int displaySize, int precision, int scale,
+                         boolean signed, String className) {
+      this.columnName = columnName;
+      this.type = type;
+      this.nullable = nullable;
+      this.displaySize = displaySize;
+      this.precision = precision;
+      this.scale = scale;
+      this.signed = signed;
+      this.className = className;
+    }
+
+    boolean isEqualsTo(UserProtos.ResultColumnMetadata result) {
+      return
+          result.getCatalogName().equals(InfoSchemaConstants.IS_CATALOG_NAME) &&
+              result.getSchemaName().isEmpty() &&
+              result.getTableName().isEmpty() &&
+              result.getColumnName().equals(columnName) &&
+              result.getLabel().equals(columnName) &&
+              result.getDataType().equals(type) &&
+              result.getIsNullable() == nullable &&
+              result.getPrecision() == precision &&
+              result.getScale() == scale &&
+              result.getSigned() == signed &&
+              result.getDisplaySize() == displaySize &&
+              result.getClassName().equals(className) &&
+              result.getSearchability() == UserProtos.ColumnSearchability.ALL &&
+              result.getAutoIncrement() == false &&
+              result.getCaseSensitivity() == false &&
+              result.getUpdatability() == UserProtos.ColumnUpdatability.READ_ONLY &&
+              result.getIsAliased() == true &&
+              result.getIsCurrency() == false;
+    }
+
+    @Override
+    public String toString() {
+      return "ExpectedColumnResult[" +
+          "columnName='" + columnName + '\'' +
+          ", type='" + type + '\'' +
+          ", nullable=" + nullable +
+          ", displaySize=" + displaySize +
+          ", precision=" + precision +
+          ", scale=" + scale +
+          ", signed=" + signed +
+          ", className='" + className + '\'' +
+          ']';
+    }
+  }
+
+  private static String toString(UserProtos.ResultColumnMetadata metadata) {
+    return "ResultColumnMetadata[" +
+        "columnName='" + metadata.getColumnName() + '\'' +
+        ", type='" + metadata.getDataType() + '\'' +
+        ", nullable=" + metadata.getIsNullable() +
+        ", displaySize=" + metadata.getDisplaySize() +
+        ", precision=" + metadata.getPrecision() +
+        ", scale=" + metadata.getScale() +
+        ", signed=" + metadata.getSigned() +
+        ", className='" + metadata.getClassName() + '\'' +
+        ']';
+  }
+}
diff --git a/exec/java-exec/src/test/java/org/apache/drill/exec/work/prepare/TestLimit0VsRegularQueriesMetadata.java b/exec/java-exec/src/test/java/org/apache/drill/exec/work/prepare/TestLimit0VsRegularQueriesMetadata.java
new file mode 100644
index 00000000000..f6a940195d6
--- /dev/null
+++ b/exec/java-exec/src/test/java/org/apache/drill/exec/work/prepare/TestLimit0VsRegularQueriesMetadata.java
@@ -0,0 +1,315 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to you under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.drill.exec.work.prepare;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Lists;
+import org.apache.drill.common.types.Types;
+import org.apache.drill.exec.ExecConstants;
+import org.junit.Test;
+
+import java.util.List;
+
+public class TestLimit0VsRegularQueriesMetadata extends PreparedStatementTestBase {
+
+  @Test
+  public void stringCasts() throws Exception {
+    String query = "select\n" +
+        "cast(col_int as varchar(30)) as col_int,\n" +
+        "cast(col_vrchr as varchar(31)) as col_vrchr,\n" +
+        "cast(col_dt as varchar(32)) as col_dt,\n" +
+        "cast(col_tim as varchar(33)) as col_tim,\n" +
+        "cast(col_tmstmp as varchar(34)) as col_tmstmp,\n" +
+        "cast(col_flt as varchar(35)) as col_flt,\n" +
+        "cast(col_intrvl_yr as varchar(36)) as col_intrvl_yr,\n" +
+        "cast(col_bln as varchar(37)) as col_bln\n" +
+        "from cp.`parquet/alltypes_optional.parquet`";
+
+    List<ExpectedColumnResult> expectedMetadata = ImmutableList.of(
+        new ExpectedColumnResult("col_int", "CHARACTER VARYING", true, 30, 30, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_vrchr", "CHARACTER VARYING", true, 31, 31, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_dt", "CHARACTER VARYING", true, 32, 32, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_tim", "CHARACTER VARYING", true, 33, 33, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_tmstmp", "CHARACTER VARYING", true, 34, 34, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_flt", "CHARACTER VARYING", true, 35, 35, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_intrvl_yr", "CHARACTER VARYING", true, 36, 36, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_bln", "CHARACTER VARYING", true, 37, 37, 0, false, String.class.getName())
+    );
+
+    verifyResults(query, expectedMetadata);
+  }
+
+  @Test
+  public void stringCastForDecimal() throws Exception {
+    try {
+      test("alter session set `planner.enable_decimal_data_type` = true");
+      String query = "select cast(commission_pct as varchar(50)) as commission_pct from cp.`parquet/fixedlenDecimal.parquet`";
+      List<ExpectedColumnResult> expectedMetadata = ImmutableList.of(
+          new ExpectedColumnResult("commission_pct", "CHARACTER VARYING", true, 50, 50, 0, false, String.class.getName()));
+
+      verifyResults(query, expectedMetadata);
+    } finally {
+      test("alter session reset `planner.enable_decimal_data_type`");
+    }
+  }
+
+  @Test
+  public void constants() throws Exception {
+    String query = "select\n" +
+        "'aaa' as col_a,\n" +
+        "10 as col_i\n," +
+        "cast(null as varchar(5)) as col_n\n," +
+        "cast('aaa' as varchar(5)) as col_a_short,\n" +
+        "cast(10 as varchar(5)) as col_i_short,\n" +
+        "cast('aaaaaaaaaaaaa' as varchar(5)) as col_a_long,\n" +
+        "cast(1000000000 as varchar(5)) as col_i_long\n" +
+        "from (values(1))";
+
+    List<ExpectedColumnResult> expectedMetadata = ImmutableList.of(
+        new ExpectedColumnResult("col_a", "CHARACTER VARYING", false, 3, 3, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_i", "INTEGER", false, 11, 0, 0, true, Integer.class.getName()),
+        new ExpectedColumnResult("col_n", "CHARACTER VARYING", true, 5, 5, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_a_short", "CHARACTER VARYING", false, 5, 5, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_i_short", "CHARACTER VARYING", false, 5, 5, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_a_long", "CHARACTER VARYING", false, 5, 5, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_i_long", "CHARACTER VARYING", false, 5, 5, 0, false, String.class.getName())
+    );
+
+    verifyResults(query, expectedMetadata);
+  }
+
+  @Test
+  public void windowFunctions() throws Exception {
+    String query = "select\n" +
+        "lead(sales_country) over (partition by sales_country order by region_id) as col_lead,\n" +
+        "lag(sales_country) over (partition by sales_country order by region_id) as col_lag,\n" +
+        "first_value(sales_country) over (partition by sales_country order by region_id) as col_first_value,\n" +
+        "last_value(sales_country) over (partition by sales_country order by region_id) as col_last_value\n" +
+        "from (select cast(sales_country as varchar(30)) as sales_country, region_id from cp.`region.json`)";
+
+    List<ExpectedColumnResult> expectedMetadata = ImmutableList.of(
+        new ExpectedColumnResult("col_lead", "CHARACTER VARYING", true, 30, 30, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_lag", "CHARACTER VARYING", true, 30, 30, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_first_value", "CHARACTER VARYING", true, 30, 30, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_last_value", "CHARACTER VARYING", true, 30, 30, 0, false, String.class.getName())
+    );
+
+    verifyResults(query, expectedMetadata);
+  }
+
+  @Test
+  public void functionsWithSameInOutLength() throws Exception {
+    String query = "select\n" +
+        "lower(sales_city) as lower_col,\n" +
+        "upper(sales_city) as upper_col,\n" +
+        "initcap(sales_city) as initcap_col,\n" +
+        "reverse(sales_city) as reverse_col,\n" +
+        "lower(cast(sales_city as varchar(30))) as lower_cast_col,\n" +
+        "upper(cast(sales_city as varchar(30))) as upper_cast_col,\n" +
+        "initcap(cast(sales_city as varchar(30))) as initcap_cast_col,\n" +
+        "reverse(cast(sales_city as varchar(30))) as reverse_cast_col\n" +
+        "from cp.`region.json`";
+
+    List<ExpectedColumnResult> expectedMetadata = ImmutableList.of(
+        new ExpectedColumnResult("lower_col", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("upper_col", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("initcap_col", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("reverse_col", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("lower_cast_col", "CHARACTER VARYING", true, 30, 30, 0, false, String.class.getName()),
+        new ExpectedColumnResult("upper_cast_col", "CHARACTER VARYING", true, 30, 30, 0, false, String.class.getName()),
+        new ExpectedColumnResult("initcap_cast_col", "CHARACTER VARYING", true, 30, 30, 0, false, String.class.getName()),
+        new ExpectedColumnResult("reverse_cast_col", "CHARACTER VARYING", true, 30, 30, 0, false, String.class.getName())
+    );
+
+    verifyResults(query, expectedMetadata);
+  }
+
+  @Test
+  public void ifExpression() throws Exception {
+    String query = "select\n" +
+        "case when sales_state_province = 'CA' then 'a' when sales_state_province = 'DB' then 'aa' else 'aaa' end as col_123,\n" +
+        "case when sales_state_province = 'CA' then 'aa' when sales_state_province = 'DB' then 'a' else 'aaa' end as col_213,\n" +
+        "case when sales_state_province = 'CA' then 'a' when sales_state_province = 'DB' then 'aaa' else 'aa' end as col_132,\n" +
+        "case when sales_state_province = 'CA' then 'aa' when sales_state_province = 'DB' then 'aaa' else 'a' end as col_231,\n" +
+        "case when sales_state_province = 'CA' then 'aaa' when sales_state_province = 'DB' then 'aa' else 'a' end as col_321,\n" +
+        "case when sales_state_province = 'CA' then 'aaa' when sales_state_province = 'DB' then 'a' else 'aa' end as col_312,\n" +
+        "case when sales_state_province = 'CA' then sales_state_province when sales_state_province = 'DB' then 'a' else 'aa' end as col_unk1,\n" +
+        "case when sales_state_province = 'CA' then 'aaa' when sales_state_province = 'DB' then sales_state_province else 'aa' end as col_unk2,\n" +
+        "case when sales_state_province = 'CA' then 'aaa' when sales_state_province = 'DB' then 'a' else sales_state_province end as col_unk3\n" +
+        "from cp.`region.json`";
+
+    List<ExpectedColumnResult> expectedMetadata = ImmutableList.of(
+        new ExpectedColumnResult("col_123", "CHARACTER VARYING", false, 3, 3, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_213", "CHARACTER VARYING", false, 3, 3, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_132", "CHARACTER VARYING", false, 3, 3, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_231", "CHARACTER VARYING", false, 3, 3, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_321", "CHARACTER VARYING", false, 3, 3, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_312", "CHARACTER VARYING", false, 3, 3, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_unk1", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_unk2", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_unk3", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName())
+    );
+
+    verifyResults(query, expectedMetadata);
+  }
+
+  @Test
+  public void coalesce() throws Exception {
+    String query = "select\n" +
+        "coalesce(cast(sales_city as varchar(10)), 'unknown') as col_first_cond,\n" +
+        "coalesce(cast(sales_city as varchar(10)), cast('unknown' as varchar(20))) as col_second_cond,\n" +
+        "coalesce(cast(null as varchar(10)), 'unknown') as col_null,\n" +
+        "coalesce(sales_city, sales_country) as col_unk\n" +
+        "from cp.`region.json`";
+
+    List<ExpectedColumnResult> expectedMetadata = ImmutableList.of(
+        new ExpectedColumnResult("col_first_cond", "CHARACTER VARYING", true, 10, 10, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_second_cond", "CHARACTER VARYING", true, 20, 20, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_null", "CHARACTER VARYING", true, 10, 10, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_unk", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName())
+    );
+
+    verifyResults(query, expectedMetadata);
+  }
+
+  @Test
+  public void pad() throws Exception {
+    String query = "SELECT\n" +
+        "%1$s(cast(sales_city as varchar(10)), 10, 'A') as col_same_pad,\n" +
+        "%1$s(cast(sales_city as varchar(10)), 0, 'A') as col_zero_pad,\n" +
+        "%1$s(cast(sales_city as varchar(10)), -1, 'A') as col_negative_pad,\n" +
+        "%1$s(cast(sales_city as varchar(10)), 9, 'A') as col_lower_pad,\n" +
+        "%1$s(cast(sales_city as varchar(10)), 20, 'A') as col_greater_pad,\n" +
+        "%1$s(sales_city, 10, 'A') as col_unk_source_length,\n" +
+        "%1$s(cast(sales_city as varchar(10)), '10', 'A') as col_length_char\n" +
+        "from cp.`region.json`";
+
+    List<ExpectedColumnResult> expectedMetadata = ImmutableList.of(
+        new ExpectedColumnResult("col_same_pad", "CHARACTER VARYING", true, 10, 10, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_zero_pad", "CHARACTER VARYING", true, 0, 0, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_negative_pad", "CHARACTER VARYING", true, 0, 0, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_lower_pad", "CHARACTER VARYING", true, 9, 9, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_greater_pad", "CHARACTER VARYING", true, 20, 20, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_unk_source_length", "CHARACTER VARYING", true, 10, 10, 0, false, String.class.getName()),
+        new ExpectedColumnResult("col_length_char", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName())
+    );
+
+    List<String> padFunctions = Lists.newArrayList("rpad", "lpad");
+    for (String function : padFunctions) {
+      verifyResults(String.format(query, function), expectedMetadata);
+    }
+  }
+
+  @Test
+  public void concat() throws Exception {
+    String query = "select\n" +
+        "concat(cast(sales_city as varchar(10)), cast(sales_city as varchar(10))) as concat_two_casts,\n" +
+        "concat(cast(sales_city as varchar(60000)), cast(sales_city as varchar(60000))) as concat_max_length,\n" +
+        "concat(cast(sales_city as varchar(10)), sales_city) as concat_one_unknown,\n" +
+        "concat(sales_city, sales_city) as concat_two_unknown,\n" +
+        "concat(cast(sales_city as varchar(10)), 'a') as concat_one_constant,\n" +
+        "concat('a', 'a') as concat_two_constants,\n" +
+        "concat(cast(sales_city as varchar(10)), cast(null as varchar(10))) as concat_right_null,\n" +
+        "concat(cast(null as varchar(10)), cast(sales_city as varchar(10))) as concat_left_null,\n" +
+        "concat(cast(null as varchar(10)), cast(null as varchar(10))) as concat_both_null,\n" +
+        "concat(cast(sales_district_id as integer), '_D') as concat_with_int,\n" +
+
+        "cast(sales_city as varchar(10)) || cast(sales_city as varchar(10)) as concat_op_two_casts,\n" +
+        "cast(sales_city as varchar(60000)) || cast(sales_city as varchar(60000)) as concat_op_max_length,\n" +
+        "cast(sales_city as varchar(10)) || sales_city as concat_op_one_unknown,\n" +
+        "sales_city || sales_city as concat_op_two_unknown,\n" +
+        "cast(sales_city as varchar(10)) || 'a' as concat_op_one_constant,\n" +
+        "'a' || 'a' as concat_op_two_constants,\n" +
+        "cast(sales_city as varchar(10)) || cast(null as varchar(10)) as concat_op_right_null,\n" +
+        "cast(null as varchar(10)) || cast(sales_city as varchar(10)) as concat_op_left_null,\n" +
+        "cast(null as varchar(10)) || cast(null as varchar(10)) as concat_op_both_null,\n" +
+        "cast(sales_district_id as integer) || '_D' as concat_op_with_int\n" +
+        "from cp.`region.json`";
+
+    List<ExpectedColumnResult> expectedMetadata = ImmutableList.of(
+        new ExpectedColumnResult("concat_two_casts", "CHARACTER VARYING", false, 20, 20, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_max_length", "CHARACTER VARYING", false, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_one_unknown", "CHARACTER VARYING", false, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_two_unknown", "CHARACTER VARYING", false, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_one_constant", "CHARACTER VARYING", false, 11, 11, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_two_constants", "CHARACTER VARYING", false, 2, 2, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_right_null", "CHARACTER VARYING", false, 20, 20, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_left_null", "CHARACTER VARYING", false, 20, 20, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_both_null", "CHARACTER VARYING", false, 20, 20, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_with_int", "CHARACTER VARYING", false, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+
+        new ExpectedColumnResult("concat_op_two_casts", "CHARACTER VARYING", true, 20, 20, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_op_max_length", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_op_one_unknown", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_op_two_unknown", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_op_one_constant", "CHARACTER VARYING", true, 11, 11, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_op_two_constants", "CHARACTER VARYING", false, 2, 2, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_op_right_null", "CHARACTER VARYING", true, 20, 20, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_op_left_null", "CHARACTER VARYING", true, 20, 20, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_op_both_null", "CHARACTER VARYING", true, 20, 20, 0, false, String.class.getName()),
+        new ExpectedColumnResult("concat_op_with_int", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName())
+        );
+
+    verifyResults(query, expectedMetadata);
+  }
+
+  @Test
+  public void unionWithConstants() throws Exception {
+    String query = "select * from (\n" +
+        "select cast('AAA' as varchar(3)) as col_const from (values(1))\n" +
+        "union all\n" +
+        "select cast('AAA' as varchar(5)) as col_const from (values(1))\n" +
+        ")";
+
+    List<ExpectedColumnResult> expectedMetadata = ImmutableList.of(
+        new ExpectedColumnResult("col_const", "CHARACTER VARYING", false, 5, 5, 0, false, String.class.getName())
+    );
+
+    verifyResults(query, expectedMetadata);
+  }
+
+  @Test
+  public void unionWithOptionalRequired() throws Exception {
+    String query = "select * from (\n" +
+        "select cast('AAA' as varchar(10)) as col_const from (values(1))\n" +
+        "union all\n" +
+        "select cast(sales_city as varchar(10)) as col_const from cp.`region.json`\n" +
+        ")";
+
+    List<ExpectedColumnResult> expectedMetadata = ImmutableList.of(
+        new ExpectedColumnResult("col_const", "CHARACTER VARYING", true, 10, 10, 0, false, String.class.getName())
+    );
+
+    verifyResults(query, expectedMetadata);
+  }
+
+  private void verifyResults(String query, List<ExpectedColumnResult> expectedMetadata) throws Exception {
+    // regular query
+    verifyMetadata(expectedMetadata, createPrepareStmt(query, false, null).getColumnsList());
+
+    // limit 0 query
+    try {
+      test("alter session set `%s` = true", ExecConstants.EARLY_LIMIT0_OPT_KEY);
+      verifyMetadata(expectedMetadata, createPrepareStmt(String.format("select * from (%s) t limit 0", query), false, null)
+          .getColumnsList());
+    } finally {
+      test("alter session reset `%s`", ExecConstants.EARLY_LIMIT0_OPT_KEY);
+    }
+  }
+
+
+}
diff --git a/exec/java-exec/src/test/java/org/apache/drill/exec/work/prepare/TestPreparedStatementProvider.java b/exec/java-exec/src/test/java/org/apache/drill/exec/work/prepare/TestPreparedStatementProvider.java
index 15fbc4f5111..ca47a02ec19 100644
--- a/exec/java-exec/src/test/java/org/apache/drill/exec/work/prepare/TestPreparedStatementProvider.java
+++ b/exec/java-exec/src/test/java/org/apache/drill/exec/work/prepare/TestPreparedStatementProvider.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -17,21 +17,12 @@
  */
 package org.apache.drill.exec.work.prepare;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertTrue;
-
 import java.sql.Date;
 import java.util.List;
 
-import org.apache.drill.BaseTestQuery;
+import org.apache.drill.common.types.Types;
 import org.apache.drill.exec.proto.UserBitShared.DrillPBError.ErrorType;
-import org.apache.drill.exec.proto.UserProtos.ColumnSearchability;
-import org.apache.drill.exec.proto.UserProtos.ColumnUpdatability;
-import org.apache.drill.exec.proto.UserProtos.CreatePreparedStatementResp;
 import org.apache.drill.exec.proto.UserProtos.PreparedStatement;
-import org.apache.drill.exec.proto.UserProtos.RequestStatus;
-import org.apache.drill.exec.proto.UserProtos.ResultColumnMetadata;
-import org.apache.drill.exec.store.ischema.InfoSchemaConstants;
 import org.junit.Test;
 
 import com.google.common.collect.ImmutableList;
@@ -39,8 +30,7 @@
 /**
  * Tests for creating and executing prepared statements.
  */
-public class TestPreparedStatementProvider extends BaseTestQuery {
-  private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(TestPreparedStatementProvider.class);
+public class TestPreparedStatementProvider extends PreparedStatementTestBase {
 
   /**
    * Simple query.
@@ -53,11 +43,11 @@ public void simple() throws Exception {
 
     List<ExpectedColumnResult> expMetadata = ImmutableList.of(
         new ExpectedColumnResult("region_id", "BIGINT", true, 20, 0, 0, true, Long.class.getName()),
-        new ExpectedColumnResult("sales_city", "CHARACTER VARYING", true, 65536, 65536, 0, false, String.class.getName()),
-        new ExpectedColumnResult("sales_state_province", "CHARACTER VARYING", true, 65536, 65536, 0, false, String.class.getName()),
-        new ExpectedColumnResult("sales_district", "CHARACTER VARYING", true, 65536, 65536, 0, false, String.class.getName()),
-        new ExpectedColumnResult("sales_region", "CHARACTER VARYING", true, 65536, 65536, 0, false, String.class.getName()),
-        new ExpectedColumnResult("sales_country", "CHARACTER VARYING", true, 65536, 65536, 0, false, String.class.getName()),
+        new ExpectedColumnResult("sales_city", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("sales_state_province", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("sales_district", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("sales_region", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
+        new ExpectedColumnResult("sales_country", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
         new ExpectedColumnResult("sales_district_id", "BIGINT", true, 20, 0, 0, true, Long.class.getName())
     );
 
@@ -82,7 +72,7 @@ public void groupByQuery() throws Exception {
     PreparedStatement preparedStatement = createPrepareStmt(query, false, null);
 
     List<ExpectedColumnResult> expMetadata = ImmutableList.of(
-        new ExpectedColumnResult("sales_city", "CHARACTER VARYING", true, 65536, 65536, 0, false, String.class.getName()),
+        new ExpectedColumnResult("sales_city", "CHARACTER VARYING", true, Types.MAX_VARCHAR_LENGTH, Types.MAX_VARCHAR_LENGTH, 0, false, String.class.getName()),
         new ExpectedColumnResult("cnt", "BIGINT", false, 20, 0, 0, true, Long.class.getName())
     );
 
@@ -132,103 +122,4 @@ public void invalidQueryParserError() throws Exception {
   public void invalidQueryValidationError() throws Exception {
     createPrepareStmt("SELECT * sdflkgdh", true, ErrorType.PARSE /** Drill returns incorrect error for parse error*/);
   }
-
-  /* Helper method which creates a prepared statement for given query. */
-  private static PreparedStatement createPrepareStmt(String query, boolean expectFailure, ErrorType errorType) throws Exception {
-    CreatePreparedStatementResp resp = client.createPreparedStatement(query).get();
-
-    assertEquals(expectFailure ? RequestStatus.FAILED : RequestStatus.OK, resp.getStatus());
-
-    if (expectFailure) {
-      assertEquals(errorType, resp.getError().getErrorType());
-    } else {
-      logger.error("Prepared statement creation failed: {}", resp.getError().getMessage());
-    }
-
-    return resp.getPreparedStatement();
-  }
-
-  private static class ExpectedColumnResult {
-    final String columnName;
-    final String type;
-    final boolean nullable;
-    final int displaySize;
-    final int precision;
-    final int scale;
-    final boolean signed;
-    final String className;
-
-    ExpectedColumnResult(String columnName, String type, boolean nullable, int displaySize, int precision, int scale,
-        boolean signed, String className) {
-      this.columnName = columnName;
-      this.type = type;
-      this.nullable = nullable;
-      this.displaySize = displaySize;
-      this.precision = precision;
-      this.scale = scale;
-      this.signed = signed;
-      this.className = className;
-    }
-
-    boolean isEqualsTo(ResultColumnMetadata result) {
-      return
-          result.getCatalogName().equals(InfoSchemaConstants.IS_CATALOG_NAME) &&
-          result.getSchemaName().isEmpty() &&
-          result.getTableName().isEmpty() &&
-          result.getColumnName().equals(columnName) &&
-          result.getLabel().equals(columnName) &&
-          result.getDataType().equals(type) &&
-          result.getIsNullable() == nullable &&
-          result.getPrecision() == precision &&
-          result.getScale() == scale &&
-          result.getSigned() == signed &&
-          result.getDisplaySize() == displaySize &&
-          result.getClassName().equals(className) &&
-          result.getSearchability() == ColumnSearchability.ALL &&
-          result.getAutoIncrement() == false &&
-          result.getCaseSensitivity() == false &&
-          result.getUpdatability() == ColumnUpdatability.READ_ONLY &&
-          result.getIsAliased() == true &&
-          result.getIsCurrency() == false;
-    }
-
-    @Override
-    public String toString() {
-      return "ExpectedColumnResult[" +
-          "columnName='" + columnName + '\'' +
-          ", type='" + type + '\'' +
-          ", nullable=" + nullable +
-          ", displaySize=" + displaySize +
-          ", precision=" + precision +
-          ", scale=" + scale +
-          ", signed=" + signed +
-          ", className='" + className + '\'' +
-          ']';
-    }
-  }
-
-  private static String toString(ResultColumnMetadata metadata) {
-    return "ResultColumnMetadata[" +
-        "columnName='" + metadata.getColumnName() + '\'' +
-        ", type='" + metadata.getDataType() + '\'' +
-        ", nullable=" + metadata.getIsNullable() +
-        ", displaySize=" + metadata.getDisplaySize() +
-        ", precision=" + metadata.getPrecision() +
-        ", scale=" + metadata.getScale() +
-        ", signed=" + metadata.getSigned() +
-        ", className='" + metadata.getClassName() + '\'' +
-        ']';
-  }
-
-  private static void verifyMetadata(List<ExpectedColumnResult> expMetadata,
-      List<ResultColumnMetadata> actMetadata) {
-    assertEquals(expMetadata.size(), actMetadata.size());
-
-    int i = 0;
-    for(ExpectedColumnResult exp : expMetadata) {
-      ResultColumnMetadata act = actMetadata.get(i++);
-
-      assertTrue("Failed to find the expected column metadata: " + exp + ". Was: " + toString(act), exp.isEqualsTo(act));
-    }
-  }
 }
diff --git a/exec/jdbc/src/test/java/org/apache/drill/jdbc/DatabaseMetaDataGetColumnsTest.java b/exec/jdbc/src/test/java/org/apache/drill/jdbc/DatabaseMetaDataGetColumnsTest.java
index 8e658694bbc..359b0bc1eef 100644
--- a/exec/jdbc/src/test/java/org/apache/drill/jdbc/DatabaseMetaDataGetColumnsTest.java
+++ b/exec/jdbc/src/test/java/org/apache/drill/jdbc/DatabaseMetaDataGetColumnsTest.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -1024,7 +1024,7 @@ public void test_COLUMN_SIZE_hasRightValue_mdrReqVARCHAR_10() throws SQLExceptio
 
   @Test
   public void test_COLUMN_SIZE_hasRightValue_mdrOptVARCHAR() throws SQLException {
-    assertThat(getIntOrNull(mdrOptVARCHAR, "COLUMN_SIZE"), equalTo(65536));
+    assertThat(getIntOrNull(mdrOptVARCHAR, "COLUMN_SIZE"), equalTo(org.apache.drill.common.types.Types.MAX_VARCHAR_LENGTH));
   }
 
   @Test
@@ -2168,7 +2168,7 @@ public void test_CHAR_OCTET_LENGTH_hasRightValue_mdrReqVARCHAR_10() throws SQLEx
   @Test
   public void test_CHAR_OCTET_LENGTH_hasRightValue_mdrOptVARCHAR() throws SQLException {
     assertThat( getIntOrNull( mdrOptVARCHAR, "CHAR_OCTET_LENGTH" ),
-        equalTo(65536 /* chars. (default of 65536) */
+        equalTo(org.apache.drill.common.types.Types.MAX_VARCHAR_LENGTH /* chars. (default of 65535) */
                          * 4  /* max. UTF-8 bytes per char. */ ) );
   }
 
diff --git a/exec/jdbc/src/test/java/org/apache/drill/jdbc/PreparedStatementTest.java b/exec/jdbc/src/test/java/org/apache/drill/jdbc/PreparedStatementTest.java
index 2e938648bd8..f931e1f87eb 100644
--- a/exec/jdbc/src/test/java/org/apache/drill/jdbc/PreparedStatementTest.java
+++ b/exec/jdbc/src/test/java/org/apache/drill/jdbc/PreparedStatementTest.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -114,7 +114,7 @@ public void testQueryMetadataInPreparedStatement() throws SQLException {
         "SELECT " +
             "cast(1 as INTEGER ) as int_field, " +
             "cast(12384729 as BIGINT ) as bigint_field, " +
-            "'varchar_value' as varchar_field, " +
+            "cast('varchar_value' as varchar(50)) as varchar_field, " +
             "timestamp '2008-2-23 10:00:20.123' as ts_field, " +
             "date '2008-2-23' as date_field, " +
             "cast('99999912399.4567' as decimal(18, 5)) as decimal_field" +
@@ -123,7 +123,7 @@ public void testQueryMetadataInPreparedStatement() throws SQLException {
       List<ExpectedColumnResult> exp = ImmutableList.of(
           new ExpectedColumnResult("int_field", INTEGER, columnNoNulls, 11, 0, 0, true, Integer.class.getName()),
           new ExpectedColumnResult("bigint_field", BIGINT, columnNoNulls, 20, 0, 0, true, Long.class.getName()),
-          new ExpectedColumnResult("varchar_field", VARCHAR, columnNoNulls, 65536, 65536, 0, false, String.class.getName()),
+          new ExpectedColumnResult("varchar_field", VARCHAR, columnNoNulls, 50, 50, 0, false, String.class.getName()),
           new ExpectedColumnResult("ts_field", TIMESTAMP, columnNoNulls, 19, 0, 0, false, Timestamp.class.getName()),
           new ExpectedColumnResult("date_field", DATE, columnNoNulls, 10, 0, 0, false, Date.class.getName()),
           new ExpectedColumnResult("decimal_field", DECIMAL, columnNoNulls, 20, 18, 5, true, BigDecimal.class.getName())
diff --git a/exec/jdbc/src/test/java/org/apache/drill/jdbc/test/TestInformationSchemaColumns.java b/exec/jdbc/src/test/java/org/apache/drill/jdbc/test/TestInformationSchemaColumns.java
index 5faf4dc8077..6c4329581d1 100644
--- a/exec/jdbc/src/test/java/org/apache/drill/jdbc/test/TestInformationSchemaColumns.java
+++ b/exec/jdbc/src/test/java/org/apache/drill/jdbc/test/TestInformationSchemaColumns.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -1154,7 +1154,7 @@ public void test_CHARACTER_MAXIMUM_LENGTH_hasRightValue_mdrReqVARCHAR_10() throw
 
   @Test
   public void test_CHARACTER_MAXIMUM_LENGTH_hasRightValue_mdrOptVARCHAR() throws SQLException {
-    assertThat(getIntOrNull(mdrOptVARCHAR, "CHARACTER_MAXIMUM_LENGTH"), equalTo(65536));
+    assertThat(getIntOrNull(mdrOptVARCHAR, "CHARACTER_MAXIMUM_LENGTH"), equalTo(org.apache.drill.common.types.Types.MAX_VARCHAR_LENGTH));
   }
 
   @Test
@@ -1318,7 +1318,7 @@ public void test_CHARACTER_OCTET_LENGTH_hasRightValue_mdrReqVARCHAR_10() throws
   @Test
   public void test_CHARACTER_OCTET_LENGTH_hasRightValue_mdrOptVARCHAR() throws SQLException {
     assertThat( getIntOrNull( mdrOptVARCHAR, "CHARACTER_OCTET_LENGTH" ),
-        equalTo(65536 /* chars. (default of 65536) */
+        equalTo(org.apache.drill.common.types.Types.MAX_VARCHAR_LENGTH /* chars. (default of 65535) */
                          * 4  /* max. UTF-8 bytes per char. */ ) );
   }
 
diff --git a/exec/vector/src/main/codegen/templates/BasicTypeHelper.java b/exec/vector/src/main/codegen/templates/BasicTypeHelper.java
index 452c3311fee..016199aa378 100644
--- a/exec/vector/src/main/codegen/templates/BasicTypeHelper.java
+++ b/exec/vector/src/main/codegen/templates/BasicTypeHelper.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -31,6 +31,7 @@
 import org.apache.drill.exec.record.MaterializedField;
 import org.apache.drill.exec.vector.complex.RepeatedMapVector;
 import org.apache.drill.exec.util.CallBack;
+import org.apache.drill.common.types.Types;
 /*
  * This class is generated using freemarker and the ${.template_name} template.
  */
@@ -39,11 +40,6 @@ public class BasicTypeHelper {
 
   private static final int WIDTH_ESTIMATE = 50;
 
-  // Default length when casting to varchar : 65536 = 2^16
-  // This only defines an absolute maximum for values, setting
-  // a high value like this will not inflate the size for small values
-  public static final int VARCHAR_DEFAULT_CAST_LEN = 65536;
-
   protected static String buildErrorMessage(final String operation, final MinorType type, final DataMode mode) {
     return String.format("Unable to %s for minor type [%s] and mode [%s]", operation, type, mode);
   }
@@ -62,9 +58,9 @@ public static int getSize(MajorType major) {
                                minor.class?substring(0, 3) == "MSG"> + WIDTH_ESTIMATE</#if>;
   </#list>
 </#list>
-      case FIXEDCHAR: return major.getWidth();
-      case FIXED16CHAR: return major.getWidth();
-      case FIXEDBINARY: return major.getWidth();
+      case FIXEDCHAR: return major.getPrecision();
+      case FIXED16CHAR: return major.getPrecision();
+      case FIXEDBINARY: return major.getPrecision();
     }
     throw new UnsupportedOperationException(buildErrorMessage("get size", major));
   }
diff --git a/exec/vector/src/main/java/org/apache/drill/exec/record/MaterializedField.java b/exec/vector/src/main/java/org/apache/drill/exec/record/MaterializedField.java
index e19210704f6..bc1ec3a5c58 100644
--- a/exec/vector/src/main/java/org/apache/drill/exec/record/MaterializedField.java
+++ b/exec/vector/src/main/java/org/apache/drill/exec/record/MaterializedField.java
@@ -157,7 +157,7 @@ public static MaterializedField create(String name, MajorType type){
 
   public MaterializedField getOtherNullableVersion() {
     MajorType mt = type;
-    DataMode newDataMode = null;
+    DataMode newDataMode;
     switch (mt.getMode()){
     case OPTIONAL:
       newDataMode = DataMode.REQUIRED;
@@ -199,16 +199,48 @@ public boolean equals(Object obj) {
             Objects.equals(this.type, other.type);
   }
 
+  /**
+   * <p>Creates materialized field string representation.
+   * Includes field name, its type with precision and scale if any and data mode.
+   * Nested fields if any are included. Number of nested fields to include is limited to 10.</p>
+   *
+   * <b>FIELD_NAME(TYPE(PRECISION,SCALE):DATA_MODE)[NESTED_FIELD_1, NESTED_FIELD_2]</b>
+   * <p>Example: ok(BIT:REQUIRED), col(VARCHAR(3):OPTIONAL), emp_id(DECIMAL28SPARSE(6,0):REQUIRED)</p>
+   *
+   * @return materialized field string representation
+   */
   @Override
   public String toString() {
     final int maxLen = 10;
-    String childStr = children != null && !children.isEmpty() ? toString(children, maxLen) : "";
-    return name + "(" + type.getMinorType().name() + ":" + type.getMode().name() + ")" + childStr;
-  }
+    String childString = children != null && !children.isEmpty() ? toString(children, maxLen) : "";
+    StringBuilder builder = new StringBuilder();
+    builder
+        .append(name)
+        .append("(")
+        .append(type.getMinorType().name());
+
+    if (type.hasPrecision()) {
+      builder.append("(");
+      builder.append(type.getPrecision());
+      if (type.hasScale()) {
+        builder.append(",");
+        builder.append(type.getScale());
+      }
+      builder.append(")");
+    }
+
+    builder
+        .append(":")
+        .append(type.getMode().name())
+        .append(")")
+        .append(childString);
+
+    return builder.toString();
+}
 
   private String toString(Collection<?> collection, int maxLen) {
     StringBuilder builder = new StringBuilder();
-    builder.append("[");
+    builder.append(" [");
     int i = 0;
     for (Iterator<?> iterator = collection.iterator(); iterator.hasNext() && i < maxLen; i++) {
       if (i > 0){
diff --git a/logical/src/main/antlr3/org/apache/drill/common/expression/parser/ExprParser.g b/logical/src/main/antlr3/org/apache/drill/common/expression/parser/ExprParser.g
index 600b7917445..12048b0c4e7 100644
--- a/logical/src/main/antlr3/org/apache/drill/common/expression/parser/ExprParser.g
+++ b/logical/src/main/antlr3/org/apache/drill/common/expression/parser/ExprParser.g
@@ -122,8 +122,8 @@ numType returns [MajorType type]
 	;
 
 charType returns [MajorType type]
-	:  VARCHAR typeLen {$type = TypeProtos.MajorType.newBuilder().setMinorType(TypeProtos.MinorType.VARCHAR).setMode(DataMode.REQUIRED).setWidth($typeLen.length.intValue()).build(); }
-	|  VARBINARY typeLen {$type = TypeProtos.MajorType.newBuilder().setMinorType(TypeProtos.MinorType.VARBINARY).setMode(DataMode.REQUIRED).setWidth($typeLen.length.intValue()).build();}	
+	:  VARCHAR typeLen {$type = TypeProtos.MajorType.newBuilder().setMinorType(TypeProtos.MinorType.VARCHAR).setMode(DataMode.REQUIRED).setPrecision($typeLen.length.intValue()).build(); }
+	|  VARBINARY typeLen {$type = TypeProtos.MajorType.newBuilder().setMinorType(TypeProtos.MinorType.VARBINARY).setMode(DataMode.REQUIRED).setPrecision($typeLen.length.intValue()).build();}
 	;
 
 precision returns [Integer value]
@@ -314,7 +314,7 @@ lookup returns [LogicalExpression e]
   | convertCall {$e = $convertCall.e; }
   | castCall {$e = $castCall.e; }
   | pathSegment {$e = new SchemaPath($pathSegment.seg, pos($pathSegment.start) ); }
-  | String {$e = new ValueExpressions.QuotedString($String.text, pos($String) ); }
+  | String {$e = new ValueExpressions.QuotedString($String.text, $String.text.length(), pos($String) ); }
   | OParen expression CParen  {$e = $expression.e; }
   | SingleQuote Identifier SingleQuote {$e = new SchemaPath($Identifier.text, pos($Identifier) ); }
   ;
diff --git a/logical/src/main/java/org/apache/drill/common/expression/ExpressionStringBuilder.java b/logical/src/main/java/org/apache/drill/common/expression/ExpressionStringBuilder.java
index 85547bc7cda..34736df324d 100644
--- a/logical/src/main/java/org/apache/drill/common/expression/ExpressionStringBuilder.java
+++ b/logical/src/main/java/org/apache/drill/common/expression/ExpressionStringBuilder.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -283,7 +283,7 @@ public Void visitCastExpression(CastExpression e, StringBuilder sb) throws Runti
 
       // add size in parens
       sb.append("(");
-      sb.append(mt.getWidth());
+      sb.append(mt.getPrecision());
       sb.append(")");
       break;
     case DECIMAL9:
diff --git a/logical/src/main/java/org/apache/drill/common/expression/IfExpression.java b/logical/src/main/java/org/apache/drill/common/expression/IfExpression.java
index e85caa0610a..147129b9537 100644
--- a/logical/src/main/java/org/apache/drill/common/expression/IfExpression.java
+++ b/logical/src/main/java/org/apache/drill/common/expression/IfExpression.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -26,6 +26,7 @@
 import org.apache.drill.common.types.TypeProtos.DataMode;
 import org.apache.drill.common.types.TypeProtos.MajorType;
 import org.apache.drill.common.types.TypeProtos.MinorType;
+import org.apache.drill.common.types.Types;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -77,7 +78,7 @@ public Builder setPosition(ExpressionPosition pos) {
 
     public Builder setElse(LogicalExpression elseExpression) {
       this.elseExpression = elseExpression;
-            return this;
+      return this;
     }
 
     public Builder setIfCondition(IfCondition conditions) {
@@ -104,13 +105,14 @@ public MajorType getMajorType() {
       return outputType;
     }
 
-    MajorType majorType = elseExpression.getMajorType();
-    if (majorType.getMinorType() == MinorType.UNION) {
+    MajorType elseType = elseExpression.getMajorType();
+    MajorType ifType = ifCondition.expression.getMajorType();
+    if (elseType.getMinorType() == MinorType.UNION) {
       Set<MinorType> subtypes = Sets.newHashSet();
-      for (MinorType subtype : majorType.getSubTypeList()) {
+      for (MinorType subtype : elseType.getSubTypeList()) {
         subtypes.add(subtype);
       }
-      for (MinorType subtype : ifCondition.expression.getMajorType().getSubTypeList()) {
+      for (MinorType subtype : ifType.getSubTypeList()) {
         subtypes.add(subtype);
       }
       MajorType.Builder builder = MajorType.newBuilder().setMinorType(MinorType.UNION).setMode(DataMode.OPTIONAL);
@@ -119,17 +121,11 @@ public MajorType getMajorType() {
       }
       return builder.build();
     }
-    if (majorType.getMode() == DataMode.OPTIONAL) {
-      return majorType;
-    }
-
-    if (ifCondition.expression.getMajorType().getMode() == DataMode.OPTIONAL) {
-      assert ifCondition.expression.getMajorType().getMinorType() == majorType.getMinorType();
-
-      return ifCondition.expression.getMajorType();
-    }
 
-    return majorType;
+    MajorType.Builder builder = MajorType.newBuilder().setMinorType(ifType.getMinorType());
+    builder.setMode(elseType.getMode() == DataMode.OPTIONAL || ifType.getMode() == DataMode.OPTIONAL ? DataMode.OPTIONAL : elseType.getMode());
+    builder = Types.calculateTypePrecisionAndScale(ifType, elseType, builder);
+    return builder.build();
   }
 
   public static Builder newBuilder() {
diff --git a/logical/src/main/java/org/apache/drill/common/expression/ValueExpressions.java b/logical/src/main/java/org/apache/drill/common/expression/ValueExpressions.java
index 662258d947e..556135fceb5 100644
--- a/logical/src/main/java/org/apache/drill/common/expression/ValueExpressions.java
+++ b/logical/src/main/java/org/apache/drill/common/expression/ValueExpressions.java
@@ -1,4 +1,4 @@
-/**
+/*
  * Licensed to the Apache Software Foundation (ASF) under one
  * or more contributor license agreements.  See the NOTICE file
  * distributed with this work for additional information
@@ -51,8 +51,8 @@ public static LogicalExpression getBit(boolean b){
     return new BooleanExpression(Boolean.toString(b), ExpressionPosition.UNKNOWN);
   }
 
-  public static LogicalExpression getChar(String s){
-    return new QuotedString(s, ExpressionPosition.UNKNOWN);
+  public static LogicalExpression getChar(String s, int precision){
+    return new QuotedString(s, precision, ExpressionPosition.UNKNOWN);
   }
 
   public static LogicalExpression getDate(GregorianCalendar date) {
@@ -650,10 +650,13 @@ public Iterator<LogicalExpression> iterator() {
 
   public static class QuotedString extends ValueExpression<String> {
 
-    private static final MajorType QUOTED_STRING_CONSTANT = Types.required(MinorType.VARCHAR);
+    public static final QuotedString EMPTY_STRING = new QuotedString("", 0, ExpressionPosition.UNKNOWN);
 
-    public QuotedString(String value, ExpressionPosition pos) {
+    private final int precision;
+
+    public QuotedString(String value, int precision, ExpressionPosition pos) {
       super(value, pos);
+      this.precision = precision;
     }
 
     public String getString() {
@@ -667,7 +670,7 @@ protected String parseValue(String s) {
 
     @Override
     public MajorType getMajorType() {
-      return QUOTED_STRING_CONSTANT;
+      return Types.withPrecision(MinorType.VARCHAR, DataMode.REQUIRED, precision);
     }
 
     @Override
diff --git a/protocol/src/main/java/org/apache/drill/common/types/TypeProtos.java b/protocol/src/main/java/org/apache/drill/common/types/TypeProtos.java
index 07efdbf4d3d..ff5698a9187 100644
--- a/protocol/src/main/java/org/apache/drill/common/types/TypeProtos.java
+++ b/protocol/src/main/java/org/apache/drill/common/types/TypeProtos.java
@@ -850,18 +850,10 @@ private DataMode(int index, int value) {
     // optional int32 width = 3;
     /**
      * <code>optional int32 width = 3;</code>
-     *
-     * <pre>
-     * optional width for fixed size values.
-     * </pre>
      */
     boolean hasWidth();
     /**
      * <code>optional int32 width = 3;</code>
-     *
-     * <pre>
-     * optional width for fixed size values.
-     * </pre>
      */
     int getWidth();
 
@@ -870,7 +862,7 @@ private DataMode(int index, int value) {
      * <code>optional int32 precision = 4;</code>
      *
      * <pre>
-     * used for decimal types
+     * used for decimal types or as optional length for fixed size value
      * </pre>
      */
     boolean hasPrecision();
@@ -878,7 +870,7 @@ private DataMode(int index, int value) {
      * <code>optional int32 precision = 4;</code>
      *
      * <pre>
-     * used for decimal types
+     * used for decimal types or as optional length for fixed size value
      * </pre>
      */
     int getPrecision();
@@ -1151,20 +1143,12 @@ public org.apache.drill.common.types.TypeProtos.DataMode getMode() {
     private int width_;
     /**
      * <code>optional int32 width = 3;</code>
-     *
-     * <pre>
-     * optional width for fixed size values.
-     * </pre>
      */
     public boolean hasWidth() {
       return ((bitField0_ & 0x00000004) == 0x00000004);
     }
     /**
      * <code>optional int32 width = 3;</code>
-     *
-     * <pre>
-     * optional width for fixed size values.
-     * </pre>
      */
     public int getWidth() {
       return width_;
@@ -1177,7 +1161,7 @@ public int getWidth() {
      * <code>optional int32 precision = 4;</code>
      *
      * <pre>
-     * used for decimal types
+     * used for decimal types or as optional length for fixed size value
      * </pre>
      */
     public boolean hasPrecision() {
@@ -1187,7 +1171,7 @@ public boolean hasPrecision() {
      * <code>optional int32 precision = 4;</code>
      *
      * <pre>
-     * used for decimal types
+     * used for decimal types or as optional length for fixed size value
      * </pre>
      */
     public int getPrecision() {
@@ -1694,30 +1678,18 @@ public Builder clearMode() {
       private int width_ ;
       /**
        * <code>optional int32 width = 3;</code>
-       *
-       * <pre>
-       * optional width for fixed size values.
-       * </pre>
        */
       public boolean hasWidth() {
         return ((bitField0_ & 0x00000004) == 0x00000004);
       }
       /**
        * <code>optional int32 width = 3;</code>
-       *
-       * <pre>
-       * optional width for fixed size values.
-       * </pre>
        */
       public int getWidth() {
         return width_;
       }
       /**
        * <code>optional int32 width = 3;</code>
-       *
-       * <pre>
-       * optional width for fixed size values.
-       * </pre>
        */
       public Builder setWidth(int value) {
         bitField0_ |= 0x00000004;
@@ -1727,10 +1699,6 @@ public Builder setWidth(int value) {
       }
       /**
        * <code>optional int32 width = 3;</code>
-       *
-       * <pre>
-       * optional width for fixed size values.
-       * </pre>
        */
       public Builder clearWidth() {
         bitField0_ = (bitField0_ & ~0x00000004);
@@ -1745,7 +1713,7 @@ public Builder clearWidth() {
        * <code>optional int32 precision = 4;</code>
        *
        * <pre>
-       * used for decimal types
+       * used for decimal types or as optional length for fixed size value
        * </pre>
        */
       public boolean hasPrecision() {
@@ -1755,7 +1723,7 @@ public boolean hasPrecision() {
        * <code>optional int32 precision = 4;</code>
        *
        * <pre>
-       * used for decimal types
+       * used for decimal types or as optional length for fixed size value
        * </pre>
        */
       public int getPrecision() {
@@ -1765,7 +1733,7 @@ public int getPrecision() {
        * <code>optional int32 precision = 4;</code>
        *
        * <pre>
-       * used for decimal types
+       * used for decimal types or as optional length for fixed size value
        * </pre>
        */
       public Builder setPrecision(int value) {
@@ -1778,7 +1746,7 @@ public Builder setPrecision(int value) {
        * <code>optional int32 precision = 4;</code>
        *
        * <pre>
-       * used for decimal types
+       * used for decimal types or as optional length for fixed size value
        * </pre>
        */
       public Builder clearPrecision() {
diff --git a/protocol/src/main/protobuf/Types.proto b/protocol/src/main/protobuf/Types.proto
index ca88fe99534..71fa4acd9c8 100644
--- a/protocol/src/main/protobuf/Types.proto
+++ b/protocol/src/main/protobuf/Types.proto
@@ -70,8 +70,8 @@ enum MinorType {
 message MajorType {
   optional MinorType minor_type = 1;
   optional DataMode mode = 2;
-  optional int32 width = 3; // optional width for fixed size values.
-  optional int32 precision = 4; // used for decimal types
+  optional int32 width = 3;
+  optional int32 precision = 4; // used for decimal types or as optional length for fixed size value
   optional int32 scale = 5; // used for decimal types
   optional int32 timeZone = 6; // used by TimeStamp type
   repeated MinorType sub_type = 7; // used by Union type
