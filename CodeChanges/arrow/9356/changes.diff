diff --git a/csharp/README.md b/csharp/README.md
index 29c6086379b6..2a60cd27c5c8 100644
--- a/csharp/README.md
+++ b/csharp/README.md
@@ -90,6 +90,7 @@ This implementation is under development and may not be suitable for use in prod
 - Timestamp
 - Date32
 - Date64
+- Decimal
 - Time32
 - Time64
 - Binary (fixed-length)
@@ -124,7 +125,6 @@ This implementation is under development and may not be suitable for use in prod
         - Dense
         - Sparse
     - Half-Float
-    - Decimal
     - Dictionary
 - Array Operations
 	- Equality / Comparison
diff --git a/csharp/src/Apache.Arrow/Arrays/ArrowArrayBuilderFactory.cs b/csharp/src/Apache.Arrow/Arrays/ArrowArrayBuilderFactory.cs
index e654bb9dd940..e7360942f3c9 100644
--- a/csharp/src/Apache.Arrow/Arrays/ArrowArrayBuilderFactory.cs
+++ b/csharp/src/Apache.Arrow/Arrays/ArrowArrayBuilderFactory.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the Apache Software Foundation (ASF) under one or more
+// Licensed to the Apache Software Foundation (ASF) under one or more
 // contributor license agreements. See the NOTICE file distributed with
 // this work for additional information regarding copyright ownership.
 // The ASF licenses this file to You under the Apache License, Version 2.0
@@ -58,9 +58,12 @@ static class ArrowArrayBuilderFactory
                     return new Date32Array.Builder();
                 case ArrowTypeId.List:
                     return new ListArray.Builder(dataType as ListType);
+                case ArrowTypeId.Decimal128:
+                    return new Decimal128Array.Builder(dataType as Decimal128Type);
+                case ArrowTypeId.Decimal256:
+                    return new Decimal256Array.Builder(dataType as Decimal256Type);
                 case ArrowTypeId.Struct:
                 case ArrowTypeId.Union:
-                case ArrowTypeId.Decimal:
                 case ArrowTypeId.Dictionary:
                 case ArrowTypeId.FixedSizedBinary:
                 case ArrowTypeId.HalfFloat:
diff --git a/csharp/src/Apache.Arrow/Arrays/ArrowArrayFactory.cs b/csharp/src/Apache.Arrow/Arrays/ArrowArrayFactory.cs
index f3452e312e93..c3429230cc65 100644
--- a/csharp/src/Apache.Arrow/Arrays/ArrowArrayFactory.cs
+++ b/csharp/src/Apache.Arrow/Arrays/ArrowArrayFactory.cs
@@ -62,7 +62,10 @@ public static IArrowArray BuildArray(ArrayData data)
                     return new Date64Array(data);
                 case ArrowTypeId.Date32:
                     return new Date32Array(data);
-                case ArrowTypeId.Decimal:
+                case ArrowTypeId.Decimal128:
+                    return new Decimal128Array(data);
+                case ArrowTypeId.Decimal256:
+                    return new Decimal256Array(data);
                 case ArrowTypeId.Dictionary:
                 case ArrowTypeId.FixedSizedBinary:
                 case ArrowTypeId.HalfFloat:
diff --git a/csharp/src/Apache.Arrow/Arrays/Decimal128Array.cs b/csharp/src/Apache.Arrow/Arrays/Decimal128Array.cs
new file mode 100644
index 000000000000..128e9e5f0818
--- /dev/null
+++ b/csharp/src/Apache.Arrow/Arrays/Decimal128Array.cs
@@ -0,0 +1,95 @@
+﻿// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements. See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Numerics;
+using Apache.Arrow.Arrays;
+using Apache.Arrow.Types;
+
+namespace Apache.Arrow
+{
+    public class Decimal128Array : FixedSizeBinaryArray
+    {
+        public class Builder : BuilderBase<Decimal128Array, Builder>
+        {
+            public Builder(Decimal128Type type) : base(type, 16)
+            {
+                DataType = type;
+            }
+
+            protected new Decimal128Type DataType { get; }
+
+            protected override Decimal128Array Build(ArrayData data)
+            {
+                return new Decimal128Array(data);
+            }
+
+            public Builder Append(decimal value)
+            {
+                Span<byte> bytes = stackalloc byte[DataType.ByteWidth];
+                DecimalUtility.GetBytes(value, DataType.Precision, DataType.Scale, DataType.ByteWidth, bytes);
+
+                return Append(bytes);
+            }
+
+            public Builder AppendRange(IEnumerable<decimal> values)
+            {
+                if (values == null)
+                {
+                    throw new ArgumentNullException(nameof(values));
+                }
+
+                foreach (decimal d in values)
+                {
+                    Append(d);
+                }
+
+                return Instance;
+            }
+
+            public Builder Set(int index, decimal value)
+            {
+                Span<byte> bytes = stackalloc byte[DataType.ByteWidth];
+                DecimalUtility.GetBytes(value, DataType.Precision, DataType.Scale, DataType.ByteWidth, bytes);
+
+                return Set(index, bytes);
+            }
+        }
+
+        public Decimal128Array(ArrayData data)
+            : base(ArrowTypeId.Decimal128, data)
+        {
+            data.EnsureDataType(ArrowTypeId.Decimal128);
+            data.EnsureBufferCount(2);
+            Debug.Assert(Data.DataType is Decimal128Type);
+        }
+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);
+
+        public int Scale => ((Decimal128Type)Data.DataType).Scale;
+        public int Precision => ((Decimal128Type)Data.DataType).Precision;
+        public int ByteWidth => ((Decimal128Type)Data.DataType).ByteWidth;
+
+        public decimal? GetValue(int index)
+        {
+            if (IsNull(index))
+            {
+                return null;
+            }
+            return DecimalUtility.GetDecimal(ValueBuffer, index, Scale, ByteWidth);
+        }
+    }
+}
diff --git a/csharp/src/Apache.Arrow/Arrays/Decimal256Array.cs b/csharp/src/Apache.Arrow/Arrays/Decimal256Array.cs
new file mode 100644
index 000000000000..fb4cd6be396e
--- /dev/null
+++ b/csharp/src/Apache.Arrow/Arrays/Decimal256Array.cs
@@ -0,0 +1,96 @@
+﻿// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements. See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+using System;
+using System.Collections.Generic;
+using System.Diagnostics;
+using System.Numerics;
+using Apache.Arrow.Arrays;
+using Apache.Arrow.Types;
+
+namespace Apache.Arrow
+{
+    public class Decimal256Array : FixedSizeBinaryArray
+    {
+        public class Builder : BuilderBase<Decimal256Array, Builder>
+        {
+            public Builder(Decimal256Type type) : base(type, 32)
+            {
+                DataType = type;
+            }
+
+            protected new Decimal256Type DataType { get; }
+
+            protected override Decimal256Array Build(ArrayData data)
+            {
+                return new Decimal256Array(data);
+            }
+
+            public Builder Append(decimal value)
+            {
+                Span<byte> bytes = stackalloc byte[DataType.ByteWidth];
+                DecimalUtility.GetBytes(value, DataType.Precision, DataType.Scale, DataType.ByteWidth, bytes);
+
+                return Append(bytes);
+            }
+
+            public Builder AppendRange(IEnumerable<decimal> values)
+            {
+                if (values == null)
+                {
+                    throw new ArgumentNullException(nameof(values));
+                }
+
+                foreach (decimal d in values)
+                {
+                    Append(d);
+                }
+
+                return Instance;
+            }
+
+            public Builder Set(int index, decimal value)
+            {
+                Span<byte> bytes = stackalloc byte[DataType.ByteWidth];
+                DecimalUtility.GetBytes(value, DataType.Precision, DataType.Scale, DataType.ByteWidth, bytes);
+
+                return Set(index, bytes);
+            }
+        }
+
+        public Decimal256Array(ArrayData data)
+            : base(ArrowTypeId.Decimal256, data)
+        {
+            data.EnsureDataType(ArrowTypeId.Decimal256);
+            data.EnsureBufferCount(2);
+            Debug.Assert(Data.DataType is Decimal256Type);
+        }
+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);
+
+        public int Scale => ((Decimal256Type)Data.DataType).Scale;
+        public int Precision => ((Decimal256Type)Data.DataType).Precision;
+        public int ByteWidth => ((Decimal256Type)Data.DataType).ByteWidth;
+
+        public decimal? GetValue(int index)
+        {
+            if (IsNull(index))
+            {
+                return null;
+            }
+
+            return DecimalUtility.GetDecimal(ValueBuffer, index, Scale, ByteWidth);
+        }
+    }
+}
diff --git a/csharp/src/Apache.Arrow/Arrays/FixedSizeBinaryArray.cs b/csharp/src/Apache.Arrow/Arrays/FixedSizeBinaryArray.cs
new file mode 100644
index 000000000000..c3cf2fc5c303
--- /dev/null
+++ b/csharp/src/Apache.Arrow/Arrays/FixedSizeBinaryArray.cs
@@ -0,0 +1,196 @@
+// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements. See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+using System;
+using System.Collections.Generic;
+using Apache.Arrow.Memory;
+using Apache.Arrow.Types;
+
+namespace Apache.Arrow.Arrays
+{
+    public class FixedSizeBinaryArray : Array
+    {
+        public FixedSizeBinaryArray(ArrayData data)
+            : base(data)
+        {
+            data.EnsureDataType(ArrowTypeId.FixedSizedBinary);
+            data.EnsureBufferCount(2);
+        }
+
+        public FixedSizeBinaryArray(ArrowTypeId typeId, ArrayData data)
+            : base(data)
+        {
+            data.EnsureDataType(typeId);
+            data.EnsureBufferCount(2);
+        }
+
+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);
+
+        public ArrowBuffer ValueBuffer => Data.Buffers[1];
+
+        public abstract class BuilderBase<TArray, TBuilder> : IArrowArrayBuilder<byte[], TArray, TBuilder>
+            where TArray : IArrowArray
+            where TBuilder : class, IArrowArrayBuilder<byte[], TArray, TBuilder>
+        {
+            protected IArrowType DataType { get; }
+            protected TBuilder Instance => this as TBuilder;
+            protected int ByteWidth { get; }
+            protected ArrowBuffer.Builder<byte> ValueBuffer { get; }
+            protected ArrowBuffer.BitmapBuilder ValidityBuffer { get; }
+            public int Length => ValueBuffer.Length / ByteWidth;
+            protected int NullCount => this.ValidityBuffer.UnsetBitCount;
+            protected abstract TArray Build(ArrayData data);
+
+            protected BuilderBase(IArrowType dataType, int byteWidth)
+            {
+                DataType = dataType;
+                ByteWidth = byteWidth;
+                ValueBuffer = new ArrowBuffer.Builder<byte>();
+                ValidityBuffer = new ArrowBuffer.BitmapBuilder();
+            }
+
+            public TArray Build(MemoryAllocator allocator = default)
+            {
+                var bufs = new[]
+                {
+                    NullCount > 0 ? ValidityBuffer.Build(allocator) : ArrowBuffer.Empty,
+                    ValueBuffer.Build(ByteWidth, allocator),
+                };
+                var data = new ArrayData(
+                    DataType,
+                    Length,
+                    NullCount,
+                    0,
+                    bufs);
+
+                return Build(data);
+            }
+
+            public TBuilder Reserve(int capacity)
+            {
+                ValueBuffer.Reserve(capacity * ByteWidth);
+                ValidityBuffer.Reserve(capacity + 1);
+                return Instance;
+            }
+
+            public TBuilder Resize(int length)
+            {
+                ValueBuffer.Resize(length * ByteWidth);
+                ValidityBuffer.Resize(length + 1);
+                return Instance;
+            }
+
+            public TBuilder Clear() {
+
+                ValueBuffer.Clear();
+                ValidityBuffer.Clear();
+
+                return Instance;
+            }
+
+            public TBuilder Append(byte[] value)
+            {
+                if(value.Length % ByteWidth != 0)
+                    throw new ArgumentOutOfRangeException("Bytes of length: " + value.Length + " do not conform to the fixed size: " + ByteWidth);
+                return Append(value.AsSpan());
+            }
+            public TBuilder Append(ReadOnlySpan<byte[]> span)
+            {
+                foreach (var b in span)
+                {
+                    Append(b);
+                }
+
+                return Instance;
+            }
+
+            public TBuilder AppendRange(IEnumerable<byte[]> values)
+            {
+                if (values == null)
+                {
+                    throw new ArgumentNullException(nameof(values));
+                }
+
+                foreach (byte[] b in values)
+                {
+                    Append(b);
+                }
+
+                return Instance;
+            }
+
+            public TBuilder Append(ReadOnlySpan<byte> span)
+            {
+                ValueBuffer.Append(span);
+                ValidityBuffer.Append(true);
+                return Instance;
+            }
+
+            public TBuilder AppendNull()
+            {
+                ValueBuffer.Append(new byte[ByteWidth]);
+                ValidityBuffer.Append(false);
+                return Instance;
+            }
+
+            public TBuilder Swap(int i, int j)
+            {
+                int iStart = i * ByteWidth;
+                int jStart = j * ByteWidth;
+                byte[] iBytes = ValueBuffer.Span.Slice(iStart, ByteWidth).ToArray();
+                Span<byte> jBytes = ValueBuffer.Span.Slice(jStart, ByteWidth);
+
+                for (int m = 0; m < ByteWidth; m++)
+                {
+                    ValueBuffer.Span[iStart + m] = jBytes[m];
+                    ValueBuffer.Span[jStart + m] = iBytes[m];
+                }
+
+                ValidityBuffer.Swap(i, j);
+                return Instance;
+            }
+
+            public TBuilder Set(int index, byte[] value)
+            {
+                return Set(index, value.AsSpan());
+            }
+
+            public TBuilder Set(int index, ReadOnlySpan<byte> value)
+            {
+                int startIndex = index * ByteWidth;
+                for (int i = 0; i < ByteWidth; i++)
+                {
+                    ValueBuffer.Span[startIndex + i] = value[i];
+                }
+
+                ValidityBuffer.Set(index, true);
+                return Instance;
+            }
+
+            public TBuilder SetNull(int index)
+            {
+                int startIndex = index * ByteWidth;
+                for (int i = 0; i < ByteWidth; i++)
+                {
+                    ValueBuffer.Span[startIndex + i] = 0;
+                }
+
+                ValidityBuffer.Set(index, false);
+                return Instance;
+            }
+
+        }
+    }
+}
diff --git a/csharp/src/Apache.Arrow/ArrowBuffer.Builder.cs b/csharp/src/Apache.Arrow/ArrowBuffer.Builder.cs
index 817282e9c0d2..7c03027feffa 100644
--- a/csharp/src/Apache.Arrow/ArrowBuffer.Builder.cs
+++ b/csharp/src/Apache.Arrow/ArrowBuffer.Builder.cs
@@ -200,9 +200,19 @@ public Builder<T> Clear()
             /// <param name="allocator">Optional memory allocator.</param>
             /// <returns>Returns an <see cref="ArrowBuffer"/> object.</returns>
             public ArrowBuffer Build(MemoryAllocator allocator = default)
+            {
+                return Build(64, allocator);
+            }
+
+            /// <summary>
+            /// Build an Arrow buffer from the appended contents so far of the specified byte size.
+            /// </summary>
+            /// <param name="allocator">Optional memory allocator.</param>
+            /// <returns>Returns an <see cref="ArrowBuffer"/> object.</returns>
+            internal ArrowBuffer Build(int byteSize, MemoryAllocator allocator = default)
             {
                 int currentBytesLength = Length * _size;
-                int bufferLength = checked((int)BitUtility.RoundUpToMultipleOf64(currentBytesLength));
+                int bufferLength = checked((int)BitUtility.RoundUpToMultiplePowerOfTwo(currentBytesLength, byteSize));
 
                 MemoryAllocator memoryAllocator = allocator ?? MemoryAllocator.Default.Value;
                 IMemoryOwner<byte> memoryOwner = memoryAllocator.Allocate(bufferLength);
diff --git a/csharp/src/Apache.Arrow/DecimalUtility.cs b/csharp/src/Apache.Arrow/DecimalUtility.cs
new file mode 100644
index 000000000000..b7ee6b9a87aa
--- /dev/null
+++ b/csharp/src/Apache.Arrow/DecimalUtility.cs
@@ -0,0 +1,162 @@
+// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements. See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+using System;
+using System.Numerics;
+
+namespace Apache.Arrow
+{
+    /// <summary>
+    /// This is semi-optimised best attempt at converting to / from decimal and the buffers
+    /// </summary>
+    internal static class DecimalUtility
+    {
+        private static readonly BigInteger _maxDecimal = new BigInteger(decimal.MaxValue);
+        private static readonly BigInteger _minDecimal = new BigInteger(decimal.MinValue);
+        private static readonly ulong[] s_powersOfTen =
+        {
+            1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000, 100000000000,
+            1000000000000, 10000000000000, 100000000000000, 1000000000000000, 10000000000000000, 100000000000000000,
+            1000000000000000000, 10000000000000000000
+        };
+
+        private static int PowersOfTenLength => s_powersOfTen.Length - 1;
+
+        internal static decimal GetDecimal(in ArrowBuffer valueBuffer, int index, int scale, int byteWidth)
+        {
+            int startIndex = index * byteWidth;
+            ReadOnlySpan<byte> value = valueBuffer.Span.Slice(startIndex, byteWidth);
+            BigInteger integerValue;
+
+#if NETCOREAPP
+            integerValue = new BigInteger(value);
+#else
+            integerValue = new BigInteger(value.ToArray());
+#endif
+
+            if (integerValue > _maxDecimal || integerValue < _minDecimal)
+            {
+                BigInteger scaleBy = BigInteger.Pow(10, scale);
+                BigInteger integerPart = BigInteger.DivRem(integerValue, scaleBy, out BigInteger fractionalPart);
+                if (integerPart > _maxDecimal || integerPart < _minDecimal) // decimal overflow, not much we can do here - C# needs a BigDecimal
+                {
+                    throw new OverflowException($"Value: {integerPart} too big or too small to be represented as a decimal");
+                }
+                return (decimal)integerPart + DivideByScale(fractionalPart, scale);
+            }
+            else
+            {
+                return DivideByScale(integerValue, scale);
+            }
+        }
+
+        private static decimal DivideByScale(BigInteger integerValue, int scale)
+        {
+            decimal result = (decimal)integerValue; // this cast is safe here
+            int drop = scale;
+            while (drop > PowersOfTenLength)
+            {
+                result /= s_powersOfTen[PowersOfTenLength];
+                drop -= PowersOfTenLength;
+            }
+
+            result /= s_powersOfTen[drop];
+            return result;
+        }
+
+        internal static void GetBytes(decimal value, int precision, int scale, int byteWidth, Span<byte> bytes)
+        {
+            // create BigInteger from decimal
+            BigInteger bigInt;
+            int[] decimalBits = decimal.GetBits(value);
+            int decScale = (decimalBits[3] >> 16) & 0x7F;
+#if NETCOREAPP
+            Span<byte> bigIntBytes = stackalloc byte[12];
+
+                for (int i = 0; i < 3; i++)
+                {
+                    int bit = decimalBits[i];
+                    Span<byte> intBytes = stackalloc byte[4];
+                    if (!BitConverter.TryWriteBytes(intBytes, bit))
+                        throw new OverflowException($"Could not extract bytes from int {bit}");
+
+                    for (int j = 0; j < 4; j++)
+                    {
+                        bigIntBytes[4 * i + j] = intBytes[j];
+                    }
+                }
+                bigInt = new BigInteger(bigIntBytes);
+#else
+            byte[] bigIntBytes = new byte[12];
+                for (int i = 0; i < 3; i++)
+                {
+                    int bit = decimalBits[i];
+                    byte[] intBytes = BitConverter.GetBytes(bit);
+                    for (int j = 0; j < intBytes.Length; j++)
+                    {
+                        bigIntBytes[4 * i + j] = intBytes[j];
+                    }
+                }
+                bigInt = new BigInteger(bigIntBytes);
+#endif
+
+            if (value < 0)
+            {
+                bigInt = -bigInt;
+            }
+
+            // validate precision and scale
+            if (decScale > scale)
+                throw new OverflowException($"Decimal scale cannot be greater than that in the Arrow vector: {decScale} != {scale}");
+
+            if (bigInt >= BigInteger.Pow(10, precision))
+                throw new OverflowException($"Decimal precision cannot be greater than that in the Arrow vector: {value} has precision > {precision}");
+
+            if (decScale < scale) // pad with trailing zeros
+            {
+                bigInt *= BigInteger.Pow(10, scale - decScale);
+            }
+
+            // extract bytes from BigInteger
+            if (bytes.Length != byteWidth)
+            {
+                throw new OverflowException($"ValueBuffer size not equal to {byteWidth} byte width: {bytes.Length}");
+            }
+
+            int bytesWritten;
+#if NETCOREAPP
+            if (!bigInt.TryWriteBytes(bytes, out bytesWritten, false, !BitConverter.IsLittleEndian))
+                throw new OverflowException("Could not extract bytes from integer value " + bigInt);
+#else
+            byte[] tempBytes = bigInt.ToByteArray();
+            tempBytes.CopyTo(bytes);
+            bytesWritten = tempBytes.Length;
+#endif
+
+            if (bytes.Length > byteWidth)
+            {
+                throw new OverflowException($"Decimal size greater than {byteWidth} bytes: {bytes.Length}");
+            }
+
+            if (bigInt.Sign == -1)
+            {
+                for (int i = bytesWritten; i < byteWidth; i++)
+                {
+                    bytes[i] = 255;
+                }
+            }
+        }
+    }
+}
diff --git a/csharp/src/Apache.Arrow/Flatbuf/BodyCompression.cs b/csharp/src/Apache.Arrow/Flatbuf/BodyCompression.cs
new file mode 100644
index 000000000000..dda0dd403518
--- /dev/null
+++ b/csharp/src/Apache.Arrow/Flatbuf/BodyCompression.cs
@@ -0,0 +1,47 @@
+// <auto-generated>
+//  automatically generated by the FlatBuffers compiler, do not modify
+// </auto-generated>
+
+namespace Apache.Arrow.Flatbuf
+{
+
+using global::System;
+using global::FlatBuffers;
+
+/// Optional compression for the memory buffers constituting IPC message
+/// bodies. Intended for use with RecordBatch but could be used for other
+/// message types
+internal struct BodyCompression : IFlatbufferObject
+{
+  private Table __p;
+  public ByteBuffer ByteBuffer { get { return __p.bb; } }
+  public static BodyCompression GetRootAsBodyCompression(ByteBuffer _bb) { return GetRootAsBodyCompression(_bb, new BodyCompression()); }
+  public static BodyCompression GetRootAsBodyCompression(ByteBuffer _bb, BodyCompression obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
+  public BodyCompression __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }
+
+  /// Compressor library
+  public CompressionType Codec { get { int o = __p.__offset(4); return o != 0 ? (CompressionType)__p.bb.GetSbyte(o + __p.bb_pos) : CompressionType.LZ4_FRAME; } }
+  /// Indicates the way the record batch body was compressed
+  public BodyCompressionMethod Method { get { int o = __p.__offset(6); return o != 0 ? (BodyCompressionMethod)__p.bb.GetSbyte(o + __p.bb_pos) : BodyCompressionMethod.BUFFER; } }
+
+  public static Offset<BodyCompression> CreateBodyCompression(FlatBufferBuilder builder,
+      CompressionType codec = CompressionType.LZ4_FRAME,
+      BodyCompressionMethod method = BodyCompressionMethod.BUFFER) {
+    builder.StartObject(2);
+    BodyCompression.AddMethod(builder, method);
+    BodyCompression.AddCodec(builder, codec);
+    return BodyCompression.EndBodyCompression(builder);
+  }
+
+  public static void StartBodyCompression(FlatBufferBuilder builder) { builder.StartObject(2); }
+  public static void AddCodec(FlatBufferBuilder builder, CompressionType codec) { builder.AddSbyte(0, (sbyte)codec, 0); }
+  public static void AddMethod(FlatBufferBuilder builder, BodyCompressionMethod method) { builder.AddSbyte(1, (sbyte)method, 0); }
+  public static Offset<BodyCompression> EndBodyCompression(FlatBufferBuilder builder) {
+    int o = builder.EndObject();
+    return new Offset<BodyCompression>(o);
+  }
+};
+
+
+}
diff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/BodyCompressionMethod.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/BodyCompressionMethod.cs
new file mode 100644
index 000000000000..e9f6b6e831e5
--- /dev/null
+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/BodyCompressionMethod.cs
@@ -0,0 +1,24 @@
+// <auto-generated>
+//  automatically generated by the FlatBuffers compiler, do not modify
+// </auto-generated>
+
+namespace Apache.Arrow.Flatbuf
+{
+
+/// Provided for forward compatibility in case we need to support different
+/// strategies for compressing the IPC message body (like whole-body
+/// compression rather than buffer-level) in the future
+internal enum BodyCompressionMethod : sbyte
+{
+  /// Each constituent buffer is first compressed with the indicated
+  /// compressor, and then written with the uncompressed length in the first 8
+  /// bytes as a 64-bit little-endian signed integer followed by the compressed
+  /// buffer bytes (and then padding as required by the protocol). The
+  /// uncompressed length may be set to -1 to indicate that the data that
+  /// follows is not compressed, which can be useful for cases where
+  /// compression does not yield appreciable savings.
+ BUFFER = 0,
+};
+
+
+}
diff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/CompressionType.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/CompressionType.cs
new file mode 100644
index 000000000000..3d886c508154
--- /dev/null
+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/CompressionType.cs
@@ -0,0 +1,15 @@
+// <auto-generated>
+//  automatically generated by the FlatBuffers compiler, do not modify
+// </auto-generated>
+
+namespace Apache.Arrow.Flatbuf
+{
+
+internal enum CompressionType : sbyte
+{
+ LZ4_FRAME = 0,
+ ZSTD = 1,
+};
+
+
+}
diff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/Feature.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/Feature.cs
new file mode 100644
index 000000000000..a05b6cf496c1
--- /dev/null
+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/Feature.cs
@@ -0,0 +1,39 @@
+// <auto-generated>
+//  automatically generated by the FlatBuffers compiler, do not modify
+// </auto-generated>
+
+namespace Apache.Arrow.Flatbuf
+{
+
+/// Represents Arrow Features that might not have full support
+/// within implementations. This is intended to be used in
+/// two scenarios:
+///  1.  A mechanism for readers of Arrow Streams
+///      and files to understand that the stream or file makes
+///      use of a feature that isn't supported or unknown to
+///      the implementation (and therefore can meet the Arrow
+///      forward compatibility guarantees).
+///  2.  A means of negotiating between a client and server
+///      what features a stream is allowed to use. The enums
+///      values here are intented to represent higher level
+///      features, additional details maybe negotiated
+///      with key-value pairs specific to the protocol.
+///
+/// Enums added to this list should be assigned power-of-two values
+/// to facilitate exchanging and comparing bitmaps for supported
+/// features.
+internal enum Feature : long
+{
+  /// Needed to make flatbuffers happy.
+ UNUSED = 0,
+  /// The stream makes use of multiple full dictionaries with the
+  /// same ID and assumes clients implement dictionary replacement
+  /// correctly.
+ DICTIONARY_REPLACEMENT = 1,
+  /// The stream makes use of compressed bodies as described
+  /// in Message.fbs.
+ COMPRESSED_BODY = 2,
+};
+
+
+}
diff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/MetadataVersion.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/MetadataVersion.cs
index 9d5c93512d4c..1e893e8cb6ff 100644
--- a/csharp/src/Apache.Arrow/Flatbuf/Enums/MetadataVersion.cs
+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/MetadataVersion.cs
@@ -7,14 +7,22 @@ namespace Apache.Arrow.Flatbuf
 
 internal enum MetadataVersion : short
 {
-  /// 0.1.0
+  /// 0.1.0 (October 2016).
  V1 = 0,
-  /// 0.2.0
+  /// 0.2.0 (February 2017). Non-backwards compatible with V1.
  V2 = 1,
-  /// 0.3.0 -> 0.7.1
+  /// 0.3.0 -> 0.7.1 (May - December 2017). Non-backwards compatible with V2.
  V3 = 2,
-  /// >= 0.8.0
+  /// >= 0.8.0 (December 2017). Non-backwards compatible with V3.
  V4 = 3,
+  /// >= 1.0.0 (July 2020. Backwards compatible with V4 (V5 readers can read V4
+  /// metadata and IPC messages). Implementations are recommended to provide a
+  /// V4 compatibility mode with V5 format changes disabled.
+  ///
+  /// Incompatible changes between V4 and V5:
+  /// - Union buffer layout has changed. In V5, Unions don't have a validity
+  ///   bitmap buffer.
+ V5 = 4,
 };
 
 
diff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/Type.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/Type.cs
index 5dcb1260b49d..e8a7932a7036 100644
--- a/csharp/src/Apache.Arrow/Flatbuf/Enums/Type.cs
+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/Type.cs
@@ -28,6 +28,10 @@ internal enum Type : byte
  FixedSizeBinary = 15,
  FixedSizeList = 16,
  Map = 17,
+ Duration = 18,
+ LargeBinary = 19,
+ LargeUtf8 = 20,
+ LargeList = 21,
 };
 
 
diff --git a/csharp/src/Apache.Arrow/Flatbuf/Footer.cs b/csharp/src/Apache.Arrow/Flatbuf/Footer.cs
index d9f50a23c841..37dbfef94093 100644
--- a/csharp/src/Apache.Arrow/Flatbuf/Footer.cs
+++ b/csharp/src/Apache.Arrow/Flatbuf/Footer.cs
@@ -26,13 +26,18 @@ internal struct Footer : IFlatbufferObject
   public int DictionariesLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
   public Block? RecordBatches(int j) { int o = __p.__offset(10); return o != 0 ? (Block?)(new Block()).__assign(__p.__vector(o) + j * 24, __p.bb) : null; }
   public int RecordBatchesLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
+  /// User-defined metadata
+  public KeyValue? CustomMetadata(int j) { int o = __p.__offset(12); return o != 0 ? (KeyValue?)(new KeyValue()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
+  public int CustomMetadataLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
 
   public static Offset<Footer> CreateFooter(FlatBufferBuilder builder,
       MetadataVersion version = MetadataVersion.V1,
       Offset<Schema> schemaOffset = default(Offset<Schema>),
       VectorOffset dictionariesOffset = default(VectorOffset),
-      VectorOffset recordBatchesOffset = default(VectorOffset)) {
-    builder.StartObject(4);
+      VectorOffset recordBatchesOffset = default(VectorOffset),
+      VectorOffset custom_metadataOffset = default(VectorOffset)) {
+    builder.StartObject(5);
+    Footer.AddCustomMetadata(builder, custom_metadataOffset);
     Footer.AddRecordBatches(builder, recordBatchesOffset);
     Footer.AddDictionaries(builder, dictionariesOffset);
     Footer.AddSchema(builder, schemaOffset);
@@ -40,13 +45,17 @@ internal struct Footer : IFlatbufferObject
     return Footer.EndFooter(builder);
   }
 
-  public static void StartFooter(FlatBufferBuilder builder) { builder.StartObject(4); }
+  public static void StartFooter(FlatBufferBuilder builder) { builder.StartObject(5); }
   public static void AddVersion(FlatBufferBuilder builder, MetadataVersion version) { builder.AddShort(0, (short)version, 0); }
   public static void AddSchema(FlatBufferBuilder builder, Offset<Schema> schemaOffset) { builder.AddOffset(1, schemaOffset.Value, 0); }
   public static void AddDictionaries(FlatBufferBuilder builder, VectorOffset dictionariesOffset) { builder.AddOffset(2, dictionariesOffset.Value, 0); }
   public static void StartDictionariesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(24, numElems, 8); }
   public static void AddRecordBatches(FlatBufferBuilder builder, VectorOffset recordBatchesOffset) { builder.AddOffset(3, recordBatchesOffset.Value, 0); }
   public static void StartRecordBatchesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(24, numElems, 8); }
+  public static void AddCustomMetadata(FlatBufferBuilder builder, VectorOffset customMetadataOffset) { builder.AddOffset(4, customMetadataOffset.Value, 0); }
+  public static VectorOffset CreateCustomMetadataVector(FlatBufferBuilder builder, Offset<KeyValue>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
+  public static VectorOffset CreateCustomMetadataVectorBlock(FlatBufferBuilder builder, Offset<KeyValue>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
+  public static void StartCustomMetadataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
   public static Offset<Footer> EndFooter(FlatBufferBuilder builder) {
     int o = builder.EndObject();
     return new Offset<Footer>(o);
diff --git a/csharp/src/Apache.Arrow/Flatbuf/Message.cs b/csharp/src/Apache.Arrow/Flatbuf/Message.cs
index 0bf9ffa5314f..db54e6ab32c7 100644
--- a/csharp/src/Apache.Arrow/Flatbuf/Message.cs
+++ b/csharp/src/Apache.Arrow/Flatbuf/Message.cs
@@ -21,25 +21,33 @@ internal struct Message : IFlatbufferObject
   public MessageHeader HeaderType { get { int o = __p.__offset(6); return o != 0 ? (MessageHeader)__p.bb.Get(o + __p.bb_pos) : MessageHeader.NONE; } }
   public TTable? Header<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(8); return o != 0 ? (TTable?)__p.__union<TTable>(o) : null; }
   public long BodyLength { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }
+  public KeyValue? CustomMetadata(int j) { int o = __p.__offset(12); return o != 0 ? (KeyValue?)(new KeyValue()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
+  public int CustomMetadataLength { get { int o = __p.__offset(12); return o != 0 ? __p.__vector_len(o) : 0; } }
 
   public static Offset<Message> CreateMessage(FlatBufferBuilder builder,
       MetadataVersion version = MetadataVersion.V1,
       MessageHeader header_type = MessageHeader.NONE,
       int headerOffset = 0,
-      long bodyLength = 0) {
-    builder.StartObject(4);
+      long bodyLength = 0,
+      VectorOffset custom_metadataOffset = default(VectorOffset)) {
+    builder.StartObject(5);
     Message.AddBodyLength(builder, bodyLength);
+    Message.AddCustomMetadata(builder, custom_metadataOffset);
     Message.AddHeader(builder, headerOffset);
     Message.AddVersion(builder, version);
     Message.AddHeaderType(builder, header_type);
     return Message.EndMessage(builder);
   }
 
-  public static void StartMessage(FlatBufferBuilder builder) { builder.StartObject(4); }
+  public static void StartMessage(FlatBufferBuilder builder) { builder.StartObject(5); }
   public static void AddVersion(FlatBufferBuilder builder, MetadataVersion version) { builder.AddShort(0, (short)version, 0); }
   public static void AddHeaderType(FlatBufferBuilder builder, MessageHeader headerType) { builder.AddByte(1, (byte)headerType, 0); }
   public static void AddHeader(FlatBufferBuilder builder, int headerOffset) { builder.AddOffset(2, headerOffset, 0); }
   public static void AddBodyLength(FlatBufferBuilder builder, long bodyLength) { builder.AddLong(3, bodyLength, 0); }
+  public static void AddCustomMetadata(FlatBufferBuilder builder, VectorOffset customMetadataOffset) { builder.AddOffset(4, customMetadataOffset.Value, 0); }
+  public static VectorOffset CreateCustomMetadataVector(FlatBufferBuilder builder, Offset<KeyValue>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
+  public static VectorOffset CreateCustomMetadataVectorBlock(FlatBufferBuilder builder, Offset<KeyValue>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
+  public static void StartCustomMetadataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
   public static Offset<Message> EndMessage(FlatBufferBuilder builder) {
     int o = builder.EndObject();
     return new Offset<Message>(o);
diff --git a/csharp/src/Apache.Arrow/Flatbuf/RecordBatch.cs b/csharp/src/Apache.Arrow/Flatbuf/RecordBatch.cs
index 9bd1acfc374e..4c95acde9d85 100644
--- a/csharp/src/Apache.Arrow/Flatbuf/RecordBatch.cs
+++ b/csharp/src/Apache.Arrow/Flatbuf/RecordBatch.cs
@@ -34,24 +34,29 @@ internal struct RecordBatch : IFlatbufferObject
   /// single buffer for the validity (nulls) bitmap
   public Buffer? Buffers(int j) { int o = __p.__offset(8); return o != 0 ? (Buffer?)(new Buffer()).__assign(__p.__vector(o) + j * 16, __p.bb) : null; }
   public int BuffersLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
+  /// Optional compression of the message body
+  public BodyCompression? Compression { get { int o = __p.__offset(10); return o != 0 ? (BodyCompression?)(new BodyCompression()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }
 
   public static Offset<RecordBatch> CreateRecordBatch(FlatBufferBuilder builder,
       long length = 0,
       VectorOffset nodesOffset = default(VectorOffset),
-      VectorOffset buffersOffset = default(VectorOffset)) {
-    builder.StartObject(3);
+      VectorOffset buffersOffset = default(VectorOffset),
+      Offset<BodyCompression> compressionOffset = default(Offset<BodyCompression>)) {
+    builder.StartObject(4);
     RecordBatch.AddLength(builder, length);
+    RecordBatch.AddCompression(builder, compressionOffset);
     RecordBatch.AddBuffers(builder, buffersOffset);
     RecordBatch.AddNodes(builder, nodesOffset);
     return RecordBatch.EndRecordBatch(builder);
   }
 
-  public static void StartRecordBatch(FlatBufferBuilder builder) { builder.StartObject(3); }
+  public static void StartRecordBatch(FlatBufferBuilder builder) { builder.StartObject(4); }
   public static void AddLength(FlatBufferBuilder builder, long length) { builder.AddLong(0, length, 0); }
   public static void AddNodes(FlatBufferBuilder builder, VectorOffset nodesOffset) { builder.AddOffset(1, nodesOffset.Value, 0); }
   public static void StartNodesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(16, numElems, 8); }
   public static void AddBuffers(FlatBufferBuilder builder, VectorOffset buffersOffset) { builder.AddOffset(2, buffersOffset.Value, 0); }
   public static void StartBuffersVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(16, numElems, 8); }
+  public static void AddCompression(FlatBufferBuilder builder, Offset<BodyCompression> compressionOffset) { builder.AddOffset(3, compressionOffset.Value, 0); }
   public static Offset<RecordBatch> EndRecordBatch(FlatBufferBuilder builder) {
     int o = builder.EndObject();
     return new Offset<RecordBatch>(o);
diff --git a/csharp/src/Apache.Arrow/Flatbuf/Schema.cs b/csharp/src/Apache.Arrow/Flatbuf/Schema.cs
index 206a8a1983d8..3764e7ba3a1f 100644
--- a/csharp/src/Apache.Arrow/Flatbuf/Schema.cs
+++ b/csharp/src/Apache.Arrow/Flatbuf/Schema.cs
@@ -27,19 +27,30 @@ internal struct Schema : IFlatbufferObject
   public int FieldsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }
   public KeyValue? CustomMetadata(int j) { int o = __p.__offset(8); return o != 0 ? (KeyValue?)(new KeyValue()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }
   public int CustomMetadataLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }
+  /// Features used in the stream/file.
+  public Feature Features(int j) { int o = __p.__offset(10); return o != 0 ? (Feature)__p.bb.GetLong(__p.__vector(o) + j * 8) : (Feature)0; }
+  public int FeaturesLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }
+#if ENABLE_SPAN_T
+  public Span<byte> GetFeaturesBytes() { return __p.__vector_as_span(10); }
+#else
+  public ArraySegment<byte>? GetFeaturesBytes() { return __p.__vector_as_arraysegment(10); }
+#endif
+  public Feature[] GetFeaturesArray() { return __p.__vector_as_array<Feature>(10); }
 
   public static Offset<Schema> CreateSchema(FlatBufferBuilder builder,
       Endianness endianness = Endianness.Little,
       VectorOffset fieldsOffset = default(VectorOffset),
-      VectorOffset custom_metadataOffset = default(VectorOffset)) {
-    builder.StartObject(3);
+      VectorOffset custom_metadataOffset = default(VectorOffset),
+      VectorOffset featuresOffset = default(VectorOffset)) {
+    builder.StartObject(4);
+    Schema.AddFeatures(builder, featuresOffset);
     Schema.AddCustomMetadata(builder, custom_metadataOffset);
     Schema.AddFields(builder, fieldsOffset);
     Schema.AddEndianness(builder, endianness);
     return Schema.EndSchema(builder);
   }
 
-  public static void StartSchema(FlatBufferBuilder builder) { builder.StartObject(3); }
+  public static void StartSchema(FlatBufferBuilder builder) { builder.StartObject(4); }
   public static void AddEndianness(FlatBufferBuilder builder, Endianness endianness) { builder.AddShort(0, (short)endianness, 0); }
   public static void AddFields(FlatBufferBuilder builder, VectorOffset fieldsOffset) { builder.AddOffset(1, fieldsOffset.Value, 0); }
   public static VectorOffset CreateFieldsVector(FlatBufferBuilder builder, Offset<Field>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
@@ -49,6 +60,10 @@ internal struct Schema : IFlatbufferObject
   public static VectorOffset CreateCustomMetadataVector(FlatBufferBuilder builder, Offset<KeyValue>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }
   public static VectorOffset CreateCustomMetadataVectorBlock(FlatBufferBuilder builder, Offset<KeyValue>[] data) { builder.StartVector(4, data.Length, 4); builder.Add(data); return builder.EndVector(); }
   public static void StartCustomMetadataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }
+  public static void AddFeatures(FlatBufferBuilder builder, VectorOffset featuresOffset) { builder.AddOffset(3, featuresOffset.Value, 0); }
+  public static VectorOffset CreateFeaturesVector(FlatBufferBuilder builder, Feature[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong((long)data[i]); return builder.EndVector(); }
+  public static VectorOffset CreateFeaturesVectorBlock(FlatBufferBuilder builder, Feature[] data) { builder.StartVector(8, data.Length, 8); builder.Add(data); return builder.EndVector(); }
+  public static void StartFeaturesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }
   public static Offset<Schema> EndSchema(FlatBufferBuilder builder) {
     int o = builder.EndObject();
     return new Offset<Schema>(o);
diff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Decimal.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Decimal.cs
index b661709f7226..97f62b6761b2 100644
--- a/csharp/src/Apache.Arrow/Flatbuf/Types/Decimal.cs
+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Decimal.cs
@@ -8,7 +8,11 @@ namespace Apache.Arrow.Flatbuf
 using global::System;
 using global::FlatBuffers;
 
-internal struct Decimal : IFlatbufferObject
+/// Exact decimal value represented as an integer value in two's
+/// complement. Currently only 128-bit (16-byte) and 256-bit (32-byte) integers
+/// are used. The representation uses the endianness indicated
+/// in the Schema.
+internal struct Decimal: IFlatbufferObject
 {
   private Table __p;
   public ByteBuffer ByteBuffer { get { return __p.bb; } }
@@ -21,19 +25,25 @@ internal struct Decimal : IFlatbufferObject
   public int Precision { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
   /// Number of digits after the decimal point "."
   public int Scale { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }
+  /// Number of bits per value. The only accepted widths are 128 and 256.
+  /// We use bitWidth for consistency with Int::bitWidth.
+  public int BitWidth { get { int o = __p.__offset(8); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)128; } }
 
   public static Offset<Decimal> CreateDecimal(FlatBufferBuilder builder,
       int precision = 0,
-      int scale = 0) {
-    builder.StartObject(2);
+      int scale = 0,
+      int bitWidth = 128) {
+    builder.StartObject(3);
+    Decimal.AddBitWidth(builder, bitWidth);
     Decimal.AddScale(builder, scale);
     Decimal.AddPrecision(builder, precision);
     return Decimal.EndDecimal(builder);
   }
 
-  public static void StartDecimal(FlatBufferBuilder builder) { builder.StartObject(2); }
+  public static void StartDecimal(FlatBufferBuilder builder) { builder.StartObject(3); }
   public static void AddPrecision(FlatBufferBuilder builder, int precision) { builder.AddInt(0, precision, 0); }
   public static void AddScale(FlatBufferBuilder builder, int scale) { builder.AddInt(1, scale, 0); }
+  public static void AddBitWidth(FlatBufferBuilder builder, int bitWidth) { builder.AddInt(2, bitWidth, 128); }
   public static Offset<Decimal> EndDecimal(FlatBufferBuilder builder) {
     int o = builder.EndObject();
     return new Offset<Decimal>(o);
diff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Duration.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Duration.cs
new file mode 100644
index 000000000000..1f3a9e410958
--- /dev/null
+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Duration.cs
@@ -0,0 +1,38 @@
+// <auto-generated>
+//  automatically generated by the FlatBuffers compiler, do not modify
+// </auto-generated>
+
+namespace Apache.Arrow.Flatbuf
+{
+
+using global::System;
+using global::FlatBuffers;
+
+internal struct Duration : IFlatbufferObject
+{
+  private Table __p;
+  public ByteBuffer ByteBuffer { get { return __p.bb; } }
+  public static Duration GetRootAsDuration(ByteBuffer _bb) { return GetRootAsDuration(_bb, new Duration()); }
+  public static Duration GetRootAsDuration(ByteBuffer _bb, Duration obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
+  public Duration __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }
+
+  public TimeUnit Unit { get { int o = __p.__offset(4); return o != 0 ? (TimeUnit)__p.bb.GetShort(o + __p.bb_pos) : TimeUnit.MILLISECOND; } }
+
+  public static Offset<Duration> CreateDuration(FlatBufferBuilder builder,
+      TimeUnit unit = TimeUnit.MILLISECOND) {
+    builder.StartObject(1);
+    Duration.AddUnit(builder, unit);
+    return Duration.EndDuration(builder);
+  }
+
+  public static void StartDuration(FlatBufferBuilder builder) { builder.StartObject(1); }
+  public static void AddUnit(FlatBufferBuilder builder, TimeUnit unit) { builder.AddShort(0, (short)unit, 1); }
+  public static Offset<Duration> EndDuration(FlatBufferBuilder builder) {
+    int o = builder.EndObject();
+    return new Offset<Duration>(o);
+  }
+};
+
+
+}
diff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/LargeBinary.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/LargeBinary.cs
new file mode 100644
index 000000000000..8ac6aa2cd032
--- /dev/null
+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/LargeBinary.cs
@@ -0,0 +1,31 @@
+// <auto-generated>
+//  automatically generated by the FlatBuffers compiler, do not modify
+// </auto-generated>
+
+namespace Apache.Arrow.Flatbuf
+{
+
+using global::System;
+using global::FlatBuffers;
+
+/// Same as Binary, but with 64-bit offsets, allowing to represent
+/// extremely large data values.
+internal struct LargeBinary : IFlatbufferObject
+{
+  private Table __p;
+  public ByteBuffer ByteBuffer { get { return __p.bb; } }
+  public static LargeBinary GetRootAsLargeBinary(ByteBuffer _bb) { return GetRootAsLargeBinary(_bb, new LargeBinary()); }
+  public static LargeBinary GetRootAsLargeBinary(ByteBuffer _bb, LargeBinary obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
+  public LargeBinary __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }
+
+
+  public static void StartLargeBinary(FlatBufferBuilder builder) { builder.StartObject(0); }
+  public static Offset<LargeBinary> EndLargeBinary(FlatBufferBuilder builder) {
+    int o = builder.EndObject();
+    return new Offset<LargeBinary>(o);
+  }
+};
+
+
+}
diff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/LargeList.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/LargeList.cs
new file mode 100644
index 000000000000..49e69a87f9ad
--- /dev/null
+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/LargeList.cs
@@ -0,0 +1,31 @@
+// <auto-generated>
+//  automatically generated by the FlatBuffers compiler, do not modify
+// </auto-generated>
+
+namespace Apache.Arrow.Flatbuf
+{
+
+using global::System;
+using global::FlatBuffers;
+
+/// Same as List, but with 64-bit offsets, allowing to represent
+/// extremely large data values.
+internal struct LargeList : IFlatbufferObject
+{
+  private Table __p;
+  public ByteBuffer ByteBuffer { get { return __p.bb; } }
+  public static LargeList GetRootAsLargeList(ByteBuffer _bb) { return GetRootAsLargeList(_bb, new LargeList()); }
+  public static LargeList GetRootAsLargeList(ByteBuffer _bb, LargeList obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
+  public LargeList __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }
+
+
+  public static void StartLargeList(FlatBufferBuilder builder) { builder.StartObject(0); }
+  public static Offset<LargeList> EndLargeList(FlatBufferBuilder builder) {
+    int o = builder.EndObject();
+    return new Offset<LargeList>(o);
+  }
+};
+
+
+}
diff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/LargeUtf8.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/LargeUtf8.cs
new file mode 100644
index 000000000000..ebb64390ff49
--- /dev/null
+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/LargeUtf8.cs
@@ -0,0 +1,31 @@
+// <auto-generated>
+//  automatically generated by the FlatBuffers compiler, do not modify
+// </auto-generated>
+
+namespace Apache.Arrow.Flatbuf
+{
+
+using global::System;
+using global::FlatBuffers;
+
+/// Same as Utf8, but with 64-bit offsets, allowing to represent
+/// extremely large data values.
+internal struct LargeUtf8 : IFlatbufferObject
+{
+  private Table __p;
+  public ByteBuffer ByteBuffer { get { return __p.bb; } }
+  public static LargeUtf8 GetRootAsLargeUtf8(ByteBuffer _bb) { return GetRootAsLargeUtf8(_bb, new LargeUtf8()); }
+  public static LargeUtf8 GetRootAsLargeUtf8(ByteBuffer _bb, LargeUtf8 obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }
+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }
+  public LargeUtf8 __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }
+
+
+  public static void StartLargeUtf8(FlatBufferBuilder builder) { builder.StartObject(0); }
+  public static Offset<LargeUtf8> EndLargeUtf8(FlatBufferBuilder builder) {
+    int o = builder.EndObject();
+    return new Offset<LargeUtf8>(o);
+  }
+};
+
+
+}
diff --git a/csharp/src/Apache.Arrow/Ipc/ArrowStreamWriter.cs b/csharp/src/Apache.Arrow/Ipc/ArrowStreamWriter.cs
index 3ad6ed25d956..5f0d16f83068 100644
--- a/csharp/src/Apache.Arrow/Ipc/ArrowStreamWriter.cs
+++ b/csharp/src/Apache.Arrow/Ipc/ArrowStreamWriter.cs
@@ -46,7 +46,9 @@ internal class ArrowRecordBatchFlatBufferBuilder :
             IArrowArrayVisitor<ListArray>,
             IArrowArrayVisitor<StringArray>,
             IArrowArrayVisitor<BinaryArray>,
-            IArrowArrayVisitor<StructArray>
+            IArrowArrayVisitor<StructArray>,
+            IArrowArrayVisitor<Decimal128Array>,
+            IArrowArrayVisitor<Decimal256Array>
         {
             public readonly struct Buffer
             {
@@ -104,6 +106,18 @@ public void Visit(BinaryArray array)
                 _buffers.Add(CreateBuffer(array.ValueBuffer));
             }
 
+            public void Visit(Decimal128Array array)
+            {
+                _buffers.Add(CreateBuffer(array.NullBitmapBuffer));
+                _buffers.Add(CreateBuffer(array.ValueBuffer));
+            }
+
+            public void Visit(Decimal256Array array)
+            {
+                _buffers.Add(CreateBuffer(array.NullBitmapBuffer));
+                _buffers.Add(CreateBuffer(array.ValueBuffer));
+            }
+
             public void Visit(StructArray array)
             {
                 _buffers.Add(CreateBuffer(array.NullBitmapBuffer));
diff --git a/csharp/src/Apache.Arrow/Ipc/ArrowTypeFlatbufferBuilder.cs b/csharp/src/Apache.Arrow/Ipc/ArrowTypeFlatbufferBuilder.cs
index b331e89b1159..d0d2b74e701b 100644
--- a/csharp/src/Apache.Arrow/Ipc/ArrowTypeFlatbufferBuilder.cs
+++ b/csharp/src/Apache.Arrow/Ipc/ArrowTypeFlatbufferBuilder.cs
@@ -61,7 +61,9 @@ class TypeVisitor :
             IArrowTypeVisitor<TimestampType>,
             IArrowTypeVisitor<ListType>,
             IArrowTypeVisitor<UnionType>,
-            IArrowTypeVisitor<StructType>
+            IArrowTypeVisitor<StructType>,
+            IArrowTypeVisitor<Decimal128Type>,
+            IArrowTypeVisitor<Decimal256Type>
         {
             private FlatBufferBuilder Builder { get; }
 
@@ -178,6 +180,20 @@ public void Visit(StructType type)
                 Result = FieldType.Build(Flatbuf.Type.Struct_, Flatbuf.Struct_.EndStruct_(Builder));
             }
 
+            public void Visit(Decimal128Type type)
+            {
+                Result = FieldType.Build(
+                    Flatbuf.Type.Decimal,
+                    Flatbuf.Decimal.CreateDecimal(Builder, type.Precision, type.Scale, type.BitWidth));
+            }
+
+            public void Visit(Decimal256Type type)
+            {
+                Result = FieldType.Build(
+                    Flatbuf.Type.Decimal,
+                    Flatbuf.Decimal.CreateDecimal(Builder, type.Precision, type.Scale, type.BitWidth));
+            }
+
             private void CreateIntType(NumberType type)
             {
                 Result = FieldType.Build(
diff --git a/csharp/src/Apache.Arrow/Ipc/MessageSerializer.cs b/csharp/src/Apache.Arrow/Ipc/MessageSerializer.cs
index b39e7498bf38..a4e766089245 100644
--- a/csharp/src/Apache.Arrow/Ipc/MessageSerializer.cs
+++ b/csharp/src/Apache.Arrow/Ipc/MessageSerializer.cs
@@ -117,7 +117,15 @@ private static Types.IArrowType GetFieldArrowType(Flatbuf.Field field, Field[] c
                     return new Types.BooleanType();
                 case Flatbuf.Type.Decimal:
                     Flatbuf.Decimal decMeta = field.Type<Flatbuf.Decimal>().Value;
-                    return new Types.DecimalType(decMeta.Precision, decMeta.Scale);
+                    switch (decMeta.BitWidth)
+                    {
+                        case 128:
+                            return new Types.Decimal128Type(decMeta.Precision, decMeta.Scale);
+                        case 256:
+                            return new Types.Decimal256Type(decMeta.Precision, decMeta.Scale);
+                        default:
+                            throw new InvalidDataException("Unsupported decimal bit width " + decMeta.BitWidth);
+                    }
                 case Flatbuf.Type.Date:
                     Flatbuf.Date dateMeta = field.Type<Flatbuf.Date>().Value;
                     switch (dateMeta.Unit)
diff --git a/csharp/src/Apache.Arrow/RecordBatch.Builder.cs b/csharp/src/Apache.Arrow/RecordBatch.Builder.cs
index a11a9975038b..c50bf1ace411 100644
--- a/csharp/src/Apache.Arrow/RecordBatch.Builder.cs
+++ b/csharp/src/Apache.Arrow/RecordBatch.Builder.cs
@@ -44,6 +44,12 @@ internal ArrayBuilder(MemoryAllocator allocator)
             public UInt64Array UInt64(Action<UInt64Array.Builder> action) => Build<UInt64Array, UInt64Array.Builder>(new UInt64Array.Builder(), action);
             public FloatArray Float(Action<FloatArray.Builder> action) => Build<FloatArray, FloatArray.Builder>(new FloatArray.Builder(), action);
             public DoubleArray Double(Action<DoubleArray.Builder> action) => Build<DoubleArray, DoubleArray.Builder>(new DoubleArray.Builder(), action);
+            public Decimal128Array Decimal128(Decimal128Type type, Action<Decimal128Array.Builder> action) =>
+                Build<Decimal128Array, Decimal128Array.Builder>(
+                    new Decimal128Array.Builder(type), action);
+            public Decimal256Array Decimal256(Decimal256Type type, Action<Decimal256Array.Builder> action) =>
+                Build<Decimal256Array, Decimal256Array.Builder>(
+                    new Decimal256Array.Builder(type), action);
             public Date32Array Date32(Action<Date32Array.Builder> action) => Build<Date32Array, Date32Array.Builder>(new Date32Array.Builder(), action);
             public Date64Array Date64(Action<Date64Array.Builder> action) => Build<Date64Array, Date64Array.Builder>(new Date64Array.Builder(), action);
             public BinaryArray Binary(Action<BinaryArray.Builder> action) => Build<BinaryArray, BinaryArray.Builder>(new BinaryArray.Builder(), action);
diff --git a/csharp/src/Apache.Arrow/Types/DecimalType.cs b/csharp/src/Apache.Arrow/Types/Decimal128Type.cs
similarity index 80%
rename from csharp/src/Apache.Arrow/Types/DecimalType.cs
rename to csharp/src/Apache.Arrow/Types/Decimal128Type.cs
index cad2e2428727..e00b9da10ead 100644
--- a/csharp/src/Apache.Arrow/Types/DecimalType.cs
+++ b/csharp/src/Apache.Arrow/Types/Decimal128Type.cs
@@ -15,19 +15,21 @@
 
 namespace Apache.Arrow.Types
 {
-    public sealed class DecimalType: FixedSizeBinaryType
+    public sealed class Decimal128Type : FixedSizeBinaryType
     {
-        public override ArrowTypeId TypeId => ArrowTypeId.Decimal;
-        public override string Name => "decimal";
+        public override ArrowTypeId TypeId => ArrowTypeId.Decimal128;
+        public override string Name => "decimal128";
 
         public int Precision { get; }
         public int Scale { get; }
 
-        public DecimalType(int precision, int scale)
+        public Decimal128Type(int precision, int scale)
             : base(16)
         {
             Precision = precision;
             Scale = scale;
         }
+
+        public override void Accept(IArrowTypeVisitor visitor) => Accept(this, visitor);
     }
 }
diff --git a/csharp/src/Apache.Arrow/Types/Decimal256Type.cs b/csharp/src/Apache.Arrow/Types/Decimal256Type.cs
new file mode 100644
index 000000000000..b184deb3cde9
--- /dev/null
+++ b/csharp/src/Apache.Arrow/Types/Decimal256Type.cs
@@ -0,0 +1,35 @@
+﻿// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements. See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+namespace Apache.Arrow.Types
+{
+    public sealed class Decimal256Type: FixedSizeBinaryType
+    {
+        public override ArrowTypeId TypeId => ArrowTypeId.Decimal256;
+        public override string Name => "decimal256";
+
+        public int Precision { get; }
+        public int Scale { get; }
+
+        public Decimal256Type(int precision, int scale)
+            : base(32)
+        {
+            Precision = precision;
+            Scale = scale;
+        }
+
+        public override void Accept(IArrowTypeVisitor visitor) => Accept(this, visitor);
+    }
+}
diff --git a/csharp/src/Apache.Arrow/Types/IArrowType.cs b/csharp/src/Apache.Arrow/Types/IArrowType.cs
index 578e18b9dedf..15c9a0244515 100644
--- a/csharp/src/Apache.Arrow/Types/IArrowType.cs
+++ b/csharp/src/Apache.Arrow/Types/IArrowType.cs
@@ -40,7 +40,8 @@ public enum ArrowTypeId
         Time32,
         Time64,
         Interval,
-        Decimal,
+        Decimal128,
+        Decimal256,
         List,
         Struct,
         Union,
diff --git a/csharp/test/Apache.Arrow.Benchmarks/ArrowReaderBenchmark.cs b/csharp/test/Apache.Arrow.Benchmarks/ArrowReaderBenchmark.cs
index 9c1bd2ff302f..4e491a2a6b12 100644
--- a/csharp/test/Apache.Arrow.Benchmarks/ArrowReaderBenchmark.cs
+++ b/csharp/test/Apache.Arrow.Benchmarks/ArrowReaderBenchmark.cs
@@ -1,4 +1,4 @@
-﻿// Licensed to the Apache Software Foundation (ASF) under one or more
+// Licensed to the Apache Software Foundation (ASF) under one or more
 // contributor license agreements. See the NOTICE file distributed with
 // this work for additional information regarding copyright ownership.
 // The ASF licenses this file to You under the Apache License, Version 2.0
@@ -116,6 +116,10 @@ private static double SumAllNumbers(RecordBatch recordBatch)
                         DoubleArray doubleArray = (DoubleArray)array;
                         sum += Sum(doubleArray);
                         break;
+                    case ArrowTypeId.Decimal128:
+                        Decimal128Array decimalArray = (Decimal128Array)array;
+                        sum += Sum(decimalArray);
+                        break;
                 }
             }
             return sum;
@@ -142,5 +146,15 @@ private static long Sum(Int64Array int64Array)
             }
             return sum;
         }
+
+        private static double Sum(Decimal128Array decimal128Array)
+        {
+            double sum = 0;
+            for (int valueIndex = 0; valueIndex < decimal128Array.Length; valueIndex++)
+            {
+                sum += (double)decimal128Array.GetValue(valueIndex);
+            }
+            return sum;
+        }
     }
 }
diff --git a/csharp/test/Apache.Arrow.Benchmarks/ArrowWriterBenchmark.cs b/csharp/test/Apache.Arrow.Benchmarks/ArrowWriterBenchmark.cs
index e2f52edf0114..f35c2a5d78d7 100644
--- a/csharp/test/Apache.Arrow.Benchmarks/ArrowWriterBenchmark.cs
+++ b/csharp/test/Apache.Arrow.Benchmarks/ArrowWriterBenchmark.cs
@@ -28,8 +28,8 @@ public class ArrowWriterBenchmark
         [Params(10_000, 1_000_000)]
         public int BatchLength{ get; set; }
 
-        //Max column set count is 21 before reaching 2gb limit of memory stream
-        [Params(10, 20)]
+        //Max column set count is 15 before reaching 2gb limit of memory stream
+        [Params(10, 14)]
         public int ColumnSetCount { get; set; }
 
         private MemoryStream _memoryStream;
diff --git a/csharp/test/Apache.Arrow.Tests/ArrowReaderVerifier.cs b/csharp/test/Apache.Arrow.Tests/ArrowReaderVerifier.cs
index b1c4653e908a..78f51a7459c0 100644
--- a/csharp/test/Apache.Arrow.Tests/ArrowReaderVerifier.cs
+++ b/csharp/test/Apache.Arrow.Tests/ArrowReaderVerifier.cs
@@ -18,6 +18,7 @@
 using System;
 using System.Linq;
 using System.Threading.Tasks;
+using Apache.Arrow.Arrays;
 using Xunit;
 
 namespace Apache.Arrow.Tests
@@ -77,7 +78,9 @@ private class ArrayComparer :
             IArrowArrayVisitor<ListArray>,
             IArrowArrayVisitor<StringArray>,
             IArrowArrayVisitor<BinaryArray>,
-            IArrowArrayVisitor<StructArray>
+            IArrowArrayVisitor<StructArray>,
+            IArrowArrayVisitor<Decimal128Array>,
+            IArrowArrayVisitor<Decimal256Array>
         {
             private readonly IArrowArray _expectedArray;
             private readonly ArrayTypeComparer _arrayTypeComparer;
@@ -103,7 +106,8 @@ public ArrayComparer(IArrowArray expectedArray)
             public void Visit(Date32Array array) => CompareArrays(array);
             public void Visit(Date64Array array) => CompareArrays(array);
             public void Visit(ListArray array) => CompareArrays(array);
-
+            public void Visit(Decimal128Array array) => CompareArrays(array);
+            public void Visit(Decimal256Array array) => CompareArrays(array);
             public void Visit(StringArray array) => CompareBinaryArrays<StringArray>(array);
 
             public void Visit(BinaryArray array) => CompareBinaryArrays<BinaryArray>(array);
@@ -147,6 +151,23 @@ private void CompareBinaryArrays<T>(BinaryArray actualArray)
                 Assert.True(expectedArray.Values.Slice(0, expectedArray.Length).SequenceEqual(actualArray.Values.Slice(0, actualArray.Length)));
             }
 
+            private void CompareArrays(FixedSizeBinaryArray actualArray)
+            {
+                Assert.IsAssignableFrom<FixedSizeBinaryArray>(_expectedArray);
+                Assert.IsAssignableFrom<FixedSizeBinaryArray>(actualArray);
+
+                var expectedArray = (FixedSizeBinaryArray)_expectedArray;
+
+                actualArray.Data.DataType.Accept(_arrayTypeComparer);
+
+                Assert.Equal(expectedArray.Length, actualArray.Length);
+                Assert.Equal(expectedArray.NullCount, actualArray.NullCount);
+                Assert.Equal(expectedArray.Offset, actualArray.Offset);
+
+                Assert.True(expectedArray.NullBitmapBuffer.Span.SequenceEqual(actualArray.NullBitmapBuffer.Span));
+                Assert.True(expectedArray.ValueBuffer.Span.Slice(0, expectedArray.Length).SequenceEqual(actualArray.ValueBuffer.Span.Slice(0, actualArray.Length)));
+            }
+
             private void CompareArrays<T>(PrimitiveArray<T> actualArray)
                 where T : struct, IEquatable<T>
             {
diff --git a/csharp/test/Apache.Arrow.Tests/Decimal128ArrayTests.cs b/csharp/test/Apache.Arrow.Tests/Decimal128ArrayTests.cs
new file mode 100644
index 000000000000..68f8ee02b120
--- /dev/null
+++ b/csharp/test/Apache.Arrow.Tests/Decimal128ArrayTests.cs
@@ -0,0 +1,241 @@
+﻿// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements. See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+using System;
+using System.Collections.Generic;
+using Apache.Arrow.Types;
+using Xunit;
+
+namespace Apache.Arrow.Tests
+{
+    public class Decimal128ArrayTests
+    {
+        public class Builder
+        {
+            public class AppendNull
+            {
+                [Fact]
+                public void AppendThenGetGivesNull()
+                {
+                    // Arrange
+                    var builder = new Decimal128Array.Builder(new Decimal128Type(8,2));
+
+                    // Act
+
+                    builder = builder.AppendNull();
+                    builder = builder.AppendNull();
+                    builder = builder.AppendNull();
+                    // Assert
+                    var array = builder.Build();
+
+                    Assert.Equal(3, array.Length);
+                    Assert.Equal(array.Data.Buffers[1].Length, array.ByteWidth * 3);
+                    Assert.Null(array.GetValue(0));
+                    Assert.Null(array.GetValue(1));
+                    Assert.Null(array.GetValue(2));
+                }
+            }
+
+            public class Append
+            {
+                [Theory]
+                [InlineData(200)]
+                public void AppendDecimal(int count)
+                {
+                    // Arrange
+                    var builder = new Decimal128Array.Builder(new Decimal128Type(14, 10));
+
+                    // Act
+                    decimal?[] testData = new decimal?[count];
+                    for (int i = 0; i < count; i++)
+                    {
+                        if (i == count - 2)
+                        {
+                            builder.AppendNull();
+                            testData[i] = null;
+                            continue;
+                        }
+                        decimal rnd = i * (decimal)Math.Round(new Random().NextDouble(),10);
+                        testData[i] = rnd;
+                        builder.Append(rnd);
+                    }
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Equal(count, array.Length);
+                    for (int i = 0; i < count; i++)
+                    {
+                        Assert.Equal(testData[i], array.GetValue(i));
+                    }
+                }
+
+                [Fact]
+                public void AppendLargeDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal128Array.Builder(new Decimal128Type(26, 2));
+                    decimal large = 999999999999909999999999.80M;
+                    // Act
+                    builder.Append(large);
+                    builder.Append(-large);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Equal(large, array.GetValue(0));
+                    Assert.Equal(-large, array.GetValue(1));
+                }
+
+                [Fact]
+                public void AppendFractionalDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal128Array.Builder(new Decimal128Type(26, 20));
+                    decimal fraction = 0.99999999999990999992M;
+                    // Act
+                    builder.Append(fraction);
+                    builder.Append(-fraction);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Equal(fraction, array.GetValue(0));
+                    Assert.Equal(-fraction, array.GetValue(1));
+                }
+
+                [Fact]
+                public void AppendRangeDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal128Array.Builder(new Decimal128Type(24, 8));
+                    var range = new decimal[] {2.123M, 1.5984M, -0.0000001M, 9878987987987987.1235407M};
+
+                    // Act
+                    builder.AppendRange(range);
+                    builder.AppendNull();
+
+                    // Assert
+                    var array = builder.Build();
+                    for(int i = 0; i < range.Length; i ++)
+                    {
+                        Assert.Equal(range[i], array.GetValue(i));
+                    }
+                    
+                    Assert.Null( array.GetValue(range.Length));
+                }
+
+                [Fact]
+                public void AppendClearAppendDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal128Array.Builder(new Decimal128Type(24, 8));
+                    
+                    // Act
+                    builder.Append(1);
+                    builder.Clear();
+                    builder.Append(10);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Equal(10, array.GetValue(0));
+                }
+
+                [Fact]
+                public void AppendInvalidPrecisionAndScaleDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal128Array.Builder(new Decimal128Type(2, 1));
+
+                    // Assert
+                    Assert.Throws<OverflowException>(() => builder.Append(100));
+                    Assert.Throws<OverflowException>(() => builder.Append(0.01M));
+                    builder.Append(-9.9M);
+                    builder.Append(0);
+                    builder.Append(9.9M);
+                }
+            }
+
+            public class Set
+            {
+                [Fact]
+                public void SetDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal128Array.Builder(new Decimal128Type(24, 8))
+                        .Resize(1);
+
+                    // Act
+                    builder.Set(0, 50.123456M);
+                    builder.Set(0, 1.01M);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Equal(1.01M, array.GetValue(0));
+                }
+
+                [Fact]
+                public void SetNull()
+                {
+                    // Arrange
+                    var builder = new Decimal128Array.Builder(new Decimal128Type(24, 8))
+                        .Resize(1);
+
+                    // Act
+                    builder.Set(0, 50.123456M);
+                    builder.SetNull(0);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Null(array.GetValue(0));
+                }
+            }
+
+            public class Swap
+            {
+                [Fact]
+                public void SetDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal128Array.Builder(new Decimal128Type(24, 8));
+
+                    // Act
+                    builder.Append(123.45M);
+                    builder.Append(678.9M);
+                    builder.Swap(0, 1);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Equal(678.9M, array.GetValue(0));
+                    Assert.Equal(123.45M, array.GetValue(1));
+                }
+
+                [Fact]
+                public void SwapNull()
+                {
+                    // Arrange
+                    var builder = new Decimal128Array.Builder(new Decimal128Type(24, 8));
+
+                    // Act
+                    builder.Append(123.456M);
+                    builder.AppendNull();
+                    builder.Swap(0, 1);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Null(array.GetValue(0));
+                    Assert.Equal(123.456M, array.GetValue(1));
+                }
+            }
+        }
+    }
+}
diff --git a/csharp/test/Apache.Arrow.Tests/Decimal256ArrayTests.cs b/csharp/test/Apache.Arrow.Tests/Decimal256ArrayTests.cs
new file mode 100644
index 000000000000..35b68823d954
--- /dev/null
+++ b/csharp/test/Apache.Arrow.Tests/Decimal256ArrayTests.cs
@@ -0,0 +1,241 @@
+﻿// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements. See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+using System;
+using System.Collections.Generic;
+using Apache.Arrow.Types;
+using Xunit;
+
+namespace Apache.Arrow.Tests
+{
+    public class Decimal256ArrayTests
+    {
+        public class Builder
+        {
+            public class AppendNull
+            {
+                [Fact]
+                public void AppendThenGetGivesNull()
+                {
+                    // Arrange
+                    var builder = new Decimal256Array.Builder(new Decimal256Type(8,2));
+
+                    // Act
+
+                    builder = builder.AppendNull();
+                    builder = builder.AppendNull();
+                    builder = builder.AppendNull();
+                    // Assert
+                    var array = builder.Build();
+
+                    Assert.Equal(3, array.Length);
+                    Assert.Equal(array.Data.Buffers[1].Length, array.ByteWidth * 3);
+                    Assert.Null(array.GetValue(0));
+                    Assert.Null(array.GetValue(1));
+                    Assert.Null(array.GetValue(2));
+                }
+            }
+
+            public class Append
+            {
+                [Theory]
+                [InlineData(200)]
+                public void AppendDecimal(int count)
+                {
+                    // Arrange
+                    var builder = new Decimal256Array.Builder(new Decimal256Type(14, 10));
+
+                    // Act
+                    decimal?[] testData = new decimal?[count];
+                    for (int i = 0; i < count; i++)
+                    {
+                        if (i == count - 2)
+                        {
+                            builder.AppendNull();
+                            testData[i] = null;
+                            continue;
+                        }
+                        decimal rnd = i * (decimal)Math.Round(new Random().NextDouble(),10);
+                        testData[i] = rnd;
+                        builder.Append(rnd);
+                    }
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Equal(count, array.Length);
+                    for (int i = 0; i < count; i++)
+                    {
+                        Assert.Equal(testData[i], array.GetValue(i));
+                    }
+                }
+
+                [Fact]
+                public void AppendLargeDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal256Array.Builder(new Decimal256Type(26, 2));
+                    decimal large = 999999999999909999999999.80M;
+                    // Act
+                    builder.Append(large);
+                    builder.Append(-large);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Equal(large, array.GetValue(0));
+                    Assert.Equal(-large, array.GetValue(1));
+                }
+
+                [Fact]
+                public void AppendFractionalDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal256Array.Builder(new Decimal256Type(26, 20));
+                    decimal fraction = 0.99999999999990999992M;
+                    // Act
+                    builder.Append(fraction);
+                    builder.Append(-fraction);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Equal(fraction, array.GetValue(0));
+                    Assert.Equal(-fraction, array.GetValue(1));
+                }
+
+                [Fact]
+                public void AppendRangeDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal256Array.Builder(new Decimal256Type(24, 8));
+                    var range = new decimal[] {2.123M, 1.5984M, -0.0000001M, 9878987987987987.1235407M};
+
+                    // Act
+                    builder.AppendRange(range);
+                    builder.AppendNull();
+
+                    // Assert
+                    var array = builder.Build();
+                    for(int i = 0; i < range.Length; i ++)
+                    {
+                        Assert.Equal(range[i], array.GetValue(i));
+                    }
+                    
+                    Assert.Null( array.GetValue(range.Length));
+                }
+
+                [Fact]
+                public void AppendClearAppendDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal256Array.Builder(new Decimal256Type(24, 8));
+                    
+                    // Act
+                    builder.Append(1);
+                    builder.Clear();
+                    builder.Append(10);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Equal(10, array.GetValue(0));
+                }
+
+                [Fact]
+                public void AppendInvalidPrecisionAndScaleDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal256Array.Builder(new Decimal256Type(2, 1));
+
+                    // Assert
+                    Assert.Throws<OverflowException>(() => builder.Append(100));
+                    Assert.Throws<OverflowException>(() => builder.Append(0.01M));
+                    builder.Append(-9.9M);
+                    builder.Append(0);
+                    builder.Append(9.9M);
+                }
+            }
+
+            public class Set
+            {
+                [Fact]
+                public void SetDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal256Array.Builder(new Decimal256Type(24, 8))
+                        .Resize(1);
+                    
+                    // Act
+                    builder.Set(0, 50.123456M);
+                    builder.Set(0, 1.01M);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Equal(1.01M, array.GetValue(0));
+                }
+
+                [Fact]
+                public void SetNull()
+                {
+                    // Arrange
+                    var builder = new Decimal256Array.Builder(new Decimal256Type(24, 8))
+                        .Resize(1);
+
+                    // Act
+                    builder.Set(0, 50.123456M);
+                    builder.SetNull(0);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Null(array.GetValue(0));
+                }
+            }
+
+            public class Swap
+            {
+                [Fact]
+                public void SetDecimal()
+                {
+                    // Arrange
+                    var builder = new Decimal256Array.Builder(new Decimal256Type(24, 8));
+
+                    // Act
+                    builder.Append(123.45M);
+                    builder.Append(678.9M);
+                    builder.Swap(0, 1);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Equal(678.9M, array.GetValue(0));
+                    Assert.Equal(123.45M, array.GetValue(1));
+                }
+
+                [Fact]
+                public void SwapNull()
+                {
+                    // Arrange
+                    var builder = new Decimal256Array.Builder(new Decimal256Type(24, 8));
+
+                    // Act
+                    builder.Append(123.456M);
+                    builder.AppendNull();
+                    builder.Swap(0, 1);
+
+                    // Assert
+                    var array = builder.Build();
+                    Assert.Null(array.GetValue(0));
+                    Assert.Equal(123.456M, array.GetValue(1));
+                }
+            }
+        }
+    }
+}
diff --git a/csharp/test/Apache.Arrow.Tests/DecimalUtilityTests.cs b/csharp/test/Apache.Arrow.Tests/DecimalUtilityTests.cs
new file mode 100644
index 000000000000..d235524d9110
--- /dev/null
+++ b/csharp/test/Apache.Arrow.Tests/DecimalUtilityTests.cs
@@ -0,0 +1,51 @@
+﻿// Licensed to the Apache Software Foundation (ASF) under one or more
+// contributor license agreements. See the NOTICE file distributed with
+// this work for additional information regarding copyright ownership.
+// The ASF licenses this file to You under the Apache License, Version 2.0
+// (the "License"); you may not use this file except in compliance with
+// the License.  You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+using System;
+using Apache.Arrow.Types;
+using Xunit;
+
+namespace Apache.Arrow.Tests
+{
+    public class DecimalUtilityTests
+    {
+        public class Overflow
+        {
+            [Theory]
+            [InlineData(100.123, 10, 4, false)]
+            [InlineData(100.123, 6, 4, false)]
+            [InlineData(100.123, 3, 3, true)]
+            [InlineData(100.123, 10, 2, true)]
+            [InlineData(100.123, 5, 2, true)]
+            [InlineData(100.123, 5, 3, true)]
+            [InlineData(100.123, 6, 3, false)]
+            public void HasExpectedResultOrThrows(decimal d, int precision , int scale, bool shouldThrow)
+            {
+                var builder = new Decimal128Array.Builder(new Decimal128Type(precision, scale));
+
+                if (shouldThrow)
+                {
+                   Assert.Throws<OverflowException>(() => builder.Append(d));
+                }
+                else
+                {
+                    builder.Append(d);
+                    var result = builder.Build(new TestMemoryAllocator());
+                    Assert.Equal(d, result.GetValue(0));
+                }
+            }
+        }
+    }
+}
diff --git a/csharp/test/Apache.Arrow.Tests/TestData.cs b/csharp/test/Apache.Arrow.Tests/TestData.cs
index 5688c6260d98..8db2241ff891 100644
--- a/csharp/test/Apache.Arrow.Tests/TestData.cs
+++ b/csharp/test/Apache.Arrow.Tests/TestData.cs
@@ -48,8 +48,9 @@ public static RecordBatch CreateSampleRecordBatch(int length, int columnSetCount
                 builder.Field(CreateField(TimestampType.Default, i));
                 builder.Field(CreateField(StringType.Default, i));
                 builder.Field(CreateField(new StructType(new List<Field> { CreateField(StringType.Default, i), CreateField(Int32Type.Default, i) }), i));
+                builder.Field(CreateField(new Decimal128Type(10, 6), i));
+                builder.Field(CreateField(new Decimal256Type(16, 8), i));
                 //builder.Field(CreateField(new FixedSizeBinaryType(16), i));
-                //builder.Field(CreateField(new DecimalType(19, 2)));
                 //builder.Field(CreateField(HalfFloatType.Default));
                 //builder.Field(CreateField(StringType.Default));
                 //builder.Field(CreateField(Time32Type.Default));
@@ -111,7 +112,9 @@ private class ArrayCreator :
             IArrowTypeVisitor<TimestampType>,
             IArrowTypeVisitor<StringType>,
             IArrowTypeVisitor<ListType>,
-            IArrowTypeVisitor<StructType>
+            IArrowTypeVisitor<StructType>,
+            IArrowTypeVisitor<Decimal128Type>,
+            IArrowTypeVisitor<Decimal256Type>
         {
             private int Length { get; }
             public IArrowArray Array { get; private set; }
@@ -132,6 +135,29 @@ public ArrayCreator(int length)
             public void Visit(UInt64Type type) => GenerateArray(new UInt64Array.Builder(), x => (ulong)x);
             public void Visit(FloatType type) => GenerateArray(new FloatArray.Builder(), x => ((float)x / Length));
             public void Visit(DoubleType type) => GenerateArray(new DoubleArray.Builder(), x => ((double)x / Length));
+            public void Visit(Decimal128Type type)
+            {
+                var builder = new Decimal128Array.Builder(type).Reserve(Length);
+
+                for (var i = 0; i < Length; i++)
+                {
+                    builder.Append((decimal)i / Length);
+                }
+
+                Array = builder.Build();
+            }
+
+            public void Visit(Decimal256Type type)
+            {
+                var builder = new Decimal256Array.Builder(type).Reserve(Length);
+
+                for (var i = 0; i < Length; i++)
+                {
+                    builder.Append((decimal)i / Length);
+                }
+
+                Array = builder.Build();
+            }
 
             public void Visit(Date32Type type)
             {
diff --git a/docs/source/status.rst b/docs/source/status.rst
index 89afd61d1391..22a7a86bfb8d 100644
--- a/docs/source/status.rst
+++ b/docs/source/status.rst
@@ -42,9 +42,9 @@ Data Types
 +-------------------+-------+-------+-------+------------+-------+-------+-------+
 | Float32/64        | ✓     | ✓     | ✓     | ✓          |  ✓    |  ✓    | ✓     |
 +-------------------+-------+-------+-------+------------+-------+-------+-------+
-| Decimal128        | ✓     | ✓     |       |            |       |  ✓    | ✓     |
+| Decimal128        | ✓     | ✓     |       |            |  ✓    |  ✓    | ✓     |
 +-------------------+-------+-------+-------+------------+-------+-------+-------+
-| Decimal256        | ✓     | ✓     |       |            |       |       | ✓     |
+| Decimal256        | ✓     | ✓     |       |            |  ✓    |       | ✓     |
 +-------------------+-------+-------+-------+------------+-------+-------+-------+
 | Date32/64         | ✓     | ✓     | ✓     | ✓          |  ✓    |  ✓    | ✓     |
 +-------------------+-------+-------+-------+------------+-------+-------+-------+
