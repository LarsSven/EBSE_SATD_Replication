diff --git a/cpp/src/plasma/CMakeLists.txt b/cpp/src/plasma/CMakeLists.txt
new file mode 100644
index 000000000000..a36089b86686
--- /dev/null
+++ b/cpp/src/plasma/CMakeLists.txt
@@ -0,0 +1,114 @@
+cmake_minimum_required(VERSION 2.8)
+
+project(plasma)
+
+add_subdirectory(${CMAKE_CURRENT_LIST_DIR}/common/)
+
+# Recursively include common
+include(${CMAKE_CURRENT_LIST_DIR}/cmake/Common.cmake)
+
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+
+if(APPLE)
+  SET(CMAKE_SHARED_LIBRARY_SUFFIX ".so")
+endif(APPLE)
+
+include_directories("${PYTHON_INCLUDE_DIRS}" thirdparty)
+
+set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} --std=c99 -D_XOPEN_SOURCE=500 -D_POSIX_C_SOURCE=200809L")
+
+# Compile flatbuffers
+
+set(PLASMA_FBS_SRC "${CMAKE_CURRENT_LIST_DIR}/format/plasma.fbs")
+set(OUTPUT_DIR ${CMAKE_CURRENT_LIST_DIR}/format/)
+
+add_custom_target(gen_plasma_fbs ALL)
+
+add_custom_command(
+  TARGET gen_plasma_fbs
+  # The --gen-object-api flag generates a C++ class MessageT for each
+  # flatbuffers message Message, which can be used to store deserialized
+  # messages in data structures. This is currently used for ObjectInfo for
+  # example.
+  COMMAND ${FLATBUFFERS_COMPILER} -c -o ${OUTPUT_DIR} ${PLASMA_FBS_SRC} --gen-object-api
+  DEPENDS ${PLASMA_FBS_SRC}
+  COMMENT "Running flatc compiler on ${PLASMA_FBS_SRC}"
+  VERBATIM
+)
+
+add_dependencies(gen_plasma_fbs flatbuffers_ep)
+
+if(UNIX AND NOT APPLE)
+  link_libraries(rt)
+endif()
+
+include_directories("${CMAKE_CURRENT_LIST_DIR}/")
+include_directories("${CMAKE_CURRENT_LIST_DIR}/common")
+include_directories("${CMAKE_CURRENT_LIST_DIR}/common/thirdparty")
+
+add_library(plasma SHARED
+  plasma.cc
+  plasma_extension.cc
+  plasma_protocol.cc
+  plasma_client.cc
+  thirdparty/xxhash.c
+  fling.c)
+
+add_dependencies(plasma gen_plasma_fbs)
+
+get_filename_component(PYTHON_SHARED_LIBRARY ${PYTHON_LIBRARIES} NAME)
+if(APPLE)
+  add_custom_command(TARGET plasma
+                     POST_BUILD COMMAND ${CMAKE_INSTALL_NAME_TOOL} -change ${PYTHON_SHARED_LIBRARY} ${PYTHON_LIBRARIES} libplasma.so)
+endif(APPLE)
+
+if(APPLE)
+  target_link_libraries(plasma -Wl,-force_load,${FLATBUFFERS_STATIC_LIB} common ${PYTHON_LIBRARIES} ${FLATBUFFERS_STATIC_LIB} -lpthread)
+else(APPLE)
+  target_link_libraries(plasma -Wl,--whole-archive ${FLATBUFFERS_STATIC_LIB} -Wl,--no-whole-archive common ${PYTHON_LIBRARIES} ${FLATBUFFERS_STATIC_LIB} -lpthread)
+endif(APPLE)
+
+include_directories("${FLATBUFFERS_INCLUDE_DIR}")
+
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
+
+set_source_files_properties(thirdparty/dlmalloc.c PROPERTIES COMPILE_FLAGS -Wno-all)
+
+add_executable(plasma_store
+  plasma_store.cc
+  plasma.cc
+  plasma_protocol.cc
+  eviction_policy.cc
+  fling.c
+  malloc.c)
+
+add_dependencies(plasma_store hiredis gen_plasma_fbs)
+
+target_link_libraries(plasma_store common ${FLATBUFFERS_STATIC_LIB})
+
+add_library(plasma_lib STATIC
+  plasma_client.cc
+  plasma.cc
+  plasma_protocol.cc
+  fling.c
+  thirdparty/xxhash.c)
+
+target_link_libraries(plasma_lib common ${FLATBUFFERS_STATIC_LIB} -lpthread)
+add_dependencies(plasma_lib gen_plasma_fbs)
+
+add_dependencies(plasma protocol_fbs)
+
+add_library(plasma_client SHARED plasma_client.cc)
+target_link_libraries(plasma_client ${FLATBUFFERS_STATIC_LIB})
+
+target_link_libraries(plasma_client common plasma_lib ${FLATBUFFERS_STATIC_LIB})
+
+function(define_test test_name library)
+  add_executable(${test_name} test/${test_name}.cc ${ARGN})
+  add_dependencies(${test_name} hiredis flatbuffers_ep)
+  target_link_libraries(${test_name} common ${FLATBUFFERS_STATIC_LIB} ${library})
+  target_compile_options(${test_name} PUBLIC "-DPLASMA_TEST -DLOCAL_SCHEDULER_TEST -DCOMMON_TEST -DRAY_COMMON_LOG_LEVEL=4 -DRAY_TIMEOUT=50")
+endfunction()
+
+define_test(client_tests plasma_lib)
+define_test(serialization_tests plasma_lib)
diff --git a/cpp/src/plasma/cmake/Common.cmake b/cpp/src/plasma/cmake/Common.cmake
new file mode 100644
index 000000000000..05dc9d79b9c7
--- /dev/null
+++ b/cpp/src/plasma/cmake/Common.cmake
@@ -0,0 +1,93 @@
+# Code for compiling flatbuffers
+
+include(ExternalProject)
+include(CMakeParseArguments)
+
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11")
+
+set(FLATBUFFERS_VERSION "1.6.0")
+
+set(FLATBUFFERS_PREFIX "${CMAKE_BINARY_DIR}/flatbuffers_ep-prefix/src/flatbuffers_ep-install")
+if (NOT TARGET flatbuffers_ep)
+  ExternalProject_Add(flatbuffers_ep
+    URL "https://github.com/google/flatbuffers/archive/v${FLATBUFFERS_VERSION}.tar.gz"
+    CMAKE_ARGS
+      "-DCMAKE_CXX_FLAGS=-fPIC"
+      "-DCMAKE_INSTALL_PREFIX:PATH=${FLATBUFFERS_PREFIX}"
+      "-DFLATBUFFERS_BUILD_TESTS=OFF")
+endif()
+
+set(FLATBUFFERS_INCLUDE_DIR "${FLATBUFFERS_PREFIX}/include")
+set(FLATBUFFERS_STATIC_LIB "${FLATBUFFERS_PREFIX}/lib/libflatbuffers.a")
+set(FLATBUFFERS_COMPILER "${FLATBUFFERS_PREFIX}/bin/flatc")
+
+message(STATUS "Flatbuffers include dir: ${FLATBUFFERS_INCLUDE_DIR}")
+message(STATUS "Flatbuffers static library: ${FLATBUFFERS_STATIC_LIB}")
+message(STATUS "Flatbuffers compiler: ${FLATBUFFERS_COMPILER}")
+include_directories(SYSTEM ${FLATBUFFERS_INCLUDE_DIR})
+
+# Custom CFLAGS
+
+set(CMAKE_C_FLAGS "-g -Wall -Wextra -Werror=implicit-function-declaration -Wno-sign-compare -Wno-unused-parameter -Wno-type-limits -Wno-missing-field-initializers --std=c99 -D_XOPEN_SOURCE=500 -D_POSIX_C_SOURCE=200809L -fPIC -std=c99")
+
+# Code for finding Python
+
+message(STATUS "Trying custom approach for finding Python.")
+# Start off by figuring out which Python executable to use.
+find_program(CUSTOM_PYTHON_EXECUTABLE python)
+message(STATUS "Found Python program: ${CUSTOM_PYTHON_EXECUTABLE}")
+execute_process(COMMAND ${CUSTOM_PYTHON_EXECUTABLE} -c "import sys; print('python' + sys.version[0:3])"
+                OUTPUT_VARIABLE PYTHON_LIBRARY_NAME OUTPUT_STRIP_TRAILING_WHITESPACE)
+message(STATUS "PYTHON_LIBRARY_NAME: " ${PYTHON_LIBRARY_NAME})
+# Now find the Python include directories.
+execute_process(COMMAND ${CUSTOM_PYTHON_EXECUTABLE} -c "from distutils.sysconfig import *; print(get_python_inc())"
+                OUTPUT_VARIABLE PYTHON_INCLUDE_DIRS OUTPUT_STRIP_TRAILING_WHITESPACE)
+message(STATUS "PYTHON_INCLUDE_DIRS: " ${PYTHON_INCLUDE_DIRS})
+# Now find the Python libraries. We'll start by looking near the Python
+# executable. If that fails, then we'll look near the Python include
+# directories.
+execute_process(COMMAND ${CUSTOM_PYTHON_EXECUTABLE} -c "import sys; print(sys.exec_prefix)"
+                OUTPUT_VARIABLE PYTHON_PREFIX OUTPUT_STRIP_TRAILING_WHITESPACE)
+message(STATUS "PYTHON_PREFIX: " ${PYTHON_PREFIX})
+# The name ending in "m" is for miniconda.
+FIND_LIBRARY(PYTHON_LIBRARIES
+             NAMES "${PYTHON_LIBRARY_NAME}" "${PYTHON_LIBRARY_NAME}m"
+             HINTS "${PYTHON_PREFIX}"
+             PATH_SUFFIXES "lib" "libs"
+             NO_DEFAULT_PATH)
+message(STATUS "PYTHON_LIBRARIES: " ${PYTHON_LIBRARIES})
+# If that failed, perhaps because the user is in a virtualenv, search around
+# the Python include directories.
+if(NOT PYTHON_LIBRARIES)
+  message(STATUS "Failed to find PYTHON_LIBRARIES near the Python executable, so now looking near the Python include directories.")
+  # The name ending in "m" is for miniconda.
+  FIND_LIBRARY(PYTHON_LIBRARIES
+               NAMES "${PYTHON_LIBRARY_NAME}" "${PYTHON_LIBRARY_NAME}m"
+               HINTS "${PYTHON_INCLUDE_DIRS}/../.."
+               PATH_SUFFIXES "lib" "libs"
+               NO_DEFAULT_PATH)
+  message(STATUS "PYTHON_LIBRARIES: " ${PYTHON_LIBRARIES})
+endif()
+# If we found the Python libraries and the include directories, then continue
+# on. If not, then try find_package as a last resort, but it probably won't
+# work.
+if(PYTHON_LIBRARIES AND PYTHON_INCLUDE_DIRS)
+  message(STATUS "The custom approach for finding Python succeeded.")
+  SET(PYTHONLIBS_FOUND TRUE)
+else()
+  message(WARNING "The custom approach for finding Python failed. Defaulting to find_package.")
+  find_package(PythonInterp REQUIRED)
+  find_package(PythonLibs ${PYTHON_VERSION_STRING} EXACT REQUIRED)
+  set(CUSTOM_PYTHON_EXECUTABLE ${PYTHON_EXECUTABLE})
+endif()
+
+message(STATUS "Using CUSTOM_PYTHON_EXECUTABLE: " ${CUSTOM_PYTHON_EXECUTABLE})
+message(STATUS "Using PYTHON_LIBRARIES: " ${PYTHON_LIBRARIES})
+message(STATUS "Using PYTHON_INCLUDE_DIRS: " ${PYTHON_INCLUDE_DIRS})
+
+# Common libraries
+
+set(COMMON_LIB "${CMAKE_BINARY_DIR}/src/common/libcommon.a"
+    CACHE STRING "Path to libcommon.a")
+
+include_directories("${CMAKE_CURRENT_LIST_DIR}/../..")
diff --git a/cpp/src/plasma/common/CMakeLists.txt b/cpp/src/plasma/common/CMakeLists.txt
new file mode 100644
index 000000000000..1b529493d49e
--- /dev/null
+++ b/cpp/src/plasma/common/CMakeLists.txt
@@ -0,0 +1,26 @@
+cmake_minimum_required(VERSION 2.8)
+
+project(common)
+
+include(${CMAKE_CURRENT_LIST_DIR}/../cmake/Common.cmake)
+
+set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")
+
+include_directories(.)
+include_directories(thirdparty)
+
+add_library(common STATIC
+  event_loop.cc
+  common.cc
+  io.cc
+  thirdparty/ae/ae.c
+  thirdparty/sha256.c)
+
+function(define_test test_name library)
+  add_executable(${test_name} test/${test_name}.cc ${ARGN})
+  add_dependencies(${test_name} hiredis flatbuffers_ep)
+  target_link_libraries(${test_name} common ${FLATBUFFERS_STATIC_LIB} ${library})
+  target_compile_options(${test_name} PUBLIC "-DPLASMA_TEST -DLOCAL_SCHEDULER_TEST -DCOMMON_TEST -DRAY_COMMON_LOG_LEVEL=4 -DRAY_TIMEOUT=50")
+endfunction()
+
+define_test(common_tests "")
diff --git a/cpp/src/plasma/common/common.cc b/cpp/src/plasma/common/common.cc
new file mode 100644
index 000000000000..a9224795a8b8
--- /dev/null
+++ b/cpp/src/plasma/common/common.cc
@@ -0,0 +1,55 @@
+#include "common.h"
+
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "io.h"
+
+/* This is used to define the array of object IDs. */
+const UT_icd object_id_icd = {sizeof(ObjectID), NULL, NULL, NULL};
+
+const UniqueID NIL_ID = {{255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
+                          255, 255, 255, 255, 255, 255, 255, 255, 255, 255}};
+
+const unsigned char NIL_DIGEST[DIGEST_SIZE] = {0};
+
+UniqueID globally_unique_id(void) {
+  /* Use /dev/urandom for "real" randomness. */
+  int fd;
+  int const flags = 0 /* for Windows compatibility */;
+  if ((fd = open("/dev/urandom", O_RDONLY, flags)) == -1) {
+    ARROW_LOG(ERROR) << "Could not generate random number";
+  }
+  UniqueID result;
+  if(read_bytes(fd, &result.id[0], UNIQUE_ID_SIZE) < 0) {
+    ARROW_LOG(FATAL) << "read_bytes failed";
+  }
+  close(fd);
+  return result;
+}
+
+bool ObjectID_equal(ObjectID first_id, ObjectID second_id) {
+  return UNIQUE_ID_EQ(first_id, second_id);
+}
+
+bool ObjectID_is_nil(ObjectID id) {
+  return ObjectID_equal(id, NIL_OBJECT_ID);
+}
+
+char *ObjectID_to_string(ObjectID obj_id, char *id_string, int id_length) {
+  DCHECK(id_length >= ID_STRING_SIZE);
+  static const char hex[] = "0123456789abcdef";
+  char *buf = id_string;
+
+  for (int i = 0; i < UNIQUE_ID_SIZE; i++) {
+    unsigned int val = obj_id.id[i];
+    *buf++ = hex[val >> 4];
+    *buf++ = hex[val & 0xf];
+  }
+  *buf = '\0';
+
+  return id_string;
+}
diff --git a/cpp/src/plasma/common/common.h b/cpp/src/plasma/common/common.h
new file mode 100644
index 000000000000..6238ef8be5c0
--- /dev/null
+++ b/cpp/src/plasma/common/common.h
@@ -0,0 +1,104 @@
+#ifndef COMMON_H
+#define COMMON_H
+
+#include <stdbool.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <inttypes.h>
+#ifndef _WIN32
+#include <execinfo.h>
+#endif
+
+#include "utarray.h"
+#ifdef __cplusplus
+extern "C" {
+#endif
+#include "sha256.h"
+#ifdef __cplusplus
+}
+#endif
+
+#include "arrow/util/logging.h"
+
+/** Assertion definitions, with optional logging. */
+
+#define CHECK_MSG(COND, M, ...)                                \
+  if (!(COND)) {                                               \
+    ARROW_LOG(FATAL) << "Check failure: " << M << " " << #COND " " ##__VA_ARGS__; \
+  }
+
+#define CHECK(COND) CHECK_MSG(COND, "")
+
+/* Arrow defines the same macro, only define it if it has not already been
+ * defined. */
+#ifndef UNUSED
+#define UNUSED(x) ((void) (x))
+#endif
+
+/* These are exit codes for common errors that can occur in Ray components. */
+#define EXIT_COULD_NOT_BIND_PORT -2
+
+/** This macro indicates that this pointer owns the data it is pointing to
+ *  and is responsible for freeing it. */
+#define OWNER
+
+/** Definitions for unique ID types. */
+#define UNIQUE_ID_SIZE 20
+
+#define UNIQUE_ID_EQ(id1, id2) (memcmp((id1).id, (id2).id, UNIQUE_ID_SIZE) == 0)
+
+#define IS_NIL_ID(id) UNIQUE_ID_EQ(id, NIL_ID)
+
+typedef struct { unsigned char id[UNIQUE_ID_SIZE]; } UniqueID;
+
+extern const UT_icd object_id_icd;
+
+extern const UniqueID NIL_ID;
+
+/* Generate a globally unique ID. */
+UniqueID globally_unique_id(void);
+
+#define NIL_OBJECT_ID NIL_ID
+
+typedef UniqueID ObjectID;
+
+#define ID_STRING_SIZE (2 * UNIQUE_ID_SIZE + 1)
+
+/**
+ * Convert an object ID to a hexdecimal string. This function assumes that
+ * buffer points to an already allocated char array of size ID_STRING_SIZE. And
+ * it writes a null-terminated hex-formatted string to id_string.
+ *
+ * @param obj_id The object ID to convert to a string.
+ * @param id_string A buffer to write the string to. It is assumed that this is
+ *        managed by the caller and is sufficiently long to store the object ID
+ *        string.
+ * @param id_length The length of the id_string buffer.
+ */
+char *ObjectID_to_string(ObjectID obj_id, char *id_string, int id_length);
+
+/**
+ * Compare two object IDs.
+ *
+ * @param first_id The first object ID to compare.
+ * @param second_id The first object ID to compare.
+ * @return True if the object IDs are the same and false otherwise.
+ */
+bool ObjectID_equal(ObjectID first_id, ObjectID second_id);
+
+/**
+ * Compare a object ID to the nil ID.
+ *
+ * @param id The object ID to compare to nil.
+ * @return True if the object ID is equal to nil.
+ */
+bool ObjectID_is_nil(ObjectID id);
+
+/** Definitions for computing hash digests. */
+#define DIGEST_SIZE SHA256_BLOCK_SIZE
+
+extern const unsigned char NIL_DIGEST[DIGEST_SIZE];
+
+#endif
diff --git a/cpp/src/plasma/common/event_loop.cc b/cpp/src/plasma/common/event_loop.cc
new file mode 100644
index 000000000000..02db320272f5
--- /dev/null
+++ b/cpp/src/plasma/common/event_loop.cc
@@ -0,0 +1,61 @@
+#include "event_loop.h"
+
+#include "common.h"
+#include <errno.h>
+
+#define INITIAL_EVENT_LOOP_SIZE 1024
+
+event_loop *event_loop_create(void) {
+  return aeCreateEventLoop(INITIAL_EVENT_LOOP_SIZE);
+}
+
+void event_loop_destroy(event_loop *loop) {
+  /* Clean up timer events. This is to make valgrind happy. */
+  aeTimeEvent *te = loop->timeEventHead;
+  while (te) {
+    aeTimeEvent *next = te->next;
+    free(te);
+    te = next;
+  }
+  aeDeleteEventLoop(loop);
+}
+
+void event_loop_add_file(event_loop *loop,
+                         int fd,
+                         int events,
+                         event_loop_file_handler handler,
+                         void *context) {
+  /* Try to add the file descriptor. */
+  int err = aeCreateFileEvent(loop, fd, events, handler, context);
+  /* If it cannot be added, increase the size of the event loop. */
+  if (err == AE_ERR && errno == ERANGE) {
+    err = aeResizeSetSize(loop, 3 * aeGetSetSize(loop) / 2);
+    DCHECK(err == AE_OK);
+    err = aeCreateFileEvent(loop, fd, events, handler, context);
+  }
+  /* In any case, test if there were errors. */
+  DCHECK(err == AE_OK);
+}
+
+void event_loop_remove_file(event_loop *loop, int fd) {
+  aeDeleteFileEvent(loop, fd, EVENT_LOOP_READ | EVENT_LOOP_WRITE);
+}
+
+int64_t event_loop_add_timer(event_loop *loop,
+                             int64_t timeout,
+                             event_loop_timer_handler handler,
+                             void *context) {
+  return aeCreateTimeEvent(loop, timeout, handler, context, NULL);
+}
+
+int event_loop_remove_timer(event_loop *loop, int64_t id) {
+  return aeDeleteTimeEvent(loop, id);
+}
+
+void event_loop_run(event_loop *loop) {
+  aeMain(loop);
+}
+
+void event_loop_stop(event_loop *loop) {
+  aeStop(loop);
+}
diff --git a/cpp/src/plasma/common/event_loop.h b/cpp/src/plasma/common/event_loop.h
new file mode 100644
index 000000000000..90e10a9725cc
--- /dev/null
+++ b/cpp/src/plasma/common/event_loop.h
@@ -0,0 +1,103 @@
+#ifndef EVENT_LOOP_H
+#define EVENT_LOOP_H
+
+#include <stdint.h>
+
+extern "C" {
+#ifdef _WIN32
+/* Quirks mean that Windows version needs to be included differently */
+#include <hiredis/hiredis.h>
+#include <ae.h>
+#else
+#include "ae/ae.h"
+#endif
+}
+
+/* Unique timer ID that will be generated when the timer is added to the
+ * event loop. Will not be reused later on in another call
+ * to event_loop_add_timer. */
+typedef long long timer_id;
+
+typedef aeEventLoop event_loop;
+
+/* File descriptor is readable. */
+#define EVENT_LOOP_READ AE_READABLE
+
+/* File descriptor is writable. */
+#define EVENT_LOOP_WRITE AE_WRITABLE
+
+/* Constant specifying that the timer is done and it will be removed. */
+#define EVENT_LOOP_TIMER_DONE AE_NOMORE
+
+/* Signature of the handler that will be called when there is a new event
+ * on the file descriptor that this handler has been registered for. The
+ * context is the one that was passed into add_file by the user. The
+ * events parameter indicates which event is available on the file,
+ * it can be EVENT_LOOP_READ or EVENT_LOOP_WRITE. */
+typedef void (*event_loop_file_handler)(event_loop *loop,
+                                        int fd,
+                                        void *context,
+                                        int events);
+
+/* This handler will be called when a timer times out. The id of the timer
+ * as well as the context that was specified when registering this handler
+ * are passed as arguments. The return is the number of milliseconds the
+ * timer shall be reset to or EVENT_LOOP_TIMER_DONE if the timer shall
+ * not be triggered again. */
+typedef int (*event_loop_timer_handler)(event_loop *loop,
+                                        timer_id timer_id,
+                                        void *context);
+
+/* Create and return a new event loop. */
+event_loop *event_loop_create(void);
+
+/* Deallocate space associated with the event loop that was created
+ * with the "create" function. */
+void event_loop_destroy(event_loop *loop);
+
+/* Register a handler that will be called any time a new event happens on
+ * a file descriptor. Can specify a context that will be passed as an
+ * argument to the handler. Currently there can only be one handler per file.
+ * The events parameter specifies which events we listen to: EVENT_LOOP_READ
+ * or EVENT_LOOP_WRITE. */
+void event_loop_add_file(event_loop *loop,
+                         int fd,
+                         int events,
+                         event_loop_file_handler handler,
+                         void *context);
+
+/* Remove a registered file event handler from the event loop. */
+void event_loop_remove_file(event_loop *loop, int fd);
+
+/** Register a handler that will be called after a time slice of
+ *  "timeout" milliseconds.
+ *
+ *  @param loop The event loop.
+ *  @param timeout The timeout in milliseconds.
+ *  @param handler The handler for the timeout.
+ *  @param context User context that can be passed in and will be passed in
+ *         as an argument for the timer handler.
+ *  @return The ID of the timer.
+ */
+int64_t event_loop_add_timer(event_loop *loop,
+                             int64_t timeout,
+                             event_loop_timer_handler handler,
+                             void *context);
+
+/**
+ * Remove a registered time event handler from the event loop. Can be called
+ * multiple times on the same timer.
+ *
+ * @param loop The event loop.
+ * @param timer_id The ID of the timer to be removed.
+ * @return Returns 0 if the removal was successful.
+ */
+int event_loop_remove_timer(event_loop *loop, int64_t timer_id);
+
+/* Run the event loop. */
+void event_loop_run(event_loop *loop);
+
+/* Stop the event loop. */
+void event_loop_stop(event_loop *loop);
+
+#endif
diff --git a/cpp/src/plasma/common/io.cc b/cpp/src/plasma/common/io.cc
new file mode 100644
index 000000000000..a27de06673b7
--- /dev/null
+++ b/cpp/src/plasma/common/io.cc
@@ -0,0 +1,383 @@
+#include "io.h"
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <string.h>
+#include <stdio.h>
+#include <inttypes.h>
+#include <stdarg.h>
+#include <sys/ioctl.h>
+#include <netinet/in.h>
+#include <netdb.h>
+
+#include "common.h"
+#include "event_loop.h"
+#include "arrow/util/logging.h"
+
+#ifndef _WIN32
+/* This function is actually not declared in standard POSIX, so declare it. */
+extern int usleep(useconds_t usec);
+#endif
+
+int bind_inet_sock(const int port, bool shall_listen) {
+  struct sockaddr_in name;
+  int socket_fd = socket(PF_INET, SOCK_STREAM, 0);
+  if (socket_fd < 0) {
+    ARROW_LOG(ERROR) << "socket() failed for port " << port;
+    return -1;
+  }
+  name.sin_family = AF_INET;
+  name.sin_port = htons(port);
+  name.sin_addr.s_addr = htonl(INADDR_ANY);
+  int on = 1;
+  /* TODO(pcm): http://stackoverflow.com/q/1150635 */
+  if (ioctl(socket_fd, FIONBIO, (char *) &on) < 0) {
+    ARROW_LOG(ERROR) << "ioctl failed";
+    close(socket_fd);
+    return -1;
+  }
+  int *const pon = (int *const) & on;
+  if (setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, pon, sizeof(on)) < 0) {
+    ARROW_LOG(ERROR) << "setsockopt failed for port " << port;
+    close(socket_fd);
+    return -1;
+  }
+  if (bind(socket_fd, (struct sockaddr *) &name, sizeof(name)) < 0) {
+    ARROW_LOG(ERROR) << "Bind failed for port " << port;
+    close(socket_fd);
+    return -1;
+  }
+  if (shall_listen && listen(socket_fd, 5) == -1) {
+    ARROW_LOG(ERROR) << "Could not listen to socket " << port;
+    close(socket_fd);
+    return -1;
+  }
+  return socket_fd;
+}
+
+int bind_ipc_sock(const char *socket_pathname, bool shall_listen) {
+  struct sockaddr_un socket_address;
+  int socket_fd = socket(AF_UNIX, SOCK_STREAM, 0);
+  if (socket_fd < 0) {
+    ARROW_LOG(ERROR) << "socket() failed for pathname " << socket_pathname;
+    return -1;
+  }
+  /* Tell the system to allow the port to be reused. */
+  int on = 1;
+  if (setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, (char *) &on,
+                 sizeof(on)) < 0) {
+    ARROW_LOG(ERROR) << "setsockopt failed for pathname " << socket_pathname;
+    close(socket_fd);
+    return -1;
+  }
+
+  unlink(socket_pathname);
+  memset(&socket_address, 0, sizeof(socket_address));
+  socket_address.sun_family = AF_UNIX;
+  if (strlen(socket_pathname) + 1 > sizeof(socket_address.sun_path)) {
+    ARROW_LOG(ERROR) << "Socket pathname is too long.";
+    close(socket_fd);
+    return -1;
+  }
+  strncpy(socket_address.sun_path, socket_pathname,
+          strlen(socket_pathname) + 1);
+
+  if (bind(socket_fd, (struct sockaddr *) &socket_address,
+           sizeof(socket_address)) != 0) {
+    ARROW_LOG(ERROR) << "Bind failed for pathname " << socket_pathname;
+    close(socket_fd);
+    return -1;
+  }
+  if (shall_listen && listen(socket_fd, 5) == -1) {
+    ARROW_LOG(ERROR) << "Could not listen to socket " << socket_pathname;
+    close(socket_fd);
+    return -1;
+  }
+  return socket_fd;
+}
+
+int connect_ipc_sock_retry(const char *socket_pathname,
+                           int num_retries,
+                           int64_t timeout) {
+  /* Pick the default values if the user did not specify. */
+  if (num_retries < 0) {
+    num_retries = NUM_CONNECT_ATTEMPTS;
+  }
+  if (timeout < 0) {
+    timeout = CONNECT_TIMEOUT_MS;
+  }
+
+  DCHECK(socket_pathname);
+  int fd = -1;
+  for (int num_attempts = 0; num_attempts < num_retries; ++num_attempts) {
+    fd = connect_ipc_sock(socket_pathname);
+    if (fd >= 0) {
+      break;
+    }
+    if (num_attempts == 0) {
+      ARROW_LOG(ERROR) << "Connection to socket failed for pathname " << socket_pathname;
+    }
+    /* Sleep for timeout milliseconds. */
+    usleep(timeout * 1000);
+  }
+  /* If we could not connect to the socket, exit. */
+  if (fd == -1) {
+    ARROW_LOG(FATAL) << "Could not connect to socket " << socket_pathname;
+  }
+  return fd;
+}
+
+int connect_ipc_sock(const char *socket_pathname) {
+  struct sockaddr_un socket_address;
+  int socket_fd;
+
+  socket_fd = socket(AF_UNIX, SOCK_STREAM, 0);
+  if (socket_fd < 0) {
+    ARROW_LOG(ERROR) << "socket() failed for pathname " << socket_pathname;
+    return -1;
+  }
+
+  memset(&socket_address, 0, sizeof(socket_address));
+  socket_address.sun_family = AF_UNIX;
+  if (strlen(socket_pathname) + 1 > sizeof(socket_address.sun_path)) {
+    ARROW_LOG(ERROR) << "Socket pathname is too long.";
+    return -1;
+  }
+  strncpy(socket_address.sun_path, socket_pathname,
+          strlen(socket_pathname) + 1);
+
+  if (connect(socket_fd, (struct sockaddr *) &socket_address,
+              sizeof(socket_address)) != 0) {
+    close(socket_fd);
+    return -1;
+  }
+
+  return socket_fd;
+}
+
+int connect_inet_sock_retry(const char *ip_addr,
+                            int port,
+                            int num_retries,
+                            int64_t timeout) {
+  /* Pick the default values if the user did not specify. */
+  if (num_retries < 0) {
+    num_retries = NUM_CONNECT_ATTEMPTS;
+  }
+  if (timeout < 0) {
+    timeout = CONNECT_TIMEOUT_MS;
+  }
+
+  DCHECK(ip_addr);
+  int fd = -1;
+  for (int num_attempts = 0; num_attempts < num_retries; ++num_attempts) {
+    fd = connect_inet_sock(ip_addr, port);
+    if (fd >= 0) {
+      break;
+    }
+    if (num_attempts == 0) {
+      ARROW_LOG(ERROR) << "Connection to socket failed for address " << ip_addr << ":" << port;
+    }
+    /* Sleep for timeout milliseconds. */
+    usleep(timeout * 1000);
+  }
+  /* If we could not connect to the socket, exit. */
+  if (fd == -1) {
+    ARROW_LOG(FATAL) << "Could not connect to address " << ip_addr << ":" << port;
+  }
+  return fd;
+}
+
+int connect_inet_sock(const char *ip_addr, int port) {
+  int fd = socket(PF_INET, SOCK_STREAM, 0);
+  if (fd < 0) {
+    ARROW_LOG(ERROR) << "socket() failed for address " << ip_addr << ":" << port;
+    return -1;
+  }
+
+  struct hostent *manager = gethostbyname(ip_addr); /* TODO(pcm): cache this */
+  if (!manager) {
+    ARROW_LOG(ERROR) << "Failed to get hostname from address " << ip_addr << ":" << port;
+    close(fd);
+    return -1;
+  }
+
+  struct sockaddr_in addr;
+  addr.sin_family = AF_INET;
+  memcpy(&addr.sin_addr.s_addr, manager->h_addr_list[0], manager->h_length);
+  addr.sin_port = htons(port);
+
+  if (connect(fd, (struct sockaddr *) &addr, sizeof(addr)) != 0) {
+    close(fd);
+    return -1;
+  }
+  return fd;
+}
+
+int accept_client(int socket_fd) {
+  int client_fd = accept(socket_fd, NULL, NULL);
+  if (client_fd < 0) {
+    ARROW_LOG(ERROR) << "Error reading from socket.";
+    return -1;
+  }
+  return client_fd;
+}
+
+int write_bytes(int fd, uint8_t *cursor, size_t length) {
+  ssize_t nbytes = 0;
+  size_t bytesleft = length;
+  size_t offset = 0;
+  while (bytesleft > 0) {
+    /* While we haven't written the whole message, write to the file
+     * descriptor, advance the cursor, and decrease the amount left to write. */
+    nbytes = write(fd, cursor + offset, bytesleft);
+    if (nbytes < 0) {
+      if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
+        continue;
+      }
+      return -1; /* Errno will be set. */
+    } else if (0 == nbytes) {
+      /* Encountered early EOF. */
+      return -1;
+    }
+    DCHECK(nbytes > 0);
+    bytesleft -= nbytes;
+    offset += nbytes;
+  }
+
+  return 0;
+}
+
+int write_message(int fd, int64_t type, int64_t length, uint8_t *bytes) {
+  int64_t version = RAY_PROTOCOL_VERSION;
+  int closed;
+  closed = write_bytes(fd, (uint8_t *) &version, sizeof(version));
+  if (closed) {
+    return closed;
+  }
+  closed = write_bytes(fd, (uint8_t *) &type, sizeof(type));
+  if (closed) {
+    return closed;
+  }
+  closed = write_bytes(fd, (uint8_t *) &length, sizeof(length));
+  if (closed) {
+    return closed;
+  }
+  closed = write_bytes(fd, bytes, length * sizeof(char));
+  if (closed) {
+    return closed;
+  }
+  return 0;
+}
+
+int read_bytes(int fd, uint8_t *cursor, size_t length) {
+  ssize_t nbytes = 0;
+  /* Termination condition: EOF or read 'length' bytes total. */
+  size_t bytesleft = length;
+  size_t offset = 0;
+  while (bytesleft > 0) {
+    nbytes = read(fd, cursor + offset, bytesleft);
+    if (nbytes < 0) {
+      if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
+        continue;
+      }
+      return -1; /* Errno will be set. */
+    } else if (0 == nbytes) {
+      /* Encountered early EOF. */
+      return -1;
+    }
+    DCHECK(nbytes > 0);
+    bytesleft -= nbytes;
+    offset += nbytes;
+  }
+
+  return 0;
+}
+
+void read_message(int fd, int64_t *type, int64_t *length, uint8_t **bytes) {
+  int64_t version;
+  int closed = read_bytes(fd, (uint8_t *) &version, sizeof(version));
+  if (closed) {
+    goto disconnected;
+  }
+  DCHECK(version == RAY_PROTOCOL_VERSION);
+  closed = read_bytes(fd, (uint8_t *) type, sizeof(*type));
+  if (closed) {
+    goto disconnected;
+  }
+  closed = read_bytes(fd, (uint8_t *) length, sizeof(*length));
+  if (closed) {
+    goto disconnected;
+  }
+  *bytes = (uint8_t *) malloc(*length * sizeof(uint8_t));
+  closed = read_bytes(fd, *bytes, *length);
+  if (closed) {
+    free(*bytes);
+    goto disconnected;
+  }
+  return;
+
+disconnected:
+  /* Handle the case in which the socket is closed. */
+  *type = DISCONNECT_CLIENT;
+  *length = 0;
+  *bytes = NULL;
+  return;
+}
+
+uint8_t *read_message_async(event_loop *loop, int sock) {
+  int64_t size;
+  int error = read_bytes(sock, (uint8_t *) &size, sizeof(int64_t));
+  if (error < 0) {
+    /* The other side has closed the socket. */
+    ARROW_LOG(WARNING) << "Socket has been closed, or some other error has occurred.";
+    if (loop != NULL) {
+      event_loop_remove_file(loop, sock);
+    }
+    close(sock);
+    return NULL;
+  }
+  uint8_t *message = (uint8_t *) malloc(size);
+  error = read_bytes(sock, message, size);
+  if (error < 0) {
+    /* The other side has closed the socket. */
+    ARROW_LOG(WARNING) << "Socket has been closed, or some other error has occurred.";
+    if (loop != NULL) {
+      event_loop_remove_file(loop, sock);
+    }
+    close(sock);
+    return NULL;
+  }
+  return message;
+}
+
+int64_t read_buffer(int fd, int64_t *type, UT_array *buffer) {
+  int64_t version;
+  int closed = read_bytes(fd, (uint8_t *) &version, sizeof(version));
+  if (closed) {
+    goto disconnected;
+  }
+  DCHECK(version == RAY_PROTOCOL_VERSION);
+  int64_t length;
+  closed = read_bytes(fd, (uint8_t *) type, sizeof(*type));
+  if (closed) {
+    goto disconnected;
+  }
+  closed = read_bytes(fd, (uint8_t *) &length, sizeof(length));
+  if (closed) {
+    goto disconnected;
+  }
+  if (length > utarray_len(buffer)) {
+    utarray_resize(buffer, length);
+  }
+  closed = read_bytes(fd, (uint8_t *) utarray_front(buffer), length);
+  if (closed) {
+    goto disconnected;
+  }
+  return length;
+disconnected:
+  /* Handle the case in which the socket is closed. */
+  *type = DISCONNECT_CLIENT;
+  return 0;
+}
diff --git a/cpp/src/plasma/common/io.h b/cpp/src/plasma/common/io.h
new file mode 100644
index 000000000000..1e68ff94112b
--- /dev/null
+++ b/cpp/src/plasma/common/io.h
@@ -0,0 +1,219 @@
+#ifndef IO_H
+#define IO_H
+
+#include <stdbool.h>
+#include <stdint.h>
+
+#include "utarray.h"
+
+#define RAY_PROTOCOL_VERSION 0x0000000000000000
+
+/* Number of times we try binding to a socket. */
+#define NUM_BIND_ATTEMPTS 5
+#define BIND_TIMEOUT_MS 100
+
+/* Number of times we try connecting to a socket. */
+#define NUM_CONNECT_ATTEMPTS 50
+#define CONNECT_TIMEOUT_MS 100
+
+struct aeEventLoop;
+typedef aeEventLoop event_loop;
+
+enum common_message_type {
+  /** Disconnect a client. */
+  DISCONNECT_CLIENT,
+  /** Log a message from a client. */
+  LOG_MESSAGE,
+  /** Submit a task to the local scheduler. */
+  SUBMIT_TASK,
+};
+
+/* Helper functions for socket communication. */
+
+/**
+ * Binds to an Internet socket at the given port. Removes any existing file at
+ * the pathname. Returns a non-blocking file descriptor for the socket, or -1
+ * if an error occurred.
+ *
+ * @note Since the returned file descriptor is non-blocking, it is not
+ * recommended to use the Linux read and write calls directly, since these
+ * might read or write a partial message. Instead, use the provided
+ * write_message and read_message methods.
+ *
+ * @param port The port to bind to.
+ * @param shall_listen Are we also starting to listen on the socket?
+ * @return A non-blocking file descriptor for the socket, or -1 if an error
+ *         occurs.
+ */
+int bind_inet_sock(const int port, bool shall_listen);
+
+/**
+ * Binds to a Unix domain streaming socket at the given
+ * pathname. Removes any existing file at the pathname.
+ *
+ * @param socket_pathname The pathname for the socket.
+ * @param shall_listen Are we also starting to listen on the socket?
+ * @return A blocking file descriptor for the socket, or -1 if an error
+ *         occurs.
+ */
+int bind_ipc_sock(const char *socket_pathname, bool shall_listen);
+
+/**
+ * Connect to a Unix domain streaming socket at the given
+ * pathname.
+ *
+ * @param socket_pathname The pathname for the socket.
+ * @return A file descriptor for the socket, or -1 if an error occurred.
+ */
+int connect_ipc_sock(const char *socket_pathname);
+
+/**
+ * Connect to a Unix domain streaming socket at the given
+ * pathname, or fail after some number of retries.
+ *
+ * @param socket_pathname The pathname for the socket.
+ * @param num_retries The number of times to retry the connection
+ *        before exiting. If -1 is provided, then this defaults to
+ *        NUM_CONNECT_ATTEMPTS.
+ * @param timeout The number of milliseconds to wait in between
+ *        retries. If -1 is provided, then this defaults to CONNECT_TIMEOUT_MS.
+ * @return A file descriptor for the socket, or -1 if an error occurred.
+ */
+int connect_ipc_sock_retry(const char *socket_pathname,
+                           int num_retries,
+                           int64_t timeout);
+
+/**
+ * Connect to an Internet socket at the given address and port.
+ *
+ * @param ip_addr The IP address to connect to.
+ * @param port The port number to connect to.
+ *
+ * @param socket_pathname The pathname for the socket.
+ * @return A file descriptor for the socket, or -1 if an error occurred.
+ */
+int connect_inet_sock(const char *ip_addr, int port);
+
+/**
+ * Connect to an Internet socket at the given address and port, or fail after
+ * some number of retries.
+ *
+ * @param ip_addr The IP address to connect to.
+ * @param port The port number to connect to.
+ * @param num_retries The number of times to retry the connection
+ *        before exiting. If -1 is provided, then this defaults to
+ *        NUM_CONNECT_ATTEMPTS.
+ * @param timeout The number of milliseconds to wait in between
+ *        retries. If -1 is provided, then this defaults to CONNECT_TIMEOUT_MS.
+ * @return A file descriptor for the socket, or -1 if an error occurred.
+ */
+int connect_inet_sock_retry(const char *ip_addr,
+                            int port,
+                            int num_retries,
+                            int64_t timeout);
+
+/**
+ * Accept a new client connection on the given socket
+ * descriptor. Returns a descriptor for the new socket.
+ */
+int accept_client(int socket_fd);
+
+/* Reading and writing data. */
+
+/**
+ * Write a sequence of bytes on a file descriptor. The bytes should then be read
+ * by read_message.
+ *
+ * @param fd The file descriptor to write to. It can be non-blocking.
+ * @param version The protocol version.
+ * @param type The type of the message to send.
+ * @param length The size in bytes of the bytes parameter.
+ * @param bytes The address of the message to send.
+ * @return int Whether there was an error while writing. 0 corresponds to
+ *         success and -1 corresponds to an error (errno will be set).
+ */
+int write_message(int fd, int64_t type, int64_t length, uint8_t *bytes);
+
+/**
+ * Read a sequence of bytes written by write_message from a file descriptor.
+ * This allocates space for the message.
+ *
+ * @note The caller must free the memory.
+ *
+ * @param fd The file descriptor to read from. It can be non-blocking.
+ * @param type The type of the message that is read will be written at this
+ *        address. If there was an error while reading, this will be
+ *        DISCONNECT_CLIENT.
+ * @param length The size in bytes of the message that is read will be written
+ *        at this address. This size does not include the bytes used to encode
+ *        the type and length. If there was an error while reading, this will
+ *        be 0.
+ * @param bytes The address at which to write the pointer to the bytes that are
+ *        read and allocated by this function. If there was an error while
+ *        reading, this will be NULL.
+ * @return Void.
+ */
+void read_message(int fd, int64_t *type, int64_t *length, uint8_t **bytes);
+
+/**
+ * Read a message from a file descriptor and remove the file descriptor from the
+ * event loop if there is an error. This will actually do two reads. The first
+ * read reads sizeof(int64_t) bytes to determine the number of bytes to read in
+ * the next read.
+ *
+ * @param loop: The event loop.
+ * @param sock: The file descriptor to read from.
+ * @return A byte buffer contining the message or NULL if there was an
+ *         error. The buffer needs to be freed by the user.
+ */
+uint8_t *read_message_async(event_loop *loop, int sock);
+
+/**
+ * Read a sequence of bytes written by write_message from a file descriptor.
+ * This does not allocate space for the message if the provided buffer is
+ * large enough and can therefore often avoid allocations.
+ *
+ * @note The caller must create and free the buffer.
+ *
+ * @param fd The file descriptor to read from. It can be non-blocking.
+ * @param type The type of the message that is read will be written at this
+ *        address. If there was an error while reading, this will be
+ *        DISCONNECT_CLIENT.
+ * @param buffer The array the message will be written to. If it is not
+ *        large enough to hold the message, it will be enlarged by read_buffer.
+ * @return Number of bytes of the message that were read. This size does not
+ *         include the bytes used to encode the type and length. If there was
+ *         an error while reading, this will be 0.
+ */
+int64_t read_buffer(int fd, int64_t *type, UT_array *buffer);
+
+/**
+ * Read a sequence of bytes from a file descriptor into a buffer. This will
+ * block until one of the following happens: (1) there is an error (2) end of
+ * file, or (3) all length bytes have been written.
+ *
+ * @note The buffer pointed to by cursor must already have length number of
+ * bytes allocated before calling this method.
+ *
+ * @param fd The file descriptor to read from. It can be non-blocking.
+ * @param cursor The cursor pointing to the beginning of the buffer.
+ * @param length The size of the byte sequence to read.
+ * @return int Whether there was an error while reading. 0 corresponds to
+ *         success and -1 corresponds to an error (errno will be set).
+ */
+int read_bytes(int fd, uint8_t *cursor, size_t length);
+
+/**
+ * Write a sequence of bytes into a file descriptor. This will block until one
+ * of the following happens: (1) there is an error (2) end of file, or (3) all
+ * length bytes have been written.
+ *
+ * @param fd The file descriptor to write to. It can be non-blocking.
+ * @param cursor The cursor pointing to the beginning of the bytes to send.
+ * @param length The size of the bytes sequence to write.
+ * @return int Whether there was an error while writing. 0 corresponds to
+ *         success and -1 corresponds to an error (errno will be set).
+ */
+int write_bytes(int fd, uint8_t *cursor, size_t length);
+
+#endif /* IO_H */
diff --git a/cpp/src/plasma/common/test/common_tests.cc b/cpp/src/plasma/common/test/common_tests.cc
new file mode 100644
index 000000000000..8acdc335e131
--- /dev/null
+++ b/cpp/src/plasma/common/test/common_tests.cc
@@ -0,0 +1,24 @@
+#include "greatest.h"
+
+#include "common.h"
+
+SUITE(common_tests);
+
+TEST sha1_test(void) {
+  static char hex[ID_STRING_SIZE];
+  UniqueID uid = globally_unique_id();
+  ObjectID_to_string((ObjectID) uid, &hex[0], ID_STRING_SIZE);
+  PASS();
+}
+
+SUITE(common_tests) {
+  RUN_TEST(sha1_test);
+}
+
+GREATEST_MAIN_DEFS();
+
+int main(int argc, char **argv) {
+  GREATEST_MAIN_BEGIN();
+  RUN_SUITE(common_tests);
+  GREATEST_MAIN_END();
+}
diff --git a/cpp/src/plasma/common/thirdparty/greatest.h b/cpp/src/plasma/common/thirdparty/greatest.h
new file mode 100644
index 000000000000..eb34ff4263ec
--- /dev/null
+++ b/cpp/src/plasma/common/thirdparty/greatest.h
@@ -0,0 +1,1023 @@
+/*
+ * Copyright (c) 2011-2016 Scott Vokes <vokes.s@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef GREATEST_H
+#define GREATEST_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* 1.2.1 */
+#define GREATEST_VERSION_MAJOR 1
+#define GREATEST_VERSION_MINOR 2
+#define GREATEST_VERSION_PATCH 1
+
+/* A unit testing system for C, contained in 1 file.
+ * It doesn't use dynamic allocation or depend on anything
+ * beyond ANSI C89.
+ *
+ * An up-to-date version can be found at:
+ *     https://github.com/silentbicycle/greatest/
+ */
+
+
+/*********************************************************************
+ * Minimal test runner template
+ *********************************************************************/
+#if 0
+#include "greatest.h"
+TEST foo_should_foo(void) {
+    PASS();
+}
+static void setup_cb(void *data) {
+    printf("setup callback for each test case\n");
+}
+static void teardown_cb(void *data) {
+    printf("teardown callback for each test case\n");
+}
+SUITE(suite) {
+    /* Optional setup/teardown callbacks which will be run before/after
+     * every test case. If using a test suite, they will be cleared when
+     * the suite finishes. */
+    SET_SETUP(setup_cb, voidp_to_callback_data);
+    SET_TEARDOWN(teardown_cb, voidp_to_callback_data);
+    RUN_TEST(foo_should_foo);
+}
+/* Add definitions that need to be in the test runner's main file. */
+GREATEST_MAIN_DEFS();
+/* Set up, run suite(s) of tests, report pass/fail/skip stats. */
+int run_tests(void) {
+    GREATEST_INIT();            /* init. greatest internals */
+    /* List of suites to run (if any). */
+    RUN_SUITE(suite);
+    /* Tests can also be run directly, without using test suites. */
+    RUN_TEST(foo_should_foo);
+    GREATEST_PRINT_REPORT();          /* display results */
+    return greatest_all_passed();
+}
+/* main(), for a standalone command-line test runner.
+ * This replaces run_tests above, and adds command line option
+ * handling and exiting with a pass/fail status. */
+int main(int argc, char **argv) {
+    GREATEST_MAIN_BEGIN();      /* init & parse command-line args */
+    RUN_SUITE(suite);
+    GREATEST_MAIN_END();        /* display results */
+}
+#endif
+/*********************************************************************/
+
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <ctype.h>
+
+/***********
+ * Options *
+ ***********/
+
+/* Default column width for non-verbose output. */
+#ifndef GREATEST_DEFAULT_WIDTH
+#define GREATEST_DEFAULT_WIDTH 72
+#endif
+
+/* FILE *, for test logging. */
+#ifndef GREATEST_STDOUT
+#define GREATEST_STDOUT stdout
+#endif
+
+/* Remove GREATEST_ prefix from most commonly used symbols? */
+#ifndef GREATEST_USE_ABBREVS
+#define GREATEST_USE_ABBREVS 1
+#endif
+
+/* Set to 0 to disable all use of setjmp/longjmp. */
+#ifndef GREATEST_USE_LONGJMP
+#define GREATEST_USE_LONGJMP 1
+#endif
+
+#if GREATEST_USE_LONGJMP
+#include <setjmp.h>
+#endif
+
+/* Set to 0 to disable all use of time.h / clock(). */
+#ifndef GREATEST_USE_TIME
+#define GREATEST_USE_TIME 1
+#endif
+
+#if GREATEST_USE_TIME
+#include <time.h>
+#endif
+
+/* Floating point type, for ASSERT_IN_RANGE. */
+#ifndef GREATEST_FLOAT
+#define GREATEST_FLOAT double
+#define GREATEST_FLOAT_FMT "%g"
+#endif
+
+/*********
+ * Types *
+ *********/
+
+/* Info for the current running suite. */
+typedef struct greatest_suite_info {
+    unsigned int tests_run;
+    unsigned int passed;
+    unsigned int failed;
+    unsigned int skipped;
+
+#if GREATEST_USE_TIME
+    /* timers, pre/post running suite and individual tests */
+    clock_t pre_suite;
+    clock_t post_suite;
+    clock_t pre_test;
+    clock_t post_test;
+#endif
+} greatest_suite_info;
+
+/* Type for a suite function. */
+typedef void (greatest_suite_cb)(void);
+
+/* Types for setup/teardown callbacks. If non-NULL, these will be run
+ * and passed the pointer to their additional data. */
+typedef void (greatest_setup_cb)(void *udata);
+typedef void (greatest_teardown_cb)(void *udata);
+
+/* Type for an equality comparison between two pointers of the same type.
+ * Should return non-0 if equal, otherwise 0.
+ * UDATA is a closure value, passed through from ASSERT_EQUAL_T[m]. */
+typedef int greatest_equal_cb(const void *exp, const void *got, void *udata);
+
+/* Type for a callback that prints a value pointed to by T.
+ * Return value has the same meaning as printf's.
+ * UDATA is a closure value, passed through from ASSERT_EQUAL_T[m]. */
+typedef int greatest_printf_cb(const void *t, void *udata);
+
+/* Callbacks for an arbitrary type; needed for type-specific
+ * comparisons via GREATEST_ASSERT_EQUAL_T[m].*/
+typedef struct greatest_type_info {
+    greatest_equal_cb *equal;
+    greatest_printf_cb *print;
+} greatest_type_info;
+
+typedef struct greatest_memory_cmp_env {
+    const unsigned char *exp;
+    const unsigned char *got;
+    size_t size;
+} greatest_memory_cmp_env;
+
+/* Callbacks for string and raw memory types. */
+extern greatest_type_info greatest_type_info_string;
+extern greatest_type_info greatest_type_info_memory;
+
+typedef enum {
+    GREATEST_FLAG_FIRST_FAIL = 0x01,
+    GREATEST_FLAG_LIST_ONLY = 0x02
+} greatest_flag_t;
+
+/* Struct containing all test runner state. */
+typedef struct greatest_run_info {
+    unsigned char flags;
+    unsigned char verbosity;
+    unsigned int tests_run;     /* total test count */
+
+    /* overall pass/fail/skip counts */
+    unsigned int passed;
+    unsigned int failed;
+    unsigned int skipped;
+    unsigned int assertions;
+
+    /* currently running test suite */
+    greatest_suite_info suite;
+
+    /* info to print about the most recent failure */
+    const char *fail_file;
+    unsigned int fail_line;
+    const char *msg;
+
+    /* current setup/teardown hooks and userdata */
+    greatest_setup_cb *setup;
+    void *setup_udata;
+    greatest_teardown_cb *teardown;
+    void *teardown_udata;
+
+    /* formatting info for ".....s...F"-style output */
+    unsigned int col;
+    unsigned int width;
+
+    /* only run a specific suite or test */
+    const char *suite_filter;
+    const char *test_filter;
+
+#if GREATEST_USE_TIME
+    /* overall timers */
+    clock_t begin;
+    clock_t end;
+#endif
+
+#if GREATEST_USE_LONGJMP
+    jmp_buf jump_dest;
+#endif
+} greatest_run_info;
+
+struct greatest_report_t {
+    /* overall pass/fail/skip counts */
+    unsigned int passed;
+    unsigned int failed;
+    unsigned int skipped;
+    unsigned int assertions;
+};
+
+/* Global var for the current testing context.
+ * Initialized by GREATEST_MAIN_DEFS(). */
+extern greatest_run_info greatest_info;
+
+/* Type for ASSERT_ENUM_EQ's ENUM_STR argument. */
+typedef const char *greatest_enum_str_fun(int value);
+
+/**********************
+ * Exported functions *
+ **********************/
+
+/* These are used internally by greatest. */
+void greatest_do_pass(const char *name);
+void greatest_do_fail(const char *name);
+void greatest_do_skip(const char *name);
+int greatest_pre_test(const char *name);
+void greatest_post_test(const char *name, int res);
+void greatest_usage(const char *name);
+int greatest_do_assert_equal_t(const void *exp, const void *got,
+    greatest_type_info *type_info, void *udata);
+
+/* These are part of the public greatest API. */
+void GREATEST_SET_SETUP_CB(greatest_setup_cb *cb, void *udata);
+void GREATEST_SET_TEARDOWN_CB(greatest_teardown_cb *cb, void *udata);
+int greatest_all_passed(void);
+void greatest_set_test_filter(const char *name);
+void greatest_set_suite_filter(const char *name);
+void greatest_get_report(struct greatest_report_t *report);
+unsigned int greatest_get_verbosity(void);
+void greatest_set_verbosity(unsigned int verbosity);
+void greatest_set_flag(greatest_flag_t flag);
+
+
+/********************
+* Language Support *
+********************/
+
+/* If __VA_ARGS__ (C99) is supported, allow parametric testing
+* without needing to manually manage the argument struct. */
+#if __STDC_VERSION__ >= 19901L || _MSC_VER >= 1800
+#define GREATEST_VA_ARGS
+#endif
+
+
+/**********
+ * Macros *
+ **********/
+
+/* Define a suite. */
+#define GREATEST_SUITE(NAME) void NAME(void); void NAME(void)
+
+/* Declare a suite, provided by another compilation unit. */
+#define GREATEST_SUITE_EXTERN(NAME) void NAME(void)
+
+/* Start defining a test function.
+ * The arguments are not included, to allow parametric testing. */
+#define GREATEST_TEST static enum greatest_test_res
+
+/* PASS/FAIL/SKIP result from a test. Used internally. */
+typedef enum greatest_test_res {
+    GREATEST_TEST_RES_PASS = 0,
+    GREATEST_TEST_RES_FAIL = -1,
+    GREATEST_TEST_RES_SKIP = 1
+} greatest_test_res;
+
+/* Run a suite. */
+#define GREATEST_RUN_SUITE(S_NAME) greatest_run_suite(S_NAME, #S_NAME)
+
+/* Run a test in the current suite. */
+#define GREATEST_RUN_TEST(TEST)                                         \
+    do {                                                                \
+        if (greatest_pre_test(#TEST) == 1) {                            \
+            enum greatest_test_res res = GREATEST_SAVE_CONTEXT();       \
+            if (res == GREATEST_TEST_RES_PASS) {                        \
+                res = TEST();                                           \
+            }                                                           \
+            greatest_post_test(#TEST, res);                             \
+        } else if (GREATEST_LIST_ONLY()) {                              \
+            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
+        }                                                               \
+    } while (0)
+
+/* Ignore a test, don't warn about it being unused. */
+#define GREATEST_IGNORE_TEST(TEST) (void)TEST
+
+/* Run a test in the current suite with one void * argument,
+ * which can be a pointer to a struct with multiple arguments. */
+#define GREATEST_RUN_TEST1(TEST, ENV)                                   \
+    do {                                                                \
+        if (greatest_pre_test(#TEST) == 1) {                            \
+            int res = TEST(ENV);                                        \
+            greatest_post_test(#TEST, res);                             \
+        } else if (GREATEST_LIST_ONLY()) {                              \
+            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
+        }                                                               \
+    } while (0)
+
+#ifdef GREATEST_VA_ARGS
+#define GREATEST_RUN_TESTp(TEST, ...)                                   \
+    do {                                                                \
+        if (greatest_pre_test(#TEST) == 1) {                            \
+            int res = TEST(__VA_ARGS__);                                \
+            greatest_post_test(#TEST, res);                             \
+        } else if (GREATEST_LIST_ONLY()) {                              \
+            fprintf(GREATEST_STDOUT, "  %s\n", #TEST);                  \
+        }                                                               \
+    } while (0)
+#endif
+
+
+/* Check if the test runner is in verbose mode. */
+#define GREATEST_IS_VERBOSE() ((greatest_info.verbosity) > 0)
+#define GREATEST_LIST_ONLY()                                            \
+    (greatest_info.flags & GREATEST_FLAG_LIST_ONLY)
+#define GREATEST_FIRST_FAIL()                                           \
+    (greatest_info.flags & GREATEST_FLAG_FIRST_FAIL)
+#define GREATEST_FAILURE_ABORT()                                        \
+    (greatest_info.suite.failed > 0 && GREATEST_FIRST_FAIL())
+
+/* Message-less forms of tests defined below. */
+#define GREATEST_PASS() GREATEST_PASSm(NULL)
+#define GREATEST_FAIL() GREATEST_FAILm(NULL)
+#define GREATEST_SKIP() GREATEST_SKIPm(NULL)
+#define GREATEST_ASSERT(COND)                                           \
+    GREATEST_ASSERTm(#COND, COND)
+#define GREATEST_ASSERT_OR_LONGJMP(COND)                                \
+    GREATEST_ASSERT_OR_LONGJMPm(#COND, COND)
+#define GREATEST_ASSERT_FALSE(COND)                                     \
+    GREATEST_ASSERT_FALSEm(#COND, COND)
+#define GREATEST_ASSERT_EQ(EXP, GOT)                                    \
+    GREATEST_ASSERT_EQm(#EXP " != " #GOT, EXP, GOT)
+#define GREATEST_ASSERT_EQ_FMT(EXP, GOT, FMT)                           \
+    GREATEST_ASSERT_EQ_FMTm(#EXP " != " #GOT, EXP, GOT, FMT)
+#define GREATEST_ASSERT_IN_RANGE(EXP, GOT, TOL)                         \
+    GREATEST_ASSERT_IN_RANGEm(#EXP " != " #GOT " +/- " #TOL, EXP, GOT, TOL)
+#define GREATEST_ASSERT_EQUAL_T(EXP, GOT, TYPE_INFO, UDATA)             \
+    GREATEST_ASSERT_EQUAL_Tm(#EXP " != " #GOT, EXP, GOT, TYPE_INFO, UDATA)
+#define GREATEST_ASSERT_STR_EQ(EXP, GOT)                                \
+    GREATEST_ASSERT_STR_EQm(#EXP " != " #GOT, EXP, GOT)
+#define GREATEST_ASSERT_STRN_EQ(EXP, GOT, SIZE)                         \
+    GREATEST_ASSERT_STRN_EQm(#EXP " != " #GOT, EXP, GOT, SIZE)
+#define GREATEST_ASSERT_MEM_EQ(EXP, GOT, SIZE)                          \
+    GREATEST_ASSERT_MEM_EQm(#EXP " != " #GOT, EXP, GOT, SIZE)
+#define GREATEST_ASSERT_ENUM_EQ(EXP, GOT, ENUM_STR)                     \
+    GREATEST_ASSERT_ENUM_EQm(#EXP " != " #GOT, EXP, GOT, ENUM_STR)
+
+/* The following forms take an additional message argument first,
+ * to be displayed by the test runner. */
+
+/* Fail if a condition is not true, with message. */
+#define GREATEST_ASSERTm(MSG, COND)                                     \
+    do {                                                                \
+        greatest_info.assertions++;                                     \
+        if (!(COND)) { GREATEST_FAILm(MSG); }                           \
+    } while (0)
+
+/* Fail if a condition is not true, longjmping out of test. */
+#define GREATEST_ASSERT_OR_LONGJMPm(MSG, COND)                          \
+    do {                                                                \
+        greatest_info.assertions++;                                     \
+        if (!(COND)) { GREATEST_FAIL_WITH_LONGJMPm(MSG); }              \
+    } while (0)
+
+/* Fail if a condition is not false, with message. */
+#define GREATEST_ASSERT_FALSEm(MSG, COND)                               \
+    do {                                                                \
+        greatest_info.assertions++;                                     \
+        if ((COND)) { GREATEST_FAILm(MSG); }                            \
+    } while (0)
+
+/* Fail if EXP != GOT (equality comparison by ==). */
+#define GREATEST_ASSERT_EQm(MSG, EXP, GOT)                              \
+    do {                                                                \
+        greatest_info.assertions++;                                     \
+        if ((EXP) != (GOT)) { GREATEST_FAILm(MSG); }                    \
+    } while (0)
+
+/* Fail if EXP != GOT (equality comparison by ==).
+ * Warning: EXP and GOT will be evaluated more than once on failure. */
+#define GREATEST_ASSERT_EQ_FMTm(MSG, EXP, GOT, FMT)                     \
+    do {                                                                \
+        const char *greatest_FMT = ( FMT );                             \
+        greatest_info.assertions++;                                     \
+        if ((EXP) != (GOT)) {                                           \
+            fprintf(GREATEST_STDOUT, "\nExpected: ");                   \
+            fprintf(GREATEST_STDOUT, greatest_FMT, EXP);                \
+            fprintf(GREATEST_STDOUT, "\n     Got: ");                   \
+            fprintf(GREATEST_STDOUT, greatest_FMT, GOT);                \
+            fprintf(GREATEST_STDOUT, "\n");                             \
+            GREATEST_FAILm(MSG);                                        \
+        }                                                               \
+    } while (0)
+
+/* Fail if EXP is not equal to GOT, printing enum IDs. */
+#define GREATEST_ASSERT_ENUM_EQm(MSG, EXP, GOT, ENUM_STR)               \
+    do {                                                                \
+        int greatest_EXP = (int)(EXP);                                  \
+        int greatest_GOT = (int)(GOT);                                  \
+        greatest_enum_str_fun *greatest_ENUM_STR = ENUM_STR;            \
+        if (greatest_EXP != greatest_GOT) {                             \
+            fprintf(GREATEST_STDOUT, "\nExpected: %s",                  \
+                greatest_ENUM_STR(greatest_EXP));                       \
+            fprintf(GREATEST_STDOUT, "\n     Got: %s\n",                \
+                greatest_ENUM_STR(greatest_GOT));                       \
+            GREATEST_FAILm(MSG);                                        \
+        }                                                               \
+    } while (0)                                                         \
+
+/* Fail if GOT not in range of EXP +|- TOL. */
+#define GREATEST_ASSERT_IN_RANGEm(MSG, EXP, GOT, TOL)                   \
+    do {                                                                \
+        GREATEST_FLOAT greatest_EXP = (EXP);                            \
+        GREATEST_FLOAT greatest_GOT = (GOT);                            \
+        GREATEST_FLOAT greatest_TOL = (TOL);                            \
+        greatest_info.assertions++;                                     \
+        if ((greatest_EXP > greatest_GOT &&                             \
+                greatest_EXP - greatest_GOT > greatest_TOL) ||          \
+            (greatest_EXP < greatest_GOT &&                             \
+                greatest_GOT - greatest_EXP > greatest_TOL)) {          \
+            fprintf(GREATEST_STDOUT,                                    \
+                "\nExpected: " GREATEST_FLOAT_FMT                       \
+                " +/- " GREATEST_FLOAT_FMT                              \
+                "\n     Got: " GREATEST_FLOAT_FMT                       \
+                "\n",                                                   \
+                greatest_EXP, greatest_TOL, greatest_GOT);              \
+            GREATEST_FAILm(MSG);                                        \
+        }                                                               \
+    } while (0)
+
+/* Fail if EXP is not equal to GOT, according to strcmp. */
+#define GREATEST_ASSERT_STR_EQm(MSG, EXP, GOT)                          \
+    do {                                                                \
+        GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT,                         \
+            &greatest_type_info_string, NULL);                          \
+    } while (0)                                                         \
+
+/* Fail if EXP is not equal to GOT, according to strcmp. */
+#define GREATEST_ASSERT_STRN_EQm(MSG, EXP, GOT, SIZE)                   \
+    do {                                                                \
+        size_t size = SIZE;                                             \
+        GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT,                         \
+            &greatest_type_info_string, &size);                         \
+    } while (0)                                                         \
+
+/* Fail if EXP is not equal to GOT, according to memcmp. */
+#define GREATEST_ASSERT_MEM_EQm(MSG, EXP, GOT, SIZE)                    \
+    do {                                                                \
+        greatest_memory_cmp_env env;                                    \
+        env.exp = (const unsigned char *)EXP;                           \
+        env.got = (const unsigned char *)GOT;                           \
+        env.size = SIZE;                                                \
+        GREATEST_ASSERT_EQUAL_Tm(MSG, env.exp, env.got,                 \
+            &greatest_type_info_memory, &env);                          \
+    } while (0)                                                         \
+
+/* Fail if EXP is not equal to GOT, according to a comparison
+ * callback in TYPE_INFO. If they are not equal, optionally use a
+ * print callback in TYPE_INFO to print them. */
+#define GREATEST_ASSERT_EQUAL_Tm(MSG, EXP, GOT, TYPE_INFO, UDATA)       \
+    do {                                                                \
+        greatest_type_info *type_info = (TYPE_INFO);                    \
+        greatest_info.assertions++;                                     \
+        if (!greatest_do_assert_equal_t(EXP, GOT,                       \
+                type_info, UDATA)) {                                    \
+            if (type_info == NULL || type_info->equal == NULL) {        \
+                GREATEST_FAILm("type_info->equal callback missing!");   \
+            } else {                                                    \
+                GREATEST_FAILm(MSG);                                    \
+            }                                                           \
+        }                                                               \
+    } while (0)                                                         \
+
+/* Pass. */
+#define GREATEST_PASSm(MSG)                                             \
+    do {                                                                \
+        greatest_info.msg = MSG;                                        \
+        return GREATEST_TEST_RES_PASS;                                  \
+    } while (0)
+
+/* Fail. */
+#define GREATEST_FAILm(MSG)                                             \
+    do {                                                                \
+        greatest_info.fail_file = __FILE__;                             \
+        greatest_info.fail_line = __LINE__;                             \
+        greatest_info.msg = MSG;                                        \
+        return GREATEST_TEST_RES_FAIL;                                  \
+    } while (0)
+
+/* Optional GREATEST_FAILm variant that longjmps. */
+#if GREATEST_USE_LONGJMP
+#define GREATEST_FAIL_WITH_LONGJMP() GREATEST_FAIL_WITH_LONGJMPm(NULL)
+#define GREATEST_FAIL_WITH_LONGJMPm(MSG)                                \
+    do {                                                                \
+        greatest_info.fail_file = __FILE__;                             \
+        greatest_info.fail_line = __LINE__;                             \
+        greatest_info.msg = MSG;                                        \
+        longjmp(greatest_info.jump_dest, GREATEST_TEST_RES_FAIL);       \
+    } while (0)
+#endif
+
+/* Skip the current test. */
+#define GREATEST_SKIPm(MSG)                                             \
+    do {                                                                \
+        greatest_info.msg = MSG;                                        \
+        return GREATEST_TEST_RES_SKIP;                                  \
+    } while (0)
+
+/* Check the result of a subfunction using ASSERT, etc. */
+#define GREATEST_CHECK_CALL(RES)                                        \
+    do {                                                                \
+        enum greatest_test_res greatest_RES = RES;                      \
+        if (greatest_RES != GREATEST_TEST_RES_PASS) {                   \
+            return greatest_RES;                                        \
+        }                                                               \
+    } while (0)                                                         \
+
+#if GREATEST_USE_TIME
+#define GREATEST_SET_TIME(NAME)                                         \
+    NAME = clock();                                                     \
+    if (NAME == (clock_t) -1) {                                         \
+        fprintf(GREATEST_STDOUT,                                        \
+            "clock error: %s\n", #NAME);                                \
+        exit(EXIT_FAILURE);                                             \
+    }
+
+#define GREATEST_CLOCK_DIFF(C1, C2)                                     \
+    fprintf(GREATEST_STDOUT, " (%lu ticks, %.3f sec)",                  \
+        (long unsigned int) (C2) - (long unsigned int)(C1),             \
+        (double)((C2) - (C1)) / (1.0 * (double)CLOCKS_PER_SEC))
+#else
+#define GREATEST_SET_TIME(UNUSED)
+#define GREATEST_CLOCK_DIFF(UNUSED1, UNUSED2)
+#endif
+
+#if GREATEST_USE_LONGJMP
+#define GREATEST_SAVE_CONTEXT()                                         \
+        /* setjmp returns 0 (GREATEST_TEST_RES_PASS) on first call */   \
+        /* so the test runs, then RES_FAIL from FAIL_WITH_LONGJMP. */   \
+        ((enum greatest_test_res)(setjmp(greatest_info.jump_dest)))
+#else
+#define GREATEST_SAVE_CONTEXT()                                         \
+    /*a no-op, since setjmp/longjmp aren't being used */                \
+    GREATEST_TEST_RES_PASS
+#endif
+
+/* Include several function definitions in the main test file. */
+#define GREATEST_MAIN_DEFS()                                            \
+                                                                        \
+/* Is FILTER a subset of NAME? */                                       \
+static int greatest_name_match(const char *name,                        \
+    const char *filter) {                                               \
+    size_t offset = 0;                                                  \
+    size_t filter_len = strlen(filter);                                 \
+    while (name[offset] != '\0') {                                      \
+        if (name[offset] == filter[0]) {                                \
+            if (0 == strncmp(&name[offset], filter, filter_len)) {      \
+                return 1;                                               \
+            }                                                           \
+        }                                                               \
+        offset++;                                                       \
+    }                                                                   \
+                                                                        \
+    return 0;                                                           \
+}                                                                       \
+                                                                        \
+int greatest_pre_test(const char *name) {                               \
+    if (!GREATEST_LIST_ONLY()                                           \
+        && (!GREATEST_FIRST_FAIL() || greatest_info.suite.failed == 0)  \
+        && (greatest_info.test_filter == NULL ||                        \
+            greatest_name_match(name, greatest_info.test_filter))) {    \
+        GREATEST_SET_TIME(greatest_info.suite.pre_test);                \
+        if (greatest_info.setup) {                                      \
+            greatest_info.setup(greatest_info.setup_udata);             \
+        }                                                               \
+        return 1;               /* test should be run */                \
+    } else {                                                            \
+        return 0;               /* skipped */                           \
+    }                                                                   \
+}                                                                       \
+                                                                        \
+void greatest_post_test(const char *name, int res) {                    \
+    GREATEST_SET_TIME(greatest_info.suite.post_test);                   \
+    if (greatest_info.teardown) {                                       \
+        void *udata = greatest_info.teardown_udata;                     \
+        greatest_info.teardown(udata);                                  \
+    }                                                                   \
+                                                                        \
+    if (res <= GREATEST_TEST_RES_FAIL) {                                \
+        greatest_do_fail(name);                                         \
+    } else if (res >= GREATEST_TEST_RES_SKIP) {                         \
+        greatest_do_skip(name);                                         \
+    } else if (res == GREATEST_TEST_RES_PASS) {                         \
+        greatest_do_pass(name);                                         \
+    }                                                                   \
+    greatest_info.suite.tests_run++;                                    \
+    greatest_info.col++;                                                \
+    if (GREATEST_IS_VERBOSE()) {                                        \
+        GREATEST_CLOCK_DIFF(greatest_info.suite.pre_test,               \
+            greatest_info.suite.post_test);                             \
+        fprintf(GREATEST_STDOUT, "\n");                                 \
+    } else if (greatest_info.col % greatest_info.width == 0) {          \
+        fprintf(GREATEST_STDOUT, "\n");                                 \
+        greatest_info.col = 0;                                          \
+    }                                                                   \
+    if (GREATEST_STDOUT == stdout) fflush(stdout);                      \
+}                                                                       \
+                                                                        \
+static void report_suite(void) {                                        \
+    if (greatest_info.suite.tests_run > 0) {                            \
+        fprintf(GREATEST_STDOUT,                                        \
+            "\n%u test%s - %u passed, %u failed, %u skipped",           \
+            greatest_info.suite.tests_run,                              \
+            greatest_info.suite.tests_run == 1 ? "" : "s",              \
+            greatest_info.suite.passed,                                 \
+            greatest_info.suite.failed,                                 \
+            greatest_info.suite.skipped);                               \
+        GREATEST_CLOCK_DIFF(greatest_info.suite.pre_suite,              \
+            greatest_info.suite.post_suite);                            \
+        fprintf(GREATEST_STDOUT, "\n");                                 \
+    }                                                                   \
+}                                                                       \
+                                                                        \
+static void update_counts_and_reset_suite(void) {                       \
+    greatest_info.setup = NULL;                                         \
+    greatest_info.setup_udata = NULL;                                   \
+    greatest_info.teardown = NULL;                                      \
+    greatest_info.teardown_udata = NULL;                                \
+    greatest_info.passed += greatest_info.suite.passed;                 \
+    greatest_info.failed += greatest_info.suite.failed;                 \
+    greatest_info.skipped += greatest_info.suite.skipped;               \
+    greatest_info.tests_run += greatest_info.suite.tests_run;           \
+    memset(&greatest_info.suite, 0, sizeof(greatest_info.suite));       \
+    greatest_info.col = 0;                                              \
+}                                                                       \
+                                                                        \
+static void greatest_run_suite(greatest_suite_cb *suite_cb,             \
+                               const char *suite_name) {                \
+    if (greatest_info.suite_filter &&                                   \
+        !greatest_name_match(suite_name, greatest_info.suite_filter)) { \
+        return;                                                         \
+    }                                                                   \
+    update_counts_and_reset_suite();                                    \
+    if (GREATEST_FIRST_FAIL() && greatest_info.failed > 0) { return; }  \
+    fprintf(GREATEST_STDOUT, "\n* Suite %s:\n", suite_name);            \
+    GREATEST_SET_TIME(greatest_info.suite.pre_suite);                   \
+    suite_cb();                                                         \
+    GREATEST_SET_TIME(greatest_info.suite.post_suite);                  \
+    report_suite();                                                     \
+}                                                                       \
+                                                                        \
+void greatest_do_pass(const char *name) {                               \
+    if (GREATEST_IS_VERBOSE()) {                                        \
+        fprintf(GREATEST_STDOUT, "PASS %s: %s",                         \
+            name, greatest_info.msg ? greatest_info.msg : "");          \
+    } else {                                                            \
+        fprintf(GREATEST_STDOUT, ".");                                  \
+    }                                                                   \
+    greatest_info.suite.passed++;                                       \
+}                                                                       \
+                                                                        \
+void greatest_do_fail(const char *name) {                               \
+    if (GREATEST_IS_VERBOSE()) {                                        \
+        fprintf(GREATEST_STDOUT,                                        \
+            "FAIL %s: %s (%s:%u)",                                      \
+            name, greatest_info.msg ? greatest_info.msg : "",           \
+            greatest_info.fail_file, greatest_info.fail_line);          \
+    } else {                                                            \
+        fprintf(GREATEST_STDOUT, "F");                                  \
+        greatest_info.col++;                                            \
+        /* add linebreak if in line of '.'s */                          \
+        if (greatest_info.col != 0) {                                   \
+            fprintf(GREATEST_STDOUT, "\n");                             \
+            greatest_info.col = 0;                                      \
+        }                                                               \
+        fprintf(GREATEST_STDOUT, "FAIL %s: %s (%s:%u)\n",               \
+            name,                                                       \
+            greatest_info.msg ? greatest_info.msg : "",                 \
+            greatest_info.fail_file, greatest_info.fail_line);          \
+    }                                                                   \
+    greatest_info.suite.failed++;                                       \
+}                                                                       \
+                                                                        \
+void greatest_do_skip(const char *name) {                               \
+    if (GREATEST_IS_VERBOSE()) {                                        \
+        fprintf(GREATEST_STDOUT, "SKIP %s: %s",                         \
+            name,                                                       \
+            greatest_info.msg ?                                         \
+            greatest_info.msg : "" );                                   \
+    } else {                                                            \
+        fprintf(GREATEST_STDOUT, "s");                                  \
+    }                                                                   \
+    greatest_info.suite.skipped++;                                      \
+}                                                                       \
+                                                                        \
+int greatest_do_assert_equal_t(const void *exp, const void *got,        \
+        greatest_type_info *type_info, void *udata) {                   \
+    int eq = 0;                                                         \
+    if (type_info == NULL || type_info->equal == NULL) {                \
+        return 0;                                                       \
+    }                                                                   \
+    eq = type_info->equal(exp, got, udata);                             \
+    if (!eq) {                                                          \
+        if (type_info->print != NULL) {                                 \
+            fprintf(GREATEST_STDOUT, "\nExpected: ");                   \
+            (void)type_info->print(exp, udata);                         \
+            fprintf(GREATEST_STDOUT, "\n     Got: ");                   \
+            (void)type_info->print(got, udata);                         \
+            fprintf(GREATEST_STDOUT, "\n");                             \
+        } else {                                                        \
+            fprintf(GREATEST_STDOUT,                                    \
+                "GREATEST_ASSERT_EQUAL_T failure at %s:%u\n",           \
+                greatest_info.fail_file,                                \
+                greatest_info.fail_line);                               \
+        }                                                               \
+    }                                                                   \
+    return eq;                                                          \
+}                                                                       \
+                                                                        \
+void greatest_usage(const char *name) {                                 \
+    fprintf(GREATEST_STDOUT,                                            \
+        "Usage: %s [-hlfv] [-s SUITE] [-t TEST]\n"                      \
+        "  -h, --help  print this Help\n"                               \
+        "  -l          List suites and their tests, then exit\n"        \
+        "  -f          Stop runner after first failure\n"               \
+        "  -v          Verbose output\n"                                \
+        "  -s SUITE    only run suites containing string SUITE\n"       \
+        "  -t TEST     only run tests containing string TEST\n",        \
+        name);                                                          \
+}                                                                       \
+                                                                        \
+static void greatest_parse_args(int argc, char **argv) {                \
+    int i = 0;                                                          \
+    for (i = 1; i < argc; i++) {                                        \
+        if (0 == strncmp("-t", argv[i], 2)) {                           \
+            if (argc <= i + 1) {                                        \
+                greatest_usage(argv[0]);                                \
+                exit(EXIT_FAILURE);                                     \
+            }                                                           \
+            greatest_info.test_filter = argv[i+1];                      \
+            i++;                                                        \
+        } else if (0 == strncmp("-s", argv[i], 2)) {                    \
+            if (argc <= i + 1) {                                        \
+                greatest_usage(argv[0]);                                \
+                exit(EXIT_FAILURE);                                     \
+            }                                                           \
+            greatest_info.suite_filter = argv[i+1];                     \
+            i++;                                                        \
+        } else if (0 == strncmp("-f", argv[i], 2)) {                    \
+            greatest_info.flags |= GREATEST_FLAG_FIRST_FAIL;            \
+        } else if (0 == strncmp("-v", argv[i], 2)) {                    \
+            greatest_info.verbosity++;                                  \
+        } else if (0 == strncmp("-l", argv[i], 2)) {                    \
+            greatest_info.flags |= GREATEST_FLAG_LIST_ONLY;             \
+        } else if (0 == strncmp("-h", argv[i], 2) ||                    \
+                   0 == strncmp("--help", argv[i], 6)) {                \
+            greatest_usage(argv[0]);                                    \
+            exit(EXIT_SUCCESS);                                         \
+        } else if (0 == strncmp("--", argv[i], 2)) {                    \
+            break;                                                      \
+        } else {                                                        \
+            fprintf(GREATEST_STDOUT,                                    \
+                "Unknown argument '%s'\n", argv[i]);                    \
+            greatest_usage(argv[0]);                                    \
+            exit(EXIT_FAILURE);                                         \
+        }                                                               \
+    }                                                                   \
+}                                                                       \
+                                                                        \
+int greatest_all_passed(void) { return (greatest_info.failed == 0); }   \
+                                                                        \
+void greatest_set_test_filter(const char *name) {                       \
+    greatest_info.test_filter = name;                                   \
+}                                                                       \
+                                                                        \
+void greatest_set_suite_filter(const char *name) {                      \
+    greatest_info.suite_filter = name;                                  \
+}                                                                       \
+                                                                        \
+void greatest_get_report(struct greatest_report_t *report) {            \
+    if (report) {                                                       \
+        report->passed = greatest_info.passed;                          \
+        report->failed = greatest_info.failed;                          \
+        report->skipped = greatest_info.skipped;                        \
+        report->assertions = greatest_info.assertions;                  \
+    }                                                                   \
+}                                                                       \
+                                                                        \
+unsigned int greatest_get_verbosity(void) {                             \
+    return greatest_info.verbosity;                                     \
+}                                                                       \
+                                                                        \
+void greatest_set_verbosity(unsigned int verbosity) {                   \
+    greatest_info.verbosity = (unsigned char)verbosity;                 \
+}                                                                       \
+                                                                        \
+void greatest_set_flag(greatest_flag_t flag) {                          \
+    greatest_info.flags |= flag;                                        \
+}                                                                       \
+                                                                        \
+void GREATEST_SET_SETUP_CB(greatest_setup_cb *cb, void *udata) {        \
+    greatest_info.setup = cb;                                           \
+    greatest_info.setup_udata = udata;                                  \
+}                                                                       \
+                                                                        \
+void GREATEST_SET_TEARDOWN_CB(greatest_teardown_cb *cb,                 \
+                                    void *udata) {                      \
+    greatest_info.teardown = cb;                                        \
+    greatest_info.teardown_udata = udata;                               \
+}                                                                       \
+                                                                        \
+static int greatest_string_equal_cb(const void *exp, const void *got,   \
+    void *udata) {                                                      \
+    size_t *size = (size_t *)udata;                                     \
+    return (size != NULL                                                \
+        ? (0 == strncmp((const char *)exp, (const char *)got, *size))   \
+        : (0 == strcmp((const char *)exp, (const char *)got)));         \
+}                                                                       \
+                                                                        \
+static int greatest_string_printf_cb(const void *t, void *udata) {      \
+    (void)udata; /* note: does not check \0 termination. */             \
+    return fprintf(GREATEST_STDOUT, "%s", (const char *)t);             \
+}                                                                       \
+                                                                        \
+greatest_type_info greatest_type_info_string = {                        \
+    greatest_string_equal_cb,                                           \
+    greatest_string_printf_cb,                                          \
+};                                                                      \
+                                                                        \
+static int greatest_memory_equal_cb(const void *exp, const void *got,   \
+    void *udata) {                                                      \
+    greatest_memory_cmp_env *env = (greatest_memory_cmp_env *)udata;    \
+    return (0 == memcmp(exp, got, env->size));                          \
+}                                                                       \
+                                                                        \
+static int greatest_memory_printf_cb(const void *t, void *udata) {      \
+    greatest_memory_cmp_env *env = (greatest_memory_cmp_env *)udata;    \
+    unsigned char *buf = (unsigned char *)t, diff_mark = ' ';           \
+    FILE *out = GREATEST_STDOUT;                                        \
+    size_t i, line_i, line_len = 0;                                     \
+    int len = 0;   /* format hexdump with differences highlighted */    \
+    for (i = 0; i < env->size; i+= line_len) {                          \
+        diff_mark = ' ';                                                \
+        line_len = env->size - i;                                       \
+        if (line_len > 16) { line_len = 16; }                           \
+        for (line_i = i; line_i < i + line_len; line_i++) {             \
+            if (env->exp[line_i] != env->got[line_i]) diff_mark = 'X';  \
+        }                                                               \
+        len += fprintf(out, "\n%04x %c ", (unsigned int)i, diff_mark);  \
+        for (line_i = i; line_i < i + line_len; line_i++) {             \
+            int m = env->exp[line_i] == env->got[line_i]; /* match? */  \
+            len += fprintf(out, "%02x%c", buf[line_i], m ? ' ' : '<');  \
+        }                                                               \
+        for (line_i = 0; line_i < 16 - line_len; line_i++) {            \
+            len += fprintf(out, "   ");                                 \
+        }                                                               \
+        fprintf(out, " ");                                              \
+        for (line_i = i; line_i < i + line_len; line_i++) {             \
+            unsigned char c = buf[line_i];                              \
+            len += fprintf(out, "%c", isprint(c) ? c : '.');            \
+        }                                                               \
+    }                                                                   \
+    len += fprintf(out, "\n");                                          \
+    return len;                                                         \
+}                                                                       \
+                                                                        \
+greatest_type_info greatest_type_info_memory = {                        \
+    greatest_memory_equal_cb,                                           \
+    greatest_memory_printf_cb,                                          \
+};                                                                      \
+                                                                        \
+greatest_run_info greatest_info
+
+/* Init internals. */
+#define GREATEST_INIT()                                                 \
+    do {                                                                \
+        /* Suppress unused function warning if features aren't used */  \
+        (void)greatest_run_suite;                                       \
+        (void)greatest_parse_args;                                      \
+                                                                        \
+        memset(&greatest_info, 0, sizeof(greatest_info));               \
+        greatest_info.width = GREATEST_DEFAULT_WIDTH;                   \
+        GREATEST_SET_TIME(greatest_info.begin);                         \
+    } while (0)                                                         \
+
+/* Handle command-line arguments, etc. */
+#define GREATEST_MAIN_BEGIN()                                           \
+    do {                                                                \
+        GREATEST_INIT();                                                \
+        greatest_parse_args(argc, argv);                                \
+    } while (0)
+
+/* Report passes, failures, skipped tests, the number of
+ * assertions, and the overall run time. */
+#define GREATEST_PRINT_REPORT()                                         \
+    do {                                                                \
+        if (!GREATEST_LIST_ONLY()) {                                    \
+            update_counts_and_reset_suite();                            \
+            GREATEST_SET_TIME(greatest_info.end);                       \
+            fprintf(GREATEST_STDOUT,                                    \
+                "\nTotal: %u test%s",                                   \
+                greatest_info.tests_run,                                \
+                greatest_info.tests_run == 1 ? "" : "s");               \
+            GREATEST_CLOCK_DIFF(greatest_info.begin,                    \
+                greatest_info.end);                                     \
+            fprintf(GREATEST_STDOUT, ", %u assertion%s\n",              \
+                greatest_info.assertions,                               \
+                greatest_info.assertions == 1 ? "" : "s");              \
+            fprintf(GREATEST_STDOUT,                                    \
+                "Pass: %u, fail: %u, skip: %u.\n",                      \
+                greatest_info.passed,                                   \
+                greatest_info.failed, greatest_info.skipped);           \
+        }                                                               \
+    } while (0)
+
+/* Report results, exit with exit status based on results. */
+#define GREATEST_MAIN_END()                                             \
+    do {                                                                \
+        GREATEST_PRINT_REPORT();                                        \
+        return (greatest_all_passed() ? EXIT_SUCCESS : EXIT_FAILURE);   \
+    } while (0)
+
+/* Make abbreviations without the GREATEST_ prefix for the
+ * most commonly used symbols. */
+#if GREATEST_USE_ABBREVS
+#define TEST           GREATEST_TEST
+#define SUITE          GREATEST_SUITE
+#define SUITE_EXTERN   GREATEST_SUITE_EXTERN
+#define RUN_TEST       GREATEST_RUN_TEST
+#define RUN_TEST1      GREATEST_RUN_TEST1
+#define RUN_SUITE      GREATEST_RUN_SUITE
+#define IGNORE_TEST    GREATEST_IGNORE_TEST
+#define ASSERT         GREATEST_ASSERT
+#define ASSERTm        GREATEST_ASSERTm
+#define ASSERT_FALSE   GREATEST_ASSERT_FALSE
+#define ASSERT_EQ      GREATEST_ASSERT_EQ
+#define ASSERT_EQ_FMT  GREATEST_ASSERT_EQ_FMT
+#define ASSERT_IN_RANGE GREATEST_ASSERT_IN_RANGE
+#define ASSERT_EQUAL_T GREATEST_ASSERT_EQUAL_T
+#define ASSERT_STR_EQ  GREATEST_ASSERT_STR_EQ
+#define ASSERT_STRN_EQ GREATEST_ASSERT_STRN_EQ
+#define ASSERT_MEM_EQ  GREATEST_ASSERT_MEM_EQ
+#define ASSERT_ENUM_EQ GREATEST_ASSERT_ENUM_EQ
+#define ASSERT_FALSEm  GREATEST_ASSERT_FALSEm
+#define ASSERT_EQm     GREATEST_ASSERT_EQm
+#define ASSERT_EQ_FMTm GREATEST_ASSERT_EQ_FMTm
+#define ASSERT_IN_RANGEm GREATEST_ASSERT_IN_RANGEm
+#define ASSERT_EQUAL_Tm GREATEST_ASSERT_EQUAL_Tm
+#define ASSERT_STR_EQm GREATEST_ASSERT_STR_EQm
+#define ASSERT_STRN_EQm GREATEST_ASSERT_STRN_EQm
+#define ASSERT_MEM_EQm GREATEST_ASSERT_MEM_EQm
+#define ASSERT_ENUM_EQm GREATEST_ASSERT_ENUM_EQm
+#define PASS           GREATEST_PASS
+#define FAIL           GREATEST_FAIL
+#define SKIP           GREATEST_SKIP
+#define PASSm          GREATEST_PASSm
+#define FAILm          GREATEST_FAILm
+#define SKIPm          GREATEST_SKIPm
+#define SET_SETUP      GREATEST_SET_SETUP_CB
+#define SET_TEARDOWN   GREATEST_SET_TEARDOWN_CB
+#define CHECK_CALL     GREATEST_CHECK_CALL
+
+#ifdef GREATEST_VA_ARGS
+#define RUN_TESTp      GREATEST_RUN_TESTp
+#endif
+
+#if GREATEST_USE_LONGJMP
+#define ASSERT_OR_LONGJMP  GREATEST_ASSERT_OR_LONGJMP
+#define ASSERT_OR_LONGJMPm GREATEST_ASSERT_OR_LONGJMPm
+#define FAIL_WITH_LONGJMP  GREATEST_FAIL_WITH_LONGJMP
+#define FAIL_WITH_LONGJMPm GREATEST_FAIL_WITH_LONGJMPm
+#endif
+
+#endif /* USE_ABBREVS */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/cpp/src/plasma/common/thirdparty/sha256.c b/cpp/src/plasma/common/thirdparty/sha256.c
new file mode 100644
index 000000000000..eb9c5c0733e7
--- /dev/null
+++ b/cpp/src/plasma/common/thirdparty/sha256.c
@@ -0,0 +1,158 @@
+/*********************************************************************
+* Filename:   sha256.c
+* Author:     Brad Conte (brad AT bradconte.com)
+* Copyright:
+* Disclaimer: This code is presented "as is" without any guarantees.
+* Details:    Implementation of the SHA-256 hashing algorithm.
+              SHA-256 is one of the three algorithms in the SHA2
+              specification. The others, SHA-384 and SHA-512, are not
+              offered in this implementation.
+              Algorithm specification can be found here:
+               * http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf
+              This implementation uses little endian byte order.
+*********************************************************************/
+
+/*************************** HEADER FILES ***************************/
+#include <stdlib.h>
+#include <memory.h>
+#include "sha256.h"
+
+/****************************** MACROS ******************************/
+#define ROTLEFT(a,b) (((a) << (b)) | ((a) >> (32-(b))))
+#define ROTRIGHT(a,b) (((a) >> (b)) | ((a) << (32-(b))))
+
+#define CH(x,y,z) (((x) & (y)) ^ (~(x) & (z)))
+#define MAJ(x,y,z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
+#define EP0(x) (ROTRIGHT(x,2) ^ ROTRIGHT(x,13) ^ ROTRIGHT(x,22))
+#define EP1(x) (ROTRIGHT(x,6) ^ ROTRIGHT(x,11) ^ ROTRIGHT(x,25))
+#define SIG0(x) (ROTRIGHT(x,7) ^ ROTRIGHT(x,18) ^ ((x) >> 3))
+#define SIG1(x) (ROTRIGHT(x,17) ^ ROTRIGHT(x,19) ^ ((x) >> 10))
+
+/**************************** VARIABLES *****************************/
+static const WORD k[64] = {
+	0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
+	0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
+	0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
+	0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
+	0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
+	0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
+	0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
+	0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
+};
+
+/*********************** FUNCTION DEFINITIONS ***********************/
+void sha256_transform(SHA256_CTX *ctx, const BYTE data[])
+{
+	WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];
+
+	for (i = 0, j = 0; i < 16; ++i, j += 4)
+		m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
+	for ( ; i < 64; ++i)
+		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
+
+	a = ctx->state[0];
+	b = ctx->state[1];
+	c = ctx->state[2];
+	d = ctx->state[3];
+	e = ctx->state[4];
+	f = ctx->state[5];
+	g = ctx->state[6];
+	h = ctx->state[7];
+
+	for (i = 0; i < 64; ++i) {
+		t1 = h + EP1(e) + CH(e,f,g) + k[i] + m[i];
+		t2 = EP0(a) + MAJ(a,b,c);
+		h = g;
+		g = f;
+		f = e;
+		e = d + t1;
+		d = c;
+		c = b;
+		b = a;
+		a = t1 + t2;
+	}
+
+	ctx->state[0] += a;
+	ctx->state[1] += b;
+	ctx->state[2] += c;
+	ctx->state[3] += d;
+	ctx->state[4] += e;
+	ctx->state[5] += f;
+	ctx->state[6] += g;
+	ctx->state[7] += h;
+}
+
+void sha256_init(SHA256_CTX *ctx)
+{
+	ctx->datalen = 0;
+	ctx->bitlen = 0;
+	ctx->state[0] = 0x6a09e667;
+	ctx->state[1] = 0xbb67ae85;
+	ctx->state[2] = 0x3c6ef372;
+	ctx->state[3] = 0xa54ff53a;
+	ctx->state[4] = 0x510e527f;
+	ctx->state[5] = 0x9b05688c;
+	ctx->state[6] = 0x1f83d9ab;
+	ctx->state[7] = 0x5be0cd19;
+}
+
+void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len)
+{
+	WORD i;
+
+	for (i = 0; i < len; ++i) {
+		ctx->data[ctx->datalen] = data[i];
+		ctx->datalen++;
+		if (ctx->datalen == 64) {
+			sha256_transform(ctx, ctx->data);
+			ctx->bitlen += 512;
+			ctx->datalen = 0;
+		}
+	}
+}
+
+void sha256_final(SHA256_CTX *ctx, BYTE hash[])
+{
+	WORD i;
+
+	i = ctx->datalen;
+
+	// Pad whatever data is left in the buffer.
+	if (ctx->datalen < 56) {
+		ctx->data[i++] = 0x80;
+		while (i < 56)
+			ctx->data[i++] = 0x00;
+	}
+	else {
+		ctx->data[i++] = 0x80;
+		while (i < 64)
+			ctx->data[i++] = 0x00;
+		sha256_transform(ctx, ctx->data);
+		memset(ctx->data, 0, 56);
+	}
+
+	// Append to the padding the total message's length in bits and transform.
+	ctx->bitlen += ctx->datalen * 8;
+	ctx->data[63] = ctx->bitlen;
+	ctx->data[62] = ctx->bitlen >> 8;
+	ctx->data[61] = ctx->bitlen >> 16;
+	ctx->data[60] = ctx->bitlen >> 24;
+	ctx->data[59] = ctx->bitlen >> 32;
+	ctx->data[58] = ctx->bitlen >> 40;
+	ctx->data[57] = ctx->bitlen >> 48;
+	ctx->data[56] = ctx->bitlen >> 56;
+	sha256_transform(ctx, ctx->data);
+
+	// Since this implementation uses little endian byte ordering and SHA uses big endian,
+	// reverse all the bytes when copying the final state to the output hash.
+	for (i = 0; i < 4; ++i) {
+		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
+	}
+}
diff --git a/cpp/src/plasma/common/thirdparty/sha256.h b/cpp/src/plasma/common/thirdparty/sha256.h
new file mode 100644
index 000000000000..7123a30dd496
--- /dev/null
+++ b/cpp/src/plasma/common/thirdparty/sha256.h
@@ -0,0 +1,34 @@
+/*********************************************************************
+* Filename:   sha256.h
+* Author:     Brad Conte (brad AT bradconte.com)
+* Copyright:
+* Disclaimer: This code is presented "as is" without any guarantees.
+* Details:    Defines the API for the corresponding SHA1 implementation.
+*********************************************************************/
+
+#ifndef SHA256_H
+#define SHA256_H
+
+/*************************** HEADER FILES ***************************/
+#include <stddef.h>
+
+/****************************** MACROS ******************************/
+#define SHA256_BLOCK_SIZE 32            // SHA256 outputs a 32 byte digest
+
+/**************************** DATA TYPES ****************************/
+typedef unsigned char BYTE;             // 8-bit byte
+typedef unsigned int  WORD;             // 32-bit word, change to "long" for 16-bit machines
+
+typedef struct {
+	BYTE data[64];
+	WORD datalen;
+	unsigned long long bitlen;
+	WORD state[8];
+} SHA256_CTX;
+
+/*********************** FUNCTION DECLARATIONS **********************/
+void sha256_init(SHA256_CTX *ctx);
+void sha256_update(SHA256_CTX *ctx, const BYTE data[], size_t len);
+void sha256_final(SHA256_CTX *ctx, BYTE hash[]);
+
+#endif   // SHA256_H
diff --git a/cpp/src/plasma/common/thirdparty/utarray.h b/cpp/src/plasma/common/thirdparty/utarray.h
new file mode 100644
index 000000000000..979e99e98eea
--- /dev/null
+++ b/cpp/src/plasma/common/thirdparty/utarray.h
@@ -0,0 +1,238 @@
+/*
+Copyright (c) 2008-2016, Troy D. Hanson   http://troydhanson.github.com/uthash/
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/* a dynamic array implementation using macros
+ */
+#ifndef UTARRAY_H
+#define UTARRAY_H
+
+#define UTARRAY_VERSION 2.0.1
+
+#ifdef __GNUC__
+#define _UNUSED_ __attribute__ ((__unused__))
+#else
+#define _UNUSED_
+#endif
+
+#include <stddef.h>  /* size_t */
+#include <string.h>  /* memset, etc */
+#include <stdlib.h>  /* exit */
+
+#ifndef oom
+#define oom() exit(-1)
+#endif
+
+typedef void (ctor_f)(void *dst, const void *src);
+typedef void (dtor_f)(void *elt);
+typedef void (init_f)(void *elt);
+typedef struct {
+    size_t sz;
+    init_f *init;
+    ctor_f *copy;
+    dtor_f *dtor;
+} UT_icd;
+
+typedef struct {
+    unsigned i,n;/* i: index of next available slot, n: num slots */
+    UT_icd icd;  /* initializer, copy and destructor functions */
+    char *d;     /* n slots of size icd->sz*/
+} UT_array;
+
+#define utarray_init(a,_icd) do {                                             \
+  memset(a,0,sizeof(UT_array));                                               \
+  (a)->icd = *(_icd);                                                         \
+} while(0)
+
+#define utarray_done(a) do {                                                  \
+  if ((a)->n) {                                                               \
+    if ((a)->icd.dtor) {                                                      \
+      unsigned _ut_i;                                                         \
+      for(_ut_i=0; _ut_i < (a)->i; _ut_i++) {                                 \
+        (a)->icd.dtor(utarray_eltptr(a,_ut_i));                               \
+      }                                                                       \
+    }                                                                         \
+    free((a)->d);                                                             \
+  }                                                                           \
+  (a)->n=0;                                                                   \
+} while(0)
+
+#define utarray_new(a,_icd) do {                                              \
+  (a) = (UT_array*)malloc(sizeof(UT_array));                                  \
+  if ((a) == NULL) oom();                                                     \
+  utarray_init(a,_icd);                                                       \
+} while(0)
+
+#define utarray_free(a) do {                                                  \
+  utarray_done(a);                                                            \
+  free(a);                                                                    \
+} while(0)
+
+#define utarray_reserve(a,by) do {                                            \
+  if (((a)->i+(by)) > (a)->n) {                                               \
+    char *utarray_tmp;                                                        \
+    while (((a)->i+(by)) > (a)->n) { (a)->n = ((a)->n ? (2*(a)->n) : 8); }    \
+    utarray_tmp=(char*)realloc((a)->d, (a)->n*(a)->icd.sz);                   \
+    if (utarray_tmp == NULL) oom();                                           \
+    (a)->d=utarray_tmp;                                                       \
+  }                                                                           \
+} while(0)
+
+#define utarray_push_back(a,p) do {                                           \
+  utarray_reserve(a,1);                                                       \
+  if ((a)->icd.copy) { (a)->icd.copy( _utarray_eltptr(a,(a)->i++), p); }      \
+  else { memcpy(_utarray_eltptr(a,(a)->i++), p, (a)->icd.sz); };              \
+} while(0)
+
+#define utarray_pop_back(a) do {                                              \
+  if ((a)->icd.dtor) { (a)->icd.dtor( _utarray_eltptr(a,--((a)->i))); }       \
+  else { (a)->i--; }                                                          \
+} while(0)
+
+#define utarray_extend_back(a) do {                                           \
+  utarray_reserve(a,1);                                                       \
+  if ((a)->icd.init) { (a)->icd.init(_utarray_eltptr(a,(a)->i)); }            \
+  else { memset(_utarray_eltptr(a,(a)->i),0,(a)->icd.sz); }                   \
+  (a)->i++;                                                                   \
+} while(0)
+
+#define utarray_len(a) ((a)->i)
+
+#define utarray_eltptr(a,j) (((j) < (a)->i) ? _utarray_eltptr(a,j) : NULL)
+#define _utarray_eltptr(a,j) ((a)->d + ((a)->icd.sz * (j)))
+
+#define utarray_insert(a,p,j) do {                                            \
+  if ((j) > (a)->i) utarray_resize(a,j);                                      \
+  utarray_reserve(a,1);                                                       \
+  if ((j) < (a)->i) {                                                         \
+    memmove( _utarray_eltptr(a,(j)+1), _utarray_eltptr(a,j),                  \
+             ((a)->i - (j))*((a)->icd.sz));                                   \
+  }                                                                           \
+  if ((a)->icd.copy) { (a)->icd.copy( _utarray_eltptr(a,j), p); }             \
+  else { memcpy(_utarray_eltptr(a,j), p, (a)->icd.sz); };                     \
+  (a)->i++;                                                                   \
+} while(0)
+
+#define utarray_inserta(a,w,j) do {                                           \
+  if (utarray_len(w) == 0) break;                                             \
+  if ((j) > (a)->i) utarray_resize(a,j);                                      \
+  utarray_reserve(a,utarray_len(w));                                          \
+  if ((j) < (a)->i) {                                                         \
+    memmove(_utarray_eltptr(a,(j)+utarray_len(w)),                            \
+            _utarray_eltptr(a,j),                                             \
+            ((a)->i - (j))*((a)->icd.sz));                                    \
+  }                                                                           \
+  if ((a)->icd.copy) {                                                        \
+    unsigned _ut_i;                                                           \
+    for(_ut_i=0;_ut_i<(w)->i;_ut_i++) {                                       \
+      (a)->icd.copy(_utarray_eltptr(a, (j) + _ut_i), _utarray_eltptr(w, _ut_i)); \
+    }                                                                         \
+  } else {                                                                    \
+    memcpy(_utarray_eltptr(a,j), _utarray_eltptr(w,0),                        \
+           utarray_len(w)*((a)->icd.sz));                                     \
+  }                                                                           \
+  (a)->i += utarray_len(w);                                                   \
+} while(0)
+
+#define utarray_resize(dst,num) do {                                          \
+  unsigned _ut_i;                                                             \
+  if ((dst)->i > (unsigned)(num)) {                                           \
+    if ((dst)->icd.dtor) {                                                    \
+      for (_ut_i = (num); _ut_i < (dst)->i; ++_ut_i) {                        \
+        (dst)->icd.dtor(_utarray_eltptr(dst, _ut_i));                         \
+      }                                                                       \
+    }                                                                         \
+  } else if ((dst)->i < (unsigned)(num)) {                                    \
+    utarray_reserve(dst, (num) - (dst)->i);                                   \
+    if ((dst)->icd.init) {                                                    \
+      for (_ut_i = (dst)->i; _ut_i < (unsigned)(num); ++_ut_i) {              \
+        (dst)->icd.init(_utarray_eltptr(dst, _ut_i));                         \
+      }                                                                       \
+    } else {                                                                  \
+      memset(_utarray_eltptr(dst, (dst)->i), 0, (dst)->icd.sz*((num) - (dst)->i)); \
+    }                                                                         \
+  }                                                                           \
+  (dst)->i = (num);                                                           \
+} while(0)
+
+#define utarray_concat(dst,src) do {                                          \
+  utarray_inserta(dst, src, utarray_len(dst));                                \
+} while(0)
+
+#define utarray_erase(a,pos,len) do {                                         \
+  if ((a)->icd.dtor) {                                                        \
+    unsigned _ut_i;                                                           \
+    for (_ut_i = 0; _ut_i < (len); _ut_i++) {                                 \
+      (a)->icd.dtor(utarray_eltptr(a, (pos) + _ut_i));                        \
+    }                                                                         \
+  }                                                                           \
+  if ((a)->i > ((pos) + (len))) {                                             \
+    memmove(_utarray_eltptr(a, pos), _utarray_eltptr(a, (pos) + (len)),       \
+            ((a)->i - ((pos) + (len))) * (a)->icd.sz);                        \
+  }                                                                           \
+  (a)->i -= (len);                                                            \
+} while(0)
+
+#define utarray_renew(a,u) do {                                               \
+  if (a) utarray_clear(a);                                                    \
+  else utarray_new(a, u);                                                     \
+} while(0)
+
+#define utarray_clear(a) do {                                                 \
+  if ((a)->i > 0) {                                                           \
+    if ((a)->icd.dtor) {                                                      \
+      unsigned _ut_i;                                                         \
+      for(_ut_i=0; _ut_i < (a)->i; _ut_i++) {                                 \
+        (a)->icd.dtor(_utarray_eltptr(a, _ut_i));                             \
+      }                                                                       \
+    }                                                                         \
+    (a)->i = 0;                                                               \
+  }                                                                           \
+} while(0)
+
+#define utarray_sort(a,cmp) do {                                              \
+  qsort((a)->d, (a)->i, (a)->icd.sz, cmp);                                    \
+} while(0)
+
+#define utarray_find(a,v,cmp) bsearch((v),(a)->d,(a)->i,(a)->icd.sz,cmp)
+
+#define utarray_front(a) (((a)->i) ? (_utarray_eltptr(a,0)) : NULL)
+#define utarray_next(a,e) (((e)==NULL) ? utarray_front(a) : ((((a)->i) > (utarray_eltidx(a,e)+1)) ? _utarray_eltptr(a,utarray_eltidx(a,e)+1) : NULL))
+#define utarray_prev(a,e) (((e)==NULL) ? utarray_back(a) : ((utarray_eltidx(a,e) > 0) ? _utarray_eltptr(a,utarray_eltidx(a,e)-1) : NULL))
+#define utarray_back(a) (((a)->i) ? (_utarray_eltptr(a,(a)->i-1)) : NULL)
+#define utarray_eltidx(a,e) (((char*)(e) >= (a)->d) ? (((char*)(e) - (a)->d)/(a)->icd.sz) : -1)
+
+/* last we pre-define a few icd for common utarrays of ints and strings */
+static void utarray_str_cpy(void *dst, const void *src) {
+  char **_src = (char**)src, **_dst = (char**)dst;
+  *_dst = (*_src == NULL) ? NULL : strdup(*_src);
+}
+static void utarray_str_dtor(void *elt) {
+  char **eltc = (char**)elt;
+  if (*eltc != NULL) free(*eltc);
+}
+static const UT_icd ut_str_icd _UNUSED_ = {sizeof(char*),NULL,utarray_str_cpy,utarray_str_dtor};
+static const UT_icd ut_int_icd _UNUSED_ = {sizeof(int),NULL,NULL,NULL};
+static const UT_icd ut_ptr_icd _UNUSED_ = {sizeof(void*),NULL,NULL,NULL};
+
+
+#endif /* UTARRAY_H */
diff --git a/cpp/src/plasma/common/thirdparty/uthash.h b/cpp/src/plasma/common/thirdparty/uthash.h
new file mode 100644
index 000000000000..45d1f9fc12a1
--- /dev/null
+++ b/cpp/src/plasma/common/thirdparty/uthash.h
@@ -0,0 +1,1074 @@
+/*
+Copyright (c) 2003-2016, Troy D. Hanson     http://troydhanson.github.com/uthash/
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef UTHASH_H
+#define UTHASH_H
+
+#define UTHASH_VERSION 2.0.1
+
+#include <string.h>   /* memcmp,strlen */
+#include <stddef.h>   /* ptrdiff_t */
+#include <stdlib.h>   /* exit() */
+
+/* These macros use decltype or the earlier __typeof GNU extension.
+   As decltype is only available in newer compilers (VS2010 or gcc 4.3+
+   when compiling c++ source) this code uses whatever method is needed
+   or, for VS2008 where neither is available, uses casting workarounds. */
+#if defined(_MSC_VER)   /* MS compiler */
+#if _MSC_VER >= 1600 && defined(__cplusplus)  /* VS2010 or newer in C++ mode */
+#define DECLTYPE(x) (decltype(x))
+#else                   /* VS2008 or older (or VS2010 in C mode) */
+#define NO_DECLTYPE
+#define DECLTYPE(x)
+#endif
+#elif defined(__BORLANDC__) || defined(__LCC__) || defined(__WATCOMC__)
+#define NO_DECLTYPE
+#define DECLTYPE(x)
+#else                   /* GNU, Sun and other compilers */
+#define DECLTYPE(x) (__typeof(x))
+#endif
+
+#ifdef NO_DECLTYPE
+#define DECLTYPE_ASSIGN(dst,src)                                                 \
+do {                                                                             \
+  char **_da_dst = (char**)(&(dst));                                             \
+  *_da_dst = (char*)(src);                                                       \
+} while (0)
+#else
+#define DECLTYPE_ASSIGN(dst,src)                                                 \
+do {                                                                             \
+  (dst) = DECLTYPE(dst)(src);                                                    \
+} while (0)
+#endif
+
+/* a number of the hash function use uint32_t which isn't defined on Pre VS2010 */
+#if defined(_WIN32)
+#if defined(_MSC_VER) && _MSC_VER >= 1600
+#include <stdint.h>
+#elif defined(__WATCOMC__) || defined(__MINGW32__) || defined(__CYGWIN__)
+#include <stdint.h>
+#else
+typedef unsigned int uint32_t;
+typedef unsigned char uint8_t;
+#endif
+#elif defined(__GNUC__) && !defined(__VXWORKS__)
+#include <stdint.h>
+#else
+typedef unsigned int uint32_t;
+typedef unsigned char uint8_t;
+#endif
+
+#ifndef uthash_fatal
+#define uthash_fatal(msg) exit(-1)        /* fatal error (out of memory,etc) */
+#endif
+#ifndef uthash_malloc
+#define uthash_malloc(sz) malloc(sz)      /* malloc fcn                      */
+#endif
+#ifndef uthash_free
+#define uthash_free(ptr,sz) free(ptr)     /* free fcn                        */
+#endif
+#ifndef uthash_strlen
+#define uthash_strlen(s) strlen(s)
+#endif
+#ifndef uthash_memcmp
+#define uthash_memcmp(a,b,n) memcmp(a,b,n)
+#endif
+
+#ifndef uthash_noexpand_fyi
+#define uthash_noexpand_fyi(tbl)          /* can be defined to log noexpand  */
+#endif
+#ifndef uthash_expand_fyi
+#define uthash_expand_fyi(tbl)            /* can be defined to log expands   */
+#endif
+
+/* initial number of buckets */
+#define HASH_INITIAL_NUM_BUCKETS 32U     /* initial number of buckets        */
+#define HASH_INITIAL_NUM_BUCKETS_LOG2 5U /* lg2 of initial number of buckets */
+#define HASH_BKT_CAPACITY_THRESH 10U     /* expand when bucket count reaches */
+
+/* calculate the element whose hash handle address is hhp */
+#define ELMT_FROM_HH(tbl,hhp) ((void*)(((char*)(hhp)) - ((tbl)->hho)))
+/* calculate the hash handle from element address elp */
+#define HH_FROM_ELMT(tbl,elp) ((UT_hash_handle *)(((char*)(elp)) + ((tbl)->hho)))
+
+#define HASH_VALUE(keyptr,keylen,hashv)                                          \
+do {                                                                             \
+  HASH_FCN(keyptr, keylen, hashv);                                               \
+} while (0)
+
+#define HASH_FIND_BYHASHVALUE(hh,head,keyptr,keylen,hashval,out)                 \
+do {                                                                             \
+  (out) = NULL;                                                                  \
+  if (head) {                                                                    \
+    unsigned _hf_bkt;                                                            \
+    HASH_TO_BKT(hashval, (head)->hh.tbl->num_buckets, _hf_bkt);                  \
+    if (HASH_BLOOM_TEST((head)->hh.tbl, hashval) != 0) {                         \
+      HASH_FIND_IN_BKT((head)->hh.tbl, hh, (head)->hh.tbl->buckets[ _hf_bkt ], keyptr, keylen, hashval, out); \
+    }                                                                            \
+  }                                                                              \
+} while (0)
+
+#define HASH_FIND(hh,head,keyptr,keylen,out)                                     \
+do {                                                                             \
+  unsigned _hf_hashv;                                                            \
+  HASH_VALUE(keyptr, keylen, _hf_hashv);                                         \
+  HASH_FIND_BYHASHVALUE(hh, head, keyptr, keylen, _hf_hashv, out);               \
+} while (0)
+
+#ifdef HASH_BLOOM
+#define HASH_BLOOM_BITLEN (1UL << HASH_BLOOM)
+#define HASH_BLOOM_BYTELEN (HASH_BLOOM_BITLEN/8UL) + (((HASH_BLOOM_BITLEN%8UL)!=0UL) ? 1UL : 0UL)
+#define HASH_BLOOM_MAKE(tbl)                                                     \
+do {                                                                             \
+  (tbl)->bloom_nbits = HASH_BLOOM;                                               \
+  (tbl)->bloom_bv = (uint8_t*)uthash_malloc(HASH_BLOOM_BYTELEN);                 \
+  if (!((tbl)->bloom_bv))  { uthash_fatal( "out of memory"); }                   \
+  memset((tbl)->bloom_bv, 0, HASH_BLOOM_BYTELEN);                                \
+  (tbl)->bloom_sig = HASH_BLOOM_SIGNATURE;                                       \
+} while (0)
+
+#define HASH_BLOOM_FREE(tbl)                                                     \
+do {                                                                             \
+  uthash_free((tbl)->bloom_bv, HASH_BLOOM_BYTELEN);                              \
+} while (0)
+
+#define HASH_BLOOM_BITSET(bv,idx) (bv[(idx)/8U] |= (1U << ((idx)%8U)))
+#define HASH_BLOOM_BITTEST(bv,idx) (bv[(idx)/8U] & (1U << ((idx)%8U)))
+
+#define HASH_BLOOM_ADD(tbl,hashv)                                                \
+  HASH_BLOOM_BITSET((tbl)->bloom_bv, (hashv & (uint32_t)((1ULL << (tbl)->bloom_nbits) - 1U)))
+
+#define HASH_BLOOM_TEST(tbl,hashv)                                               \
+  HASH_BLOOM_BITTEST((tbl)->bloom_bv, (hashv & (uint32_t)((1ULL << (tbl)->bloom_nbits) - 1U)))
+
+#else
+#define HASH_BLOOM_MAKE(tbl)
+#define HASH_BLOOM_FREE(tbl)
+#define HASH_BLOOM_ADD(tbl,hashv)
+#define HASH_BLOOM_TEST(tbl,hashv) (1)
+#define HASH_BLOOM_BYTELEN 0U
+#endif
+
+#define HASH_MAKE_TABLE(hh,head)                                                 \
+do {                                                                             \
+  (head)->hh.tbl = (UT_hash_table*)uthash_malloc(                                \
+                  sizeof(UT_hash_table));                                        \
+  if (!((head)->hh.tbl))  { uthash_fatal( "out of memory"); }                    \
+  memset((head)->hh.tbl, 0, sizeof(UT_hash_table));                              \
+  (head)->hh.tbl->tail = &((head)->hh);                                          \
+  (head)->hh.tbl->num_buckets = HASH_INITIAL_NUM_BUCKETS;                        \
+  (head)->hh.tbl->log2_num_buckets = HASH_INITIAL_NUM_BUCKETS_LOG2;              \
+  (head)->hh.tbl->hho = (char*)(&(head)->hh) - (char*)(head);                    \
+  (head)->hh.tbl->buckets = (UT_hash_bucket*)uthash_malloc(                      \
+          HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket));               \
+  if (! (head)->hh.tbl->buckets) { uthash_fatal( "out of memory"); }             \
+  memset((head)->hh.tbl->buckets, 0,                                             \
+          HASH_INITIAL_NUM_BUCKETS*sizeof(struct UT_hash_bucket));               \
+  HASH_BLOOM_MAKE((head)->hh.tbl);                                               \
+  (head)->hh.tbl->signature = HASH_SIGNATURE;                                    \
+} while (0)
+
+#define HASH_REPLACE_BYHASHVALUE_INORDER(hh,head,fieldname,keylen_in,hashval,add,replaced,cmpfcn) \
+do {                                                                             \
+  (replaced) = NULL;                                                             \
+  HASH_FIND_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, replaced); \
+  if (replaced) {                                                                \
+     HASH_DELETE(hh, head, replaced);                                            \
+  }                                                                              \
+  HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, &((add)->fieldname), keylen_in, hashval, add, cmpfcn); \
+} while (0)
+
+#define HASH_REPLACE_BYHASHVALUE(hh,head,fieldname,keylen_in,hashval,add,replaced) \
+do {                                                                             \
+  (replaced) = NULL;                                                             \
+  HASH_FIND_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, replaced); \
+  if (replaced) {                                                                \
+     HASH_DELETE(hh, head, replaced);                                            \
+  }                                                                              \
+  HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, add); \
+} while (0)
+
+#define HASH_REPLACE(hh,head,fieldname,keylen_in,add,replaced)                   \
+do {                                                                             \
+  unsigned _hr_hashv;                                                            \
+  HASH_VALUE(&((add)->fieldname), keylen_in, _hr_hashv);                         \
+  HASH_REPLACE_BYHASHVALUE(hh, head, fieldname, keylen_in, _hr_hashv, add, replaced); \
+} while (0)
+
+#define HASH_REPLACE_INORDER(hh,head,fieldname,keylen_in,add,replaced,cmpfcn)    \
+do {                                                                             \
+  unsigned _hr_hashv;                                                            \
+  HASH_VALUE(&((add)->fieldname), keylen_in, _hr_hashv);                         \
+  HASH_REPLACE_BYHASHVALUE_INORDER(hh, head, fieldname, keylen_in, _hr_hashv, add, replaced, cmpfcn); \
+} while (0)
+
+#define HASH_APPEND_LIST(hh, head, add)                                          \
+do {                                                                             \
+  (add)->hh.next = NULL;                                                         \
+  (add)->hh.prev = ELMT_FROM_HH((head)->hh.tbl, (head)->hh.tbl->tail);           \
+  (head)->hh.tbl->tail->next = (add);                                            \
+  (head)->hh.tbl->tail = &((add)->hh);                                           \
+} while (0)
+
+#define HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh,head,keyptr,keylen_in,hashval,add,cmpfcn) \
+do {                                                                             \
+  unsigned _ha_bkt;                                                              \
+  (add)->hh.hashv = (hashval);                                                   \
+  (add)->hh.key = (char*) (keyptr);                                              \
+  (add)->hh.keylen = (unsigned) (keylen_in);                                     \
+  if (!(head)) {                                                                 \
+    (add)->hh.next = NULL;                                                       \
+    (add)->hh.prev = NULL;                                                       \
+    (head) = (add);                                                              \
+    HASH_MAKE_TABLE(hh, head);                                                   \
+  } else {                                                                       \
+    struct UT_hash_handle *_hs_iter = &(head)->hh;                               \
+    (add)->hh.tbl = (head)->hh.tbl;                                              \
+    do {                                                                         \
+      if (cmpfcn(DECLTYPE(head) ELMT_FROM_HH((head)->hh.tbl, _hs_iter), add) > 0) \
+        break;                                                                   \
+    } while ((_hs_iter = _hs_iter->next));                                       \
+    if (_hs_iter) {                                                              \
+      (add)->hh.next = _hs_iter;                                                 \
+      if (((add)->hh.prev = _hs_iter->prev)) {                                   \
+        HH_FROM_ELMT((head)->hh.tbl, _hs_iter->prev)->next = (add);              \
+      } else {                                                                   \
+        (head) = (add);                                                          \
+      }                                                                          \
+      _hs_iter->prev = (add);                                                    \
+    } else {                                                                     \
+      HASH_APPEND_LIST(hh, head, add);                                           \
+    }                                                                            \
+  }                                                                              \
+  (head)->hh.tbl->num_items++;                                                   \
+  HASH_TO_BKT(hashval, (head)->hh.tbl->num_buckets, _ha_bkt);                    \
+  HASH_ADD_TO_BKT((head)->hh.tbl->buckets[_ha_bkt], &(add)->hh);                 \
+  HASH_BLOOM_ADD((head)->hh.tbl, hashval);                                       \
+  HASH_EMIT_KEY(hh, head, keyptr, keylen_in);                                    \
+  HASH_FSCK(hh, head);                                                           \
+} while (0)
+
+#define HASH_ADD_KEYPTR_INORDER(hh,head,keyptr,keylen_in,add,cmpfcn)             \
+do {                                                                             \
+  unsigned _hs_hashv;                                                            \
+  HASH_VALUE(keyptr, keylen_in, _hs_hashv);                                      \
+  HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, keyptr, keylen_in, _hs_hashv, add, cmpfcn); \
+} while (0)
+
+#define HASH_ADD_BYHASHVALUE_INORDER(hh,head,fieldname,keylen_in,hashval,add,cmpfcn) \
+  HASH_ADD_KEYPTR_BYHASHVALUE_INORDER(hh, head, &((add)->fieldname), keylen_in, hashval, add, cmpfcn)
+
+#define HASH_ADD_INORDER(hh,head,fieldname,keylen_in,add,cmpfcn)                 \
+  HASH_ADD_KEYPTR_INORDER(hh, head, &((add)->fieldname), keylen_in, add, cmpfcn)
+
+#define HASH_ADD_KEYPTR_BYHASHVALUE(hh,head,keyptr,keylen_in,hashval,add)        \
+do {                                                                             \
+  unsigned _ha_bkt;                                                              \
+  (add)->hh.hashv = (hashval);                                                   \
+  (add)->hh.key = (char*) (keyptr);                                              \
+  (add)->hh.keylen = (unsigned) (keylen_in);                                     \
+  if (!(head)) {                                                                 \
+    (add)->hh.next = NULL;                                                       \
+    (add)->hh.prev = NULL;                                                       \
+    (head) = (add);                                                              \
+    HASH_MAKE_TABLE(hh, head);                                                   \
+  } else {                                                                       \
+    (add)->hh.tbl = (head)->hh.tbl;                                              \
+    HASH_APPEND_LIST(hh, head, add);                                             \
+  }                                                                              \
+  (head)->hh.tbl->num_items++;                                                   \
+  HASH_TO_BKT(hashval, (head)->hh.tbl->num_buckets, _ha_bkt);                    \
+  HASH_ADD_TO_BKT((head)->hh.tbl->buckets[_ha_bkt], &(add)->hh);                 \
+  HASH_BLOOM_ADD((head)->hh.tbl, hashval);                                       \
+  HASH_EMIT_KEY(hh, head, keyptr, keylen_in);                                    \
+  HASH_FSCK(hh, head);                                                           \
+} while (0)
+
+#define HASH_ADD_KEYPTR(hh,head,keyptr,keylen_in,add)                            \
+do {                                                                             \
+  unsigned _ha_hashv;                                                            \
+  HASH_VALUE(keyptr, keylen_in, _ha_hashv);                                      \
+  HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, keyptr, keylen_in, _ha_hashv, add);      \
+} while (0)
+
+#define HASH_ADD_BYHASHVALUE(hh,head,fieldname,keylen_in,hashval,add)            \
+  HASH_ADD_KEYPTR_BYHASHVALUE(hh, head, &((add)->fieldname), keylen_in, hashval, add)
+
+#define HASH_ADD(hh,head,fieldname,keylen_in,add)                                \
+  HASH_ADD_KEYPTR(hh, head, &((add)->fieldname), keylen_in, add)
+
+#define HASH_TO_BKT(hashv,num_bkts,bkt)                                          \
+do {                                                                             \
+  bkt = ((hashv) & ((num_bkts) - 1U));                                           \
+} while (0)
+
+/* delete "delptr" from the hash table.
+ * "the usual" patch-up process for the app-order doubly-linked-list.
+ * The use of _hd_hh_del below deserves special explanation.
+ * These used to be expressed using (delptr) but that led to a bug
+ * if someone used the same symbol for the head and deletee, like
+ *  HASH_DELETE(hh,users,users);
+ * We want that to work, but by changing the head (users) below
+ * we were forfeiting our ability to further refer to the deletee (users)
+ * in the patch-up process. Solution: use scratch space to
+ * copy the deletee pointer, then the latter references are via that
+ * scratch pointer rather than through the repointed (users) symbol.
+ */
+#define HASH_DELETE(hh,head,delptr)                                              \
+do {                                                                             \
+    struct UT_hash_handle *_hd_hh_del;                                           \
+    if ( ((delptr)->hh.prev == NULL) && ((delptr)->hh.next == NULL) )  {         \
+        uthash_free((head)->hh.tbl->buckets,                                     \
+                    (head)->hh.tbl->num_buckets*sizeof(struct UT_hash_bucket) ); \
+        HASH_BLOOM_FREE((head)->hh.tbl);                                         \
+        uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                      \
+        head = NULL;                                                             \
+    } else {                                                                     \
+        unsigned _hd_bkt;                                                        \
+        _hd_hh_del = &((delptr)->hh);                                            \
+        if ((delptr) == ELMT_FROM_HH((head)->hh.tbl,(head)->hh.tbl->tail)) {     \
+            (head)->hh.tbl->tail =                                               \
+                (UT_hash_handle*)((ptrdiff_t)((delptr)->hh.prev) +               \
+                (head)->hh.tbl->hho);                                            \
+        }                                                                        \
+        if ((delptr)->hh.prev != NULL) {                                         \
+            ((UT_hash_handle*)((ptrdiff_t)((delptr)->hh.prev) +                  \
+                    (head)->hh.tbl->hho))->next = (delptr)->hh.next;             \
+        } else {                                                                 \
+            DECLTYPE_ASSIGN(head,(delptr)->hh.next);                             \
+        }                                                                        \
+        if (_hd_hh_del->next != NULL) {                                          \
+            ((UT_hash_handle*)((ptrdiff_t)_hd_hh_del->next +                     \
+                    (head)->hh.tbl->hho))->prev =                                \
+                    _hd_hh_del->prev;                                            \
+        }                                                                        \
+        HASH_TO_BKT( _hd_hh_del->hashv, (head)->hh.tbl->num_buckets, _hd_bkt);   \
+        HASH_DEL_IN_BKT(hh,(head)->hh.tbl->buckets[_hd_bkt], _hd_hh_del);        \
+        (head)->hh.tbl->num_items--;                                             \
+    }                                                                            \
+    HASH_FSCK(hh,head);                                                          \
+} while (0)
+
+
+/* convenience forms of HASH_FIND/HASH_ADD/HASH_DEL */
+#define HASH_FIND_STR(head,findstr,out)                                          \
+    HASH_FIND(hh,head,findstr,(unsigned)uthash_strlen(findstr),out)
+#define HASH_ADD_STR(head,strfield,add)                                          \
+    HASH_ADD(hh,head,strfield[0],(unsigned)uthash_strlen(add->strfield),add)
+#define HASH_REPLACE_STR(head,strfield,add,replaced)                             \
+    HASH_REPLACE(hh,head,strfield[0],(unsigned)uthash_strlen(add->strfield),add,replaced)
+#define HASH_FIND_INT(head,findint,out)                                          \
+    HASH_FIND(hh,head,findint,sizeof(int),out)
+#define HASH_ADD_INT(head,intfield,add)                                          \
+    HASH_ADD(hh,head,intfield,sizeof(int),add)
+#define HASH_REPLACE_INT(head,intfield,add,replaced)                             \
+    HASH_REPLACE(hh,head,intfield,sizeof(int),add,replaced)
+#define HASH_FIND_PTR(head,findptr,out)                                          \
+    HASH_FIND(hh,head,findptr,sizeof(void *),out)
+#define HASH_ADD_PTR(head,ptrfield,add)                                          \
+    HASH_ADD(hh,head,ptrfield,sizeof(void *),add)
+#define HASH_REPLACE_PTR(head,ptrfield,add,replaced)                             \
+    HASH_REPLACE(hh,head,ptrfield,sizeof(void *),add,replaced)
+#define HASH_DEL(head,delptr)                                                    \
+    HASH_DELETE(hh,head,delptr)
+
+/* HASH_FSCK checks hash integrity on every add/delete when HASH_DEBUG is defined.
+ * This is for uthash developer only; it compiles away if HASH_DEBUG isn't defined.
+ */
+#ifdef HASH_DEBUG
+#define HASH_OOPS(...) do { fprintf(stderr,__VA_ARGS__); exit(-1); } while (0)
+#define HASH_FSCK(hh,head)                                                       \
+do {                                                                             \
+    struct UT_hash_handle *_thh;                                                 \
+    if (head) {                                                                  \
+        unsigned _bkt_i;                                                         \
+        unsigned _count;                                                         \
+        char *_prev;                                                             \
+        _count = 0;                                                              \
+        for( _bkt_i = 0; _bkt_i < (head)->hh.tbl->num_buckets; _bkt_i++) {       \
+            unsigned _bkt_count = 0;                                             \
+            _thh = (head)->hh.tbl->buckets[_bkt_i].hh_head;                      \
+            _prev = NULL;                                                        \
+            while (_thh) {                                                       \
+               if (_prev != (char*)(_thh->hh_prev)) {                            \
+                   HASH_OOPS("invalid hh_prev %p, actual %p\n",                  \
+                    _thh->hh_prev, _prev );                                      \
+               }                                                                 \
+               _bkt_count++;                                                     \
+               _prev = (char*)(_thh);                                            \
+               _thh = _thh->hh_next;                                             \
+            }                                                                    \
+            _count += _bkt_count;                                                \
+            if ((head)->hh.tbl->buckets[_bkt_i].count !=  _bkt_count) {          \
+               HASH_OOPS("invalid bucket count %u, actual %u\n",                 \
+                (head)->hh.tbl->buckets[_bkt_i].count, _bkt_count);              \
+            }                                                                    \
+        }                                                                        \
+        if (_count != (head)->hh.tbl->num_items) {                               \
+            HASH_OOPS("invalid hh item count %u, actual %u\n",                   \
+                (head)->hh.tbl->num_items, _count );                             \
+        }                                                                        \
+        /* traverse hh in app order; check next/prev integrity, count */         \
+        _count = 0;                                                              \
+        _prev = NULL;                                                            \
+        _thh =  &(head)->hh;                                                     \
+        while (_thh) {                                                           \
+           _count++;                                                             \
+           if (_prev !=(char*)(_thh->prev)) {                                    \
+              HASH_OOPS("invalid prev %p, actual %p\n",                          \
+                    _thh->prev, _prev );                                         \
+           }                                                                     \
+           _prev = (char*)ELMT_FROM_HH((head)->hh.tbl, _thh);                    \
+           _thh = ( _thh->next ?  (UT_hash_handle*)((char*)(_thh->next) +        \
+                                  (head)->hh.tbl->hho) : NULL );                 \
+        }                                                                        \
+        if (_count != (head)->hh.tbl->num_items) {                               \
+            HASH_OOPS("invalid app item count %u, actual %u\n",                  \
+                (head)->hh.tbl->num_items, _count );                             \
+        }                                                                        \
+    }                                                                            \
+} while (0)
+#else
+#define HASH_FSCK(hh,head)
+#endif
+
+/* When compiled with -DHASH_EMIT_KEYS, length-prefixed keys are emitted to
+ * the descriptor to which this macro is defined for tuning the hash function.
+ * The app can #include <unistd.h> to get the prototype for write(2). */
+#ifdef HASH_EMIT_KEYS
+#define HASH_EMIT_KEY(hh,head,keyptr,fieldlen)                                   \
+do {                                                                             \
+    unsigned _klen = fieldlen;                                                   \
+    write(HASH_EMIT_KEYS, &_klen, sizeof(_klen));                                \
+    write(HASH_EMIT_KEYS, keyptr, (unsigned long)fieldlen);                      \
+} while (0)
+#else
+#define HASH_EMIT_KEY(hh,head,keyptr,fieldlen)
+#endif
+
+/* default to Jenkin's hash unless overridden e.g. DHASH_FUNCTION=HASH_SAX */
+#ifdef HASH_FUNCTION
+#define HASH_FCN HASH_FUNCTION
+#else
+#define HASH_FCN HASH_JEN
+#endif
+
+/* The Bernstein hash function, used in Perl prior to v5.6. Note (x<<5+x)=x*33. */
+#define HASH_BER(key,keylen,hashv)                                               \
+do {                                                                             \
+  unsigned _hb_keylen=(unsigned)keylen;                                          \
+  const unsigned char *_hb_key=(const unsigned char*)(key);                      \
+  (hashv) = 0;                                                                   \
+  while (_hb_keylen-- != 0U) {                                                   \
+      (hashv) = (((hashv) << 5) + (hashv)) + *_hb_key++;                         \
+  }                                                                              \
+} while (0)
+
+
+/* SAX/FNV/OAT/JEN hash functions are macro variants of those listed at
+ * http://eternallyconfuzzled.com/tuts/algorithms/jsw_tut_hashing.aspx */
+#define HASH_SAX(key,keylen,hashv)                                               \
+do {                                                                             \
+  unsigned _sx_i;                                                                \
+  const unsigned char *_hs_key=(const unsigned char*)(key);                      \
+  hashv = 0;                                                                     \
+  for(_sx_i=0; _sx_i < keylen; _sx_i++) {                                        \
+      hashv ^= (hashv << 5) + (hashv >> 2) + _hs_key[_sx_i];                     \
+  }                                                                              \
+} while (0)
+/* FNV-1a variation */
+#define HASH_FNV(key,keylen,hashv)                                               \
+do {                                                                             \
+  unsigned _fn_i;                                                                \
+  const unsigned char *_hf_key=(const unsigned char*)(key);                      \
+  hashv = 2166136261U;                                                           \
+  for(_fn_i=0; _fn_i < keylen; _fn_i++) {                                        \
+      hashv = hashv ^ _hf_key[_fn_i];                                            \
+      hashv = hashv * 16777619U;                                                 \
+  }                                                                              \
+} while (0)
+
+#define HASH_OAT(key,keylen,hashv)                                               \
+do {                                                                             \
+  unsigned _ho_i;                                                                \
+  const unsigned char *_ho_key=(const unsigned char*)(key);                      \
+  hashv = 0;                                                                     \
+  for(_ho_i=0; _ho_i < keylen; _ho_i++) {                                        \
+      hashv += _ho_key[_ho_i];                                                   \
+      hashv += (hashv << 10);                                                    \
+      hashv ^= (hashv >> 6);                                                     \
+  }                                                                              \
+  hashv += (hashv << 3);                                                         \
+  hashv ^= (hashv >> 11);                                                        \
+  hashv += (hashv << 15);                                                        \
+} while (0)
+
+#define HASH_JEN_MIX(a,b,c)                                                      \
+do {                                                                             \
+  a -= b; a -= c; a ^= ( c >> 13 );                                              \
+  b -= c; b -= a; b ^= ( a << 8 );                                               \
+  c -= a; c -= b; c ^= ( b >> 13 );                                              \
+  a -= b; a -= c; a ^= ( c >> 12 );                                              \
+  b -= c; b -= a; b ^= ( a << 16 );                                              \
+  c -= a; c -= b; c ^= ( b >> 5 );                                               \
+  a -= b; a -= c; a ^= ( c >> 3 );                                               \
+  b -= c; b -= a; b ^= ( a << 10 );                                              \
+  c -= a; c -= b; c ^= ( b >> 15 );                                              \
+} while (0)
+
+#define HASH_JEN(key,keylen,hashv)                                               \
+do {                                                                             \
+  unsigned _hj_i,_hj_j,_hj_k;                                                    \
+  unsigned const char *_hj_key=(unsigned const char*)(key);                      \
+  hashv = 0xfeedbeefu;                                                           \
+  _hj_i = _hj_j = 0x9e3779b9u;                                                   \
+  _hj_k = (unsigned)(keylen);                                                    \
+  while (_hj_k >= 12U) {                                                         \
+    _hj_i +=    (_hj_key[0] + ( (unsigned)_hj_key[1] << 8 )                      \
+        + ( (unsigned)_hj_key[2] << 16 )                                         \
+        + ( (unsigned)_hj_key[3] << 24 ) );                                      \
+    _hj_j +=    (_hj_key[4] + ( (unsigned)_hj_key[5] << 8 )                      \
+        + ( (unsigned)_hj_key[6] << 16 )                                         \
+        + ( (unsigned)_hj_key[7] << 24 ) );                                      \
+    hashv += (_hj_key[8] + ( (unsigned)_hj_key[9] << 8 )                         \
+        + ( (unsigned)_hj_key[10] << 16 )                                        \
+        + ( (unsigned)_hj_key[11] << 24 ) );                                     \
+                                                                                 \
+     HASH_JEN_MIX(_hj_i, _hj_j, hashv);                                          \
+                                                                                 \
+     _hj_key += 12;                                                              \
+     _hj_k -= 12U;                                                               \
+  }                                                                              \
+  hashv += (unsigned)(keylen);                                                   \
+  switch ( _hj_k ) {                                                             \
+     case 11: hashv += ( (unsigned)_hj_key[10] << 24 ); /* FALLTHROUGH */        \
+     case 10: hashv += ( (unsigned)_hj_key[9] << 16 );  /* FALLTHROUGH */        \
+     case 9:  hashv += ( (unsigned)_hj_key[8] << 8 );   /* FALLTHROUGH */        \
+     case 8:  _hj_j += ( (unsigned)_hj_key[7] << 24 );  /* FALLTHROUGH */        \
+     case 7:  _hj_j += ( (unsigned)_hj_key[6] << 16 );  /* FALLTHROUGH */        \
+     case 6:  _hj_j += ( (unsigned)_hj_key[5] << 8 );   /* FALLTHROUGH */        \
+     case 5:  _hj_j += _hj_key[4];                      /* FALLTHROUGH */        \
+     case 4:  _hj_i += ( (unsigned)_hj_key[3] << 24 );  /* FALLTHROUGH */        \
+     case 3:  _hj_i += ( (unsigned)_hj_key[2] << 16 );  /* FALLTHROUGH */        \
+     case 2:  _hj_i += ( (unsigned)_hj_key[1] << 8 );   /* FALLTHROUGH */        \
+     case 1:  _hj_i += _hj_key[0];                                               \
+  }                                                                              \
+  HASH_JEN_MIX(_hj_i, _hj_j, hashv);                                             \
+} while (0)
+
+/* The Paul Hsieh hash function */
+#undef get16bits
+#if (defined(__GNUC__) && defined(__i386__)) || defined(__WATCOMC__)             \
+  || defined(_MSC_VER) || defined (__BORLANDC__) || defined (__TURBOC__)
+#define get16bits(d) (*((const uint16_t *) (d)))
+#endif
+
+#if !defined (get16bits)
+#define get16bits(d) ((((uint32_t)(((const uint8_t *)(d))[1])) << 8)             \
+                       +(uint32_t)(((const uint8_t *)(d))[0]) )
+#endif
+#define HASH_SFH(key,keylen,hashv)                                               \
+do {                                                                             \
+  unsigned const char *_sfh_key=(unsigned const char*)(key);                     \
+  uint32_t _sfh_tmp, _sfh_len = (uint32_t)keylen;                                \
+                                                                                 \
+  unsigned _sfh_rem = _sfh_len & 3U;                                             \
+  _sfh_len >>= 2;                                                                \
+  hashv = 0xcafebabeu;                                                           \
+                                                                                 \
+  /* Main loop */                                                                \
+  for (;_sfh_len > 0U; _sfh_len--) {                                             \
+    hashv    += get16bits (_sfh_key);                                            \
+    _sfh_tmp  = ((uint32_t)(get16bits (_sfh_key+2)) << 11) ^ hashv;              \
+    hashv     = (hashv << 16) ^ _sfh_tmp;                                        \
+    _sfh_key += 2U*sizeof (uint16_t);                                            \
+    hashv    += hashv >> 11;                                                     \
+  }                                                                              \
+                                                                                 \
+  /* Handle end cases */                                                         \
+  switch (_sfh_rem) {                                                            \
+    case 3: hashv += get16bits (_sfh_key);                                       \
+            hashv ^= hashv << 16;                                                \
+            hashv ^= (uint32_t)(_sfh_key[sizeof (uint16_t)]) << 18;              \
+            hashv += hashv >> 11;                                                \
+            break;                                                               \
+    case 2: hashv += get16bits (_sfh_key);                                       \
+            hashv ^= hashv << 11;                                                \
+            hashv += hashv >> 17;                                                \
+            break;                                                               \
+    case 1: hashv += *_sfh_key;                                                  \
+            hashv ^= hashv << 10;                                                \
+            hashv += hashv >> 1;                                                 \
+  }                                                                              \
+                                                                                 \
+    /* Force "avalanching" of final 127 bits */                                  \
+    hashv ^= hashv << 3;                                                         \
+    hashv += hashv >> 5;                                                         \
+    hashv ^= hashv << 4;                                                         \
+    hashv += hashv >> 17;                                                        \
+    hashv ^= hashv << 25;                                                        \
+    hashv += hashv >> 6;                                                         \
+} while (0)
+
+#ifdef HASH_USING_NO_STRICT_ALIASING
+/* The MurmurHash exploits some CPU's (x86,x86_64) tolerance for unaligned reads.
+ * For other types of CPU's (e.g. Sparc) an unaligned read causes a bus error.
+ * MurmurHash uses the faster approach only on CPU's where we know it's safe.
+ *
+ * Note the preprocessor built-in defines can be emitted using:
+ *
+ *   gcc -m64 -dM -E - < /dev/null                  (on gcc)
+ *   cc -## a.c (where a.c is a simple test file)   (Sun Studio)
+ */
+#if (defined(__i386__) || defined(__x86_64__)  || defined(_M_IX86))
+#define MUR_GETBLOCK(p,i) p[i]
+#else /* non intel */
+#define MUR_PLUS0_ALIGNED(p) (((unsigned long)p & 3UL) == 0UL)
+#define MUR_PLUS1_ALIGNED(p) (((unsigned long)p & 3UL) == 1UL)
+#define MUR_PLUS2_ALIGNED(p) (((unsigned long)p & 3UL) == 2UL)
+#define MUR_PLUS3_ALIGNED(p) (((unsigned long)p & 3UL) == 3UL)
+#define WP(p) ((uint32_t*)((unsigned long)(p) & ~3UL))
+#if (defined(__BIG_ENDIAN__) || defined(SPARC) || defined(__ppc__) || defined(__ppc64__))
+#define MUR_THREE_ONE(p) ((((*WP(p))&0x00ffffff) << 8) | (((*(WP(p)+1))&0xff000000) >> 24))
+#define MUR_TWO_TWO(p)   ((((*WP(p))&0x0000ffff) <<16) | (((*(WP(p)+1))&0xffff0000) >> 16))
+#define MUR_ONE_THREE(p) ((((*WP(p))&0x000000ff) <<24) | (((*(WP(p)+1))&0xffffff00) >>  8))
+#else /* assume little endian non-intel */
+#define MUR_THREE_ONE(p) ((((*WP(p))&0xffffff00) >> 8) | (((*(WP(p)+1))&0x000000ff) << 24))
+#define MUR_TWO_TWO(p)   ((((*WP(p))&0xffff0000) >>16) | (((*(WP(p)+1))&0x0000ffff) << 16))
+#define MUR_ONE_THREE(p) ((((*WP(p))&0xff000000) >>24) | (((*(WP(p)+1))&0x00ffffff) <<  8))
+#endif
+#define MUR_GETBLOCK(p,i) (MUR_PLUS0_ALIGNED(p) ? ((p)[i]) :           \
+                            (MUR_PLUS1_ALIGNED(p) ? MUR_THREE_ONE(p) : \
+                             (MUR_PLUS2_ALIGNED(p) ? MUR_TWO_TWO(p) :  \
+                                                      MUR_ONE_THREE(p))))
+#endif
+#define MUR_ROTL32(x,r) (((x) << (r)) | ((x) >> (32 - (r))))
+#define MUR_FMIX(_h) \
+do {                 \
+  _h ^= _h >> 16;    \
+  _h *= 0x85ebca6bu; \
+  _h ^= _h >> 13;    \
+  _h *= 0xc2b2ae35u; \
+  _h ^= _h >> 16;    \
+} while (0)
+
+#define HASH_MUR(key,keylen,hashv)                                     \
+do {                                                                   \
+  const uint8_t *_mur_data = (const uint8_t*)(key);                    \
+  const int _mur_nblocks = (int)(keylen) / 4;                          \
+  uint32_t _mur_h1 = 0xf88D5353u;                                      \
+  uint32_t _mur_c1 = 0xcc9e2d51u;                                      \
+  uint32_t _mur_c2 = 0x1b873593u;                                      \
+  uint32_t _mur_k1 = 0;                                                \
+  const uint8_t *_mur_tail;                                            \
+  const uint32_t *_mur_blocks = (const uint32_t*)(_mur_data+(_mur_nblocks*4)); \
+  int _mur_i;                                                          \
+  for(_mur_i = -_mur_nblocks; _mur_i!=0; _mur_i++) {                   \
+    _mur_k1 = MUR_GETBLOCK(_mur_blocks,_mur_i);                        \
+    _mur_k1 *= _mur_c1;                                                \
+    _mur_k1 = MUR_ROTL32(_mur_k1,15);                                  \
+    _mur_k1 *= _mur_c2;                                                \
+                                                                       \
+    _mur_h1 ^= _mur_k1;                                                \
+    _mur_h1 = MUR_ROTL32(_mur_h1,13);                                  \
+    _mur_h1 = (_mur_h1*5U) + 0xe6546b64u;                              \
+  }                                                                    \
+  _mur_tail = (const uint8_t*)(_mur_data + (_mur_nblocks*4));          \
+  _mur_k1=0;                                                           \
+  switch((keylen) & 3U) {                                              \
+    case 3: _mur_k1 ^= (uint32_t)_mur_tail[2] << 16; /* FALLTHROUGH */ \
+    case 2: _mur_k1 ^= (uint32_t)_mur_tail[1] << 8;  /* FALLTHROUGH */ \
+    case 1: _mur_k1 ^= (uint32_t)_mur_tail[0];                         \
+    _mur_k1 *= _mur_c1;                                                \
+    _mur_k1 = MUR_ROTL32(_mur_k1,15);                                  \
+    _mur_k1 *= _mur_c2;                                                \
+    _mur_h1 ^= _mur_k1;                                                \
+  }                                                                    \
+  _mur_h1 ^= (uint32_t)(keylen);                                       \
+  MUR_FMIX(_mur_h1);                                                   \
+  hashv = _mur_h1;                                                     \
+} while (0)
+#endif  /* HASH_USING_NO_STRICT_ALIASING */
+
+/* iterate over items in a known bucket to find desired item */
+#define HASH_FIND_IN_BKT(tbl,hh,head,keyptr,keylen_in,hashval,out)               \
+do {                                                                             \
+  if ((head).hh_head != NULL) {                                                  \
+    DECLTYPE_ASSIGN(out, ELMT_FROM_HH(tbl, (head).hh_head));                     \
+  } else {                                                                       \
+    (out) = NULL;                                                                \
+  }                                                                              \
+  while ((out) != NULL) {                                                        \
+    if ((out)->hh.hashv == (hashval) && (out)->hh.keylen == (keylen_in)) {       \
+      if (uthash_memcmp((out)->hh.key, keyptr, keylen_in) == 0) {                \
+        break;                                                                   \
+      }                                                                          \
+    }                                                                            \
+    if ((out)->hh.hh_next != NULL) {                                             \
+      DECLTYPE_ASSIGN(out, ELMT_FROM_HH(tbl, (out)->hh.hh_next));                \
+    } else {                                                                     \
+      (out) = NULL;                                                              \
+    }                                                                            \
+  }                                                                              \
+} while (0)
+
+/* add an item to a bucket  */
+#define HASH_ADD_TO_BKT(head,addhh)                                              \
+do {                                                                             \
+ head.count++;                                                                   \
+ (addhh)->hh_next = head.hh_head;                                                \
+ (addhh)->hh_prev = NULL;                                                        \
+ if (head.hh_head != NULL) { (head).hh_head->hh_prev = (addhh); }                \
+ (head).hh_head=addhh;                                                           \
+ if ((head.count >= ((head.expand_mult+1U) * HASH_BKT_CAPACITY_THRESH))          \
+     && ((addhh)->tbl->noexpand != 1U)) {                                        \
+       HASH_EXPAND_BUCKETS((addhh)->tbl);                                        \
+ }                                                                               \
+} while (0)
+
+/* remove an item from a given bucket */
+#define HASH_DEL_IN_BKT(hh,head,hh_del)                                          \
+    (head).count--;                                                              \
+    if ((head).hh_head == hh_del) {                                              \
+      (head).hh_head = hh_del->hh_next;                                          \
+    }                                                                            \
+    if (hh_del->hh_prev) {                                                       \
+        hh_del->hh_prev->hh_next = hh_del->hh_next;                              \
+    }                                                                            \
+    if (hh_del->hh_next) {                                                       \
+        hh_del->hh_next->hh_prev = hh_del->hh_prev;                              \
+    }
+
+/* Bucket expansion has the effect of doubling the number of buckets
+ * and redistributing the items into the new buckets. Ideally the
+ * items will distribute more or less evenly into the new buckets
+ * (the extent to which this is true is a measure of the quality of
+ * the hash function as it applies to the key domain).
+ *
+ * With the items distributed into more buckets, the chain length
+ * (item count) in each bucket is reduced. Thus by expanding buckets
+ * the hash keeps a bound on the chain length. This bounded chain
+ * length is the essence of how a hash provides constant time lookup.
+ *
+ * The calculation of tbl->ideal_chain_maxlen below deserves some
+ * explanation. First, keep in mind that we're calculating the ideal
+ * maximum chain length based on the *new* (doubled) bucket count.
+ * In fractions this is just n/b (n=number of items,b=new num buckets).
+ * Since the ideal chain length is an integer, we want to calculate
+ * ceil(n/b). We don't depend on floating point arithmetic in this
+ * hash, so to calculate ceil(n/b) with integers we could write
+ *
+ *      ceil(n/b) = (n/b) + ((n%b)?1:0)
+ *
+ * and in fact a previous version of this hash did just that.
+ * But now we have improved things a bit by recognizing that b is
+ * always a power of two. We keep its base 2 log handy (call it lb),
+ * so now we can write this with a bit shift and logical AND:
+ *
+ *      ceil(n/b) = (n>>lb) + ( (n & (b-1)) ? 1:0)
+ *
+ */
+#define HASH_EXPAND_BUCKETS(tbl)                                                 \
+do {                                                                             \
+    unsigned _he_bkt;                                                            \
+    unsigned _he_bkt_i;                                                          \
+    struct UT_hash_handle *_he_thh, *_he_hh_nxt;                                 \
+    UT_hash_bucket *_he_new_buckets, *_he_newbkt;                                \
+    _he_new_buckets = (UT_hash_bucket*)uthash_malloc(                            \
+             2UL * tbl->num_buckets * sizeof(struct UT_hash_bucket));            \
+    if (!_he_new_buckets) { uthash_fatal( "out of memory"); }                    \
+    memset(_he_new_buckets, 0,                                                   \
+            2UL * tbl->num_buckets * sizeof(struct UT_hash_bucket));             \
+    tbl->ideal_chain_maxlen =                                                    \
+       (tbl->num_items >> (tbl->log2_num_buckets+1U)) +                          \
+       (((tbl->num_items & ((tbl->num_buckets*2U)-1U)) != 0U) ? 1U : 0U);        \
+    tbl->nonideal_items = 0;                                                     \
+    for(_he_bkt_i = 0; _he_bkt_i < tbl->num_buckets; _he_bkt_i++)                \
+    {                                                                            \
+        _he_thh = tbl->buckets[ _he_bkt_i ].hh_head;                             \
+        while (_he_thh != NULL) {                                                \
+           _he_hh_nxt = _he_thh->hh_next;                                        \
+           HASH_TO_BKT( _he_thh->hashv, tbl->num_buckets*2U, _he_bkt);           \
+           _he_newbkt = &(_he_new_buckets[ _he_bkt ]);                           \
+           if (++(_he_newbkt->count) > tbl->ideal_chain_maxlen) {                \
+             tbl->nonideal_items++;                                              \
+             _he_newbkt->expand_mult = _he_newbkt->count /                       \
+                                        tbl->ideal_chain_maxlen;                 \
+           }                                                                     \
+           _he_thh->hh_prev = NULL;                                              \
+           _he_thh->hh_next = _he_newbkt->hh_head;                               \
+           if (_he_newbkt->hh_head != NULL) { _he_newbkt->hh_head->hh_prev =     \
+                _he_thh; }                                                       \
+           _he_newbkt->hh_head = _he_thh;                                        \
+           _he_thh = _he_hh_nxt;                                                 \
+        }                                                                        \
+    }                                                                            \
+    uthash_free( tbl->buckets, tbl->num_buckets*sizeof(struct UT_hash_bucket) ); \
+    tbl->num_buckets *= 2U;                                                      \
+    tbl->log2_num_buckets++;                                                     \
+    tbl->buckets = _he_new_buckets;                                              \
+    tbl->ineff_expands = (tbl->nonideal_items > (tbl->num_items >> 1)) ?         \
+        (tbl->ineff_expands+1U) : 0U;                                            \
+    if (tbl->ineff_expands > 1U) {                                               \
+        tbl->noexpand=1;                                                         \
+        uthash_noexpand_fyi(tbl);                                                \
+    }                                                                            \
+    uthash_expand_fyi(tbl);                                                      \
+} while (0)
+
+
+/* This is an adaptation of Simon Tatham's O(n log(n)) mergesort */
+/* Note that HASH_SORT assumes the hash handle name to be hh.
+ * HASH_SRT was added to allow the hash handle name to be passed in. */
+#define HASH_SORT(head,cmpfcn) HASH_SRT(hh,head,cmpfcn)
+#define HASH_SRT(hh,head,cmpfcn)                                                 \
+do {                                                                             \
+  unsigned _hs_i;                                                                \
+  unsigned _hs_looping,_hs_nmerges,_hs_insize,_hs_psize,_hs_qsize;               \
+  struct UT_hash_handle *_hs_p, *_hs_q, *_hs_e, *_hs_list, *_hs_tail;            \
+  if (head != NULL) {                                                            \
+      _hs_insize = 1;                                                            \
+      _hs_looping = 1;                                                           \
+      _hs_list = &((head)->hh);                                                  \
+      while (_hs_looping != 0U) {                                                \
+          _hs_p = _hs_list;                                                      \
+          _hs_list = NULL;                                                       \
+          _hs_tail = NULL;                                                       \
+          _hs_nmerges = 0;                                                       \
+          while (_hs_p != NULL) {                                                \
+              _hs_nmerges++;                                                     \
+              _hs_q = _hs_p;                                                     \
+              _hs_psize = 0;                                                     \
+              for ( _hs_i = 0; _hs_i  < _hs_insize; _hs_i++ ) {                  \
+                  _hs_psize++;                                                   \
+                  _hs_q = (UT_hash_handle*)((_hs_q->next != NULL) ?              \
+                          ((void*)((char*)(_hs_q->next) +                        \
+                          (head)->hh.tbl->hho)) : NULL);                         \
+                  if (! (_hs_q) ) { break; }                                     \
+              }                                                                  \
+              _hs_qsize = _hs_insize;                                            \
+              while ((_hs_psize > 0U) || ((_hs_qsize > 0U) && (_hs_q != NULL))) {\
+                  if (_hs_psize == 0U) {                                         \
+                      _hs_e = _hs_q;                                             \
+                      _hs_q = (UT_hash_handle*)((_hs_q->next != NULL) ?          \
+                              ((void*)((char*)(_hs_q->next) +                    \
+                              (head)->hh.tbl->hho)) : NULL);                     \
+                      _hs_qsize--;                                               \
+                  } else if ( (_hs_qsize == 0U) || (_hs_q == NULL) ) {           \
+                      _hs_e = _hs_p;                                             \
+                      if (_hs_p != NULL){                                        \
+                        _hs_p = (UT_hash_handle*)((_hs_p->next != NULL) ?        \
+                                ((void*)((char*)(_hs_p->next) +                  \
+                                (head)->hh.tbl->hho)) : NULL);                   \
+                       }                                                         \
+                      _hs_psize--;                                               \
+                  } else if ((                                                   \
+                      cmpfcn(DECLTYPE(head)(ELMT_FROM_HH((head)->hh.tbl,_hs_p)), \
+                             DECLTYPE(head)(ELMT_FROM_HH((head)->hh.tbl,_hs_q))) \
+                             ) <= 0) {                                           \
+                      _hs_e = _hs_p;                                             \
+                      if (_hs_p != NULL){                                        \
+                        _hs_p = (UT_hash_handle*)((_hs_p->next != NULL) ?        \
+                               ((void*)((char*)(_hs_p->next) +                   \
+                               (head)->hh.tbl->hho)) : NULL);                    \
+                       }                                                         \
+                      _hs_psize--;                                               \
+                  } else {                                                       \
+                      _hs_e = _hs_q;                                             \
+                      _hs_q = (UT_hash_handle*)((_hs_q->next != NULL) ?          \
+                              ((void*)((char*)(_hs_q->next) +                    \
+                              (head)->hh.tbl->hho)) : NULL);                     \
+                      _hs_qsize--;                                               \
+                  }                                                              \
+                  if ( _hs_tail != NULL ) {                                      \
+                      _hs_tail->next = ((_hs_e != NULL) ?                        \
+                            ELMT_FROM_HH((head)->hh.tbl,_hs_e) : NULL);          \
+                  } else {                                                       \
+                      _hs_list = _hs_e;                                          \
+                  }                                                              \
+                  if (_hs_e != NULL) {                                           \
+                  _hs_e->prev = ((_hs_tail != NULL) ?                            \
+                     ELMT_FROM_HH((head)->hh.tbl,_hs_tail) : NULL);              \
+                  }                                                              \
+                  _hs_tail = _hs_e;                                              \
+              }                                                                  \
+              _hs_p = _hs_q;                                                     \
+          }                                                                      \
+          if (_hs_tail != NULL){                                                 \
+            _hs_tail->next = NULL;                                               \
+          }                                                                      \
+          if ( _hs_nmerges <= 1U ) {                                             \
+              _hs_looping=0;                                                     \
+              (head)->hh.tbl->tail = _hs_tail;                                   \
+              DECLTYPE_ASSIGN(head,ELMT_FROM_HH((head)->hh.tbl, _hs_list));      \
+          }                                                                      \
+          _hs_insize *= 2U;                                                      \
+      }                                                                          \
+      HASH_FSCK(hh,head);                                                        \
+ }                                                                               \
+} while (0)
+
+/* This function selects items from one hash into another hash.
+ * The end result is that the selected items have dual presence
+ * in both hashes. There is no copy of the items made; rather
+ * they are added into the new hash through a secondary hash
+ * hash handle that must be present in the structure. */
+#define HASH_SELECT(hh_dst, dst, hh_src, src, cond)                              \
+do {                                                                             \
+  unsigned _src_bkt, _dst_bkt;                                                   \
+  void *_last_elt=NULL, *_elt;                                                   \
+  UT_hash_handle *_src_hh, *_dst_hh, *_last_elt_hh=NULL;                         \
+  ptrdiff_t _dst_hho = ((char*)(&(dst)->hh_dst) - (char*)(dst));                 \
+  if (src != NULL) {                                                             \
+    for(_src_bkt=0; _src_bkt < (src)->hh_src.tbl->num_buckets; _src_bkt++) {     \
+      for(_src_hh = (src)->hh_src.tbl->buckets[_src_bkt].hh_head;                \
+          _src_hh != NULL;                                                       \
+          _src_hh = _src_hh->hh_next) {                                          \
+          _elt = ELMT_FROM_HH((src)->hh_src.tbl, _src_hh);                       \
+          if (cond(_elt)) {                                                      \
+            _dst_hh = (UT_hash_handle*)(((char*)_elt) + _dst_hho);               \
+            _dst_hh->key = _src_hh->key;                                         \
+            _dst_hh->keylen = _src_hh->keylen;                                   \
+            _dst_hh->hashv = _src_hh->hashv;                                     \
+            _dst_hh->prev = _last_elt;                                           \
+            _dst_hh->next = NULL;                                                \
+            if (_last_elt_hh != NULL) { _last_elt_hh->next = _elt; }             \
+            if (dst == NULL) {                                                   \
+              DECLTYPE_ASSIGN(dst,_elt);                                         \
+              HASH_MAKE_TABLE(hh_dst,dst);                                       \
+            } else {                                                             \
+              _dst_hh->tbl = (dst)->hh_dst.tbl;                                  \
+            }                                                                    \
+            HASH_TO_BKT(_dst_hh->hashv, _dst_hh->tbl->num_buckets, _dst_bkt);    \
+            HASH_ADD_TO_BKT(_dst_hh->tbl->buckets[_dst_bkt],_dst_hh);            \
+            (dst)->hh_dst.tbl->num_items++;                                      \
+            _last_elt = _elt;                                                    \
+            _last_elt_hh = _dst_hh;                                              \
+          }                                                                      \
+      }                                                                          \
+    }                                                                            \
+  }                                                                              \
+  HASH_FSCK(hh_dst,dst);                                                         \
+} while (0)
+
+#define HASH_CLEAR(hh,head)                                                      \
+do {                                                                             \
+  if (head != NULL) {                                                            \
+    uthash_free((head)->hh.tbl->buckets,                                         \
+                (head)->hh.tbl->num_buckets*sizeof(struct UT_hash_bucket));      \
+    HASH_BLOOM_FREE((head)->hh.tbl);                                             \
+    uthash_free((head)->hh.tbl, sizeof(UT_hash_table));                          \
+    (head)=NULL;                                                                 \
+  }                                                                              \
+} while (0)
+
+#define HASH_OVERHEAD(hh,head)                                                   \
+ ((head != NULL) ? (                                                             \
+ (size_t)(((head)->hh.tbl->num_items   * sizeof(UT_hash_handle))   +             \
+          ((head)->hh.tbl->num_buckets * sizeof(UT_hash_bucket))   +             \
+           sizeof(UT_hash_table)                                   +             \
+           (HASH_BLOOM_BYTELEN))) : 0U)
+
+#ifdef NO_DECLTYPE
+#define HASH_ITER(hh,head,el,tmp)                                                \
+for(((el)=(head)), ((*(char**)(&(tmp)))=(char*)((head!=NULL)?(head)->hh.next:NULL)); \
+  (el) != NULL; ((el)=(tmp)), ((*(char**)(&(tmp)))=(char*)((tmp!=NULL)?(tmp)->hh.next:NULL)))
+#else
+#define HASH_ITER(hh,head,el,tmp)                                                \
+for(((el)=(head)), ((tmp)=DECLTYPE(el)((head!=NULL)?(head)->hh.next:NULL));      \
+  (el) != NULL; ((el)=(tmp)), ((tmp)=DECLTYPE(el)((tmp!=NULL)?(tmp)->hh.next:NULL)))
+#endif
+
+/* obtain a count of items in the hash */
+#define HASH_COUNT(head) HASH_CNT(hh,head)
+#define HASH_CNT(hh,head) ((head != NULL)?((head)->hh.tbl->num_items):0U)
+
+typedef struct UT_hash_bucket {
+   struct UT_hash_handle *hh_head;
+   unsigned count;
+
+   /* expand_mult is normally set to 0. In this situation, the max chain length
+    * threshold is enforced at its default value, HASH_BKT_CAPACITY_THRESH. (If
+    * the bucket's chain exceeds this length, bucket expansion is triggered).
+    * However, setting expand_mult to a non-zero value delays bucket expansion
+    * (that would be triggered by additions to this particular bucket)
+    * until its chain length reaches a *multiple* of HASH_BKT_CAPACITY_THRESH.
+    * (The multiplier is simply expand_mult+1). The whole idea of this
+    * multiplier is to reduce bucket expansions, since they are expensive, in
+    * situations where we know that a particular bucket tends to be overused.
+    * It is better to let its chain length grow to a longer yet-still-bounded
+    * value, than to do an O(n) bucket expansion too often.
+    */
+   unsigned expand_mult;
+
+} UT_hash_bucket;
+
+/* random signature used only to find hash tables in external analysis */
+#define HASH_SIGNATURE 0xa0111fe1u
+#define HASH_BLOOM_SIGNATURE 0xb12220f2u
+
+typedef struct UT_hash_table {
+   UT_hash_bucket *buckets;
+   unsigned num_buckets, log2_num_buckets;
+   unsigned num_items;
+   struct UT_hash_handle *tail; /* tail hh in app order, for fast append    */
+   ptrdiff_t hho; /* hash handle offset (byte pos of hash handle in element */
+
+   /* in an ideal situation (all buckets used equally), no bucket would have
+    * more than ceil(#items/#buckets) items. that's the ideal chain length. */
+   unsigned ideal_chain_maxlen;
+
+   /* nonideal_items is the number of items in the hash whose chain position
+    * exceeds the ideal chain maxlen. these items pay the penalty for an uneven
+    * hash distribution; reaching them in a chain traversal takes >ideal steps */
+   unsigned nonideal_items;
+
+   /* ineffective expands occur when a bucket doubling was performed, but
+    * afterward, more than half the items in the hash had nonideal chain
+    * positions. If this happens on two consecutive expansions we inhibit any
+    * further expansion, as it's not helping; this happens when the hash
+    * function isn't a good fit for the key domain. When expansion is inhibited
+    * the hash will still work, albeit no longer in constant time. */
+   unsigned ineff_expands, noexpand;
+
+   uint32_t signature; /* used only to find hash tables in external analysis */
+#ifdef HASH_BLOOM
+   uint32_t bloom_sig; /* used only to test bloom exists in external analysis */
+   uint8_t *bloom_bv;
+   uint8_t bloom_nbits;
+#endif
+
+} UT_hash_table;
+
+typedef struct UT_hash_handle {
+   struct UT_hash_table *tbl;
+   void *prev;                       /* prev element in app order      */
+   void *next;                       /* next element in app order      */
+   struct UT_hash_handle *hh_prev;   /* previous hh in bucket order    */
+   struct UT_hash_handle *hh_next;   /* next hh in bucket order        */
+   void *key;                        /* ptr to enclosing struct's key  */
+   unsigned keylen;                  /* enclosing struct's key len     */
+   unsigned hashv;                   /* result of hash-fcn(key)        */
+} UT_hash_handle;
+
+#endif /* UTHASH_H */
diff --git a/cpp/src/plasma/common/thirdparty/utlist.h b/cpp/src/plasma/common/thirdparty/utlist.h
new file mode 100644
index 000000000000..9b5534ffbdb0
--- /dev/null
+++ b/cpp/src/plasma/common/thirdparty/utlist.h
@@ -0,0 +1,895 @@
+/*
+Copyright (c) 2007-2016, Troy D. Hanson   http://troydhanson.github.com/uthash/
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
+OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifndef UTLIST_H
+#define UTLIST_H
+
+#define UTLIST_VERSION 2.0.1
+
+#include <assert.h>
+
+/*
+ * This file contains macros to manipulate singly and doubly-linked lists.
+ *
+ * 1. LL_ macros:  singly-linked lists.
+ * 2. DL_ macros:  doubly-linked lists.
+ * 3. CDL_ macros: circular doubly-linked lists.
+ *
+ * To use singly-linked lists, your structure must have a "next" pointer.
+ * To use doubly-linked lists, your structure must "prev" and "next" pointers.
+ * Either way, the pointer to the head of the list must be initialized to NULL.
+ *
+ * ----------------.EXAMPLE -------------------------
+ * struct item {
+ *      int id;
+ *      struct item *prev, *next;
+ * }
+ *
+ * struct item *list = NULL:
+ *
+ * int main() {
+ *      struct item *item;
+ *      ... allocate and populate item ...
+ *      DL_APPEND(list, item);
+ * }
+ * --------------------------------------------------
+ *
+ * For doubly-linked lists, the append and delete macros are O(1)
+ * For singly-linked lists, append and delete are O(n) but prepend is O(1)
+ * The sort macro is O(n log(n)) for all types of single/double/circular lists.
+ */
+
+/* These macros use decltype or the earlier __typeof GNU extension.
+   As decltype is only available in newer compilers (VS2010 or gcc 4.3+
+   when compiling c++ code), this code uses whatever method is needed
+   or, for VS2008 where neither is available, uses casting workarounds. */
+#ifdef _MSC_VER            /* MS compiler */
+#if _MSC_VER >= 1600 && defined(__cplusplus)  /* VS2010 or newer in C++ mode */
+#define LDECLTYPE(x) decltype(x)
+#else                     /* VS2008 or older (or VS2010 in C mode) */
+#define NO_DECLTYPE
+#endif
+#elif defined(__ICCARM__)
+#define NO_DECLTYPE
+#else                      /* GNU, Sun and other compilers */
+#define LDECLTYPE(x) __typeof(x)
+#endif
+
+/* for VS2008 we use some workarounds to get around the lack of decltype,
+ * namely, we always reassign our tmp variable to the list head if we need
+ * to dereference its prev/next pointers, and save/restore the real head.*/
+#ifdef NO_DECLTYPE
+#define IF_NO_DECLTYPE(x) x
+#define LDECLTYPE(x) char*
+#define _SV(elt,list) _tmp = (char*)(list); {char **_alias = (char**)&(list); *_alias = (elt); }
+#define _NEXT(elt,list,next) ((char*)((list)->next))
+#define _NEXTASGN(elt,list,to,next) { char **_alias = (char**)&((list)->next); *_alias=(char*)(to); }
+/* #define _PREV(elt,list,prev) ((char*)((list)->prev)) */
+#define _PREVASGN(elt,list,to,prev) { char **_alias = (char**)&((list)->prev); *_alias=(char*)(to); }
+#define _RS(list) { char **_alias = (char**)&(list); *_alias=_tmp; }
+#define _CASTASGN(a,b) { char **_alias = (char**)&(a); *_alias=(char*)(b); }
+#else
+#define IF_NO_DECLTYPE(x)
+#define _SV(elt,list)
+#define _NEXT(elt,list,next) ((elt)->next)
+#define _NEXTASGN(elt,list,to,next) ((elt)->next)=(to)
+/* #define _PREV(elt,list,prev) ((elt)->prev) */
+#define _PREVASGN(elt,list,to,prev) ((elt)->prev)=(to)
+#define _RS(list)
+#define _CASTASGN(a,b) (a)=(b)
+#endif
+
+/******************************************************************************
+ * The sort macro is an adaptation of Simon Tatham's O(n log(n)) mergesort    *
+ * Unwieldy variable names used here to avoid shadowing passed-in variables.  *
+ *****************************************************************************/
+#define LL_SORT(list, cmp)                                                                     \
+    LL_SORT2(list, cmp, next)
+
+#define LL_SORT2(list, cmp, next)                                                              \
+do {                                                                                           \
+  LDECLTYPE(list) _ls_p;                                                                       \
+  LDECLTYPE(list) _ls_q;                                                                       \
+  LDECLTYPE(list) _ls_e;                                                                       \
+  LDECLTYPE(list) _ls_tail;                                                                    \
+  IF_NO_DECLTYPE(LDECLTYPE(list) _tmp;)                                                        \
+  int _ls_insize, _ls_nmerges, _ls_psize, _ls_qsize, _ls_i, _ls_looping;                       \
+  if (list) {                                                                                  \
+    _ls_insize = 1;                                                                            \
+    _ls_looping = 1;                                                                           \
+    while (_ls_looping) {                                                                      \
+      _CASTASGN(_ls_p,list);                                                                   \
+      (list) = NULL;                                                                           \
+      _ls_tail = NULL;                                                                         \
+      _ls_nmerges = 0;                                                                         \
+      while (_ls_p) {                                                                          \
+        _ls_nmerges++;                                                                         \
+        _ls_q = _ls_p;                                                                         \
+        _ls_psize = 0;                                                                         \
+        for (_ls_i = 0; _ls_i < _ls_insize; _ls_i++) {                                         \
+          _ls_psize++;                                                                         \
+          _SV(_ls_q,list); _ls_q = _NEXT(_ls_q,list,next); _RS(list);                          \
+          if (!_ls_q) break;                                                                   \
+        }                                                                                      \
+        _ls_qsize = _ls_insize;                                                                \
+        while (_ls_psize > 0 || (_ls_qsize > 0 && _ls_q)) {                                    \
+          if (_ls_psize == 0) {                                                                \
+            _ls_e = _ls_q; _SV(_ls_q,list); _ls_q =                                            \
+              _NEXT(_ls_q,list,next); _RS(list); _ls_qsize--;                                  \
+          } else if (_ls_qsize == 0 || !_ls_q) {                                               \
+            _ls_e = _ls_p; _SV(_ls_p,list); _ls_p =                                            \
+              _NEXT(_ls_p,list,next); _RS(list); _ls_psize--;                                  \
+          } else if (cmp(_ls_p,_ls_q) <= 0) {                                                  \
+            _ls_e = _ls_p; _SV(_ls_p,list); _ls_p =                                            \
+              _NEXT(_ls_p,list,next); _RS(list); _ls_psize--;                                  \
+          } else {                                                                             \
+            _ls_e = _ls_q; _SV(_ls_q,list); _ls_q =                                            \
+              _NEXT(_ls_q,list,next); _RS(list); _ls_qsize--;                                  \
+          }                                                                                    \
+          if (_ls_tail) {                                                                      \
+            _SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,_ls_e,next); _RS(list);                \
+          } else {                                                                             \
+            _CASTASGN(list,_ls_e);                                                             \
+          }                                                                                    \
+          _ls_tail = _ls_e;                                                                    \
+        }                                                                                      \
+        _ls_p = _ls_q;                                                                         \
+      }                                                                                        \
+      if (_ls_tail) {                                                                          \
+        _SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,NULL,next); _RS(list);                     \
+      }                                                                                        \
+      if (_ls_nmerges <= 1) {                                                                  \
+        _ls_looping=0;                                                                         \
+      }                                                                                        \
+      _ls_insize *= 2;                                                                         \
+    }                                                                                          \
+  }                                                                                            \
+} while (0)
+
+
+#define DL_SORT(list, cmp)                                                                     \
+    DL_SORT2(list, cmp, prev, next)
+
+#define DL_SORT2(list, cmp, prev, next)                                                        \
+do {                                                                                           \
+  LDECLTYPE(list) _ls_p;                                                                       \
+  LDECLTYPE(list) _ls_q;                                                                       \
+  LDECLTYPE(list) _ls_e;                                                                       \
+  LDECLTYPE(list) _ls_tail;                                                                    \
+  IF_NO_DECLTYPE(LDECLTYPE(list) _tmp;)                                                        \
+  int _ls_insize, _ls_nmerges, _ls_psize, _ls_qsize, _ls_i, _ls_looping;                       \
+  if (list) {                                                                                  \
+    _ls_insize = 1;                                                                            \
+    _ls_looping = 1;                                                                           \
+    while (_ls_looping) {                                                                      \
+      _CASTASGN(_ls_p,list);                                                                   \
+      (list) = NULL;                                                                           \
+      _ls_tail = NULL;                                                                         \
+      _ls_nmerges = 0;                                                                         \
+      while (_ls_p) {                                                                          \
+        _ls_nmerges++;                                                                         \
+        _ls_q = _ls_p;                                                                         \
+        _ls_psize = 0;                                                                         \
+        for (_ls_i = 0; _ls_i < _ls_insize; _ls_i++) {                                         \
+          _ls_psize++;                                                                         \
+          _SV(_ls_q,list); _ls_q = _NEXT(_ls_q,list,next); _RS(list);                          \
+          if (!_ls_q) break;                                                                   \
+        }                                                                                      \
+        _ls_qsize = _ls_insize;                                                                \
+        while ((_ls_psize > 0) || ((_ls_qsize > 0) && _ls_q)) {                                \
+          if (_ls_psize == 0) {                                                                \
+            _ls_e = _ls_q; _SV(_ls_q,list); _ls_q =                                            \
+              _NEXT(_ls_q,list,next); _RS(list); _ls_qsize--;                                  \
+          } else if ((_ls_qsize == 0) || (!_ls_q)) {                                           \
+            _ls_e = _ls_p; _SV(_ls_p,list); _ls_p =                                            \
+              _NEXT(_ls_p,list,next); _RS(list); _ls_psize--;                                  \
+          } else if (cmp(_ls_p,_ls_q) <= 0) {                                                  \
+            _ls_e = _ls_p; _SV(_ls_p,list); _ls_p =                                            \
+              _NEXT(_ls_p,list,next); _RS(list); _ls_psize--;                                  \
+          } else {                                                                             \
+            _ls_e = _ls_q; _SV(_ls_q,list); _ls_q =                                            \
+              _NEXT(_ls_q,list,next); _RS(list); _ls_qsize--;                                  \
+          }                                                                                    \
+          if (_ls_tail) {                                                                      \
+            _SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,_ls_e,next); _RS(list);                \
+          } else {                                                                             \
+            _CASTASGN(list,_ls_e);                                                             \
+          }                                                                                    \
+          _SV(_ls_e,list); _PREVASGN(_ls_e,list,_ls_tail,prev); _RS(list);                     \
+          _ls_tail = _ls_e;                                                                    \
+        }                                                                                      \
+        _ls_p = _ls_q;                                                                         \
+      }                                                                                        \
+      _CASTASGN((list)->prev, _ls_tail);                                                       \
+      _SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,NULL,next); _RS(list);                       \
+      if (_ls_nmerges <= 1) {                                                                  \
+        _ls_looping=0;                                                                         \
+      }                                                                                        \
+      _ls_insize *= 2;                                                                         \
+    }                                                                                          \
+  }                                                                                            \
+} while (0)
+
+#define CDL_SORT(list, cmp)                                                                    \
+    CDL_SORT2(list, cmp, prev, next)
+
+#define CDL_SORT2(list, cmp, prev, next)                                                       \
+do {                                                                                           \
+  LDECLTYPE(list) _ls_p;                                                                       \
+  LDECLTYPE(list) _ls_q;                                                                       \
+  LDECLTYPE(list) _ls_e;                                                                       \
+  LDECLTYPE(list) _ls_tail;                                                                    \
+  LDECLTYPE(list) _ls_oldhead;                                                                 \
+  LDECLTYPE(list) _tmp;                                                                        \
+  int _ls_insize, _ls_nmerges, _ls_psize, _ls_qsize, _ls_i, _ls_looping;                       \
+  if (list) {                                                                                  \
+    _ls_insize = 1;                                                                            \
+    _ls_looping = 1;                                                                           \
+    while (_ls_looping) {                                                                      \
+      _CASTASGN(_ls_p,list);                                                                   \
+      _CASTASGN(_ls_oldhead,list);                                                             \
+      (list) = NULL;                                                                           \
+      _ls_tail = NULL;                                                                         \
+      _ls_nmerges = 0;                                                                         \
+      while (_ls_p) {                                                                          \
+        _ls_nmerges++;                                                                         \
+        _ls_q = _ls_p;                                                                         \
+        _ls_psize = 0;                                                                         \
+        for (_ls_i = 0; _ls_i < _ls_insize; _ls_i++) {                                         \
+          _ls_psize++;                                                                         \
+          _SV(_ls_q,list);                                                                     \
+          if (_NEXT(_ls_q,list,next) == _ls_oldhead) {                                         \
+            _ls_q = NULL;                                                                      \
+          } else {                                                                             \
+            _ls_q = _NEXT(_ls_q,list,next);                                                    \
+          }                                                                                    \
+          _RS(list);                                                                           \
+          if (!_ls_q) break;                                                                   \
+        }                                                                                      \
+        _ls_qsize = _ls_insize;                                                                \
+        while (_ls_psize > 0 || (_ls_qsize > 0 && _ls_q)) {                                    \
+          if (_ls_psize == 0) {                                                                \
+            _ls_e = _ls_q; _SV(_ls_q,list); _ls_q =                                            \
+              _NEXT(_ls_q,list,next); _RS(list); _ls_qsize--;                                  \
+            if (_ls_q == _ls_oldhead) { _ls_q = NULL; }                                        \
+          } else if (_ls_qsize == 0 || !_ls_q) {                                               \
+            _ls_e = _ls_p; _SV(_ls_p,list); _ls_p =                                            \
+              _NEXT(_ls_p,list,next); _RS(list); _ls_psize--;                                  \
+            if (_ls_p == _ls_oldhead) { _ls_p = NULL; }                                        \
+          } else if (cmp(_ls_p,_ls_q) <= 0) {                                                  \
+            _ls_e = _ls_p; _SV(_ls_p,list); _ls_p =                                            \
+              _NEXT(_ls_p,list,next); _RS(list); _ls_psize--;                                  \
+            if (_ls_p == _ls_oldhead) { _ls_p = NULL; }                                        \
+          } else {                                                                             \
+            _ls_e = _ls_q; _SV(_ls_q,list); _ls_q =                                            \
+              _NEXT(_ls_q,list,next); _RS(list); _ls_qsize--;                                  \
+            if (_ls_q == _ls_oldhead) { _ls_q = NULL; }                                        \
+          }                                                                                    \
+          if (_ls_tail) {                                                                      \
+            _SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,_ls_e,next); _RS(list);                \
+          } else {                                                                             \
+            _CASTASGN(list,_ls_e);                                                             \
+          }                                                                                    \
+          _SV(_ls_e,list); _PREVASGN(_ls_e,list,_ls_tail,prev); _RS(list);                     \
+          _ls_tail = _ls_e;                                                                    \
+        }                                                                                      \
+        _ls_p = _ls_q;                                                                         \
+      }                                                                                        \
+      _CASTASGN((list)->prev,_ls_tail);                                                        \
+      _CASTASGN(_tmp,list);                                                                    \
+      _SV(_ls_tail,list); _NEXTASGN(_ls_tail,list,_tmp,next); _RS(list);                       \
+      if (_ls_nmerges <= 1) {                                                                  \
+        _ls_looping=0;                                                                         \
+      }                                                                                        \
+      _ls_insize *= 2;                                                                         \
+    }                                                                                          \
+  }                                                                                            \
+} while (0)
+
+/******************************************************************************
+ * singly linked list macros (non-circular)                                   *
+ *****************************************************************************/
+#define LL_PREPEND(head,add)                                                                   \
+    LL_PREPEND2(head,add,next)
+
+#define LL_PREPEND2(head,add,next)                                                             \
+do {                                                                                           \
+  (add)->next = (head);                                                                        \
+  (head) = (add);                                                                              \
+} while (0)
+
+#define LL_CONCAT(head1,head2)                                                                 \
+    LL_CONCAT2(head1,head2,next)
+
+#define LL_CONCAT2(head1,head2,next)                                                           \
+do {                                                                                           \
+  LDECLTYPE(head1) _tmp;                                                                       \
+  if (head1) {                                                                                 \
+    _tmp = (head1);                                                                            \
+    while (_tmp->next) { _tmp = _tmp->next; }                                                  \
+    _tmp->next=(head2);                                                                        \
+  } else {                                                                                     \
+    (head1)=(head2);                                                                           \
+  }                                                                                            \
+} while (0)
+
+#define LL_APPEND(head,add)                                                                    \
+    LL_APPEND2(head,add,next)
+
+#define LL_APPEND2(head,add,next)                                                              \
+do {                                                                                           \
+  LDECLTYPE(head) _tmp;                                                                        \
+  (add)->next=NULL;                                                                            \
+  if (head) {                                                                                  \
+    _tmp = (head);                                                                             \
+    while (_tmp->next) { _tmp = _tmp->next; }                                                  \
+    _tmp->next=(add);                                                                          \
+  } else {                                                                                     \
+    (head)=(add);                                                                              \
+  }                                                                                            \
+} while (0)
+
+#define LL_DELETE(head,del)                                                                    \
+    LL_DELETE2(head,del,next)
+
+#define LL_DELETE2(head,del,next)                                                              \
+do {                                                                                           \
+  LDECLTYPE(head) _tmp;                                                                        \
+  if ((head) == (del)) {                                                                       \
+    (head)=(head)->next;                                                                       \
+  } else {                                                                                     \
+    _tmp = (head);                                                                             \
+    while (_tmp->next && (_tmp->next != (del))) {                                              \
+      _tmp = _tmp->next;                                                                       \
+    }                                                                                          \
+    if (_tmp->next) {                                                                          \
+      _tmp->next = (del)->next;                                                                \
+    }                                                                                          \
+  }                                                                                            \
+} while (0)
+
+#define LL_COUNT(head,el,counter)                                                              \
+    LL_COUNT2(head,el,counter,next)                                                            \
+
+#define LL_COUNT2(head,el,counter,next)                                                        \
+do {                                                                                           \
+  (counter) = 0;                                                                               \
+  LL_FOREACH2(head,el,next) { ++(counter); }                                                   \
+} while (0)
+
+#define LL_FOREACH(head,el)                                                                    \
+    LL_FOREACH2(head,el,next)
+
+#define LL_FOREACH2(head,el,next)                                                              \
+    for ((el) = (head); el; (el) = (el)->next)
+
+#define LL_FOREACH_SAFE(head,el,tmp)                                                           \
+    LL_FOREACH_SAFE2(head,el,tmp,next)
+
+#define LL_FOREACH_SAFE2(head,el,tmp,next)                                                     \
+  for ((el) = (head); (el) && ((tmp) = (el)->next, 1); (el) = (tmp))
+
+#define LL_SEARCH_SCALAR(head,out,field,val)                                                   \
+    LL_SEARCH_SCALAR2(head,out,field,val,next)
+
+#define LL_SEARCH_SCALAR2(head,out,field,val,next)                                             \
+do {                                                                                           \
+    LL_FOREACH2(head,out,next) {                                                               \
+      if ((out)->field == (val)) break;                                                        \
+    }                                                                                          \
+} while (0)
+
+#define LL_SEARCH(head,out,elt,cmp)                                                            \
+    LL_SEARCH2(head,out,elt,cmp,next)
+
+#define LL_SEARCH2(head,out,elt,cmp,next)                                                      \
+do {                                                                                           \
+    LL_FOREACH2(head,out,next) {                                                               \
+      if ((cmp(out,elt))==0) break;                                                            \
+    }                                                                                          \
+} while (0)
+
+#define LL_REPLACE_ELEM2(head, el, add, next)                                                  \
+do {                                                                                           \
+ LDECLTYPE(head) _tmp;                                                                         \
+ assert((head) != NULL);                                                                       \
+ assert((el) != NULL);                                                                         \
+ assert((add) != NULL);                                                                        \
+ (add)->next = (el)->next;                                                                     \
+ if ((head) == (el)) {                                                                         \
+  (head) = (add);                                                                              \
+ } else {                                                                                      \
+  _tmp = (head);                                                                               \
+  while (_tmp->next && (_tmp->next != (el))) {                                                 \
+   _tmp = _tmp->next;                                                                          \
+  }                                                                                            \
+  if (_tmp->next) {                                                                            \
+    _tmp->next = (add);                                                                        \
+  }                                                                                            \
+ }                                                                                             \
+} while (0)
+
+#define LL_REPLACE_ELEM(head, el, add)                                                         \
+    LL_REPLACE_ELEM2(head, el, add, next)
+
+#define LL_PREPEND_ELEM2(head, el, add, next)                                                  \
+do {                                                                                           \
+ if (el) {                                                                                     \
+  LDECLTYPE(head) _tmp;                                                                        \
+  assert((head) != NULL);                                                                      \
+  assert((add) != NULL);                                                                       \
+  (add)->next = (el);                                                                          \
+  if ((head) == (el)) {                                                                        \
+   (head) = (add);                                                                             \
+  } else {                                                                                     \
+   _tmp = (head);                                                                              \
+   while (_tmp->next && (_tmp->next != (el))) {                                                \
+    _tmp = _tmp->next;                                                                         \
+   }                                                                                           \
+   if (_tmp->next) {                                                                           \
+     _tmp->next = (add);                                                                       \
+   }                                                                                           \
+  }                                                                                            \
+ } else {                                                                                      \
+  LL_APPEND2(head, add, next);                                                                 \
+ }                                                                                             \
+} while (0)                                                                                    \
+
+#define LL_PREPEND_ELEM(head, el, add)                                                         \
+    LL_PREPEND_ELEM2(head, el, add, next)
+
+#define LL_APPEND_ELEM2(head, el, add, next)                                                   \
+do {                                                                                           \
+ if (el) {                                                                                     \
+  assert((head) != NULL);                                                                      \
+  assert((add) != NULL);                                                                       \
+  (add)->next = (el)->next;                                                                    \
+  (el)->next = (add);                                                                          \
+ } else {                                                                                      \
+  LL_PREPEND2(head, add, next);                                                                \
+ }                                                                                             \
+} while (0)                                                                                    \
+
+#define LL_APPEND_ELEM(head, el, add)                                                          \
+    LL_APPEND_ELEM2(head, el, add, next)
+
+#ifdef NO_DECLTYPE
+/* Here are VS2008 / NO_DECLTYPE replacements for a few functions */
+
+#undef LL_CONCAT2
+#define LL_CONCAT2(head1,head2,next)                                                           \
+do {                                                                                           \
+  char *_tmp;                                                                                  \
+  if (head1) {                                                                                 \
+    _tmp = (char*)(head1);                                                                     \
+    while ((head1)->next) { (head1) = (head1)->next; }                                         \
+    (head1)->next = (head2);                                                                   \
+    _RS(head1);                                                                                \
+  } else {                                                                                     \
+    (head1)=(head2);                                                                           \
+  }                                                                                            \
+} while (0)
+
+#undef LL_APPEND2
+#define LL_APPEND2(head,add,next)                                                              \
+do {                                                                                           \
+  if (head) {                                                                                  \
+    (add)->next = head;     /* use add->next as a temp variable */                             \
+    while ((add)->next->next) { (add)->next = (add)->next->next; }                             \
+    (add)->next->next=(add);                                                                   \
+  } else {                                                                                     \
+    (head)=(add);                                                                              \
+  }                                                                                            \
+  (add)->next=NULL;                                                                            \
+} while (0)
+
+#undef LL_DELETE2
+#define LL_DELETE2(head,del,next)                                                              \
+do {                                                                                           \
+  if ((head) == (del)) {                                                                       \
+    (head)=(head)->next;                                                                       \
+  } else {                                                                                     \
+    char *_tmp = (char*)(head);                                                                \
+    while ((head)->next && ((head)->next != (del))) {                                          \
+      (head) = (head)->next;                                                                   \
+    }                                                                                          \
+    if ((head)->next) {                                                                        \
+      (head)->next = ((del)->next);                                                            \
+    }                                                                                          \
+    _RS(head);                                                                                 \
+  }                                                                                            \
+} while (0)
+
+#undef LL_REPLACE_ELEM2
+#define LL_REPLACE_ELEM2(head, el, add, next)                                                  \
+do {                                                                                           \
+  assert((head) != NULL);                                                                      \
+  assert((el) != NULL);                                                                        \
+  assert((add) != NULL);                                                                       \
+  if ((head) == (el)) {                                                                        \
+    (head) = (add);                                                                            \
+  } else {                                                                                     \
+    (add)->next = head;                                                                        \
+    while ((add)->next->next && ((add)->next->next != (el))) {                                 \
+      (add)->next = (add)->next->next;                                                         \
+    }                                                                                          \
+    if ((add)->next->next) {                                                                   \
+      (add)->next->next = (add);                                                               \
+    }                                                                                          \
+  }                                                                                            \
+  (add)->next = (el)->next;                                                                    \
+} while (0)
+
+#undef LL_PREPEND_ELEM2
+#define LL_PREPEND_ELEM2(head, el, add, next)                                                  \
+do {                                                                                           \
+  if (el) {                                                                                    \
+    assert((head) != NULL);                                                                    \
+    assert((add) != NULL);                                                                     \
+    if ((head) == (el)) {                                                                      \
+      (head) = (add);                                                                          \
+    } else {                                                                                   \
+      (add)->next = (head);                                                                    \
+      while ((add)->next->next && ((add)->next->next != (el))) {                               \
+        (add)->next = (add)->next->next;                                                       \
+      }                                                                                        \
+      if ((add)->next->next) {                                                                 \
+        (add)->next->next = (add);                                                             \
+      }                                                                                        \
+    }                                                                                          \
+    (add)->next = (el);                                                                        \
+  } else {                                                                                     \
+    LL_APPEND2(head, add, next);                                                               \
+  }                                                                                            \
+} while (0)                                                                                    \
+
+#endif /* NO_DECLTYPE */
+
+/******************************************************************************
+ * doubly linked list macros (non-circular)                                   *
+ *****************************************************************************/
+#define DL_PREPEND(head,add)                                                                   \
+    DL_PREPEND2(head,add,prev,next)
+
+#define DL_PREPEND2(head,add,prev,next)                                                        \
+do {                                                                                           \
+ (add)->next = (head);                                                                         \
+ if (head) {                                                                                   \
+   (add)->prev = (head)->prev;                                                                 \
+   (head)->prev = (add);                                                                       \
+ } else {                                                                                      \
+   (add)->prev = (add);                                                                        \
+ }                                                                                             \
+ (head) = (add);                                                                               \
+} while (0)
+
+#define DL_APPEND(head,add)                                                                    \
+    DL_APPEND2(head,add,prev,next)
+
+#define DL_APPEND2(head,add,prev,next)                                                         \
+do {                                                                                           \
+  if (head) {                                                                                  \
+      (add)->prev = (head)->prev;                                                              \
+      (head)->prev->next = (add);                                                              \
+      (head)->prev = (add);                                                                    \
+      (add)->next = NULL;                                                                      \
+  } else {                                                                                     \
+      (head)=(add);                                                                            \
+      (head)->prev = (head);                                                                   \
+      (head)->next = NULL;                                                                     \
+  }                                                                                            \
+} while (0)
+
+#define DL_CONCAT(head1,head2)                                                                 \
+    DL_CONCAT2(head1,head2,prev,next)
+
+#define DL_CONCAT2(head1,head2,prev,next)                                                      \
+do {                                                                                           \
+  LDECLTYPE(head1) _tmp;                                                                       \
+  if (head2) {                                                                                 \
+    if (head1) {                                                                               \
+        _CASTASGN(_tmp, (head2)->prev);                                                        \
+        (head2)->prev = (head1)->prev;                                                         \
+        (head1)->prev->next = (head2);                                                         \
+        _CASTASGN((head1)->prev, _tmp);                                                        \
+    } else {                                                                                   \
+        (head1)=(head2);                                                                       \
+    }                                                                                          \
+  }                                                                                            \
+} while (0)
+
+#define DL_DELETE(head,del)                                                                    \
+    DL_DELETE2(head,del,prev,next)
+
+#define DL_DELETE2(head,del,prev,next)                                                         \
+do {                                                                                           \
+  assert((del)->prev != NULL);                                                                 \
+  if ((del)->prev == (del)) {                                                                  \
+      (head)=NULL;                                                                             \
+  } else if ((del)==(head)) {                                                                  \
+      (del)->next->prev = (del)->prev;                                                         \
+      (head) = (del)->next;                                                                    \
+  } else {                                                                                     \
+      (del)->prev->next = (del)->next;                                                         \
+      if ((del)->next) {                                                                       \
+          (del)->next->prev = (del)->prev;                                                     \
+      } else {                                                                                 \
+          (head)->prev = (del)->prev;                                                          \
+      }                                                                                        \
+  }                                                                                            \
+} while (0)
+
+#define DL_COUNT(head,el,counter)                                                              \
+    DL_COUNT2(head,el,counter,next)                                                            \
+
+#define DL_COUNT2(head,el,counter,next)                                                        \
+do {                                                                                           \
+  (counter) = 0;                                                                               \
+  DL_FOREACH2(head,el,next) { ++(counter); }                                                   \
+} while (0)
+
+#define DL_FOREACH(head,el)                                                                    \
+    DL_FOREACH2(head,el,next)
+
+#define DL_FOREACH2(head,el,next)                                                              \
+    for ((el) = (head); el; (el) = (el)->next)
+
+/* this version is safe for deleting the elements during iteration */
+#define DL_FOREACH_SAFE(head,el,tmp)                                                           \
+    DL_FOREACH_SAFE2(head,el,tmp,next)
+
+#define DL_FOREACH_SAFE2(head,el,tmp,next)                                                     \
+  for ((el) = (head); (el) && ((tmp) = (el)->next, 1); (el) = (tmp))
+
+/* these are identical to their singly-linked list counterparts */
+#define DL_SEARCH_SCALAR LL_SEARCH_SCALAR
+#define DL_SEARCH LL_SEARCH
+#define DL_SEARCH_SCALAR2 LL_SEARCH_SCALAR2
+#define DL_SEARCH2 LL_SEARCH2
+
+#define DL_REPLACE_ELEM2(head, el, add, prev, next)                                            \
+do {                                                                                           \
+ assert((head) != NULL);                                                                       \
+ assert((el) != NULL);                                                                         \
+ assert((add) != NULL);                                                                        \
+ if ((head) == (el)) {                                                                         \
+  (head) = (add);                                                                              \
+  (add)->next = (el)->next;                                                                    \
+  if ((el)->next == NULL) {                                                                    \
+   (add)->prev = (add);                                                                        \
+  } else {                                                                                     \
+   (add)->prev = (el)->prev;                                                                   \
+   (add)->next->prev = (add);                                                                  \
+  }                                                                                            \
+ } else {                                                                                      \
+  (add)->next = (el)->next;                                                                    \
+  (add)->prev = (el)->prev;                                                                    \
+  (add)->prev->next = (add);                                                                   \
+  if ((el)->next == NULL) {                                                                    \
+   (head)->prev = (add);                                                                       \
+  } else {                                                                                     \
+   (add)->next->prev = (add);                                                                  \
+  }                                                                                            \
+ }                                                                                             \
+} while (0)
+
+#define DL_REPLACE_ELEM(head, el, add)                                                         \
+    DL_REPLACE_ELEM2(head, el, add, prev, next)
+
+#define DL_PREPEND_ELEM2(head, el, add, prev, next)                                            \
+do {                                                                                           \
+ if (el) {                                                                                     \
+  assert((head) != NULL);                                                                      \
+  assert((add) != NULL);                                                                       \
+  (add)->next = (el);                                                                          \
+  (add)->prev = (el)->prev;                                                                    \
+  (el)->prev = (add);                                                                          \
+  if ((head) == (el)) {                                                                        \
+   (head) = (add);                                                                             \
+  } else {                                                                                     \
+   (add)->prev->next = (add);                                                                  \
+  }                                                                                            \
+ } else {                                                                                      \
+  DL_APPEND2(head, add, prev, next);                                                           \
+ }                                                                                             \
+} while (0)                                                                                    \
+
+#define DL_PREPEND_ELEM(head, el, add)                                                         \
+    DL_PREPEND_ELEM2(head, el, add, prev, next)
+
+#define DL_APPEND_ELEM2(head, el, add, prev, next)                                             \
+do {                                                                                           \
+ if (el) {                                                                                     \
+  assert((head) != NULL);                                                                      \
+  assert((add) != NULL);                                                                       \
+  (add)->next = (el)->next;                                                                    \
+  (add)->prev = (el);                                                                          \
+  (el)->next = (add);                                                                          \
+  if ((add)->next) {                                                                           \
+   (add)->next->prev = (add);                                                                  \
+  } else {                                                                                     \
+   (head)->prev = (add);                                                                       \
+  }                                                                                            \
+ } else {                                                                                      \
+  DL_PREPEND2(head, add, prev, next);                                                          \
+ }                                                                                             \
+} while (0)                                                                                    \
+
+#define DL_APPEND_ELEM(head, el, add)                                                          \
+   DL_APPEND_ELEM2(head, el, add, prev, next)
+
+/******************************************************************************
+ * circular doubly linked list macros                                         *
+ *****************************************************************************/
+#define CDL_APPEND(head,add)                                                                   \
+    CDL_APPEND2(head,add,prev,next)
+
+#define CDL_APPEND2(head,add,prev,next)                                                        \
+do {                                                                                           \
+ if (head) {                                                                                   \
+   (add)->prev = (head)->prev;                                                                 \
+   (add)->next = (head);                                                                       \
+   (head)->prev = (add);                                                                       \
+   (add)->prev->next = (add);                                                                  \
+ } else {                                                                                      \
+   (add)->prev = (add);                                                                        \
+   (add)->next = (add);                                                                        \
+   (head) = (add);                                                                             \
+ }                                                                                             \
+} while (0)
+
+#define CDL_PREPEND(head,add)                                                                  \
+    CDL_PREPEND2(head,add,prev,next)
+
+#define CDL_PREPEND2(head,add,prev,next)                                                       \
+do {                                                                                           \
+ if (head) {                                                                                   \
+   (add)->prev = (head)->prev;                                                                 \
+   (add)->next = (head);                                                                       \
+   (head)->prev = (add);                                                                       \
+   (add)->prev->next = (add);                                                                  \
+ } else {                                                                                      \
+   (add)->prev = (add);                                                                        \
+   (add)->next = (add);                                                                        \
+ }                                                                                             \
+ (head) = (add);                                                                               \
+} while (0)
+
+#define CDL_DELETE(head,del)                                                                   \
+    CDL_DELETE2(head,del,prev,next)
+
+#define CDL_DELETE2(head,del,prev,next)                                                        \
+do {                                                                                           \
+  if (((head)==(del)) && ((head)->next == (head))) {                                           \
+      (head) = NULL;                                                                           \
+  } else {                                                                                     \
+     (del)->next->prev = (del)->prev;                                                          \
+     (del)->prev->next = (del)->next;                                                          \
+     if ((del) == (head)) (head)=(del)->next;                                                  \
+  }                                                                                            \
+} while (0)
+
+#define CDL_COUNT(head,el,counter)                                                             \
+    CDL_COUNT2(head,el,counter,next)                                                           \
+
+#define CDL_COUNT2(head, el, counter,next)                                                     \
+do {                                                                                           \
+  (counter) = 0;                                                                               \
+  CDL_FOREACH2(head,el,next) { ++(counter); }                                                  \
+} while (0)
+
+#define CDL_FOREACH(head,el)                                                                   \
+    CDL_FOREACH2(head,el,next)
+
+#define CDL_FOREACH2(head,el,next)                                                             \
+    for ((el)=(head);el;(el)=(((el)->next==(head)) ? NULL : (el)->next))
+
+#define CDL_FOREACH_SAFE(head,el,tmp1,tmp2)                                                    \
+    CDL_FOREACH_SAFE2(head,el,tmp1,tmp2,prev,next)
+
+#define CDL_FOREACH_SAFE2(head,el,tmp1,tmp2,prev,next)                                         \
+  for ((el) = (head), (tmp1) = (head) ? (head)->prev : NULL;                                   \
+       (el) && ((tmp2) = (el)->next, 1);                                                       \
+       (el) = ((el) == (tmp1) ? NULL : (tmp2)))
+
+#define CDL_SEARCH_SCALAR(head,out,field,val)                                                  \
+    CDL_SEARCH_SCALAR2(head,out,field,val,next)
+
+#define CDL_SEARCH_SCALAR2(head,out,field,val,next)                                            \
+do {                                                                                           \
+    CDL_FOREACH2(head,out,next) {                                                              \
+      if ((out)->field == (val)) break;                                                        \
+    }                                                                                          \
+} while (0)
+
+#define CDL_SEARCH(head,out,elt,cmp)                                                           \
+    CDL_SEARCH2(head,out,elt,cmp,next)
+
+#define CDL_SEARCH2(head,out,elt,cmp,next)                                                     \
+do {                                                                                           \
+    CDL_FOREACH2(head,out,next) {                                                              \
+      if ((cmp(out,elt))==0) break;                                                            \
+    }                                                                                          \
+} while (0)
+
+#define CDL_REPLACE_ELEM2(head, el, add, prev, next)                                           \
+do {                                                                                           \
+ assert((head) != NULL);                                                                       \
+ assert((el) != NULL);                                                                         \
+ assert((add) != NULL);                                                                        \
+ if ((el)->next == (el)) {                                                                     \
+  (add)->next = (add);                                                                         \
+  (add)->prev = (add);                                                                         \
+  (head) = (add);                                                                              \
+ } else {                                                                                      \
+  (add)->next = (el)->next;                                                                    \
+  (add)->prev = (el)->prev;                                                                    \
+  (add)->next->prev = (add);                                                                   \
+  (add)->prev->next = (add);                                                                   \
+  if ((head) == (el)) {                                                                        \
+   (head) = (add);                                                                             \
+  }                                                                                            \
+ }                                                                                             \
+} while (0)
+
+#define CDL_REPLACE_ELEM(head, el, add)                                                        \
+    CDL_REPLACE_ELEM2(head, el, add, prev, next)
+
+#define CDL_PREPEND_ELEM2(head, el, add, prev, next)                                           \
+do {                                                                                           \
+  if (el) {                                                                                    \
+    assert((head) != NULL);                                                                    \
+    assert((add) != NULL);                                                                     \
+    (add)->next = (el);                                                                        \
+    (add)->prev = (el)->prev;                                                                  \
+    (el)->prev = (add);                                                                        \
+    (add)->prev->next = (add);                                                                 \
+    if ((head) == (el)) {                                                                      \
+      (head) = (add);                                                                          \
+    }                                                                                          \
+  } else {                                                                                     \
+    CDL_APPEND2(head, add, prev, next);                                                        \
+  }                                                                                            \
+} while (0)
+
+#define CDL_PREPEND_ELEM(head, el, add)                                                        \
+    CDL_PREPEND_ELEM2(head, el, add, prev, next)
+
+#define CDL_APPEND_ELEM2(head, el, add, prev, next)                                            \
+do {                                                                                           \
+ if (el) {                                                                                     \
+  assert((head) != NULL);                                                                      \
+  assert((add) != NULL);                                                                       \
+  (add)->next = (el)->next;                                                                    \
+  (add)->prev = (el);                                                                          \
+  (el)->next = (add);                                                                          \
+  (add)->next->prev = (add);                                                                   \
+ } else {                                                                                      \
+  CDL_PREPEND2(head, add, prev, next);                                                         \
+ }                                                                                             \
+} while (0)
+
+#define CDL_APPEND_ELEM(head, el, add)                                                         \
+    CDL_APPEND_ELEM2(head, el, add, prev, next)
+
+#endif /* UTLIST_H */
diff --git a/cpp/src/plasma/doc/plasma-doxy-config b/cpp/src/plasma/doc/plasma-doxy-config
new file mode 100644
index 000000000000..9c291f838883
--- /dev/null
+++ b/cpp/src/plasma/doc/plasma-doxy-config
@@ -0,0 +1,2473 @@
+# Doxyfile 1.8.13
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project.
+#
+# All text after a double hash (##) is considered a comment and is placed in
+# front of the TAG it is preceding.
+#
+# All text after a single hash (#) is considered a comment and will be ignored.
+# The format is:
+# TAG = value [value, ...]
+# For lists, items can also be appended using:
+# TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (\" \").
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file
+# that follow. The default is UTF-8 which is also the encoding used for all text
+# before the first occurrence of this tag. Doxygen uses libiconv (or the iconv
+# built into libc) for the transcoding. See http://www.gnu.org/software/libiconv
+# for the list of possible encodings.
+# The default value is: UTF-8.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
+# double-quotes, unless you are using Doxywizard) that should identify the
+# project for which the documentation is generated. This name is used in the
+# title of most generated pages and in a few other places.
+# The default value is: My Project.
+
+PROJECT_NAME           = "Plasma"
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
+# could be handy for archiving the generated documentation or if some version
+# control system is used.
+
+PROJECT_NUMBER         =
+
+# Using the PROJECT_BRIEF tag one can provide an optional one line description
+# for a project that appears at the top of each page and should give viewer a
+# quick idea about the purpose of the project. Keep the description short.
+
+PROJECT_BRIEF          =
+
+# With the PROJECT_LOGO tag one can specify a logo or an icon that is included
+# in the documentation. The maximum height of the logo should not exceed 55
+# pixels and the maximum width should not exceed 200 pixels. Doxygen will copy
+# the logo to the output directory.
+
+PROJECT_LOGO           =
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
+# into which the generated documentation will be written. If a relative path is
+# entered, it will be relative to the location where doxygen was started. If
+# left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       =
+
+# If the CREATE_SUBDIRS tag is set to YES then doxygen will create 4096 sub-
+# directories (in 2 levels) under the output directory of each output format and
+# will distribute the generated files over these directories. Enabling this
+# option can be useful when feeding doxygen a huge amount of source files, where
+# putting all generated files in the same directory would otherwise causes
+# performance problems for the file system.
+# The default value is: NO.
+
+CREATE_SUBDIRS         = NO
+
+# If the ALLOW_UNICODE_NAMES tag is set to YES, doxygen will allow non-ASCII
+# characters to appear in the names of generated files. If set to NO, non-ASCII
+# characters will be escaped, for example _xE3_x81_x84 will be used for Unicode
+# U+3044.
+# The default value is: NO.
+
+ALLOW_UNICODE_NAMES    = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# Possible values are: Afrikaans, Arabic, Armenian, Brazilian, Catalan, Chinese,
+# Chinese-Traditional, Croatian, Czech, Danish, Dutch, English (United States),
+# Esperanto, Farsi (Persian), Finnish, French, German, Greek, Hungarian,
+# Indonesian, Italian, Japanese, Japanese-en (Japanese with English messages),
+# Korean, Korean-en (Korean with English messages), Latvian, Lithuanian,
+# Macedonian, Norwegian, Persian (Farsi), Polish, Portuguese, Romanian, Russian,
+# Serbian, Serbian-Cyrillic, Slovak, Slovene, Spanish, Swedish, Turkish,
+# Ukrainian and Vietnamese.
+# The default value is: English.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES, doxygen will include brief member
+# descriptions after the members that are listed in the file and class
+# documentation (similar to Javadoc). Set to NO to disable this.
+# The default value is: YES.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES, doxygen will prepend the brief
+# description of a member or function before the detailed description
+#
+# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+# The default value is: YES.
+
+REPEAT_BRIEF           = YES
+
+# This tag implements a quasi-intelligent brief description abbreviator that is
+# used to form the text in various listings. Each string in this list, if found
+# as the leading text of the brief description, will be stripped from the text
+# and the result, after processing the whole list, is used as the annotated
+# text. Otherwise, the brief description is used as-is. If left blank, the
+# following values are used ($name is automatically replaced with the name of
+# the entity):The $name class, The $name widget, The $name file, is, provides,
+# specifies, contains, represents, a, an and the.
+
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# doxygen will generate a detailed section even if there is only a brief
+# description.
+# The default value is: NO.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+# The default value is: NO.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES, doxygen will prepend the full path
+# before files name in the file list and in the header files. If set to NO the
+# shortest path that makes the file name unique will be used
+# The default value is: YES.
+
+FULL_PATH_NAMES        = YES
+
+# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
+# Stripping is only done if one of the specified strings matches the left-hand
+# part of the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the path to
+# strip.
+#
+# Note that you can specify absolute paths here, but also relative paths, which
+# will be relative from the directory where doxygen is started.
+# This tag requires that the tag FULL_PATH_NAMES is set to YES.
+
+STRIP_FROM_PATH        =
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
+# path mentioned in the documentation of a class, which tells the reader which
+# header file to include in order to use a class. If left blank only the name of
+# the header file containing the class definition is used. Otherwise one should
+# specify the list of include paths that are normally passed to the compiler
+# using the -I flag.
+
+STRIP_FROM_INC_PATH    =
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
+# less readable) file names. This can be useful is your file systems doesn't
+# support long names like on DOS, Mac, or CD-ROM.
+# The default value is: NO.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
+# first line (until the first dot) of a Javadoc-style comment as the brief
+# description. If set to NO, the Javadoc-style will behave just like regular Qt-
+# style comments (thus requiring an explicit @brief command for a brief
+# description.)
+# The default value is: NO.
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
+# line (until the first dot) of a Qt-style comment as the brief description. If
+# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
+# requiring an explicit \brief command for a brief description.)
+# The default value is: NO.
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
+# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
+# a brief description. This used to be the default behavior. The new default is
+# to treat a multi-line C++ comment block as a detailed description. Set this
+# tag to YES if you prefer the old behavior instead.
+#
+# Note that setting this tag to YES also means that rational rose comments are
+# not recognized any more.
+# The default value is: NO.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
+# documentation from any documented member that it re-implements.
+# The default value is: YES.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES then doxygen will produce a new
+# page for each member. If set to NO, the documentation of a member will be part
+# of the file/class/namespace that contains it.
+# The default value is: NO.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
+# uses this value to replace tabs by spaces in code fragments.
+# Minimum value: 1, maximum value: 16, default value: 4.
+
+TAB_SIZE               = 2
+
+# This tag can be used to specify a number of aliases that act as commands in
+# the documentation. An alias has the form:
+# name=value
+# For example adding
+# "sideeffect=@par Side Effects:\n"
+# will allow you to put the command \sideeffect (or @sideeffect) in the
+# documentation, which will result in a user-defined paragraph with heading
+# "Side Effects:". You can put \n's in the value part of an alias to insert
+# newlines.
+
+ALIASES                =
+
+# This tag can be used to specify a number of word-keyword mappings (TCL only).
+# A mapping has the form "name=value". For example adding "class=itcl::class"
+# will allow you to use the command class in the itcl::class meaning.
+
+TCL_SUBST              =
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
+# only. Doxygen will then generate output that is more tailored for C. For
+# instance, some of the names that are used will be different. The list of all
+# members will be omitted, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_FOR_C  = NO
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
+# Python sources only. Doxygen will then generate output that is more tailored
+# for that language. For instance, namespaces will be presented as packages,
+# qualified scopes will look different, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources. Doxygen will then generate output that is tailored for Fortran.
+# The default value is: NO.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for VHDL.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it
+# parses. With this tag you can assign which parser to use for a given
+# extension. Doxygen has a built-in mapping, but you can override or extend it
+# using this tag. The format is ext=language, where ext is a file extension, and
+# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
+# C#, C, C++, D, PHP, Objective-C, Python, Fortran (fixed format Fortran:
+# FortranFixed, free formatted Fortran: FortranFree, unknown formatted Fortran:
+# Fortran. In the later case the parser tries to guess whether the code is fixed
+# or free formatted code, this is the default for Fortran type files), VHDL. For
+# instance to make doxygen treat .inc files as Fortran files (default is PHP),
+# and .f files as C (default is Fortran), use: inc=Fortran f=C.
+#
+# Note: For files without extension you can use no_extension as a placeholder.
+#
+# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
+# the files are not read by doxygen.
+
+EXTENSION_MAPPING      =
+
+# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
+# according to the Markdown format, which allows for more readable
+# documentation. See http://daringfireball.net/projects/markdown/ for details.
+# The output of markdown processing is further processed by doxygen, so you can
+# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
+# case of backward compatibilities issues.
+# The default value is: YES.
+
+MARKDOWN_SUPPORT       = YES
+
+# When the TOC_INCLUDE_HEADINGS tag is set to a non-zero value, all headings up
+# to that level are automatically included in the table of contents, even if
+# they do not have an id attribute.
+# Note: This feature currently applies only to Markdown headings.
+# Minimum value: 0, maximum value: 99, default value: 0.
+# This tag requires that the tag MARKDOWN_SUPPORT is set to YES.
+
+TOC_INCLUDE_HEADINGS   = 0
+
+# When enabled doxygen tries to link words that correspond to documented
+# classes, or namespaces to their corresponding documentation. Such a link can
+# be prevented in individual cases by putting a % sign in front of the word or
+# globally by setting AUTOLINK_SUPPORT to NO.
+# The default value is: YES.
+
+AUTOLINK_SUPPORT       = YES
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should set this
+# tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string);
+# versus func(std::string) {}). This also make the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+# The default value is: NO.
+
+BUILTIN_STL_SUPPORT    = NO
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+# The default value is: NO.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
+# http://www.riverbankcomputing.co.uk/software/sip/intro) sources only. Doxygen
+# will parse them like normal C++ but will assume all classes use public instead
+# of private inheritance when no explicit protection keyword is present.
+# The default value is: NO.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate
+# getter and setter methods for a property. Setting this option to YES will make
+# doxygen to replace the get and set methods by a property in the documentation.
+# This will only work if the methods are indeed getting or setting a simple
+# type. If this is not the case, or you want to show the methods anyway, you
+# should set this option to NO.
+# The default value is: YES.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+# The default value is: NO.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# If one adds a struct or class to a group and this option is enabled, then also
+# any nested class or struct is added to the same group. By default this option
+# is disabled and one has to add nested compounds explicitly via \ingroup.
+# The default value is: NO.
+
+GROUP_NESTED_COMPOUNDS = NO
+
+# Set the SUBGROUPING tag to YES to allow class member groups of the same type
+# (for instance a group of public functions) to be put as a subgroup of that
+# type (e.g. under the Public Functions section). Set it to NO to prevent
+# subgrouping. Alternatively, this can be done per class using the
+# \nosubgrouping command.
+# The default value is: YES.
+
+SUBGROUPING            = YES
+
+# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
+# are shown inside the group in which they are included (e.g. using \ingroup)
+# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
+# and RTF).
+#
+# Note that this feature does not work in combination with
+# SEPARATE_MEMBER_PAGES.
+# The default value is: NO.
+
+INLINE_GROUPED_CLASSES = NO
+
+# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
+# with only public data fields or simple typedef fields will be shown inline in
+# the documentation of the scope in which they are defined (i.e. file,
+# namespace, or group documentation), provided this scope is documented. If set
+# to NO, structs, classes, and unions are shown on a separate page (for HTML and
+# Man pages) or section (for LaTeX and RTF).
+# The default value is: NO.
+
+INLINE_SIMPLE_STRUCTS  = NO
+
+# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
+# enum is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically be
+# useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+# The default value is: NO.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
+# cache is used to resolve symbols given their name and scope. Since this can be
+# an expensive process and often the same symbol appears multiple times in the
+# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
+# doxygen will become slower. If the cache is too large, memory is wasted. The
+# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
+# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
+# symbols. At the end of a run doxygen will report the cache usage and suggest
+# the optimal cache size from a speed point of view.
+# Minimum value: 0, maximum value: 9, default value: 0.
+
+LOOKUP_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES, doxygen will assume all entities in
+# documentation are documented, even if no documentation was available. Private
+# class members and static file members will be hidden unless the
+# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
+# Note: This will also disable the warnings about undocumented members that are
+# normally produced when WARNINGS is set to YES.
+# The default value is: NO.
+
+EXTRACT_ALL            = YES
+
+# If the EXTRACT_PRIVATE tag is set to YES, all private members of a class will
+# be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_PACKAGE tag is set to YES, all members with package or internal
+# scope will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PACKAGE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES, all static members of a file will be
+# included in the documentation.
+# The default value is: NO.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES, classes (and structs) defined
+# locally in source files will be included in the documentation. If set to NO,
+# only classes defined in header files are included. Does not have any effect
+# for Java sources.
+# The default value is: YES.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. If set to YES, local methods,
+# which are defined in the implementation section but not in the interface are
+# included in the documentation. If set to NO, only methods in the interface are
+# included.
+# The default value is: NO.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base name of
+# the file that contains the anonymous namespace. By default anonymous namespace
+# are hidden.
+# The default value is: NO.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
+# undocumented members inside documented classes or files. If set to NO these
+# members will be included in the various overviews, but no documentation
+# section is generated. This option has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy. If set
+# to NO, these classes will be included in the various overviews. This option
+# has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
+# (class|struct|union) declarations. If set to NO, these declarations will be
+# included in the documentation.
+# The default value is: NO.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
+# documentation blocks found inside the body of a function. If set to NO, these
+# blocks will be appended to the function's detailed documentation block.
+# The default value is: NO.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation that is typed after a
+# \internal command is included. If the tag is set to NO then the documentation
+# will be excluded. Set it to YES to include the internal documentation.
+# The default value is: NO.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
+# names in lower-case letters. If set to YES, upper-case letters are also
+# allowed. This is useful if you have classes or files whose names only differ
+# in case and if your file system supports case sensitive file names. Windows
+# and Mac users are advised to set this option to NO.
+# The default value is: system dependent.
+
+CASE_SENSE_NAMES       = NO
+
+# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
+# their full class and namespace scopes in the documentation. If set to YES, the
+# scope will be hidden.
+# The default value is: NO.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the HIDE_COMPOUND_REFERENCE tag is set to NO (default) then doxygen will
+# append additional text to a page's title, such as Class Reference. If set to
+# YES the compound reference will be hidden.
+# The default value is: NO.
+
+HIDE_COMPOUND_REFERENCE= NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
+# the files that are included by a file in the documentation of that file.
+# The default value is: YES.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the SHOW_GROUPED_MEMB_INC tag is set to YES then Doxygen will add for each
+# grouped member an include statement to the documentation, telling the reader
+# which file to include in order to use the member.
+# The default value is: NO.
+
+SHOW_GROUPED_MEMB_INC  = NO
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
+# files with double quotes in the documentation rather than with sharp brackets.
+# The default value is: NO.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
+# documentation for inline members.
+# The default value is: YES.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
+# (detailed) documentation of file and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order.
+# The default value is: YES.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
+# descriptions of file, namespace and class members alphabetically by member
+# name. If set to NO, the members will appear in declaration order. Note that
+# this will also influence the order of the classes in the class list.
+# The default value is: NO.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
+# (brief and detailed) documentation of class members so that constructors and
+# destructors are listed first. If set to NO the constructors will appear in the
+# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
+# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
+# member documentation.
+# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
+# detailed member documentation.
+# The default value is: NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
+# of group names into alphabetical order. If set to NO the group names will
+# appear in their defined order.
+# The default value is: NO.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
+# fully-qualified names, including namespaces. If set to NO, the class list will
+# be sorted only by class name, not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the alphabetical
+# list.
+# The default value is: NO.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
+# type resolution of all parameters of a function it will reject a match between
+# the prototype and the implementation of a member function even if there is
+# only one candidate or it is obvious which candidate to choose by doing a
+# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
+# accept a match between prototype and implementation in such cases.
+# The default value is: NO.
+
+STRICT_PROTO_MATCHING  = NO
+
+# The GENERATE_TODOLIST tag can be used to enable (YES) or disable (NO) the todo
+# list. This list is created by putting \todo commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable (YES) or disable (NO) the test
+# list. This list is created by putting \test commands in the documentation.
+# The default value is: YES.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable (YES) or disable (NO) the bug
+# list. This list is created by putting \bug commands in the documentation.
+# The default value is: YES.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable (YES) or disable (NO)
+# the deprecated list. This list is created by putting \deprecated commands in
+# the documentation.
+# The default value is: YES.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional documentation
+# sections, marked by \if <section_label> ... \endif and \cond <section_label>
+# ... \endcond blocks.
+
+ENABLED_SECTIONS       =
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
+# initial value of a variable or macro / define can have for it to appear in the
+# documentation. If the initializer consists of more lines than specified here
+# it will be hidden. Use a value of 0 to hide initializers completely. The
+# appearance of the value of individual variables and macros / defines can be
+# controlled using \showinitializer or \hideinitializer command in the
+# documentation regardless of this setting.
+# Minimum value: 0, maximum value: 10000, default value: 30.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
+# the bottom of the documentation of classes and structs. If set to YES, the
+# list will mention the files that were used to generate the documentation.
+# The default value is: YES.
+
+SHOW_USED_FILES        = YES
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
+# will remove the Files entry from the Quick Index and from the Folder Tree View
+# (if specified).
+# The default value is: YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
+# page. This will remove the Namespaces entry from the Quick Index and from the
+# Folder Tree View (if specified).
+# The default value is: YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command command input-file, where command is the value of the
+# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
+# by doxygen. Whatever the program writes to standard output is used as the file
+# version. For an example see the documentation.
+
+FILE_VERSION_FILTER    =
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
+# by doxygen. The layout file controls the global structure of the generated
+# output files in an output format independent way. To create the layout file
+# that represents doxygen's defaults, run doxygen with the -l option. You can
+# optionally specify a file name after the option, if omitted DoxygenLayout.xml
+# will be used as the name of the layout file.
+#
+# Note that if you run doxygen from a directory containing a file called
+# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
+# tag is left empty.
+
+LAYOUT_FILE            =
+
+# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
+# the reference definitions. This must be a list of .bib files. The .bib
+# extension is automatically appended if omitted. This requires the bibtex tool
+# to be installed. See also http://en.wikipedia.org/wiki/BibTeX for more info.
+# For LaTeX the style of the bibliography can be controlled using
+# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
+# search path. See also \cite for info how to create references.
+
+CITE_BIB_FILES         =
+
+#---------------------------------------------------------------------------
+# Configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated to
+# standard output by doxygen. If QUIET is set to YES this implies that the
+# messages are off.
+# The default value is: NO.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated to standard error (stderr) by doxygen. If WARNINGS is set to YES
+# this implies that the warnings are on.
+#
+# Tip: Turn warnings on while writing the documentation.
+# The default value is: YES.
+
+WARNINGS               = YES
+
+# If the WARN_IF_UNDOCUMENTED tag is set to YES then doxygen will generate
+# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
+# will automatically be disabled.
+# The default value is: YES.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as not documenting some parameters
+# in a documented function, or documenting parameters that don't exist or using
+# markup commands wrongly.
+# The default value is: YES.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
+# are documented, but have no documentation for their parameters or return
+# value. If set to NO, doxygen will only warn about wrong or incomplete
+# parameter documentation, but not about the absence of documentation.
+# The default value is: NO.
+
+WARN_NO_PARAMDOC       = NO
+
+# If the WARN_AS_ERROR tag is set to YES then doxygen will immediately stop when
+# a warning is encountered.
+# The default value is: NO.
+
+WARN_AS_ERROR          = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that doxygen
+# can produce. The string should contain the $file, $line, and $text tags, which
+# will be replaced by the file and line number from which the warning originated
+# and the warning text. Optionally the format may contain $version, which will
+# be replaced by the version of the file (if it could be obtained via
+# FILE_VERSION_FILTER)
+# The default value is: $file:$line: $text.
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning and error
+# messages should be written. If left blank the output is written to standard
+# error (stderr).
+
+WARN_LOGFILE           =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag is used to specify the files and/or directories that contain
+# documented source files. You may enter file names like myfile.cpp or
+# directories like /usr/src/myproject. Separate the files or directories with
+# spaces. See also FILE_PATTERNS and EXTENSION_MAPPING
+# Note: If this tag is empty the current directory is searched.
+
+INPUT                  = ../src
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
+# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
+# documentation (see: http://www.gnu.org/software/libiconv) for the list of
+# possible encodings.
+# The default value is: UTF-8.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
+# *.h) to filter out the source-files in the directories.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# read by doxygen.
+#
+# If left blank the following patterns are tested:*.c, *.cc, *.cxx, *.cpp,
+# *.c++, *.java, *.ii, *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h,
+# *.hh, *.hxx, *.hpp, *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc,
+# *.m, *.markdown, *.md, *.mm, *.dox, *.py, *.pyw, *.f90, *.f95, *.f03, *.f08,
+# *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf and *.qsf.
+
+FILE_PATTERNS          = *.c \
+                         *.cc \
+                         *.cxx \
+                         *.cpp \
+                         *.c++ \
+                         *.java \
+                         *.ii \
+                         *.ixx \
+                         *.ipp \
+                         *.i++ \
+                         *.inl \
+                         *.idl \
+                         *.ddl \
+                         *.odl \
+                         *.h \
+                         *.hh \
+                         *.hxx \
+                         *.hpp \
+                         *.h++ \
+                         *.cs \
+                         *.d \
+                         *.php \
+                         *.php4 \
+                         *.php5 \
+                         *.phtml \
+                         *.inc \
+                         *.m \
+                         *.markdown \
+                         *.md \
+                         *.mm \
+                         *.dox \
+                         *.py \
+                         *.pyw \
+                         *.f90 \
+                         *.f95 \
+                         *.f03 \
+                         *.f08 \
+                         *.f \
+                         *.for \
+                         *.tcl \
+                         *.vhd \
+                         *.vhdl \
+                         *.ucf \
+                         *.qsf
+
+# The RECURSIVE tag can be used to specify whether or not subdirectories should
+# be searched for input files as well.
+# The default value is: NO.
+
+RECURSIVE              = NO
+
+# The EXCLUDE tag can be used to specify files and/or directories that should be
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+#
+# Note that relative paths are relative to the directory from which doxygen is
+# run.
+
+EXCLUDE                = ../src/utarray.h ../src/uthash.h
+
+# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
+# directories that are symbolic links (a Unix file system feature) are excluded
+# from the input.
+# The default value is: NO.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories.
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       =
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories use the pattern */test/*
+
+EXCLUDE_SYMBOLS        =
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or directories
+# that contain example code fragments that are included (see the \include
+# command).
+
+EXAMPLE_PATH           =
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
+# *.h) to filter out the source-files in the directories. If left blank all
+# files are included.
+
+EXAMPLE_PATTERNS       = *
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude commands
+# irrespective of the value of the RECURSIVE tag.
+# The default value is: NO.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or directories
+# that contain images that are to be included in the documentation (see the
+# \image command).
+
+IMAGE_PATH             =
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command:
+#
+# <filter> <input-file>
+#
+# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
+# name of an input file. Doxygen will then use the output that the filter
+# program writes to standard output. If FILTER_PATTERNS is specified, this tag
+# will be ignored.
+#
+# Note that the filter must not add or remove lines; it is applied before the
+# code is scanned, but not when the output code is generated. If lines are added
+# or removed, the anchors will not be placed correctly.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+INPUT_FILTER           =
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis. Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match. The filters are a list of the form: pattern=filter
+# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
+# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
+# patterns match the file name, INPUT_FILTER is applied.
+#
+# Note that for custom extensions or not directly supported extensions you also
+# need to set EXTENSION_MAPPING for the extension otherwise the files are not
+# properly processed by doxygen.
+
+FILTER_PATTERNS        =
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER) will also be used to filter the input files that are used for
+# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
+# The default value is: NO.
+
+FILTER_SOURCE_FILES    = NO
+
+# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
+# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
+# it is also possible to disable source filtering for a specific pattern using
+# *.ext= (so without naming a filter).
+# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.
+
+FILTER_SOURCE_PATTERNS =
+
+# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
+# is part of the input, its contents will be placed on the main page
+# (index.html). This can be useful if you have a project on for instance GitHub
+# and want to reuse the introduction page also for the doxygen output.
+
+USE_MDFILE_AS_MAINPAGE =
+
+#---------------------------------------------------------------------------
+# Configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
+# generated. Documented entities will be cross-referenced with these sources.
+#
+# Note: To get rid of all source code in the generated output, make sure that
+# also VERBATIM_HEADERS is set to NO.
+# The default value is: NO.
+
+SOURCE_BROWSER         = NO
+
+# Setting the INLINE_SOURCES tag to YES will include the body of functions,
+# classes and enums directly into the documentation.
+# The default value is: NO.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
+# special comment blocks from generated source code fragments. Normal C, C++ and
+# Fortran comments will always remain visible.
+# The default value is: YES.
+
+STRIP_CODE_COMMENTS    = YES
+
+# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
+# function all documented functions referencing it will be listed.
+# The default value is: NO.
+
+REFERENCED_BY_RELATION = NO
+
+# If the REFERENCES_RELATION tag is set to YES then for each documented function
+# all documented entities called/used by that function will be listed.
+# The default value is: NO.
+
+REFERENCES_RELATION    = NO
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
+# to YES then the hyperlinks from functions in REFERENCES_RELATION and
+# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
+# link to the documentation.
+# The default value is: YES.
+
+REFERENCES_LINK_SOURCE = YES
+
+# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
+# source code will show a tooltip with additional information such as prototype,
+# brief description and links to the definition and documentation. Since this
+# will make the HTML file larger and loading of large files a bit slower, you
+# can opt to disable this feature.
+# The default value is: YES.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+SOURCE_TOOLTIPS        = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code will
+# point to the HTML generated by the htags(1) tool instead of doxygen built-in
+# source browser. The htags tool is part of GNU's global source tagging system
+# (see http://www.gnu.org/software/global/global.html). You will need version
+# 4.8.6 or higher.
+#
+# To use it do the following:
+# - Install the latest version of global
+# - Enable SOURCE_BROWSER and USE_HTAGS in the config file
+# - Make sure the INPUT points to the root of the source tree
+# - Run doxygen as normal
+#
+# Doxygen will invoke htags (and that will in turn invoke gtags), so these
+# tools must be available from the command line (i.e. in the search path).
+#
+# The result: instead of the source browser generated by doxygen, the links to
+# source code will now point to the output of htags.
+# The default value is: NO.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
+# verbatim copy of the header file for each class for which an include is
+# specified. Set to NO to disable this.
+# See also: Section \class.
+# The default value is: YES.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
+# compounds will be generated. Enable this if the project contains a lot of
+# classes, structs, unions or interfaces.
+# The default value is: YES.
+
+ALPHABETICAL_INDEX     = YES
+
+# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
+# which the alphabetical index list will be split.
+# Minimum value: 1, maximum value: 20, default value: 5.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all classes will
+# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
+# can be used to specify a prefix (or a list of prefixes) that should be ignored
+# while generating the index headers.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+IGNORE_PREFIX          =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES, doxygen will generate HTML output
+# The default value is: YES.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
+# generated HTML page (for example: .htm, .php, .asp).
+# The default value is: .html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
+# each generated HTML page. If the tag is left blank doxygen will generate a
+# standard header.
+#
+# To get valid HTML the header file that includes any scripts and style sheets
+# that doxygen needs, which is dependent on the configuration options used (e.g.
+# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
+# default header using
+# doxygen -w html new_header.html new_footer.html new_stylesheet.css
+# YourConfigFile
+# and then modify the file new_header.html. See also section "Doxygen usage"
+# for information on how to generate the default header that doxygen normally
+# uses.
+# Note: The header is subject to change so you typically have to regenerate the
+# default header when upgrading to a newer version of doxygen. For a description
+# of the possible markers and block names see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_HEADER            =
+
+# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
+# generated HTML page. If the tag is left blank doxygen will generate a standard
+# footer. See HTML_HEADER for more information on how to generate a default
+# footer and what special commands can be used inside the footer. See also
+# section "Doxygen usage" for information on how to generate the default footer
+# that doxygen normally uses.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FOOTER            =
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
+# sheet that is used by each HTML page. It can be used to fine-tune the look of
+# the HTML output. If left blank doxygen will generate a default style sheet.
+# See also section "Doxygen usage" for information on how to generate the style
+# sheet that doxygen normally uses.
+# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
+# it is more robust and this tag (HTML_STYLESHEET) will in the future become
+# obsolete.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_STYLESHEET        =
+
+# The HTML_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# cascading style sheets that are included after the standard style sheets
+# created by doxygen. Using this option one can overrule certain style aspects.
+# This is preferred over using HTML_STYLESHEET since it does not replace the
+# standard style sheet and is therefore more robust against future updates.
+# Doxygen will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list). For an example see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_STYLESHEET  =
+
+# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the HTML output directory. Note
+# that these files will be copied to the base HTML output directory. Use the
+# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
+# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
+# files will be copied as-is; there are no commands or markers available.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_FILES       =
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
+# will adjust the colors in the style sheet and background images according to
+# this color. Hue is specified as an angle on a colorwheel, see
+# http://en.wikipedia.org/wiki/Hue for more information. For instance the value
+# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
+# purple, and 360 is red again.
+# Minimum value: 0, maximum value: 359, default value: 220.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_HUE    = 220
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
+# in the HTML output. For a value of 0 the output will use grayscales only. A
+# value of 255 will produce the most vivid colors.
+# Minimum value: 0, maximum value: 255, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_SAT    = 100
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
+# luminance component of the colors in the HTML output. Values below 100
+# gradually make the output lighter, whereas values above 100 make the output
+# darker. The value divided by 100 is the actual gamma applied, so 80 represents
+# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
+# change the gamma.
+# Minimum value: 40, maximum value: 240, default value: 80.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_GAMMA  = 80
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+# page will contain the date and time when the page was generated. Setting this
+# to YES can help to show when doxygen was last run and thus if the
+# documentation is up to date.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_TIMESTAMP         = NO
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_SECTIONS  = NO
+
+# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
+# shown in the various tree structured indices initially; the user can expand
+# and collapse entries dynamically later on. Doxygen will expand the tree to
+# such a level that at most the specified number of entries are visible (unless
+# a fully collapsed tree already exceeds this amount). So setting the number of
+# entries 1 will produce a full collapsed tree by default. 0 is a special value
+# representing an infinite number of entries and will result in a full expanded
+# tree by default.
+# Minimum value: 0, maximum value: 9999, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_INDEX_NUM_ENTRIES = 100
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files will be
+# generated that can be used as input for Apple's Xcode 3 integrated development
+# environment (see: http://developer.apple.com/tools/xcode/), introduced with
+# OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a
+# Makefile in the HTML output directory. Running make will produce the docset in
+# that directory and running make install will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
+# startup. See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
+# for more information.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_DOCSET        = NO
+
+# This tag determines the name of the docset feed. A documentation feed provides
+# an umbrella under which multiple documentation sets from a single provider
+# (such as a company or product suite) can be grouped.
+# The default value is: Doxygen generated docs.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# This tag specifies a string that should uniquely identify the documentation
+# set bundle. This should be a reverse domain-name style string, e.g.
+# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
+# the documentation publisher. This should be a reverse domain-name style
+# string, e.g. com.mycompany.MyDocSet.documentation.
+# The default value is: org.doxygen.Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
+# The default value is: Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
+# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
+# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
+# (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on
+# Windows.
+#
+# The HTML Help Workshop contains a compiler that can convert all HTML output
+# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
+# files are now used as the Windows 98 help format, and will replace the old
+# Windows help format (.hlp) on all Windows platforms in the future. Compressed
+# HTML files also contain an index, a table of contents, and you can search for
+# words in the documentation. The HTML workshop also contains a viewer for
+# compressed HTML files.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_HTMLHELP      = NO
+
+# The CHM_FILE tag can be used to specify the file name of the resulting .chm
+# file. You can add a path in front of the file if the result should not be
+# written to the html output directory.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_FILE               =
+
+# The HHC_LOCATION tag can be used to specify the location (absolute path
+# including file name) of the HTML help compiler (hhc.exe). If non-empty,
+# doxygen will try to run the HTML help compiler on the generated index.hhp.
+# The file has to be specified with full path.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+HHC_LOCATION           =
+
+# The GENERATE_CHI flag controls if a separate .chi index file is generated
+# (YES) or that it should be included in the master .chm file (NO).
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+GENERATE_CHI           = NO
+
+# The CHM_INDEX_ENCODING is used to encode HtmlHelp index (hhk), content (hhc)
+# and project file content.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_INDEX_ENCODING     =
+
+# The BINARY_TOC flag controls whether a binary table of contents is generated
+# (YES) or a normal table of contents (NO) in the .chm file. Furthermore it
+# enables the Previous and Next buttons.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members to
+# the table of contents of the HTML help documentation and to the tree view.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
+# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
+# (.qch) of the generated HTML documentation.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
+# the file name of the resulting .qch file. The path specified is relative to
+# the HTML output folder.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QCH_FILE               =
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
+# Project output. For more information please see Qt Help Project / Namespace
+# (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#namespace).
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
+# Help Project output. For more information please see Qt Help Project / Virtual
+# Folders (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#virtual-
+# folders).
+# The default value is: doc.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
+# filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_NAME   =
+
+# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
+# custom filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_ATTRS  =
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
+# project's filter section matches. Qt Help Project / Filter Attributes (see:
+# http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_SECT_FILTER_ATTRS  =
+
+# The QHG_LOCATION tag can be used to specify the location of Qt's
+# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
+# generated .qhp file.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHG_LOCATION           =
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
+# generated, together with the HTML files, they form an Eclipse help plugin. To
+# install this plugin and make it available under the help contents menu in
+# Eclipse, the contents of the directory containing the HTML and XML files needs
+# to be copied into the plugins directory of eclipse. The name of the directory
+# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
+# After copying Eclipse needs to be restarted before the help appears.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the Eclipse help plugin. When installing the plugin
+# the directory name containing the HTML and XML files should also have this
+# name. Each documentation set should have its own identifier.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# If you want full control over the layout of the generated HTML pages it might
+# be necessary to disable the index and replace it with your own. The
+# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
+# of each HTML page. A value of NO enables the index and the value YES disables
+# it. Since the tabs in the index contain the same information as the navigation
+# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+DISABLE_INDEX          = NO
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information. If the tag
+# value is set to YES, a side panel will be generated containing a tree-like
+# index structure (just like the one that is generated for HTML Help). For this
+# to work a browser that supports JavaScript, DHTML, CSS and frames is required
+# (i.e. any modern browser). Windows users are probably better off using the
+# HTML help feature. Via custom style sheets (see HTML_EXTRA_STYLESHEET) one can
+# further fine-tune the look of the index. As an example, the default style
+# sheet generated by doxygen has an example that shows how to put an image at
+# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
+# the same information as the tab index, you could consider setting
+# DISABLE_INDEX to YES when enabling this option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_TREEVIEW      = NO
+
+# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
+# doxygen will group on one line in the generated HTML documentation.
+#
+# Note that a value of 0 will completely suppress the enum values from appearing
+# in the overview section.
+# Minimum value: 0, maximum value: 20, default value: 4.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
+# to set the initial width (in pixels) of the frame in which the tree is shown.
+# Minimum value: 0, maximum value: 1500, default value: 250.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+TREEVIEW_WIDTH         = 250
+
+# If the EXT_LINKS_IN_WINDOW option is set to YES, doxygen will open links to
+# external symbols imported via tag files in a separate window.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# Use this tag to change the font size of LaTeX formulas included as images in
+# the HTML documentation. When you change the font size after a successful
+# doxygen run you need to manually remove any form_*.png images from the HTML
+# output directory to force them to be regenerated.
+# Minimum value: 8, maximum value: 50, default value: 10.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANPARENT tag to determine whether or not the images
+# generated for formulas are transparent PNGs. Transparent PNGs are not
+# supported properly for IE 6.0, but are supported on all modern browsers.
+#
+# Note that when changing this option you need to delete any form_*.png files in
+# the HTML output directory before the changes have effect.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_TRANSPARENT    = YES
+
+# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
+# http://www.mathjax.org) which uses client side Javascript for the rendering
+# instead of using pre-rendered bitmaps. Use this if you do not have LaTeX
+# installed or if you want to formulas look prettier in the HTML output. When
+# enabled you may also need to install MathJax separately and configure the path
+# to it using the MATHJAX_RELPATH option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+USE_MATHJAX            = NO
+
+# When MathJax is enabled you can set the default output format to be used for
+# the MathJax output. See the MathJax site (see:
+# http://docs.mathjax.org/en/latest/output.html) for more details.
+# Possible values are: HTML-CSS (which is slower, but has the best
+# compatibility), NativeMML (i.e. MathML) and SVG.
+# The default value is: HTML-CSS.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_FORMAT         = HTML-CSS
+
+# When MathJax is enabled you need to specify the location relative to the HTML
+# output directory using the MATHJAX_RELPATH option. The destination directory
+# should contain the MathJax.js script. For instance, if the mathjax directory
+# is located at the same level as the HTML output directory, then
+# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
+# Content Delivery Network so you can quickly see the result without installing
+# MathJax. However, it is strongly recommended to install a local copy of
+# MathJax from http://www.mathjax.org before deployment.
+# The default value is: http://cdn.mathjax.org/mathjax/latest.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_RELPATH        = http://cdn.mathjax.org/mathjax/latest
+
+# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
+# extension names that should be enabled during MathJax rendering. For example
+# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_EXTENSIONS     =
+
+# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
+# of code that will be used on startup of the MathJax code. See the MathJax site
+# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
+# example see the documentation.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_CODEFILE       =
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
+# the HTML output. The underlying search engine uses javascript and DHTML and
+# should work on any modern browser. Note that when using HTML help
+# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
+# there is already a search function so this one should typically be disabled.
+# For large projects the javascript based search engine can be slow, then
+# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
+# search using the keyboard; to jump to the search box use <access key> + S
+# (what the <access key> is depends on the OS and browser, but it is typically
+# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
+# key> to jump into the search results window, the results can be navigated
+# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
+# the search. The filter options can be selected when the cursor is inside the
+# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
+# to select a filter and <Enter> or <escape> to activate or cancel the filter
+# option.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+SEARCHENGINE           = YES
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+# implemented using a web server instead of a web client using Javascript. There
+# are two flavors of web server based searching depending on the EXTERNAL_SEARCH
+# setting. When disabled, doxygen will generate a PHP script for searching and
+# an index file used by the script. When EXTERNAL_SEARCH is enabled the indexing
+# and searching needs to be provided by external tools. See the section
+# "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SERVER_BASED_SEARCH    = NO
+
+# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
+# script for searching. Instead the search results are written to an XML file
+# which needs to be processed by an external indexer. Doxygen will invoke an
+# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
+# search results.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: http://xapian.org/).
+#
+# See the section "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH        = NO
+
+# The SEARCHENGINE_URL should point to a search engine hosted by a web server
+# which will return the search results when EXTERNAL_SEARCH is enabled.
+#
+# Doxygen ships with an example indexer (doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: http://xapian.org/). See the section "External Indexing and
+# Searching" for details.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHENGINE_URL       =
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
+# search data is written to a file for indexing by an external tool. With the
+# SEARCHDATA_FILE tag the name of this file can be specified.
+# The default file is: searchdata.xml.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHDATA_FILE        = searchdata.xml
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
+# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
+# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
+# projects and redirect the results back to the right project.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH_ID     =
+
+# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
+# projects other than the one defined by this configuration file, but that are
+# all added to the same external search index. Each project needs to have a
+# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
+# to a relative location where the documentation can be found. The format is:
+# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTRA_SEARCH_MAPPINGS  =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES, doxygen will generate LaTeX output.
+# The default value is: YES.
+
+GENERATE_LATEX         = YES
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked.
+#
+# Note that when enabling USE_PDFLATEX this option is only used for generating
+# bitmaps for formulas in the HTML output, but not in the Makefile that is
+# written to the output directory.
+# The default file is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
+# index for LaTeX.
+# The default file is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES, doxygen generates more compact LaTeX
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+COMPACT_LATEX          = NO
+
+# The PAPER_TYPE tag can be used to set the paper type that is used by the
+# printer.
+# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
+# 14 inches) and executive (7.25 x 10.5 inches).
+# The default value is: a4.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PAPER_TYPE             = a4
+
+# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
+# that should be included in the LaTeX output. The package can be specified just
+# by its name or with the correct syntax as to be used with the LaTeX
+# \usepackage command. To get the times font for instance you can specify :
+# EXTRA_PACKAGES=times or EXTRA_PACKAGES={times}
+# To use the option intlimits with the amsmath package you can specify:
+# EXTRA_PACKAGES=[intlimits]{amsmath}
+# If left blank no extra packages will be included.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+EXTRA_PACKAGES         =
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
+# generated LaTeX document. The header should contain everything until the first
+# chapter. If it is left blank doxygen will generate a standard header. See
+# section "Doxygen usage" for information on how to let doxygen write the
+# default header to a separate file.
+#
+# Note: Only use a user-defined header if you know what you are doing! The
+# following commands have a special meaning inside the header: $title,
+# $datetime, $date, $doxygenversion, $projectname, $projectnumber,
+# $projectbrief, $projectlogo. Doxygen will replace $title with the empty
+# string, for the replacement values of the other commands the user is referred
+# to HTML_HEADER.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HEADER           =
+
+# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
+# generated LaTeX document. The footer should contain everything after the last
+# chapter. If it is left blank doxygen will generate a standard footer. See
+# LATEX_HEADER for more information on how to generate a default footer and what
+# special commands can be used inside the footer.
+#
+# Note: Only use a user-defined footer if you know what you are doing!
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_FOOTER           =
+
+# The LATEX_EXTRA_STYLESHEET tag can be used to specify additional user-defined
+# LaTeX style sheets that are included after the standard style sheets created
+# by doxygen. Using this option one can overrule certain style aspects. Doxygen
+# will copy the style sheet files to the output directory.
+# Note: The order of the extra style sheet files is of importance (e.g. the last
+# style sheet in the list overrules the setting of the previous ones in the
+# list).
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_STYLESHEET =
+
+# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the LATEX_OUTPUT output
+# directory. Note that the files will be copied as-is; there are no commands or
+# markers available.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_FILES      =
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
+# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
+# contain links (just like the HTML output) instead of page references. This
+# makes the output suitable for online browsing using a PDF viewer.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PDF_HYPERLINKS         = YES
+
+# If the USE_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
+# the PDF file directly from the LaTeX files. Set this option to YES, to get a
+# higher quality PDF documentation.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
+# command to the generated LaTeX files. This will instruct LaTeX to keep running
+# if errors occur, instead of asking the user for help. This option is also used
+# when generating formulas in HTML.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BATCHMODE        = NO
+
+# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
+# index chapters (such as File Index, Compound Index, etc.) in the output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HIDE_INDICES     = NO
+
+# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
+# code with syntax highlighting in the LaTeX output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_SOURCE_CODE      = NO
+
+# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
+# bibliography, e.g. plainnat, or ieeetr. See
+# http://en.wikipedia.org/wiki/BibTeX and \cite for more info.
+# The default value is: plain.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BIB_STYLE        = plain
+
+# If the LATEX_TIMESTAMP tag is set to YES then the footer of each generated
+# page will contain the date and time when the page was generated. Setting this
+# to NO can help when comparing the output of multiple runs.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_TIMESTAMP        = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES, doxygen will generate RTF output. The
+# RTF output is optimized for Word 97 and may not look too pretty with other RTF
+# readers/editors.
+# The default value is: NO.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: rtf.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES, doxygen generates more compact RTF
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
+# contain hyperlink fields. The RTF file will contain links (just like the HTML
+# output) instead of page references. This makes the output suitable for online
+# browsing using Word or some other Word compatible readers that support those
+# fields.
+#
+# Note: WordPad (write) and others do not support links.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's config
+# file, i.e. a series of assignments. You only have to provide replacements,
+# missing definitions are set to their default value.
+#
+# See also section "Doxygen usage" for information on how to generate the
+# default style sheet that doxygen normally uses.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_STYLESHEET_FILE    =
+
+# Set optional variables used in the generation of an RTF document. Syntax is
+# similar to doxygen's config file. A template extensions file can be generated
+# using doxygen -e rtf extensionFile.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_EXTENSIONS_FILE    =
+
+# If the RTF_SOURCE_CODE tag is set to YES then doxygen will include source code
+# with syntax highlighting in the RTF output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_SOURCE_CODE        = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES, doxygen will generate man pages for
+# classes and files.
+# The default value is: NO.
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it. A directory man3 will be created inside the directory specified by
+# MAN_OUTPUT.
+# The default directory is: man.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to the generated
+# man pages. In case the manual section does not start with a number, the number
+# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
+# optional.
+# The default value is: .3.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_EXTENSION          = .3
+
+# The MAN_SUBDIR tag determines the name of the directory created within
+# MAN_OUTPUT in which the man pages are placed. If defaults to man followed by
+# MAN_EXTENSION with the initial . removed.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_SUBDIR             =
+
+# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
+# will generate one additional man file for each entity documented in the real
+# man page(s). These additional files only source the real man page, but without
+# them the man command would be unable to find the correct page.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES, doxygen will generate an XML file that
+# captures the structure of the code including all documentation.
+# The default value is: NO.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: xml.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_OUTPUT             = xml
+
+# If the XML_PROGRAMLISTING tag is set to YES, doxygen will dump the program
+# listings (including syntax highlighting and cross-referencing information) to
+# the XML output. Note that enabling this will significantly increase the size
+# of the XML output.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the DOCBOOK output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_DOCBOOK tag is set to YES, doxygen will generate Docbook files
+# that can be used to generate PDF.
+# The default value is: NO.
+
+GENERATE_DOCBOOK       = NO
+
+# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
+# front of it.
+# The default directory is: docbook.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_OUTPUT         = docbook
+
+# If the DOCBOOK_PROGRAMLISTING tag is set to YES, doxygen will include the
+# program listings (including syntax highlighting and cross-referencing
+# information) to the DOCBOOK output. Note that enabling this will significantly
+# increase the size of the DOCBOOK output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_PROGRAMLISTING = NO
+
+#---------------------------------------------------------------------------
+# Configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES, doxygen will generate an
+# AutoGen Definitions (see http://autogen.sf.net) file that captures the
+# structure of the code including all documentation. Note that this feature is
+# still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES, doxygen will generate a Perl module
+# file that captures the structure of the code including all documentation.
+#
+# Note that this feature is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES, doxygen will generate the necessary
+# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
+# output from the Perl module output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES, the Perl module output will be nicely
+# formatted so it can be parsed by a human reader. This is useful if you want to
+# understand what is going on. On the other hand, if this tag is set to NO, the
+# size of the Perl module output will be much smaller and Perl will parse it
+# just the same.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file are
+# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
+# so different doxyrules.make files included by the same Makefile don't
+# overwrite each other's variables.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_MAKEVAR_PREFIX =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES, doxygen will evaluate all
+# C-preprocessor directives found in the sources and include files.
+# The default value is: YES.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES, doxygen will expand all macro names
+# in the source code. If set to NO, only conditional compilation will be
+# performed. Macro expansion can be done in a controlled way by setting
+# EXPAND_ONLY_PREDEF to YES.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
+# the macro expansion is limited to the macros specified with the PREDEFINED and
+# EXPAND_AS_DEFINED tags.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES, the include files in the
+# INCLUDE_PATH will be searched if a #include is found.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by the
+# preprocessor.
+# This tag requires that the tag SEARCH_INCLUDES is set to YES.
+
+INCLUDE_PATH           =
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will be
+# used.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+INCLUDE_FILE_PATTERNS  =
+
+# The PREDEFINED tag can be used to specify one or more macro names that are
+# defined before the preprocessor is started (similar to the -D option of e.g.
+# gcc). The argument of the tag is a list of macros of the form: name or
+# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
+# is assumed. To prevent a macro definition from being undefined via #undef or
+# recursively expanded use the := operator instead of the = operator.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+PREDEFINED             =
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
+# tag can be used to specify a list of macro names that should be expanded. The
+# macro definition that is found in the sources will be used. Use the PREDEFINED
+# tag if you want to use a different macro definition that overrules the
+# definition found in the source code.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_AS_DEFINED      =
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
+# remove all references to function-like macros that are alone on a line, have
+# an all uppercase name, and do not end with a semicolon. Such function macros
+# are typically used for boiler-plate code, and will confuse the parser if not
+# removed.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES tag can be used to specify one or more tag files. For each tag
+# file the location of the external documentation should be added. The format of
+# a tag file without this location is as follows:
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where loc1 and loc2 can be relative or absolute paths or URLs. See the
+# section "Linking to external documentation" for more information about the use
+# of tag files.
+# Note: Each tag file must have a unique name (where the name does NOT include
+# the path). If a tag file is not located in the directory in which doxygen is
+# run, you must also specify the path to the tagfile here.
+
+TAGFILES               =
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
+# tag file that is based on the input files it reads. See section "Linking to
+# external documentation" for more information about the usage of tag files.
+
+GENERATE_TAGFILE       =
+
+# If the ALLEXTERNALS tag is set to YES, all external class will be listed in
+# the class index. If set to NO, only the inherited external classes will be
+# listed.
+# The default value is: NO.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES, all external groups will be listed
+# in the modules index. If set to NO, only the current project's groups will be
+# listed.
+# The default value is: YES.
+
+EXTERNAL_GROUPS        = YES
+
+# If the EXTERNAL_PAGES tag is set to YES, all external pages will be listed in
+# the related pages index. If set to NO, only the current project's pages will
+# be listed.
+# The default value is: YES.
+
+EXTERNAL_PAGES         = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script
+# interpreter (i.e. the result of 'which perl').
+# The default file (with absolute path) is: /usr/bin/perl.
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES, doxygen will generate a class diagram
+# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
+# NO turns the diagrams off. Note that this option also works with HAVE_DOT
+# disabled, but it is recommended to install and use dot, since it yields more
+# powerful graphs.
+# The default value is: YES.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc
+# command. Doxygen will then run the mscgen tool (see:
+# http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where
+# the mscgen tool resides. If left empty the tool is assumed to be found in the
+# default search path.
+
+MSCGEN_PATH            =
+
+# You can include diagrams made with dia in doxygen documentation. Doxygen will
+# then run dia to produce the diagram and insert it in the documentation. The
+# DIA_PATH tag allows you to specify the directory where the dia binary resides.
+# If left empty dia is assumed to be found in the default search path.
+
+DIA_PATH               =
+
+# If set to YES the inheritance and collaboration graphs will hide inheritance
+# and usage relations if the target is undocumented or is not a class.
+# The default value is: YES.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz (see:
+# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
+# Bell Labs. The other options in this section have no effect if this option is
+# set to NO
+# The default value is: NO.
+
+HAVE_DOT               = NO
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
+# to run in parallel. When set to 0 doxygen will base this on the number of
+# processors available in the system. You can set it explicitly to a value
+# larger than 0 to get control over the balance between CPU load and processing
+# speed.
+# Minimum value: 0, maximum value: 32, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_NUM_THREADS        = 0
+
+# When you want a differently looking font in the dot files that doxygen
+# generates you can specify the font name using DOT_FONTNAME. You need to make
+# sure dot is able to find the font, which can be done by putting it in a
+# standard location or by setting the DOTFONTPATH environment variable or by
+# setting DOT_FONTPATH to the directory containing the font.
+# The default value is: Helvetica.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTNAME           = Helvetica
+
+# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
+# dot graphs.
+# Minimum value: 4, maximum value: 24, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the default font as specified with
+# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
+# the path where dot can find it using this tag.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTPATH           =
+
+# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
+# each documented class showing the direct and indirect inheritance relations.
+# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
+# graph for each documented class showing the direct and indirect implementation
+# dependencies (inheritance, containment, and class references variables) of the
+# class with other documented classes.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
+# groups, showing the direct groups dependencies.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES, doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LOOK               = NO
+
+# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
+# class node. If there are many fields or methods and many nodes the graph may
+# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
+# number of items for each type to make the size more manageable. Set this to 0
+# for no limit. Note that the threshold may be exceeded by 50% before the limit
+# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
+# but if the number exceeds 15, the total amount of fields shown is limited to
+# 10.
+# Minimum value: 0, maximum value: 100, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LIMIT_NUM_FIELDS   = 10
+
+# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
+# collaboration graphs will show the relations between templates and their
+# instances.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+TEMPLATE_RELATIONS     = NO
+
+# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
+# YES then doxygen will generate a graph for each documented file showing the
+# direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDE_GRAPH          = YES
+
+# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
+# set to YES then doxygen will generate a graph for each documented file showing
+# the direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable call graphs for selected
+# functions only using the \callgraph command. Disabling a call graph can be
+# accomplished by means of the command \hidecallgraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable caller graphs for selected
+# functions only using the \callergraph command. Disabling a caller graph can be
+# accomplished by means of the command \hidecallergraph.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
+# hierarchy of all classes instead of a textual one.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
+# dependencies a directory has on other directories in a graphical way. The
+# dependency relations are determined by the #include relations between the
+# files in the directories.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot. For an explanation of the image formats see the section
+# output formats in the documentation of the dot tool (Graphviz (see:
+# http://www.graphviz.org/)).
+# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
+# to make the SVG files visible in IE 9+ (other browsers do not have this
+# requirement).
+# Possible values are: png, jpg, gif, svg, png:gd, png:gd:gd, png:cairo,
+# png:cairo:gd, png:cairo:cairo, png:cairo:gdiplus, png:gdiplus and
+# png:gdiplus:gdiplus.
+# The default value is: png.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_IMAGE_FORMAT       = png
+
+# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
+# enable generation of interactive SVG images that allow zooming and panning.
+#
+# Note that this requires a modern browser other than Internet Explorer. Tested
+# and working are Firefox, Chrome, Safari, and Opera.
+# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
+# the SVG files visible. Older versions of IE do not have SVG support.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INTERACTIVE_SVG        = NO
+
+# The DOT_PATH tag can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_PATH               =
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the \dotfile
+# command).
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOTFILE_DIRS           =
+
+# The MSCFILE_DIRS tag can be used to specify one or more directories that
+# contain msc files that are included in the documentation (see the \mscfile
+# command).
+
+MSCFILE_DIRS           =
+
+# The DIAFILE_DIRS tag can be used to specify one or more directories that
+# contain dia files that are included in the documentation (see the \diafile
+# command).
+
+DIAFILE_DIRS           =
+
+# When using plantuml, the PLANTUML_JAR_PATH tag should be used to specify the
+# path where java can find the plantuml.jar file. If left blank, it is assumed
+# PlantUML is not used or called during a preprocessing step. Doxygen will
+# generate a warning when it encounters a \startuml command in this case and
+# will not generate output for the diagram.
+
+PLANTUML_JAR_PATH      =
+
+# When using plantuml, the PLANTUML_CFG_FILE tag can be used to specify a
+# configuration file for plantuml.
+
+PLANTUML_CFG_FILE      =
+
+# When using plantuml, the specified paths are searched for files specified by
+# the !include statement in a plantuml block.
+
+PLANTUML_INCLUDE_PATH  =
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
+# that will be shown in the graph. If the number of nodes in a graph becomes
+# larger than this value, doxygen will truncate the graph, which is visualized
+# by representing a node as a red box. Note that doxygen if the number of direct
+# children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
+# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+# Minimum value: 0, maximum value: 10000, default value: 50.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
+# generated by dot. A depth value of 3 means that only nodes reachable from the
+# root by following a path via at most 3 edges will be shown. Nodes that lay
+# further from the root node will be omitted. Note that setting this option to 1
+# or 2 may greatly reduce the computation time needed for large code bases. Also
+# note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+# Minimum value: 0, maximum value: 1000, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not seem
+# to support this out of the box.
+#
+# Warning: Depending on the platform used, enabling this option may lead to
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
+# read).
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_TRANSPARENT        = NO
+
+# Set the DOT_MULTI_TARGETS tag to YES to allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10) support
+# this, this feature is disabled by default.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
+# explaining the meaning of the various boxes and arrows in the dot generated
+# graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES, doxygen will remove the intermediate dot
+# files that are used to generate the various graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_CLEANUP            = YES
diff --git a/cpp/src/plasma/eviction_policy.cc b/cpp/src/plasma/eviction_policy.cc
new file mode 100644
index 000000000000..1529ccd8d5af
--- /dev/null
+++ b/cpp/src/plasma/eviction_policy.cc
@@ -0,0 +1,214 @@
+#include "eviction_policy.h"
+
+#include "utlist.h"
+
+/** An element representing a released object in a doubly-linked list. This is
+ *  used to implement an LRU cache. */
+typedef struct ReleasedObject {
+  /** The object_id of the released object. */
+  ObjectID object_id;
+  /** Needed for the doubly-linked list macros. */
+  struct ReleasedObject *prev;
+  /** Needed for the doubly-linked list macros. */
+  struct ReleasedObject *next;
+} ReleasedObject;
+
+/** This type is used to define a hash table mapping the object ID of a released
+ *  object to its location in the doubly-linked list of released objects. */
+typedef struct {
+  /** Object ID of this object. */
+  ObjectID object_id;
+  /** A pointer to the corresponding entry for this object in the doubly-linked
+   *  list of released objects. */
+  ReleasedObject *released_object;
+  /** Handle for the uthash table. */
+  UT_hash_handle handle;
+} released_object_entry;
+
+/** The part of the Plasma state that is maintained by the eviction policy. */
+struct EvictionState {
+  /** The amount of memory (in bytes) currently being used. */
+  int64_t memory_used;
+  /** A doubly-linked list of the released objects in order from least recently
+   *  released to most recently released. */
+  ReleasedObject *released_objects;
+  /** A hash table mapping the object ID of a released object to its location in
+   *  the doubly linked list of released objects. */
+  released_object_entry *released_object_table;
+};
+
+/* This is used to define the array of object IDs used to define the
+ * released_objects type. */
+UT_icd released_objects_entry_icd = {sizeof(ObjectID), NULL, NULL, NULL};
+
+EvictionState *EvictionState_init(void) {
+  EvictionState *state = (EvictionState *) malloc(sizeof(EvictionState));
+  state->memory_used = 0;
+  state->released_objects = NULL;
+  state->released_object_table = NULL;
+  return state;
+}
+
+void EvictionState_free(EvictionState *s) {
+  /* Delete each element in the doubly-linked list. */
+  ReleasedObject *element, *temp;
+  DL_FOREACH_SAFE(s->released_objects, element, temp) {
+    DL_DELETE(s->released_objects, element);
+    free(element);
+  }
+  /* Delete each element in the hash table. */
+  released_object_entry *current_entry, *temp_entry;
+  HASH_ITER(handle, s->released_object_table, current_entry, temp_entry) {
+    HASH_DELETE(handle, s->released_object_table, current_entry);
+    free(current_entry);
+  }
+  /* Free the eviction state. */
+  free(s);
+}
+
+void add_object_to_lru_cache(EvictionState *eviction_state,
+                             ObjectID object_id) {
+  /* Add the object ID to the doubly-linked list. */
+  ReleasedObject *linked_list_entry =
+      (ReleasedObject *) malloc(sizeof(ReleasedObject));
+  linked_list_entry->object_id = object_id;
+  DL_APPEND(eviction_state->released_objects, linked_list_entry);
+  /* Check that the object ID is not already in the hash table. */
+  released_object_entry *hash_table_entry;
+  HASH_FIND(handle, eviction_state->released_object_table, &object_id,
+            sizeof(object_id), hash_table_entry);
+  CHECK(hash_table_entry == NULL);
+  /* Add the object ID to the hash table. */
+  hash_table_entry =
+      (released_object_entry *) malloc(sizeof(released_object_entry));
+  hash_table_entry->object_id = object_id;
+  hash_table_entry->released_object = linked_list_entry;
+  HASH_ADD(handle, eviction_state->released_object_table, object_id,
+           sizeof(object_id), hash_table_entry);
+}
+
+void remove_object_from_lru_cache(EvictionState *eviction_state,
+                                  ObjectID object_id) {
+  /* Check that the object ID is in the hash table. */
+  released_object_entry *hash_table_entry;
+  HASH_FIND(handle, eviction_state->released_object_table, &object_id,
+            sizeof(object_id), hash_table_entry);
+  /* Only remove the object ID if it is in the LRU cache. */
+  CHECK(hash_table_entry != NULL);
+  /* Remove the object ID from the doubly-linked list. */
+  DL_DELETE(eviction_state->released_objects,
+            hash_table_entry->released_object);
+  /* Free the entry from the doubly-linked list. */
+  free(hash_table_entry->released_object);
+  /* Remove the object ID from the hash table. */
+  HASH_DELETE(handle, eviction_state->released_object_table, hash_table_entry);
+  /* Free the entry from the hash table. */
+  free(hash_table_entry);
+}
+
+int64_t EvictionState_choose_objects_to_evict(
+    EvictionState *eviction_state,
+    PlasmaStoreInfo *plasma_store_info,
+    int64_t num_bytes_required,
+    int64_t *num_objects_to_evict,
+    ObjectID **objects_to_evict) {
+  int64_t num_objects = 0;
+  int64_t num_bytes = 0;
+  /* Figure out how many objects need to be evicted in order to recover a
+   * sufficient number of bytes. */
+  ReleasedObject *element, *temp;
+  DL_FOREACH_SAFE(eviction_state->released_objects, element, temp) {
+    if (num_bytes >= num_bytes_required) {
+      break;
+    }
+    /* Find the object table entry for this object. */
+    object_table_entry *entry;
+    HASH_FIND(handle, plasma_store_info->objects, &element->object_id,
+              sizeof(element->object_id), entry);
+    /* Update the cumulative bytes and the number of objects so far. */
+    num_bytes += (entry->info.data_size + entry->info.metadata_size);
+    num_objects += 1;
+  }
+  /* Construct the return values. */
+  *num_objects_to_evict = num_objects;
+  if (num_objects == 0) {
+    *objects_to_evict = NULL;
+  } else {
+    *objects_to_evict = (ObjectID *) malloc(num_objects * sizeof(ObjectID));
+    int counter = 0;
+    DL_FOREACH_SAFE(eviction_state->released_objects, element, temp) {
+      if (counter == num_objects) {
+        break;
+      }
+      (*objects_to_evict)[counter] = element->object_id;
+      /* Update the LRU cache. */
+      remove_object_from_lru_cache(eviction_state, element->object_id);
+      counter += 1;
+    }
+  }
+  /* Update the number used. */
+  eviction_state->memory_used -= num_bytes;
+  return num_bytes;
+}
+
+void EvictionState_object_created(EvictionState *eviction_state,
+                                  PlasmaStoreInfo *plasma_store_info,
+                                  ObjectID obj_id) {
+  add_object_to_lru_cache(eviction_state, obj_id);
+}
+
+bool EvictionState_require_space(EvictionState *eviction_state,
+                                 PlasmaStoreInfo *plasma_store_info,
+                                 int64_t size,
+                                 int64_t *num_objects_to_evict,
+                                 ObjectID **objects_to_evict) {
+  /* Check if there is enough space to create the object. */
+  int64_t required_space =
+      eviction_state->memory_used + size - plasma_store_info->memory_capacity;
+  int64_t num_bytes_evicted;
+  if (required_space > 0) {
+    /* Try to free up at least as much space as we need right now but ideally
+     * up to 20% of the total capacity. */
+    int64_t space_to_free = std::max(size, plasma_store_info->memory_capacity / 5);
+    ARROW_LOG(INFO) << "not enough space to create this object, so evicting objects";
+    /* Choose some objects to evict, and update the return pointers. */
+    num_bytes_evicted = EvictionState_choose_objects_to_evict(
+        eviction_state, plasma_store_info, space_to_free, num_objects_to_evict,
+        objects_to_evict);
+    ARROW_LOG(INFO) <<
+        "There is not enough space to create this object, so evicting "
+        << *num_objects_to_evict << " objects to free up " << num_bytes_evicted << " bytes.";
+  } else {
+    num_bytes_evicted = 0;
+    *num_objects_to_evict = 0;
+    *objects_to_evict = NULL;
+  }
+  if (num_bytes_evicted >= required_space) {
+    /* We only increment the space used if there is enough space to create the
+     * object. */
+    eviction_state->memory_used += size;
+  }
+  return num_bytes_evicted >= required_space;
+}
+
+void EvictionState_begin_object_access(EvictionState *eviction_state,
+                                       PlasmaStoreInfo *plasma_store_info,
+                                       ObjectID obj_id,
+                                       int64_t *num_objects_to_evict,
+                                       ObjectID **objects_to_evict) {
+  /* If the object is in the LRU cache, remove it. */
+  remove_object_from_lru_cache(eviction_state, obj_id);
+  *num_objects_to_evict = 0;
+  *objects_to_evict = NULL;
+}
+
+void EvictionState_end_object_access(EvictionState *eviction_state,
+                                     PlasmaStoreInfo *plasma_store_info,
+                                     ObjectID obj_id,
+                                     int64_t *num_objects_to_evict,
+                                     ObjectID **objects_to_evict) {
+  /* Add the object to the LRU cache.*/
+  add_object_to_lru_cache(eviction_state, obj_id);
+  *num_objects_to_evict = 0;
+  *objects_to_evict = NULL;
+}
diff --git a/cpp/src/plasma/eviction_policy.h b/cpp/src/plasma/eviction_policy.h
new file mode 100644
index 000000000000..63cfcbc06cf3
--- /dev/null
+++ b/cpp/src/plasma/eviction_policy.h
@@ -0,0 +1,149 @@
+#ifndef EVICTION_POLICY_H
+#define EVICTION_POLICY_H
+
+#include "plasma.h"
+
+/* ==== The eviction policy ====
+ *
+ * This file contains declaration for all functions and data structures that
+ * need to be provided if you want to implement a new eviction algorithm for the
+ * Plasma store.
+ */
+
+/** Internal state of the eviction policy. */
+typedef struct EvictionState EvictionState;
+
+/**
+ * Initialize the eviction policy state.
+ *
+ * @param system_memory The amount of memory that can be used by the Plasma
+ *        store.
+ * @return The internal state of the eviction policy.
+ */
+EvictionState *EvictionState_init(void);
+
+/**
+ * Free the eviction policy state.
+ *
+ * @param state The state managed by the eviction policy.
+ * @return Void.
+ */
+void EvictionState_free(EvictionState *state);
+
+/**
+ * This method will be called whenever an object is first created in order to
+ * add it to the LRU cache. This is done so that the first time, the Plasma
+ * store calls begin_object_access, we can remove the object from the LRU cache.
+ *
+ * @param eviction_state The state managed by the eviction policy.
+ * @param plasma_store_info Information about the Plasma store that is exposed
+ *        to the eviction policy.
+ * @param obj_id The object ID of the object that was created.
+ * @return Void.
+ */
+void EvictionState_object_created(EvictionState *eviction_state,
+                                  PlasmaStoreInfo *plasma_store_info,
+                                  ObjectID obj_id);
+
+/**
+ * This method will be called when the Plasma store needs more space, perhaps to
+ * create a new object. If the required amount of space cannot be freed up, then
+ * a fatal error will be thrown. When this method is called, the eviction policy
+ * will assume that the objects chosen to be evicted will in fact be evicted
+ * from the Plasma store by the caller.
+ *
+ * @param eviction_state The state managed by the eviction policy.
+ * @param plasma_store_info Information about the Plasma store that is exposed
+ *        to the eviction policy.
+ * @param size The size in bytes of the new object, including both data and
+ *        metadata.
+ * @param num_objects_to_evict The number of objects that are chosen will be
+ *        stored at this address.
+ * @param objects_to_evict An array of the object IDs that were chosen will be
+ *        stored at this address. If the number of objects chosen is greater
+ *        than 0, then the caller needs to free that array. If it equals 0, then
+ *        the array will be NULL.
+ * @return True if enough space can be freed and false otherwise.
+ */
+bool EvictionState_require_space(EvictionState *eviction_state,
+                                 PlasmaStoreInfo *plasma_store_info,
+                                 int64_t size,
+                                 int64_t *num_objects_to_evict,
+                                 ObjectID **objects_to_evict);
+
+/**
+ * This method will be called whenever an unused object in the Plasma store
+ * starts to be used. When this method is called, the eviction policy will
+ * assume that the objects chosen to be evicted will in fact be evicted from the
+ * Plasma store by the caller.
+ *
+ * @param eviction_state The state managed by the eviction policy.
+ * @param plasma_store_info Information about the Plasma store that is exposed
+ *        to the eviction policy.
+ * @param obj_id The ID of the object that is now being used.
+ * @param num_objects_to_evict The number of objects that are chosen will be
+ *        stored at this address.
+ * @param objects_to_evict An array of the object IDs that were chosen will be
+ *        stored at this address. If the number of objects chosen is greater
+ *        than 0, then the caller needs to free that array. If it equals 0, then
+ *        the array will be NULL.
+ * @return Void.
+ */
+void EvictionState_begin_object_access(EvictionState *eviction_state,
+                                       PlasmaStoreInfo *plasma_store_info,
+                                       ObjectID obj_id,
+                                       int64_t *num_objects_to_evict,
+                                       ObjectID **objects_to_evict);
+
+/**
+ * This method will be called whenever an object in the Plasma store that was
+ * being used is no longer being used. When this method is called, the eviction
+ * policy will assume that the objects chosen to be evicted will in fact be
+ * evicted from the Plasma store by the caller.
+ *
+ * @param eviction_state The state managed by the eviction policy.
+ * @param plasma_store_info Information about the Plasma store that is exposed
+ *        to the eviction policy.
+ * @param obj_id The ID of the object that is no longer being used.
+ * @param num_objects_to_evict The number of objects that are chosen will be
+ *        stored at this address.
+ * @param objects_to_evict An array of the object IDs that were chosen will be
+ *        stored at this address. If the number of objects chosen is greater
+ *        than 0, then the caller needs to free that array. If it equals 0, then
+ *        the array will be NULL.
+ * @return Void.
+ */
+void EvictionState_end_object_access(EvictionState *eviction_state,
+                                     PlasmaStoreInfo *plasma_store_info,
+                                     ObjectID obj_id,
+                                     int64_t *num_objects_to_evict,
+                                     ObjectID **objects_to_evict);
+
+/**
+ * Choose some objects to evict from the Plasma store. When this method is
+ * called, the eviction policy will assume that the objects chosen to be evicted
+ * will in fact be evicted from the Plasma store by the caller.
+ *
+ * @note This method is not part of the API. It is exposed in the header file
+ * only for testing.
+ *
+ * @param eviction_state The state managed by the eviction policy.
+ * @param plasma_store_info Information about the Plasma store that is exposed
+ *        to the eviction policy.
+ * @param num_bytes_required The number of bytes of space to try to free up.
+ * @param num_objects_to_evict The number of objects that are chosen will be
+ *        stored at this address.
+ * @param objects_to_evict An array of the object IDs that were chosen will be
+ *        stored at this address. If the number of objects chosen is greater
+ *        than 0, then the caller needs to free that array. If it equals 0, then
+ *        the array will be NULL.
+ * @return The total number of bytes of space chosen to be evicted.
+ */
+int64_t EvictionState_choose_objects_to_evict(
+    EvictionState *eviction_state,
+    PlasmaStoreInfo *plasma_store_info,
+    int64_t num_bytes_required,
+    int64_t *num_objects_to_evict,
+    ObjectID **objects_to_evict);
+
+#endif /* EVICTION_POLICY_H */
diff --git a/cpp/src/plasma/fling.c b/cpp/src/plasma/fling.c
new file mode 100644
index 000000000000..379b896b543e
--- /dev/null
+++ b/cpp/src/plasma/fling.c
@@ -0,0 +1,76 @@
+#include "fling.h"
+
+#include <string.h>
+
+void init_msg(struct msghdr *msg,
+              struct iovec *iov,
+              char *buf,
+              size_t buf_len) {
+  iov->iov_base = buf;
+  iov->iov_len = 1;
+
+  msg->msg_iov = iov;
+  msg->msg_iovlen = 1;
+  msg->msg_control = buf;
+  msg->msg_controllen = buf_len;
+  msg->msg_name = NULL;
+  msg->msg_namelen = 0;
+}
+
+int send_fd(int conn, int fd) {
+  struct msghdr msg;
+  struct iovec iov;
+  char buf[CMSG_SPACE(sizeof(int))];
+  memset(&buf, 0, CMSG_SPACE(sizeof(int)));
+
+  init_msg(&msg, &iov, buf, sizeof(buf));
+
+  struct cmsghdr *header = CMSG_FIRSTHDR(&msg);
+  header->cmsg_level = SOL_SOCKET;
+  header->cmsg_type = SCM_RIGHTS;
+  header->cmsg_len = CMSG_LEN(sizeof(int));
+  *(int *) CMSG_DATA(header) = fd;
+
+  /* Send file descriptor. */
+  return sendmsg(conn, &msg, 0);
+}
+
+int recv_fd(int conn) {
+  struct msghdr msg;
+  struct iovec iov;
+  char buf[CMSG_SPACE(sizeof(int))];
+  init_msg(&msg, &iov, buf, sizeof(buf));
+
+  if (recvmsg(conn, &msg, 0) == -1)
+    return -1;
+
+  int found_fd = -1;
+  int oh_noes = 0;
+  for (struct cmsghdr *header = CMSG_FIRSTHDR(&msg); header != NULL;
+       header = CMSG_NXTHDR(&msg, header))
+    if (header->cmsg_level == SOL_SOCKET && header->cmsg_type == SCM_RIGHTS) {
+      int count =
+          (header->cmsg_len - (CMSG_DATA(header) - (unsigned char *) header)) /
+          sizeof(int);
+      for (int i = 0; i < count; ++i) {
+        int fd = ((int *) CMSG_DATA(header))[i];
+        if (found_fd == -1) {
+          found_fd = fd;
+        } else {
+          close(fd);
+          oh_noes = 1;
+        }
+      }
+    }
+
+  /* The sender sent us more than one file descriptor. We've closed
+   * them all to prevent fd leaks but notify the caller that we got
+   * a bad message. */
+  if (oh_noes) {
+    close(found_fd);
+    errno = EBADMSG;
+    return -1;
+  }
+
+  return found_fd;
+}
diff --git a/cpp/src/plasma/fling.h b/cpp/src/plasma/fling.h
new file mode 100644
index 000000000000..efc41d801e89
--- /dev/null
+++ b/cpp/src/plasma/fling.h
@@ -0,0 +1,43 @@
+/* FLING: Exchanging file descriptors over sockets
+ *
+ * This is a little library for sending file descriptors over a socket
+ * between processes. The reason for doing that (as opposed to using
+ * filenames to share the files) is so (a) no files remain in the
+ * filesystem after all the processes terminate, (b) to make sure that
+ * there are no name collisions and (c) to be able to control who has
+ * access to the data.
+ *
+ * Most of the code is from https://github.com/sharvil/flingfd */
+
+#include <unistd.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+
+/* This is neccessary for Mac OS X, see http://www.apuebook.com/faqs2e.html
+ * (10). */
+#if !defined(CMSG_SPACE) && !defined(CMSG_LEN)
+#define CMSG_SPACE(len) \
+  (__DARWIN_ALIGN32(sizeof(struct cmsghdr)) + __DARWIN_ALIGN32(len))
+#define CMSG_LEN(len) (__DARWIN_ALIGN32(sizeof(struct cmsghdr)) + (len))
+#endif
+
+void init_msg(struct msghdr *msg, struct iovec *iov, char *buf, size_t buf_len);
+
+/**
+ * Send a file descriptor over a unix domain socket.
+ *
+ * @param conn Unix domain socket to send the file descriptor over.
+ * @param fd File descriptor to send over.
+ * @return Status code which is < 0 on failure.
+ */
+int send_fd(int conn, int fd);
+
+/**
+ * Receive a file descriptor over a unix domain socket.
+ *
+ * @param conn Unix domain socket to receive the file descriptor from.
+ * @return File descriptor or a value < 0 on failure.
+ */
+int recv_fd(int conn);
diff --git a/cpp/src/plasma/format/plasma.fbs b/cpp/src/plasma/format/plasma.fbs
new file mode 100644
index 000000000000..36e0b4b27a24
--- /dev/null
+++ b/cpp/src/plasma/format/plasma.fbs
@@ -0,0 +1,292 @@
+// Plasma protocol specification
+
+enum MessageType:int {
+  // Create a new object.
+  PlasmaCreateRequest = 1,
+  PlasmaCreateReply,
+  // Seal an object.
+  PlasmaSealRequest,
+  PlasmaSealReply,
+  // Get an object that is stored on the local Plasma store.
+  PlasmaGetRequest,
+  PlasmaGetReply,
+  // Release an object.
+  PlasmaReleaseRequest,
+  PlasmaReleaseReply,
+  // Delete an object.
+  PlasmaDeleteRequest,
+  PlasmaDeleteReply,
+  // Get status of an object.
+  PlasmaStatusRequest,
+  PlasmaStatusReply,
+  // See if the store contains an object (will be deprecated).
+  PlasmaContainsRequest,
+  PlasmaContainsReply,
+  // Get information for a newly connecting client.
+  PlasmaConnectRequest,
+  PlasmaConnectReply,
+  // Make room for new objects in the plasma store.
+  PlasmaEvictRequest,
+  PlasmaEvictReply,
+  // Fetch objects from remote Plasma stores.
+  PlasmaFetchRequest,
+  // Wait for objects to be ready either from local or remote Plasma stores.
+  PlasmaWaitRequest,
+  PlasmaWaitReply,
+  // Subscribe to a list of objects or to all objects.
+  PlasmaSubscribeRequest,
+  // Unsubscribe.
+  PlasmaUnsubscribeRequest,
+  // Sending and receiving data.
+  // PlasmaDataRequest initiates sending the data, there will be one
+  // such message per data transfer.
+  PlasmaDataRequest,
+  // PlasmaDataReply contains the actual data and is sent back to the
+  // object store that requested the data. For each transfer, multiple
+  // reply messages get sent. Each one contains a fixed number of bytes.
+  PlasmaDataReply,
+  // Object notifications.
+  PlasmaNotification
+}
+
+enum PlasmaError:int {
+  // Operation was successful.
+  OK,
+  // Trying to create an object that already exists.
+  ObjectExists,
+  // Trying to access an object that doesn't exist.
+  ObjectNonexistent,
+  // Trying to create an object but there isn't enough space in the store.
+  OutOfMemory
+}
+
+// Plasma store messages
+
+struct PlasmaObjectSpec {
+  // Index of the memory segment (= memory mapped file) that
+  // this object is allocated in.
+  segment_index: int;
+  // Size in bytes of this segment (needed to call mmap).
+  mmap_size: ulong;
+  // The offset in bytes in the memory mapped file of the data.
+  data_offset: ulong;
+  // The size in bytes of the data.
+  data_size: ulong;
+  // The offset in bytes in the memory mapped file of the metadata.
+  metadata_offset: ulong;
+  // The size in bytes of the metadata.
+  metadata_size: ulong;
+}
+
+table PlasmaCreateRequest {
+  // ID of the object to be created.
+  object_id: string;
+  // The size of the object's data in bytes.
+  data_size: ulong;
+  // The size of the object's metadata in bytes.
+  metadata_size: ulong;
+}
+
+table PlasmaCreateReply {
+  // ID of the object that was created.
+  object_id: string;
+  // The object that is returned with this reply.
+  plasma_object: PlasmaObjectSpec;
+  // Error that occurred for this call.
+  error: PlasmaError;
+}
+
+table PlasmaSealRequest {
+  // ID of the object to be sealed.
+  object_id: string;
+  // Hash of the object data.
+  digest: string;
+}
+
+table PlasmaSealReply {
+  // ID of the object that was sealed.
+  object_id: string;
+  // Error code.
+  error: PlasmaError;
+}
+
+table PlasmaGetRequest {
+  // IDs of the objects stored at local Plasma store we are getting.
+  object_ids: [string];
+  // The number of milliseconds before the request should timeout.
+  timeout_ms: long;
+}
+
+table PlasmaGetReply {
+  // IDs of the objects being returned.
+  // This number can be smaller than the number of requested
+  // objects if not all requested objects are stored and sealed
+  // in the local Plasma store.
+  object_ids: [string];
+  // Plasma object information, in the same order as their IDs.
+  plasma_objects: [PlasmaObjectSpec];
+  // The number of elements in both object_ids and plasma_objects arrays must agree.
+}
+
+table PlasmaReleaseRequest {
+  // ID of the object to be released.
+  object_id: string;
+}
+
+table PlasmaReleaseReply {
+  // ID of the object that was released.
+  object_id: string;
+  // Error code.
+  error: PlasmaError;
+}
+
+table PlasmaDeleteRequest {
+  // ID of the object to be deleted.
+  object_id: string;
+}
+
+table PlasmaDeleteReply {
+  // ID of the object that was deleted.
+  object_id: string;
+  // Error code.
+  error: PlasmaError;
+}
+
+table PlasmaStatusRequest {
+  // IDs of the objects stored at local Plasma store we request the status of.
+  object_ids: [string];
+}
+
+enum ObjectStatus:int {
+  // Object is stored in the local Plasma Store.
+  Local = 1,
+  // Object is stored on a remote Plasma store, and it is not stored on the
+  // local Plasma Store.
+  Remote,
+  // Object is not stored in the system.
+  Nonexistent,
+  // Object is currently transferred from a remote Plasma store the the local
+  // Plasma Store.
+  Transfer
+}
+
+table PlasmaStatusReply {
+  // IDs of the objects being returned.
+  object_ids: [string];
+  // Status of the object.
+  status: [ObjectStatus];
+}
+
+// PlasmaContains is a subset of PlasmaStatus which does not
+// involve the plasma manager, only the store. We should consider
+// unifying them in the future and deprecating PlasmaContains.
+
+table PlasmaContainsRequest {
+  // ID of the object we are querying.
+  object_id: string;
+}
+
+table PlasmaContainsReply {
+  // ID of the object we are querying.
+  object_id: string;
+  // 1 if the object is in the store and 0 otherwise.
+  has_object: int;
+}
+
+// PlasmaConnect is used by a plasma client the first time it connects with the
+// store. This is not really necessary, but is used to get some information
+// about the store such as its memory capacity.
+
+table PlasmaConnectRequest {
+}
+
+table PlasmaConnectReply {
+  // The memory capacity of the store.
+  memory_capacity: long;
+}
+
+table PlasmaEvictRequest {
+  // Number of bytes that shall be freed.
+  num_bytes: ulong;
+}
+
+table PlasmaEvictReply {
+  // Number of bytes that have been freed.
+  num_bytes: ulong;
+}
+
+table PlasmaFetchRequest {
+  // IDs of objects to be gotten.
+  object_ids: [string];
+}
+
+table ObjectRequestSpec {
+  // ID of the object.
+  object_id: string;
+  // The type of the object. This specifies whether we
+  // will be waiting for an object store in the local or
+  // global Plasma store.
+  type: int;
+}
+
+table PlasmaWaitRequest {
+  // Array of object requests whose status we are asking for.
+  object_requests: [ObjectRequestSpec];
+  // Number of objects expected to be returned, if available.
+  num_ready_objects: int;
+  // timeout
+  timeout: long;
+}
+
+table ObjectReply {
+  // ID of the object.
+  object_id: string;
+  // The object status. This specifies where the object is stored.
+  status: int;
+}
+
+table PlasmaWaitReply {
+  // Array of object requests being returned.
+  object_requests: [ObjectReply];
+  // Number of objects expected to be returned, if available.
+  num_ready_objects: int;
+}
+
+table PlasmaSubscribeRequest {
+}
+
+table PlasmaDataRequest {
+  // ID of the object that is requested.
+  object_id: string;
+  // The host address where the data shall be sent to.
+  address: string;
+  // The port of the manager the data shall be sent to.
+  port: int;
+}
+
+table PlasmaDataReply {
+  // ID of the object that will be sent.
+  object_id: string;
+  // Size of the object data in bytes.
+  object_size: ulong;
+  // Size of the metadata in bytes.
+  metadata_size: ulong;
+}
+
+// Object information data structure.
+table ObjectInfo {
+  // Object ID of this object.
+  object_id: string;
+  // Number of bytes the content of this object occupies in memory.
+  data_size: long;
+  // Number of bytes the metadata of this object occupies in memory.
+  metadata_size: long;
+  // Unix epoch of when this object was created.
+  create_time: long;
+  // How long creation of this object took.
+  construct_duration: long;
+  // Hash of the object content.
+  digest: string;
+  // Specifies if this object was deleted or added.
+  is_deletion: bool;
+}
diff --git a/cpp/src/plasma/malloc.c b/cpp/src/plasma/malloc.c
new file mode 100644
index 000000000000..fe1ebb249244
--- /dev/null
+++ b/cpp/src/plasma/malloc.c
@@ -0,0 +1,170 @@
+#include <assert.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+// #include "common.h"
+#include "uthash.h"
+
+void *fake_mmap(size_t);
+int fake_munmap(void *, size_t);
+
+#define MMAP(s) fake_mmap(s)
+#define MUNMAP(a, s) fake_munmap(a, s)
+#define DIRECT_MMAP(s) fake_mmap(s)
+#define DIRECT_MUNMAP(a, s) fake_munmap(a, s)
+#define USE_DL_PREFIX
+#define HAVE_MORECORE 0
+#define DEFAULT_MMAP_THRESHOLD MAX_SIZE_T
+#define DEFAULT_GRANULARITY ((size_t) 128U * 1024U)
+
+#include "thirdparty/dlmalloc.c"
+
+#undef MMAP
+#undef MUNMAP
+#undef DIRECT_MMAP
+#undef DIRECT_MUNMAP
+#undef USE_DL_PREFIX
+#undef HAVE_MORECORE
+#undef DEFAULT_GRANULARITY
+
+struct mmap_record {
+  int fd;
+  void *pointer;
+  int64_t size;
+  UT_hash_handle hh_fd;
+  UT_hash_handle hh_pointer;
+};
+
+/* TODO(rshin): Don't have two hash tables. */
+struct mmap_record *records_by_fd = NULL;
+struct mmap_record *records_by_pointer = NULL;
+
+const int GRANULARITY_MULTIPLIER = 2;
+
+static void *pointer_advance(void *p, ptrdiff_t n) {
+  return (unsigned char *) p + n;
+}
+
+static void *pointer_retreat(void *p, ptrdiff_t n) {
+  return (unsigned char *) p - n;
+}
+
+static ptrdiff_t pointer_distance(void const *pfrom, void const *pto) {
+  return (unsigned char const *) pto - (unsigned char const *) pfrom;
+}
+
+/* Create a buffer. This is creating a temporary file and then
+ * immediately unlinking it so we do not leave traces in the system. */
+int create_buffer(int64_t size) {
+  int fd;
+#ifdef _WIN32
+  if (!CreateFileMapping(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE,
+                         (DWORD)((uint64_t) size >> (CHAR_BIT * sizeof(DWORD))),
+                         (DWORD)(uint64_t) size, NULL)) {
+    fd = -1;
+  }
+#else
+#ifdef __linux__
+  static char template[] = "/dev/shm/plasmaXXXXXX";
+#else
+  static char template[] = "/tmp/plasmaXXXXXX";
+#endif
+  char file_name[32];
+  strncpy(file_name, template, 32);
+  fd = mkstemp(file_name);
+  if (fd < 0)
+    return -1;
+  FILE *file = fdopen(fd, "a+");
+  if (!file) {
+    close(fd);
+    return -1;
+  }
+  if (unlink(file_name) != 0) {
+    printf("unlink error\n");
+    return -1;
+  }
+  if (ftruncate(fd, (off_t) size) != 0) {
+    printf("ftruncate error\n");
+    return -1;
+  }
+#endif
+  return fd;
+}
+
+void *fake_mmap(size_t size) {
+  /* Add sizeof(size_t) so that the returned pointer is deliberately not
+   * page-aligned. This ensures that the segments of memory returned by
+   * fake_mmap are never contiguous. */
+  size += sizeof(size_t);
+
+  int fd = create_buffer(size);
+  if (fd < 0) {
+    printf("Failed to create buffer during mmap\n");
+    exit(-1);
+  }
+  void *pointer = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+  if (pointer == MAP_FAILED) {
+    return pointer;
+  }
+
+  /* Increase dlmalloc's allocation granularity directly. */
+  mparams.granularity *= GRANULARITY_MULTIPLIER;
+
+  struct mmap_record *record = malloc(sizeof(struct mmap_record));
+  record->fd = fd;
+  record->pointer = pointer;
+  record->size = size;
+  HASH_ADD(hh_fd, records_by_fd, fd, sizeof(fd), record);
+  HASH_ADD(hh_pointer, records_by_pointer, pointer, sizeof(pointer), record);
+
+  /* We lie to dlmalloc about where mapped memory actually lives. */
+  pointer = pointer_advance(pointer, sizeof(size_t));
+  return pointer;
+}
+
+int fake_munmap(void *addr, size_t size) {
+  addr = pointer_retreat(addr, sizeof(size_t));
+  size += sizeof(size_t);
+
+  struct mmap_record *record;
+
+  HASH_FIND(hh_pointer, records_by_pointer, &addr, sizeof(addr), record);
+  if (record == NULL || record->size != size) {
+    /* Reject requests to munmap that don't directly match previous
+     * calls to mmap, to prevent dlmalloc from trimming. */
+    return -1;
+  }
+
+  HASH_DELETE(hh_fd, records_by_fd, record);
+  HASH_DELETE(hh_pointer, records_by_pointer, record);
+
+  int r = munmap(addr, size);
+  if (r == 0) {
+    close(record->fd);
+  }
+  return r;
+}
+
+void get_malloc_mapinfo(void *addr,
+                        int *fd,
+                        int64_t *map_size,
+                        ptrdiff_t *offset) {
+  struct mmap_record *record;
+  /* TODO(rshin): Implement a more efficient search through records_by_fd. */
+  for (record = records_by_fd; record != NULL; record = record->hh_fd.next) {
+    if (addr >= record->pointer &&
+        addr < pointer_advance(record->pointer, record->size)) {
+      *fd = record->fd;
+      *map_size = record->size;
+      *offset = pointer_distance(record->pointer, addr);
+      return;
+    }
+  }
+  *fd = -1;
+  *map_size = 0;
+  *offset = 0;
+}
diff --git a/cpp/src/plasma/malloc.h b/cpp/src/plasma/malloc.h
new file mode 100644
index 000000000000..9fc1f48bb9e6
--- /dev/null
+++ b/cpp/src/plasma/malloc.h
@@ -0,0 +1,9 @@
+#ifndef MALLOC_H
+#define MALLOC_H
+
+void get_malloc_mapinfo(void *addr,
+                        int *fd,
+                        int64_t *map_length,
+                        ptrdiff_t *offset);
+
+#endif /* MALLOC_H */
diff --git a/cpp/src/plasma/plasma.cc b/cpp/src/plasma/plasma.cc
new file mode 100644
index 000000000000..2582069c7a53
--- /dev/null
+++ b/cpp/src/plasma/plasma.cc
@@ -0,0 +1,40 @@
+#include "plasma.h"
+
+#include "io.h"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <unistd.h>
+
+#include "plasma_protocol.h"
+
+bool warn_if_sigpipe(int status, int client_sock) {
+  if (status >= 0) {
+    return false;
+  }
+  if (errno == EPIPE || errno == EBADF || errno == ECONNRESET) {
+    ARROW_LOG(WARNING) <<
+        "Received SIGPIPE or BAD FILE DESCRIPTOR when sending a message to "
+        "client on fd " << client_sock << ". The client on the other end may have hung up.";
+    return true;
+  }
+  ARROW_LOG(FATAL) << "Failed to write message to client on fd " << client_sock;
+}
+
+/**
+ * This will create a new ObjectInfo buffer. The first sizeof(int64_t) bytes
+ * of this buffer are the length of the remaining message and the
+ * remaining message is a serialized version of the object info.
+ *
+ * @param object_info The object info to be serialized
+ * @return The object info buffer. It is the caller's responsibility to free
+ *         this buffer with "free" after it has been used.
+ */
+uint8_t *create_object_info_buffer(ObjectInfoT *object_info) {
+  flatbuffers::FlatBufferBuilder fbb;
+  auto message = CreateObjectInfo(fbb, object_info);
+  fbb.Finish(message);
+  uint8_t *notification = (uint8_t *) malloc(sizeof(int64_t) + fbb.GetSize());
+  *((int64_t *) notification) = fbb.GetSize();
+  memcpy(notification + sizeof(int64_t), fbb.GetBufferPointer(), fbb.GetSize());
+  return notification;
+}
diff --git a/cpp/src/plasma/plasma.h b/cpp/src/plasma/plasma.h
new file mode 100644
index 000000000000..4fdf73d873cc
--- /dev/null
+++ b/cpp/src/plasma/plasma.h
@@ -0,0 +1,142 @@
+#ifndef PLASMA_H
+#define PLASMA_H
+
+#include <inttypes.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdbool.h>
+#include <stddef.h>
+#include <string.h>
+#include <unistd.h> /* pid_t */
+
+#include "common.h"
+#include "format/plasma_generated.h"
+
+#include "utarray.h"
+#include "uthash.h"
+
+/** Allocation granularity used in plasma for object allocation. */
+#define BLOCK_SIZE 64
+
+/**
+ * Object request data structure. Used in the plasma_wait_for_objects()
+ * argument.
+ */
+typedef struct {
+  /** The ID of the requested object. If ID_NIL request any object. */
+  ObjectID object_id;
+  /** Request associated to the object. It can take one of the following values:
+   *  - PLASMA_QUERY_LOCAL: return if or when the object is available in the
+   *    local Plasma Store.
+   *  - PLASMA_QUERY_ANYWHERE: return if or when the object is available in
+   *    the system (i.e., either in the local or a remote Plasma Store). */
+  int type;
+  /** Object status. Same as the status returned by plasma_status() function
+   *  call. This is filled in by plasma_wait_for_objects1():
+   *  - ObjectStatus_Local: object is ready at the local Plasma Store.
+   *  - ObjectStatus_Remote: object is ready at a remote Plasma Store.
+   *  - ObjectStatus_Nonexistent: object does not exist in the system.
+   *  - PLASMA_CLIENT_IN_TRANSFER, if the object is currently being scheduled
+   *    for being transferred or it is transferring. */
+  int status;
+} ObjectRequest;
+
+/* Handle to access memory mapped file and map it into client address space. */
+typedef struct {
+  /** The file descriptor of the memory mapped file in the store. It is used as
+   *  a unique identifier of the file in the client to look up the corresponding
+   *  file descriptor on the client's side. */
+  int store_fd;
+  /** The size in bytes of the memory mapped file. */
+  int64_t mmap_size;
+} object_handle;
+
+typedef struct {
+  /** Handle for memory mapped file the object is stored in. */
+  object_handle handle;
+  /** The offset in bytes in the memory mapped file of the data. */
+  ptrdiff_t data_offset;
+  /** The offset in bytes in the memory mapped file of the metadata. */
+  ptrdiff_t metadata_offset;
+  /** The size in bytes of the data. */
+  int64_t data_size;
+  /** The size in bytes of the metadata. */
+  int64_t metadata_size;
+} PlasmaObject;
+
+typedef enum {
+  /** Object was created but not sealed in the local Plasma Store. */
+  PLASMA_CREATED = 1,
+  /** Object is sealed and stored in the local Plasma Store. */
+  PLASMA_SEALED
+} object_state;
+
+typedef enum {
+  /** The object was not found. */
+  OBJECT_NOT_FOUND = 0,
+  /** The object was found. */
+  OBJECT_FOUND = 1
+} object_status;
+
+typedef enum {
+  /** Query for object in the local plasma store. */
+  PLASMA_QUERY_LOCAL = 1,
+  /** Query for object in the local plasma store or in a remote plasma store. */
+  PLASMA_QUERY_ANYWHERE
+} object_request_type;
+
+/** This type is used by the Plasma store. It is here because it is exposed to
+ *  the eviction policy. */
+typedef struct {
+  /** Object id of this object. */
+  ObjectID object_id;
+  /** Object info like size, creation time and owner. */
+  ObjectInfoT info;
+  /** Memory mapped file containing the object. */
+  int fd;
+  /** Size of the underlying map. */
+  int64_t map_size;
+  /** Offset from the base of the mmap. */
+  ptrdiff_t offset;
+  /** Handle for the uthash table. */
+  UT_hash_handle handle;
+  /** Pointer to the object data. Needed to free the object. */
+  uint8_t *pointer;
+  /** An array of the clients that are currently using this object. */
+  UT_array *clients;
+  /** The state of the object, e.g., whether it is open or sealed. */
+  object_state state;
+  /** The digest of the object. Used to see if two objects are the same. */
+  unsigned char digest[DIGEST_SIZE];
+} object_table_entry;
+
+/** The plasma store information that is exposed to the eviction policy. */
+typedef struct {
+  /** Objects that are in the Plasma store. */
+  object_table_entry *objects;
+  /** The amount of memory (in bytes) that we allow to be allocated in the
+   *  store. */
+  int64_t memory_capacity;
+} PlasmaStoreInfo;
+
+/**
+ * Print a warning if the status is less than zero. This should be used to check
+ * the success of messages sent to plasma clients. We print a warning instead of
+ * failing because the plasma clients are allowed to die. This is used to handle
+ * situations where the store writes to a client file descriptor, and the client
+ * may already have disconnected. If we have processed the disconnection and
+ * closed the file descriptor, we should get a BAD FILE DESCRIPTOR error. If we
+ * have not, then we should get a SIGPIPE.
+ *
+ * @param status The status to check. If it is less less than zero, we will
+ *        print a warning.
+ * @param client_sock The client socket. This is just used to print some extra
+ *        information.
+ * @return Void.
+ */
+bool warn_if_sigpipe(int status, int client_sock);
+
+uint8_t *create_object_info_buffer(ObjectInfoT *object_info);
+
+#endif /* PLASMA_H */
diff --git a/cpp/src/plasma/plasma_client.cc b/cpp/src/plasma/plasma_client.cc
new file mode 100644
index 000000000000..90a9568746e7
--- /dev/null
+++ b/cpp/src/plasma/plasma_client.cc
@@ -0,0 +1,774 @@
+/* PLASMA CLIENT: Client library for using the plasma store and manager */
+
+#ifdef _WIN32
+#include <Win32_Interop/win32_types.h>
+#endif
+
+#include <algorithm>
+
+#include <assert.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/socket.h>
+#include <sys/un.h>
+#include <strings.h>
+#include <netinet/in.h>
+#include <sys/time.h>
+#include <netdb.h>
+#include <poll.h>
+
+#include "common.h"
+#include "io.h"
+#include "plasma.h"
+#include "plasma_protocol.h"
+#include "plasma_client.h"
+#include "uthash.h"
+#include "utlist.h"
+
+/* C++ includes */
+#include <vector>
+#include <thread>
+
+extern "C" {
+#include "sha256.h"
+#include "fling.h"
+
+#define XXH_STATIC_LINKING_ONLY
+#include "xxhash.h"
+
+#define XXH64_DEFAULT_SEED 0
+}
+
+#define THREADPOOL_SIZE 8
+#define BYTES_IN_MB (1 << 20)
+static std::vector<std::thread> threadpool_(THREADPOOL_SIZE);
+
+typedef struct {
+  /** Key that uniquely identifies the  memory mapped file. In practice, we
+   *  take the numerical value of the file descriptor in the object store. */
+  int key;
+  /** The result of mmap for this file descriptor. */
+  uint8_t *pointer;
+  /** The length of the memory-mapped file. */
+  size_t length;
+  /** The number of objects in this memory-mapped file that are currently being
+   *  used by the client. When this count reaches zeros, we unmap the file. */
+  int count;
+  /** Handle for the uthash table. */
+  UT_hash_handle hh;
+} client_mmap_table_entry;
+
+typedef struct {
+  /** The ID of the object. This is used as the key in the hash table. */
+  ObjectID object_id;
+  /** A count of the number of times this client has called plasma_create or
+   *  plasma_get on this object ID minus the number of calls to plasma_release.
+   *  When this count reaches zero, we remove the entry from the objects_in_use
+   *  and decrement a count in the relevant client_mmap_table_entry. */
+  int count;
+  /** Cached information to read the object. */
+  PlasmaObject object;
+  /** A flag representing whether the object has been sealed. */
+  bool is_sealed;
+  /** Handle for the uthash table. */
+  UT_hash_handle hh;
+} object_in_use_entry;
+
+/** Configuration options for the plasma client. */
+typedef struct {
+  /** Number of release calls we wait until the object is actually released.
+   *  This allows us to avoid invalidating the cpu cache on workers if objects
+   *  are reused accross tasks. */
+  int release_delay;
+} plasma_client_config;
+
+/** An element representing a pending release call in a doubly-linked list. This
+ *  is used to implement the delayed release mechanism. */
+typedef struct pending_release {
+  /** The object_id of the released object. */
+  ObjectID object_id;
+  /** Needed for the doubly-linked list macros. */
+  struct pending_release *prev;
+  /** Needed for the doubly-linked list macros. */
+  struct pending_release *next;
+} pending_release;
+
+/** Information about a connection between a Plasma Client and Plasma Store.
+ *  This is used to avoid mapping the same files into memory multiple times. */
+struct PlasmaConnection {
+  /** File descriptor of the Unix domain socket that connects to the store. */
+  int store_conn;
+  /** File descriptor of the Unix domain socket that connects to the manager. */
+  int manager_conn;
+  /** File descriptor of the Unix domain socket on which client receives event
+   *  notifications for the objects it subscribes for when these objects are
+   *  sealed either locally or remotely. */
+  int manager_conn_subscribe;
+  /** Buffer that holds memory for serializing plasma protocol messages. */
+  protocol_builder *builder;
+  /** Table of dlmalloc buffer files that have been memory mapped so far. This
+   *  is a hash table mapping a file descriptor to a struct containing the
+   *  address of the corresponding memory-mapped file. */
+  client_mmap_table_entry *mmap_table;
+  /** A hash table of the object IDs that are currently being used by this
+   * client. */
+  object_in_use_entry *objects_in_use;
+  /** Object IDs of the last few release calls. This is a doubly-linked list and
+   *  is used to delay releasing objects to see if they can be reused by
+   *  subsequent tasks so we do not unneccessarily invalidate cpu caches.
+   *  TODO(pcm): replace this with a proper lru cache using the size of the L3
+   *  cache. */
+  pending_release *release_history;
+  /** The length of the release_history doubly-linked list. This is an
+   *  implementation detail. */
+  int release_history_length;
+  /** The number of bytes in the combined objects that are held in the release
+   *  history doubly-linked list. If this is too large then the client starts
+   *  releasing objects. */
+  int64_t in_use_object_bytes;
+  /** Configuration options for the plasma client. */
+  plasma_client_config config;
+  /** The amount of memory available to the Plasma store. The client needs this
+   *  information to make sure that it does not delay in releasing so much
+   *  memory that the store is unable to evict enough objects to free up space.
+   */
+  int64_t store_capacity;
+};
+
+/* If the file descriptor fd has been mmapped in this client process before,
+ * return the pointer that was returned by mmap, otherwise mmap it and store the
+ * pointer in a hash table. */
+uint8_t *lookup_or_mmap(PlasmaConnection *conn,
+                        int fd,
+                        int store_fd_val,
+                        int64_t map_size) {
+  client_mmap_table_entry *entry;
+  HASH_FIND_INT(conn->mmap_table, &store_fd_val, entry);
+  if (entry) {
+    close(fd);
+    return entry->pointer;
+  } else {
+    uint8_t *result = (uint8_t *) mmap(NULL, map_size, PROT_READ | PROT_WRITE,
+                                       MAP_SHARED, fd, 0);
+    if (result == MAP_FAILED) {
+      ARROW_LOG(FATAL) << "mmap failed";
+    }
+    close(fd);
+    entry = (client_mmap_table_entry *) malloc(sizeof(client_mmap_table_entry));
+    entry->key = store_fd_val;
+    entry->pointer = result;
+    entry->length = map_size;
+    entry->count = 0;
+    HASH_ADD_INT(conn->mmap_table, key, entry);
+    return result;
+  }
+}
+
+/* Get a pointer to a file that we know has been memory mapped in this client
+ * process before. */
+uint8_t *lookup_mmapped_file(PlasmaConnection *conn, int store_fd_val) {
+  client_mmap_table_entry *entry;
+  HASH_FIND_INT(conn->mmap_table, &store_fd_val, entry);
+  CHECK(entry);
+  return entry->pointer;
+}
+
+void increment_object_count(PlasmaConnection *conn,
+                            ObjectID object_id,
+                            PlasmaObject *object,
+                            bool is_sealed) {
+  /* Increment the count of the object to track the fact that it is being used.
+   * The corresponding decrement should happen in plasma_release. */
+  object_in_use_entry *object_entry;
+  HASH_FIND(hh, conn->objects_in_use, &object_id, sizeof(object_id),
+            object_entry);
+  if (object_entry == NULL) {
+    /* Add this object ID to the hash table of object IDs in use. The
+     * corresponding call to free happens in plasma_release. */
+    object_entry = (object_in_use_entry *) malloc(sizeof(object_in_use_entry));
+    object_entry->object_id = object_id;
+    object_entry->object = *object;
+    object_entry->count = 0;
+    object_entry->is_sealed = is_sealed;
+    HASH_ADD(hh, conn->objects_in_use, object_id, sizeof(object_id),
+             object_entry);
+    /* Increment the count of the number of objects in the memory-mapped file
+     * that are being used. The corresponding decrement should happen in
+     * plasma_release. */
+    client_mmap_table_entry *entry;
+    HASH_FIND_INT(conn->mmap_table, &object->handle.store_fd, entry);
+    CHECK(entry != NULL);
+    CHECK(entry->count >= 0);
+    /* Update the in_use_object_bytes. */
+    conn->in_use_object_bytes +=
+        (object_entry->object.data_size + object_entry->object.metadata_size);
+    entry->count += 1;
+  } else {
+    CHECK(object_entry->count > 0);
+  }
+  /* Increment the count of the number of instances of this object that are
+   * being used by this client. The corresponding decrement should happen in
+   * plasma_release. */
+  object_entry->count += 1;
+}
+
+int plasma_create(PlasmaConnection *conn,
+                  ObjectID obj_id,
+                  int64_t data_size,
+                  uint8_t *metadata,
+                  int64_t metadata_size,
+                  uint8_t **data) {
+  ARROW_LOG(INFO) << "called plasma_create on conn " << conn->store_conn
+                   << " with size " << data_size << " and metadata size " << metadata_size;
+  CHECK(plasma_send_CreateRequest(conn->store_conn, conn->builder, obj_id,
+                                  data_size, metadata_size) >= 0);
+  uint8_t *reply_data =
+      plasma_receive(conn->store_conn, MessageType_PlasmaCreateReply);
+  int error;
+  ObjectID id;
+  PlasmaObject object;
+  plasma_read_CreateReply(reply_data, &id, &object, &error);
+  free(reply_data);
+  if (error != PlasmaError_OK) {
+    ARROW_LOG(WARNING) << "returned from plasma_create with error " << error;
+    CHECK(error == PlasmaError_OutOfMemory ||
+          error == PlasmaError_ObjectExists);
+    return error;
+  }
+  /* If the CreateReply included an error, then the store will not send a file
+   * descriptor. */
+  int fd = recv_fd(conn->store_conn);
+  if (fd < 0) {
+    ARROW_LOG(FATAL) << "recv not successful";
+  }
+  CHECK(object.data_size == data_size);
+  CHECK(object.metadata_size == metadata_size);
+  /* The metadata should come right after the data. */
+  CHECK(object.metadata_offset == object.data_offset + data_size);
+  *data = lookup_or_mmap(conn, fd, object.handle.store_fd,
+                         object.handle.mmap_size) +
+          object.data_offset;
+  /* If plasma_create is being called from a transfer, then we will not copy the
+   * metadata here. The metadata will be written along with the data streamed
+   * from the transfer. */
+  if (metadata != NULL) {
+    /* Copy the metadata to the buffer. */
+    memcpy(*data + object.data_size, metadata, metadata_size);
+  }
+  /* Increment the count of the number of instances of this object that this
+   * client is using. A call to plasma_release is required to decrement this
+   * count. Cache the reference to the object. */
+  increment_object_count(conn, obj_id, &object, false);
+  /* We increment the count a second time (and the corresponding decrement will
+   * happen in a plasma_release call in plasma_seal) so even if the buffer
+   * returned by plasma_create goes out of scope, the object does not get
+   * released before the call to plasma_seal happens. */
+  increment_object_count(conn, obj_id, &object, false);
+  return PlasmaError_OK;
+}
+
+void plasma_get(PlasmaConnection *conn,
+                ObjectID object_ids[],
+                int64_t num_objects,
+                int64_t timeout_ms,
+                ObjectBuffer object_buffers[]) {
+  /* Fill out the info for the objects that are already in use locally. */
+  bool all_present = true;
+  for (int i = 0; i < num_objects; ++i) {
+    object_in_use_entry *object_entry;
+    HASH_FIND(hh, conn->objects_in_use, &object_ids[i], sizeof(object_ids[i]),
+              object_entry);
+    if (object_entry == NULL) {
+      /* This object is not currently in use by this client, so we need to send
+       * a request to the store. */
+      all_present = false;
+      /* Make a note to ourselves that the object is not present. */
+      object_buffers[i].data_size = -1;
+    } else {
+      PlasmaObject *object;
+      /* NOTE: If the object is still unsealed, we will deadlock, since we must
+       * have been the one who created it. */
+      if (!object_entry->is_sealed) {
+        ARROW_LOG(FATAL) << "Plasma client called get on an unsealed object that it created";
+      }
+      object = &object_entry->object;
+      object_buffers[i].data =
+          lookup_mmapped_file(conn, object->handle.store_fd);
+      object_buffers[i].data = object_buffers[i].data + object->data_offset;
+      object_buffers[i].data_size = object->data_size;
+      object_buffers[i].metadata = object_buffers[i].data + object->data_size;
+      object_buffers[i].metadata_size = object->metadata_size;
+      /* Increment the count of the number of instances of this object that this
+       * client is using. A call to plasma_release is required to decrement this
+       * count. Cache the reference to the object. */
+      increment_object_count(conn, object_ids[i], object, true);
+    }
+  }
+
+  if (all_present) {
+    return;
+  }
+
+  /* If we get here, then the objects aren't all currently in use by this
+   * client, so we need to send a request to the plasma store. */
+  CHECK(plasma_send_GetRequest(conn->store_conn, conn->builder, object_ids,
+                               num_objects, timeout_ms) >= 0);
+  uint8_t *reply_data =
+      plasma_receive(conn->store_conn, MessageType_PlasmaGetReply);
+  ObjectID *received_obj_ids =
+      (ObjectID *) malloc(num_objects * sizeof(ObjectID));
+  PlasmaObject *object_data =
+      (PlasmaObject *) malloc(num_objects * sizeof(PlasmaObject));
+  PlasmaObject *object;
+  plasma_read_GetReply(reply_data, received_obj_ids, object_data, num_objects);
+  free(reply_data);
+
+  for (int i = 0; i < num_objects; ++i) {
+    DCHECK(ObjectID_equal(received_obj_ids[i], object_ids[i]));
+    object = &object_data[i];
+    if (object_buffers[i].data_size != -1) {
+      /* If the object was already in use by the client, then the store should
+       * have returned it. */
+      DCHECK(object->data_size != -1);
+      /* We won't use this file descriptor, but the store sent us one, so we
+       * need to receive it and then close it right away so we don't leak file
+       * descriptors. */
+      int fd = recv_fd(conn->store_conn);
+      close(fd);
+      CHECK(fd >= 0);
+      /* We've already filled out the information for this object, so we can
+       * just continue. */
+      continue;
+    }
+    /* If we are here, the object was not currently in use, so we need to
+     * process the reply from the object store. */
+    if (object->data_size != -1) {
+      /* The object was retrieved. The user will be responsible for releasing
+       * this object. */
+      int fd = recv_fd(conn->store_conn);
+      CHECK(fd >= 0);
+      object_buffers[i].data = lookup_or_mmap(conn, fd, object->handle.store_fd,
+                                              object->handle.mmap_size);
+      /* Finish filling out the return values. */
+      object_buffers[i].data = object_buffers[i].data + object->data_offset;
+      object_buffers[i].data_size = object->data_size;
+      object_buffers[i].metadata = object_buffers[i].data + object->data_size;
+      object_buffers[i].metadata_size = object->metadata_size;
+      /* Increment the count of the number of instances of this object that this
+       * client is using. A call to plasma_release is required to decrement this
+       * count. Cache the reference to the object. */
+      increment_object_count(conn, received_obj_ids[i], object, true);
+    } else {
+      /* The object was not retrieved. Make sure we already put a -1 here to
+       * indicate that the object was not retrieved. The caller is not
+       * responsible for releasing this object. */
+      DCHECK(object_buffers[i].data_size == -1);
+      object_buffers[i].data_size = -1;
+    }
+  }
+  free(object_data);
+  free(received_obj_ids);
+}
+
+/**
+ * This is a helper method for implementing plasma_release. We maintain a buffer
+ * of release calls and only perform them once the buffer becomes full (as
+ * judged by the aggregate sizes of the objects). There may be multiple release
+ * calls for the same object ID in the buffer. In this case, the first release
+ * calls will not do anything. The client will only send a message to the store
+ * releasing the object when the client is truly done with the object.
+ *
+ * @param conn The plasma connection.
+ * @param object_id The object ID to attempt to release.
+ */
+void plasma_perform_release(PlasmaConnection *conn, ObjectID object_id) {
+  /* Decrement the count of the number of instances of this object that are
+   * being used by this client. The corresponding increment should have happened
+   * in plasma_get. */
+  object_in_use_entry *object_entry;
+  HASH_FIND(hh, conn->objects_in_use, &object_id, sizeof(object_id),
+            object_entry);
+  CHECK(object_entry != NULL);
+  object_entry->count -= 1;
+  CHECK(object_entry->count >= 0);
+  /* Check if the client is no longer using this object. */
+  if (object_entry->count == 0) {
+    /* Decrement the count of the number of objects in this memory-mapped file
+     * that the client is using. The corresponding increment should have
+     * happened in plasma_get. */
+    client_mmap_table_entry *entry;
+    int fd = object_entry->object.handle.store_fd;
+    HASH_FIND_INT(conn->mmap_table, &fd, entry);
+    CHECK(entry != NULL);
+    entry->count -= 1;
+    CHECK(entry->count >= 0);
+    /* If none are being used then unmap the file. */
+    if (entry->count == 0) {
+      munmap(entry->pointer, entry->length);
+      /* Remove the corresponding entry from the hash table. */
+      HASH_DELETE(hh, conn->mmap_table, entry);
+      free(entry);
+    }
+    /* Tell the store that the client no longer needs the object. */
+    CHECK(plasma_send_ReleaseRequest(conn->store_conn, conn->builder,
+                                     object_id) >= 0);
+    /* Update the in_use_object_bytes. */
+    conn->in_use_object_bytes -=
+        (object_entry->object.data_size + object_entry->object.metadata_size);
+    DCHECK(conn->in_use_object_bytes >= 0);
+    /* Remove the entry from the hash table of objects currently in use. */
+    HASH_DELETE(hh, conn->objects_in_use, object_entry);
+    free(object_entry);
+  }
+}
+
+void plasma_release(PlasmaConnection *conn, ObjectID obj_id) {
+  /* Add the new object to the release history. The corresponding call to free
+   * will occur in plasma_perform_release or in plasma_disconnect. */
+  pending_release *pending_release_entry =
+      (pending_release *) malloc(sizeof(pending_release));
+  pending_release_entry->object_id = obj_id;
+  DL_APPEND(conn->release_history, pending_release_entry);
+  conn->release_history_length += 1;
+  /* If there are too many bytes in use by the client or if there are too many
+   * pending release calls, and there are at least some pending release calls in
+   * the release_history list, then release some objects. */
+  while ((conn->in_use_object_bytes >
+              std::min(L3_CACHE_SIZE_BYTES, conn->store_capacity / 100) ||
+          conn->release_history_length > conn->config.release_delay) &&
+         conn->release_history_length > 0) {
+    DCHECK(conn->release_history != NULL);
+    /* Perform a release for the object ID for the first pending release. */
+    plasma_perform_release(conn, conn->release_history->object_id);
+    /* Remove the first entry from the doubly-linked list. Note that the pointer
+     * to the doubly linked list is just the pointer to the first entry. */
+    pending_release *release_history_first_entry = conn->release_history;
+    DL_DELETE(conn->release_history, release_history_first_entry);
+    free(release_history_first_entry);
+    conn->release_history_length -= 1;
+    DCHECK(conn->release_history_length >= 0);
+  }
+  if (conn->release_history_length == 0) {
+    DCHECK(conn->release_history == NULL);
+  }
+}
+
+/* This method is used to query whether the plasma store contains an object. */
+void plasma_contains(PlasmaConnection *conn, ObjectID obj_id, int *has_object) {
+  /* Check if we already have a reference to the object. */
+  object_in_use_entry *object_entry;
+  HASH_FIND(hh, conn->objects_in_use, &obj_id, sizeof(obj_id), object_entry);
+  if (object_entry) {
+    *has_object = 1;
+  } else {
+    /* If we don't already have a reference to the object, check with the store
+     * to see if we have the object. */
+    plasma_send_ContainsRequest(conn->store_conn, conn->builder, obj_id);
+    uint8_t *reply_data =
+        plasma_receive(conn->store_conn, MessageType_PlasmaContainsReply);
+    ObjectID object_id2;
+    plasma_read_ContainsReply(reply_data, &object_id2, has_object);
+    free(reply_data);
+  }
+}
+
+static void compute_block_hash(const unsigned char *data,
+                               int64_t nbytes,
+                               uint64_t *hash) {
+  XXH64_state_t hash_state;
+  XXH64_reset(&hash_state, XXH64_DEFAULT_SEED);
+  XXH64_update(&hash_state, data, nbytes);
+  *hash = XXH64_digest(&hash_state);
+}
+
+static inline bool compute_object_hash_parallel(XXH64_state_t *hash_state,
+                                                const unsigned char *data,
+                                                int64_t nbytes) {
+  /* Note that this function will likely be faster if the address of data is
+   * aligned on a 64-byte boundary. */
+  const uint64_t num_threads = THREADPOOL_SIZE;
+  uint64_t threadhash[num_threads + 1];
+  const uint64_t data_address = reinterpret_cast<uint64_t>(data);
+  const uint64_t num_blocks = nbytes / BLOCK_SIZE;
+  const uint64_t chunk_size = (num_blocks / num_threads) * BLOCK_SIZE;
+  const uint64_t right_address = data_address + chunk_size * num_threads;
+  const uint64_t suffix = (data_address + nbytes) - right_address;
+  /* Now the data layout is | k * num_threads * block_size | suffix | ==
+   * | num_threads * chunk_size | suffix |, where chunk_size = k * block_size.
+   * Each thread gets a "chunk" of k blocks, except the suffix thread. */
+
+  for (int i = 0; i < num_threads; i++) {
+    threadpool_[i] =
+        std::thread(compute_block_hash,
+                    reinterpret_cast<uint8_t *>(data_address) + i * chunk_size,
+                    chunk_size, &threadhash[i]);
+  }
+  compute_block_hash(reinterpret_cast<uint8_t *>(right_address), suffix,
+                     &threadhash[num_threads]);
+
+  /* Join the threads. */
+  for (auto &t : threadpool_) {
+    if (t.joinable()) {
+      t.join();
+    }
+  }
+
+  XXH64_update(hash_state, (unsigned char *) threadhash, sizeof(threadhash));
+  return true;
+}
+
+static uint64_t compute_object_hash(const ObjectBuffer &obj_buffer) {
+  XXH64_state_t hash_state;
+  XXH64_reset(&hash_state, XXH64_DEFAULT_SEED);
+  if (obj_buffer.data_size >= BYTES_IN_MB) {
+    compute_object_hash_parallel(&hash_state, (unsigned char *) obj_buffer.data,
+                                 obj_buffer.data_size);
+  } else {
+    XXH64_update(&hash_state, (unsigned char *) obj_buffer.data,
+                 obj_buffer.data_size);
+  }
+  XXH64_update(&hash_state, (unsigned char *) obj_buffer.metadata,
+               obj_buffer.metadata_size);
+  return XXH64_digest(&hash_state);
+}
+
+bool plasma_compute_object_hash(PlasmaConnection *conn,
+                                ObjectID obj_id,
+                                unsigned char *digest) {
+  /* Get the plasma object data. We pass in a timeout of 0 to indicate that
+   * the operation should timeout immediately. */
+  ObjectBuffer obj_buffer;
+  ObjectID obj_id_array[1] = {obj_id};
+  uint64_t hash;
+
+  plasma_get(conn, obj_id_array, 1, 0, &obj_buffer);
+  /* If the object was not retrieved, return false. */
+  if (obj_buffer.data_size == -1) {
+    return false;
+  }
+  /* Compute the hash. */
+  hash = compute_object_hash(obj_buffer);
+  memcpy(digest, &hash, sizeof(hash));
+  /* Release the plasma object. */
+  plasma_release(conn, obj_id);
+  return true;
+}
+
+void plasma_seal(PlasmaConnection *conn, ObjectID object_id) {
+  /* Make sure this client has a reference to the object before sending the
+   * request to Plasma. */
+  object_in_use_entry *object_entry;
+  HASH_FIND(hh, conn->objects_in_use, &object_id, sizeof(object_id),
+            object_entry);
+  if (object_entry == NULL) {
+    ARROW_LOG(FATAL) << "Plasma client called seal an object without a reference to it";
+  }
+  if (object_entry->is_sealed) {
+    ARROW_LOG(FATAL) << "Plasma client called seal an already sealed object";
+  }
+  object_entry->is_sealed = true;
+  /* Send the seal request to Plasma. */
+  static unsigned char digest[DIGEST_SIZE];
+  CHECK(plasma_compute_object_hash(conn, object_id, &digest[0]));
+  CHECK(plasma_send_SealRequest(conn->store_conn, conn->builder, object_id,
+                                &digest[0]) >= 0);
+  /* We call plasma_release to decrement the number of instances of this object
+   * that are currently being used by this client. The corresponding increment
+   * happened in plasma_create and was used to ensure that the object was not
+   * released before the call to plasma_seal. */
+  plasma_release(conn, object_id);
+}
+
+void plasma_delete(PlasmaConnection *conn, ObjectID object_id) {
+  /* TODO(rkn): In the future, we can use this method to give hints to the
+   * eviction policy about when an object will no longer be needed. */
+}
+
+int64_t plasma_evict(PlasmaConnection *conn, int64_t num_bytes) {
+  /* Send a request to the store to evict objects. */
+  CHECK(plasma_send_EvictRequest(conn->store_conn, conn->builder, num_bytes) >=
+        0);
+  /* Wait for a response with the number of bytes actually evicted. */
+  int64_t type;
+  int64_t length;
+  uint8_t *reply_data;
+  read_message(conn->store_conn, &type, &length, &reply_data);
+  int64_t num_bytes_evicted;
+  plasma_read_EvictReply(reply_data, &num_bytes_evicted);
+  free(reply_data);
+  return num_bytes_evicted;
+}
+
+int plasma_subscribe(PlasmaConnection *conn) {
+  int fd[2];
+  /* TODO: Just create 1 socket, bind it to port 0 to find a free port, and
+   * send the port number instead, and let the client connect. */
+  /* Create a non-blocking socket pair. This will only be used to send
+   * notifications from the Plasma store to the client. */
+  socketpair(AF_UNIX, SOCK_STREAM, 0, fd);
+  /* Make the socket non-blocking. */
+  int flags = fcntl(fd[1], F_GETFL, 0);
+  CHECK(fcntl(fd[1], F_SETFL, flags | O_NONBLOCK) == 0);
+  /* Tell the Plasma store about the subscription. */
+  CHECK(plasma_send_SubscribeRequest(conn->store_conn, conn->builder) >= 0);
+  /* Send the file descriptor that the Plasma store should use to push
+   * notifications about sealed objects to this client. */
+  CHECK(send_fd(conn->store_conn, fd[1]) >= 0);
+  close(fd[1]);
+  /* Return the file descriptor that the client should use to read notifications
+   * about sealed objects. */
+  return fd[0];
+}
+
+PlasmaConnection *plasma_connect(const char *store_socket_name,
+                                 const char *manager_socket_name,
+                                 int release_delay) {
+  /* Initialize the store connection struct */
+  PlasmaConnection *result =
+      (PlasmaConnection *) malloc(sizeof(PlasmaConnection));
+  result->store_conn = connect_ipc_sock_retry(store_socket_name, -1, -1);
+  if (manager_socket_name != NULL) {
+    result->manager_conn = connect_ipc_sock_retry(manager_socket_name, -1, -1);
+  } else {
+    result->manager_conn = -1;
+  }
+  result->builder = make_protocol_builder();
+  result->mmap_table = NULL;
+  result->objects_in_use = NULL;
+  result->config.release_delay = release_delay;
+  /* Initialize the release history doubly-linked list to NULL and also
+   * initialize other implementation details of the release history. */
+  result->release_history = NULL;
+  result->release_history_length = 0;
+  result->in_use_object_bytes = 0;
+  /* Send a ConnectRequest to the store to get its memory capacity. */
+  plasma_send_ConnectRequest(result->store_conn, result->builder);
+  uint8_t *reply_data =
+      plasma_receive(result->store_conn, MessageType_PlasmaConnectReply);
+  plasma_read_ConnectReply(reply_data, &result->store_capacity);
+  free(reply_data);
+  return result;
+}
+
+void plasma_disconnect(PlasmaConnection *conn) {
+  /* Perform the pending release calls to flush out the queue so that the counts
+   * in the objects_in_use table are accurate. */
+  pending_release *element, *temp;
+  DL_FOREACH_SAFE(conn->release_history, element, temp) {
+    plasma_perform_release(conn, element->object_id);
+    DL_DELETE(conn->release_history, element);
+    free(element);
+  }
+  /* Loop over the objects in use table and release all remaining objects. */
+  object_in_use_entry *current_entry, *temp_entry;
+  HASH_ITER(hh, conn->objects_in_use, current_entry, temp_entry) {
+    ObjectID object_id_to_release = current_entry->object_id;
+    int count = current_entry->count;
+    for (int i = 0; i < count; ++i) {
+      plasma_perform_release(conn, object_id_to_release);
+    }
+  }
+  /* Check that we've successfully released everything. */
+  if (conn->in_use_object_bytes != 0) {
+    ARROW_LOG(FATAL) << "conn->in_use_object_bytes = " << conn->in_use_object_bytes;
+  }
+  free_protocol_builder(conn->builder);
+  close(conn->store_conn);
+  if (conn->manager_conn >= 0) {
+    close(conn->manager_conn);
+  }
+  free(conn);
+}
+
+bool plasma_manager_is_connected(PlasmaConnection *conn) {
+  return conn->manager_conn >= 0;
+}
+
+#define h_addr h_addr_list[0]
+
+void plasma_transfer(PlasmaConnection *conn,
+                     const char *address,
+                     int port,
+                     ObjectID object_id) {
+  CHECK(plasma_send_DataRequest(conn->manager_conn, conn->builder, object_id,
+                                address, port) >= 0);
+}
+
+void plasma_fetch(PlasmaConnection *conn,
+                  int num_object_ids,
+                  ObjectID object_ids[]) {
+  CHECK(conn != NULL);
+  CHECK(conn->manager_conn >= 0);
+  CHECK(plasma_send_FetchRequest(conn->manager_conn, conn->builder, object_ids,
+                                 num_object_ids) >= 0);
+}
+
+int get_manager_fd(PlasmaConnection *conn) {
+  return conn->manager_conn;
+}
+
+int plasma_status(PlasmaConnection *conn, ObjectID object_id) {
+  CHECK(conn != NULL);
+  CHECK(conn->manager_conn >= 0);
+
+  plasma_send_StatusRequest(conn->manager_conn, conn->builder, &object_id, 1);
+  uint8_t *reply_data =
+      plasma_receive(conn->manager_conn, MessageType_PlasmaStatusReply);
+  int object_status;
+  plasma_read_StatusReply(reply_data, &object_id, &object_status, 1);
+  free(reply_data);
+  return object_status;
+}
+
+int plasma_wait(PlasmaConnection *conn,
+                int num_object_requests,
+                ObjectRequest object_requests[],
+                int num_ready_objects,
+                uint64_t timeout_ms) {
+  CHECK(conn != NULL);
+  CHECK(conn->manager_conn >= 0);
+  CHECK(num_object_requests > 0);
+  CHECK(num_ready_objects > 0);
+  CHECK(num_ready_objects <= num_object_requests);
+
+  for (int i = 0; i < num_object_requests; ++i) {
+    CHECK(object_requests[i].type == PLASMA_QUERY_LOCAL ||
+          object_requests[i].type == PLASMA_QUERY_ANYWHERE);
+  }
+
+  CHECK(plasma_send_WaitRequest(conn->manager_conn, conn->builder,
+                                object_requests, num_object_requests,
+                                num_ready_objects, timeout_ms) >= 0);
+  uint8_t *reply_data =
+      plasma_receive(conn->manager_conn, MessageType_PlasmaWaitReply);
+  plasma_read_WaitReply(reply_data, object_requests, &num_ready_objects);
+  free(reply_data);
+
+  int num_objects_ready = 0;
+  for (int i = 0; i < num_object_requests; ++i) {
+    int type = object_requests[i].type;
+    int status = object_requests[i].status;
+    switch (type) {
+    case PLASMA_QUERY_LOCAL:
+      if (status == ObjectStatus_Local) {
+        num_objects_ready += 1;
+      }
+      break;
+    case PLASMA_QUERY_ANYWHERE:
+      if (status == ObjectStatus_Local || status == ObjectStatus_Remote) {
+        num_objects_ready += 1;
+      } else {
+        CHECK(status == ObjectStatus_Nonexistent);
+      }
+      break;
+    default:
+      ARROW_LOG(FATAL) << "This code should be unreachable.";
+    }
+  }
+  return num_objects_ready;
+}
diff --git a/cpp/src/plasma/plasma_client.h b/cpp/src/plasma/plasma_client.h
new file mode 100644
index 000000000000..3551a68778e6
--- /dev/null
+++ b/cpp/src/plasma/plasma_client.h
@@ -0,0 +1,336 @@
+#ifndef PLASMA_CLIENT_H
+#define PLASMA_CLIENT_H
+
+#include <stdbool.h>
+#include <time.h>
+
+#include "plasma.h"
+
+/* Number of objects that are kept around without releasing them. */
+constexpr int PLASMA_DEFAULT_RELEASE_DELAY = 64;
+/* Use 100MB as an overestimate of the L3 cache size. */
+constexpr int64_t L3_CACHE_SIZE_BYTES = 100000000;
+
+typedef struct PlasmaConnection PlasmaConnection;
+
+/**
+ * Try to connect to the socket several times. If unsuccessful, fail.
+ *
+ * @param socket_name Name of the Unix domain socket to connect to.
+ * @param num_retries Number of retries.
+ * @param timeout Timeout in milliseconds.
+ * @return File descriptor of the socket.
+ */
+int socket_connect_retry(const char *socket_name,
+                         int num_retries,
+                         int64_t timeout);
+
+/**
+ * Connect to the local plasma store and plasma manager. Return
+ * the resulting connection.
+ *
+ * @param store_socket_name The name of the UNIX domain socket to use to
+ *        connect to the Plasma store.
+ * @param manager_socket_name The name of the UNIX domain socket to use to
+ *        connect to the local Plasma manager. If this is NULL, then this
+ *        function will not connect to a manager.
+ * @return The object containing the connection state.
+ */
+PlasmaConnection *plasma_connect(const char *store_socket_name,
+                                 const char *manager_socket_name,
+                                 int release_delay);
+
+/**
+ * Disconnect from the local plasma instance, including the local store and
+ * manager.
+ *
+ * @param conn The connection to the local plasma store and plasma manager.
+ * @return Void.
+ */
+void plasma_disconnect(PlasmaConnection *conn);
+
+/**
+ * Return true if the plasma manager is connected.
+ *
+ * @param conn The connection to the local plasma store and plasma manager.
+ * @return True if the plasma manager is connected and false otherwise.
+ */
+bool plasma_manager_is_connected(PlasmaConnection *conn);
+
+/**
+ * Try to connect to a possibly remote Plasma Manager.
+ *
+ * @param addr The IP address of the Plasma Manager to connect to.
+ * @param port The port of the Plasma Manager to connect to.
+ * @return The file descriptor to use to send messages to the
+ *         Plasma Manager. If connection was unsuccessful, this
+ *         value is -1.
+ */
+int plasma_manager_connect(const char *addr, int port);
+
+/**
+ * Create an object in the Plasma Store. Any metadata for this object must be
+ * be passed in when the object is created.
+ *
+ * @param conn The object containing the connection state.
+ * @param object_id The ID to use for the newly created object.
+ * @param size The size in bytes of the space to be allocated for this object's
+          data (this does not include space used for metadata).
+ * @param metadata The object's metadata. If there is no metadata, this pointer
+          should be NULL.
+ * @param metadata_size The size in bytes of the metadata. If there is no
+          metadata, this should be 0.
+ * @param data The address of the newly created object will be written here.
+ * @return One of the following error codes:
+ *         - PlasmaError_OK, if the object was created successfully.
+ *         - PlasmaError_ObjectExists, if an object with this ID is already
+ *           present in the store. In this case, the client should not call
+ *           plasma_release.
+ *         - PlasmaError_OutOfMemory, if the store is out of memory and cannot
+ *           create the object. In this case, the client should not call
+ *           plasma_release.
+ */
+int plasma_create(PlasmaConnection *conn,
+                  ObjectID object_id,
+                  int64_t size,
+                  uint8_t *metadata,
+                  int64_t metadata_size,
+                  uint8_t **data);
+
+/**
+ * Object buffer data structure.
+ */
+typedef struct {
+  /** The size in bytes of the data object. */
+  int64_t data_size;
+  /** The address of the data object. */
+  uint8_t *data;
+  /** The metadata size in bytes. */
+  int64_t metadata_size;
+  /** The address of the metadata. */
+  uint8_t *metadata;
+} ObjectBuffer;
+
+/**
+ * Get some objects from the Plasma Store. This function will block until the
+ * objects have all been created and sealed in the Plasma Store or the timeout
+ * expires. The caller is responsible for releasing any retrieved objects, but
+ * the caller should not release objects that were not retrieved.
+ *
+ * @param conn The object containing the connection state.
+ * @param object_ids The IDs of the objects to get.
+ * @param num_object_ids The number of object IDs to get.
+ * @param timeout_ms The amount of time in milliseconds to wait before this
+ *        request times out. If this value is -1, then no timeout is set.
+ * @param object_buffers An array where the results will be stored. If the data
+ *        size field is -1, then the object was not retrieved.
+ * @return Void.
+ */
+void plasma_get(PlasmaConnection *conn,
+                ObjectID object_ids[],
+                int64_t num_objects,
+                int64_t timeout_ms,
+                ObjectBuffer object_buffers[]);
+
+/**
+ * Tell Plasma that the client no longer needs the object. This should be called
+ * after plasma_get when the client is done with the object. After this call,
+ * the address returned by plasma_get is no longer valid. This should be called
+ * once for each call to plasma_get (with the same object ID).
+ *
+ * @param conn The object containing the connection state.
+ * @param object_id The ID of the object that is no longer needed.
+ * @return Void.
+ */
+void plasma_release(PlasmaConnection *conn, ObjectID object_id);
+
+/**
+ * Check if the object store contains a particular object and the object has
+ * been sealed. The result will be stored in has_object.
+ *
+ * @todo: We may want to indicate if the object has been created but not sealed.
+ *
+ * @param conn The object containing the connection state.
+ * @param object_id The ID of the object whose presence we are checking.
+ * @param has_object The function will write 1 at this address if the object is
+ *        present and 0 if it is not present.
+ * @return Void.
+ */
+void plasma_contains(PlasmaConnection *conn,
+                     ObjectID object_id,
+                     int *has_object);
+
+/**
+ * Compute the hash of an object in the object store.
+ *
+ * @param conn The object containing the connection state.
+ * @param object_id The ID of the object we want to hash.
+ * @param digest A pointer at which to return the hash digest of the object.
+ *        The pointer must have at least DIGEST_SIZE bytes allocated.
+ * @return A boolean representing whether the hash operation succeeded.
+ */
+bool plasma_compute_object_hash(PlasmaConnection *conn,
+                                ObjectID object_id,
+                                unsigned char *digest);
+
+/**
+ * Seal an object in the object store. The object will be immutable after this
+ * call.
+ *
+ * @param conn The object containing the connection state.
+ * @param object_id The ID of the object to seal.
+ * @return Void.
+ */
+void plasma_seal(PlasmaConnection *conn, ObjectID object_id);
+
+/**
+ * Delete an object from the object store. This currently assumes that the
+ * object is present and has been sealed.
+ *
+ * @todo We may want to allow the deletion of objects that are not present or
+ *       haven't been sealed.
+ *
+ * @param conn The object containing the connection state.
+ * @param object_id The ID of the object to delete.
+ * @return Void.
+ */
+void plasma_delete(PlasmaConnection *conn, ObjectID object_id);
+
+/**
+ * Delete objects until we have freed up num_bytes bytes or there are no more
+ * released objects that can be deleted.
+ *
+ * @param conn The object containing the connection state.
+ * @param num_bytes The number of bytes to try to free up.
+ * @return The total number of bytes of space retrieved.
+ */
+int64_t plasma_evict(PlasmaConnection *conn, int64_t num_bytes);
+
+/**
+ * Attempt to initiate the transfer of some objects from remote Plasma Stores.
+ * This method does not guarantee that the fetched objects will arrive locally.
+ *
+ * For an object that is available in the local Plasma Store, this method will
+ * not do anything. For an object that is not available locally, it will check
+ * if the object are already being fetched. If so, it will not do anything. If
+ * not, it will query the object table for a list of Plasma Managers that have
+ * the object. The object table will return a non-empty list, and this Plasma
+ * Manager will attempt to initiate transfers from one of those Plasma Managers.
+ *
+ * This function is non-blocking.
+ *
+ * This method is idempotent in the sense that it is ok to call it multiple
+ * times.
+ *
+ * @param conn The object containing the connection state.
+ * @param num_object_ids The number of object IDs fetch is being called on.
+ * @param object_ids The IDs of the objects that fetch is being called on.
+ * @return Void.
+ */
+void plasma_fetch(PlasmaConnection *conn,
+                  int num_object_ids,
+                  ObjectID object_ids[]);
+
+/**
+ * Transfer local object to a different plasma manager.
+ *
+ * @param conn The object containing the connection state.
+ * @param addr IP address of the plasma manager we are transfering to.
+ * @param port Port of the plasma manager we are transfering to.
+ * @object_id ObjectID of the object we are transfering.
+ *
+ * @return Void.
+ */
+void plasma_transfer(PlasmaConnection *conn,
+                     const char *addr,
+                     int port,
+                     ObjectID object_id);
+
+/**
+ * Subscribe to notifications when objects are sealed in the object store.
+ * Whenever an object is sealed, a message will be written to the client socket
+ * that is returned by this method.
+ *
+ * @param conn The object containing the connection state.
+ * @return The file descriptor that the client should use to read notifications
+           from the object store about sealed objects.
+ */
+int plasma_subscribe(PlasmaConnection *conn);
+
+/**
+ * Get the file descriptor for the socket connection to the plasma manager.
+ *
+ * @param conn The plasma connection.
+ * @return The file descriptor for the manager connection. If there is no
+ *         connection to the manager, this is -1.
+ */
+int get_manager_fd(PlasmaConnection *conn);
+
+/**
+ * Return the status of a given object. This method may query the object table.
+ *
+ * @param conn The object containing the connection state.
+ * @param object_id The ID of the object whose status we query.
+ * @return Status as returned by get_status() function. Status can take the
+ *         following values.
+ *         - PLASMA_CLIENT_LOCAL, if object is stored in the local Plasma Store.
+ *           has been already scheduled by the Plasma Manager.
+ *         - PLASMA_CLIENT_TRANSFER, if the object is either currently being
+ *           transferred or just scheduled.
+ *         - PLASMA_CLIENT_REMOTE, if the object is stored at a remote
+ *           Plasma Store.
+ *         - PLASMA_CLIENT_DOES_NOT_EXIST, if the object doesnt exist in the
+ *           system.
+ */
+int plasma_status(PlasmaConnection *conn, ObjectID object_id);
+
+/**
+ * Return the information associated to a given object.
+ *
+ * @param conn The object containing the connection state.
+ * @param object_id The ID of the object whose info the client queries.
+ * @param object_info The object's infirmation.
+ * @return PLASMA_CLIENT_LOCAL, if the object is in the local Plasma Store.
+ *         PLASMA_CLIENT_NOT_LOCAL, if not. In this case, the caller needs to
+ *         ignore data, metadata_size, and metadata fields.
+ */
+int plasma_info(PlasmaConnection *conn,
+                ObjectID object_id,
+                ObjectInfo *object_info);
+
+/**
+ * Wait for (1) a specified number of objects to be available (sealed) in the
+ * local Plasma Store or in a remote Plasma Store, or (2) for a timeout to
+ * expire. This is a blocking call.
+ *
+ * @param conn The object containing the connection state.
+ * @param num_object_requests Size of the object_requests array.
+ * @param object_requests Object event array. Each element contains a request
+ *        for a particular object_id. The type of request is specified in the
+ *        "type" field.
+ *        - A PLASMA_QUERY_LOCAL request is satisfied when object_id becomes
+ *          available in the local Plasma Store. In this case, this function
+ *          sets the "status" field to ObjectStatus_Local. Note, if the status
+ *          is not ObjectStatus_Local, it will be ObjectStatus_Nonexistent,
+ *          but it may exist elsewhere in the system.
+ *        - A PLASMA_QUERY_ANYWHERE request is satisfied when object_id becomes
+ *          available either at the local Plasma Store or on a remote Plasma
+ *          Store. In this case, the functions sets the "status" field to
+ *          ObjectStatus_Local or ObjectStatus_Remote.
+ * @param num_ready_objects The number of requests in object_requests array that
+ *        must be satisfied before the function returns, unless it timeouts.
+ *        The num_ready_objects should be no larger than num_object_requests.
+ * @param timeout_ms Timeout value in milliseconds. If this timeout expires
+ *        before min_num_ready_objects of requests are satisfied, the function
+ *        returns.
+ * @return Number of satisfied requests in the object_requests list. If the
+ *         returned number is less than min_num_ready_objects this means that
+ *         timeout expired.
+ */
+int plasma_wait(PlasmaConnection *conn,
+                int num_object_requests,
+                ObjectRequest object_requests[],
+                int num_ready_objects,
+                uint64_t timeout_ms);
+
+#endif /* PLASMA_CLIENT_H */
diff --git a/cpp/src/plasma/plasma_extension.cc b/cpp/src/plasma/plasma_extension.cc
new file mode 100644
index 000000000000..60fa13c6bf9c
--- /dev/null
+++ b/cpp/src/plasma/plasma_extension.cc
@@ -0,0 +1,463 @@
+#include <Python.h>
+#include "bytesobject.h"
+
+#include "common.h"
+#include "io.h"
+#include "plasma_protocol.h"
+#include "plasma_client.h"
+
+PyObject *PlasmaOutOfMemoryError;
+PyObject *PlasmaObjectExistsError;
+
+#include "plasma_extension.h"
+
+PyObject *PyPlasma_connect(PyObject *self, PyObject *args) {
+  const char *store_socket_name;
+  const char *manager_socket_name;
+  int release_delay;
+  if (!PyArg_ParseTuple(args, "ssi", &store_socket_name, &manager_socket_name,
+                        &release_delay)) {
+    return NULL;
+  }
+  PlasmaConnection *conn;
+  if (strlen(manager_socket_name) == 0) {
+    conn = plasma_connect(store_socket_name, NULL, release_delay);
+  } else {
+    conn =
+        plasma_connect(store_socket_name, manager_socket_name, release_delay);
+  }
+  return PyCapsule_New(conn, "plasma", NULL);
+}
+
+PyObject *PyPlasma_disconnect(PyObject *self, PyObject *args) {
+  PyObject *conn_capsule;
+  PlasmaConnection *conn;
+  if (!PyArg_ParseTuple(args, "O", &conn_capsule)) {
+    return NULL;
+  }
+  CHECK(PyObjectToPlasmaConnection(conn_capsule, &conn));
+  plasma_disconnect(conn);
+  /* We use the context of the connection capsule to indicate if the connection
+   * is still active (if the context is NULL) or if it is closed (if the context
+   * is (void*) 0x1). This is neccessary because the primary pointer of the
+   * capsule cannot be NULL. */
+  PyCapsule_SetContext(conn_capsule, (void *) 0x1);
+  Py_RETURN_NONE;
+}
+
+PyObject *PyPlasma_create(PyObject *self, PyObject *args) {
+  PlasmaConnection *conn;
+  ObjectID object_id;
+  long long size;
+  PyObject *metadata;
+  if (!PyArg_ParseTuple(args, "O&O&LO", PyObjectToPlasmaConnection, &conn,
+                        PyStringToUniqueID, &object_id, &size, &metadata)) {
+    return NULL;
+  }
+  if (!PyByteArray_Check(metadata)) {
+    PyErr_SetString(PyExc_TypeError, "metadata must be a bytearray");
+    return NULL;
+  }
+  uint8_t *data;
+  int error_code = plasma_create(conn, object_id, size,
+                                 (uint8_t *) PyByteArray_AsString(metadata),
+                                 PyByteArray_Size(metadata), &data);
+  if (error_code == PlasmaError_ObjectExists) {
+    PyErr_SetString(PlasmaObjectExistsError,
+                    "An object with this ID already exists in the plasma "
+                    "store.");
+    return NULL;
+  }
+  if (error_code == PlasmaError_OutOfMemory) {
+    PyErr_SetString(PlasmaOutOfMemoryError,
+                    "The plasma store ran out of memory and could not create "
+                    "this object.");
+    return NULL;
+  }
+  CHECK(error_code == PlasmaError_OK);
+
+#if PY_MAJOR_VERSION >= 3
+  return PyMemoryView_FromMemory((char *) data, (Py_ssize_t) size, PyBUF_WRITE);
+#else
+  return PyBuffer_FromReadWriteMemory((void *) data, (Py_ssize_t) size);
+#endif
+}
+
+PyObject *PyPlasma_hash(PyObject *self, PyObject *args) {
+  PlasmaConnection *conn;
+  ObjectID object_id;
+  if (!PyArg_ParseTuple(args, "O&O&", PyObjectToPlasmaConnection, &conn,
+                        PyStringToUniqueID, &object_id)) {
+    return NULL;
+  }
+  unsigned char digest[DIGEST_SIZE];
+  bool success = plasma_compute_object_hash(conn, object_id, digest);
+  if (success) {
+    PyObject *digest_string =
+        PyBytes_FromStringAndSize((char *) digest, DIGEST_SIZE);
+    return digest_string;
+  } else {
+    Py_RETURN_NONE;
+  }
+}
+
+PyObject *PyPlasma_seal(PyObject *self, PyObject *args) {
+  PlasmaConnection *conn;
+  ObjectID object_id;
+  if (!PyArg_ParseTuple(args, "O&O&", PyObjectToPlasmaConnection, &conn,
+                        PyStringToUniqueID, &object_id)) {
+    return NULL;
+  }
+  plasma_seal(conn, object_id);
+  Py_RETURN_NONE;
+}
+
+PyObject *PyPlasma_release(PyObject *self, PyObject *args) {
+  PlasmaConnection *conn;
+  ObjectID object_id;
+  if (!PyArg_ParseTuple(args, "O&O&", PyObjectToPlasmaConnection, &conn,
+                        PyStringToUniqueID, &object_id)) {
+    return NULL;
+  }
+  plasma_release(conn, object_id);
+  Py_RETURN_NONE;
+}
+
+PyObject *PyPlasma_get(PyObject *self, PyObject *args) {
+  PlasmaConnection *conn;
+  PyObject *object_id_list;
+  long long timeout_ms;
+  if (!PyArg_ParseTuple(args, "O&OL", PyObjectToPlasmaConnection, &conn,
+                        &object_id_list, &timeout_ms)) {
+    return NULL;
+  }
+
+  Py_ssize_t num_object_ids = PyList_Size(object_id_list);
+  ObjectID *object_ids = (ObjectID *) malloc(sizeof(ObjectID) * num_object_ids);
+  ObjectBuffer *object_buffers =
+      (ObjectBuffer *) malloc(sizeof(ObjectBuffer) * num_object_ids);
+
+  for (int i = 0; i < num_object_ids; ++i) {
+    PyStringToUniqueID(PyList_GetItem(object_id_list, i), &object_ids[i]);
+  }
+
+  Py_BEGIN_ALLOW_THREADS;
+  plasma_get(conn, object_ids, num_object_ids, timeout_ms, object_buffers);
+  Py_END_ALLOW_THREADS;
+  free(object_ids);
+
+  PyObject *returns = PyList_New(num_object_ids);
+  for (int i = 0; i < num_object_ids; ++i) {
+    if (object_buffers[i].data_size != -1) {
+      /* The object was retrieved, so return the object. */
+      PyObject *t = PyTuple_New(2);
+#if PY_MAJOR_VERSION >= 3
+      PyTuple_SetItem(
+          t, 0, PyMemoryView_FromMemory(
+                    (char *) object_buffers[i].data,
+                    (Py_ssize_t) object_buffers[i].data_size, PyBUF_READ));
+      PyTuple_SetItem(
+          t, 1, PyMemoryView_FromMemory(
+                    (char *) object_buffers[i].metadata,
+                    (Py_ssize_t) object_buffers[i].metadata_size, PyBUF_READ));
+#else
+      PyTuple_SetItem(
+          t, 0, PyBuffer_FromMemory((void *) object_buffers[i].data,
+                                    (Py_ssize_t) object_buffers[i].data_size));
+      PyTuple_SetItem(t, 1, PyBuffer_FromMemory(
+                                (void *) object_buffers[i].metadata,
+                                (Py_ssize_t) object_buffers[i].metadata_size));
+#endif
+      PyList_SetItem(returns, i, t);
+    } else {
+      /* The object was not retrieved, so just add None to the list of return
+       * values. */
+      Py_XINCREF(Py_None);
+      PyList_SetItem(returns, i, Py_None);
+    }
+  }
+  free(object_buffers);
+  return returns;
+}
+
+PyObject *PyPlasma_contains(PyObject *self, PyObject *args) {
+  PlasmaConnection *conn;
+  ObjectID object_id;
+  if (!PyArg_ParseTuple(args, "O&O&", PyObjectToPlasmaConnection, &conn,
+                        PyStringToUniqueID, &object_id)) {
+    return NULL;
+  }
+  int has_object;
+  plasma_contains(conn, object_id, &has_object);
+
+  if (has_object)
+    Py_RETURN_TRUE;
+  else
+    Py_RETURN_FALSE;
+}
+
+PyObject *PyPlasma_fetch(PyObject *self, PyObject *args) {
+  PlasmaConnection *conn;
+  PyObject *object_id_list;
+  if (!PyArg_ParseTuple(args, "O&O", PyObjectToPlasmaConnection, &conn,
+                        &object_id_list)) {
+    return NULL;
+  }
+  if (!plasma_manager_is_connected(conn)) {
+    PyErr_SetString(PyExc_RuntimeError, "Not connected to the plasma manager");
+    return NULL;
+  }
+  Py_ssize_t n = PyList_Size(object_id_list);
+  ObjectID *object_ids = (ObjectID *) malloc(sizeof(ObjectID) * n);
+  for (int i = 0; i < n; ++i) {
+    PyStringToUniqueID(PyList_GetItem(object_id_list, i), &object_ids[i]);
+  }
+  plasma_fetch(conn, (int) n, object_ids);
+  free(object_ids);
+  Py_RETURN_NONE;
+}
+
+PyObject *PyPlasma_wait(PyObject *self, PyObject *args) {
+  PlasmaConnection *conn;
+  PyObject *object_id_list;
+  long long timeout;
+  int num_returns;
+  if (!PyArg_ParseTuple(args, "O&OLi", PyObjectToPlasmaConnection, &conn,
+                        &object_id_list, &timeout, &num_returns)) {
+    return NULL;
+  }
+  Py_ssize_t n = PyList_Size(object_id_list);
+
+  if (!plasma_manager_is_connected(conn)) {
+    PyErr_SetString(PyExc_RuntimeError, "Not connected to the plasma manager");
+    return NULL;
+  }
+  if (num_returns < 0) {
+    PyErr_SetString(PyExc_RuntimeError,
+                    "The argument num_returns cannot be less than zero.");
+    return NULL;
+  }
+  if (num_returns > n) {
+    PyErr_SetString(
+        PyExc_RuntimeError,
+        "The argument num_returns cannot be greater than len(object_ids)");
+    return NULL;
+  }
+  int64_t threshold = 1 << 30;
+  if (timeout > threshold) {
+    PyErr_SetString(PyExc_RuntimeError,
+                    "The argument timeout cannot be greater than 2 ** 30.");
+    return NULL;
+  }
+
+  ObjectRequest *object_requests =
+      (ObjectRequest *) malloc(sizeof(ObjectRequest) * n);
+  for (int i = 0; i < n; ++i) {
+    CHECK(PyStringToUniqueID(PyList_GetItem(object_id_list, i),
+                             &object_requests[i].object_id) == 1);
+    object_requests[i].type = PLASMA_QUERY_ANYWHERE;
+  }
+  /* Drop the global interpreter lock while we are waiting, so other threads can
+   * run. */
+  int num_return_objects;
+  Py_BEGIN_ALLOW_THREADS;
+  num_return_objects = plasma_wait(conn, (int) n, object_requests, num_returns,
+                                   (uint64_t) timeout);
+  Py_END_ALLOW_THREADS;
+
+  int num_to_return = std::min(num_return_objects, num_returns);
+  PyObject *ready_ids = PyList_New(num_to_return);
+  PyObject *waiting_ids = PySet_New(object_id_list);
+  int num_returned = 0;
+  for (int i = 0; i < n; ++i) {
+    if (num_returned == num_to_return) {
+      break;
+    }
+    if (object_requests[i].status == ObjectStatus_Local ||
+        object_requests[i].status == ObjectStatus_Remote) {
+      PyObject *ready =
+          PyBytes_FromStringAndSize((char *) object_requests[i].object_id.id,
+                                    sizeof(object_requests[i].object_id));
+      PyList_SetItem(ready_ids, num_returned, ready);
+      PySet_Discard(waiting_ids, ready);
+      num_returned += 1;
+    } else {
+      CHECK(object_requests[i].status == ObjectStatus_Nonexistent);
+    }
+  }
+  CHECK(num_returned == num_to_return);
+  /* Return both the ready IDs and the remaining IDs. */
+  PyObject *t = PyTuple_New(2);
+  PyTuple_SetItem(t, 0, ready_ids);
+  PyTuple_SetItem(t, 1, waiting_ids);
+  return t;
+}
+
+PyObject *PyPlasma_evict(PyObject *self, PyObject *args) {
+  PlasmaConnection *conn;
+  long long num_bytes;
+  if (!PyArg_ParseTuple(args, "O&L", PyObjectToPlasmaConnection, &conn,
+                        &num_bytes)) {
+    return NULL;
+  }
+  int64_t evicted_bytes = plasma_evict(conn, (int64_t) num_bytes);
+  return PyLong_FromLong((long) evicted_bytes);
+}
+
+PyObject *PyPlasma_delete(PyObject *self, PyObject *args) {
+  PlasmaConnection *conn;
+  ObjectID object_id;
+  if (!PyArg_ParseTuple(args, "O&O&", PyObjectToPlasmaConnection, &conn,
+                        PyStringToUniqueID, &object_id)) {
+    return NULL;
+  }
+  plasma_delete(conn, object_id);
+  Py_RETURN_NONE;
+}
+
+PyObject *PyPlasma_transfer(PyObject *self, PyObject *args) {
+  PlasmaConnection *conn;
+  ObjectID object_id;
+  const char *addr;
+  int port;
+  if (!PyArg_ParseTuple(args, "O&O&si", PyObjectToPlasmaConnection, &conn,
+                        PyStringToUniqueID, &object_id, &addr, &port)) {
+    return NULL;
+  }
+
+  if (!plasma_manager_is_connected(conn)) {
+    PyErr_SetString(PyExc_RuntimeError, "Not connected to the plasma manager");
+    return NULL;
+  }
+
+  plasma_transfer(conn, addr, port, object_id);
+  Py_RETURN_NONE;
+}
+
+PyObject *PyPlasma_subscribe(PyObject *self, PyObject *args) {
+  PlasmaConnection *conn;
+  if (!PyArg_ParseTuple(args, "O&", PyObjectToPlasmaConnection, &conn)) {
+    return NULL;
+  }
+
+  int sock = plasma_subscribe(conn);
+  return PyLong_FromLong(sock);
+}
+
+PyObject *PyPlasma_receive_notification(PyObject *self, PyObject *args) {
+  int plasma_sock;
+
+  if (!PyArg_ParseTuple(args, "i", &plasma_sock)) {
+    return NULL;
+  }
+  /* Receive object notification from the plasma connection socket. If the
+   * object was added, return a tuple of its fields: ObjectID, data_size,
+   * metadata_size. If the object was deleted, data_size and metadata_size will
+   * be set to -1. */
+  uint8_t *notification = read_message_async(NULL, plasma_sock);
+  if (notification == NULL) {
+    PyErr_SetString(PyExc_RuntimeError,
+                    "Failed to read object notification from Plasma socket");
+    return NULL;
+  }
+  auto object_info = flatbuffers::GetRoot<ObjectInfo>(notification);
+  /* Construct a tuple from object_info and return. */
+  PyObject *t = PyTuple_New(3);
+  PyTuple_SetItem(t, 0,
+                  PyBytes_FromStringAndSize(object_info->object_id()->data(),
+                                            object_info->object_id()->size()));
+  if (object_info->is_deletion()) {
+    PyTuple_SetItem(t, 1, PyLong_FromLong(-1));
+    PyTuple_SetItem(t, 2, PyLong_FromLong(-1));
+  } else {
+    PyTuple_SetItem(t, 1, PyLong_FromLong(object_info->data_size()));
+    PyTuple_SetItem(t, 2, PyLong_FromLong(object_info->metadata_size()));
+  }
+
+  free(notification);
+  return t;
+}
+
+static PyMethodDef plasma_methods[] = {
+    {"connect", PyPlasma_connect, METH_VARARGS, "Connect to plasma."},
+    {"disconnect", PyPlasma_disconnect, METH_VARARGS,
+     "Disconnect from plasma."},
+    {"create", PyPlasma_create, METH_VARARGS, "Create a new plasma object."},
+    {"hash", PyPlasma_hash, METH_VARARGS,
+     "Compute the hash of a plasma object."},
+    {"seal", PyPlasma_seal, METH_VARARGS, "Seal a plasma object."},
+    {"get", PyPlasma_get, METH_VARARGS, "Get a plasma object."},
+    {"contains", PyPlasma_contains, METH_VARARGS,
+     "Does the plasma store contain this plasma object?"},
+    {"fetch", PyPlasma_fetch, METH_VARARGS,
+     "Fetch the object from another plasma manager instance."},
+    {"wait", PyPlasma_wait, METH_VARARGS,
+     "Wait until num_returns objects in object_ids are ready."},
+    {"evict", PyPlasma_evict, METH_VARARGS,
+     "Evict some objects until we recover some number of bytes."},
+    {"release", PyPlasma_release, METH_VARARGS, "Release the plasma object."},
+    {"delete", PyPlasma_delete, METH_VARARGS, "Delete a plasma object."},
+    {"transfer", PyPlasma_transfer, METH_VARARGS,
+     "Transfer object to another plasma manager."},
+    {"subscribe", PyPlasma_subscribe, METH_VARARGS,
+     "Subscribe to the plasma notification socket."},
+    {"receive_notification", PyPlasma_receive_notification, METH_VARARGS,
+     "Receive next notification from plasma notification socket."},
+    {NULL} /* Sentinel */
+};
+
+#if PY_MAJOR_VERSION >= 3
+static struct PyModuleDef moduledef = {
+    PyModuleDef_HEAD_INIT,
+    "libplasma",                           /* m_name */
+    "A Python client library for plasma.", /* m_doc */
+    0,                                     /* m_size */
+    plasma_methods,                        /* m_methods */
+    NULL,                                  /* m_reload */
+    NULL,                                  /* m_traverse */
+    NULL,                                  /* m_clear */
+    NULL,                                  /* m_free */
+};
+#endif
+
+#if PY_MAJOR_VERSION >= 3
+#define INITERROR return NULL
+#else
+#define INITERROR return
+#endif
+
+#ifndef PyMODINIT_FUNC /* declarations for DLL import/export */
+#define PyMODINIT_FUNC void
+#endif
+
+#if PY_MAJOR_VERSION >= 3
+#define MOD_INIT(name) PyMODINIT_FUNC PyInit_##name(void)
+#else
+#define MOD_INIT(name) PyMODINIT_FUNC init##name(void)
+#endif
+
+MOD_INIT(libplasma) {
+#if PY_MAJOR_VERSION >= 3
+  PyObject *m = PyModule_Create(&moduledef);
+#else
+  PyObject *m = Py_InitModule3("libplasma", plasma_methods,
+                               "A Python client library for plasma.");
+#endif
+
+  /* Create a custom exception for when an object ID is reused. */
+  char plasma_object_exists_error[] = "plasma_object_exists.error";
+  PlasmaObjectExistsError =
+      PyErr_NewException(plasma_object_exists_error, NULL, NULL);
+  Py_INCREF(PlasmaObjectExistsError);
+  PyModule_AddObject(m, "plasma_object_exists_error", PlasmaObjectExistsError);
+  /* Create a custom exception for when the plasma store is out of memory. */
+  char plasma_out_of_memory_error[] = "plasma_out_of_memory.error";
+  PlasmaOutOfMemoryError =
+      PyErr_NewException(plasma_out_of_memory_error, NULL, NULL);
+  Py_INCREF(PlasmaOutOfMemoryError);
+  PyModule_AddObject(m, "plasma_out_of_memory_error", PlasmaOutOfMemoryError);
+
+#if PY_MAJOR_VERSION >= 3
+  return m;
+#endif
+}
diff --git a/cpp/src/plasma/plasma_extension.h b/cpp/src/plasma/plasma_extension.h
new file mode 100644
index 000000000000..f659b8cdc662
--- /dev/null
+++ b/cpp/src/plasma/plasma_extension.h
@@ -0,0 +1,25 @@
+#ifndef PLASMA_EXTENSION_H
+#define PLASMA_EXTENSION_H
+
+static int PyObjectToPlasmaConnection(PyObject *object,
+                                      PlasmaConnection **conn) {
+  if (PyCapsule_IsValid(object, "plasma")) {
+    *conn = (PlasmaConnection *) PyCapsule_GetPointer(object, "plasma");
+    return 1;
+  } else {
+    PyErr_SetString(PyExc_TypeError, "must be a 'plasma' capsule");
+    return 0;
+  }
+}
+
+int PyStringToUniqueID(PyObject *object, ObjectID *object_id) {
+  if (PyBytes_Check(object)) {
+    memcpy(&object_id->id[0], PyBytes_AsString(object), UNIQUE_ID_SIZE);
+    return 1;
+  } else {
+    PyErr_SetString(PyExc_TypeError, "must be a 20 character string");
+    return 0;
+  }
+}
+
+#endif /* PLASMA_EXTENSION_H */
diff --git a/cpp/src/plasma/plasma_protocol.cc b/cpp/src/plasma/plasma_protocol.cc
new file mode 100644
index 000000000000..5064a157b593
--- /dev/null
+++ b/cpp/src/plasma/plasma_protocol.cc
@@ -0,0 +1,638 @@
+#include "flatbuffers/flatbuffers.h"
+#include "format/plasma_generated.h"
+
+#include "plasma_protocol.h"
+#include "io.h"
+
+#define FLATBUFFER_BUILDER_DEFAULT_SIZE 1024
+
+flatbuffers::Offset<flatbuffers::String> to_flatbuf(
+    flatbuffers::FlatBufferBuilder &fbb,
+    ObjectID object_id) {
+  return fbb.CreateString((char *) &object_id.id[0], sizeof(object_id.id));
+}
+
+ObjectID from_flatbuf(const flatbuffers::String *string) {
+  ObjectID object_id;
+  CHECK(string->size() == sizeof(object_id.id));
+  memcpy(&object_id.id[0], string->data(), sizeof(object_id.id));
+  return object_id;
+}
+
+flatbuffers::Offset<
+    flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>>
+to_flatbuf(flatbuffers::FlatBufferBuilder &fbb,
+           ObjectID object_ids[],
+           int64_t num_objects) {
+  std::vector<flatbuffers::Offset<flatbuffers::String>> results;
+  for (size_t i = 0; i < num_objects; i++) {
+    results.push_back(to_flatbuf(fbb, object_ids[i]));
+  }
+  return fbb.CreateVector(results);
+}
+
+protocol_builder *make_protocol_builder(void) {
+  return NULL;
+}
+
+void free_protocol_builder(protocol_builder *builder) {}
+
+uint8_t *plasma_receive(int sock, int64_t message_type) {
+  int64_t type;
+  int64_t length;
+  uint8_t *reply_data;
+  read_message(sock, &type, &length, &reply_data);
+  if (type != message_type) {
+    ARROW_LOG(FATAL) << "type = " << type << ", message_type = " << message_type;
+  }
+  return reply_data;
+}
+
+/* Create messages. */
+
+int plasma_send_CreateRequest(int sock,
+                              protocol_builder *B,
+                              ObjectID object_id,
+                              int64_t data_size,
+                              int64_t metadata_size) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaCreateRequest(fbb, to_flatbuf(fbb, object_id),
+                                           data_size, metadata_size);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaCreateRequest, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_CreateRequest(uint8_t *data,
+                               ObjectID *object_id,
+                               int64_t *data_size,
+                               int64_t *metadata_size) {
+  CHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaCreateRequest>(data);
+  *data_size = message->data_size();
+  *metadata_size = message->metadata_size();
+  *object_id = from_flatbuf(message->object_id());
+}
+
+int plasma_send_CreateReply(int sock,
+                            protocol_builder *B,
+                            ObjectID object_id,
+                            PlasmaObject *object,
+                            int error_code) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  PlasmaObjectSpec plasma_object(
+      object->handle.store_fd, object->handle.mmap_size, object->data_offset,
+      object->data_size, object->metadata_offset, object->metadata_size);
+  auto message =
+      CreatePlasmaCreateReply(fbb, to_flatbuf(fbb, object_id), &plasma_object,
+                              (PlasmaError) error_code);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaCreateReply, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_CreateReply(uint8_t *data,
+                             ObjectID *object_id,
+                             PlasmaObject *object,
+                             int *error_code) {
+  CHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaCreateReply>(data);
+  *object_id = from_flatbuf(message->object_id());
+  object->handle.store_fd = message->plasma_object()->segment_index();
+  object->handle.mmap_size = message->plasma_object()->mmap_size();
+  object->data_offset = message->plasma_object()->data_offset();
+  object->data_size = message->plasma_object()->data_size();
+  object->metadata_offset = message->plasma_object()->metadata_offset();
+  object->metadata_size = message->plasma_object()->metadata_size();
+  *error_code = message->error();
+}
+
+/* Seal messages. */
+
+int plasma_send_SealRequest(int sock,
+                            protocol_builder *B,
+                            ObjectID object_id,
+                            unsigned char *digest) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto digest_string = fbb.CreateString((char *) digest, DIGEST_SIZE);
+  auto message =
+      CreatePlasmaSealRequest(fbb, to_flatbuf(fbb, object_id), digest_string);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaSealRequest, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_SealRequest(uint8_t *data,
+                             ObjectID *object_id,
+                             unsigned char *digest) {
+  CHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaSealRequest>(data);
+  *object_id = from_flatbuf(message->object_id());
+  CHECK(message->digest()->size() == DIGEST_SIZE);
+  memcpy(digest, message->digest()->data(), DIGEST_SIZE);
+}
+
+int plasma_send_SealReply(int sock,
+                          protocol_builder *B,
+                          ObjectID object_id,
+                          int error) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaSealReply(fbb, to_flatbuf(fbb, object_id),
+                                       (PlasmaError) error);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaSealReply, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_SealReply(uint8_t *data, ObjectID *object_id, int *error) {
+  CHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaSealReply>(data);
+  *object_id = from_flatbuf(message->object_id());
+  *error = message->error();
+}
+
+/* Release messages. */
+
+int plasma_send_ReleaseRequest(int sock,
+                               protocol_builder *B,
+                               ObjectID object_id) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaSealRequest(fbb, to_flatbuf(fbb, object_id));
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaReleaseRequest, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_ReleaseRequest(uint8_t *data, ObjectID *object_id) {
+  CHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaReleaseRequest>(data);
+  *object_id = from_flatbuf(message->object_id());
+}
+
+int plasma_send_ReleaseReply(int sock,
+                             protocol_builder *B,
+                             ObjectID object_id,
+                             int error) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaReleaseReply(fbb, to_flatbuf(fbb, object_id),
+                                          (PlasmaError) error);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaReleaseReply, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_ReleaseReply(uint8_t *data, ObjectID *object_id, int *error) {
+  CHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaReleaseReply>(data);
+  *object_id = from_flatbuf(message->object_id());
+  *error = message->error();
+}
+
+/* Delete messages. */
+
+int plasma_send_DeleteRequest(int sock,
+                              protocol_builder *B,
+                              ObjectID object_id) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaDeleteRequest(fbb, to_flatbuf(fbb, object_id));
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaDeleteRequest, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_DeleteRequest(uint8_t *data, ObjectID *object_id) {
+  CHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaReleaseReply>(data);
+  *object_id = from_flatbuf(message->object_id());
+}
+
+int plasma_send_DeleteReply(int sock,
+                            protocol_builder *B,
+                            ObjectID object_id,
+                            int error) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaDeleteReply(fbb, to_flatbuf(fbb, object_id),
+                                         (PlasmaError) error);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaDeleteReply, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_DeleteReply(uint8_t *data, ObjectID *object_id, int *error) {
+  CHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaDeleteReply>(data);
+  *object_id = from_flatbuf(message->object_id());
+  *error = message->error();
+}
+
+/* Satus messages. */
+
+int plasma_send_StatusRequest(int sock,
+                              protocol_builder *B,
+                              ObjectID object_ids[],
+                              int64_t num_objects) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message =
+      CreatePlasmaStatusRequest(fbb, to_flatbuf(fbb, object_ids, num_objects));
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaStatusRequest, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+int64_t plasma_read_StatusRequest_num_objects(uint8_t *data) {
+  DCHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaStatusRequest>(data);
+  return message->object_ids()->size();
+}
+
+void plasma_read_StatusRequest(uint8_t *data,
+                               ObjectID object_ids[],
+                               int64_t num_objects) {
+  DCHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaStatusRequest>(data);
+  for (int64_t i = 0; i < num_objects; ++i) {
+    object_ids[i] = from_flatbuf(message->object_ids()->Get(i));
+  }
+}
+
+int plasma_send_StatusReply(int sock,
+                            protocol_builder *B,
+                            ObjectID object_ids[],
+                            int object_status[],
+                            int64_t num_objects) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message =
+      CreatePlasmaStatusReply(fbb, to_flatbuf(fbb, object_ids, num_objects),
+                              fbb.CreateVector(object_status, num_objects));
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaStatusReply, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+int64_t plasma_read_StatusReply_num_objects(uint8_t *data) {
+  DCHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaStatusReply>(data);
+  return message->object_ids()->size();
+}
+
+void plasma_read_StatusReply(uint8_t *data,
+                             ObjectID object_ids[],
+                             int object_status[],
+                             int64_t num_objects) {
+  DCHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaStatusReply>(data);
+  for (int64_t i = 0; i < num_objects; ++i) {
+    object_ids[i] = from_flatbuf(message->object_ids()->Get(i));
+  }
+  for (int64_t i = 0; i < num_objects; ++i) {
+    object_status[i] = message->status()->data()[i];
+  }
+}
+
+/* Contains messages. */
+
+int plasma_send_ContainsRequest(int sock,
+                                protocol_builder *B,
+                                ObjectID object_id) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaContainsRequest(fbb, to_flatbuf(fbb, object_id));
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaContainsRequest, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_ContainsRequest(uint8_t *data, ObjectID *object_id) {
+  CHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaContainsRequest>(data);
+  *object_id = from_flatbuf(message->object_id());
+}
+
+int plasma_send_ContainsReply(int sock,
+                              protocol_builder *B,
+                              ObjectID object_id,
+                              int has_object) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message =
+      CreatePlasmaContainsReply(fbb, to_flatbuf(fbb, object_id), has_object);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaContainsReply, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_ContainsReply(uint8_t *data,
+                               ObjectID *object_id,
+                               int *has_object) {
+  CHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaContainsReply>(data);
+  *object_id = from_flatbuf(message->object_id());
+  *has_object = message->has_object();
+}
+
+/* Connect messages. */
+
+int plasma_send_ConnectRequest(int sock, protocol_builder *B) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaConnectRequest(fbb);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaConnectRequest, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_ConnectRequest(uint8_t *data) {}
+
+int plasma_send_ConnectReply(int sock,
+                             protocol_builder *B,
+                             int64_t memory_capacity) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaConnectReply(fbb, memory_capacity);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaConnectReply, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_ConnectReply(uint8_t *data, int64_t *memory_capacity) {
+  DCHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaConnectReply>(data);
+  *memory_capacity = message->memory_capacity();
+}
+
+/* Evict messages. */
+
+int plasma_send_EvictRequest(int sock, protocol_builder *B, int64_t num_bytes) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaEvictRequest(fbb, num_bytes);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaEvictRequest, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_EvictRequest(uint8_t *data, int64_t *num_bytes) {
+  CHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaEvictRequest>(data);
+  *num_bytes = message->num_bytes();
+}
+
+int plasma_send_EvictReply(int sock, protocol_builder *B, int64_t num_bytes) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaEvictReply(fbb, num_bytes);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaEvictReply, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_EvictReply(uint8_t *data, int64_t *num_bytes) {
+  DCHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaEvictReply>(data);
+  *num_bytes = message->num_bytes();
+}
+
+/* Get messages. */
+
+int plasma_send_GetRequest(int sock,
+                           protocol_builder *B,
+                           ObjectID object_ids[],
+                           int64_t num_objects,
+                           int64_t timeout_ms) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaGetRequest(
+      fbb, to_flatbuf(fbb, object_ids, num_objects), timeout_ms);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaGetRequest, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+int64_t plasma_read_GetRequest_num_objects(uint8_t *data) {
+  DCHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaGetRequest>(data);
+  return message->object_ids()->size();
+}
+
+void plasma_read_GetRequest(uint8_t *data,
+                            ObjectID object_ids[],
+                            int64_t *timeout_ms,
+                            int64_t num_objects) {
+  DCHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaGetRequest>(data);
+  for (int64_t i = 0; i < num_objects; ++i) {
+    object_ids[i] = from_flatbuf(message->object_ids()->Get(i));
+  }
+  *timeout_ms = message->timeout_ms();
+}
+
+int plasma_send_GetReply(int sock,
+                         protocol_builder *B,
+                         ObjectID object_ids[],
+                         PlasmaObject plasma_objects[],
+                         int64_t num_objects) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  std::vector<PlasmaObjectSpec> objects;
+
+  for (int i = 0; i < num_objects; ++i) {
+    PlasmaObject *object = &plasma_objects[i];
+    objects.push_back(PlasmaObjectSpec(
+        object->handle.store_fd, object->handle.mmap_size, object->data_offset,
+        object->data_size, object->metadata_offset, object->metadata_size));
+  }
+  auto message = CreatePlasmaGetReply(
+      fbb, to_flatbuf(fbb, object_ids, num_objects),
+      fbb.CreateVectorOfStructs(objects.data(), num_objects));
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaGetReply, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_GetReply(uint8_t *data,
+                          ObjectID object_ids[],
+                          PlasmaObject plasma_objects[],
+                          int64_t num_objects) {
+  CHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaGetReply>(data);
+  for (int64_t i = 0; i < num_objects; ++i) {
+    object_ids[i] = from_flatbuf(message->object_ids()->Get(i));
+  }
+  for (int64_t i = 0; i < num_objects; ++i) {
+    const PlasmaObjectSpec *object = message->plasma_objects()->Get(i);
+    plasma_objects[i].handle.store_fd = object->segment_index();
+    plasma_objects[i].handle.mmap_size = object->mmap_size();
+    plasma_objects[i].data_offset = object->data_offset();
+    plasma_objects[i].data_size = object->data_size();
+    plasma_objects[i].metadata_offset = object->metadata_offset();
+    plasma_objects[i].metadata_size = object->metadata_size();
+  }
+}
+
+/* Fetch messages. */
+
+int plasma_send_FetchRequest(int sock,
+                             protocol_builder *B,
+                             ObjectID object_ids[],
+                             int64_t num_objects) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message =
+      CreatePlasmaFetchRequest(fbb, to_flatbuf(fbb, object_ids, num_objects));
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaFetchRequest, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+int64_t plasma_read_FetchRequest_num_objects(uint8_t *data) {
+  DCHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaFetchRequest>(data);
+  return message->object_ids()->size();
+}
+
+void plasma_read_FetchRequest(uint8_t *data,
+                              ObjectID object_ids[],
+                              int64_t num_objects) {
+  CHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaFetchRequest>(data);
+  for (int64_t i = 0; i < num_objects; ++i) {
+    object_ids[i] = from_flatbuf(message->object_ids()->Get(i));
+  }
+}
+
+/* Wait messages. */
+
+int plasma_send_WaitRequest(int sock,
+                            protocol_builder *B,
+                            ObjectRequest object_requests[],
+                            int num_requests,
+                            int num_ready_objects,
+                            int64_t timeout_ms) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+
+  std::vector<flatbuffers::Offset<ObjectRequestSpec>> object_request_specs;
+  for (int i = 0; i < num_requests; i++) {
+    object_request_specs.push_back(CreateObjectRequestSpec(
+        fbb, to_flatbuf(fbb, object_requests[i].object_id),
+        object_requests[i].type));
+  }
+
+  auto message =
+      CreatePlasmaWaitRequest(fbb, fbb.CreateVector(object_request_specs),
+                              num_ready_objects, timeout_ms);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaWaitRequest, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+int plasma_read_WaitRequest_num_object_ids(uint8_t *data) {
+  DCHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaWaitRequest>(data);
+  return message->object_requests()->size();
+}
+
+void plasma_read_WaitRequest(uint8_t *data,
+                             ObjectRequest object_requests[],
+                             int num_object_ids,
+                             int64_t *timeout_ms,
+                             int *num_ready_objects) {
+  DCHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaWaitRequest>(data);
+  *num_ready_objects = message->num_ready_objects();
+  *timeout_ms = message->timeout();
+
+  CHECK(num_object_ids == message->object_requests()->size());
+  for (int i = 0; i < num_object_ids; i++) {
+    object_requests[i].object_id =
+        from_flatbuf(message->object_requests()->Get(i)->object_id());
+    object_requests[i].type = message->object_requests()->Get(i)->type();
+  }
+}
+
+int plasma_send_WaitReply(int sock,
+                          protocol_builder *B,
+                          ObjectRequest object_requests[],
+                          int num_ready_objects) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+
+  std::vector<flatbuffers::Offset<ObjectReply>> object_replies;
+  for (int i = 0; i < num_ready_objects; i++) {
+    object_replies.push_back(
+        CreateObjectReply(fbb, to_flatbuf(fbb, object_requests[i].object_id),
+                          object_requests[i].status));
+  }
+
+  auto message = CreatePlasmaWaitReply(
+      fbb, fbb.CreateVector(object_replies.data(), num_ready_objects),
+      num_ready_objects);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaWaitReply, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_WaitReply(uint8_t *data,
+                           ObjectRequest object_requests[],
+                           int *num_ready_objects) {
+  DCHECK(data);
+
+  auto message = flatbuffers::GetRoot<PlasmaWaitReply>(data);
+  *num_ready_objects = message->num_ready_objects();
+  for (int i = 0; i < *num_ready_objects; i++) {
+    object_requests[i].object_id =
+        from_flatbuf(message->object_requests()->Get(i)->object_id());
+    object_requests[i].status = message->object_requests()->Get(i)->status();
+  }
+}
+
+/* Subscribe messages. */
+
+int plasma_send_SubscribeRequest(int sock, protocol_builder *B) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaSubscribeRequest(fbb);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaSubscribeRequest, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+/* Data messages. */
+
+int plasma_send_DataRequest(int sock,
+                            protocol_builder *B,
+                            ObjectID object_id,
+                            const char *address,
+                            int port) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto addr = fbb.CreateString((char *) address, strlen(address));
+  auto message =
+      CreatePlasmaDataRequest(fbb, to_flatbuf(fbb, object_id), addr, port);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaDataRequest, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_DataRequest(uint8_t *data,
+                             ObjectID *object_id,
+                             char **address,
+                             int *port) {
+  DCHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaDataRequest>(data);
+  DCHECK(message->object_id()->size() == sizeof(object_id->id));
+  *object_id = from_flatbuf(message->object_id());
+  *address = strdup(message->address()->c_str());
+  *port = message->port();
+}
+
+int plasma_send_DataReply(int sock,
+                          protocol_builder *B,
+                          ObjectID object_id,
+                          int64_t object_size,
+                          int64_t metadata_size) {
+  flatbuffers::FlatBufferBuilder fbb(FLATBUFFER_BUILDER_DEFAULT_SIZE);
+  auto message = CreatePlasmaDataReply(fbb, to_flatbuf(fbb, object_id),
+                                       object_size, metadata_size);
+  fbb.Finish(message);
+  return write_message(sock, MessageType_PlasmaDataReply, fbb.GetSize(),
+                       fbb.GetBufferPointer());
+}
+
+void plasma_read_DataReply(uint8_t *data,
+                           ObjectID *object_id,
+                           int64_t *object_size,
+                           int64_t *metadata_size) {
+  DCHECK(data);
+  auto message = flatbuffers::GetRoot<PlasmaDataReply>(data);
+  *object_id = from_flatbuf(message->object_id());
+  *object_size = (int64_t) message->object_size();
+  *metadata_size = (int64_t) message->metadata_size();
+}
diff --git a/cpp/src/plasma/plasma_protocol.h b/cpp/src/plasma/plasma_protocol.h
new file mode 100644
index 000000000000..6142be92cc90
--- /dev/null
+++ b/cpp/src/plasma/plasma_protocol.h
@@ -0,0 +1,285 @@
+#ifndef PLASMA_PROTOCOL_H
+#define PLASMA_PROTOCOL_H
+
+#include "format/plasma_generated.h"
+
+#include "common.h"
+#include "plasma.h"
+
+typedef void protocol_builder;
+
+/* An argument to a function that a return value gets written to. */
+#define OUT
+
+/**
+ * Convert an object ID to a flatbuffer string.
+ *
+ * @param fbb Reference to the flatbuffer builder.
+ * @param object_id The object ID to be converted.
+ * @return The flatbuffer string contining the object ID.
+ */
+flatbuffers::Offset<flatbuffers::String> to_flatbuf(
+    flatbuffers::FlatBufferBuilder &fbb,
+    ObjectID object_id);
+
+/**
+ * Convert a flatbuffer string to an object ID.
+ *
+ * @param string The flatbuffer string.
+ * @return The object ID.
+ */
+ObjectID from_flatbuf(const flatbuffers::String *string);
+
+/**
+ * Convert an array of object IDs to a flatbuffer vector of strings.
+ *
+ * @param fbb Reference to the flatbuffer builder.
+ * @param object_ids Array of object IDs.
+ * @param num_objects Number of elements in the array.
+ * @return Flatbuffer vector of strings.
+ */
+flatbuffers::Offset<
+    flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>>
+to_flatbuf(flatbuffers::FlatBufferBuilder &fbb,
+           ObjectID object_ids[],
+           int64_t num_objects);
+
+protocol_builder *make_protocol_builder(void);
+
+void free_protocol_builder(protocol_builder *builder);
+
+/* Plasma receive message. */
+
+uint8_t *plasma_receive(int sock, int64_t message_type);
+
+/* Plasma Create message functions. */
+
+int plasma_send_CreateRequest(int sock,
+                              protocol_builder *B,
+                              ObjectID object_id,
+                              int64_t data_size,
+                              int64_t metadata_size);
+
+void plasma_read_CreateRequest(uint8_t *data,
+                               ObjectID *object_id,
+                               int64_t *data_size,
+                               int64_t *metadata_size);
+
+int plasma_send_CreateReply(int sock,
+                            protocol_builder *B,
+                            ObjectID object_id,
+                            PlasmaObject *object,
+                            int error);
+
+void plasma_read_CreateReply(uint8_t *data,
+                             ObjectID *object_id,
+                             PlasmaObject *object,
+                             int *error);
+
+/* Plasma Seal message functions. */
+
+int plasma_send_SealRequest(int sock,
+                            protocol_builder *B,
+                            ObjectID object_id,
+                            unsigned char *digest);
+
+void plasma_read_SealRequest(uint8_t *data,
+                             OUT ObjectID *object_id,
+                             OUT unsigned char *digest);
+
+int plasma_send_SealReply(int sock,
+                          protocol_builder *B,
+                          ObjectID object_id,
+                          int error);
+
+void plasma_read_SealReply(uint8_t *data, ObjectID *object_id, int *error);
+
+/* Plasma Get message functions. */
+
+int plasma_send_GetRequest(int sock,
+                           protocol_builder *B,
+                           ObjectID object_ids[],
+                           int64_t num_objects,
+                           int64_t timeout_ms);
+
+int64_t plasma_read_GetRequest_num_objects(uint8_t *data);
+
+void plasma_read_GetRequest(uint8_t *data,
+                            ObjectID object_ids[],
+                            int64_t *timeout_ms,
+                            int64_t num_objects);
+
+int plasma_send_GetReply(int sock,
+                         protocol_builder *B,
+                         ObjectID object_ids[],
+                         PlasmaObject plasma_objects[],
+                         int64_t num_objects);
+
+void plasma_read_GetReply(uint8_t *data,
+                          ObjectID object_ids[],
+                          PlasmaObject plasma_objects[],
+                          int64_t num_objects);
+
+/* Plasma Release message functions. */
+
+int plasma_send_ReleaseRequest(int sock,
+                               protocol_builder *B,
+                               ObjectID object_id);
+
+void plasma_read_ReleaseRequest(uint8_t *data, ObjectID *object_id);
+
+int plasma_send_ReleaseReply(int sock,
+                             protocol_builder *B,
+                             ObjectID object_id,
+                             int error);
+
+void plasma_read_ReleaseReply(uint8_t *data, ObjectID *object_id, int *error);
+
+/* Plasma Delete message functions. */
+
+int plasma_send_DeleteRequest(int sock,
+                              protocol_builder *B,
+                              ObjectID object_id);
+
+void plasma_read_DeleteRequest(uint8_t *data, ObjectID *object_id);
+
+int plasma_send_DeleteReply(int sock,
+                            protocol_builder *B,
+                            ObjectID object_id,
+                            int error);
+
+void plasma_read_DeleteReply(uint8_t *data, ObjectID *object_id, int *error);
+
+/* Plasma Status message functions. */
+
+int plasma_send_StatusRequest(int sock,
+                              protocol_builder *B,
+                              ObjectID object_ids[],
+                              int64_t num_objects);
+
+int64_t plasma_read_StatusRequest_num_objects(uint8_t *data);
+
+void plasma_read_StatusRequest(uint8_t *data,
+                               ObjectID object_ids[],
+                               int64_t num_objects);
+
+int plasma_send_StatusReply(int sock,
+                            protocol_builder *B,
+                            ObjectID object_ids[],
+                            int object_status[],
+                            int64_t num_objects);
+
+int64_t plasma_read_StatusReply_num_objects(uint8_t *data);
+
+void plasma_read_StatusReply(uint8_t *data,
+                             ObjectID object_ids[],
+                             int object_status[],
+                             int64_t num_objects);
+
+/* Plasma Constains message functions. */
+
+int plasma_send_ContainsRequest(int sock,
+                                protocol_builder *B,
+                                ObjectID object_id);
+
+void plasma_read_ContainsRequest(uint8_t *data, ObjectID *object_id);
+
+int plasma_send_ContainsReply(int sock,
+                              protocol_builder *B,
+                              ObjectID object_id,
+                              int has_object);
+
+void plasma_read_ContainsReply(uint8_t *data,
+                               ObjectID *object_id,
+                               int *has_object);
+
+/* Plasma Connect message functions. */
+
+int plasma_send_ConnectRequest(int sock, protocol_builder *B);
+
+void plasma_read_ConnectRequest(uint8_t *data);
+
+int plasma_send_ConnectReply(int sock,
+                             protocol_builder *B,
+                             int64_t memory_capacity);
+
+void plasma_read_ConnectReply(uint8_t *data, int64_t *memory_capacity);
+
+/* Plasma Evict message functions (no reply so far). */
+
+int plasma_send_EvictRequest(int sock, protocol_builder *B, int64_t num_bytes);
+
+void plasma_read_EvictRequest(uint8_t *data, int64_t *num_bytes);
+
+int plasma_send_EvictReply(int sock, protocol_builder *B, int64_t num_bytes);
+
+void plasma_read_EvictReply(uint8_t *data, int64_t *num_bytes);
+
+/* Plasma Fetch Remote message functions. */
+
+int plasma_send_FetchRequest(int sock,
+                             protocol_builder *B,
+                             ObjectID object_ids[],
+                             int64_t num_objects);
+
+int64_t plasma_read_FetchRequest_num_objects(uint8_t *data);
+
+void plasma_read_FetchRequest(uint8_t *data,
+                              ObjectID object_ids[],
+                              int64_t num_objects);
+
+/* Plasma Wait message functions. */
+
+int plasma_send_WaitRequest(int sock,
+                            protocol_builder *B,
+                            ObjectRequest object_requests[],
+                            int num_requests,
+                            int num_ready_objects,
+                            int64_t timeout_ms);
+
+int plasma_read_WaitRequest_num_object_ids(uint8_t *data);
+
+void plasma_read_WaitRequest(uint8_t *data,
+                             ObjectRequest object_requests[],
+                             int num_object_ids,
+                             int64_t *timeout_ms,
+                             int *num_ready_objects);
+
+int plasma_send_WaitReply(int sock,
+                          protocol_builder *B,
+                          ObjectRequest object_requests[],
+                          int num_ready_objects);
+
+void plasma_read_WaitReply(uint8_t *data,
+                           ObjectRequest object_requests[],
+                           int *num_ready_objects);
+
+/* Plasma Subscribe message functions. */
+
+int plasma_send_SubscribeRequest(int sock, protocol_builder *B);
+
+/* Plasma Data message functions. */
+
+int plasma_send_DataRequest(int sock,
+                            protocol_builder *B,
+                            ObjectID object_id,
+                            const char *address,
+                            int port);
+
+void plasma_read_DataRequest(uint8_t *data,
+                             ObjectID *object_id,
+                             char **address,
+                             int *port);
+
+int plasma_send_DataReply(int sock,
+                          protocol_builder *B,
+                          ObjectID object_id,
+                          int64_t object_size,
+                          int64_t metadata_size);
+
+void plasma_read_DataReply(uint8_t *data,
+                           ObjectID *object_id,
+                           int64_t *object_size,
+                           int64_t *metadata_size);
+
+#endif /* PLASMA_PROTOCOL */
diff --git a/cpp/src/plasma/plasma_store.cc b/cpp/src/plasma/plasma_store.cc
new file mode 100644
index 000000000000..324c657fbb2b
--- /dev/null
+++ b/cpp/src/plasma/plasma_store.cc
@@ -0,0 +1,941 @@
+/* PLASMA STORE: This is a simple object store server process
+ *
+ * It accepts incoming client connections on a unix domain socket
+ * (name passed in via the -s option of the executable) and uses a
+ * single thread to serve the clients. Each client establishes a
+ * connection and can create objects, wait for objects and seal
+ * objects through that connection.
+ *
+ * It keeps a hash table that maps object_ids (which are 20 byte long,
+ * just enough to store and SHA1 hash) to memory mapped files. */
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/socket.h>
+#include <sys/statvfs.h>
+#include <sys/types.h>
+#include <sys/un.h>
+#include <getopt.h>
+#include <string.h>
+#include <signal.h>
+#include <limits.h>
+#include <poll.h>
+
+#include "common.h"
+#include "event_loop.h"
+#include "eviction_policy.h"
+#include "io.h"
+#include "uthash.h"
+#include "utarray.h"
+#include "plasma_protocol.h"
+#include "plasma_store.h"
+#include "plasma.h"
+#include "arrow/util/logging.h"
+
+extern "C" {
+#include "fling.h"
+#include "malloc.h"
+void *dlmalloc(size_t);
+void *dlmemalign(size_t alignment, size_t bytes);
+void dlfree(void *);
+}
+
+/** Contains all information that is associated with a Plasma store client. */
+struct Client {
+  /** The socket used to communicate with the client. */
+  int sock;
+  /** A pointer to the global plasma state. */
+  PlasmaStoreState *plasma_state;
+};
+
+/* This is used to define the array of clients used to define the
+ * object_table_entry type. */
+UT_icd client_icd = {sizeof(Client *), NULL, NULL, NULL};
+
+/* This is used to define the queue of object notifications for plasma
+ * subscribers. */
+UT_icd object_info_icd = {sizeof(uint8_t *), NULL, NULL, NULL};
+
+typedef struct {
+  /** Client file descriptor. This is used as a key for the hash table. */
+  int subscriber_fd;
+  /** The object notifications for clients. We notify the client about the
+   *  objects in the order that the objects were sealed or deleted. */
+  UT_array *object_notifications;
+  /** Handle for the uthash table. */
+  UT_hash_handle hh;
+} NotificationQueue;
+
+typedef struct {
+  /** The client connection that called get. */
+  Client *client;
+  /** The ID of the timer that will time out and cause this wait to return to
+   *  the client if it hasn't already returned. */
+  int64_t timer;
+  /** The number of objects in this get request. */
+  int64_t num_object_ids;
+  /** The object IDs involved in this request. This is used in the reply. */
+  ObjectID *object_ids;
+  /** The object information for the objects in this request. This is used in
+   *  the reply. */
+  PlasmaObject *objects;
+  /** The minimum number of objects to wait for in this request. */
+  int64_t num_objects_to_wait_for;
+  /** The number of object requests in this wait request that are already
+   *  satisfied. */
+  int64_t num_satisfied;
+} GetRequest;
+
+typedef struct {
+  /** The ID of the object. This is used as a key in a hash table. */
+  ObjectID object_id;
+  /** An array of the get requests involving this object ID. */
+  UT_array *get_requests;
+  /** Handle for the uthash table in the store state that keeps track of the get
+   *  requests involving this object ID. */
+  UT_hash_handle hh;
+} ObjectGetRequests;
+
+/** This is used to define the utarray of get requests in the
+ *  ObjectGetRequests struct. */
+UT_icd get_request_icd = {sizeof(GetRequest *), NULL, NULL, NULL};
+
+struct PlasmaStoreState {
+  /* Event loop of the plasma store. */
+  event_loop *loop;
+  /** A hash table mapping object IDs to a vector of the get requests that are
+   *  waiting for the object to arrive. */
+  ObjectGetRequests *object_get_requests;
+  /** The pending notifications that have not been sent to subscribers because
+   *  the socket send buffers were full. This is a hash table from client file
+   *  descriptor to an array of object_ids to send to that client. */
+  NotificationQueue *pending_notifications;
+  /** The plasma store information, including the object tables, that is exposed
+   *  to the eviction policy. */
+  PlasmaStoreInfo *plasma_store_info;
+  /** The state that is managed by the eviction policy. */
+  EvictionState *eviction_state;
+  /** Input buffer. This is allocated only once to avoid mallocs for every
+   *  call to process_message. */
+  UT_array *input_buffer;
+  /** Buffer that holds memory for serializing plasma protocol messages. */
+  protocol_builder *builder;
+};
+
+PlasmaStoreState *g_state;
+
+UT_icd byte_icd = {sizeof(uint8_t), NULL, NULL, NULL};
+
+PlasmaStoreState *PlasmaStoreState_init(event_loop *loop,
+                                        int64_t system_memory) {
+  PlasmaStoreState *state =
+      (PlasmaStoreState *) malloc(sizeof(PlasmaStoreState));
+  state->loop = loop;
+  state->object_get_requests = NULL;
+  state->pending_notifications = NULL;
+  /* Initialize the plasma store info. */
+  state->plasma_store_info =
+      (PlasmaStoreInfo *) malloc(sizeof(PlasmaStoreInfo));
+  state->plasma_store_info->objects = NULL;
+  state->plasma_store_info->memory_capacity = system_memory;
+  /* Initialize the eviction state. */
+  state->eviction_state = EvictionState_init();
+  utarray_new(state->input_buffer, &byte_icd);
+  state->builder = make_protocol_builder();
+  return state;
+}
+
+void PlasmaStoreState_free(PlasmaStoreState *state) {
+  /* Here we only clean up objects that need to be cleaned
+   * up to make the valgrind warnings go away. Objects that
+   * are still reachable are not cleaned up. */
+  object_table_entry *entry, *tmp;
+  HASH_ITER(handle, state->plasma_store_info->objects, entry, tmp) {
+    HASH_DELETE(handle, state->plasma_store_info->objects, entry);
+    utarray_free(entry->clients);
+    delete entry;
+  }
+  NotificationQueue *queue, *temp_queue;
+  HASH_ITER(hh, state->pending_notifications, queue, temp_queue) {
+    for (int i = 0; i < utarray_len(queue->object_notifications); ++i) {
+      uint8_t **notification =
+          (uint8_t **) utarray_eltptr(queue->object_notifications, i);
+      uint8_t *data = *notification;
+      free(data);
+    }
+    utarray_free(queue->object_notifications);
+  }
+}
+
+void push_notification(PlasmaStoreState *state,
+                       ObjectInfoT *object_notification);
+
+/* If this client is not already using the object, add the client to the
+ * object's list of clients, otherwise do nothing. */
+void add_client_to_object_clients(object_table_entry *entry,
+                                  Client *client_info) {
+  /* Check if this client is already using the object. */
+  for (int i = 0; i < utarray_len(entry->clients); ++i) {
+    Client **c = (Client **) utarray_eltptr(entry->clients, i);
+    if (*c == client_info) {
+      return;
+    }
+  }
+  /* If there are no other clients using this object, notify the eviction policy
+   * that the object is being used. */
+  if (utarray_len(entry->clients) == 0) {
+    /* Tell the eviction policy that this object is being used. */
+    int64_t num_objects_to_evict;
+    ObjectID *objects_to_evict;
+    EvictionState_begin_object_access(
+        client_info->plasma_state->eviction_state,
+        client_info->plasma_state->plasma_store_info, entry->object_id,
+        &num_objects_to_evict, &objects_to_evict);
+    remove_objects(client_info->plasma_state, num_objects_to_evict,
+                   objects_to_evict);
+  }
+  /* Add the client pointer to the list of clients using this object. */
+  utarray_push_back(entry->clients, &client_info);
+}
+
+/* Create a new object buffer in the hash table. */
+int create_object(Client *client_context,
+                  ObjectID obj_id,
+                  int64_t data_size,
+                  int64_t metadata_size,
+                  PlasmaObject *result) {
+  ARROW_LOG(INFO) << "creating object"; /* TODO(pcm): add ObjectID here */
+  PlasmaStoreState *plasma_state = client_context->plasma_state;
+  object_table_entry *entry;
+  /* TODO(swang): Return these error to the client instead of exiting. */
+  HASH_FIND(handle, plasma_state->plasma_store_info->objects, &obj_id,
+            sizeof(obj_id), entry);
+  if (entry != NULL) {
+    /* There is already an object with the same ID in the Plasma Store, so
+     * ignore this requst. */
+    return PlasmaError_ObjectExists;
+  }
+  /* Tell the eviction policy how much space we need to create this object. */
+  int64_t num_objects_to_evict;
+  ObjectID *objects_to_evict;
+  bool success = EvictionState_require_space(
+      plasma_state->eviction_state, plasma_state->plasma_store_info,
+      data_size + metadata_size, &num_objects_to_evict, &objects_to_evict);
+  remove_objects(plasma_state, num_objects_to_evict, objects_to_evict);
+  /* Return an error to the client if not enough space could be freed to create
+   * the object. */
+  if (!success) {
+    return PlasmaError_OutOfMemory;
+  }
+  /* Allocate space for the new object. We use dlmemalign instead of dlmalloc in
+   * order to align the allocated region to a 64-byte boundary. This is not
+   * strictly necessary, but it is an optimization that could speed up the
+   * computation of a hash of the data (see compute_object_hash_parallel in
+   * plasma_client.cc). Note that even though this pointer is 64-byte aligned,
+   * it is not guaranteed that the corresponding pointer in the client will be
+   * 64-byte aligned, but in practice it often will be. */
+  uint8_t *pointer =
+      (uint8_t *) dlmemalign(BLOCK_SIZE, data_size + metadata_size);
+  int fd;
+  int64_t map_size;
+  ptrdiff_t offset;
+  get_malloc_mapinfo(pointer, &fd, &map_size, &offset);
+  assert(fd != -1);
+
+  entry = new object_table_entry();
+  entry->object_id = obj_id;
+  entry->info.object_id = std::string((char *) &obj_id.id[0], sizeof(obj_id));
+  entry->info.data_size = data_size;
+  entry->info.metadata_size = metadata_size;
+  entry->pointer = pointer;
+  /* TODO(pcm): set the other fields */
+  entry->fd = fd;
+  entry->map_size = map_size;
+  entry->offset = offset;
+  entry->state = PLASMA_CREATED;
+  utarray_new(entry->clients, &client_icd);
+  HASH_ADD(handle, plasma_state->plasma_store_info->objects, object_id,
+           sizeof(ObjectID), entry);
+  result->handle.store_fd = fd;
+  result->handle.mmap_size = map_size;
+  result->data_offset = offset;
+  result->metadata_offset = offset + data_size;
+  result->data_size = data_size;
+  result->metadata_size = metadata_size;
+  /* Notify the eviction policy that this object was created. This must be done
+   * immediately before the call to add_client_to_object_clients so that the
+   * eviction policy does not have an opportunity to evict the object. */
+  EvictionState_object_created(plasma_state->eviction_state,
+                               plasma_state->plasma_store_info, obj_id);
+  /* Record that this client is using this object. */
+  add_client_to_object_clients(entry, client_context);
+  return PlasmaError_OK;
+}
+
+void add_get_request_for_object(PlasmaStoreState *store_state,
+                                ObjectID object_id,
+                                GetRequest *get_req) {
+  ObjectGetRequests *object_get_reqs;
+  HASH_FIND(hh, store_state->object_get_requests, &object_id, sizeof(object_id),
+            object_get_reqs);
+  /* If there are currently no get requests involving this object ID, create a
+   * new ObjectGetRequests struct for this object ID and add it to the hash
+   * table. */
+  if (object_get_reqs == NULL) {
+    object_get_reqs = (ObjectGetRequests *) malloc(sizeof(ObjectGetRequests));
+    object_get_reqs->object_id = object_id;
+    utarray_new(object_get_reqs->get_requests, &get_request_icd);
+    HASH_ADD(hh, store_state->object_get_requests, object_id,
+             sizeof(object_get_reqs->object_id), object_get_reqs);
+  }
+  /* Add this get request to the vector of get requests involving this object
+   * ID. */
+  utarray_push_back(object_get_reqs->get_requests, &get_req);
+}
+
+void remove_get_request_for_object(PlasmaStoreState *store_state,
+                                   ObjectID object_id,
+                                   GetRequest *get_req) {
+  ObjectGetRequests *object_get_reqs;
+  HASH_FIND(hh, store_state->object_get_requests, &object_id, sizeof(object_id),
+            object_get_reqs);
+  /* If there is a vector of get requests for this object ID, and if this vector
+   * contains the get request, then remove the get request from the vector. */
+  if (object_get_reqs != NULL) {
+    for (int i = 0; i < utarray_len(object_get_reqs->get_requests); ++i) {
+      GetRequest **get_req_ptr =
+          (GetRequest **) utarray_eltptr(object_get_reqs->get_requests, i);
+      if (*get_req_ptr == get_req) {
+        /* Remove the get request from the array. */
+        utarray_erase(object_get_reqs->get_requests, i, 1);
+        break;
+      }
+    }
+    /* In principle, if there are no more get requests involving this object ID,
+     * then we could remove the object_get_reqs struct. However, the
+     * object_get_reqs struct gets removed in update_object_get_requests. */
+  }
+}
+
+void remove_get_request(PlasmaStoreState *store_state, GetRequest *get_req) {
+  if (get_req->timer != -1) {
+    CHECK(event_loop_remove_timer(store_state->loop, get_req->timer) == AE_OK);
+  }
+  free(get_req->object_ids);
+  free(get_req->objects);
+  free(get_req);
+}
+
+void PlasmaObject_init(PlasmaObject *object, object_table_entry *entry) {
+  DCHECK(object != NULL);
+  DCHECK(entry != NULL);
+  DCHECK(entry->state == PLASMA_SEALED);
+  object->handle.store_fd = entry->fd;
+  object->handle.mmap_size = entry->map_size;
+  object->data_offset = entry->offset;
+  object->metadata_offset = entry->offset + entry->info.data_size;
+  object->data_size = entry->info.data_size;
+  object->metadata_size = entry->info.metadata_size;
+}
+
+void return_from_get(PlasmaStoreState *store_state, GetRequest *get_req) {
+  /* Send the get reply to the client. */
+  int status = plasma_send_GetReply(get_req->client->sock, store_state->builder,
+                                    get_req->object_ids, get_req->objects,
+                                    get_req->num_object_ids);
+  warn_if_sigpipe(status, get_req->client->sock);
+  /* If we successfully sent the get reply message to the client, then also send
+   * the file descriptors. */
+  if (status >= 0) {
+    /* Send all of the file descriptors for the present objects. */
+    for (int i = 0; i < get_req->num_object_ids; ++i) {
+      /* We use the data size to indicate whether the object is present or not.
+       */
+      if (get_req->objects[i].data_size != -1) {
+        int error_code =
+            send_fd(get_req->client->sock, get_req->objects[i].handle.store_fd);
+        /* If we failed to send the file descriptor, loop until we have sent it
+         * successfully. TODO(rkn): This is problematic for two reasons. First
+         * of all, sending the file descriptor should just succeed without any
+         * errors, but sometimes I see a "Message too long" error number.
+         * Second, looping like this allows a client to potentially block the
+         * plasma store event loop which should never happen. */
+        while (error_code < 0) {
+          if (errno == EMSGSIZE) {
+            ARROW_LOG(WARNING) << "Failed to send file descriptor, retrying.";
+            error_code = send_fd(get_req->client->sock,
+                                 get_req->objects[i].handle.store_fd);
+            continue;
+          }
+          warn_if_sigpipe(error_code, get_req->client->sock);
+          break;
+        }
+      }
+    }
+  }
+
+  /* Remove the get request from each of the relevant object_get_requests hash
+   * tables if it is present there. It should only be present there if the get
+   * request timed out. */
+  for (int i = 0; i < get_req->num_object_ids; ++i) {
+    remove_get_request_for_object(store_state, get_req->object_ids[i], get_req);
+  }
+  /* Remove the get request. */
+  remove_get_request(store_state, get_req);
+}
+
+void update_object_get_requests(PlasmaStoreState *store_state,
+                                ObjectID obj_id) {
+  /* Update the in-progress get requests. */
+  ObjectGetRequests *object_get_reqs;
+  HASH_FIND(hh, store_state->object_get_requests, &obj_id, sizeof(obj_id),
+            object_get_reqs);
+  if (object_get_reqs != NULL) {
+    /* We compute the number of requests first because the length of the utarray
+     * will change as we iterate over it (because each call to return_from_get
+     * will remove one element). */
+    int num_requests = utarray_len(object_get_reqs->get_requests);
+    /* The argument index is the index of the current element of the utarray
+     * that we are processing. It may differ from the counter i when elements
+     * are removed from the array. */
+    int index = 0;
+    for (int i = 0; i < num_requests; ++i) {
+      GetRequest **get_req_ptr =
+          (GetRequest **) utarray_eltptr(object_get_reqs->get_requests, index);
+      GetRequest *get_req = *get_req_ptr;
+
+      int num_updated = 0;
+      for (int j = 0; j < get_req->num_objects_to_wait_for; ++j) {
+        object_table_entry *entry;
+        HASH_FIND(handle, store_state->plasma_store_info->objects, &obj_id,
+                  sizeof(obj_id), entry);
+        CHECK(entry != NULL);
+
+        if (ObjectID_equal(get_req->object_ids[j], obj_id)) {
+          PlasmaObject_init(&get_req->objects[j], entry);
+          num_updated += 1;
+          get_req->num_satisfied += 1;
+          /* Record the fact that this client will be using this object and will
+           * be responsible for releasing this object. */
+          add_client_to_object_clients(entry, get_req->client);
+        }
+      }
+      /* Check a few things just to be sure there aren't bugs. */
+      DCHECK(num_updated > 0);
+      if (num_updated > 1) {
+        ARROW_LOG(WARNING) << "A get request contained a duplicated object ID.";
+      }
+
+      /* If this get request is done, reply to the client. */
+      if (get_req->num_satisfied == get_req->num_objects_to_wait_for) {
+        return_from_get(store_state, get_req);
+      } else {
+        /* The call to return_from_get will remove the current element in the
+         * array, so we only increment the counter in the else branch. */
+        index += 1;
+      }
+    }
+    DCHECK(index == utarray_len(object_get_reqs->get_requests));
+    /* Remove the array of get requests for this object, since no one should be
+     * waiting for this object anymore. */
+    HASH_DELETE(hh, store_state->object_get_requests, object_get_reqs);
+    utarray_free(object_get_reqs->get_requests);
+    free(object_get_reqs);
+  }
+}
+
+int get_timeout_handler(event_loop *loop, timer_id id, void *context) {
+  GetRequest *get_req = (GetRequest *) context;
+  return_from_get(get_req->client->plasma_state, get_req);
+  return EVENT_LOOP_TIMER_DONE;
+}
+
+void process_get_request(Client *client_context,
+                         int num_object_ids,
+                         ObjectID object_ids[],
+                         uint64_t timeout_ms) {
+  PlasmaStoreState *plasma_state = client_context->plasma_state;
+
+  /* Create a get request for this object. */
+  GetRequest *get_req = (GetRequest *) malloc(sizeof(GetRequest));
+  memset(get_req, 0, sizeof(GetRequest));
+  get_req->client = client_context;
+  get_req->timer = -1;
+  get_req->num_object_ids = num_object_ids;
+  get_req->object_ids = (ObjectID *) malloc(num_object_ids * sizeof(ObjectID));
+  get_req->objects =
+      (PlasmaObject *) malloc(num_object_ids * sizeof(PlasmaObject));
+  for (int i = 0; i < num_object_ids; ++i) {
+    get_req->object_ids[i] = object_ids[i];
+  }
+  get_req->num_objects_to_wait_for = num_object_ids;
+  get_req->num_satisfied = 0;
+
+  for (int i = 0; i < num_object_ids; ++i) {
+    ObjectID obj_id = object_ids[i];
+
+    /* Check if this object is already present locally. If so, record that the
+     * object is being used and mark it as accounted for. */
+    object_table_entry *entry;
+    HASH_FIND(handle, plasma_state->plasma_store_info->objects, &obj_id,
+              sizeof(obj_id), entry);
+    if (entry && entry->state == PLASMA_SEALED) {
+      /* Update the get request to take into account the present object. */
+      PlasmaObject_init(&get_req->objects[i], entry);
+      get_req->num_satisfied += 1;
+      /* If necessary, record that this client is using this object. In the case
+       * where entry == NULL, this will be called from seal_object. */
+      add_client_to_object_clients(entry, client_context);
+    } else {
+      /* Add a placeholder plasma object to the get request to indicate that the
+       * object is not present. This will be parsed by the client. We memset it
+       * to 0 so valgrind doesn't complain. We set the data size to -1 to
+       * indicate that the object is not present. */
+      memset(&get_req->objects[i], 0, sizeof(get_req->objects[i]));
+      get_req->objects[i].data_size = -1;
+      /* Add the get request to the relevant data structures. */
+      add_get_request_for_object(plasma_state, obj_id, get_req);
+    }
+  }
+
+  /* If all of the objects are present already or if the timeout is 0, return to
+   * the client. */
+  if (get_req->num_satisfied == get_req->num_objects_to_wait_for ||
+      timeout_ms == 0) {
+    return_from_get(plasma_state, get_req);
+  } else if (timeout_ms != -1) {
+    /* Set a timer that will cause the get request to return to the client. Note
+     * that a timeout of -1 is used to indicate that no timer should be set. */
+    get_req->timer = event_loop_add_timer(plasma_state->loop, timeout_ms,
+                                          get_timeout_handler, get_req);
+  }
+}
+
+int remove_client_from_object_clients(object_table_entry *entry,
+                                      Client *client_info) {
+  /* Find the location of the client in the array. */
+  for (int i = 0; i < utarray_len(entry->clients); ++i) {
+    Client **c = (Client **) utarray_eltptr(entry->clients, i);
+    if (*c == client_info) {
+      /* Remove the client from the array. */
+      utarray_erase(entry->clients, i, 1);
+      /* If no more clients are using this object, notify the eviction policy
+       * that the object is no longer being used. */
+      if (utarray_len(entry->clients) == 0) {
+        /* Tell the eviction policy that this object is no longer being used. */
+        int64_t num_objects_to_evict;
+        ObjectID *objects_to_evict;
+        EvictionState_end_object_access(
+            client_info->plasma_state->eviction_state,
+            client_info->plasma_state->plasma_store_info, entry->object_id,
+            &num_objects_to_evict, &objects_to_evict);
+        remove_objects(client_info->plasma_state, num_objects_to_evict,
+                       objects_to_evict);
+      }
+      /* Return 1 to indicate that the client was removed. */
+      return 1;
+    }
+  }
+  /* Return 0 to indicate that the client was not removed. */
+  return 0;
+}
+
+void release_object(Client *client_context, ObjectID object_id) {
+  PlasmaStoreState *plasma_state = client_context->plasma_state;
+  object_table_entry *entry;
+  HASH_FIND(handle, plasma_state->plasma_store_info->objects, &object_id,
+            sizeof(object_id), entry);
+  CHECK(entry != NULL);
+  /* Remove the client from the object's array of clients. */
+  CHECK(remove_client_from_object_clients(entry, client_context) == 1);
+}
+
+/* Check if an object is present. */
+int contains_object(Client *client_context, ObjectID object_id) {
+  PlasmaStoreState *plasma_state = client_context->plasma_state;
+  object_table_entry *entry;
+  HASH_FIND(handle, plasma_state->plasma_store_info->objects, &object_id,
+            sizeof(object_id), entry);
+  return entry && (entry->state == PLASMA_SEALED) ? OBJECT_FOUND
+                                                  : OBJECT_NOT_FOUND;
+}
+
+/* Seal an object that has been created in the hash table. */
+void seal_object(Client *client_context,
+                 ObjectID object_id,
+                 unsigned char digest[]) {
+  ARROW_LOG(INFO) << "sealing object";  // TODO(pcm): add ObjectID here
+  PlasmaStoreState *plasma_state = client_context->plasma_state;
+  object_table_entry *entry;
+  HASH_FIND(handle, plasma_state->plasma_store_info->objects, &object_id,
+            sizeof(object_id), entry);
+  CHECK(entry != NULL);
+  CHECK(entry->state == PLASMA_CREATED);
+  /* Set the state of object to SEALED. */
+  entry->state = PLASMA_SEALED;
+  /* Set the object digest. */
+  entry->info.digest = std::string((char *) &digest[0], DIGEST_SIZE);
+  /* Inform all subscribers that a new object has been sealed. */
+  push_notification(plasma_state, &entry->info);
+
+  /* Update all get requests that involve this object. */
+  update_object_get_requests(plasma_state, object_id);
+}
+
+/* Delete an object that has been created in the hash table. This should only
+ * be called on objects that are returned by the eviction policy to evict. */
+void delete_object(PlasmaStoreState *plasma_state, ObjectID object_id) {
+  ARROW_LOG(INFO) << "deleting object";
+  object_table_entry *entry;
+  HASH_FIND(handle, plasma_state->plasma_store_info->objects, &object_id,
+            sizeof(object_id), entry);
+  /* TODO(rkn): This should probably not fail, but should instead throw an
+   * error. Maybe we should also support deleting objects that have been created
+   * but not sealed. */
+  CHECK_MSG(entry != NULL, "To delete an object it must be in the object table.");
+  CHECK_MSG(entry->state == PLASMA_SEALED,
+         "To delete an object it must have been sealed.");
+  CHECK_MSG(utarray_len(entry->clients) == 0,
+         "To delete an object, there must be no clients currently using it.");
+  uint8_t *pointer = entry->pointer;
+  HASH_DELETE(handle, plasma_state->plasma_store_info->objects, entry);
+  dlfree(pointer);
+  utarray_free(entry->clients);
+  delete entry;
+  /* Inform all subscribers that the object has been deleted. */
+  ObjectInfoT notification;
+  notification.object_id =
+      std::string((char *) &object_id.id[0], sizeof(object_id));
+  notification.is_deletion = true;
+  push_notification(plasma_state, &notification);
+}
+
+void remove_objects(PlasmaStoreState *plasma_state,
+                    int64_t num_objects_to_evict,
+                    ObjectID *objects_to_evict) {
+  if (num_objects_to_evict > 0) {
+    for (int i = 0; i < num_objects_to_evict; ++i) {
+      delete_object(plasma_state, objects_to_evict[i]);
+    }
+    /* Free the array of objects to evict. This array was originally allocated
+     * by the eviction policy. */
+    free(objects_to_evict);
+  }
+}
+
+void push_notification(PlasmaStoreState *plasma_state,
+                       ObjectInfoT *object_info) {
+  NotificationQueue *queue, *temp_queue;
+  HASH_ITER(hh, plasma_state->pending_notifications, queue, temp_queue) {
+    uint8_t *notification = create_object_info_buffer(object_info);
+    utarray_push_back(queue->object_notifications, &notification);
+    send_notifications(plasma_state->loop, queue->subscriber_fd, plasma_state,
+                       0);
+    /* The notification gets freed in send_notifications when the notification
+     * is sent over the socket. */
+  }
+}
+
+/* Send more notifications to a subscriber. */
+void send_notifications(event_loop *loop,
+                        int client_sock,
+                        void *context,
+                        int events) {
+  PlasmaStoreState *plasma_state = (PlasmaStoreState *) context;
+  NotificationQueue *queue;
+  HASH_FIND_INT(plasma_state->pending_notifications, &client_sock, queue);
+  CHECK(queue != NULL);
+
+  int num_processed = 0;
+  bool closed = false;
+  /* Loop over the array of pending notifications and send as many of them as
+   * possible. */
+  for (int i = 0; i < utarray_len(queue->object_notifications); ++i) {
+    uint8_t **notification =
+        (uint8_t **) utarray_eltptr(queue->object_notifications, i);
+    uint8_t *data = *notification;
+    /* Decode the length, which is the first bytes of the message. */
+    int64_t size = *((int64_t *) data);
+
+    /* Attempt to send a notification about this object ID. */
+    int nbytes = send(client_sock, data, sizeof(int64_t) + size, 0);
+    if (nbytes >= 0) {
+      CHECK(nbytes == sizeof(int64_t) + size);
+    } else if (nbytes == -1 &&
+               (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)) {
+      ARROW_LOG(INFO) <<
+          "The socket's send buffer is full, so we are caching this "
+          "notification and will send it later.";
+      /* Add a callback to the event loop to send queued notifications whenever
+       * there is room in the socket's send buffer. Callbacks can be added
+       * more than once here and will be overwritten. The callback is removed
+       * at the end of the method. */
+      event_loop_add_file(plasma_state->loop, client_sock, EVENT_LOOP_WRITE,
+                          send_notifications, plasma_state);
+      break;
+    } else {
+      ARROW_LOG(WARNING) << "Failed to send notification to client on fd " << client_sock;
+      if (errno == EPIPE) {
+        closed = true;
+        break;
+      }
+    }
+    num_processed += 1;
+    /* The corresponding malloc happened in create_object_info_buffer
+     * within push_notification. */
+    free(data);
+  }
+  /* Remove the sent notifications from the array. */
+  utarray_erase(queue->object_notifications, 0, num_processed);
+
+  /* Stop sending notifications if the pipe was broken. */
+  if (closed) {
+    close(client_sock);
+    utarray_free(queue->object_notifications);
+    HASH_DEL(plasma_state->pending_notifications, queue);
+    free(queue);
+  }
+
+  /* If we have sent all notifications, remove the fd from the event loop. */
+  if (utarray_len(queue->object_notifications) == 0) {
+    event_loop_remove_file(loop, client_sock);
+  }
+}
+
+/* Subscribe to notifications about sealed objects. */
+void subscribe_to_updates(Client *client_context, int conn) {
+  ARROW_LOG(INFO) << "subscribing to updates";
+  PlasmaStoreState *plasma_state = client_context->plasma_state;
+  /* TODO(rkn): The store could block here if the client doesn't send a file
+   * descriptor. */
+  int fd = recv_fd(conn);
+  if (fd < 0) {
+    /* This may mean that the client died before sending the file descriptor. */
+    ARROW_LOG(WARNING) << "Failed to receive file descriptor from client on fd " << conn;
+    return;
+  }
+
+  /* Create a new array to buffer notifications that can't be sent to the
+   * subscriber yet because the socket send buffer is full. TODO(rkn): the queue
+   * never gets freed. */
+  NotificationQueue *queue =
+      (NotificationQueue *) malloc(sizeof(NotificationQueue));
+  queue->subscriber_fd = fd;
+  utarray_new(queue->object_notifications, &object_info_icd);
+  HASH_ADD_INT(plasma_state->pending_notifications, subscriber_fd, queue);
+
+  /* Push notifications to the new subscriber about existing objects. */
+  object_table_entry *entry, *temp_entry;
+  HASH_ITER(handle, plasma_state->plasma_store_info->objects, entry,
+            temp_entry) {
+    push_notification(plasma_state, &entry->info);
+  }
+  send_notifications(plasma_state->loop, queue->subscriber_fd, plasma_state, 0);
+}
+
+void process_message(event_loop *loop,
+                     int client_sock,
+                     void *context,
+                     int events) {
+  Client *client_context = (Client *) context;
+  PlasmaStoreState *state = client_context->plasma_state;
+  int64_t type;
+  read_buffer(client_sock, &type, state->input_buffer);
+
+  uint8_t *input = (uint8_t *) utarray_front(state->input_buffer);
+  ObjectID object_ids[1];
+  int64_t num_objects;
+  PlasmaObject objects[1];
+  memset(&objects[0], 0, sizeof(objects));
+
+  /* Process the different types of requests. */
+  switch (type) {
+  case MessageType_PlasmaCreateRequest: {
+    int64_t data_size;
+    int64_t metadata_size;
+    plasma_read_CreateRequest(input, &object_ids[0], &data_size,
+                              &metadata_size);
+    int error_code = create_object(client_context, object_ids[0], data_size,
+                                   metadata_size, &objects[0]);
+    warn_if_sigpipe(
+        plasma_send_CreateReply(client_sock, state->builder, object_ids[0],
+                                &objects[0], error_code),
+        client_sock);
+    if (error_code == PlasmaError_OK) {
+      warn_if_sigpipe(send_fd(client_sock, objects[0].handle.store_fd),
+                      client_sock);
+    }
+  } break;
+  case MessageType_PlasmaGetRequest: {
+    num_objects = plasma_read_GetRequest_num_objects(input);
+    ObjectID *object_ids_to_get =
+        (ObjectID *) malloc(num_objects * sizeof(ObjectID));
+    int64_t timeout_ms;
+    plasma_read_GetRequest(input, object_ids_to_get, &timeout_ms, num_objects);
+    /* TODO(pcm): The array object_ids_to_get could be reused in
+     * process_get_request. */
+    process_get_request(client_context, num_objects, object_ids_to_get,
+                        timeout_ms);
+    free(object_ids_to_get);
+  } break;
+  case MessageType_PlasmaReleaseRequest:
+    plasma_read_ReleaseRequest(input, &object_ids[0]);
+    release_object(client_context, object_ids[0]);
+    break;
+  case MessageType_PlasmaContainsRequest:
+    plasma_read_ContainsRequest(input, &object_ids[0]);
+    if (contains_object(client_context, object_ids[0]) == OBJECT_FOUND) {
+      warn_if_sigpipe(plasma_send_ContainsReply(client_sock, state->builder,
+                                                object_ids[0], 1),
+                      client_sock);
+    } else {
+      warn_if_sigpipe(plasma_send_ContainsReply(client_sock, state->builder,
+                                                object_ids[0], 0),
+                      client_sock);
+    }
+    break;
+  case MessageType_PlasmaSealRequest: {
+    unsigned char digest[DIGEST_SIZE];
+    plasma_read_SealRequest(input, &object_ids[0], &digest[0]);
+    seal_object(client_context, object_ids[0], &digest[0]);
+  } break;
+  case MessageType_PlasmaEvictRequest: {
+    /* This code path should only be used for testing. */
+    int64_t num_bytes;
+    plasma_read_EvictRequest(input, &num_bytes);
+    int64_t num_objects_to_evict;
+    ObjectID *objects_to_evict;
+    int64_t num_bytes_evicted = EvictionState_choose_objects_to_evict(
+        client_context->plasma_state->eviction_state,
+        client_context->plasma_state->plasma_store_info, num_bytes,
+        &num_objects_to_evict, &objects_to_evict);
+    remove_objects(client_context->plasma_state, num_objects_to_evict,
+                   objects_to_evict);
+    warn_if_sigpipe(
+        plasma_send_EvictReply(client_sock, state->builder, num_bytes_evicted),
+        client_sock);
+  } break;
+  case MessageType_PlasmaSubscribeRequest:
+    subscribe_to_updates(client_context, client_sock);
+    break;
+  case MessageType_PlasmaConnectRequest: {
+    warn_if_sigpipe(
+        plasma_send_ConnectReply(client_sock, state->builder,
+                                 state->plasma_store_info->memory_capacity),
+        client_sock);
+  } break;
+  case DISCONNECT_CLIENT: {
+    ARROW_LOG(INFO) << "Disconnecting client on fd " << client_sock;
+    event_loop_remove_file(loop, client_sock);
+    /* If this client was using any objects, remove it from the appropriate
+     * lists. */
+    PlasmaStoreState *plasma_state = client_context->plasma_state;
+    object_table_entry *entry, *temp_entry;
+    HASH_ITER(handle, plasma_state->plasma_store_info->objects, entry,
+              temp_entry) {
+      remove_client_from_object_clients(entry, client_context);
+    }
+    /* Note, the store may still attempt to send a message to the disconnected
+     * client (for example, when an object ID that the client was waiting for
+     * is ready). In these cases, the attempt to send the message will fail, but
+     * the store should just ignore the failure. */
+  } break;
+  default:
+    /* This code should be unreachable. */
+    CHECK(0);
+  }
+}
+
+void new_client_connection(event_loop *loop,
+                           int listener_sock,
+                           void *context,
+                           int events) {
+  PlasmaStoreState *plasma_state = (PlasmaStoreState *) context;
+  int new_socket = accept_client(listener_sock);
+  /* Create a new client object. This will also be used as the context to use
+   * for events on this client's socket. TODO(rkn): free this somewhere. */
+  Client *client_context = (Client *) malloc(sizeof(Client));
+  client_context->sock = new_socket;
+  client_context->plasma_state = plasma_state;
+  /* Add a callback to handle events on this socket. */
+  event_loop_add_file(loop, new_socket, EVENT_LOOP_READ, process_message,
+                      client_context);
+  ARROW_LOG(INFO) << "new connection with fd " << new_socket;
+}
+
+/* Report "success" to valgrind. */
+void signal_handler(int signal) {
+  if (signal == SIGTERM) {
+    PlasmaStoreState_free(g_state);
+    exit(0);
+  }
+}
+
+void start_server(char *socket_name, int64_t system_memory) {
+  /* Ignore SIGPIPE signals. If we don't do this, then when we attempt to write
+   * to a client that has already died, the store could die. */
+  signal(SIGPIPE, SIG_IGN);
+  /* Create the event loop. */
+  event_loop *loop = event_loop_create();
+  PlasmaStoreState *state = PlasmaStoreState_init(loop, system_memory);
+  int socket = bind_ipc_sock(socket_name, true);
+  CHECK(socket >= 0);
+  event_loop_add_file(loop, socket, EVENT_LOOP_READ, new_client_connection,
+                      state);
+  g_state = state;
+  event_loop_run(loop);
+}
+
+int main(int argc, char *argv[]) {
+  signal(SIGTERM, signal_handler);
+  char *socket_name = NULL;
+  int64_t system_memory = -1;
+  int c;
+  while ((c = getopt(argc, argv, "s:m:")) != -1) {
+    switch (c) {
+    case 's':
+      socket_name = optarg;
+      break;
+    case 'm': {
+      char extra;
+      int scanned = sscanf(optarg, "%" SCNd64 "%c", &system_memory, &extra);
+      CHECK(scanned == 1);
+      ARROW_LOG(INFO) << "Allowing the Plasma store to use up to " << ((double) system_memory) / 1000000000 << "GB of memory";
+      break;
+    }
+    default:
+      exit(-1);
+    }
+  }
+  if (!socket_name) {
+    ARROW_LOG(FATAL) << "please specify socket for incoming connections with -s switch";
+  }
+  if (system_memory == -1) {
+    ARROW_LOG(FATAL) << "please specify the amount of system memory with -m switch";
+  }
+#ifdef __linux__
+  /* On Linux, check that the amount of memory available in /dev/shm is large
+   * enough to accommodate the request. If it isn't, then fail. */
+  int shm_fd = open("/dev/shm", O_RDONLY);
+  struct statvfs shm_vfs_stats;
+  fstatvfs(shm_fd, &shm_vfs_stats);
+  /* The value shm_vfs_stats.f_bsize is the block size, and the value
+   * shm_vfs_stats.f_bavail is the number of available blocks. */
+  int64_t shm_mem_avail = shm_vfs_stats.f_bsize * shm_vfs_stats.f_bavail;
+  close(shm_fd);
+  if (system_memory > shm_mem_avail) {
+    ARROW_LOG(FATAL) <<
+        "System memory request exceeds memory available in /dev/shm. The "
+        "request is for " << system_memory << " bytes, and the amount available is " << shm_mem_avail <<
+        " bytes. You may be able to free up space by deleting files in "
+        "/dev/shm. If you are inside a Docker container, you may need to pass "
+        "an argument with the flag '--shm-size' to 'docker run'.";
+  }
+#endif
+  ARROW_LOG(INFO) << "starting server listening on " << socket_name;
+  start_server(socket_name, system_memory);
+}
diff --git a/cpp/src/plasma/plasma_store.h b/cpp/src/plasma/plasma_store.h
new file mode 100644
index 000000000000..cd1717649562
--- /dev/null
+++ b/cpp/src/plasma/plasma_store.h
@@ -0,0 +1,103 @@
+#ifndef PLASMA_STORE_H
+#define PLASMA_STORE_H
+
+#include "plasma.h"
+
+typedef struct Client Client;
+
+typedef struct PlasmaStoreState PlasmaStoreState;
+
+/**
+ * Create a new object. The client must do a call to release_object to tell the
+ * store when it is done with the object.
+ *
+ * @param client_context The context of the client making this request.
+ * @param object_id Object ID of the object to be created.
+ * @param data_size Size in bytes of the object to be created.
+ * @param metadata_size Size in bytes of the object metadata.
+ * @return One of the following error codes:
+ *         - PlasmaError_OK, if the object was created successfully.
+ *         - PlasmaError_ObjectExists, if an object with this ID is already
+ *           present in the store. In this case, the client should not call
+ *           plasma_release.
+ *         - PlasmaError_OutOfMemory, if the store is out of memory and cannot
+ *           create the object. In this case, the client should not call
+ *           plasma_release.
+ */
+int create_object(Client *client_context,
+                  ObjectID object_id,
+                  int64_t data_size,
+                  int64_t metadata_size,
+                  PlasmaObject *result);
+
+/**
+ * Get an object. This method assumes that we currently have or will eventually
+ * have this object sealed. If the object has not yet been sealed, the client
+ * that requested the object will be notified when it is sealed.
+ *
+ * For each call to get_object, the client must do a call to release_object to
+ * tell the store when it is done with the object.
+ *
+ * @param client_context The context of the client making this request.
+ * @param conn The client connection that requests the object.
+ * @param object_id Object ID of the object to be gotten.
+ * @return The status of the object (object_status in plasma.h).
+ */
+int get_object(Client *client_context,
+               int conn,
+               ObjectID object_id,
+               PlasmaObject *result);
+
+/**
+ * Record the fact that a particular client is no longer using an object.
+ *
+ * @param client_context The context of the client making this request.
+ * @param object_id The object ID of the object that is being released.
+ * @param Void.
+ */
+void release_object(Client *client_context, ObjectID object_id);
+
+/**
+ * Seal an object. The object is now immutable and can be accessed with get.
+ *
+ * @param client_context The context of the client making this request.
+ * @param object_id Object ID of the object to be sealed.
+ * @param digest The digest of the object. This is used to tell if two objects
+ *        with the same object ID are the same.
+ * @return Void.
+ */
+void seal_object(Client *client_context,
+                 ObjectID object_id,
+                 unsigned char digest[]);
+
+/**
+ * Check if the plasma store contains an object:
+ *
+ * @param client_context The context of the client making this request.
+ * @param object_id Object ID that will be checked.
+ * @return OBJECT_FOUND if the object is in the store, OBJECT_NOT_FOUND if not
+ */
+int contains_object(Client *client_context, ObjectID object_id);
+
+/**
+ * Send notifications about sealed objects to the subscribers. This is called
+ * in seal_object. If the socket's send buffer is full, the notification will be
+ * buffered, and this will be called again when the send buffer has room.
+ *
+ * @param loop The Plasma store event loop.
+ * @param client_sock The socket of the client to send the notification to.
+ * @param plasma_state The plasma store global state.
+ * @param events This is needed for this function to have the signature of a
+          callback.
+ * @return Void.
+ */
+void send_notifications(event_loop *loop,
+                        int client_sock,
+                        void *plasma_state,
+                        int events);
+
+void remove_objects(PlasmaStoreState *plasma_state,
+                    int64_t num_objects_to_evict,
+                    ObjectID *objects_to_evict);
+
+#endif /* PLASMA_STORE_H */
diff --git a/cpp/src/plasma/setup-env.sh b/cpp/src/plasma/setup-env.sh
new file mode 100644
index 000000000000..a1b2cb4b1a59
--- /dev/null
+++ b/cpp/src/plasma/setup-env.sh
@@ -0,0 +1,5 @@
+echo "Adding Plasma to PYTHONPATH" 1>&2
+
+ROOT_DIR=$(cd "$(dirname "${BASH_SOURCE:-$0}")"; pwd)
+
+export PYTHONPATH="$ROOT_DIR/lib/python/:$PYTHONPATH"
diff --git a/cpp/src/plasma/setup.py b/cpp/src/plasma/setup.py
new file mode 100644
index 000000000000..1df0d4b00431
--- /dev/null
+++ b/cpp/src/plasma/setup.py
@@ -0,0 +1,34 @@
+from __future__ import absolute_import
+from __future__ import division
+from __future__ import print_function
+
+from setuptools import setup, find_packages
+import setuptools.command.install as _install
+
+import subprocess
+
+
+class install(_install.install):
+  def run(self):
+    subprocess.check_call(["make"])
+    subprocess.check_call(["cp", "build/plasma_store", "plasma/plasma_store"])
+    subprocess.check_call(["cp", "build/plasma_manager",
+                           "plasma/plasma_manager"])
+    subprocess.check_call(["cmake", ".."], cwd="./build")
+    subprocess.check_call(["make", "install"], cwd="./build")
+    # Calling _install.install.run(self) does not fetch required packages and
+    # instead performs an old-style install. See command/install.py in
+    # setuptools. So, calling do_egg_install() manually here.
+    self.do_egg_install()
+
+
+setup(name="Plasma",
+      version="0.0.1",
+      description="Plasma client for Python",
+      packages=find_packages(),
+      package_data={"plasma": ["plasma_store",
+                               "plasma_manager",
+                               "libplasma.so"]},
+      cmdclass={"install": install},
+      include_package_data=True,
+      zip_safe=False)
diff --git a/cpp/src/plasma/test/client_tests.cc b/cpp/src/plasma/test/client_tests.cc
new file mode 100644
index 000000000000..dd939f248c29
--- /dev/null
+++ b/cpp/src/plasma/test/client_tests.cc
@@ -0,0 +1,311 @@
+#include "greatest.h"
+
+#include <assert.h>
+#include <unistd.h>
+#include <sys/time.h>
+
+#include "plasma.h"
+#include "plasma_protocol.h"
+#include "plasma_client.h"
+
+SUITE(plasma_client_tests);
+
+TEST plasma_status_tests(void) {
+  PlasmaConnection *plasma_conn1 = plasma_connect(
+      "/tmp/store1", "/tmp/manager1", PLASMA_DEFAULT_RELEASE_DELAY);
+  PlasmaConnection *plasma_conn2 = plasma_connect(
+      "/tmp/store2", "/tmp/manager2", PLASMA_DEFAULT_RELEASE_DELAY);
+  ObjectID oid1 = globally_unique_id();
+
+  /* Test for object non-existence. */
+  int status = plasma_status(plasma_conn1, oid1);
+  ASSERT(status == ObjectStatus_Nonexistent);
+
+  /* Test for the object being in local Plasma store. */
+  /* First create object. */
+  int64_t data_size = 100;
+  uint8_t metadata[] = {5};
+  int64_t metadata_size = sizeof(metadata);
+  uint8_t *data;
+  plasma_create(plasma_conn1, oid1, data_size, metadata, metadata_size, &data);
+  plasma_seal(plasma_conn1, oid1);
+  /* Sleep to avoid race condition of Plasma Manager waiting for notification.
+   */
+  sleep(1);
+  status = plasma_status(plasma_conn1, oid1);
+  ASSERT(status == ObjectStatus_Local);
+
+  /* Test for object being remote. */
+  status = plasma_status(plasma_conn2, oid1);
+  ASSERT(status == ObjectStatus_Remote);
+
+  plasma_disconnect(plasma_conn1);
+  plasma_disconnect(plasma_conn2);
+
+  PASS();
+}
+
+TEST plasma_fetch_tests(void) {
+  PlasmaConnection *plasma_conn1 = plasma_connect(
+      "/tmp/store1", "/tmp/manager1", PLASMA_DEFAULT_RELEASE_DELAY);
+  PlasmaConnection *plasma_conn2 = plasma_connect(
+      "/tmp/store2", "/tmp/manager2", PLASMA_DEFAULT_RELEASE_DELAY);
+  ObjectID oid1 = globally_unique_id();
+
+  /* Test for object non-existence. */
+  int status;
+
+  /* No object in the system */
+  status = plasma_status(plasma_conn1, oid1);
+  ASSERT(status == ObjectStatus_Nonexistent);
+
+  /* Test for the object being in local Plasma store. */
+  /* First create object. */
+  int64_t data_size = 100;
+  uint8_t metadata[] = {5};
+  int64_t metadata_size = sizeof(metadata);
+  uint8_t *data;
+  plasma_create(plasma_conn1, oid1, data_size, metadata, metadata_size, &data);
+  plasma_seal(plasma_conn1, oid1);
+
+  /* Object with ID oid1 has been just inserted. On the next fetch we might
+   * either find the object or not, depending on whether the Plasma Manager has
+   * received the notification from the Plasma Store or not. */
+  ObjectID oid_array1[1] = {oid1};
+  plasma_fetch(plasma_conn1, 1, oid_array1);
+  status = plasma_status(plasma_conn1, oid1);
+  ASSERT((status == ObjectStatus_Local) ||
+         (status == ObjectStatus_Nonexistent));
+
+  /* Sleep to make sure Plasma Manager got the notification. */
+  sleep(1);
+  status = plasma_status(plasma_conn1, oid1);
+  ASSERT(status == ObjectStatus_Local);
+
+  /* Test for object being remote. */
+  status = plasma_status(plasma_conn2, oid1);
+  ASSERT(status == ObjectStatus_Remote);
+
+  /* Sleep to make sure the object has been fetched and it is now stored in the
+   * local Plasma Store. */
+  plasma_fetch(plasma_conn2, 1, oid_array1);
+  sleep(1);
+  status = plasma_status(plasma_conn2, oid1);
+  ASSERT(status == ObjectStatus_Local);
+
+  sleep(1);
+  plasma_disconnect(plasma_conn1);
+  plasma_disconnect(plasma_conn2);
+
+  PASS();
+}
+
+void init_data_123(uint8_t *data, uint64_t size, uint8_t base) {
+  for (int i = 0; i < size; i++) {
+    data[i] = base + i;
+  }
+}
+
+bool is_equal_data_123(uint8_t *data1, uint8_t *data2, uint64_t size) {
+  for (int i = 0; i < size; i++) {
+    if (data1[i] != data2[i]) {
+      return false;
+    };
+  }
+  return true;
+}
+
+TEST plasma_nonblocking_get_tests(void) {
+  PlasmaConnection *plasma_conn = plasma_connect("/tmp/store1", "/tmp/manager1",
+                                                 PLASMA_DEFAULT_RELEASE_DELAY);
+  ObjectID oid = globally_unique_id();
+  ObjectID oid_array[1] = {oid};
+  ObjectBuffer obj_buffer;
+
+  /* Test for object non-existence. */
+  plasma_get(plasma_conn, oid_array, 1, 0, &obj_buffer);
+  ASSERT(obj_buffer.data_size == -1);
+
+  /* Test for the object being in local Plasma store. */
+  /* First create object. */
+  int64_t data_size = 4;
+  uint8_t metadata[] = {5};
+  int64_t metadata_size = sizeof(metadata);
+  uint8_t *data;
+  plasma_create(plasma_conn, oid, data_size, metadata, metadata_size, &data);
+  init_data_123(data, data_size, 0);
+  plasma_seal(plasma_conn, oid);
+
+  sleep(1);
+  plasma_get(plasma_conn, oid_array, 1, 0, &obj_buffer);
+  ASSERT(is_equal_data_123(data, obj_buffer.data, data_size) == true);
+
+  sleep(1);
+  plasma_disconnect(plasma_conn);
+
+  PASS();
+}
+
+TEST plasma_wait_for_objects_tests(void) {
+  PlasmaConnection *plasma_conn1 = plasma_connect(
+      "/tmp/store1", "/tmp/manager1", PLASMA_DEFAULT_RELEASE_DELAY);
+  PlasmaConnection *plasma_conn2 = plasma_connect(
+      "/tmp/store2", "/tmp/manager2", PLASMA_DEFAULT_RELEASE_DELAY);
+  ObjectID oid1 = globally_unique_id();
+  ObjectID oid2 = globally_unique_id();
+#define NUM_OBJ_REQUEST 2
+#define WAIT_TIMEOUT_MS 1000
+  ObjectRequest obj_requests[NUM_OBJ_REQUEST];
+
+  obj_requests[0].object_id = oid1;
+  obj_requests[0].type = PLASMA_QUERY_ANYWHERE;
+  obj_requests[1].object_id = oid2;
+  obj_requests[1].type = PLASMA_QUERY_ANYWHERE;
+
+  struct timeval start, end;
+  gettimeofday(&start, NULL);
+  int n = plasma_wait(plasma_conn1, NUM_OBJ_REQUEST, obj_requests,
+                      NUM_OBJ_REQUEST, WAIT_TIMEOUT_MS);
+  ASSERT(n == 0);
+  gettimeofday(&end, NULL);
+  float diff_ms = (end.tv_sec - start.tv_sec);
+  diff_ms = (((diff_ms * 1000000.) + end.tv_usec) - (start.tv_usec)) / 1000.;
+  /* Reduce threshold by 10% to make sure we pass consistently. */
+  ASSERT(diff_ms > WAIT_TIMEOUT_MS * 0.9);
+
+  /* Create and insert an object in plasma_conn1. */
+  int64_t data_size = 4;
+  uint8_t metadata[] = {5};
+  int64_t metadata_size = sizeof(metadata);
+  uint8_t *data;
+  plasma_create(plasma_conn1, oid1, data_size, metadata, metadata_size, &data);
+  plasma_seal(plasma_conn1, oid1);
+
+  n = plasma_wait(plasma_conn1, NUM_OBJ_REQUEST, obj_requests, NUM_OBJ_REQUEST,
+                  WAIT_TIMEOUT_MS);
+  ASSERT(n == 1);
+
+  /* Create and insert an object in plasma_conn2. */
+  plasma_create(plasma_conn2, oid2, data_size, metadata, metadata_size, &data);
+  plasma_seal(plasma_conn2, oid2);
+
+  n = plasma_wait(plasma_conn1, NUM_OBJ_REQUEST, obj_requests, NUM_OBJ_REQUEST,
+                  WAIT_TIMEOUT_MS);
+  ASSERT(n == 2);
+
+  n = plasma_wait(plasma_conn2, NUM_OBJ_REQUEST, obj_requests, NUM_OBJ_REQUEST,
+                  WAIT_TIMEOUT_MS);
+  ASSERT(n == 2);
+
+  obj_requests[0].type = PLASMA_QUERY_LOCAL;
+  obj_requests[1].type = PLASMA_QUERY_LOCAL;
+  n = plasma_wait(plasma_conn1, NUM_OBJ_REQUEST, obj_requests, NUM_OBJ_REQUEST,
+                  WAIT_TIMEOUT_MS);
+  ASSERT(n == 1);
+
+  n = plasma_wait(plasma_conn2, NUM_OBJ_REQUEST, obj_requests, NUM_OBJ_REQUEST,
+                  WAIT_TIMEOUT_MS);
+  ASSERT(n == 1);
+
+  plasma_disconnect(plasma_conn1);
+  plasma_disconnect(plasma_conn2);
+
+  PASS();
+}
+
+TEST plasma_get_tests(void) {
+  PlasmaConnection *plasma_conn1 = plasma_connect(
+      "/tmp/store1", "/tmp/manager1", PLASMA_DEFAULT_RELEASE_DELAY);
+  PlasmaConnection *plasma_conn2 = plasma_connect(
+      "/tmp/store2", "/tmp/manager2", PLASMA_DEFAULT_RELEASE_DELAY);
+  ObjectID oid1 = globally_unique_id();
+  ObjectID oid2 = globally_unique_id();
+  ObjectBuffer obj_buffer;
+
+  ObjectID oid_array1[1] = {oid1};
+  ObjectID oid_array2[1] = {oid2};
+
+  int64_t data_size = 4;
+  uint8_t metadata[] = {5};
+  int64_t metadata_size = sizeof(metadata);
+  uint8_t *data;
+  plasma_create(plasma_conn1, oid1, data_size, metadata, metadata_size, &data);
+  init_data_123(data, data_size, 1);
+  plasma_seal(plasma_conn1, oid1);
+
+  plasma_get(plasma_conn1, oid_array1, 1, -1, &obj_buffer);
+  ASSERT(data[0] == obj_buffer.data[0]);
+
+  plasma_create(plasma_conn2, oid2, data_size, metadata, metadata_size, &data);
+  init_data_123(data, data_size, 2);
+  plasma_seal(plasma_conn2, oid2);
+
+  plasma_fetch(plasma_conn1, 1, oid_array2);
+  plasma_get(plasma_conn1, oid_array2, 1, -1, &obj_buffer);
+  ASSERT(data[0] == obj_buffer.data[0]);
+
+  sleep(1);
+  plasma_disconnect(plasma_conn1);
+  plasma_disconnect(plasma_conn2);
+
+  PASS();
+}
+
+TEST plasma_get_multiple_tests(void) {
+  PlasmaConnection *plasma_conn1 = plasma_connect(
+      "/tmp/store1", "/tmp/manager1", PLASMA_DEFAULT_RELEASE_DELAY);
+  PlasmaConnection *plasma_conn2 = plasma_connect(
+      "/tmp/store2", "/tmp/manager2", PLASMA_DEFAULT_RELEASE_DELAY);
+  ObjectID oid1 = globally_unique_id();
+  ObjectID oid2 = globally_unique_id();
+  ObjectID obj_ids[NUM_OBJ_REQUEST];
+  ObjectBuffer obj_buffer[NUM_OBJ_REQUEST];
+  int obj1_first = 1, obj2_first = 2;
+
+  obj_ids[0] = oid1;
+  obj_ids[1] = oid2;
+
+  int64_t data_size = 4;
+  uint8_t metadata[] = {5};
+  int64_t metadata_size = sizeof(metadata);
+  uint8_t *data;
+  plasma_create(plasma_conn1, oid1, data_size, metadata, metadata_size, &data);
+  init_data_123(data, data_size, obj1_first);
+  plasma_seal(plasma_conn1, oid1);
+
+  /* This only waits for oid1. */
+  plasma_get(plasma_conn1, obj_ids, 1, -1, obj_buffer);
+  ASSERT(data[0] == obj_buffer[0].data[0]);
+
+  plasma_create(plasma_conn2, oid2, data_size, metadata, metadata_size, &data);
+  init_data_123(data, data_size, obj2_first);
+  plasma_seal(plasma_conn2, oid2);
+
+  plasma_fetch(plasma_conn1, 2, obj_ids);
+  plasma_get(plasma_conn1, obj_ids, 2, -1, obj_buffer);
+  ASSERT(obj1_first == obj_buffer[0].data[0]);
+  ASSERT(obj2_first == obj_buffer[1].data[0]);
+
+  sleep(1);
+  plasma_disconnect(plasma_conn1);
+  plasma_disconnect(plasma_conn2);
+
+  PASS();
+}
+
+SUITE(plasma_client_tests) {
+  RUN_TEST(plasma_status_tests);
+  RUN_TEST(plasma_fetch_tests);
+  RUN_TEST(plasma_nonblocking_get_tests);
+  RUN_TEST(plasma_wait_for_objects_tests);
+  RUN_TEST(plasma_get_tests);
+  RUN_TEST(plasma_get_multiple_tests);
+}
+
+GREATEST_MAIN_DEFS();
+
+int main(int argc, char **argv) {
+  GREATEST_MAIN_BEGIN();
+  RUN_SUITE(plasma_client_tests);
+  GREATEST_MAIN_END();
+}
diff --git a/cpp/src/plasma/test/run_tests.sh b/cpp/src/plasma/test/run_tests.sh
new file mode 100644
index 000000000000..eb66bec78b1c
--- /dev/null
+++ b/cpp/src/plasma/test/run_tests.sh
@@ -0,0 +1,35 @@
+#!/usr/bin/env bash
+
+# Cause the script to exit if a single command fails.
+set -e
+
+./src/plasma/plasma_store -s /tmp/plasma_store_socket_1 -m 0 &
+sleep 1
+./src/plasma/manager_tests
+killall plasma_store
+./src/plasma/serialization_tests
+
+./src/common/thirdparty/redis/src/redis-server --loglevel warning --loadmodule ./src/common/redis_module/libray_redis_module.so &
+redis_pid=$!
+sleep 1
+# flush the redis server
+../common/thirdparty/redis/src/redis-cli flushall &
+sleep 1
+./src/plasma/plasma_store -s /tmp/store1 -m 1000000000 &
+plasma1_pid=$!
+./src/plasma/plasma_manager -m /tmp/manager1 -s /tmp/store1 -h 127.0.0.1 -p 11111 -r 127.0.0.1:6379 &
+plasma2_pid=$!
+./src/plasma/plasma_store -s /tmp/store2 -m 1000000000 &
+plasma3_pid=$!
+./src/plasma/plasma_manager -m /tmp/manager2 -s /tmp/store2 -h 127.0.0.1 -p 22222 -r 127.0.0.1:6379 &
+plasma4_pid=$!
+sleep 1
+
+./src/plasma/client_tests
+
+kill $plasma4_pid
+kill $plasma3_pid
+kill $plasma2_pid
+kill $plasma1_pid
+kill $redis_pid
+wait $redis_pid
diff --git a/cpp/src/plasma/test/run_valgrind.sh b/cpp/src/plasma/test/run_valgrind.sh
new file mode 100644
index 000000000000..74531e72161d
--- /dev/null
+++ b/cpp/src/plasma/test/run_valgrind.sh
@@ -0,0 +1,10 @@
+#!/usr/bin/env bash
+
+# Cause the script to exit if a single command fails.
+set -e
+
+./src/plasma/plasma_store -s /tmp/plasma_store_socket_1 -m 0 &
+sleep 1
+valgrind --leak-check=full --error-exitcode=1 ./src/plasma/manager_tests
+killall plasma_store
+valgrind --leak-check=full --error-exitcode=1 ./src/plasma/serialization_tests
diff --git a/cpp/src/plasma/test/serialization_tests.cc b/cpp/src/plasma/test/serialization_tests.cc
new file mode 100644
index 000000000000..3bc74c77df58
--- /dev/null
+++ b/cpp/src/plasma/test/serialization_tests.cc
@@ -0,0 +1,442 @@
+#include "greatest.h"
+
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "plasma.h"
+#include "plasma_protocol.h"
+#include "common.h"
+#include "io.h"
+#include "../plasma.h"
+
+SUITE(plasma_serialization_tests);
+
+protocol_builder *g_B;
+
+/**
+ * Create a temporary file. Needs to be closed by the caller.
+ *
+ * @return File descriptor of the file.
+ */
+int create_temp_file(void) {
+  static char temp[] = "/tmp/tempfileXXXXXX";
+  char file_name[32];
+  strncpy(file_name, temp, 32);
+  return mkstemp(file_name);
+}
+
+/**
+ * Seek to the beginning of a file and read a message from it.
+ *
+ * @param fd File descriptor of the file.
+ * @param message type Message type that we expect in the file.
+ *
+ * @return Pointer to the content of the message. Needs to be freed by the
+ * caller.
+ */
+uint8_t *read_message_from_file(int fd, int message_type) {
+  /* Go to the beginning of the file. */
+  lseek(fd, 0, SEEK_SET);
+  int64_t type;
+  int64_t length;
+  uint8_t *data;
+  read_message(fd, &type, &length, &data);
+  CHECK(type == message_type);
+  return data;
+}
+
+PlasmaObject random_plasma_object(void) {
+  int random = rand();
+  PlasmaObject object;
+  memset(&object, 0, sizeof(object));
+  object.handle.store_fd = random + 7;
+  object.handle.mmap_size = random + 42;
+  object.data_offset = random + 1;
+  object.metadata_offset = random + 2;
+  object.data_size = random + 3;
+  object.metadata_size = random + 4;
+  return object;
+}
+
+TEST plasma_create_request_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_id1 = globally_unique_id();
+  int64_t data_size1 = 42;
+  int64_t metadata_size1 = 11;
+  plasma_send_CreateRequest(fd, g_B, object_id1, data_size1, metadata_size1);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaCreateRequest);
+  ObjectID object_id2;
+  int64_t data_size2;
+  int64_t metadata_size2;
+  plasma_read_CreateRequest(data, &object_id2, &data_size2, &metadata_size2);
+  ASSERT_EQ(data_size1, data_size2);
+  ASSERT_EQ(metadata_size1, metadata_size2);
+  ASSERT(ObjectID_equal(object_id1, object_id2));
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_create_reply_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_id1 = globally_unique_id();
+  PlasmaObject object1 = random_plasma_object();
+  plasma_send_CreateReply(fd, g_B, object_id1, &object1, 0);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaCreateReply);
+  ObjectID object_id2;
+  PlasmaObject object2;
+  memset(&object2, 0, sizeof(object2));
+  int error_code;
+  plasma_read_CreateReply(data, &object_id2, &object2, &error_code);
+  ASSERT(ObjectID_equal(object_id1, object_id2));
+  ASSERT(memcmp(&object1, &object2, sizeof(object1)) == 0);
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_seal_request_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_id1 = globally_unique_id();
+  unsigned char digest1[DIGEST_SIZE];
+  memset(&digest1[0], 7, DIGEST_SIZE);
+  plasma_send_SealRequest(fd, g_B, object_id1, &digest1[0]);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaSealRequest);
+  ObjectID object_id2;
+  unsigned char digest2[DIGEST_SIZE];
+  plasma_read_SealRequest(data, &object_id2, &digest2[0]);
+  ASSERT(ObjectID_equal(object_id1, object_id2));
+  ASSERT(memcmp(&digest1[0], &digest2[0], DIGEST_SIZE) == 0);
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_seal_reply_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_id1 = globally_unique_id();
+  int error1 = 5;
+  plasma_send_SealReply(fd, g_B, object_id1, error1);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaSealReply);
+  ObjectID object_id2;
+  int error2;
+  plasma_read_SealReply(data, &object_id2, &error2);
+  ASSERT(ObjectID_equal(object_id1, object_id2));
+  ASSERT(error1 == error2);
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_get_request_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_ids[2];
+  object_ids[0] = globally_unique_id();
+  object_ids[1] = globally_unique_id();
+  int64_t timeout_ms = 1234;
+  plasma_send_GetRequest(fd, g_B, object_ids, 2, timeout_ms);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaGetRequest);
+  ObjectID object_ids_return[2];
+  int64_t timeout_ms_return;
+  plasma_read_GetRequest(data, &object_ids_return[0], &timeout_ms_return, 2);
+  ASSERT(ObjectID_equal(object_ids[0], object_ids_return[0]));
+  ASSERT(ObjectID_equal(object_ids[1], object_ids_return[1]));
+  ASSERT(timeout_ms == timeout_ms_return);
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_get_reply_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_ids[2];
+  object_ids[0] = globally_unique_id();
+  object_ids[1] = globally_unique_id();
+  PlasmaObject plasma_objects[2];
+  plasma_objects[0] = random_plasma_object();
+  plasma_objects[1] = random_plasma_object();
+  plasma_send_GetReply(fd, g_B, object_ids, plasma_objects, 2);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaGetReply);
+  int64_t num_objects = plasma_read_GetRequest_num_objects(data);
+  ObjectID object_ids_return[num_objects];
+  PlasmaObject plasma_objects_return[2];
+  memset(&plasma_objects_return, 0, sizeof(plasma_objects_return));
+  plasma_read_GetReply(data, object_ids_return, &plasma_objects_return[0],
+                       num_objects);
+  ASSERT(ObjectID_equal(object_ids[0], object_ids_return[0]));
+  ASSERT(ObjectID_equal(object_ids[1], object_ids_return[1]));
+  ASSERT(memcmp(&plasma_objects[0], &plasma_objects_return[0],
+                sizeof(PlasmaObject)) == 0);
+  ASSERT(memcmp(&plasma_objects[1], &plasma_objects_return[1],
+                sizeof(PlasmaObject)) == 0);
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_release_request_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_id1 = globally_unique_id();
+  plasma_send_ReleaseRequest(fd, g_B, object_id1);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaReleaseRequest);
+  ObjectID object_id2;
+  plasma_read_ReleaseRequest(data, &object_id2);
+  ASSERT(ObjectID_equal(object_id1, object_id2));
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_release_reply_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_id1 = globally_unique_id();
+  int error1 = 5;
+  plasma_send_ReleaseReply(fd, g_B, object_id1, error1);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaReleaseReply);
+  ObjectID object_id2;
+  int error2;
+  plasma_read_ReleaseReply(data, &object_id2, &error2);
+  ASSERT(ObjectID_equal(object_id1, object_id2));
+  ASSERT(error1 == error2);
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_delete_request_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_id1 = globally_unique_id();
+  plasma_send_DeleteRequest(fd, g_B, object_id1);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaDeleteRequest);
+  ObjectID object_id2;
+  plasma_read_DeleteRequest(data, &object_id2);
+  ASSERT(ObjectID_equal(object_id1, object_id2));
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_delete_reply_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_id1 = globally_unique_id();
+  int error1 = 5;
+  plasma_send_DeleteReply(fd, g_B, object_id1, error1);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaDeleteReply);
+  ObjectID object_id2;
+  int error2;
+  plasma_read_DeleteReply(data, &object_id2, &error2);
+  ASSERT(ObjectID_equal(object_id1, object_id2));
+  ASSERT(error1 == error2);
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_status_request_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_ids[2];
+  object_ids[0] = globally_unique_id();
+  object_ids[1] = globally_unique_id();
+  plasma_send_StatusRequest(fd, g_B, object_ids, 2);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaStatusRequest);
+  int64_t num_objects = plasma_read_StatusRequest_num_objects(data);
+  ObjectID object_ids_read[num_objects];
+  plasma_read_StatusRequest(data, object_ids_read, num_objects);
+  ASSERT(ObjectID_equal(object_ids[0], object_ids_read[0]));
+  ASSERT(ObjectID_equal(object_ids[1], object_ids_read[1]));
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_status_reply_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_ids[2];
+  object_ids[0] = globally_unique_id();
+  object_ids[1] = globally_unique_id();
+  int object_statuses[2] = {42, 43};
+  plasma_send_StatusReply(fd, g_B, object_ids, object_statuses, 2);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaStatusReply);
+  int64_t num_objects = plasma_read_StatusReply_num_objects(data);
+  ObjectID object_ids_read[num_objects];
+  int object_statuses_read[num_objects];
+  plasma_read_StatusReply(data, object_ids_read, object_statuses_read,
+                          num_objects);
+  ASSERT(ObjectID_equal(object_ids[0], object_ids_read[0]));
+  ASSERT(ObjectID_equal(object_ids[1], object_ids_read[1]));
+  ASSERT_EQ(object_statuses[0], object_statuses_read[0]);
+  ASSERT_EQ(object_statuses[1], object_statuses_read[1]);
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_evict_request_test(void) {
+  int fd = create_temp_file();
+  int64_t num_bytes = 111;
+  plasma_send_EvictRequest(fd, g_B, num_bytes);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaEvictRequest);
+  int64_t num_bytes_received;
+  plasma_read_EvictRequest(data, &num_bytes_received);
+  ASSERT_EQ(num_bytes, num_bytes_received);
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_evict_reply_test(void) {
+  int fd = create_temp_file();
+  int64_t num_bytes = 111;
+  plasma_send_EvictReply(fd, g_B, num_bytes);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaEvictReply);
+  int64_t num_bytes_received;
+  plasma_read_EvictReply(data, &num_bytes_received);
+  ASSERT_EQ(num_bytes, num_bytes_received);
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_fetch_request_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_ids[2];
+  object_ids[0] = globally_unique_id();
+  object_ids[1] = globally_unique_id();
+  plasma_send_FetchRequest(fd, g_B, object_ids, 2);
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaFetchRequest);
+  ObjectID object_ids_read[2];
+  plasma_read_FetchRequest(data, &object_ids_read[0], 2);
+  ASSERT(ObjectID_equal(object_ids[0], object_ids_read[0]));
+  ASSERT(ObjectID_equal(object_ids[1], object_ids_read[1]));
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_wait_request_test(void) {
+  int fd = create_temp_file();
+  ObjectRequest object_requests[2];
+  object_requests[0].object_id = globally_unique_id();
+  object_requests[0].type = PLASMA_QUERY_ANYWHERE;
+  object_requests[1].object_id = globally_unique_id();
+  object_requests[1].type = PLASMA_QUERY_LOCAL;
+  int num_ready_objects = 1;
+  int64_t timeout_ms = 1000;
+  plasma_send_WaitRequest(fd, g_B, object_requests, 2, num_ready_objects,
+                          timeout_ms);
+  /* Read message back. */
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaWaitRequest);
+  ObjectRequest object_requests_read[2];
+  int num_object_ids_read = plasma_read_WaitRequest_num_object_ids(data);
+  ASSERT_EQ(num_object_ids_read, 2);
+  int num_ready_objects_read;
+  int64_t timeout_ms_read;
+  plasma_read_WaitRequest(data, &object_requests_read[0], num_object_ids_read,
+                          &timeout_ms_read, &num_ready_objects_read);
+  ASSERT(ObjectID_equal(object_requests[0].object_id,
+                        object_requests_read[0].object_id));
+  ASSERT(ObjectID_equal(object_requests[1].object_id,
+                        object_requests_read[1].object_id));
+  ASSERT(object_requests[0].type == object_requests_read[0].type);
+  ASSERT(object_requests[1].type == object_requests_read[1].type);
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_wait_reply_test(void) {
+  int fd = create_temp_file();
+  ObjectRequest object_replies1[2];
+  object_replies1[0].object_id = globally_unique_id();
+  object_replies1[0].status = ObjectStatus_Local;
+  object_replies1[1].object_id = globally_unique_id();
+  object_replies1[1].status = ObjectStatus_Nonexistent;
+  int num_ready_objects1 = 2;
+  plasma_send_WaitReply(fd, g_B, object_replies1, num_ready_objects1);
+  /* Read message back. */
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaWaitReply);
+  ObjectRequest object_replies2[2];
+  int num_ready_objects_read2;
+  plasma_read_WaitReply(data, &object_replies2[0], &num_ready_objects_read2);
+  ASSERT(ObjectID_equal(object_replies1[0].object_id,
+                        object_replies2[0].object_id));
+  ASSERT(ObjectID_equal(object_replies1[1].object_id,
+                        object_replies2[1].object_id));
+  ASSERT(object_replies1[0].status == object_replies2[0].status);
+  ASSERT(object_replies1[1].status == object_replies2[1].status);
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_data_request_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_id1 = globally_unique_id();
+  const char *address1 = "address1";
+  int port1 = 12345;
+  plasma_send_DataRequest(fd, g_B, object_id1, address1, port1);
+  /* Reading message back. */
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaDataRequest);
+  ObjectID object_id2;
+  char *address2;
+  int port2;
+  plasma_read_DataRequest(data, &object_id2, &address2, &port2);
+  ASSERT(ObjectID_equal(object_id1, object_id2));
+  ASSERT(strcmp(address1, address2) == 0);
+  ASSERT(port1 == port2);
+  free(address2);
+  free(data);
+  close(fd);
+  PASS();
+}
+
+TEST plasma_data_reply_test(void) {
+  int fd = create_temp_file();
+  ObjectID object_id1 = globally_unique_id();
+  int64_t object_size1 = 146;
+  int64_t metadata_size1 = 198;
+  plasma_send_DataReply(fd, g_B, object_id1, object_size1, metadata_size1);
+  /* Reading message back. */
+  uint8_t *data = read_message_from_file(fd, MessageType_PlasmaDataReply);
+  ObjectID object_id2;
+  int64_t object_size2;
+  int64_t metadata_size2;
+  plasma_read_DataReply(data, &object_id2, &object_size2, &metadata_size2);
+  ASSERT(ObjectID_equal(object_id1, object_id2));
+  ASSERT(object_size1 == object_size2);
+  ASSERT(metadata_size1 == metadata_size2);
+  free(data);
+  PASS();
+}
+
+SUITE(plasma_serialization_tests) {
+  RUN_TEST(plasma_create_request_test);
+  RUN_TEST(plasma_create_reply_test);
+  RUN_TEST(plasma_seal_request_test);
+  RUN_TEST(plasma_seal_reply_test);
+  RUN_TEST(plasma_get_request_test);
+  RUN_TEST(plasma_get_reply_test);
+  RUN_TEST(plasma_release_request_test);
+  RUN_TEST(plasma_release_reply_test);
+  RUN_TEST(plasma_delete_request_test);
+  RUN_TEST(plasma_delete_reply_test);
+  RUN_TEST(plasma_status_request_test);
+  RUN_TEST(plasma_status_reply_test);
+  RUN_TEST(plasma_evict_request_test);
+  RUN_TEST(plasma_evict_reply_test);
+  RUN_TEST(plasma_fetch_request_test);
+  RUN_TEST(plasma_wait_request_test);
+  RUN_TEST(plasma_wait_reply_test);
+  RUN_TEST(plasma_data_request_test);
+  RUN_TEST(plasma_data_reply_test);
+}
+
+GREATEST_MAIN_DEFS();
+
+int main(int argc, char **argv) {
+  g_B = make_protocol_builder();
+  GREATEST_MAIN_BEGIN();
+  RUN_SUITE(plasma_serialization_tests);
+  GREATEST_MAIN_END();
+  free_protocol_builder(g_B);
+}
