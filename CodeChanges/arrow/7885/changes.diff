diff --git a/cpp/src/gandiva/function_registry_arithmetic.cc b/cpp/src/gandiva/function_registry_arithmetic.cc
index 34526b50d1b2..dc1332cde221 100644
--- a/cpp/src/gandiva/function_registry_arithmetic.cc
+++ b/cpp/src/gandiva/function_registry_arithmetic.cc
@@ -87,8 +87,11 @@ std::vector<NativeFunction> GetArithmeticFunctionRegistry() {
       UNARY_SAFE_NULL_IF_NULL(bitwise_not, {}, int32, int32),
       UNARY_SAFE_NULL_IF_NULL(bitwise_not, {}, int64, int64),
 
+      // round functions
       BINARY_GENERIC_SAFE_NULL_IF_NULL(round, {}, float32, int32, float32),
       BINARY_GENERIC_SAFE_NULL_IF_NULL(round, {}, float64, int32, float64),
+      BINARY_GENERIC_SAFE_NULL_IF_NULL(round, {}, int32, int32, int32),
+      BINARY_GENERIC_SAFE_NULL_IF_NULL(round, {}, int64, int32, int64),
 
       // compare functions
       BINARY_RELATIONAL_BOOL_FN(equal, ({"eq", "same"})),
diff --git a/cpp/src/gandiva/precompiled/extended_math_ops.cc b/cpp/src/gandiva/precompiled/extended_math_ops.cc
index 73fe45645e07..3329acc15e49 100644
--- a/cpp/src/gandiva/precompiled/extended_math_ops.cc
+++ b/cpp/src/gandiva/precompiled/extended_math_ops.cc
@@ -15,6 +15,7 @@
 // specific language governing permissions and limitations
 // under the License.
 
+#include "arrow/util/logging.h"
 #include "gandiva/precompiled/decimal_ops.h"
 
 extern "C" {
@@ -125,6 +126,82 @@ POWER(float64, float64, float64)
 ROUND_DECIMAL(float32)
 ROUND_DECIMAL(float64)
 
+FORCE_INLINE
+gdv_int32 round_int32_int32(gdv_int32 number, gdv_int32 precision) {
+  // for integers, there is nothing following the decimal point,
+  // so round() always returns the same number if precision >= 0
+  if (precision >= 0) {
+    return number;
+  }
+  gdv_int32 abs_precision = -precision;
+  // This is to ensure that there is no overflow while calculating 10^precision, 9 is
+  // the smallest N for which 10^N does not fit into 32 bits, so we can safely return 0
+  if (abs_precision > 9) {
+    return 0;
+  }
+  gdv_int32 num_sign = (number > 0) ? 1 : -1;
+  gdv_int32 abs_number = number * num_sign;
+  gdv_int32 power_of_10 = static_cast<gdv_int32>(get_power_of_10(abs_precision));
+  gdv_int32 remainder = abs_number % power_of_10;
+  abs_number -= remainder;
+  // if the fractional part of the quotient >= 0.5, round to next higher integer
+  if (remainder >= power_of_10 / 2) {
+    abs_number += power_of_10;
+  }
+  return abs_number * num_sign;
+}
+
+FORCE_INLINE
+gdv_int64 round_int64_int32(gdv_int64 number, gdv_int32 precision) {
+  // for long integers, there is nothing following the decimal point,
+  // so round() always returns the same number if precision >= 0
+  if (precision >= 0) {
+    return number;
+  }
+  gdv_int32 abs_precision = -precision;
+  // This is to ensure that there is no overflow while calculating 10^precision, 19 is
+  // the smallest N for which 10^N does not fit into 64 bits, so we can safely return 0
+  if (abs_precision > 18) {
+    return 0;
+  }
+  gdv_int32 num_sign = (number > 0) ? 1 : -1;
+  gdv_int64 abs_number = number * num_sign;
+  gdv_int64 power_of_10 = get_power_of_10(abs_precision);
+  gdv_int64 remainder = abs_number % power_of_10;
+  abs_number -= remainder;
+  // if the fractional part of the quotient >= 0.5, round to next higher integer
+  if (remainder >= power_of_10 / 2) {
+    abs_number += power_of_10;
+  }
+  return abs_number * num_sign;
+}
+
+FORCE_INLINE
+gdv_int64 get_power_of_10(gdv_int32 exp) {
+  DCHECK_GE(exp, 0);
+  DCHECK_LE(exp, 18);
+  static const gdv_int64 power_of_10[] = {1,
+                                          10,
+                                          100,
+                                          1000,
+                                          10000,
+                                          100000,
+                                          1000000,
+                                          10000000,
+                                          100000000,
+                                          1000000000,
+                                          10000000000,
+                                          100000000000,
+                                          1000000000000,
+                                          10000000000000,
+                                          100000000000000,
+                                          1000000000000000,
+                                          10000000000000000,
+                                          100000000000000000,
+                                          1000000000000000000};
+  return power_of_10[exp];
+}
+
 FORCE_INLINE
 gdv_int64 truncate_int64_int32(gdv_int64 in, gdv_int32 out_scale) {
   bool overflow = false;
diff --git a/cpp/src/gandiva/precompiled/extended_math_ops_test.cc b/cpp/src/gandiva/precompiled/extended_math_ops_test.cc
index f4cbf6b8fee0..fcbefe1bb306 100644
--- a/cpp/src/gandiva/precompiled/extended_math_ops_test.cc
+++ b/cpp/src/gandiva/precompiled/extended_math_ops_test.cc
@@ -103,6 +103,22 @@ TEST(TestExtendedMathOps, TestRoundDecimal) {
   VerifyFuzzyEquals(round_float64_int32((double)INT_MIN - 1, 0), (double)INT_MIN - 1);
 }
 
+TEST(TestExtendedMathOps, TestRound) {
+  EXPECT_EQ(round_int32_int32(7589, -1), 7590);
+  EXPECT_EQ(round_int32_int32(8532, -2), 8500);
+  EXPECT_EQ(round_int32_int32(-8579, -1), -8580);
+  EXPECT_EQ(round_int32_int32(-8612, -2), -8600);
+  EXPECT_EQ(round_int32_int32(758, 2), 758);
+  EXPECT_EQ(round_int32_int32(8612, -5), 0);
+
+  EXPECT_EQ(round_int64_int32(3453562312, -2), 3453562300);
+  EXPECT_EQ(round_int64_int32(3453562343, -5), 3453600000);
+  EXPECT_EQ(round_int64_int32(345353425343, 12), 345353425343);
+  EXPECT_EQ(round_int64_int32(-23453462343, -4), -23453460000);
+  EXPECT_EQ(round_int64_int32(-23453462343, -5), -23453500000);
+  EXPECT_EQ(round_int64_int32(345353425343, -12), 0);
+}
+
 TEST(TestExtendedMathOps, TestTruncate) {
   EXPECT_EQ(truncate_int64_int32(1234, 4), 1234);
   EXPECT_EQ(truncate_int64_int32(-1234, 4), -1234);
diff --git a/cpp/src/gandiva/precompiled/types.h b/cpp/src/gandiva/precompiled/types.h
index 2ed4a25a6485..67711c41933d 100644
--- a/cpp/src/gandiva/precompiled/types.h
+++ b/cpp/src/gandiva/precompiled/types.h
@@ -135,6 +135,9 @@ gdv_float64 div_float64_float64(gdv_int64 context, gdv_float64 in1, gdv_float64
 gdv_float32 round_float32_int32(gdv_float32 number, gdv_int32 out_scale);
 gdv_float64 round_float64_int32(gdv_float64 number, gdv_int32 out_scale);
 gdv_float64 get_scale_multiplier(gdv_int32);
+gdv_int32 round_int32_int32(gdv_int32 number, gdv_int32 precision);
+gdv_int64 round_int64_int32(gdv_int64 number, gdv_int32 precision);
+gdv_int64 get_power_of_10(gdv_int32);
 
 gdv_float64 cbrt_int32(gdv_int32);
 gdv_float64 cbrt_int64(gdv_int64);
