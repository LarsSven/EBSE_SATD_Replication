diff --git a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
index 5b5df67a170..3020490a284 100644
--- a/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
+++ b/core/src/main/java/org/apache/calcite/plan/volcano/VolcanoPlanner.java
@@ -58,11 +58,9 @@
 import org.apache.calcite.util.Util;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.LinkedHashMultimap;
 import com.google.common.collect.LinkedListMultimap;
 import com.google.common.collect.Multimap;
 import com.google.common.collect.Ordering;
-import com.google.common.collect.SetMultimap;
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
@@ -239,8 +237,8 @@ public class VolcanoPlanner extends AbstractRelOptPlanner {
 
   /** Maps rule classes to their name, to ensure that the names are unique and
    * conform to rules. */
-  private final SetMultimap<String, Class> ruleNames =
-      LinkedHashMultimap.create();
+  private final Map<String, RelOptRule> ruleNames = new HashMap<>();
+
 
   //~ Constructors -----------------------------------------------------------
 
@@ -451,12 +449,9 @@ public boolean addRule(RelOptRule rule) {
     assert added;
 
     final String ruleName = rule.toString();
-    if (ruleNames.put(ruleName, rule.getClass())) {
-      Set<Class> x = ruleNames.get(ruleName);
-      if (x.size() > 1) {
-        throw new RuntimeException("Rule description '" + ruleName
-            + "' is not unique; classes: " + x);
-      }
+    if (ruleNames.put(ruleName, rule) != null) {
+      throw new RuntimeException("Rule description '" + ruleName
+          + "' is not unique. ");
     }
 
     mapRuleDescription(rule);
@@ -493,6 +488,9 @@ public boolean removeRule(RelOptRule rule) {
       return false;
     }
 
+    // Remove rule name.
+    ruleNames.remove(rule.toString());
+
     // Remove description.
     unmapRuleDescription(rule);
 
@@ -948,8 +946,8 @@ public void registerSchema(RelOptSchema schema) {
 
   /**
    * Sets whether this planner should consider rel nodes with Convention.NONE
-   * to have inifinte cost or not.
-   * @param infinite Whether to make none convention rel nodes inifite cost
+   * to have infinite cost or not.
+   * @param infinite Whether to make none convention rel nodes infinite cost
    */
   public void setNoneConventionHasInfiniteCost(boolean infinite) {
     this.noneConventionHasInfiniteCost = infinite;
