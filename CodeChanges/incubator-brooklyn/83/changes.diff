diff --git a/api/src/main/java/brooklyn/management/TaskQueueingContext.java b/api/src/main/java/brooklyn/management/TaskQueueingContext.java
index 813ed19939..431ee1765e 100644
--- a/api/src/main/java/brooklyn/management/TaskQueueingContext.java
+++ b/api/src/main/java/brooklyn/management/TaskQueueingContext.java
@@ -33,7 +33,11 @@
 @Beta
 public interface TaskQueueingContext {
 
-    /** queues the task for submission as part of this queueing context; should mark it as submitted */
+    /** queues the task for submission as part of this queueing context
+     * <p>
+     * implementations should mark it as queued but not yet submitted.
+     * note the task may have already been submitted, and is being queued here for informational purposes,
+     * in which case the implementation should not run it. */
     public void queue(Task<?> t);
     
     /** returns a list of queued tasks (immutable copy) */
diff --git a/core/src/main/java/brooklyn/entity/basic/AbstractEntity.java b/core/src/main/java/brooklyn/entity/basic/AbstractEntity.java
index 0f291bfd33..438f407638 100644
--- a/core/src/main/java/brooklyn/entity/basic/AbstractEntity.java
+++ b/core/src/main/java/brooklyn/entity/basic/AbstractEntity.java
@@ -243,7 +243,7 @@ public AbstractEntity(Entity parent) {
      * @deprecated since 0.5; instead use no-arg constructor with EntityManager().createEntity(spec)
      */
     @Deprecated
-    public AbstractEntity(Map flags, Entity parent) {
+    public AbstractEntity(@SuppressWarnings("rawtypes") Map flags, Entity parent) {
         if (flags==null) {
             throw new IllegalArgumentException("Flags passed to entity "+this+" must not be null (try no-arguments or empty map)");
         }
diff --git a/core/src/main/java/brooklyn/entity/basic/AbstractGroupImpl.java b/core/src/main/java/brooklyn/entity/basic/AbstractGroupImpl.java
index 8542e3aa2f..4aeb931c74 100644
--- a/core/src/main/java/brooklyn/entity/basic/AbstractGroupImpl.java
+++ b/core/src/main/java/brooklyn/entity/basic/AbstractGroupImpl.java
@@ -61,7 +61,7 @@ public AbstractGroupImpl() {
     }
 
     @Deprecated
-    public AbstractGroupImpl(Map flags, Entity parent) {
+    public AbstractGroupImpl(@SuppressWarnings("rawtypes") Map flags, Entity parent) {
         super(flags, parent);
     }
 
diff --git a/core/src/main/java/brooklyn/entity/basic/DynamicGroupImpl.java b/core/src/main/java/brooklyn/entity/basic/DynamicGroupImpl.java
index 67a5d26523..2f4d7a3859 100644
--- a/core/src/main/java/brooklyn/entity/basic/DynamicGroupImpl.java
+++ b/core/src/main/java/brooklyn/entity/basic/DynamicGroupImpl.java
@@ -33,6 +33,7 @@
 import brooklyn.management.internal.CollectionChangeListener;
 import brooklyn.management.internal.ManagementContextInternal;
 import brooklyn.util.GroovyJavaMethods;
+import brooklyn.util.exceptions.Exceptions;
 
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
@@ -50,7 +51,7 @@ public class DynamicGroupImpl extends AbstractGroupImpl implements DynamicGroup
     public DynamicGroupImpl() { }
 
     @Deprecated
-    public DynamicGroupImpl(Map flags, Entity parent) {
+    public DynamicGroupImpl(@SuppressWarnings("rawtypes") Map flags, Entity parent) {
         super(flags, parent);
     }
 
@@ -160,7 +161,13 @@ public void onManagementBecomingMaster() {
         }
         setChangeListener = new MyEntitySetChangeListener();
         ((ManagementContextInternal) getManagementContext()).addEntitySetListener(setChangeListener);
-        rescanEntities();
+        try {
+            rescanEntities();
+        } catch (Exception e) {
+            log.warn("Error rescanning entities when rebinding; may be a group set against an unknown entity: "+e);
+            log.debug("Trace for rescan entities error", e);
+            Exceptions.propagateIfFatal(e);
+        }
     }
 
     @Override
diff --git a/core/src/main/java/brooklyn/entity/basic/Entities.java b/core/src/main/java/brooklyn/entity/basic/Entities.java
index 281189085a..3e8b2250f3 100644
--- a/core/src/main/java/brooklyn/entity/basic/Entities.java
+++ b/core/src/main/java/brooklyn/entity/basic/Entities.java
@@ -80,6 +80,7 @@
 import brooklyn.util.stream.Streams;
 import brooklyn.util.task.DynamicTasks;
 import brooklyn.util.task.ParallelTask;
+import brooklyn.util.task.TaskTags;
 import brooklyn.util.task.Tasks;
 import brooklyn.util.task.system.ProcessTaskWrapper;
 import brooklyn.util.task.system.SystemTasks;
@@ -161,7 +162,7 @@ public static <T> Task<List<T>> invokeEffectorList(EntityLocal callingEntity, It
                         "description", "Invoking effector \""+effector.getName()+"\" on "+tasks.size()+(tasks.size() == 1 ? " entity" : " entities"),
                         "tag", BrooklynTaskTags.tagForCallerEntity(callingEntity)),
                 tasks);
-        
+        TaskTags.markInessential(invoke);
         return DynamicTasks.queueIfPossible(invoke).orSubmitAsync(callingEntity).asTask();
     }
     public static <T> Task<List<T>> invokeEffectorListWithMap(EntityLocal callingEntity, Iterable<? extends Entity> entitiesToCall,
@@ -183,11 +184,18 @@ public static <T> Task<List<T>> invokeEffectorList(EntityLocal callingEntity, It
     public static <T> Task<T> invokeEffector(EntityLocal callingEntity, Entity entityToCall,
             final Effector<T> effector, final Map<String,?> parameters) {
         Task<T> t = Effectors.invocation(entityToCall, effector, parameters).asTask();
+        TaskTags.markInessential(t);
         
         // we pass to callingEntity for consistency above, but in exec-context it should be
         // re-dispatched to targetEntity
         ((EntityInternal)callingEntity).getManagementSupport().getExecutionContext().submit(
                 MutableMap.of("tag", BrooklynTaskTags.tagForCallerEntity(callingEntity)), t);
+        
+        if (DynamicTasks.getTaskQueuingContext()!=null) {
+            // include it as a child (in the gui), marked inessential, because the caller is invoking programmatically
+            DynamicTasks.queue(t);
+        }
+        
         return t;
     }
     @SuppressWarnings("unchecked")
diff --git a/core/src/main/java/brooklyn/entity/group/DynamicCluster.java b/core/src/main/java/brooklyn/entity/group/DynamicCluster.java
index 917752ffdf..c44f302594 100644
--- a/core/src/main/java/brooklyn/entity/group/DynamicCluster.java
+++ b/core/src/main/java/brooklyn/entity/group/DynamicCluster.java
@@ -50,7 +50,6 @@
 
 import com.google.common.annotations.Beta;
 import com.google.common.base.Function;
-import com.google.common.base.Optional;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Multimap;
 import com.google.common.reflect.TypeToken;
@@ -80,6 +79,7 @@
  */
 // TODO document use of advanced availability zone configuration and features
 @ImplementedBy(DynamicClusterImpl.class)
+@SuppressWarnings("serial")
 public interface DynamicCluster extends AbstractGroup, Cluster, MemberReplaceable {
 
     @Beta
@@ -121,6 +121,7 @@ interface ZoneFailureDetector {
             "dynamiccluster.memberspec", "entity spec for creating new cluster members", null);
 
     /** @deprecated since 0.7.0; use {@link #MEMBER_SPEC} instead. */
+    @SuppressWarnings("rawtypes")
     @Deprecated
     @SetFromFlag("factory")
     ConfigKey<EntityFactory> FACTORY = ConfigKeys.newConfigKey(
@@ -131,6 +132,7 @@ interface ZoneFailureDetector {
             new TypeToken<Function<Collection<Entity>, Entity>>() {},
             "dynamiccluster.removalstrategy", "strategy for deciding what to remove when down-sizing", null);
 
+    @SuppressWarnings("rawtypes")
     @SetFromFlag("customChildFlags")
     ConfigKey<Map> CUSTOM_CHILD_FLAGS = ConfigKeys.newConfigKey(
             Map.class, "dynamiccluster.customChildFlags", "Additional flags to be passed to children when they are being created", ImmutableMap.of());
@@ -174,16 +176,6 @@ interface ZoneFailureDetector {
     @Effector(description="Changes the size of the cluster.")
     Collection<Entity> resizeByDelta(@EffectorParam(name="delta", description="The change in number of nodes") int delta);
 
-    /**
-     * Adds a node to the cluster in a single {@link Location}
-     */
-    Optional<Entity> addInSingleLocation(Location loc, Map<?,?> extraFlags);
-
-    /**
-     * Adds a node to the cluster in each {@link Location}
-     */
-    Collection<Entity> addInEachLocation(Iterable<Location> locs, Map<?,?> extraFlags);
-
     void setRemovalStrategy(Function<Collection<Entity>, Entity> val);
 
     void setZonePlacementStrategy(NodePlacementStrategy val);
diff --git a/core/src/main/java/brooklyn/entity/group/DynamicClusterImpl.java b/core/src/main/java/brooklyn/entity/group/DynamicClusterImpl.java
index 410b01e7f0..b6224a48ec 100644
--- a/core/src/main/java/brooklyn/entity/group/DynamicClusterImpl.java
+++ b/core/src/main/java/brooklyn/entity/group/DynamicClusterImpl.java
@@ -56,11 +56,13 @@
 import brooklyn.util.collections.MutableList;
 import brooklyn.util.collections.MutableMap;
 import brooklyn.util.exceptions.Exceptions;
+import brooklyn.util.exceptions.ReferenceWithError;
 import brooklyn.util.flags.TypeCoercions;
 import brooklyn.util.guava.Maybe;
 import brooklyn.util.javalang.JavaClassNames;
 import brooklyn.util.javalang.Reflections;
 import brooklyn.util.task.DynamicTasks;
+import brooklyn.util.task.TaskTags;
 import brooklyn.util.task.Tasks;
 import brooklyn.util.text.StringPredicates;
 import brooklyn.util.text.Strings;
@@ -257,7 +259,13 @@ public void start(Collection<? extends Location> locsO) {
             int initialSize = getConfig(INITIAL_SIZE).intValue();
             int initialQuorumSize = getInitialQuorumSize();
 
-            resize(initialSize);
+            try {
+                resize(initialSize);
+            } catch (Exception e) {
+                Exceptions.propagateIfFatal(e);
+                // apart from logging, ignore problems here; we extract them below
+                LOG.debug("Error resizing "+this+" to size "+initialSize+" (collecting and handling): "+e, e);
+            }
 
             Iterable<Task<?>> failed = Tasks.failed(Tasks.children(Tasks.current()));
             Iterator<Task<?>> fi = failed.iterator();
@@ -478,10 +486,12 @@ public String replaceMember(String memberId) {
      */
     protected Entity replaceMember(Entity member, Location memberLoc, Map<?, ?> extraFlags) {
         synchronized (mutex) {
-            Optional<Entity> added = addInSingleLocation(memberLoc, extraFlags);
+            ReferenceWithError<Optional<Entity>> added = addInSingleLocation(memberLoc, extraFlags);
 
-            if (!added.isPresent()) {
+            if (!added.getMaskingError().isPresent()) {
                 String msg = String.format("In %s, failed to grow, to replace %s; not removing", this, member);
+                if (added.hasError())
+                    throw new IllegalStateException(msg, added.getError());
                 throw new IllegalStateException(msg);
             }
 
@@ -492,7 +502,7 @@ protected Entity replaceMember(Entity member, Location memberLoc, Map<?, ?> extr
                 throw new StopFailedRuntimeException("replaceMember failed to stop and remove old member "+member.getId(), e);
             }
 
-            return added.get();
+            return added.getThrowingError().get();
         }
     }
 
@@ -575,7 +585,7 @@ protected Collection<Entity> grow(int delta) {
         }
 
         // create and start the entities
-        return addInEachLocation(chosenLocations, ImmutableMap.of());
+        return addInEachLocation(chosenLocations, ImmutableMap.of()).getThrowingError();
     }
 
     /** <strong>Note</strong> for sub-clases; this method can be called while synchronized on {@link #mutex}. */
@@ -606,14 +616,22 @@ protected Collection<Entity> shrink(int delta) {
         }
     }
 
-    @Override
-    public Optional<Entity> addInSingleLocation(Location location, Map<?,?> flags) {
-        Collection<Entity> added = addInEachLocation(ImmutableList.of(location), flags);
-        return Iterables.isEmpty(added) ? Optional.<Entity>absent() : Optional.of(Iterables.getOnlyElement(added));
+    protected ReferenceWithError<Optional<Entity>> addInSingleLocation(Location location, Map<?,?> flags) {
+        ReferenceWithError<Collection<Entity>> added = addInEachLocation(ImmutableList.of(location), flags);
+        
+        Optional<Entity> result = Iterables.isEmpty(added.getMaskingError()) ? Optional.<Entity>absent() : Optional.of(Iterables.getOnlyElement(added.get()));
+        if (!added.hasError()) {
+            return ReferenceWithError.newInstanceWithoutError( result );
+        } else {
+            if (added.masksErrorIfPresent()) {
+                return ReferenceWithError.newInstanceMaskingError( result, added.getError() );
+            } else {
+                return ReferenceWithError.newInstanceThrowingError( result, added.getError() );
+            }
+        }
     }
 
-    @Override
-    public Collection<Entity> addInEachLocation(Iterable<Location> locations, Map<?,?> flags) {
+    protected ReferenceWithError<Collection<Entity>> addInEachLocation(Iterable<Location> locations, Map<?,?> flags) {
         List<Entity> addedEntities = Lists.newArrayList();
         Map<Entity, Location> addedEntityLocations = Maps.newLinkedHashMap();
         Map<Entity, Task<?>> tasks = Maps.newLinkedHashMap();
@@ -627,7 +645,9 @@ public Collection<Entity> addInEachLocation(Iterable<Location> locations, Map<?,
             tasks.put(entity, task);
         }
 
-        DynamicTasks.queueIfPossible(Tasks.parallel("starting "+tasks.size()+" node"+Strings.s(tasks.size())+" (parallel)", tasks.values())).orSubmitAsync(this);
+        Task<List<?>> parallel = Tasks.parallel("starting "+tasks.size()+" node"+Strings.s(tasks.size())+" (parallel)", tasks.values());
+        TaskTags.markInessential(parallel);
+        DynamicTasks.queueIfPossible(parallel).orSubmitAsync(this);
         Map<Entity, Throwable> errors = waitForTasksOnEntityStart(tasks);
 
         // if tracking, then report success/fail to the ZoneFailureDetector
@@ -643,6 +663,11 @@ public Collection<Entity> addInEachLocation(Iterable<Location> locations, Map<?,
                 }
             }
         }
+        
+        Collection<Entity> result = MutableList.<Entity> builder()
+            .addAll(addedEntities)
+            .removeAll(errors.keySet())
+            .build();
 
         // quarantine/cleanup as necessary
         if (!errors.isEmpty()) {
@@ -651,12 +676,10 @@ public Collection<Entity> addInEachLocation(Iterable<Location> locations, Map<?,
             } else {
                 cleanupFailedNodes(errors.keySet());
             }
+            return ReferenceWithError.newInstanceMaskingError(result, Exceptions.create(errors.values()));
         }
 
-        return MutableList.<Entity> builder()
-                .addAll(addedEntities)
-                .removeAll(errors.keySet())
-                .build();
+        return ReferenceWithError.newInstanceWithoutError(result);
     }
 
     protected void quarantineFailedNodes(Collection<Entity> failedEntities) {
diff --git a/core/src/main/java/brooklyn/event/basic/DependentConfiguration.java b/core/src/main/java/brooklyn/event/basic/DependentConfiguration.java
index d569aea7e5..8630214955 100644
--- a/core/src/main/java/brooklyn/event/basic/DependentConfiguration.java
+++ b/core/src/main/java/brooklyn/event/basic/DependentConfiguration.java
@@ -151,6 +151,9 @@ public static <T> T waitInTaskForAttributeReady(Entity source, AttributeSensor<T
         return waitInTaskForAttributeReady(source, sensor, ready, ImmutableList.<AttributeAndSensorCondition<?>>of());
     }
     
+    // TODO would be nice to have an easy semantics for whenServiceUp (cf DynamicWebAppClusterImpl.whenServiceUp)
+    // and TODO would be nice to have it stop when source is unmanaged (with ability to define post-processing)
+    // probably using the builder for both of these...
     public static <T> T waitInTaskForAttributeReady(final Entity source, final AttributeSensor<T> sensor, Predicate<? super T> ready, List<AttributeAndSensorCondition<?>> abortConditions) {
         T value = source.getAttribute(sensor);
         final List<Exception> abortion = Lists.newCopyOnWriteArrayList();
diff --git a/core/src/main/java/brooklyn/location/basic/AbstractLocation.java b/core/src/main/java/brooklyn/location/basic/AbstractLocation.java
index d4686226f2..eb46be7753 100644
--- a/core/src/main/java/brooklyn/location/basic/AbstractLocation.java
+++ b/core/src/main/java/brooklyn/location/basic/AbstractLocation.java
@@ -528,7 +528,7 @@ public void addChild(Location child) {
         child.setParent(this);
     }
     
-    protected boolean removeChild(Location child) {
+    public boolean removeChild(Location child) {
         boolean removed;
         synchronized (children) {
             removed = children.remove(child);
diff --git a/core/src/main/java/brooklyn/location/basic/FixedListMachineProvisioningLocation.java b/core/src/main/java/brooklyn/location/basic/FixedListMachineProvisioningLocation.java
index 523eb6dc85..242319bc90 100644
--- a/core/src/main/java/brooklyn/location/basic/FixedListMachineProvisioningLocation.java
+++ b/core/src/main/java/brooklyn/location/basic/FixedListMachineProvisioningLocation.java
@@ -184,7 +184,7 @@ public void addChild(Location child) {
     }
 
     @Override
-    protected boolean removeChild(Location child) {
+    public boolean removeChild(Location child) {
         if (inUse.contains(child)) {
             throw new IllegalStateException("Child location "+child+" is in use; cannot remove from "+this);
         }
diff --git a/core/src/main/java/brooklyn/management/internal/AbstractManagementContext.java b/core/src/main/java/brooklyn/management/internal/AbstractManagementContext.java
index 46e751d1d3..0a3077a413 100644
--- a/core/src/main/java/brooklyn/management/internal/AbstractManagementContext.java
+++ b/core/src/main/java/brooklyn/management/internal/AbstractManagementContext.java
@@ -290,12 +290,17 @@ public T call() {
      * Returns the actual task (if it is local) or a proxy task (if it is remote);
      * if management for the entity has not yet started this may start it.
      * 
-     * @deprecated since 0.6.0 use effectors (or support {@code runAtEntity(Entity, Task)} if something else is needed);
+     * @deprecated since 0.6.0 use effectors (or support {@code runAtEntity(Entity, Effector, Map)} if something else is needed);
      * (Callable with Map flags is too open-ended, bothersome to support, and not used much) 
      */
     @Deprecated
     public abstract <T> Task<T> runAtEntity(@SuppressWarnings("rawtypes") Map flags, Entity entity, Callable<T> c);
 
+    /** Runs the given effector in the right place for the given entity.
+     * The task is immediately submitted in the background, but also recorded in the queueing context (if present)
+     * so it appears as a child, but marked inessential so it does not fail the parent task, who will ordinarily
+     * call {@link Task#get()} on the object and may do their own failure handling. 
+     */
     protected abstract <T> Task<T> runAtEntity(final Entity entity, final Effector<T> eff, @SuppressWarnings("rawtypes") final Map parameters);
 
     @Override
diff --git a/core/src/main/java/brooklyn/management/internal/LocalLocationManager.java b/core/src/main/java/brooklyn/management/internal/LocalLocationManager.java
index 303825705b..8ce4dbe8c1 100644
--- a/core/src/main/java/brooklyn/management/internal/LocalLocationManager.java
+++ b/core/src/main/java/brooklyn/management/internal/LocalLocationManager.java
@@ -88,6 +88,13 @@ public <T extends Location> T createLocation(LocationSpec<T> spec) {
             T loc = locationFactory.createLocation(spec);
             if (!createUnmanaged) {
                 manage(loc);
+            } else {
+                // remove references
+                Location parent = loc.getParent();
+                if (parent!=null) {
+                    ((AbstractLocation)parent).removeChild(loc);
+                }
+                preRegisteredLocationsById.remove(loc.getId());
             }
             
             return loc;
diff --git a/core/src/main/java/brooklyn/management/internal/LocalManagementContext.java b/core/src/main/java/brooklyn/management/internal/LocalManagementContext.java
index 3ee97a7982..136dba178a 100644
--- a/core/src/main/java/brooklyn/management/internal/LocalManagementContext.java
+++ b/core/src/main/java/brooklyn/management/internal/LocalManagementContext.java
@@ -52,11 +52,15 @@
 import brooklyn.management.ManagementContext;
 import brooklyn.management.SubscriptionManager;
 import brooklyn.management.Task;
+import brooklyn.management.TaskAdaptable;
 import brooklyn.management.ha.OsgiManager;
 import brooklyn.util.exceptions.Exceptions;
 import brooklyn.util.guava.Maybe;
 import brooklyn.util.task.BasicExecutionContext;
 import brooklyn.util.task.BasicExecutionManager;
+import brooklyn.util.task.DynamicTasks;
+import brooklyn.util.task.TaskTags;
+import brooklyn.util.task.Tasks;
 import brooklyn.util.text.Strings;
 
 import com.google.common.annotations.Beta;
@@ -322,12 +326,24 @@ protected void finalize() {
         terminate();
     }
 
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     @Override
-    public <T> Task<T> runAtEntity(@SuppressWarnings("rawtypes") Map flags, Entity entity, Callable<T> c) {
+    public <T> Task<T> runAtEntity(Map flags, Entity entity, Callable<T> c) {
 		manageIfNecessary(entity, elvis(Arrays.asList(flags.get("displayName"), flags.get("description"), flags, c)));
-        return getExecutionContext(entity).submit(flags, c);
+        return runAtEntity(entity, Tasks.<T>builder().dynamic(true).body(c).flags(flags).build());
     }
 
+    protected <T> Task<T> runAtEntity(Entity entity, TaskAdaptable<T> task) {
+        getExecutionContext(entity).submit(task);
+        if (DynamicTasks.getTaskQueuingContext()!=null) {
+            // put it in the queueing context so it appears in the GUI
+            // mark it inessential as this is being invoked from code,
+            // the caller will do 'get' to handle errors
+            TaskTags.markInessential(task);
+            DynamicTasks.getTaskQueuingContext().queue(task.asTask());
+        }
+        return task.asTask();
+    }
     
     @Override
     protected <T> Task<T> runAtEntity(final Entity entity, final Effector<T> eff, @SuppressWarnings("rawtypes") final Map parameters) {
@@ -338,7 +354,7 @@ protected <T> Task<T> runAtEntity(final Entity entity, final Effector<T> eff, @S
             log.debug("Top-level effector invocation: {} on {}", eff, entity);
             ec = getExecutionContext(entity);
         }
-        return ec.submit(Effectors.invocation(entity, eff, parameters));
+        return runAtEntity(entity, Effectors.invocation(entity, eff, parameters));
     }
 
     @Override
diff --git a/core/src/main/java/brooklyn/management/internal/LocalSubscriptionManager.java b/core/src/main/java/brooklyn/management/internal/LocalSubscriptionManager.java
index a1d084a3b9..0bd8578a71 100644
--- a/core/src/main/java/brooklyn/management/internal/LocalSubscriptionManager.java
+++ b/core/src/main/java/brooklyn/management/internal/LocalSubscriptionManager.java
@@ -180,6 +180,10 @@ public <T> void publish(final SensorEvent<T> event) {
                     continue;
                 final Subscription sAtClosureCreation = s;
                 em.submit(mapOf("tag", s.subscriberExecutionManagerTag), new Runnable() {
+                    @Override
+                    public String toString() {
+                        return "LSM.publish("+event+")";
+                    }
                     public void run() {
                         sAtClosureCreation.listener.onEvent(event);
                     }});
diff --git a/core/src/main/java/brooklyn/util/ResourceUtils.java b/core/src/main/java/brooklyn/util/ResourceUtils.java
index 5aacfb3b0f..cabd03665a 100644
--- a/core/src/main/java/brooklyn/util/ResourceUtils.java
+++ b/core/src/main/java/brooklyn/util/ResourceUtils.java
@@ -46,6 +46,7 @@
 import brooklyn.util.collections.MutableMap;
 import brooklyn.util.exceptions.Exceptions;
 import brooklyn.util.javalang.Threads;
+import brooklyn.util.net.Networking;
 import brooklyn.util.net.Urls;
 import brooklyn.util.os.Os;
 import brooklyn.util.stream.Streams;
@@ -66,6 +67,8 @@ public class ResourceUtils {
     private String context = null;
     private Object contextObject = null;
     
+    static { Networking.init(); }
+    
     /**
      * Creates a {@link ResourceUtils} object with a specific class loader and context.
      * <p>
diff --git a/core/src/main/java/brooklyn/util/task/BasicExecutionManager.java b/core/src/main/java/brooklyn/util/task/BasicExecutionManager.java
index a9d6a46e45..da8c4561e2 100644
--- a/core/src/main/java/brooklyn/util/task/BasicExecutionManager.java
+++ b/core/src/main/java/brooklyn/util/task/BasicExecutionManager.java
@@ -288,59 +288,76 @@ public <T> Task<T> submit(Map<?,?> flags, TaskAdaptable<T> task) {
     }
 
     public <T> Task<T> scheduleWith(Task<T> task) { return scheduleWith(Collections.emptyMap(), task); }
-	public <T> Task<T> scheduleWith(Map<?,?> flags, Task<T> task) {
-		synchronized (task) {
-			if (((TaskInternal<?>)task).getResult()!=null) return task;
-			return submitNewTask(flags, task);
-		}
-	}
+    public <T> Task<T> scheduleWith(Map<?,?> flags, Task<T> task) {
+        synchronized (task) {
+            if (((TaskInternal<?>)task).getResult()!=null) return task;
+            return submitNewTask(flags, task);
+        }
+    }
 
-	@SuppressWarnings("unchecked")
+    @SuppressWarnings("unchecked")
     protected Task<?> submitNewScheduledTask(final Map<?,?> flags, final ScheduledTask task) {
-		task.submitTimeUtc = System.currentTimeMillis();
-		tasksById.put(task.getId(), task);
-		if (!task.isDone()) {
-			task.result = delayedRunner.schedule(new Callable<Object>() { @SuppressWarnings("rawtypes")
-            public Object call() {
-				if (task.startTimeUtc==-1) task.startTimeUtc = System.currentTimeMillis();
-				try {
-				    beforeStart(flags, task);
-				    final TaskInternal<?> taskScheduled = (TaskInternal<?>) task.newTask();
-				    taskScheduled.setSubmittedByTask(task);
-				    final Callable<?> oldJob = taskScheduled.getJob();
-				    taskScheduled.setJob(new Callable() { public Object call() {
-				        task.recentRun = taskScheduled;
-				        synchronized (task) {
-				            task.notifyAll();
-				        }
-				        Object result;
-				        try {
-				            result = oldJob.call();
-				        } catch (Exception e) {
-				            log.warn("Error executing "+oldJob+" (scheduled job of "+task+" - "+task.getDescription()+"); cancelling scheduled execution", e);
-				            throw Exceptions.propagate(e);
-				        }
-				        task.runCount++;
-				        if (task.period!=null && !task.isCancelled()) {
-				            task.delay = task.period;
-				            submitNewScheduledTask(flags, task);
-				        }
-				        return result;
-				    }});
-				    task.nextRun = taskScheduled;
-				    BasicExecutionContext ec = BasicExecutionContext.getCurrentExecutionContext();
-				    if (ec!=null) return ec.submit(taskScheduled);
-				    else return submit(taskScheduled);
-				} finally {
-				    afterEnd(flags, task);
-				}
-			}},
-			task.delay.toNanoseconds(), TimeUnit.NANOSECONDS);
-		} else {
-			task.endTimeUtc = System.currentTimeMillis();
-		}
-		return task;
-	}
+        task.submitTimeUtc = System.currentTimeMillis();
+        tasksById.put(task.getId(), task);
+        if (!task.isDone()) {
+            task.result = delayedRunner.schedule(new ScheduledTaskCallable(task, flags),
+                task.delay.toNanoseconds(), TimeUnit.NANOSECONDS);
+        } else {
+            task.endTimeUtc = System.currentTimeMillis();
+        }
+        return task;
+    }
+
+    protected class ScheduledTaskCallable implements Callable<Object> {
+        public ScheduledTask task;
+        public Map<?,?> flags;
+
+        public ScheduledTaskCallable(ScheduledTask task, Map<?, ?> flags) {
+            this.task = task;
+            this.flags = flags;
+        }
+
+        @SuppressWarnings({ "rawtypes", "unchecked" })
+        public Object call() {
+            if (task.startTimeUtc==-1) task.startTimeUtc = System.currentTimeMillis();
+            try {
+                beforeStart(flags, task);
+                final TaskInternal<?> taskScheduled = (TaskInternal<?>) task.newTask();
+                taskScheduled.setSubmittedByTask(task);
+                final Callable<?> oldJob = taskScheduled.getJob();
+                taskScheduled.setJob(new Callable() { public Object call() {
+                    task.recentRun = taskScheduled;
+                    synchronized (task) {
+                        task.notifyAll();
+                    }
+                    Object result;
+                    try {
+                        result = oldJob.call();
+                    } catch (Exception e) {
+                        log.warn("Error executing "+oldJob+" (scheduled job of "+task+" - "+task.getDescription()+"); cancelling scheduled execution", e);
+                        throw Exceptions.propagate(e);
+                    }
+                    task.runCount++;
+                    if (task.period!=null && !task.isCancelled()) {
+                        task.delay = task.period;
+                        submitNewScheduledTask(flags, task);
+                    }
+                    return result;
+                }});
+                task.nextRun = taskScheduled;
+                BasicExecutionContext ec = BasicExecutionContext.getCurrentExecutionContext();
+                if (ec!=null) return ec.submit(taskScheduled);
+                else return submit(taskScheduled);
+            } finally {
+                afterEnd(flags, task);
+            }
+        }
+
+        @Override
+        public String toString() {
+            return "ScheduledTaskCallable["+task+","+flags+"]";
+        }
+    }
 
     @SuppressWarnings("unchecked")
     protected <T> Task<T> submitNewTask(final Map<?,?> flags, final Task<T> task) {
@@ -355,43 +372,49 @@ protected <T> Task<T> submitNewTask(final Map<?,?> flags, final Task<T> task) {
         if (((TaskInternal<T>)task).getJob() == null) 
             throw new NullPointerException("Task "+task+" submitted with with null job: job must be supplied.");
         
-        Callable<T> job = new Callable<T>() { public T call() {
-          try {
-            T result = null;
-            Throwable error = null;
-            String oldThreadName = Thread.currentThread().getName();
-            try {
-                if (RENAME_THREADS) {
-                    String newThreadName = oldThreadName+"-"+task.getDisplayName()+
-                            "["+task.getId().substring(0, 8)+"]";
-                    Thread.currentThread().setName(newThreadName);
-                }
-                beforeStart(flags, task);
-                if (!task.isCancelled()) {
-                    result = ((TaskInternal<T>)task).getJob().call();
-                } else throw new CancellationException();
-            } catch(Throwable e) {
-                error = e;
-            } finally {
-                if (RENAME_THREADS) {
-                    Thread.currentThread().setName(oldThreadName);
+        Callable<T> job = new Callable<T>() { 
+            public T call() {
+                try {
+                    T result = null;
+                    Throwable error = null;
+                    String oldThreadName = Thread.currentThread().getName();
+                    try {
+                        if (RENAME_THREADS) {
+                            String newThreadName = oldThreadName+"-"+task.getDisplayName()+
+                                "["+task.getId().substring(0, 8)+"]";
+                            Thread.currentThread().setName(newThreadName);
+                        }
+                        beforeStart(flags, task);
+                        if (!task.isCancelled()) {
+                            result = ((TaskInternal<T>)task).getJob().call();
+                        } else throw new CancellationException();
+                    } catch(Throwable e) {
+                        error = e;
+                    } finally {
+                        if (RENAME_THREADS) {
+                            Thread.currentThread().setName(oldThreadName);
+                        }
+                        afterEnd(flags, task);
+                    }
+                    if (error!=null) {
+                        if (log.isDebugEnabled()) {
+                            // debug only here, because we rethrow
+                            log.debug("Exception running task "+task+" (rethrowing): "+error.getMessage(), error);
+                            if (log.isTraceEnabled())
+                                log.trace("Trace for exception running task "+task+" (rethrowing): "+error.getMessage(), error);
+                        }
+                        throw Exceptions.propagate(error);
+                    }
+                    return result;
+                } finally {
+                    ((TaskInternal<?>)task).runListeners();
                 }
-                afterEnd(flags, task);
             }
-            if (error!=null) {
-                if (log.isDebugEnabled()) {
-                    // debug only here, because we rethrow
-                    log.debug("Exception running task "+task+" (rethrowing): "+error.getMessage(), error);
-                    if (log.isTraceEnabled())
-                        log.trace("Trace for exception running task "+task+" (rethrowing): "+error.getMessage(), error);
-                }
-                throw Exceptions.propagate(error);
+            @Override
+            public String toString() {
+                return "BEM.call("+task+","+flags+")";
             }
-            return result;
-          } finally {
-              ((TaskInternal<?>)task).runListeners();
-          }
-        }};
+        };
         
         // If there's a scheduler then use that; otherwise execute it directly
         Set<TaskScheduler> schedulers = null;
diff --git a/core/src/main/java/brooklyn/util/task/BasicTask.java b/core/src/main/java/brooklyn/util/task/BasicTask.java
index 8337edf771..5bbd9cb6df 100644
--- a/core/src/main/java/brooklyn/util/task/BasicTask.java
+++ b/core/src/main/java/brooklyn/util/task/BasicTask.java
@@ -20,7 +20,6 @@
 
 import static brooklyn.util.JavaGroovyEquivalents.asString;
 import static brooklyn.util.JavaGroovyEquivalents.elvisString;
-import static brooklyn.util.JavaGroovyEquivalents.join;
 import groovy.lang.Closure;
 
 import java.io.PrintWriter;
@@ -117,8 +116,7 @@ public BasicTask(Map<?,?> flags, Callable<T> job) {
 
         description = elvisString(flags.remove("description"), "");
         String d = asString(flags.remove("displayName"));
-        if (d==null) d = join(tags, "-");
-        displayName = d;
+        displayName = (d==null ? "" : d);
     }
 
     public BasicTask(Runnable job) { this(GroovyJavaMethods.<T>callableFromRunnable(job)); }
@@ -144,10 +142,13 @@ public boolean equals(Object obj) {
     }
 
     @Override
-    public String toString() { 
-        return "Task["+(displayName!=null && displayName.length()>0?displayName+
-                (tags!=null && !tags.isEmpty()?"":";")+" ":"")+
-                (tags!=null && !tags.isEmpty()?tags+"; ":"")+getId()+"]";
+    public String toString() {
+        // give display name plus id, or job and tags plus id; some jobs have been extended to include nice tostrings 
+        return "Task["+
+            (Strings.isNonEmpty(displayName) ? 
+                displayName : 
+                (job + (tags!=null && !tags.isEmpty() ? ";"+tags : "")) ) +
+            ":"+getId()+"]";
     }
 
     @Override
@@ -230,14 +231,19 @@ public synchronized void initResult(ListenableFuture<T> result) {
 
     // basic fields --------------------
 
+    @Override
+    public boolean isQueued() {
+        return (queuedTimeUtc >= 0);
+    }
+
     @Override
     public boolean isQueuedOrSubmitted() {
-        return (queuedTimeUtc >= 0) || isSubmitted();
+        return isQueued() || isSubmitted();
     }
 
     @Override
     public boolean isQueuedAndNotSubmitted() {
-        return (queuedTimeUtc >= 0) && (!isSubmitted());
+        return isQueued() && (!isSubmitted());
     }
 
     @Override
diff --git a/core/src/main/java/brooklyn/util/task/DynamicSequentialTask.java b/core/src/main/java/brooklyn/util/task/DynamicSequentialTask.java
index 15ccb14c82..520c8b0842 100644
--- a/core/src/main/java/brooklyn/util/task/DynamicSequentialTask.java
+++ b/core/src/main/java/brooklyn/util/task/DynamicSequentialTask.java
@@ -184,9 +184,9 @@ public Iterable<Task<?>> getChildren() {
     /** submits the indicated task for execution in the current execution context, and returns immediately */
     protected void submitBackgroundInheritingContext(Task<?> task) {
         BasicExecutionContext ec = BasicExecutionContext.getCurrentExecutionContext();
-        if (log.isTraceEnabled())
-            log.trace("task {} - submitting background task {} ({})", new Object[] { 
-                Tasks.current(), task, ec });
+        if (log.isTraceEnabled()) {
+            log.trace("task {} - submitting background task {} ({})", new Object[] { Tasks.current(), task, ec });
+        }
         if (ec==null) {
             String message = Tasks.current()!=null ?
                     // user forgot ExecContext:
@@ -197,10 +197,13 @@ protected void submitBackgroundInheritingContext(Task<?> task) {
             throw new IllegalStateException(message);
         }
         synchronized (task) {
-            if (task.isSubmitted() && !task.isDone())
-                log.debug("DST "+this+" skipping submission of child "+task+" because it is already submitted");
-            else
+            if (task.isSubmitted() && !task.isDone()) {
+                if (log.isTraceEnabled()) {
+                    log.trace("DST "+this+" skipping submission of child "+task+" because it is already submitted");
+                }
+            } else {
                 ec.submit(task);
+            }
         }
     }
 
@@ -367,7 +370,7 @@ public List<Object> call() throws Exception {
         
         @Override
         public String toString() {
-            return "DstJob:"+DynamicSequentialTask.this;
+            return "DstJob:"+DynamicSequentialTask.this.getId();
         }
 
         /** waits for this job to complete, or the given time to elapse */
diff --git a/core/src/main/java/brooklyn/util/task/DynamicTasks.java b/core/src/main/java/brooklyn/util/task/DynamicTasks.java
index 4955b32595..4a08d6f7eb 100644
--- a/core/src/main/java/brooklyn/util/task/DynamicTasks.java
+++ b/core/src/main/java/brooklyn/util/task/DynamicTasks.java
@@ -226,7 +226,7 @@ public static <T> Task<T> queueInTaskHierarchy(Task<T> task) {
     public static <V extends TaskAdaptable<?>> V queue(V task) {
         try {
             Preconditions.checkNotNull(task, "Task to queue cannot be null");
-            Preconditions.checkState(!Tasks.isQueuedOrSubmitted(task), "Task to queue must not yet be submitted: %s", task);
+            Preconditions.checkState(!Tasks.isQueued(task), "Task to queue must not yet be queued: %s", task);
             TaskQueueingContext adder = getTaskQueuingContext();
             if (adder==null) 
                 throw new IllegalStateException("Task "+task+" cannot be queued here; no queueing context available");
@@ -267,14 +267,23 @@ public static <T> Task<T> queue(String name, Runnable job) {
         return DynamicTasks.queue(Tasks.<T>builder().name(name).body(job).build());
     }
 
+    /** queues the task if needed, i.e. if it is not yet submitted (so it will run), 
+     * or if it is submitted but not queued and we are in a queueing context (so it is available for informational purposes) */
     public static <T extends TaskAdaptable<?>> T queueIfNeeded(T task) {
-        if (!Tasks.isQueuedOrSubmitted(task))
-            queue(task);
+        if (!Tasks.isQueued(task)) {
+            if (Tasks.isSubmitted(task) && getTaskQueuingContext()==null) {
+                // already submitted and not in a queueing context, don't try to queue
+            } else {
+                // needs submitting, put it in the queue
+                // (will throw an error if we are not a queueing context)
+                queue(task);
+            }
+        }
         return task;
     }
     
-    /** submits the given task if needed, and gets the result (unchecked) 
-     * only permitted in a queueing context (ie a DST main job) */
+    /** submits/queues the given task if needed, and gets the result (unchecked) 
+     * only permitted in a queueing context (ie a DST main job) if the task is not yet submitted */
     // things get really confusing if you try to queueInTaskHierarchy -- easy to cause deadlocks!
     public static <T> T get(TaskAdaptable<T> t) {
         return queueIfNeeded(t).asTask().getUnchecked();
@@ -312,5 +321,11 @@ public static void swallowChildrenFailures() {
     public static void markInessential() {
         Tasks.markInessential();
     }
+
+    /** queues the task if possible, otherwise submits it asynchronously; returns the task for callers to 
+     * {@link Task#getUnchecked()} or {@link Task#blockUntilEnded()} */
+    public static <T> Task<T> submit(TaskAdaptable<T> task, Entity entity) {
+        return queueIfPossible(task).orSubmitAsync(entity).asTask();
+    }
     
 }
diff --git a/core/src/main/java/brooklyn/util/task/ForwardingTask.java b/core/src/main/java/brooklyn/util/task/ForwardingTask.java
index 729e28eb03..e54ebeff55 100644
--- a/core/src/main/java/brooklyn/util/task/ForwardingTask.java
+++ b/core/src/main/java/brooklyn/util/task/ForwardingTask.java
@@ -192,6 +192,11 @@ public Future<T> getResult() {
         return delegate().getResult();
     }
 
+    @Override
+    public boolean isQueued() {
+        return delegate().isQueued();
+    }
+
     @Override
     public boolean isQueuedOrSubmitted() {
         return delegate().isQueuedOrSubmitted();
diff --git a/core/src/main/java/brooklyn/util/task/ParallelTask.java b/core/src/main/java/brooklyn/util/task/ParallelTask.java
index f326f56f77..9828bbf3d1 100644
--- a/core/src/main/java/brooklyn/util/task/ParallelTask.java
+++ b/core/src/main/java/brooklyn/util/task/ParallelTask.java
@@ -63,7 +63,11 @@ protected List<T> runJobs() throws InterruptedException, ExecutionException {
                 x = task.get();
             } catch (Exception e) {
                 Exceptions.propagateIfFatal(e);
-                exceptions.add(e);
+                if (TaskTags.isInessential(task)) {
+                    // ignore exception as it's inessential
+                } else {
+                    exceptions.add(e);
+                }
                 x = null;
             }
             result.add(x);
diff --git a/core/src/main/java/brooklyn/util/task/SingleThreadedScheduler.java b/core/src/main/java/brooklyn/util/task/SingleThreadedScheduler.java
index c53dc95bc9..14c08c4af4 100644
--- a/core/src/main/java/brooklyn/util/task/SingleThreadedScheduler.java
+++ b/core/src/main/java/brooklyn/util/task/SingleThreadedScheduler.java
@@ -18,7 +18,6 @@
  */
 package brooklyn.util.task;
 
-import java.util.Map;
 import java.util.Queue;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CancellationException;
@@ -50,6 +49,7 @@ public class SingleThreadedScheduler implements TaskScheduler, CanSetName {
     private static final Logger LOG = LoggerFactory.getLogger(SingleThreadedScheduler.class);
     
     private final Queue<QueuedSubmission<?>> order = new ConcurrentLinkedQueue<QueuedSubmission<?>>();
+    private int queueSize = 0;
     private final AtomicBoolean running = new AtomicBoolean(false);
     
     private ExecutorService executor;
@@ -78,10 +78,13 @@ public synchronized <T> Future<T> submit(Callable<T> c) {
         } else {
             WrappingFuture<T> f = new WrappingFuture<T>();
             order.add(new QueuedSubmission<T>(c, f));
-            int size = order.size();
-            if (size>0 && (size == 50 || (size<=500 && (size%100)==0) || (size%1000)==0) && size!=lastSizeWarn) {
-                LOG.warn("{} is backing up, {} tasks queued", this, size);
-                lastSizeWarn = size;
+            queueSize++;
+            if (queueSize>0 && (queueSize == 50 || (queueSize<=500 && (queueSize%100)==0) || (queueSize%1000)==0) && queueSize!=lastSizeWarn) {
+                LOG.warn("{} is backing up, {} tasks queued", this, queueSize);
+                if (LOG.isDebugEnabled()) {
+                    LOG.debug("Task queue backing up detail, queue "+this+"; task context is "+Tasks.current()+"; latest task is "+c+"; first task is "+order.peek());
+                }
+                lastSizeWarn = queueSize;
             }
             return f;
         }
@@ -97,6 +100,7 @@ private synchronized void onEnd() {
                 done = true;
             } else {
                 QueuedSubmission<?> qs = order.remove();
+                queueSize--;
                 if (!qs.f.isCancelled()) {
                     Future future = executeNow(qs.c);
                     qs.f.setDelegate(future);
@@ -126,6 +130,11 @@ private synchronized <T> Future<T> executeNow(final Callable<T> c) {
             this.c = c;
             this.f = f;
         }
+        
+        @Override
+        public String toString() {
+            return "QueuedSubmission["+c+"]@"+Integer.toHexString(System.identityHashCode(this));
+        }
     }
     
     /**
diff --git a/core/src/main/java/brooklyn/util/task/TaskBuilder.java b/core/src/main/java/brooklyn/util/task/TaskBuilder.java
index 35dd8bc787..ed3e2828d9 100644
--- a/core/src/main/java/brooklyn/util/task/TaskBuilder.java
+++ b/core/src/main/java/brooklyn/util/task/TaskBuilder.java
@@ -18,10 +18,9 @@
  */
 package brooklyn.util.task;
 
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Callable;
 
@@ -30,7 +29,9 @@
 import brooklyn.management.TaskFactory;
 import brooklyn.management.TaskQueueingContext;
 import brooklyn.util.JavaGroovyEquivalents;
+import brooklyn.util.collections.MutableList;
 import brooklyn.util.collections.MutableMap;
+import brooklyn.util.collections.MutableSet;
 
 import com.google.common.collect.Iterables;
 
@@ -41,8 +42,9 @@
     String description = null;
     Callable<T> body = null;
     Boolean swallowChildrenFailures = null;
-    List<TaskAdaptable<?>> children = new ArrayList<TaskAdaptable<?>>();
-    Set<Object> tags = new LinkedHashSet<Object>();
+    List<TaskAdaptable<?>> children = MutableList.of();
+    Set<Object> tags = MutableSet.of();
+    Map<String,Object> flags = MutableMap.of();
     Boolean dynamic = null;
     boolean parallel = false;
     
@@ -112,18 +114,30 @@ public TaskBuilder<T> tag(Object tag) {
         tags.add(tag);
         return this;
     }
+    
+    /** adds a flag to the given task */
+    public TaskBuilder<T> flag(String flag, Object value) {
+        flags.put(flag, value);
+        return this;
+    }
+
+    /** adds the given flags to the given task */
+    public TaskBuilder<T> flags(Map<String,Object> flags) {
+        this.flags.putAll(flags);
+        return this;
+    }
 
     @SuppressWarnings({ "unchecked", "rawtypes" })
     public Task<T> build() {
-        MutableMap<String, Object> flags = MutableMap.of();
-        if (name!=null) flags.add("displayName", name);
-        if (description!=null) flags.add("description", description);
-        if (!tags.isEmpty()) flags.add("tags", tags);
+        MutableMap<String, Object> taskFlags = MutableMap.copyOf(flags);
+        if (name!=null) taskFlags.put("displayName", name);
+        if (description!=null) taskFlags.put("description", description);
+        if (!tags.isEmpty()) taskFlags.put("tags", tags);
         
         if (Boolean.FALSE.equals(dynamic) && children.isEmpty()) {
             if (swallowChildrenFailures!=null)
                 throw new IllegalArgumentException("Cannot set swallowChildrenFailures for non-dynamic task: "+this);
-            return new BasicTask<T>(flags, body);
+            return new BasicTask<T>(taskFlags, body);
         }
         
         // prefer dynamic set unless (a) user has said not dynamic, or (b) it's parallel (since there is no dynamic parallel yet)
@@ -132,7 +146,7 @@ public Task<T> build() {
         if (Boolean.TRUE.equals(dynamic) || (dynamic==null && !parallel)) {
             if (parallel)
                 throw new UnsupportedOperationException("No implementation of parallel dynamic aggregate task available");
-            DynamicSequentialTask<T> result = new DynamicSequentialTask<T>(flags, body);
+            DynamicSequentialTask<T> result = new DynamicSequentialTask<T>(taskFlags, body);
             if (swallowChildrenFailures!=null && swallowChildrenFailures.booleanValue()) result.swallowChildrenFailures();
             for (TaskAdaptable t: children)
                 result.queue(t.asTask());
@@ -148,9 +162,9 @@ public Task<T> build() {
         }
         
         if (parallel)
-            return new ParallelTask(flags, children);
+            return new ParallelTask(taskFlags, children);
         else
-            return new SequentialTask(flags, children);
+            return new SequentialTask(taskFlags, children);
     }
 
     /** returns a a factory based on this builder */
diff --git a/core/src/main/java/brooklyn/util/task/TaskInternal.java b/core/src/main/java/brooklyn/util/task/TaskInternal.java
index 5a797bc602..d3a4ce88c9 100644
--- a/core/src/main/java/brooklyn/util/task/TaskInternal.java
+++ b/core/src/main/java/brooklyn/util/task/TaskInternal.java
@@ -53,8 +53,8 @@
     Future<T> getResult();
     
     boolean isQueuedOrSubmitted();
-
     boolean isQueuedAndNotSubmitted();
+    boolean isQueued();
 
     /** marks the task as queued for execution */
     void markQueued();
diff --git a/core/src/main/java/brooklyn/util/task/Tasks.java b/core/src/main/java/brooklyn/util/task/Tasks.java
index 277f677482..9a7a0629f6 100644
--- a/core/src/main/java/brooklyn/util/task/Tasks.java
+++ b/core/src/main/java/brooklyn/util/task/Tasks.java
@@ -327,6 +327,14 @@ public static boolean isAncestorCancelled(Task<?> t) {
         return isAncestorCancelled(t.getSubmittedByTask());
     }
 
+    public static boolean isQueued(TaskAdaptable<?> task) {
+        return ((TaskInternal<?>)task.asTask()).isQueued();
+    }
+
+    public static boolean isSubmitted(TaskAdaptable<?> task) {
+        return ((TaskInternal<?>)task.asTask()).isSubmitted();
+    }
+    
     public static boolean isQueuedOrSubmitted(TaskAdaptable<?> task) {
         return ((TaskInternal<?>)task.asTask()).isQueuedOrSubmitted();
     }
@@ -336,7 +344,7 @@ public static boolean isQueuedOrSubmitted(TaskAdaptable<?> task) {
      * @return true if the task was added, false otherwise.
      */
     public static boolean tryQueueing(TaskQueueingContext adder, TaskAdaptable<?> task) {
-        if (task==null || isQueuedOrSubmitted(task))
+        if (task==null || isQueued(task))
             return false;
         try {
             adder.queue(task.asTask());
@@ -408,6 +416,10 @@ public static Task<Void> fail(final String name, final Throwable optionalError)
             if (optionalError!=null) throw Exceptions.propagate(optionalError); else throw new RuntimeException("Failed: "+name);
         } }).build();
     }
+    public static Task<Void> warning(final String message, final Throwable optionalError) {
+        log.warn(message);
+        return TaskTags.markInessential(fail(message, optionalError));
+    }
 
     /** marks the current task inessential; this mainly matters if the task is running in a parent
      * {@link TaskQueueingContext} and we don't want the parent to fail if this task fails
diff --git a/core/src/main/java/brooklyn/util/task/ssh/SshTasks.java b/core/src/main/java/brooklyn/util/task/ssh/SshTasks.java
index 652a083795..6a0a63e904 100644
--- a/core/src/main/java/brooklyn/util/task/ssh/SshTasks.java
+++ b/core/src/main/java/brooklyn/util/task/ssh/SshTasks.java
@@ -44,6 +44,7 @@
 import brooklyn.util.net.Urls;
 import brooklyn.util.ssh.BashCommands;
 import brooklyn.util.stream.Streams;
+import brooklyn.util.task.DynamicTasks;
 import brooklyn.util.task.Tasks;
 import brooklyn.util.task.ssh.internal.PlainSshExecTaskFactory;
 import brooklyn.util.task.system.ProcessTaskFactory;
@@ -144,8 +145,13 @@ public static ProcessTaskFactory<Boolean> dontRequireTtyForSudo(SshMachineLocati
             .returning(new Function<ProcessTaskWrapper<?>,Boolean>() { public Boolean apply(ProcessTaskWrapper<?> task) {
                 if (task.getExitCode()==0 && task.getStdout().contains("sudo-is-working-"+id)) return true;
                 Entity entity = BrooklynTaskTags.getTargetOrContextEntity(Tasks.current());
-                log.warn("Error setting up sudo for "+task.getMachine().getUser()+"@"+task.getMachine().getAddress().getHostName()+" "+
-                        " (exit code "+task.getExitCode()+(entity!=null ? ", entity "+entity : "")+")");
+                
+                // TODO if in a queueing context can we mark this task inessential and throw?
+                // that way user sees the message...
+                String message = "Error setting up sudo for "+task.getMachine().getUser()+"@"+task.getMachine().getAddress().getHostName()+" "+
+                        " (exit code "+task.getExitCode()+(entity!=null ? ", entity "+entity : "")+")";
+                DynamicTasks.queueIfPossible(Tasks.warning(message, null));
+                
                 Streams.logStreamTail(log, "STDERR of sudo setup problem", Streams.byteArrayOfString(task.getStderr()), 1024);
                 if (requireSuccess) {
                     throw new IllegalStateException("Passwordless sudo is required for "+task.getMachine().getUser()+"@"+task.getMachine().getAddress().getHostName()+
diff --git a/core/src/test/java/brooklyn/entity/effector/EffectorBasicTest.java b/core/src/test/java/brooklyn/entity/effector/EffectorBasicTest.java
index e435445104..66618f8116 100644
--- a/core/src/test/java/brooklyn/entity/effector/EffectorBasicTest.java
+++ b/core/src/test/java/brooklyn/entity/effector/EffectorBasicTest.java
@@ -19,6 +19,7 @@
 package brooklyn.entity.effector;
 
 import java.util.List;
+import java.util.concurrent.Callable;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -30,13 +31,17 @@
 import brooklyn.entity.basic.Entities;
 import brooklyn.entity.basic.EntityLocal;
 import brooklyn.entity.proxying.EntitySpec;
+import brooklyn.entity.trait.FailingEntity;
 import brooklyn.entity.trait.Startable;
 import brooklyn.location.basic.SimulatedLocation;
+import brooklyn.management.HasTaskChildren;
 import brooklyn.management.Task;
 import brooklyn.management.internal.ManagementContextInternal;
 import brooklyn.test.TestUtils;
 import brooklyn.test.entity.TestEntity;
 import brooklyn.util.collections.MutableMap;
+import brooklyn.util.exceptions.Exceptions;
+import brooklyn.util.task.Tasks;
 
 import com.google.common.collect.ImmutableList;
 
@@ -75,7 +80,6 @@ public void testInvokeEffectorStartWithArgs() {
         TestUtils.assertSetsEqual(locs, app.getLocations());
     }
 
-
     @Test
     public void testInvokeEffectorStartWithTwoEntities() {
         TestEntity entity = app.createAndManageChild(EntitySpec.create(TestEntity.class));
@@ -92,5 +96,89 @@ public void testInvokeEffectorTaskHasTag() {
 //        log.info("TAGS: "+starting.getTags());
         Assert.assertTrue(starting.getTags().contains(ManagementContextInternal.EFFECTOR_TAG));
     }
+
+    // check various failure situations
+    
+    private FailingEntity createFailingEntity() {
+        FailingEntity entity = app.createAndManageChild(EntitySpec.create(FailingEntity.class)
+            .configure(FailingEntity.FAIL_ON_START, true));
+        return entity;
+    }
+
+    // uncaught failures are propagates
+    
+    @Test
+    public void testInvokeEffectorStartFailing_Method() {
+        FailingEntity entity = createFailingEntity();
+        assertStartMethodFails(entity);
+    }
+
+    @Test
+    public void testInvokeEffectorStartFailing_EntityInvoke() {
+        FailingEntity entity = createFailingEntity();
+        assertTaskFails( entity.invoke(Startable.START, MutableMap.of("locations", locs)) );
+    }
+     
+    @Test
+    public void testInvokeEffectorStartFailing_EntitiesInvoke() {
+        FailingEntity entity = createFailingEntity();
+        
+        assertTaskFails( Entities.invokeEffectorWithArgs(entity, entity, Startable.START, locs) );
+    }
+
+    // caught failures are NOT propagated!
+    
+    @Test
+    public void testInvokeEffectorStartFailing_MethodInDynamicTask() {
+        Task<Void> task = app.getExecutionContext().submit(Tasks.<Void>builder().dynamic(true).body(new Callable<Void>() {
+            @Override public Void call() throws Exception {
+                testInvokeEffectorStartFailing_Method();
+                return null;
+            }
+        }).build());
+        
+        assertTaskSucceeds(task);
+        assertTaskHasFailedChild(task);
+    }
+
+    @Test
+    public void testInvokeEffectorStartFailing_MethodInTask() {
+        Task<Void> task = app.getExecutionContext().submit(Tasks.<Void>builder().dynamic(false).body(new Callable<Void>() {
+            @Override public Void call() throws Exception {
+                testInvokeEffectorStartFailing_Method();
+                return null;
+            }
+        }).build());
+        
+        assertTaskSucceeds(task);
+    }
+
+    private void assertTaskSucceeds(Task<Void> task) {
+        task.getUnchecked();
+        Assert.assertFalse(task.isError());
+    }
+
+    private void assertTaskHasFailedChild(Task<Void> task) {
+        Assert.assertTrue(Tasks.failed( ((HasTaskChildren)task).getChildren() ).iterator().hasNext());
+    }
+        
+    private void assertStartMethodFails(FailingEntity entity) {
+        try {
+            entity.start(locs);
+            Assert.fail("Should have failed");
+        } catch (Exception e) {
+            // expected
+        }
+    }
+     
+    protected void assertTaskFails(Task<?> t) {
+        try {
+            t.get();
+            Assert.fail("Should have failed");
+        } catch (Exception e) {
+            Exceptions.propagateIfFatal(e);
+            // expected
+        }
+    }
     
 }
diff --git a/core/src/test/java/brooklyn/entity/group/DynamicClusterTest.java b/core/src/test/java/brooklyn/entity/group/DynamicClusterTest.java
index ebdd5fe081..298d6d2e50 100644
--- a/core/src/test/java/brooklyn/entity/group/DynamicClusterTest.java
+++ b/core/src/test/java/brooklyn/entity/group/DynamicClusterTest.java
@@ -39,6 +39,7 @@
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
 
+import org.testng.Assert;
 import org.testng.annotations.BeforeMethod;
 import org.testng.annotations.Test;
 
@@ -349,7 +350,7 @@ public void failingEntitiesDontBreakClusterActions() throws Exception {
                     }}));
 
         cluster.start(ImmutableList.of(loc));
-        cluster.resize(3);
+        resizeExpectingError(cluster, 3);
         assertEquals(cluster.getCurrentSize(), (Integer)2);
         assertEquals(cluster.getMembers().size(), 2);
         for (Entity member : cluster.getMembers()) {
@@ -357,6 +358,20 @@ public void failingEntitiesDontBreakClusterActions() throws Exception {
         }
     }
 
+    static Exception resizeExpectingError(DynamicCluster cluster, int size) {
+        try {
+            cluster.resize(size);
+            Assert.fail("Resize should have failed");
+            // unreachable:
+            return null;
+        } catch (Exception e) {
+            Exceptions.propagateIfFatal(e);
+            // expect: brooklyn.util.exceptions.PropagatedRuntimeException: Error invoking resize at DynamicClusterImpl{id=I9Ggxfc1}: 1 of 3 parallel child tasks failed: Simulating entity stop failure for test
+            Assert.assertTrue(e.toString().contains("resize"));
+            return e;
+        }
+    }
+
     @Test
     public void testInitialQuorumSizeSufficientForStartup() throws Exception {
         final int failNum = 1;
@@ -447,7 +462,7 @@ public void testCanQuarantineFailedEntities() throws Exception {
                     }}));
 
         cluster.start(ImmutableList.of(loc));
-        cluster.resize(3);
+        resizeExpectingError(cluster, 3);
         assertEquals(cluster.getCurrentSize(), (Integer)2);
         assertEquals(cluster.getMembers().size(), 2);
         assertEquals(Iterables.size(Iterables.filter(cluster.getChildren(), Predicates.instanceOf(FailingEntity.class))), 3);
@@ -484,7 +499,7 @@ public void testDoNotQuarantineFailedEntities() throws Exception {
         assertEquals(cluster.getChildren().size(), 0, "children="+cluster.getChildren());
         
         // Failed node will not be a member or child
-        cluster.resize(3);
+        resizeExpectingError(cluster, 3);
         assertEquals(cluster.getCurrentSize(), (Integer)2);
         assertEquals(cluster.getMembers().size(), 2);
         assertEquals(cluster.getChildren().size(), 2, "children="+cluster.getChildren());
diff --git a/core/src/test/java/brooklyn/entity/group/DynamicClusterWithAvailabilityZonesTest.java b/core/src/test/java/brooklyn/entity/group/DynamicClusterWithAvailabilityZonesTest.java
index 569f99f80e..6574400b5e 100644
--- a/core/src/test/java/brooklyn/entity/group/DynamicClusterWithAvailabilityZonesTest.java
+++ b/core/src/test/java/brooklyn/entity/group/DynamicClusterWithAvailabilityZonesTest.java
@@ -154,9 +154,9 @@ public void testAbandonsFailingZone() throws Exception {
         String otherLoc = (locUsed.equals("zone1") ? "zone2" : "zone1");
         
         // This entity will fail; configured to give up on that zone after just two failure
-        cluster.resize(2);
+        DynamicClusterTest.resizeExpectingError(cluster, 2);
         assertEquals(cluster.getCurrentSize(), (Integer)1);
-        cluster.resize(2);
+        DynamicClusterTest.resizeExpectingError(cluster, 2);
         assertEquals(cluster.getCurrentSize(), (Integer)1);
         
         cluster.resize(3);
diff --git a/docs/use/guide/quickstart/policies-and-catalogs.md b/docs/use/guide/quickstart/policies-and-catalogs.md
index efa06ff10d..f649cf94cb 100644
--- a/docs/use/guide/quickstart/policies-and-catalogs.md
+++ b/docs/use/guide/quickstart/policies-and-catalogs.md
@@ -26,7 +26,7 @@ Now when we open the web console, two applications are displayed from the catalo
 
 Select the 'Demo Web Cluster with DB' and click 'Next'.
 
-[![Viewing Catalog entries in Add Application dialog.](images/add-application-catalog-web-cluster-with-db.png)](add-application-catalog-web-cluster-with-db-largea.png)
+[![Viewing Catalog entries in Add Application dialog.](images/add-application-catalog-web-cluster-with-db.png)](add-application-catalog-web-cluster-with-db-large.png)
 
 Select the Location that Brooklyn should deploy to, and name your application:
 
@@ -58,7 +58,7 @@ As load is added, Brooklyn requests a new cloud machine, creates a new app serve
 
 ### Next
 
-The [Elastic Web Cluster Example]({{site.url}}/use/examples/webcluster/index.html) page
+The [Elastic Web Cluster Example]({{site.url}}use/examples/webcluster/index.html) page
 details how to build this demo application from scratch in Java. It shows in more detail how Brooklyn can
 complement your application with policy driven management, and how applications can be
 run from the command line.
diff --git a/locations/jclouds/src/main/java/brooklyn/location/jclouds/JcloudsLocation.java b/locations/jclouds/src/main/java/brooklyn/location/jclouds/JcloudsLocation.java
index e27e16c695..0736a7d3d8 100644
--- a/locations/jclouds/src/main/java/brooklyn/location/jclouds/JcloudsLocation.java
+++ b/locations/jclouds/src/main/java/brooklyn/location/jclouds/JcloudsLocation.java
@@ -110,6 +110,7 @@
 import brooklyn.util.config.ConfigBag;
 import brooklyn.util.exceptions.CompoundRuntimeException;
 import brooklyn.util.exceptions.Exceptions;
+import brooklyn.util.exceptions.ReferenceWithError;
 import brooklyn.util.flags.SetFromFlag;
 import brooklyn.util.flags.TypeCoercions;
 import brooklyn.util.guava.Maybe;
@@ -193,6 +194,8 @@ public class JcloudsLocation extends AbstractCloudMachineProvisioningLocation im
     @SetFromFlag // so it's persisted
     private final Map<JcloudsSshMachineLocation,String> vmInstanceIds = Maps.newLinkedHashMap();
     
+    static { Networking.init(); }
+    
     public JcloudsLocation() {
         super();
     }
@@ -1733,16 +1736,16 @@ public Boolean call() {
         
         Stopwatch stopwatch = Stopwatch.createStarted();
         
-        boolean reachable = new Repeater()
+        ReferenceWithError<Boolean> reachable = new Repeater()
             .every(1,SECONDS)
             .until(checker)
             .limitTimeTo(delayMs, MILLISECONDS)
-            .run();
+            .runKeepingError();
 
-        if (!reachable) {
+        if (!reachable.getMaskingError()) {
             throw new IllegalStateException("SSH failed for "+
                     user+"@"+vmIp+" ("+setup.getDescription()+") after waiting "+
-                    Time.makeTimeStringRounded(delayMs));
+                    Time.makeTimeStringRounded(delayMs), reachable.getError());
         }
         
         LOG.debug("VM {}: is sshable after {} on {}@{}",new Object[] {
diff --git a/locations/jclouds/src/main/java/brooklyn/location/jclouds/JcloudsUtil.java b/locations/jclouds/src/main/java/brooklyn/location/jclouds/JcloudsUtil.java
index f3fdb34ce8..9bb6027b4a 100644
--- a/locations/jclouds/src/main/java/brooklyn/location/jclouds/JcloudsUtil.java
+++ b/locations/jclouds/src/main/java/brooklyn/location/jclouds/JcloudsUtil.java
@@ -76,6 +76,7 @@
 import brooklyn.util.collections.MutableList;
 import brooklyn.util.collections.MutableMap;
 import brooklyn.util.config.ConfigBag;
+import brooklyn.util.exceptions.Exceptions;
 import brooklyn.util.net.Protocol;
 import brooklyn.util.ssh.BashCommands;
 import brooklyn.util.ssh.IptablesCommands;
@@ -387,7 +388,19 @@ public static String getFirstReachableAddress(ComputeServiceContext context, Nod
         //     jclouds.ssh.max-retries
         //     jclouds.ssh.retry-auth
 
-        final SshClient client = context.utils().sshForNode().apply(node);
+        SshClient client;
+        try {
+            client = context.utils().sshForNode().apply(node);
+        } catch (Exception e) {
+            Exceptions.propagateIfFatal(e);
+            /* i've seen: java.lang.IllegalStateException: Optional.get() cannot be called on an absent value
+             * from org.jclouds.crypto.ASN1Codec.createASN1Sequence(ASN1Codec.java:86), if the ssh key has a passphrase, against AWS.
+             * 
+             * others have reported: java.lang.IllegalArgumentException: DER length more than 4 bytes
+             * when using a key with a passphrase (perhaps from other clouds?); not sure if that's this callpath or a different one.
+             */
+            throw new IllegalStateException("Unable to connect SshClient to "+node+"; check that the node is accessible and that the SSH key exists and is correctly configured, including any passphrase defined", e);
+        }
         return client.getHostAddress();
     }
     
diff --git a/software/base/src/main/java/brooklyn/entity/basic/AbstractSoftwareProcessSshDriver.java b/software/base/src/main/java/brooklyn/entity/basic/AbstractSoftwareProcessSshDriver.java
index 6b4e153781..198b9793e7 100644
--- a/software/base/src/main/java/brooklyn/entity/basic/AbstractSoftwareProcessSshDriver.java
+++ b/software/base/src/main/java/brooklyn/entity/basic/AbstractSoftwareProcessSshDriver.java
@@ -588,7 +588,7 @@ protected ScriptHelper newScript(Map<String, ?> flags, String phase) {
             }
             if (INSTALLING.equals(phase)) {
                 // mutexId should be global because otherwise package managers will contend with each other 
-                s.useMutex(getLocation(), "installing", "installing "+elvis(entity,this));
+                s.useMutex(getLocation(), "installation lock at host", "installing "+elvis(entity,this));
                 s.header.append(
                         "export INSTALL_DIR=\""+getInstallDir()+"\"",
                         "mkdir -p $INSTALL_DIR",
diff --git a/software/base/src/main/java/brooklyn/entity/basic/lifecycle/NaiveScriptRunner.java b/software/base/src/main/java/brooklyn/entity/basic/lifecycle/NaiveScriptRunner.java
index 409b10e79b..670b1df783 100644
--- a/software/base/src/main/java/brooklyn/entity/basic/lifecycle/NaiveScriptRunner.java
+++ b/software/base/src/main/java/brooklyn/entity/basic/lifecycle/NaiveScriptRunner.java
@@ -37,6 +37,7 @@ public interface NaiveScriptRunner {
      *  out, err as output/error streams;
      *  logPrefix, prefix string to put in log output;
      *  env, map of environment vars to pass to shell environment */
+    @SuppressWarnings("rawtypes")
     int execute(Map flags, List<String> script, String summaryForLogging);
 
 }
diff --git a/software/base/src/main/java/brooklyn/entity/basic/lifecycle/ScriptHelper.java b/software/base/src/main/java/brooklyn/entity/basic/lifecycle/ScriptHelper.java
index 6854eb0ba9..e60e1d781d 100644
--- a/software/base/src/main/java/brooklyn/entity/basic/lifecycle/ScriptHelper.java
+++ b/software/base/src/main/java/brooklyn/entity/basic/lifecycle/ScriptHelper.java
@@ -66,6 +66,7 @@ public class ScriptHelper {
     public final ScriptPart body = new ScriptPart(this);
     public final ScriptPart footer = new ScriptPart(this);
     
+    @SuppressWarnings("rawtypes")
     protected final Map flags = new LinkedHashMap();
     protected Predicate<? super Integer> resultCodeCheck = Predicates.alwaysTrue();
     protected Predicate<? super ScriptHelper> executionCheck = Predicates.alwaysTrue();
@@ -86,6 +87,7 @@ public ScriptHelper(NaiveScriptRunner runner, String summary) {
      * Takes a closure which accepts this ScriptHelper and returns true or false
      * as to whether the script needs to run (or can throw error if desired)
      */
+    @SuppressWarnings({ "rawtypes", "unchecked" })
     public ScriptHelper executeIf(Closure c) {
         Predicate<ScriptHelper> predicate = GroovyJavaMethods.predicateFromClosure(c);
         return executeIf(predicate);
@@ -174,6 +176,7 @@ public boolean apply(@Nullable Integer input) {
      * closure always returns true (and the exit code is made available to the
      * caller if they care)
      */
+    @SuppressWarnings({ "rawtypes", "unchecked" })
     public ScriptHelper requireResultCode(Closure integerFilter) {
         Predicate<Integer> objectPredicate = GroovyJavaMethods.predicateFromClosure(integerFilter);
         return requireResultCode(objectPredicate);
@@ -312,6 +315,7 @@ public int execute() {
         }
     }
     
+    @SuppressWarnings({ "rawtypes", "unchecked" })
     public int executeInternal() {
         if (!executionCheck.apply(this)) {
             return 0;
@@ -358,10 +362,12 @@ protected RuntimeException logWithDetailsAndThrow(String message, Throwable opti
         throw new IllegalStateException(message);
     }
 
+    @SuppressWarnings("rawtypes")
     public Map getFlags() {
         return flags;
     }
     
+    @SuppressWarnings("unchecked")
     public ScriptHelper setFlag(String flag, Object value) {
         flags.put(flag, value);
         return this;
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/ControlledDynamicWebAppCluster.java b/software/webapp/src/main/java/brooklyn/entity/webapp/ControlledDynamicWebAppCluster.java
index 9fef09c9a1..0c263d95fc 100644
--- a/software/webapp/src/main/java/brooklyn/entity/webapp/ControlledDynamicWebAppCluster.java
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/ControlledDynamicWebAppCluster.java
@@ -57,8 +57,8 @@
  * members has no effect on the members of the underlying DynamicCluster - treat this as a read-only view.
  */
 @ImplementedBy(ControlledDynamicWebAppClusterImpl.class)
-public interface ControlledDynamicWebAppCluster extends DynamicGroup, Entity, Startable, Resizable, MemberReplaceable, Group, ElasticJavaWebAppService {
-
+public interface ControlledDynamicWebAppCluster extends DynamicGroup, Entity, Startable, Resizable, MemberReplaceable, Group, ElasticJavaWebAppService, JavaWebAppService.CanDeployAndUndeploy, JavaWebAppService.CanRedeployAll {
+    
     @SetFromFlag("initialSize")
     public static ConfigKey<Integer> INITIAL_SIZE = ConfigKeys.newConfigKeyWithDefault(Cluster.INITIAL_SIZE, 1);
 
@@ -66,20 +66,24 @@ public interface ControlledDynamicWebAppCluster extends DynamicGroup, Entity, St
     public static BasicAttributeSensorAndConfigKey<LoadBalancer> CONTROLLER = new BasicAttributeSensorAndConfigKey<LoadBalancer>(
         LoadBalancer.class, "controlleddynamicwebappcluster.controller", "Controller for the cluster; if null a default will created (using controllerSpec)");
 
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     @SetFromFlag("controllerSpec")
     public static BasicAttributeSensorAndConfigKey<EntitySpec<? extends LoadBalancer>> CONTROLLER_SPEC = new BasicAttributeSensorAndConfigKey(
             EntitySpec.class, "controlleddynamicwebappcluster.controllerSpec", "Spec for creating the controller (if one not supplied explicitly); if null an NGINX instance will be created");
 
+    @SuppressWarnings({ "unchecked", "rawtypes", "deprecation" })
     /** factory (or closure) to create the web server, given flags */
     @SetFromFlag("factory")
     public static BasicAttributeSensorAndConfigKey<ConfigurableEntityFactory<? extends WebAppService>> FACTORY = new BasicAttributeSensorAndConfigKey(
             ConfigurableEntityFactory.class, DynamicCluster.FACTORY.getName(), "factory (or closure) to create the web server");
 
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     /** Spec for web server entiites to be created */
     @SetFromFlag("memberSpec")
     public static BasicAttributeSensorAndConfigKey<EntitySpec<? extends WebAppService>> MEMBER_SPEC = new BasicAttributeSensorAndConfigKey(
             EntitySpec.class, DynamicCluster.MEMBER_SPEC.getName(), "Spec for web server entiites to be created");
 
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     @SetFromFlag("webClusterSpec")
     public static BasicAttributeSensorAndConfigKey<EntitySpec<? extends DynamicWebAppCluster>> WEB_CLUSTER_SPEC = new BasicAttributeSensorAndConfigKey(
             EntitySpec.class, "controlleddynamicwebappcluster.webClusterSpec", "Spec for creating the cluster; if null a DynamicWebAppCluster will be created");
@@ -91,9 +95,11 @@ public interface ControlledDynamicWebAppCluster extends DynamicGroup, Entity, St
 
     public static final AttributeSensor<Lifecycle> SERVICE_STATE = Attributes.SERVICE_STATE;
 
+    
     public LoadBalancer getController();
     
     public ConfigurableEntityFactory<WebAppService> getFactory();
     
     public DynamicWebAppCluster getCluster();
+    
 }
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/ControlledDynamicWebAppClusterImpl.java b/software/webapp/src/main/java/brooklyn/entity/webapp/ControlledDynamicWebAppClusterImpl.java
index acb2327a4d..47e7ec93f2 100644
--- a/software/webapp/src/main/java/brooklyn/entity/webapp/ControlledDynamicWebAppClusterImpl.java
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/ControlledDynamicWebAppClusterImpl.java
@@ -49,7 +49,6 @@
 import brooklyn.util.collections.MutableMap;
 import brooklyn.util.exceptions.Exceptions;
 
-import com.google.common.base.Predicate;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Lists;
 
@@ -61,7 +60,7 @@ public ControlledDynamicWebAppClusterImpl() {
         this(MutableMap.of(), null);
     }
     
-    public ControlledDynamicWebAppClusterImpl(Map flags) {
+    public ControlledDynamicWebAppClusterImpl(Map<?,?> flags) {
         this(flags, null);
     }
     
@@ -69,7 +68,8 @@ public ControlledDynamicWebAppClusterImpl(Entity parent) {
         this(MutableMap.of(), parent);
     }
     
-    public ControlledDynamicWebAppClusterImpl(Map flags, Entity parent) {
+    @Deprecated
+    public ControlledDynamicWebAppClusterImpl(Map<?,?> flags, Entity parent) {
         super(flags, parent);
         setAttribute(SERVICE_UP, false);
     }
@@ -106,6 +106,7 @@ public void init() {
             webClusterSpec = EntitySpec.create(DynamicWebAppCluster.class);
         }
         boolean hasMemberSpec = webClusterSpec.getConfig().containsKey(DynamicWebAppCluster.MEMBER_SPEC) || webClusterSpec.getFlags().containsKey("memberSpec");
+        @SuppressWarnings("deprecation")
         boolean hasMemberFactory = webClusterSpec.getConfig().containsKey(DynamicWebAppCluster.FACTORY) || webClusterSpec.getFlags().containsKey("factory");
         if (!(hasMemberSpec || hasMemberFactory)) {
             webClusterSpec.configure(webClusterFlags);
@@ -159,6 +160,7 @@ public LoadBalancer getController() {
         return getAttribute(CONTROLLER);
     }
 
+    @SuppressWarnings("unchecked")
     @Override
     public synchronized ConfigurableEntityFactory<WebAppService> getFactory() {
         return (ConfigurableEntityFactory<WebAppService>) getAttribute(FACTORY);
@@ -307,10 +309,21 @@ public Integer getCurrentSize() {
         return getCluster().getCurrentSize();
     }
 
-    private Entity findChildOrNull(Predicate<? super Entity> predicate) {
-        for (Entity contender : getChildren()) {
-            if (predicate.apply(contender)) return contender;
-        }
-        return null;
+    @Override
+    public void deploy(String url, String targetName) {
+        DynamicWebAppClusterImpl.addToWarsByContext(this, url, targetName);
+        getCluster().deploy(url, targetName);
+    }
+
+    @Override
+    public void undeploy(String targetName) {
+        DynamicWebAppClusterImpl.removeFromWarsByContext(this, targetName);
+        getCluster().undeploy(targetName);
     }
+
+    @Override
+    public void redeployAll() {
+        getCluster().redeployAll();
+    }
+
 }
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppCluster.java b/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppCluster.java
index e561c56f57..04ec69e1e7 100644
--- a/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppCluster.java
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppCluster.java
@@ -35,7 +35,7 @@
  * </ul>
  */
 @ImplementedBy(DynamicWebAppClusterImpl.class)
-public interface DynamicWebAppCluster extends DynamicCluster, WebAppService {
+public interface DynamicWebAppCluster extends DynamicCluster, WebAppService, JavaWebAppService, JavaWebAppService.CanDeployAndUndeploy, JavaWebAppService.CanRedeployAll {
 
     public static final AttributeSensor<Double> REQUEST_COUNT_PER_NODE = new BasicAttributeSensor<Double>(
             Double.class, "webapp.reqs.total.perNode", "Cluster entity request average");
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppClusterImpl.java b/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppClusterImpl.java
index 360870f83c..1b401953f3 100644
--- a/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppClusterImpl.java
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppClusterImpl.java
@@ -18,17 +18,41 @@
  */
 package brooklyn.entity.webapp;
 
+import static com.google.common.base.Preconditions.checkNotNull;
+
 import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Callable;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import brooklyn.enricher.Enrichers;
 import brooklyn.entity.Entity;
+import brooklyn.entity.basic.Attributes;
+import brooklyn.entity.basic.Entities;
+import brooklyn.entity.basic.EntityInternal;
+import brooklyn.entity.effector.Effectors;
 import brooklyn.entity.group.DynamicCluster;
 import brooklyn.entity.group.DynamicClusterImpl;
 import brooklyn.event.AttributeSensor;
 import brooklyn.event.SensorEvent;
 import brooklyn.event.SensorEventListener;
+import brooklyn.management.Task;
+import brooklyn.management.TaskAdaptable;
+import brooklyn.util.collections.MutableMap;
+import brooklyn.util.collections.MutableSet;
+import brooklyn.util.exceptions.Exceptions;
+import brooklyn.util.task.DynamicTasks;
+import brooklyn.util.task.TaskBuilder;
+import brooklyn.util.task.TaskTags;
+import brooklyn.util.task.Tasks;
+import brooklyn.util.time.Duration;
+import brooklyn.util.time.Time;
 
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.Iterables;
 
 /**
  * DynamicWebAppClusters provide cluster-wide aggregates of entity attributes.  Currently totals and averages:
@@ -41,6 +65,9 @@
  */
 public class DynamicWebAppClusterImpl extends DynamicClusterImpl implements DynamicWebAppCluster {
 
+    private static final Logger log = LoggerFactory.getLogger(DynamicWebAppClusterImpl.class);
+    private static final FilenameToWebContextMapper FILENAME_TO_WEB_CONTEXT_MAPPER = new FilenameToWebContextMapper();
+    
     /**
      * Instantiate a new DynamicWebAppCluster.  Parameters as per {@link DynamicCluster#DynamicCluster()}
      */
@@ -82,7 +109,9 @@ public void onManagementBecomingMaster() {
         }
         
         for (List<? extends AttributeSensor<? extends Number>> es : averagingEnricherSetup) {
+            @SuppressWarnings("unchecked")
             AttributeSensor<Number> t = (AttributeSensor<Number>) es.get(0);
+            @SuppressWarnings("unchecked")
             AttributeSensor<Double> average = (AttributeSensor<Double>) es.get(1);
             addEnricher(Enrichers.builder()
                     .aggregating(t)
@@ -127,4 +156,143 @@ protected boolean calculateServiceUp() {
         }
         return up;
     }
+    
+    // TODO this will probably be useful elsewhere ... but where to put it?
+    // TODO add support for this in DependentConfiguration (see TODO there)
+    /** Waits for the given target to report service up, then runs the given task
+     * (often an invocation on that entity), with the given name.
+     * If the target goes away, this task marks itself inessential
+     * before failing so as not to cause a parent task to fail. */
+    static <T> Task<T> whenServiceUp(final Entity target, final TaskAdaptable<T> task, String name) {
+        return Tasks.<T>builder().name(name).dynamic(true).body(new Callable<T>() {
+            @Override
+            public T call() {
+                try {
+                    while (true) {
+                        if (!Entities.isManaged(target)) {
+                            Tasks.markInessential();
+                            throw new IllegalStateException("Target "+target+" is no longer managed");
+                        }
+                        if (Boolean.TRUE.equals(target.getAttribute(Attributes.SERVICE_UP))) {
+                            Tasks.resetBlockingDetails();
+                            TaskTags.markInessential(task);
+                            DynamicTasks.queue(task);
+                            try {
+                                return task.asTask().getUnchecked();
+                            } catch (Exception e) {
+                                if (Entities.isManaged(target)) {
+                                    throw Exceptions.propagate(e);
+                                } else {
+                                    Tasks.markInessential();
+                                    throw new IllegalStateException("Target "+target+" is no longer managed", e);
+                                }
+                            }
+                        } else {
+                            Tasks.setBlockingDetails("Waiting on "+target+" to be ready");
+                        }
+                        // TODO replace with subscription?
+                        Time.sleep(Duration.ONE_SECOND);
+                    }
+                } finally {
+                    Tasks.resetBlockingDetails();
+                }
+            }
+        }).build();        
+    }
+
+    @Override
+    public void deploy(String url, String targetName) {
+        checkNotNull(url, "url");
+        checkNotNull(targetName, "targetName");
+        targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);
+
+        // set it up so future nodes get the right wars
+        addToWarsByContext(this, url, targetName);
+        
+        log.debug("Deploying "+targetName+"->"+url+" across cluster "+this+"; WARs now "+getConfig(WARS_BY_CONTEXT));
+
+        Iterable<CanDeployAndUndeploy> targets = Iterables.filter(getChildren(), CanDeployAndUndeploy.class);
+        TaskBuilder<Void> tb = Tasks.<Void>builder().parallel(true).name("Deploy "+targetName+" to cluster (size "+Iterables.size(targets)+")");
+        for (Entity target: targets) {
+            tb.add(whenServiceUp(target, Effectors.invocation(target, DEPLOY, MutableMap.of("url", url, "targetName", targetName)),
+                "Deploy "+targetName+" to "+target+" when ready"));
+        }
+        DynamicTasks.queueIfPossible(tb.build()).orSubmitAsync(this).asTask().getUnchecked();
+
+        // Update attribute
+        // TODO support for atomic sensor update (should be part of standard tooling; NB there is some work towards this, according to @aledsage)
+        Set<String> deployedWars = MutableSet.copyOf(getAttribute(DEPLOYED_WARS));
+        deployedWars.add(targetName);
+        setAttribute(DEPLOYED_WARS, deployedWars);
+    }
+    
+    @Override
+    public void undeploy(String targetName) {
+        checkNotNull(targetName, "targetName");
+        targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);
+        
+        // set it up so future nodes get the right wars
+        if (!removeFromWarsByContext(this, targetName)) {
+            DynamicTasks.submit(Tasks.warning("Context "+targetName+" not known at "+this+"; attempting to undeploy regardless", null), this);
+        }
+        
+        log.debug("Undeploying "+targetName+" across cluster "+this+"; WARs now "+getConfig(WARS_BY_CONTEXT));
+
+        Iterable<CanDeployAndUndeploy> targets = Iterables.filter(getChildren(), CanDeployAndUndeploy.class);
+        TaskBuilder<Void> tb = Tasks.<Void>builder().parallel(true).name("Undeploy "+targetName+" across cluster (size "+Iterables.size(targets)+")");
+        for (Entity target: targets) {
+            tb.add(whenServiceUp(target, Effectors.invocation(target, UNDEPLOY, MutableMap.of("targetName", targetName)),
+                "Undeploy "+targetName+" at "+target+" when ready"));
+        }
+        DynamicTasks.queueIfPossible(tb.build()).orSubmitAsync(this).asTask().getUnchecked();
+
+        // Update attribute
+        Set<String> deployedWars = MutableSet.copyOf(getAttribute(DEPLOYED_WARS));
+        deployedWars.remove( FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName) );
+        setAttribute(DEPLOYED_WARS, deployedWars);
+    }
+
+    static void addToWarsByContext(Entity entity, String url, String targetName) {
+        targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);
+        // TODO a better way to do atomic updates, see comment above
+        synchronized (entity) {
+            Map<String,String> newWarsMap = MutableMap.copyOf(entity.getConfig(WARS_BY_CONTEXT));
+            newWarsMap.put(targetName, url);
+            ((EntityInternal)entity).setConfig(WARS_BY_CONTEXT, newWarsMap);
+        }
+    }
+
+    static boolean removeFromWarsByContext(Entity entity, String targetName) {
+        targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);
+        // TODO a better way to do atomic updates, see comment above
+        synchronized (entity) {
+            Map<String,String> newWarsMap = MutableMap.copyOf(entity.getConfig(WARS_BY_CONTEXT));
+            String url = newWarsMap.remove(targetName);
+            if (url==null) {
+                return false;
+            }
+            ((EntityInternal)entity).setConfig(WARS_BY_CONTEXT, newWarsMap);
+            return true;
+        }
+    }
+    
+    @Override
+    public void redeployAll() {
+        Map<String, String> wars = MutableMap.copyOf(getConfig(WARS_BY_CONTEXT));
+        String redeployPrefix = "Redeploy all WARs (count "+wars.size()+")";
+
+        log.debug("Redeplying all WARs across cluster "+this+": "+getConfig(WARS_BY_CONTEXT));
+        
+        Iterable<CanDeployAndUndeploy> targetEntities = Iterables.filter(getChildren(), CanDeployAndUndeploy.class);
+        TaskBuilder<Void> tb = Tasks.<Void>builder().parallel(true).name(redeployPrefix+" across cluster (size "+Iterables.size(targetEntities)+")");
+        for (Entity targetEntity: targetEntities) {
+            TaskBuilder<Void> redeployAllToTarget = Tasks.<Void>builder().name(redeployPrefix+" at "+targetEntity+" (after ready check)");
+            for (String warContextPath: wars.keySet()) {
+                redeployAllToTarget.add(Effectors.invocation(targetEntity, DEPLOY, MutableMap.of("url", wars.get(warContextPath), "targetName", warContextPath)));
+            }
+            tb.add(whenServiceUp(targetEntity, redeployAllToTarget.build(), redeployPrefix+" at "+targetEntity+" when ready"));
+        }
+        DynamicTasks.queueIfPossible(tb.build()).orSubmitAsync(this).asTask().getUnchecked();
+    }  
+
 }
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppFabricImpl.java b/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppFabricImpl.java
index 3af6817732..4023748f8e 100644
--- a/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppFabricImpl.java
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/DynamicWebAppFabricImpl.java
@@ -63,7 +63,9 @@ public void onManagementBecomingMaster() {
         }
         
         for (List<? extends AttributeSensor<? extends Number>> es : averagingEnricherSetup) {
+            @SuppressWarnings("unchecked")
             AttributeSensor<Number> t = (AttributeSensor<Number>) es.get(0);
+            @SuppressWarnings("unchecked")
             AttributeSensor<Double> average = (AttributeSensor<Double>) es.get(1);
             
             // TODO This needs to respond to changes in FABRIC_SIZE as well, to recalculate
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/ElasticJavaWebAppService.java b/software/webapp/src/main/java/brooklyn/entity/webapp/ElasticJavaWebAppService.java
index 26e9e96c14..89a1311bee 100644
--- a/software/webapp/src/main/java/brooklyn/entity/webapp/ElasticJavaWebAppService.java
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/ElasticJavaWebAppService.java
@@ -24,6 +24,7 @@
 import brooklyn.entity.basic.AbstractConfigurableEntityFactory;
 import brooklyn.entity.basic.ConfigurableEntityFactory;
 import brooklyn.entity.basic.EntityFactoryForLocation;
+import brooklyn.entity.proxying.EntitySpec;
 import brooklyn.entity.trait.Startable;
 import brooklyn.location.Location;
 import brooklyn.location.MachineProvisioningLocation;
@@ -34,10 +35,14 @@ public interface ElasticJavaWebAppServiceAwareLocation {
         ConfigurableEntityFactory<ElasticJavaWebAppService> newWebClusterFactory();
     }
 
+    /** @deprecated since 0.7.0 use {@link EntitySpec} */
+    @Deprecated
     public static class Factory extends AbstractConfigurableEntityFactory<ElasticJavaWebAppService>
     implements EntityFactoryForLocation<ElasticJavaWebAppService> {
 
-        public ElasticJavaWebAppService newEntity2(Map flags, Entity parent) {
+        private static final long serialVersionUID = 6654647949712073832L;
+
+        public ElasticJavaWebAppService newEntity2(@SuppressWarnings("rawtypes") Map flags, Entity parent) {
             return new ControlledDynamicWebAppClusterImpl(flags, parent);
         }
 
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/JavaWebAppService.java b/software/webapp/src/main/java/brooklyn/entity/webapp/JavaWebAppService.java
index 044f49c084..1317ef0b8d 100644
--- a/software/webapp/src/main/java/brooklyn/entity/webapp/JavaWebAppService.java
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/JavaWebAppService.java
@@ -20,9 +20,16 @@
 
 import java.util.List;
 import java.util.Map;
+import java.util.Set;
 
 import brooklyn.config.ConfigKey;
+import brooklyn.entity.Entity;
+import brooklyn.entity.annotation.Effector;
+import brooklyn.entity.annotation.EffectorParam;
+import brooklyn.entity.basic.MethodEffector;
 import brooklyn.entity.java.UsesJava;
+import brooklyn.event.AttributeSensor;
+import brooklyn.event.basic.BasicAttributeSensor;
 import brooklyn.event.basic.BasicConfigKey;
 import brooklyn.util.flags.SetFromFlag;
 
@@ -32,11 +39,71 @@ public interface JavaWebAppService extends WebAppService, UsesJava {
 	public static final ConfigKey<String> ROOT_WAR = new BasicConfigKey<String>(
 	        String.class, "wars.root", "WAR file to deploy as the ROOT, as URL (supporting file: and classpath: prefixes)");
 
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     @SetFromFlag("wars")
 	public static final ConfigKey<List<String>> NAMED_WARS = new BasicConfigKey(
 	        List.class, "wars.named", "Archive files to deploy, as URL strings (supporting file: and classpath: prefixes); context (path in user-facing URL) will be inferred by name");
     
+    @SuppressWarnings({ "unchecked", "rawtypes" })
     @SetFromFlag("warsByContext")
     public static final ConfigKey<Map<String,String>> WARS_BY_CONTEXT = new BasicConfigKey(
             Map.class, "wars.by.context", "Map of context keys (path in user-facing URL, typically without slashes) to archives (e.g. WARs by URL) to deploy, supporting file: and classpath: prefixes)");
+    
+    /** Optional marker interface for entities which support 'deploy' and 'undeploy' */
+    public interface CanDeployAndUndeploy extends Entity {
+
+        @SuppressWarnings({ "unchecked", "rawtypes" })
+        public static final AttributeSensor<Set<String>> DEPLOYED_WARS = new BasicAttributeSensor(
+                Set.class, "webapp.deployedWars", "Names of archives/contexts that are currently deployed");
+
+        public static final MethodEffector<Void> DEPLOY = new MethodEffector<Void>(CanDeployAndUndeploy.class, "deploy");
+        public static final MethodEffector<Void> UNDEPLOY = new MethodEffector<Void>(CanDeployAndUndeploy.class, "undeploy");
+
+        /**
+         * Deploys the given artifact, from a source URL, to a given deployment filename/context.
+         * There is some variance in expected filename/context at various servers,
+         * so the following conventions are followed:
+         * <p>
+         *   either ROOT.WAR or /       denotes root context
+         * <p>
+         *   anything of form  FOO.?AR  (ending .?AR) is copied with that name (unless copying not necessary)
+         *                              and is expected to be served from /FOO
+         * <p>
+         *   anything of form  /FOO     (with leading slash) is expected to be served from /FOO
+         *                              (and is copied as FOO.WAR)
+         * <p>
+         *   anything of form  FOO      (without a dot) is expected to be served from /FOO
+         *                              (and is copied as FOO.WAR)
+         * <p>
+         *   otherwise <i>please note</i> behaviour may vary on different appservers;
+         *   e.g. FOO.FOO would probably be ignored on appservers which expect a file copied across (usually),
+         *   but served as /FOO.FOO on systems that take a deployment context.
+         * <p>
+         * See {@link FileNameToContextMappingTest} for definitive examples!
+         *
+         * @param url  where to get the war, as a URL, either classpath://xxx or file:///home/xxx or http(s)...
+         * @param targetName  where to tell the server to serve the WAR, see above
+         */
+        @Effector(description="Deploys the given artifact, from a source URL, to a given deployment filename/context")
+        public void deploy(
+                @EffectorParam(name="url", description="URL of WAR file") String url, 
+                @EffectorParam(name="targetName", description="context path where WAR should be deployed (/ for ROOT)") String targetName);
+
+        /** 
+         * For the DEPLOYED_WARS to be updated, the input must match the result of the call to deploy,
+         * e.g. the transformed name using 
+         */
+        @Effector(description="Undeploys the given context/artifact")
+        public void undeploy(
+                @EffectorParam(name="targetName") String targetName);
+    }
+
+    /** Optional marker interface for entities which support 'redeployAll' */
+    public interface CanRedeployAll {
+        public static final MethodEffector<Void> REDEPLOY_ALL = new MethodEffector<Void>(CanRedeployAll.class, "redeployAll");
+        
+        @Effector(description="Redeploys all web apps known here across the cluster (e.g. if it gets into an inconsistent state)")
+        public void redeployAll();
+    }
+        
 }
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/JavaWebAppSoftwareProcess.java b/software/webapp/src/main/java/brooklyn/entity/webapp/JavaWebAppSoftwareProcess.java
index a6b43e2ab2..5460f795e0 100644
--- a/software/webapp/src/main/java/brooklyn/entity/webapp/JavaWebAppSoftwareProcess.java
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/JavaWebAppSoftwareProcess.java
@@ -18,57 +18,7 @@
  */
 package brooklyn.entity.webapp;
 
-import java.util.Set;
-
-import brooklyn.entity.annotation.Effector;
-import brooklyn.entity.annotation.EffectorParam;
-import brooklyn.entity.basic.MethodEffector;
 import brooklyn.entity.basic.SoftwareProcess;
-import brooklyn.event.AttributeSensor;
-import brooklyn.event.basic.BasicAttributeSensor;
-
-public interface JavaWebAppSoftwareProcess extends SoftwareProcess, JavaWebAppService {
-
-    public static final AttributeSensor<Set<String>> DEPLOYED_WARS = new BasicAttributeSensor(
-            Set.class, "webapp.deployedWars", "Names of archives/contexts that are currently deployed");
-
-    public static final MethodEffector<Void> DEPLOY = new MethodEffector<Void>(JavaWebAppSoftwareProcess.class, "deploy");
-    public static final MethodEffector<Void> UNDEPLOY = new MethodEffector<Void>(JavaWebAppSoftwareProcess.class, "undeploy");
-
-    /**
-     * Deploys the given artifact, from a source URL, to a given deployment filename/context.
-     * There is some variance in expected filename/context at various servers,
-     * so the following conventions are followed:
-     * <p>
-     *   either ROOT.WAR or /       denotes root context
-     * <p>
-     *   anything of form  FOO.?AR  (ending .?AR) is copied with that name (unless copying not necessary)
-     *                              and is expected to be served from /FOO
-     * <p>
-     *   anything of form  /FOO     (with leading slash) is expected to be served from /FOO
-     *                              (and is copied as FOO.WAR)
-     * <p>
-     *   anything of form  FOO      (without a dot) is expected to be served from /FOO
-     *                              (and is copied as FOO.WAR)
-     * <p>
-     *   otherwise <i>please note</i> behaviour may vary on different appservers;
-     *   e.g. FOO.FOO would probably be ignored on appservers which expect a file copied across (usually),
-     *   but served as /FOO.FOO on systems that take a deployment context.
-     * <p>
-     * See {@link FileNameToContextMappingTest} for definitive examples!
-     *
-     * @param url  where to get the war, as a URL, either classpath://xxx or file:///home/xxx or http(s)...
-     * @param targetName  where to tell the server to serve the WAR, see above
-     */
-    @Effector(description="Deploys the given artifact, from a source URL, to a given deployment filename/context")
-    public void deploy(
-            @EffectorParam(name="url", description="URL of WAR file") String url, 
-            @EffectorParam(name="targetName", description="context path where WAR should be deployed (/ for ROOT)") String targetName);
 
-    /** 
-     * For the DEPLOYED_WARS to be updated, the input must match the result of the call to deploy
-     */
-    @Effector(description="Undeploys the given context/artifact")
-    public void undeploy(
-            @EffectorParam(name="targetName") String targetName);
+public interface JavaWebAppSoftwareProcess extends SoftwareProcess, JavaWebAppService, JavaWebAppService.CanDeployAndUndeploy {
 }
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/JavaWebAppSoftwareProcessImpl.java b/software/webapp/src/main/java/brooklyn/entity/webapp/JavaWebAppSoftwareProcessImpl.java
index c67ad2b6cb..2b6ab29503 100644
--- a/software/webapp/src/main/java/brooklyn/entity/webapp/JavaWebAppSoftwareProcessImpl.java
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/JavaWebAppSoftwareProcessImpl.java
@@ -48,14 +48,17 @@ public JavaWebAppSoftwareProcessImpl(){
         super();
     }
 
+    @SuppressWarnings("rawtypes")
     public JavaWebAppSoftwareProcessImpl(Entity parent){
         this(new LinkedHashMap(),parent);
     }
 
+    @SuppressWarnings("rawtypes")
     public JavaWebAppSoftwareProcessImpl(Map flags){
         this(flags, null);
     }
 
+    @SuppressWarnings("rawtypes")
     public JavaWebAppSoftwareProcessImpl(Map flags, Entity parent) {
         super(flags, parent);
     }
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/WebAppServiceConstants.java b/software/webapp/src/main/java/brooklyn/entity/webapp/WebAppServiceConstants.java
index b76ea2e30f..4a9903eef6 100644
--- a/software/webapp/src/main/java/brooklyn/entity/webapp/WebAppServiceConstants.java
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/WebAppServiceConstants.java
@@ -23,17 +23,14 @@
 import brooklyn.config.render.RendererHints;
 import brooklyn.entity.basic.Attributes;
 import brooklyn.event.AttributeSensor;
-import brooklyn.event.basic.BasicAttributeSensor;
 import brooklyn.event.basic.BasicAttributeSensorAndConfigKey;
 import brooklyn.event.basic.PortAttributeSensorAndConfigKey;
 import brooklyn.event.basic.Sensors;
 import brooklyn.util.flags.SetFromFlag;
-import brooklyn.util.text.ByteSizeStrings;
-import brooklyn.util.time.Duration;
 
 import com.google.common.collect.ImmutableList;
 
-public interface WebAppServiceConstants {
+public interface WebAppServiceConstants extends WebAppServiceMetrics {
 
     @SetFromFlag("httpPort")
     public static final PortAttributeSensorAndConfigKey HTTP_PORT = Attributes.HTTP_PORT;
@@ -50,50 +47,15 @@ public interface WebAppServiceConstants {
     public static final BasicAttributeSensorAndConfigKey<HttpsSslConfig> HTTPS_SSL_CONFIG = new BasicAttributeSensorAndConfigKey<HttpsSslConfig>(
             HttpsSslConfig.class, "webapp.https.ssl", "SSL Configuration for HTTPS", null);
     
-    public static final AttributeSensor<Integer> REQUEST_COUNT =
-            Sensors.newIntegerSensor("webapp.reqs.total", "Request count");
-    public static final brooklyn.event.basic.BasicAttributeSensor<Integer> ERROR_COUNT =
-            new brooklyn.event.basic.BasicAttributeSensor<Integer>(Integer.class, "webapp.reqs.errors", "Request errors");
-    public static final AttributeSensor<Integer> TOTAL_PROCESSING_TIME = Sensors.newIntegerSensor(
-            "webapp.reqs.processingTime.total", "Total processing time, reported by webserver (millis)");
-    public static final AttributeSensor<Integer> MAX_PROCESSING_TIME =
-            Sensors.newIntegerSensor("webapp.reqs.processingTime.max", "Max processing time for any single request, reported by webserver (millis)");
-
-    /** the fraction of time represented by the most recent delta to TOTAL_PROCESSING_TIME, ie 0.4 if 800 millis were accumulated in last 2s;
-     * easily configured with {@link WebAppServiceMethods#connectWebAppServerPolicies(brooklyn.entity.basic.EntityLocal, brooklyn.util.time.Duration)} */
-    public static final AttributeSensor<Double> PROCESSING_TIME_FRACTION_LAST =
-            Sensors.newDoubleSensor("webapp.reqs.processingTime.fraction.last", "Fraction of time spent processing, reported by webserver (percentage, last datapoint)");
-    public static final AttributeSensor<Double> PROCESSING_TIME_FRACTION_IN_WINDOW =
-            Sensors.newDoubleSensor("webapp.reqs.processingTime.fraction.windowed", "Fraction of time spent processing, reported by webserver (percentage, over time window)");
-
-    public static final AttributeSensor<Long> BYTES_RECEIVED =
-            new BasicAttributeSensor<Long>(Long.class, "webapp.reqs.bytes.received", "Total bytes received by the webserver");
-    public static final AttributeSensor<Long> BYTES_SENT =
-            new BasicAttributeSensor<Long>(Long.class, "webapp.reqs.bytes.sent", "Total bytes sent by the webserver");
-
-    /** req/second computed from the delta of the last request count and an associated timestamp */
-    public static final AttributeSensor<Double> REQUESTS_PER_SECOND_LAST =
-            Sensors.newDoubleSensor("webapp.reqs.perSec.last", "Reqs/sec (last datapoint)");
-
-    /** rolled-up req/second for a window, 
-     * easily configured with {@link WebAppServiceMethods#connectWebAppServerPolicies(brooklyn.entity.basic.EntityLocal, brooklyn.util.time.Duration)} */
-    public static final AttributeSensor<Double> REQUESTS_PER_SECOND_IN_WINDOW =
-            Sensors.newDoubleSensor("webapp.reqs.perSec.windowed", "Reqs/sec (over time window)");
-
     public static final AttributeSensor<String> ROOT_URL = RootUrl.ROOT_URL;
 
 }
 
-//this class is added because the ROOT_URL relies on a static initialization which unfortunately can't be added to
-//an interface.
+// this class is added because the ROOT_URL relies on a static initialization which unfortunately can't be added to an interface.
 class RootUrl {
     public static final AttributeSensor<String> ROOT_URL = Sensors.newStringSensor("webapp.url", "URL");
 
     static {
         RendererHints.register(ROOT_URL, new RendererHints.NamedActionWithUrl("Open"));
-        RendererHints.register(WebAppServiceConstants.TOTAL_PROCESSING_TIME, RendererHints.displayValue(Duration.millisToStringRounded()));
-        RendererHints.register(WebAppServiceConstants.MAX_PROCESSING_TIME, RendererHints.displayValue(Duration.millisToStringRounded()));
-        RendererHints.register(WebAppServiceConstants.BYTES_RECEIVED, RendererHints.displayValue(ByteSizeStrings.metric()));
-        RendererHints.register(WebAppServiceConstants.BYTES_SENT, RendererHints.displayValue(ByteSizeStrings.metric()));
     }
 }
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/WebAppServiceMetrics.java b/software/webapp/src/main/java/brooklyn/entity/webapp/WebAppServiceMetrics.java
new file mode 100644
index 0000000000..710e344c6b
--- /dev/null
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/WebAppServiceMetrics.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package brooklyn.entity.webapp;
+
+import brooklyn.config.render.RendererHints;
+import brooklyn.event.AttributeSensor;
+import brooklyn.event.basic.BasicAttributeSensor;
+import brooklyn.event.basic.Sensors;
+import brooklyn.util.text.ByteSizeStrings;
+import brooklyn.util.time.Duration;
+
+public interface WebAppServiceMetrics {
+    
+    public static final AttributeSensor<Integer> REQUEST_COUNT = Initializer.REQUEST_COUNT;
+        
+    public static final brooklyn.event.basic.BasicAttributeSensor<Integer> ERROR_COUNT =
+            new brooklyn.event.basic.BasicAttributeSensor<Integer>(Integer.class, "webapp.reqs.errors", "Request errors");
+    public static final AttributeSensor<Integer> TOTAL_PROCESSING_TIME = Sensors.newIntegerSensor(
+            "webapp.reqs.processingTime.total", "Total processing time, reported by webserver (millis)");
+    public static final AttributeSensor<Integer> MAX_PROCESSING_TIME =
+            Sensors.newIntegerSensor("webapp.reqs.processingTime.max", "Max processing time for any single request, reported by webserver (millis)");
+
+    /** the fraction of time represented by the most recent delta to TOTAL_PROCESSING_TIME, ie 0.4 if 800 millis were accumulated in last 2s;
+     * easily configured with {@link WebAppServiceMethods#connectWebAppServerPolicies(brooklyn.entity.basic.EntityLocal, brooklyn.util.time.Duration)} */
+    public static final AttributeSensor<Double> PROCESSING_TIME_FRACTION_LAST =
+            Sensors.newDoubleSensor("webapp.reqs.processingTime.fraction.last", "Fraction of time spent processing, reported by webserver (percentage, last datapoint)");
+    public static final AttributeSensor<Double> PROCESSING_TIME_FRACTION_IN_WINDOW =
+            Sensors.newDoubleSensor("webapp.reqs.processingTime.fraction.windowed", "Fraction of time spent processing, reported by webserver (percentage, over time window)");
+
+    public static final AttributeSensor<Long> BYTES_RECEIVED =
+            new BasicAttributeSensor<Long>(Long.class, "webapp.reqs.bytes.received", "Total bytes received by the webserver");
+    public static final AttributeSensor<Long> BYTES_SENT =
+            new BasicAttributeSensor<Long>(Long.class, "webapp.reqs.bytes.sent", "Total bytes sent by the webserver");
+
+    /** req/second computed from the delta of the last request count and an associated timestamp */
+    public static final AttributeSensor<Double> REQUESTS_PER_SECOND_LAST =
+            Sensors.newDoubleSensor("webapp.reqs.perSec.last", "Reqs/sec (last datapoint)");
+
+    /** rolled-up req/second for a window, 
+     * easily configured with {@link WebAppServiceMethods#connectWebAppServerPolicies(brooklyn.entity.basic.EntityLocal, brooklyn.util.time.Duration)} */
+    public static final AttributeSensor<Double> REQUESTS_PER_SECOND_IN_WINDOW =
+            Sensors.newDoubleSensor("webapp.reqs.perSec.windowed", "Reqs/sec (over time window)");
+
+    // this class is added because the above need static initialization which unfortunately can't be added to an interface.
+    static class Initializer {
+        public static final AttributeSensor<Integer> REQUEST_COUNT =
+            Sensors.newIntegerSensor("webapp.reqs.total", "Request count");
+
+        static {
+            RendererHints.register(WebAppServiceConstants.TOTAL_PROCESSING_TIME, RendererHints.displayValue(Duration.millisToStringRounded()));
+            RendererHints.register(WebAppServiceConstants.MAX_PROCESSING_TIME, RendererHints.displayValue(Duration.millisToStringRounded()));
+            RendererHints.register(WebAppServiceConstants.BYTES_RECEIVED, RendererHints.displayValue(ByteSizeStrings.metric()));
+            RendererHints.register(WebAppServiceConstants.BYTES_SENT, RendererHints.displayValue(ByteSizeStrings.metric()));
+        }
+    }
+
+}
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/jboss/JBoss6Server.java b/software/webapp/src/main/java/brooklyn/entity/webapp/jboss/JBoss6Server.java
index d3a6041ad9..f2cc135101 100644
--- a/software/webapp/src/main/java/brooklyn/entity/webapp/jboss/JBoss6Server.java
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/jboss/JBoss6Server.java
@@ -24,14 +24,13 @@
 import brooklyn.entity.basic.SoftwareProcess;
 import brooklyn.entity.java.UsesJmx;
 import brooklyn.entity.proxying.ImplementedBy;
-import brooklyn.entity.webapp.JavaWebAppService;
 import brooklyn.entity.webapp.JavaWebAppSoftwareProcess;
 import brooklyn.event.basic.BasicAttributeSensorAndConfigKey;
 import brooklyn.util.flags.SetFromFlag;
 
 @Catalog(name="JBoss Application Server 6", description="AS6: an open source Java application server from JBoss", iconUrl="classpath:///jboss-logo.png")
 @ImplementedBy(JBoss6ServerImpl.class)
-public interface JBoss6Server extends JavaWebAppSoftwareProcess, JavaWebAppService, UsesJmx {
+public interface JBoss6Server extends JavaWebAppSoftwareProcess, UsesJmx {
 
     // TODO Instead of using portIncrement, would prefer to use http_port as "8080+" etc.
     // On localhost, if an existing jboss6 is running and consuming the required port(s), 
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/jboss/JBoss7Server.java b/software/webapp/src/main/java/brooklyn/entity/webapp/jboss/JBoss7Server.java
index 620294cfbe..70b5131400 100644
--- a/software/webapp/src/main/java/brooklyn/entity/webapp/jboss/JBoss7Server.java
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/jboss/JBoss7Server.java
@@ -24,7 +24,6 @@
 import brooklyn.entity.basic.SoftwareProcess;
 import brooklyn.entity.proxying.ImplementedBy;
 import brooklyn.entity.trait.HasShortName;
-import brooklyn.entity.webapp.JavaWebAppService;
 import brooklyn.entity.webapp.JavaWebAppSoftwareProcess;
 import brooklyn.event.AttributeSensor;
 import brooklyn.event.basic.BasicAttributeSensorAndConfigKey;
@@ -36,7 +35,7 @@
 
 @Catalog(name="JBoss Application Server 7", description="AS7: an open source Java application server from JBoss", iconUrl="classpath:///jboss-logo.png")
 @ImplementedBy(JBoss7ServerImpl.class)
-public interface JBoss7Server extends JavaWebAppSoftwareProcess, JavaWebAppService, HasShortName {
+public interface JBoss7Server extends JavaWebAppSoftwareProcess, HasShortName {
 
     @SetFromFlag("version")
     ConfigKey<String> SUGGESTED_VERSION =
diff --git a/software/webapp/src/main/java/brooklyn/entity/webapp/tomcat/TomcatServerImpl.java b/software/webapp/src/main/java/brooklyn/entity/webapp/tomcat/TomcatServerImpl.java
index ea79eb1a07..a83f284674 100644
--- a/software/webapp/src/main/java/brooklyn/entity/webapp/tomcat/TomcatServerImpl.java
+++ b/software/webapp/src/main/java/brooklyn/entity/webapp/tomcat/TomcatServerImpl.java
@@ -29,7 +29,6 @@
 import brooklyn.entity.webapp.JavaWebAppSoftwareProcessImpl;
 import brooklyn.event.feed.jmx.JmxAttributePollConfig;
 import brooklyn.event.feed.jmx.JmxFeed;
-import brooklyn.util.time.Duration;
 
 import com.google.common.base.Functions;
 import com.google.common.base.Predicates;
@@ -57,7 +56,7 @@ public void connectSensors() {
 
             jmxFeed = JmxFeed.builder()
                     .entity(this)
-                    .period(500, TimeUnit.MILLISECONDS)
+                    .period(3000, TimeUnit.MILLISECONDS)
                     .pollAttribute(new JmxAttributePollConfig<Integer>(ERROR_COUNT)
                             .objectName(requestProcessorMbeanName)
                             .attributeName("errorCount"))
@@ -95,6 +94,7 @@ public void disconnectSensors() {
         }
     }
 
+    @SuppressWarnings("rawtypes")
     @Override
     public Class getDriverInterface() {
         return Tomcat7Driver.class;
diff --git a/usage/jsgui/src/main/webapp/assets/js/model/task-summary.js b/usage/jsgui/src/main/webapp/assets/js/model/task-summary.js
index 23014d73f4..afc3549d57 100644
--- a/usage/jsgui/src/main/webapp/assets/js/model/task-summary.js
+++ b/usage/jsgui/src/main/webapp/assets/js/model/task-summary.js
@@ -65,7 +65,7 @@ define([
         parse: function(resp) {
             _.keys(this.attributes).forEach(function(key) {
               if (resp[key] === undefined) {
-                resp[key] = undefined;
+                resp[key] = null;
               }
             });
 
diff --git a/usage/jsgui/src/main/webapp/assets/js/view/activity-details.js b/usage/jsgui/src/main/webapp/assets/js/view/activity-details.js
index 989b53140b..df98a77d77 100644
--- a/usage/jsgui/src/main/webapp/assets/js/view/activity-details.js
+++ b/usage/jsgui/src/main/webapp/assets/js/view/activity-details.js
@@ -146,10 +146,14 @@ define([
                         that.displayTextForLinkedTask(v)+"</a>" })
             this.updateFieldWith('result',
                 function(v) {
-                    if (v.toString().length<20 &&  !/\r|\n/.exec(v)) {
-                        return " with result: <span class='result-literal'>"+_.escape(v)+"</span>";
+                    // use display string (JSON.stringify(_.escape(v)) because otherwise list of [null,null] is just ","  
+                    var vs = Util.toDisplayString(v);
+                    if (vs.trim().length==0) {
+                        return " (empty result)";
+                    } else if (vs.length<20 &&  !/\r|\n/.exec(v)) {
+                        return " with result: <span class='result-literal'>"+vs+"</span>";
                     } else {
-                        return "<div class='result-literal'>"+_.escape(v).replace(/\n+/g,"<br>")+"</div>"
+                        return "<div class='result-literal'>"+vs.replace(/\n+/g,"<br>")+"</div>"
                     }
                  })
             this.updateFieldWith('tags', function(tags) {
@@ -276,7 +280,7 @@ define([
             }
             ViewUtils.updateMyDataTable(this.subtasksTable, subtasks, function(task, index) {
                 return [ task.get("id"),
-                         (task.get("entityId") && task.get("entityId")!=that.task.get("entityId") ? task.get("entityDisplayName") + ": " : "") + 
+                         (task.get("entityId") && (!that.task || task.get("entityId")!=that.task.get("entityId")) ? task.get("entityDisplayName") + ": " : "") + 
                          task.get("displayName"),
                          task.get("submitTimeUtc") <= 0 ? "-" : moment(task.get("submitTimeUtc")).calendar(),
                          task.get("currentStatus")
diff --git a/utils/common/src/main/java/brooklyn/util/concurrent/CallableFromRunnable.java b/utils/common/src/main/java/brooklyn/util/concurrent/CallableFromRunnable.java
new file mode 100644
index 0000000000..2160e5fe1d
--- /dev/null
+++ b/utils/common/src/main/java/brooklyn/util/concurrent/CallableFromRunnable.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package brooklyn.util.concurrent;
+
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executors;
+
+import com.google.common.annotations.Beta;
+
+/** Wraps a Runnable as a Callable. Like {@link Executors#callable(Runnable, Object)} but including the underlying toString. */
+@Beta
+public class CallableFromRunnable<T> implements Callable<T> {
+    
+    public static <T> CallableFromRunnable<T> newInstance(Runnable task, T result) {
+        return new CallableFromRunnable<T>(task, result);
+    }
+    
+    private final Runnable task;
+    private final T result;
+    
+    protected CallableFromRunnable(Runnable task, T result) {
+        this.task = task;
+        this.result = result;
+    }
+    
+    public T call() {
+        task.run();
+        return result;
+    }
+    
+    @Override
+    public String toString() {
+        if (result!=null)
+            return "CallableFromRunnable["+task+(result!=null ? "->"+result : "")+"]";
+        else
+            return ""+task;
+    }
+}
\ No newline at end of file
diff --git a/utils/common/src/main/java/brooklyn/util/exceptions/ReferenceWithError.java b/utils/common/src/main/java/brooklyn/util/exceptions/ReferenceWithError.java
new file mode 100644
index 0000000000..cdb592502d
--- /dev/null
+++ b/utils/common/src/main/java/brooklyn/util/exceptions/ReferenceWithError.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+package brooklyn.util.exceptions;
+
+import javax.annotation.Nullable;
+
+import com.google.common.base.Supplier;
+
+/** A reference to an object which can carry an object alongside it. */
+public class ReferenceWithError<T> implements Supplier<T> {
+
+    private final T object;
+    private final Throwable error;
+    private final boolean maskError;
+
+    /** returns a reference which includes an error, and where attempts to get the content cause the error to throw */
+    public static <T> ReferenceWithError<T> newInstanceThrowingError(T object, Throwable error) {
+        return new ReferenceWithError<T>(object, error, true);
+    }
+    
+    /** returns a reference which includes an error, but attempts to get the content do not cause the error to throw */
+    public static <T> ReferenceWithError<T> newInstanceMaskingError(T object, Throwable error) {
+        return new ReferenceWithError<T>(object, error, false);
+    }
+    
+    /** returns a reference which includes an error, but attempts to get the content do not cause the error to throw */
+    public static <T> ReferenceWithError<T> newInstanceWithoutError(T object) {
+        return new ReferenceWithError<T>(object, null, false);
+    }
+    
+    protected ReferenceWithError(@Nullable T object, @Nullable Throwable error, boolean throwErrorOnAccess) {
+        this.object = object;
+        this.error = error;
+        this.maskError = throwErrorOnAccess;
+    }
+
+    /** whether this will mask any error on an attempt to {@link #get()};
+     * if false (if created with {@link #newInstanceThrowingError(Object, Throwable)}) a call to {@link #get()} will throw if there is an error;
+     * true if created with {@link #newInstanceMaskingError(Object, Throwable)} and {@link #get()} will not throw */
+    public boolean masksErrorIfPresent() {
+        return maskError;
+    }
+
+    /** returns the underlying value, throwing if there is an error and {@link #throwsErrorOnAccess()} is set */
+    public T get() {
+        if (masksErrorIfPresent()) {
+            return getMaskingError();
+        }
+        return getThrowingError();
+    }
+
+    public T getMaskingError() {
+        return object;
+    }
+
+    public T getThrowingError() {
+        checkNoError();
+        return object;
+    }
+
+    /** throws if there is an error (even if masked) */
+    public void checkNoError() {
+        if (hasError())
+            Exceptions.propagate(error);
+    }
+
+    /** returns the error (not throwing) */
+    public Throwable getError() {
+        return error;
+    }
+    
+    /** true if there is an error (whether masked or not) */
+    public boolean hasError() {
+        return error!=null;
+    }
+    
+}
diff --git a/utils/common/src/main/java/brooklyn/util/javalang/Reflections.java b/utils/common/src/main/java/brooklyn/util/javalang/Reflections.java
index 9ea35cefec..e5b78c6835 100644
--- a/utils/common/src/main/java/brooklyn/util/javalang/Reflections.java
+++ b/utils/common/src/main/java/brooklyn/util/javalang/Reflections.java
@@ -209,6 +209,7 @@ public Constructor<?> loadConstructor(Class<?> clazz, Class<?>[] argTypes) throw
     /** Invokes a suitable constructor, supporting varargs and primitives */
     public static <T> Optional<T> invokeConstructorWithArgs(ClassLoader classLoader, String className, Object...argsArray) {
         Reflections reflections = new Reflections(classLoader);
+        @SuppressWarnings("unchecked")
         Class<T> clazz = (Class<T>) reflections.loadClass(className);
         return invokeConstructorWithArgs(reflections, clazz, argsArray, false);
     }
diff --git a/utils/common/src/main/java/brooklyn/util/net/Networking.java b/utils/common/src/main/java/brooklyn/util/net/Networking.java
index dde2678e90..8c2d4f1ff5 100644
--- a/utils/common/src/main/java/brooklyn/util/net/Networking.java
+++ b/utils/common/src/main/java/brooklyn/util/net/Networking.java
@@ -386,4 +386,23 @@ public static boolean isReachable(HostAndPort endpoint) {
 
     // TODO go through nic's, looking for public, private, etc, on localhost
 
+    /**
+     * force use of TLSv1, fixing:
+     * http://stackoverflow.com/questions/9828414/receiving-sslhandshakeexception-handshake-failure-despite-my-client-ignoring-al
+     */
+    public static void installTlsOnlyForHttpsForcing() {
+        System.setProperty("https.protocols", "TLSv1");
+    }
+    public static void installTlsForHttpsIfAppropriate() {
+        if (System.getProperty("https.protocols")==null && System.getProperty("brooklyn.https.protocols.leave_untouched")==null) {
+            installTlsOnlyForHttpsForcing();
+        }
+    }
+    static {
+        installTlsForHttpsIfAppropriate();
+    }
+    
+    /** does nothing, but forces the class to be loaded and do static initialization */
+    public static void init() {}
+    
 }
diff --git a/utils/common/src/main/java/brooklyn/util/repeat/Repeater.java b/utils/common/src/main/java/brooklyn/util/repeat/Repeater.java
index 71ca09957b..be0d3f2252 100644
--- a/utils/common/src/main/java/brooklyn/util/repeat/Repeater.java
+++ b/utils/common/src/main/java/brooklyn/util/repeat/Repeater.java
@@ -30,6 +30,7 @@
 import org.slf4j.LoggerFactory;
 
 import brooklyn.util.exceptions.Exceptions;
+import brooklyn.util.exceptions.ReferenceWithError;
 import brooklyn.util.time.CountdownTimer;
 import brooklyn.util.time.Duration;
 import brooklyn.util.time.Time;
@@ -300,6 +301,10 @@ public Repeater limitTimeTo(Duration duration) {
      * @return true if the exit condition was satisfied; false if the loop terminated for any other reason.
      */
     public boolean run() {
+        return runKeepingError().getMaskingError();
+    }
+    
+    public ReferenceWithError<Boolean> runKeepingError() {
         Preconditions.checkState(body != null, "repeat() method has not been called to set the body");
         Preconditions.checkState(exitCondition != null, "until() method has not been called to set the exit condition");
         Preconditions.checkState(delayOnIteration != null, "every() method (or other delaySupplier() / backoff() method) has not been called to set the loop delay");
@@ -330,7 +335,7 @@ public boolean run() {
             }
             if (done) {
                 if (log.isDebugEnabled()) log.debug("{}: condition satisfied", description);
-                return true;
+                return ReferenceWithError.newInstanceWithoutError(true);
             } else {
                 if (log.isDebugEnabled()) {
                     String msg = String.format("%s: unsatisfied during iteration %s %s", description, iterations,
@@ -352,7 +357,7 @@ public boolean run() {
                 }
                 if (warnOnUnRethrownException && lastError != null)
                     log.warn("{}: error caught checking condition: {}", description, lastError.getMessage());
-                return false;
+                return ReferenceWithError.newInstanceMaskingError(false, lastError);
             }
 
             if (timer.isExpired()) {
@@ -362,7 +367,7 @@ public boolean run() {
                     log.error("{}: error caught checking condition: {}", description, lastError.getMessage());
                     throw Exceptions.propagate(lastError);
                 }
-                return false;
+                return ReferenceWithError.newInstanceMaskingError(false, lastError);
             }
 
             Time.sleep(delayThisIteration);
diff --git a/utils/groovy/src/main/java/brooklyn/util/GroovyJavaMethods.groovy b/utils/groovy/src/main/java/brooklyn/util/GroovyJavaMethods.groovy
index 5867bda9e0..199f6a5e49 100644
--- a/utils/groovy/src/main/java/brooklyn/util/GroovyJavaMethods.groovy
+++ b/utils/groovy/src/main/java/brooklyn/util/GroovyJavaMethods.groovy
@@ -21,7 +21,8 @@ package brooklyn.util;
 import static brooklyn.util.GroovyJavaMethods.truth
 
 import java.util.concurrent.Callable
-import java.util.concurrent.Executors
+
+import brooklyn.util.concurrent.CallableFromRunnable;
 
 import com.google.common.base.Function
 import com.google.common.base.Predicate
@@ -53,7 +54,7 @@ public class GroovyJavaMethods {
     }
 
     public static <T> Callable<T> callableFromRunnable(final Runnable job) {
-        return (job in Callable) ? callableFromClosure(job) : Executors.callable(job);
+        return (job in Callable) ? callableFromClosure(job) : CallableFromRunnable.newInstance(job, null);
     }
 
     public static <T> Predicate<T> predicateFromClosure(final Closure<Boolean> job) {
