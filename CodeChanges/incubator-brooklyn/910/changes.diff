diff --git a/core/src/main/java/org/apache/brooklyn/core/sensor/DependentConfiguration.java b/core/src/main/java/org/apache/brooklyn/core/sensor/DependentConfiguration.java
index ddca05c59c..6c251a7f7f 100644
--- a/core/src/main/java/org/apache/brooklyn/core/sensor/DependentConfiguration.java
+++ b/core/src/main/java/org/apache/brooklyn/core/sensor/DependentConfiguration.java
@@ -68,6 +68,7 @@
 import org.apache.brooklyn.util.groovy.GroovyJavaMethods;
 import org.apache.brooklyn.util.guava.Functionals;
 import org.apache.brooklyn.util.guava.Maybe;
+import org.apache.brooklyn.util.text.StringFunctions;
 import org.apache.brooklyn.util.text.Strings;
 import org.apache.brooklyn.util.time.CountdownTimer;
 import org.apache.brooklyn.util.time.Duration;
@@ -180,7 +181,7 @@ public static <T> T waitInTaskForAttributeReady(final Entity source, final Attri
     public static <T> T waitInTaskForAttributeReady(final Entity source, final AttributeSensor<T> sensor, Predicate<? super T> ready, List<AttributeAndSensorCondition<?>> abortConditions, String blockingDetails) {
         return new WaitInTaskForAttributeReady<T,T>(source, sensor, ready, abortConditions, blockingDetails).call();
     }
-    
+
     protected static class WaitInTaskForAttributeReady<T,V> implements Callable<V> {
 
         /* This is a change since before Oct 2014. Previously it would continue to poll,
@@ -483,7 +484,100 @@ public static Task<String> formatString(final String spec, final Object ...args)
             taskArgs);
     }
 
-    /** returns a task for parallel execution returning a list of values for the given sensor for the given entity list, 
+    public static Task<String> regexReplacement(Object source, Object pattern, Object replacement) {
+        List<TaskAdaptable<Object>> taskArgs = getTaskAdaptable(source, pattern, replacement);
+        Function<List<Object>, String> transformer = new RegexTransformerString(source, pattern, replacement);
+        return transformMultiple(
+                MutableMap.of("displayName", String.format("creating regex replacement function (%s:%s)", pattern, replacement)),
+                transformer,
+                taskArgs
+        );
+    }
+
+    public static Task<Function<String, String>> regexReplacement(Object pattern, Object replacement) {
+        List<TaskAdaptable<Object>> taskArgs = getTaskAdaptable(pattern, replacement);
+        Function<List<Object>, Function<String, String>> transformer = new RegexTransformerFunction(pattern, replacement);
+        return transformMultiple(
+                MutableMap.of("displayName", String.format("creating regex replacement function (%s:%s)", pattern, replacement)),
+                transformer,
+                taskArgs
+        );
+    }
+
+    private static List<TaskAdaptable<Object>> getTaskAdaptable(Object... args){
+        List<TaskAdaptable<Object>> taskArgs = Lists.newArrayList();
+        for (Object arg: args) {
+            if (arg instanceof TaskAdaptable) {
+                taskArgs.add((TaskAdaptable<Object>)arg);
+            } else if (arg instanceof TaskFactory) {
+                taskArgs.add(((TaskFactory<TaskAdaptable<Object>>)arg).newTask());
+            }
+        }
+        return taskArgs;
+    }
+
+    public static class RegexTransformerString implements Function<List<Object>, String> {
+
+        private final Object source;
+        private final Object pattern;
+        private final Object replacement;
+
+        public RegexTransformerString(Object source, Object pattern, Object replacement){
+            this.source = source;
+            this.pattern = pattern;
+            this.replacement = replacement;
+        }
+
+        @Nullable
+        @Override
+        public String apply(@Nullable List<Object> input) {
+            Iterator<?> taskArgsIterator = input.iterator();
+            String resolvedSource = resolveArgument(source, taskArgsIterator);
+            String resolvedPattern = resolveArgument(pattern, taskArgsIterator);
+            String resolvedReplacement = resolveArgument(replacement, taskArgsIterator);
+            return new StringFunctions.RegexReplacer(resolvedPattern, resolvedReplacement).apply(resolvedSource);
+        }
+    }
+
+    @Beta
+    public static class RegexTransformerFunction implements Function<List<Object>, Function<String, String>> {
+
+        private final Object pattern;
+        private final Object replacement;
+
+        public RegexTransformerFunction(Object pattern, Object replacement){
+            this.pattern = pattern;
+            this.replacement = replacement;
+        }
+
+        @Override
+        public Function<String, String> apply(List<Object> input) {
+            Iterator<?> taskArgsIterator = input.iterator();
+            return new StringFunctions.RegexReplacer(resolveArgument(pattern, taskArgsIterator), resolveArgument(replacement, taskArgsIterator));
+        }
+
+    }
+
+    /**
+     * Resolves the argument as follows:
+     *
+     * If the argument is a DeferredSupplier, we will block and wait for it to resolve. If the argument is TaskAdaptable or TaskFactory,
+     * we will assume that the resolved task has been queued on the {@code taskArgsIterator}, otherwise the argument has already been resolved.
+     */
+    private static String resolveArgument(Object argument, Iterator<?> taskArgsIterator) {
+        Object resolvedArgument;
+        if (argument instanceof TaskAdaptable) {
+            resolvedArgument = taskArgsIterator.next();
+        } else if (argument instanceof DeferredSupplier) {
+            resolvedArgument = ((DeferredSupplier<?>) argument).get();
+        } else {
+            resolvedArgument = argument;
+        }
+        return String.valueOf(resolvedArgument);
+    }
+
+
+    /** returns a task for parallel execution returning a list of values for the given sensor for the given entity list,
      * optionally when the values satisfy a given readiness predicate (defaulting to groovy truth if not supplied) */
     public static <T> Task<List<T>> listAttributesWhenReady(AttributeSensor<T> sensor, Iterable<Entity> entities) {
         return listAttributesWhenReady(sensor, entities, GroovyJavaMethods.truthPredicate());
diff --git a/core/src/main/java/org/apache/brooklyn/enricher/stock/AbstractTransformer.java b/core/src/main/java/org/apache/brooklyn/enricher/stock/AbstractTransformer.java
index 89ebb1a5d1..8a9cf534dd 100644
--- a/core/src/main/java/org/apache/brooklyn/enricher/stock/AbstractTransformer.java
+++ b/core/src/main/java/org/apache/brooklyn/enricher/stock/AbstractTransformer.java
@@ -57,14 +57,16 @@ public AbstractTransformer() {
     public void setEntity(EntityLocal entity) {
         super.setEntity(entity);
 
-        Function<SensorEvent<T>, U> transformation = getTransformation();
         this.producer = getConfig(PRODUCER) == null ? entity: getConfig(PRODUCER);
         this.sourceSensor = (Sensor<T>) getRequiredConfig(SOURCE_SENSOR);
         Sensor<?> targetSensorSpecified = getConfig(TARGET_SENSOR);
         this.targetSensor = targetSensorSpecified!=null ? (Sensor<U>) targetSensorSpecified : (Sensor<U>) this.sourceSensor;
         if (producer.equals(entity) && targetSensorSpecified==null) {
+            // We cannot call getTransformation() here to log the tranformation, as it will attempt
+            // to resolve the transformation, which will cause the entity initialization thread to
+            // block
             LOG.error("Refusing to add an enricher which reads and publishes on the same sensor: "+
-                producer+"."+sourceSensor+" (computing "+transformation+")");
+                producer+"."+sourceSensor+" (computing transformation)");
             // we don't throw because this error may manifest itself after a lengthy deployment, 
             // and failing it at that point simply because of an enricher is not very pleasant
             // (at least not until we have good re-run support across the board)
diff --git a/core/src/main/java/org/apache/brooklyn/enricher/stock/Transformer.java b/core/src/main/java/org/apache/brooklyn/enricher/stock/Transformer.java
index ef23ab4ea5..d6c454959d 100644
--- a/core/src/main/java/org/apache/brooklyn/enricher/stock/Transformer.java
+++ b/core/src/main/java/org/apache/brooklyn/enricher/stock/Transformer.java
@@ -43,10 +43,9 @@
     public static ConfigKey<?> TARGET_VALUE = ConfigKeys.newConfigKey(Object.class, "enricher.targetValue");
     public static ConfigKey<Function<?, ?>> TRANSFORMATION_FROM_VALUE = ConfigKeys.newConfigKey(new TypeToken<Function<?, ?>>() {}, "enricher.transformation");
     public static ConfigKey<Function<?, ?>> TRANSFORMATION_FROM_EVENT = ConfigKeys.newConfigKey(new TypeToken<Function<?, ?>>() {}, "enricher.transformation.fromevent");
-    
-    public Transformer() {
-    }
 
+    public Transformer() { }
+    
     /** returns a function for transformation, for immediate use only (not for caching, as it may change) */
     @Override
     @SuppressWarnings("unchecked")
diff --git a/core/src/test/java/org/apache/brooklyn/core/entity/DependentConfigurationTest.java b/core/src/test/java/org/apache/brooklyn/core/entity/DependentConfigurationTest.java
index acd3a7d683..6d73c6df80 100644
--- a/core/src/test/java/org/apache/brooklyn/core/entity/DependentConfigurationTest.java
+++ b/core/src/test/java/org/apache/brooklyn/core/entity/DependentConfigurationTest.java
@@ -31,11 +31,11 @@
 
 import org.apache.brooklyn.api.entity.EntitySpec;
 import org.apache.brooklyn.api.mgmt.Task;
-import org.apache.brooklyn.core.entity.Attributes;
-import org.apache.brooklyn.core.entity.Entities;
+import org.apache.brooklyn.api.sensor.AttributeSensor;
 import org.apache.brooklyn.core.entity.lifecycle.Lifecycle;
 import org.apache.brooklyn.core.entity.lifecycle.ServiceStateLogic;
 import org.apache.brooklyn.core.sensor.DependentConfiguration;
+import org.apache.brooklyn.core.sensor.Sensors;
 import org.apache.brooklyn.core.test.BrooklynAppUnitTestSupport;
 import org.apache.brooklyn.core.test.entity.TestEntity;
 import org.apache.brooklyn.test.Asserts;
@@ -109,6 +109,51 @@ public void testFormatString() throws Exception {
         Assert.assertEquals(t.get(TIMEOUT_MS, TimeUnit.MILLISECONDS), "http://localhost:8081/");
     }
 
+    @Test
+    public void testRegexReplacementFunctionWithStrings() throws Exception {
+        Task<Function<String, String>> task = DependentConfiguration.regexReplacement("foo", "bar");
+        submit(task);
+        Function<String, String> regexReplacer = task.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
+        Assert.assertEquals(regexReplacer.apply("somefootext"), "somebartext");
+    }
+
+    @Test
+    public void testRegexReplacementFunctionWithAttributeWhenReady() throws Exception {
+        AttributeSensor<Object> replacementSensor = Sensors.newSensor(Object.class, "test.replacement");
+        Task<String> pattern = DependentConfiguration.attributeWhenReady(entity, TestEntity.NAME);
+        Task<Object> replacement = DependentConfiguration.attributeWhenReady(entity, replacementSensor);
+        Task<Function<String, String>> task = DependentConfiguration.regexReplacement(pattern, replacement);
+        submit(task);
+        entity.sensors().set(TestEntity.NAME, "foo");
+        entity.sensors().set(replacementSensor, "bar");
+        Function<String, String> regexReplacer = task.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
+        Assert.assertEquals(regexReplacer.apply("somefootext"), "somebartext");
+    }
+
+    @Test
+    public void testRegexReplacementWithStrings() throws Exception {
+        Task<String> task = DependentConfiguration.regexReplacement("somefootext", "foo", "bar");
+        submit(task);
+        String result = task.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
+        Assert.assertEquals(result, "somebartext");
+    }
+
+    @Test
+    public void testRegexReplacementWithAttributeWhenReady() throws Exception {
+        AttributeSensor<String> sourceSensor = Sensors.newStringSensor("test.source");
+        AttributeSensor<String> replacementSensor = Sensors.newSensor(String.class, "test.replacement");
+        Task<String> source = DependentConfiguration.attributeWhenReady(entity, sourceSensor);
+        Task<String> pattern = DependentConfiguration.attributeWhenReady(entity, TestEntity.NAME);
+        Task<String> replacement = DependentConfiguration.attributeWhenReady(entity, replacementSensor);
+        Task<String> task = DependentConfiguration.regexReplacement(source, pattern, replacement);
+        submit(task);
+        entity.sensors().set(sourceSensor, "somefootext");
+        entity.sensors().set(TestEntity.NAME, "foo");
+        entity.sensors().set(replacementSensor, "bar");
+        String result = task.get(TIMEOUT_MS, TimeUnit.MILLISECONDS);
+        Assert.assertEquals(result, "somebartext");
+    }
+
     @Test
     public void testAttributeWhenReady() throws Exception {
         final Task<String> t = submit(DependentConfiguration.attributeWhenReady(entity, TestEntity.NAME));
diff --git a/usage/camp/src/main/java/org/apache/brooklyn/camp/brooklyn/spi/dsl/BrooklynDslInterpreter.java b/usage/camp/src/main/java/org/apache/brooklyn/camp/brooklyn/spi/dsl/BrooklynDslInterpreter.java
index 2a7649efe2..f43d33c4b9 100644
--- a/usage/camp/src/main/java/org/apache/brooklyn/camp/brooklyn/spi/dsl/BrooklynDslInterpreter.java
+++ b/usage/camp/src/main/java/org/apache/brooklyn/camp/brooklyn/spi/dsl/BrooklynDslInterpreter.java
@@ -168,8 +168,15 @@ public Object evaluateOn(Object o, FunctionWithArgs f, boolean deepEvaluation) {
         
         String fn = f.getFunction();
         fn = Strings.removeFromStart(fn, "$brooklyn:");
+        if (fn.startsWith("function.")) {
+            // If the function name starts with 'function.', then we look for the function in BrooklynDslCommon.Functions
+            // As all functions in BrooklynDslCommon.Functions are static, we don't need to worry whether a class
+            // or an instance was passed into this method
+            o = BrooklynDslCommon.Functions.class;
+            fn = Strings.removeFromStart(fn, "function.");
+        }
         try {
-            List<Object> args = new ArrayList<Object>();
+            List<Object> args = new ArrayList<>();
             for (Object arg: f.getArgs()) {
                 args.add( deepEvaluation ? evaluate(arg, true) : arg );
             }
diff --git a/usage/camp/src/main/java/org/apache/brooklyn/camp/brooklyn/spi/dsl/methods/BrooklynDslCommon.java b/usage/camp/src/main/java/org/apache/brooklyn/camp/brooklyn/spi/dsl/methods/BrooklynDslCommon.java
index 92dc14e700..1a7d20ac0d 100644
--- a/usage/camp/src/main/java/org/apache/brooklyn/camp/brooklyn/spi/dsl/methods/BrooklynDslCommon.java
+++ b/usage/camp/src/main/java/org/apache/brooklyn/camp/brooklyn/spi/dsl/methods/BrooklynDslCommon.java
@@ -18,11 +18,14 @@
  */
 package org.apache.brooklyn.camp.brooklyn.spi.dsl.methods;
 
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.Callable;
 
+import javax.annotation.Nullable;
+
 import org.apache.brooklyn.api.entity.Entity;
 import org.apache.brooklyn.api.mgmt.Task;
 import org.apache.brooklyn.api.mgmt.TaskAdaptable;
@@ -191,6 +194,14 @@ public static Object formatString(final String pattern, final Object...args) {
         }
     }
 
+    public static Object regexReplacement(final Object source, final Object pattern, final Object replacement) {
+        if (DslUtils.resolved(Arrays.asList(source, pattern, replacement))) {
+            return (new Functions.RegexReplacer(String.valueOf(pattern), String.valueOf(replacement))).apply(String.valueOf(source));
+        } else {
+            return new DslRegexReplacement(source, pattern, replacement);
+        }
+    }
+
     /**
      * Deferred execution of String formatting.
      *
@@ -221,6 +232,31 @@ public String toString() {
         }
     }
 
+
+
+    protected static class DslRegexReplacement extends BrooklynDslDeferredSupplier<String> {
+
+        private Object source;
+        private Object pattern;
+        private Object replacement;
+
+        public DslRegexReplacement(Object source, Object pattern, Object replacement) {
+            this.pattern = pattern;
+            this.replacement = replacement;
+            this.source = source;
+        }
+
+        @Override
+        public Task<String> newTask() {
+            return DependentConfiguration.regexReplacement(source, pattern, replacement);
+        }
+
+        @Override
+        public String toString() {
+            return String.format("$brooklyn:regexReplace(%s:%s:%s)",source, pattern, replacement);
+        }
+    }
+
     /** @deprecated since 0.7.0; use {@link DslFormatString} */
     @SuppressWarnings("serial")
     @Deprecated
@@ -347,4 +383,51 @@ public String toString() {
         }
     }
 
+    public static class Functions {
+        public static Object regexReplacement(final Object pattern, final Object replacement) {
+            if (DslUtils.resolved(pattern, replacement)) {
+                return new RegexReplacer(String.valueOf(pattern), String.valueOf(replacement));
+            } else {
+                return new DslRegexReplacer(pattern, replacement);
+            }
+        }
+
+        public static class RegexReplacer implements Function<String, String> {
+            private final String pattern;
+            private final String replacement;
+
+            public RegexReplacer(String pattern, String replacement) {
+                this.pattern = pattern;
+                this.replacement = replacement;
+            }
+
+            @Nullable
+            @Override
+            public String apply(@Nullable String s) {
+                return s == null ? null : Strings.replaceAllRegex(s, pattern, replacement);
+            }
+        }
+
+        protected static class DslRegexReplacer extends BrooklynDslDeferredSupplier<Function<String, String>> {
+
+            private Object pattern;
+            private Object replacement;
+
+            public DslRegexReplacer(Object pattern, Object replacement) {
+                this.pattern = pattern;
+                this.replacement = replacement;
+            }
+
+            @Override
+            public Task<Function<String, String>> newTask() {
+                return DependentConfiguration.regexReplacement(pattern, replacement);
+            }
+
+            @Override
+            public String toString() {
+                return String.format("$brooklyn:regexReplace(%s:%s)", pattern, replacement);
+            }
+        }
+    }
+
 }
diff --git a/usage/camp/src/test/java/org/apache/brooklyn/camp/brooklyn/DslAndRebindYamlTest.java b/usage/camp/src/test/java/org/apache/brooklyn/camp/brooklyn/DslAndRebindYamlTest.java
index 42bf9f11c4..39b7ab5d11 100644
--- a/usage/camp/src/test/java/org/apache/brooklyn/camp/brooklyn/DslAndRebindYamlTest.java
+++ b/usage/camp/src/test/java/org/apache/brooklyn/camp/brooklyn/DslAndRebindYamlTest.java
@@ -25,6 +25,7 @@
 import org.apache.brooklyn.api.entity.Application;
 import org.apache.brooklyn.api.entity.Entity;
 import org.apache.brooklyn.api.mgmt.ManagementContext;
+import org.apache.brooklyn.api.sensor.AttributeSensor;
 import org.apache.brooklyn.api.sensor.Sensor;
 import org.apache.brooklyn.config.ConfigKey;
 import org.apache.brooklyn.core.config.ConfigKeys;
@@ -35,6 +36,7 @@
 import org.apache.brooklyn.core.mgmt.rebind.RebindTestUtils;
 import org.apache.brooklyn.core.sensor.Sensors;
 import org.apache.brooklyn.core.test.entity.TestEntity;
+import org.apache.brooklyn.test.EntityTestUtils;
 import org.apache.brooklyn.util.collections.MutableSet;
 import org.apache.brooklyn.util.core.task.Tasks;
 import org.slf4j.Logger;
@@ -241,4 +243,72 @@ private Entity entityWithFormatString() throws Exception {
             "    test.confName: $brooklyn:formatString(\"hello %s\", \"world\")");
     }
 
+
+    /*
+        - type: org.apache.brooklyn.enricher.stock.Transformer
+          brooklyn.config:
+            enricher.sourceSensor: $brooklyn:sensor("mongodb.server.replicaSet.primary.endpoint")
+            enricher.targetSensor: $brooklyn:sensor("justtheport")
+            enricher.transformation: $brooklyn:function.regexReplacement("^.*:", "")
+        - type: org.apache.brooklyn.enricher.stock.Transformer
+          brooklyn.config:
+            enricher.sourceSensor: $brooklyn:sensor("mongodb.server.replicaSet.primary.endpoint")
+            enricher.targetSensor: $brooklyn:sensor("directport")
+            enricher.targetValue: $brooklyn:regexReplacement($brooklyn:attributeWhenReady("mongodb.server.replicaSet.primary.endpoint"), "^.*:", "foo")
+     */
+
+    @Test
+    public void testRegexReplacementWithStrings() throws Exception {
+        Entity testEntity = setupAndCheckTestEntityInBasicYamlWith(
+                "  brooklyn.config:",
+                "    test.regex.config: $brooklyn:regexReplacement(\"somefooname\", \"foo\", \"bar\")"
+        );
+        Assert.assertEquals("somebarname", testEntity.getConfig(ConfigKeys.newStringConfigKey("test.regex.config")));
+    }
+
+    @Test
+    public void testRegexReplacementWithAttributeWhenReady() throws Exception {
+        Entity testEntity = setupAndCheckTestEntityInBasicYamlWith(
+                "  brooklyn.config:",
+                "    test.regex.config: $brooklyn:regexReplacement($brooklyn:attributeWhenReady(\"test.regex.source\"), $brooklyn:attributeWhenReady(\"test.regex.pattern\"), $brooklyn:attributeWhenReady(\"test.regex.replacement\"))"
+        );
+        testEntity.sensors().set(Sensors.newStringSensor("test.regex.source"), "somefooname");
+        testEntity.sensors().set(Sensors.newStringSensor("test.regex.pattern"), "foo");
+        testEntity.sensors().set(Sensors.newStringSensor("test.regex.replacement"), "bar");
+
+        Assert.assertEquals("somebarname", testEntity.getConfig(ConfigKeys.newStringConfigKey("test.regex.config")));
+    }
+
+    @Test
+    public void testRegexReplacementFunctionWithStrings() throws Exception {
+        Entity testEntity = setupAndCheckTestEntityInBasicYamlWith(
+                "  brooklyn.enrichers:",
+                "  - type: org.apache.brooklyn.enricher.stock.Transformer",
+                "    brooklyn.config:",
+                "      enricher.sourceSensor: $brooklyn:sensor(\"test.name\")",
+                "      enricher.targetSensor: $brooklyn:sensor(\"test.name.transformed\")",
+                "      enricher.transformation: $brooklyn:function.regexReplacement(\"foo\", \"bar\")"
+        );
+        testEntity.sensors().set(TestEntity.NAME, "somefooname");
+        AttributeSensor<String> transformedSensor = Sensors.newStringSensor("test.name.transformed");
+        EntityTestUtils.assertAttributeEqualsEventually(testEntity, transformedSensor, "somebarname");
+    }
+
+    @Test
+    public void testRegexReplacementFunctionWithAttributeWhenReady() throws Exception {
+        Entity testEntity = setupAndCheckTestEntityInBasicYamlWith(
+                "  brooklyn.enrichers:",
+                "  - type: org.apache.brooklyn.enricher.stock.Transformer",
+                "    brooklyn.config:",
+                "      enricher.sourceSensor: $brooklyn:sensor(\"test.name\")",
+                "      enricher.targetSensor: $brooklyn:sensor(\"test.name.transformed\")",
+                "      enricher.transformation: $brooklyn:function.regexReplacement($brooklyn:attributeWhenReady(\"test.pattern\"), $brooklyn:attributeWhenReady(\"test.replacement\"))"
+        );
+        testEntity.sensors().set(Sensors.newStringSensor("test.pattern"), "foo");
+        testEntity.sensors().set(Sensors.newStringSensor("test.replacement"), "bar");
+        testEntity.sensors().set(TestEntity.NAME, "somefooname");
+        AttributeSensor<String> transformedSensor = Sensors.newStringSensor("test.name.transformed");
+        EntityTestUtils.assertAttributeEqualsEventually(testEntity, transformedSensor, "somebarname");
+    }
+
 }
diff --git a/utils/common/src/main/java/org/apache/brooklyn/util/text/StringFunctions.java b/utils/common/src/main/java/org/apache/brooklyn/util/text/StringFunctions.java
index dd9a980843..ec2c023f6d 100644
--- a/utils/common/src/main/java/org/apache/brooklyn/util/text/StringFunctions.java
+++ b/utils/common/src/main/java/org/apache/brooklyn/util/text/StringFunctions.java
@@ -383,16 +383,33 @@ public static Function<String, String> convertCase(final CaseFormat src, final C
     }
     
     protected static class ConvertCaseFunction implements Function<String, String> {
-        private final CaseFormat src;
-        private final CaseFormat target;
+       private final CaseFormat src;
+       private final CaseFormat target;
 
-        public ConvertCaseFunction(CaseFormat src, CaseFormat target) {
-            this.src = src;
-            this.target = target;
+       public ConvertCaseFunction(CaseFormat src, CaseFormat target) {
+          this.src = src;
+          this.target = target;
+       }
+
+       @Override
+       public String apply(String input) {
+          return src.to(target, input);
+       }
+    }
+
+    public static class RegexReplacer implements Function<String, String> {
+        private final String pattern;
+        private final String replacement;
+
+        public RegexReplacer(String pattern, String replacement) {
+            this.pattern = pattern;
+            this.replacement = replacement;
         }
+
+        @Nullable
         @Override
-        public String apply(String input) {
-            return src.to(target, input);
+        public String apply(@Nullable String s) {
+            return Strings.replaceAllRegex(s, pattern, replacement);
         }
     }
 }
