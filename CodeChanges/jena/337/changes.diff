diff --git a/jena-arq/src/main/java/org/apache/jena/query/TxnType.java b/jena-arq/src/main/java/org/apache/jena/query/TxnType.java
index a315a139f1..56c841a478 100644
--- a/jena-arq/src/main/java/org/apache/jena/query/TxnType.java
+++ b/jena-arq/src/main/java/org/apache/jena/query/TxnType.java
@@ -36,11 +36,11 @@ public enum TxnType {
      * exception.
      * 
      * <li>{@code READ_COMMITTED_PROMOTE}: Use this with care. The promotion will succeed but 
-     * changes from oher transactions become visible.
+     * changes from other transactions become visible.
      * </ul>
      * 
      * Read committed: at the point transaction attempts promotion from "read" to
-     * "write", the sytem checks if the datset has chnage since the trsnaction started
+     * "write", the system checks if the dataset has changed since the transaction started
      * (called {@code begin}). If {@code READ_PROMOTE}, the dataset must not have
      * changed; if {@code READ_COMMITTED_PROMOTE} any intermediate changes are
      * visible but the application can not assume any data it has read in the
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/core/Transactional.java b/jena-arq/src/main/java/org/apache/jena/sparql/core/Transactional.java
index 85f3b5de2f..271e287066 100644
--- a/jena-arq/src/main/java/org/apache/jena/sparql/core/Transactional.java
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/core/Transactional.java
@@ -63,21 +63,21 @@ public interface Transactional
 {
     /**
      * Start a transaction which is READ mode and which will switch to WRITE if an update
-     * is attempted but only if no intermdiate transaction has performed an update. 
+     * is attempted but only if no intermediate transaction has performed an update. 
      * <p>
      * See {@link #begin(TxnType)} for more details an options.
      * <p>
-     * May not be implemented. See {@link #begin(ReadWrite)} is guaranted to be provided.
+     * May not be implemented. See {@link #begin(ReadWrite)} is guaranteed to be provided.
      */
     public default void begin() { begin(TxnType.READ_PROMOTE); }
     
     /**
      * Start a transaction.<br/>
-     * READ or WRITE transactions start in that state and do not chnage for the
+     * READ or WRITE transactions start in that state and do not change for the
      * lifetime of the transaction.
      * <ul>
      * 
-     * <li>{@code WRITE}: this gaurantees a WRITE will complete if {@code commit()} is
+     * <li>{@code WRITE}: this guarantees a WRITE will complete if {@code commit()} is
      * called. The same as {@code begin(ReadWrite.WRITE)}.
      * 
      * <li>{@code READ}: the transaction can not promote to WRITE,ensuring read-only
@@ -88,14 +88,14 @@ public interface Transactional
      * transaction. See also {@link #promote}.
      * 
      * <li>{@code READ_COMMITTED_PROMOTE}: Use this with care. The promotion will
-     * succeed but changes from oher transactions become visible.
+     * succeed but changes from other transactions become visible.
      * 
      * </ul>
      * 
      * Read committed: at the point transaction attempts promotion from "read" to
-     * "write", the sytem checks if the datset has chnage since the trsnaction started
+     * "write", the system checks if the dataset has change since the transaction started
      * (called {@code begin}). If {@code READ_PROMOTE}, the dataset must not have
-     * changed; if {@code READ_COMMITTED_PROMOTE} anyh intermediate changes are
+     * changed; if {@code READ_COMMITTED_PROMOTE} any intermediate changes are
      * visible but the application can not assume any data it has read in the
      * transaction is the same as it was at the point the transaction started.
      * <p>
@@ -113,13 +113,13 @@ public interface Transactional
      * Attempt to promote a transaction from "read" to "write" and the transaction
      * start with a "promote" mode ({@code READ_PROMOTE} or {@code READ_COMMITTED_PROMOTE}).
      * <p>
-     * Returns "true" if the transction is in write mode after the call.
-     * The method always succeeeds of the transaction is already
+     * Returns "true" if the transaction is in write mode after the call.
+     * The method always succeeds of the transaction is already
      * "write".
      * <p>
      * This method returns true if a {@code READ_PROMOTE} or {@code READ_COMMITTED_PROMOTE} is promoted.
      * <p>
-     * This method returns false if a {@code READ_PROMOTE} can't be promoted - the transaction is stil valid and in "read" mode. 
+     * This method returns false if a {@code READ_PROMOTE} can't be promoted - the transaction is still valid and in "read" mode. 
      * <p>
      * This method throws an exception if there is an attempt to promote a "READ" transaction. 
      */
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/core/mem/DatasetGraphInMemory.java b/jena-arq/src/main/java/org/apache/jena/sparql/core/mem/DatasetGraphInMemory.java
index 44dd8dbf57..0a48161378 100644
--- a/jena-arq/src/main/java/org/apache/jena/sparql/core/mem/DatasetGraphInMemory.java
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/core/mem/DatasetGraphInMemory.java
@@ -20,10 +20,11 @@
 
 import static java.lang.ThreadLocal.withInitial;
 import static org.apache.jena.graph.Node.ANY;
-import static org.apache.jena.query.ReadWrite.READ;
 import static org.apache.jena.query.ReadWrite.WRITE;
 import static org.apache.jena.sparql.core.Quad.isUnionGraph;
 import static org.apache.jena.sparql.util.graph.GraphUtils.triples2quadsDftGraph ;
+import static org.apache.jena.system.Txn.calculateRead;
+import static org.apache.jena.system.Txn.executeWrite;
 import static org.slf4j.LoggerFactory.getLogger;
 
 import java.util.Iterator;
@@ -33,9 +34,7 @@
 import java.util.function.Supplier;
 
 import org.apache.jena.atlas.lib.InternalErrorException ;
-import org.apache.jena.graph.Graph;
-import org.apache.jena.graph.Node;
-import org.apache.jena.graph.Triple;
+import org.apache.jena.graph.*;
 import org.apache.jena.query.ReadWrite;
 import org.apache.jena.query.TxnType;
 import org.apache.jena.shared.Lock;
@@ -315,15 +314,7 @@ private static void withLock(java.util.concurrent.locks.Lock lock, Runnable acti
     }
     
     private <T> Iterator<T> access(final Supplier<Iterator<T>> source) {
-        if (!isInTransaction()) {
-            begin(READ);
-            try {
-                return source.get();
-            } finally {
-                end();
-            }
-        }
-        return source.get();
+        return isInTransaction() ? source.get() : calculateRead(this, source::get);
     }
 
     @Override
@@ -390,33 +381,23 @@ public void removeGraph(final Node graphName) {
      * @param payload
      */
     private <T> void mutate(final Consumer<T> mutator, final T payload) {
-        if (!isInTransaction()) {
-            begin(WRITE);
-            try {
-                mutator.accept(payload);
-                commit();
-            } finally {
-                end();
-            }
-            return ;
-        }
-        if ( !transactionMode().equals(WRITE) ) {
-            TxnType mode = transactionType.get();
-            switch(mode) {
-                case WRITE :
+        if (isInTransaction()) {
+            if (!transactionMode().equals(WRITE)) {
+                TxnType mode = transactionType.get();
+                switch (mode) {
+                case WRITE:
                     break;
-                case READ :
+                case READ:
                     throw new JenaTransactionException("Tried to write inside a READ transaction!");
-                case READ_COMMITTED_PROMOTE :
-                case READ_PROMOTE :
-                {
+                case READ_COMMITTED_PROMOTE:
+                case READ_PROMOTE:
                     boolean readCommitted = (mode == TxnType.READ_COMMITTED_PROMOTE);
                     _promote(readCommitted);
                     break;
                 }
             }
-        }
-        mutator.accept(payload);
+            mutator.accept(payload);
+        } else executeWrite(this, () -> mutator.accept(payload));
     }
 
     /**
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/util/Context.java b/jena-arq/src/main/java/org/apache/jena/sparql/util/Context.java
index 783a6db008..9318cf1bd1 100644
--- a/jena-arq/src/main/java/org/apache/jena/sparql/util/Context.java
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/util/Context.java
@@ -20,8 +20,6 @@
 
 import java.util.* ;
 import java.util.concurrent.ConcurrentHashMap ;
-import java.util.function.Consumer;
-
 import org.apache.jena.atlas.lib.Lib ;
 import org.apache.jena.query.ARQ ;
 import org.apache.jena.sparql.ARQConstants ;
@@ -37,7 +35,7 @@ public class Context {
     public static final Context      emptyContext = new Context(true) ;
 
     protected Map<Symbol, Object>    context      = new ConcurrentHashMap<>() ;
-    protected List<Consumer<Symbol>> callbacks    = new ArrayList<>() ;
+
     protected boolean                readonly     = false ;
 
     /** Create an empty context */
@@ -86,13 +84,11 @@ public Object get(Symbol property, Object defaultValue) {
     /** Store a named value - overwrites any previous set value */
     public void put(Symbol property, Object value) {
         _put(property, value) ;
-        doCallbacks(property) ;
     }
 
     /** Store a named value - overwrites any previous set value */
     public void set(Symbol property, Object value) {
         _put(property, value) ;
-        doCallbacks(property) ;
     }
 
     private void _put(Symbol property, Object value) {
@@ -125,13 +121,11 @@ public void setIfUndef(Symbol property, Object value) {
     /** Remove any value associated with a property */
     public void remove(Symbol property) {
         context.remove(property) ;
-        doCallbacks(property) ;
     }
 
     /** Remove any value associated with a property - alternative method name */
     public void unset(Symbol property) {
         context.remove(property) ;
-        doCallbacks(property) ;
     }
 
     // ---- Helpers
@@ -202,10 +196,8 @@ public long getLong(Symbol symbol, long defaultValue) {
     public void putAll(Context other) {
         if ( readonly )
             throw new ARQException("Context is readonly") ;
-        if ( other != null ) {
-            for ( Map.Entry<Symbol, Object> e : other.context.entrySet() )
-                put(e.getKey(), e.getValue()) ;
-        }
+        if ( other != null )
+            other.context.forEach(this::put);
     }
 
     // -- true/false
@@ -315,23 +307,6 @@ public int size() {
         return context.size() ;
     }
 
-    // ---- Callbacks
-    public synchronized void addCallback(Consumer<Symbol> m) {
-        callbacks.add(m) ;
-    }
-
-    public synchronized void removeCallback(Consumer<Symbol> m) {
-        callbacks.remove(m) ;
-    }
-
-    public synchronized List<Consumer<Symbol>> getCallbacks() {
-        return Collections.unmodifiableList(callbacks) ;
-    }
-
-    private synchronized void doCallbacks(Symbol symbol) {
-        callbacks.forEach(c -> c.accept(symbol));
-    }
-
     @Override
     public String toString() {
         String x = "" ;
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/util/DifferenceDatasetGraph.java b/jena-arq/src/main/java/org/apache/jena/sparql/util/DifferenceDatasetGraph.java
new file mode 100644
index 0000000000..6dbdfadef4
--- /dev/null
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/util/DifferenceDatasetGraph.java
@@ -0,0 +1,103 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util;
+
+import static org.apache.jena.sparql.core.Quad.ANY;
+
+import java.util.Iterator;
+import java.util.function.Function;
+
+import org.apache.jena.graph.*;
+import org.apache.jena.graph.compose.Difference;
+import org.apache.jena.sparql.core.DatasetGraph;
+import org.apache.jena.util.iterator.ExtendedIterator;
+import org.apache.jena.util.iterator.NullIterator;
+
+public class DifferenceDatasetGraph extends DyadicDatasetGraph {
+
+	public DifferenceDatasetGraph(DatasetGraph left, DatasetGraph right, Context c) {
+		super(left, right, c);
+	}
+	
+	private Graph difference(Function<DatasetGraph, Graph> op) {
+	    return apply(DifferenceView::new, op);
+	}
+
+	@Override
+	public Graph getDefaultGraph() {
+		return difference(DatasetGraph::getDefaultGraph);
+	}
+
+	@Override
+	public Graph getGraph(Node graphNode) {
+		return difference(dsg -> dsg.getGraph(graphNode));
+	}
+
+	@Override
+	public boolean containsGraph(Node graphNode) {
+		return getLeft().containsGraph(graphNode);
+	}
+
+	@Override
+	public Iterator<Node> listGraphNodes() {
+		return getLeft().listGraphNodes();
+	}
+
+	@Override
+	public boolean contains(Node g, Node s, Node p, Node o) {
+	    return both(dsg -> dsg.contains(g, s, p, o));
+	}
+
+	@Override
+	public boolean isEmpty() {
+		return getLeft().isEmpty() || getLeft() == getRight() || !contains(ANY);
+	}
+
+	@Override
+	public long size() {
+		return getLeft().size();
+	}
+	
+    static class DifferenceView extends Difference {
+
+        public DifferenceView(Graph L, Graph R) {
+            super(L, R);
+        }
+
+        @Override
+        public void performAdd(Triple t) {
+            throwNoMutationAllowed();
+        }
+
+        @Override
+        public void performDelete(Triple t) {
+            throwNoMutationAllowed();
+        }
+        
+        @Override
+        public void clear() {
+            throwNoMutationAllowed();
+        }
+
+        @Override
+        public ExtendedIterator<Triple> _graphBaseFind(Triple s) {
+            return L.isEmpty() ? NullIterator.instance() : super._graphBaseFind(s);
+        }
+    }
+}
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/util/DyadicDatasetGraph.java b/jena-arq/src/main/java/org/apache/jena/sparql/util/DyadicDatasetGraph.java
new file mode 100644
index 0000000000..439e6c8ca2
--- /dev/null
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/util/DyadicDatasetGraph.java
@@ -0,0 +1,248 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util;
+
+import static java.util.Objects.requireNonNull;
+import static org.apache.jena.atlas.iterator.Iter.count;
+import static org.apache.jena.atlas.iterator.Iter.map;
+import static org.apache.jena.ext.com.google.common.collect.Iterators.concat;
+import static org.apache.jena.graph.Node.ANY;
+import static org.apache.jena.query.TxnType.READ;
+import static org.apache.jena.sparql.core.Quad.defaultGraphIRI;
+import static org.apache.jena.sparql.util.graph.GraphUtils.triples2quads;
+
+import java.util.Iterator;
+
+import org.apache.jena.atlas.lib.PairOfSameType;
+import org.apache.jena.graph.Graph;
+import org.apache.jena.graph.Node;
+import org.apache.jena.graph.compose.MultiUnion;
+import org.apache.jena.query.ReadWrite;
+import org.apache.jena.query.TxnType;
+import org.apache.jena.shared.Lock;
+import org.apache.jena.sparql.core.DatasetGraph;
+import org.apache.jena.sparql.core.Quad;
+
+public abstract class DyadicDatasetGraph extends PairOfSameType<DatasetGraph> implements DatasetGraph {
+
+    private Context context;
+
+    private final Lock lock;
+
+    protected DyadicDatasetGraph(DatasetGraph left, DatasetGraph right, Context c) {
+        super(requireNonNull(left), requireNonNull(right));
+        this.context = requireNonNull(c);
+        this.lock = new PairLock(left.getLock(), right.getLock());
+    }
+
+    protected static void throwNoMutationAllowed() {
+        throw new UnsupportedOperationException("This view does not allow mutation!");
+    }
+
+    @Override
+    public void commit() {
+        throwNoMutationAllowed();
+    }
+
+    @Override
+    public void begin(TxnType type) {
+        switch (type) {
+        case READ:
+            forEach(dsg -> dsg.begin(type));
+            break;
+        default:
+            throwNoMutationAllowed();
+        }
+    }
+
+    @Override
+    public boolean promote() {
+        // no mutation allowed
+        return false;
+    }
+
+    @Override
+    public ReadWrite transactionMode() {
+        return TxnType.convert(transactionType());
+    }
+
+    @Override
+    public TxnType transactionType() {
+        return both(dsg -> dsg.transactionType() == READ) ? READ : null;
+    }
+
+    @Override
+    public synchronized void begin(ReadWrite readWrite) {
+        begin(TxnType.convert(readWrite));
+    }
+
+    @Override
+    public void abort() {
+        forEach(DatasetGraph::abort);
+    }
+
+    @Override
+    public void end() {
+        forEach(DatasetGraph::end);
+    }
+
+    @Override
+    public boolean isInTransaction() {
+        return either(DatasetGraph::isInTransaction);
+    }
+
+    @Override
+    public void setDefaultGraph(Graph g) {
+        throwNoMutationAllowed();
+    }
+
+    @Override
+    public void addGraph(Node graphName, Graph graph) {
+        throwNoMutationAllowed();
+    }
+
+    @Override
+    public void removeGraph(Node graphName) {
+        throwNoMutationAllowed();
+    }
+
+    @Override
+    public void add(Quad quad) {
+        throwNoMutationAllowed();
+    }
+
+    @Override
+    public void delete(Quad quad) {
+        throwNoMutationAllowed();
+    }
+
+    @Override
+    public void add(Node g, Node s, Node p, Node o) {
+        throwNoMutationAllowed();
+    }
+
+    @Override
+    public void delete(Node g, Node s, Node p, Node o) {
+        throwNoMutationAllowed();
+    }
+
+    @Override
+    public void deleteAny(Node g, Node s, Node p, Node o) {
+        throwNoMutationAllowed();
+    }
+
+    @Override
+    public void clear() {
+        throwNoMutationAllowed();
+    }
+
+    @Override
+    public Iterator<Quad> find() {
+        return find(Quad.ANY);
+    }
+
+    @Override
+    public Iterator<Quad> find(Quad q) {
+        return find(q.getGraph(), q.getSubject(), q.getPredicate(), q.getObject());
+    }
+
+    @Override
+    public Iterator<Quad> find(Node g, Node s, Node p, Node o) {
+        return g.isConcrete()
+                ? findInOneGraph(g, s, p, o)
+                : concat(findNG(ANY, s, p, o), findInOneGraph(defaultGraphIRI, s, p, o));
+    }
+
+    @Override
+    public Iterator<Quad> findNG(Node g, Node s, Node p, Node o) {
+        return g.isConcrete()
+                ? findInOneGraph(g, s, p, o)
+                : concat(map(listGraphNodes(), gn -> findInOneGraph(gn, s, p, o)));
+    }
+
+    protected Iterator<Quad> findInOneGraph(Node g, Node s, Node p, Node o) {
+        return triples2quads(g, getGraph(g).find(s, p, o));
+    }
+
+    @Override
+    public Graph getUnionGraph() {
+        return new MultiUnion(map(listGraphNodes(), this::getGraph));
+    }
+
+    @Override
+    public boolean contains(Quad q) {
+        return contains(q.getGraph(), q.getSubject(), q.getPredicate(), q.getObject());
+    }
+
+    @Override
+    public Lock getLock() {
+        return lock;
+    }
+
+    @Override
+    public Context getContext() {
+        return context;
+    }
+
+    public DatasetGraph setContext(Context c) {
+        this.context = c;
+        return this;
+    }
+
+    @Override
+    public void close() {
+    }
+
+    @Override
+    public boolean supportsTransactions() {
+        return both(DatasetGraph::supportsTransactions);
+    }
+
+    @Override
+    public boolean supportsTransactionAbort() {
+        return both(DatasetGraph::supportsTransactionAbort);
+    }
+
+    @Override
+    public long size() {
+        return count(listGraphNodes());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return listGraphNodes().hasNext();
+    }
+
+    private static class PairLock extends PairOfSameType<Lock> implements Lock {
+
+        public PairLock(Lock left, Lock right) {
+            super(left, right);
+        }
+
+        @Override
+        public void enterCriticalSection(boolean readLockRequested) {
+            forEach(lock -> lock.enterCriticalSection(readLockRequested));
+        }
+
+        @Override
+        public void leaveCriticalSection() {
+            forEach(Lock::leaveCriticalSection);
+        }
+    }
+}
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/util/IntersectionDatasetGraph.java b/jena-arq/src/main/java/org/apache/jena/sparql/util/IntersectionDatasetGraph.java
new file mode 100644
index 0000000000..469f64b5f8
--- /dev/null
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/util/IntersectionDatasetGraph.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util;
+
+import static org.apache.jena.atlas.iterator.Iter.iter;
+
+import java.util.Iterator;
+import java.util.function.Function;
+
+import org.apache.jena.graph.*;
+import org.apache.jena.graph.compose.Intersection;
+import org.apache.jena.sparql.core.DatasetGraph;
+import org.apache.jena.util.iterator.ExtendedIterator;
+import org.apache.jena.util.iterator.NullIterator;
+
+public class IntersectionDatasetGraph extends DyadicDatasetGraph {
+  
+    public IntersectionDatasetGraph(DatasetGraph left, DatasetGraph right, Context c) {
+        super(left, right, c);
+    }
+
+    Graph intersect(Function<DatasetGraph, Graph> op) {
+        return apply(IntersectionView::new, op);
+    }
+
+    @Override
+    public Graph getDefaultGraph() {
+        return intersect(DatasetGraph::getDefaultGraph);
+    }
+
+    @Override
+    public Graph getGraph(Node graphNode) {
+        return intersect(dsg -> dsg.getGraph(graphNode));
+    }
+
+    @Override
+    public boolean containsGraph(Node graphNode) {
+        return both(dsg -> dsg.containsGraph(graphNode) && !dsg.getGraph(graphNode).isEmpty());
+    }
+
+    @Override
+    public Iterator<Node> listGraphNodes() {
+        return iter(getLeft().listGraphNodes()).filter(getRight()::containsGraph);
+    }
+
+    @Override
+    public boolean contains(Node g, Node s, Node p, Node o) {
+        return both(dsg -> dsg.contains(g, s, p, o));
+    }
+
+    static class IntersectionView extends Intersection {
+
+        public IntersectionView(Graph L, Graph R) {
+            super(L, R);
+        }
+
+        @Override
+        public void performAdd(Triple t) {
+            throwNoMutationAllowed();
+        }
+
+        @Override
+        public void performDelete(Triple t) {
+            throwNoMutationAllowed();
+        }
+        
+        @Override
+        public void clear() {
+            throwNoMutationAllowed();
+        }
+
+        @Override
+        protected ExtendedIterator<Triple> _graphBaseFind(Triple s) {
+            return L.isEmpty() || R.isEmpty() ? NullIterator.instance() : super._graphBaseFind(s);
+        }
+    }
+}
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/util/UnionDatasetGraph.java b/jena-arq/src/main/java/org/apache/jena/sparql/util/UnionDatasetGraph.java
new file mode 100644
index 0000000000..c76ed858a1
--- /dev/null
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/util/UnionDatasetGraph.java
@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util;
+
+import java.util.Iterator;
+import java.util.function.Function;
+
+import org.apache.jena.atlas.iterator.Iter;
+import org.apache.jena.graph.*;
+import org.apache.jena.graph.compose.Union;
+import org.apache.jena.sparql.core.DatasetGraph;
+import org.apache.jena.sparql.core.Quad;
+
+public class UnionDatasetGraph extends DyadicDatasetGraph {
+
+    public UnionDatasetGraph(DatasetGraph left, DatasetGraph right, Context c) {
+        super(left, right, c);
+    }
+
+    private Graph union(Function<DatasetGraph, Graph> op) {
+        return apply(UnionView::new, op);
+    }
+
+    <T> Iter<T> fromEach(Function<DatasetGraph, Iterator<T>> op) {
+        return apply(Iter::concat, op).distinct();
+    }
+
+    @Override
+    public Graph getDefaultGraph() {
+        return union(DatasetGraph::getDefaultGraph);
+    }
+
+    @Override
+    public Graph getGraph(Node graphNode) {
+        return union(dsg -> dsg.getGraph(graphNode));
+    }
+
+    @Override
+    public Graph getUnionGraph() {
+        return union(DatasetGraph::getUnionGraph);
+    }
+
+    @Override
+    public boolean containsGraph(Node graphNode) {
+        return either(dsg -> dsg.containsGraph(graphNode));
+    }
+
+    @Override
+    public Iterator<Node> listGraphNodes() {
+        return fromEach(DatasetGraph::listGraphNodes);
+    }
+
+    @Override
+    public Iterator<Quad> find(Node g, Node s, Node p, Node o) {
+        return fromEach(dsg -> dsg.find(g, s, p, o));
+    }
+
+    @Override
+    public Iterator<Quad> findNG(Node g, Node s, Node p, Node o) {
+        return fromEach(dsg -> dsg.findNG(g, s, p, o));
+    }
+
+    @Override
+    public boolean contains(Node g, Node s, Node p, Node o) {
+        return either(dsg -> dsg.contains(g, s, p, o));
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return both(DatasetGraph::isEmpty);
+    }
+    
+    static class UnionView extends Union {
+
+        public UnionView(Graph L, Graph R) {
+            super(L, R);
+        }
+
+        @Override
+        public void performAdd(Triple t) {
+            throwNoMutationAllowed();
+        }
+
+        @Override
+        public void performDelete(Triple t) {
+            throwNoMutationAllowed();
+        }
+        
+        @Override
+        public void clear() {
+            throwNoMutationAllowed();
+        }
+    }
+}
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/util/compose/DatasetCollector.java b/jena-arq/src/main/java/org/apache/jena/sparql/util/compose/DatasetCollector.java
new file mode 100644
index 0000000000..e44e40029e
--- /dev/null
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/util/compose/DatasetCollector.java
@@ -0,0 +1,125 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util.compose;
+
+import static org.apache.jena.system.Txn.*;
+
+import java.util.function.*;
+
+import org.apache.jena.atlas.lib.IdentityFinishCollector.UnorderedIdentityFinishCollector;
+import org.apache.jena.query.Dataset;
+import org.apache.jena.query.DatasetFactory;
+import org.apache.jena.rdf.model.Model;
+
+public abstract class DatasetCollector implements UnorderedIdentityFinishCollector<Dataset, Dataset> {
+
+    @Override
+    public Supplier<Dataset> supplier() {
+        return DatasetFactory::createTxnMem;
+    }
+
+    public ConcurrentDatasetCollector concurrent() {
+        return new ConcurrentDatasetCollector(this);
+    }
+
+    /**
+     * Use only with {@link Dataset}s that support transactions.
+     */
+    public static class ConcurrentDatasetCollector extends DatasetCollector
+            implements ConcurrentUnorderedIdentityFinishCollector<Dataset, Dataset> {
+
+        private final DatasetCollector collector;
+
+        public ConcurrentDatasetCollector(DatasetCollector col) {
+            this.collector = col;
+        }
+
+        @Override
+        public BinaryOperator<Dataset> combiner() {
+            return (d1, d2) ->  calculateRead(d2, () -> calculateWrite(d1, () -> collector.combiner().apply(d1, d2)));
+        }
+
+        @Override
+        public BiConsumer<Dataset, Dataset> accumulator() {
+            return (d1, d2) -> executeRead(d2, () -> executeWrite(d1, () -> collector.accumulator().accept(d1, d2)));
+        }
+    }
+
+    public static class UnionDatasetCollector extends DatasetCollector {
+
+        @Override
+        public BinaryOperator<Dataset> combiner() {
+            return DatasetLib::union;
+        }
+
+        @Override
+        public BiConsumer<Dataset, Dataset> accumulator() {
+            return (d1, d2) -> {
+                d1.getDefaultModel().add(d2.getDefaultModel());
+                d2.listNames().forEachRemaining(name -> {
+                    Model union = d1.getNamedModel(name).union(d2.getNamedModel(name));
+                    d1.replaceNamedModel(name, union);
+                });
+            };
+        }
+    }
+
+    public static class IntersectionDatasetCollector extends DatasetCollector {
+
+        /**
+         * The first element is treated differently because
+         * {@link DatasetCollector#supplier()} does not provide an identity element for
+         * intersection.
+         */
+        private volatile boolean afterFirstElement = false;
+
+        @Override
+        public BinaryOperator<Dataset> combiner() {
+            return DatasetLib::intersection;
+        }
+
+        @Override
+        public BiConsumer<Dataset, Dataset> accumulator() {
+            return (d1, d2) -> {
+                if (afterFirstElement) {
+                    d1.setDefaultModel(d1.getDefaultModel().intersection(d2.getDefaultModel()));
+                    d1.listNames().forEachRemaining(name -> {
+                        if (d2.containsNamedModel(name)) {
+                            Model intersection = d1.getNamedModel(name).intersection(d2.getNamedModel(name));
+                            d1.replaceNamedModel(name, intersection);
+                        } else d1.removeNamedModel(name);
+                    });
+                } else {
+                    // first element of the stream
+                    d1.setDefaultModel(d2.getDefaultModel());
+                    d2.listNames().forEachRemaining(name -> d1.replaceNamedModel(name, d2.getNamedModel(name)));
+                    afterFirstElement = true;
+                }
+            };
+        }
+    }
+
+    static DatasetCollector union() {
+        return new UnionDatasetCollector();
+    }
+
+    static DatasetCollector intersect() {
+        return new IntersectionDatasetCollector();
+    }
+}
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/util/compose/DatasetLib.java b/jena-arq/src/main/java/org/apache/jena/sparql/util/compose/DatasetLib.java
new file mode 100644
index 0000000000..db45d7fd35
--- /dev/null
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/util/compose/DatasetLib.java
@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util.compose;
+
+import static org.apache.jena.sparql.util.Context.emptyContext;
+
+import org.apache.jena.query.Dataset;
+import org.apache.jena.query.DatasetFactory;
+import org.apache.jena.sparql.util.Context;
+import org.apache.jena.sparql.util.DifferenceDatasetGraph;
+import org.apache.jena.sparql.util.IntersectionDatasetGraph;
+import org.apache.jena.sparql.util.UnionDatasetGraph;
+
+public class DatasetLib {
+
+    public static Dataset union(final Dataset d1, final Dataset d2, Context c) {
+        return DatasetFactory.wrap(new UnionDatasetGraph(d1.asDatasetGraph(), d2.asDatasetGraph(), c));
+    }
+
+    public static Dataset union(final Dataset d1, final Dataset d2) {
+        return union(d1, d2, emptyContext);
+    }
+
+    public static Dataset intersection(final Dataset d1, final Dataset d2, Context c) {
+        return DatasetFactory.wrap(new IntersectionDatasetGraph(d1.asDatasetGraph(), d2.asDatasetGraph(), c));
+    }
+
+    public static Dataset intersection(final Dataset d1, final Dataset d2) {
+        return intersection(d1, d2, emptyContext);
+    }
+
+    public static Dataset difference(final Dataset d1, final Dataset d2, Context c) {
+        return DatasetFactory.wrap(new DifferenceDatasetGraph(d1.asDatasetGraph(), d2.asDatasetGraph(), c));
+    }
+
+    public static Dataset difference(final Dataset d1, final Dataset d2) {
+        return DatasetFactory.wrap(new DifferenceDatasetGraph(d1.asDatasetGraph(), d2.asDatasetGraph(), emptyContext));
+    }
+
+    public static Collectors collectors() {
+        return Collectors.instance;
+    }
+
+    public static class Collectors {
+
+        private static final Collectors instance = new Collectors();
+
+        public DatasetCollector union() {
+            return DatasetCollector.union();
+        }
+
+        public DatasetCollector intersect() {
+            return DatasetCollector.intersect();
+        }
+    }
+}
diff --git a/jena-arq/src/main/java/org/apache/jena/system/Txn.java b/jena-arq/src/main/java/org/apache/jena/system/Txn.java
index 5a92a0455b..dc7158b5e2 100644
--- a/jena-arq/src/main/java/org/apache/jena/system/Txn.java
+++ b/jena-arq/src/main/java/org/apache/jena/system/Txn.java
@@ -37,7 +37,7 @@ public class Txn {
      * <p>
      * Such a transaction may abort if an update is executed
      * by another thread before this one is promoted to "write" mode.
-     * If so, the data protected by {@code txn} is unchanaged.
+     * If so, the data protected by {@code txn} is unchanged.
      * <p>
      * If the application knows updates will be needed, consider using {@link #executeWrite}
      * which starts in "write" mode.
@@ -55,7 +55,7 @@ public static <T extends Transactional> void execute(T txn, Runnable r) {
      * <p>
      * Such a transaction may abort if an update is executed
      * by another thread before this one is promoted to "write" mode.
-     * If so, the data protected by {@code txn} is unchanaged.
+     * If so, the data protected by {@code txn} is unchanged.
      * <p>
      * If the application knows updates will be needed, consider using {@link #executeWrite}
      * which starts in "write" mode.
diff --git a/jena-arq/src/test/java/org/apache/jena/sparql/util/TS_DyadicDatasetGraphs.java b/jena-arq/src/test/java/org/apache/jena/sparql/util/TS_DyadicDatasetGraphs.java
new file mode 100644
index 0000000000..643b41b7b1
--- /dev/null
+++ b/jena-arq/src/test/java/org/apache/jena/sparql/util/TS_DyadicDatasetGraphs.java
@@ -0,0 +1,28 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Suite;
+import org.junit.runners.Suite.SuiteClasses;
+
+@RunWith(Suite.class)
+@SuiteClasses({ TestIntersectionDatasetGraph.class, TestDifferenceDatasetGraph.class, TestUnionDatasetGraph.class })
+
+public class TS_DyadicDatasetGraphs {}
diff --git a/jena-arq/src/test/java/org/apache/jena/sparql/util/TS_Util.java b/jena-arq/src/test/java/org/apache/jena/sparql/util/TS_Util.java
index 18fd5bd292..40f108db1a 100644
--- a/jena-arq/src/test/java/org/apache/jena/sparql/util/TS_Util.java
+++ b/jena-arq/src/test/java/org/apache/jena/sparql/util/TS_Util.java
@@ -19,6 +19,7 @@
 package org.apache.jena.sparql.util;
 
 import org.apache.jena.atlas.lib.TestDateTimeUtils ;
+import org.apache.jena.sparql.util.compose.TS_DatasetCollectors;
 import org.junit.runner.RunWith ;
 import org.junit.runners.Suite ;
 import org.junit.runners.Suite.SuiteClasses ;
@@ -28,8 +29,9 @@
     TestDateTimeParsing.class ,
     TestList.class ,
     TestDateTimeUtils.class ,
-    TestFmtUtils.class
+    TestFmtUtils.class,
+    TS_DyadicDatasetGraphs.class,
+    TS_DatasetCollectors.class
 })
-
 public class TS_Util
 { }
diff --git a/jena-arq/src/test/java/org/apache/jena/sparql/util/TestDifferenceDatasetGraph.java b/jena-arq/src/test/java/org/apache/jena/sparql/util/TestDifferenceDatasetGraph.java
new file mode 100644
index 0000000000..f3656004d1
--- /dev/null
+++ b/jena-arq/src/test/java/org/apache/jena/sparql/util/TestDifferenceDatasetGraph.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util;
+
+import static org.apache.jena.sparql.sse.SSE.parseGraph;
+
+import org.apache.jena.graph.*;
+import org.apache.jena.sparql.core.DatasetGraph;
+import org.apache.jena.sparql.core.DatasetGraphFactory;
+import org.junit.Test;
+
+public class TestDifferenceDatasetGraph extends TestDyadicDatasetGraph {
+
+    @Override
+    public DifferenceDatasetGraph testInstance(DatasetGraph left, DatasetGraph right, Context c) {
+        return new DifferenceDatasetGraph(left, right, c);
+    }
+    
+    @Test
+    public void testDifference() {
+        final Graph g1 = parseGraph("(graph (triple <s1> <p1> <o1> ))");
+        final DatasetGraph dsg1 = DatasetGraphFactory.create(g1);
+        final Node graphName1 = NodeFactory.createBlankNode();
+        dsg1.addGraph(graphName1, g1);
+        final Graph g2 = parseGraph("(graph (triple <s2> <p2> <o2> ))");
+        final DatasetGraph dsg2 = DatasetGraphFactory.create(g2);
+        final Node graphName2 = NodeFactory.createBlankNode();
+        dsg2.addGraph(graphName2, g2);
+        DatasetGraph dsg = testInstance(dsg1, dsg2, Context.emptyContext);
+
+        assertEquals(1, dsg.size());
+        assertTrue(g1.isIsomorphicWith(dsg.getGraph(graphName1)));
+        assertTrue(g1.isIsomorphicWith(dsg.getDefaultGraph()));
+        assertTrue(dsg.getGraph(graphName2).isEmpty());
+    }
+
+}
diff --git a/jena-arq/src/test/java/org/apache/jena/sparql/util/TestDyadicDatasetGraph.java b/jena-arq/src/test/java/org/apache/jena/sparql/util/TestDyadicDatasetGraph.java
new file mode 100644
index 0000000000..0113c46a22
--- /dev/null
+++ b/jena-arq/src/test/java/org/apache/jena/sparql/util/TestDyadicDatasetGraph.java
@@ -0,0 +1,233 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util;
+
+import static org.apache.jena.sparql.core.DatasetGraphFactory.createTxnMem;
+
+import org.apache.jena.atlas.junit.BaseTest;
+import org.apache.jena.graph.Node;
+import org.apache.jena.graph.NodeFactory;
+import org.apache.jena.query.ReadWrite;
+import org.apache.jena.query.TxnType;
+import org.apache.jena.sparql.core.DatasetGraph;
+import org.apache.jena.sparql.core.DatasetGraphZero;
+import org.junit.Test;
+
+public abstract class TestDyadicDatasetGraph extends BaseTest {
+
+    public abstract DatasetGraph testInstance(DatasetGraph left, DatasetGraph right, Context c);
+
+    private DatasetGraph emptyDsg() {
+        return testInstance(createTxnMem(), createTxnMem(), Context.emptyContext);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void nullDatasetGraphsNotAllowed() {
+        testInstance(null, null, Context.emptyContext);
+    }
+
+    @Test(expected = NullPointerException.class)
+    public void nullContextNotAllowed() {
+        testInstance(new DatasetGraphZero(), new DatasetGraphZero(), null);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void noAddingQuads() {
+        emptyDsg().add(null);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void noAddingQuads2() {
+        emptyDsg().add(null, null, null, null);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void noDeletingQuads() {
+        emptyDsg().delete(null);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void noDeletingQuads2() {
+        emptyDsg().delete(null, null, null, null);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void noDeletingAnyQuads() {
+        emptyDsg().deleteAny(null, null, null, null);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void noAddingGraphs() {
+        emptyDsg().addGraph(null, null);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void noDeletingGraphs() {
+        emptyDsg().removeGraph(null);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void noClearing() {
+        emptyDsg().clear();
+    }
+    
+    @Test(expected = UnsupportedOperationException.class)
+    public void noAddingToDefaultGraph() {
+        emptyDsg().getDefaultGraph().add(null);
+    }
+    
+    @Test(expected = UnsupportedOperationException.class)
+    public void noDeletingFromDefaultGraph() {
+        emptyDsg().getDefaultGraph().delete(null);
+    }
+    
+    @Test(expected = UnsupportedOperationException.class)
+    public void noAddingToANamedGraph() {
+        Node graphName = NodeFactory.createBlankNode();
+        emptyDsg().getGraph(graphName).add(null);
+    }
+    
+    @Test(expected = UnsupportedOperationException.class)
+    public void noDeletingFromANamedGraph() {
+        Node graphName = NodeFactory.createBlankNode();
+        emptyDsg().getGraph(graphName).delete(null);
+    }
+    
+    @Test(expected = UnsupportedOperationException.class)
+    public void noClearingDefaultGraph() {
+        emptyDsg().getDefaultGraph().clear();
+    }
+    
+    @Test(expected = UnsupportedOperationException.class)
+    public void noClearingANamedGraph() {
+        Node graphName = NodeFactory.createBlankNode();
+        emptyDsg().getGraph(graphName).clear();
+    }
+    
+    @Test(expected = UnsupportedOperationException.class)
+    public void noRemovingFromANamedGraph() {
+        Node graphName = NodeFactory.createBlankNode();
+        emptyDsg().getGraph(graphName).remove(null, null, null);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void noWriting1() {
+        emptyDsg().begin(ReadWrite.WRITE);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void noWriting2() {
+        emptyDsg().begin(TxnType.WRITE);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void noWriting3() {
+        emptyDsg().begin(TxnType.READ_PROMOTE);
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void noWriting4() {
+        emptyDsg().begin(TxnType.READ_COMMITTED_PROMOTE);
+    }
+    
+    @Test
+    public void noPromoting() {
+        assertFalse(emptyDsg().promote());
+    }
+
+    @Test(expected = UnsupportedOperationException.class)
+    public void noCommitting() {
+        final DatasetGraph dsg = emptyDsg();
+        assertFalse(dsg.isInTransaction());
+        dsg.begin(ReadWrite.READ);
+        assertTrue(dsg.isInTransaction());
+        dsg.commit();
+    }
+    
+    @Test
+    public void testTransactionTypeAndMode() {
+        final DatasetGraph dsg = emptyDsg();
+        assertFalse(dsg.isInTransaction());
+        try {
+            dsg.begin(TxnType.READ);
+            assertTrue(dsg.isInTransaction());
+            assertEquals(TxnType.READ, dsg.transactionType());
+            assertEquals(ReadWrite.READ, dsg.transactionMode());
+        } finally {
+            dsg.end();
+        }
+        assertFalse(dsg.isInTransaction());
+    }
+
+    @Test
+    public void canUseEndToFinishTransaction1() {
+        DatasetGraph dsg = emptyDsg();
+        assertFalse(dsg.isInTransaction());
+        try {
+            dsg.begin(ReadWrite.READ);
+            assertTrue(dsg.isInTransaction());
+            dsg.end();
+            assertFalse(dsg.isInTransaction());
+        } catch (UnsupportedOperationException e) {
+            fail();
+        }
+    }
+
+    @Test
+    public void canUseEndToFinishTransaction2() {
+        DatasetGraph dsg = emptyDsg();
+        assertFalse(dsg.isInTransaction());
+        try {
+            dsg.begin(TxnType.READ);
+            assertTrue(dsg.isInTransaction());
+            dsg.end();
+            assertFalse(dsg.isInTransaction());
+        } catch (UnsupportedOperationException e) {
+            fail();
+        }
+    }
+
+    @Test
+    public void canUseAbortToFinishTransaction1() {
+        DatasetGraph dsg = emptyDsg();
+        assertFalse(dsg.isInTransaction());
+        try {
+            dsg.begin(ReadWrite.READ);
+            assertTrue(dsg.isInTransaction());
+            dsg.abort();
+            assertFalse(dsg.isInTransaction());
+        } catch (UnsupportedOperationException e) {
+            fail();
+        }
+    }
+
+    @Test
+    public void canUseAbortToFinishTransaction2() {
+        DatasetGraph dsg = emptyDsg();
+        assertFalse(dsg.isInTransaction());
+        try {
+            dsg.begin(TxnType.READ);
+            assertTrue(dsg.isInTransaction());
+            dsg.abort();
+            assertFalse(dsg.isInTransaction());
+        } catch (UnsupportedOperationException e) {
+            fail();
+        }
+    }
+}
diff --git a/jena-arq/src/test/java/org/apache/jena/sparql/util/TestIntersectionDatasetGraph.java b/jena-arq/src/test/java/org/apache/jena/sparql/util/TestIntersectionDatasetGraph.java
new file mode 100644
index 0000000000..b76e7c3d16
--- /dev/null
+++ b/jena-arq/src/test/java/org/apache/jena/sparql/util/TestIntersectionDatasetGraph.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util;
+
+import static org.apache.jena.sparql.sse.SSE.parseGraph;
+
+import org.apache.jena.graph.*;
+import org.apache.jena.sparql.core.DatasetGraph;
+import org.apache.jena.sparql.core.DatasetGraphFactory;
+import org.junit.Test;
+
+public class TestIntersectionDatasetGraph extends TestDyadicDatasetGraph {
+
+    @Override
+    public IntersectionDatasetGraph testInstance(DatasetGraph left, DatasetGraph right, Context c) {
+        return new IntersectionDatasetGraph(left, right, c);
+    }
+
+    @Test
+    public void testIntersection() {
+        final Graph g1 = parseGraph("(graph (triple <s1> <p1> <o1> ))");
+        final DatasetGraph dsg1 = DatasetGraphFactory.create(g1);
+        final Node graphName1 = NodeFactory.createBlankNode();
+        dsg1.addGraph(graphName1, g1);
+        final Graph g2 = parseGraph("(graph (triple <s2> <p2> <o2> ))");
+        final DatasetGraph dsg2 = DatasetGraphFactory.create(g2);
+        final Node graphName2 = NodeFactory.createBlankNode();
+        dsg2.addGraph(graphName2, g2);
+        final Node graphName3 = NodeFactory.createBlankNode();
+        dsg1.addGraph(graphName3, g1);
+        dsg2.addGraph(graphName3, g1);
+        DatasetGraph dsg = testInstance(dsg1, dsg2, Context.emptyContext);
+        assertEquals(1, dsg.size());
+        assertTrue(dsg.getDefaultGraph().isEmpty());
+        assertTrue(dsg.getGraph(graphName1).isEmpty());
+        assertTrue(dsg.getGraph(graphName2).isEmpty());
+        assertTrue(g1.isIsomorphicWith(dsg.getGraph(graphName3)));
+    }
+}
diff --git a/jena-arq/src/test/java/org/apache/jena/sparql/util/TestUnionDatasetGraph.java b/jena-arq/src/test/java/org/apache/jena/sparql/util/TestUnionDatasetGraph.java
new file mode 100644
index 0000000000..e35f4d0c9b
--- /dev/null
+++ b/jena-arq/src/test/java/org/apache/jena/sparql/util/TestUnionDatasetGraph.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util;
+
+import static org.apache.jena.sparql.sse.SSE.parseGraph;
+
+import org.apache.jena.graph.*;
+import org.apache.jena.sparql.core.DatasetGraph;
+import org.apache.jena.sparql.core.DatasetGraphFactory;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class TestUnionDatasetGraph extends TestDyadicDatasetGraph {
+
+    @Override
+    public DatasetGraph testInstance(DatasetGraph left, DatasetGraph right, Context c) {
+        return new UnionDatasetGraph(left, right, c);
+    }
+
+    @Test
+    public void testUnion() {
+        final Graph g1 = parseGraph("(graph (triple <s1> <p1> <o1> ))");
+        final DatasetGraph dsg1 = DatasetGraphFactory.create(g1);
+        final Node graphName1 = NodeFactory.createBlankNode();
+        dsg1.addGraph(graphName1, g1);
+        final Graph g2 = parseGraph("(graph (triple <s2> <p2> <o2> ))");
+        final DatasetGraph dsg2 = DatasetGraphFactory.create(g2);
+        final Node graphName2 = NodeFactory.createBlankNode();
+        dsg2.addGraph(graphName2, g2);
+        DatasetGraph dsg = testInstance(dsg1, dsg2, Context.emptyContext);
+
+        assertEquals(2, dsg.size());
+        assertTrue(g1.isIsomorphicWith(dsg.getGraph(graphName1)));
+        assertTrue(g2.isIsomorphicWith(dsg.getGraph(graphName2)));
+        g1.find().mapWith(dsg.getDefaultGraph()::contains).forEachRemaining(Assert::assertTrue);
+        g2.find().mapWith(dsg.getDefaultGraph()::contains).forEachRemaining(Assert::assertTrue);
+    }
+}
diff --git a/jena-arq/src/test/java/org/apache/jena/sparql/util/compose/TS_DatasetCollectors.java b/jena-arq/src/test/java/org/apache/jena/sparql/util/compose/TS_DatasetCollectors.java
new file mode 100644
index 0000000000..208768635d
--- /dev/null
+++ b/jena-arq/src/test/java/org/apache/jena/sparql/util/compose/TS_DatasetCollectors.java
@@ -0,0 +1,28 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util.compose;
+
+import org.junit.runner.RunWith;
+import org.junit.runners.Suite;
+import org.junit.runners.Suite.SuiteClasses;
+
+@RunWith(Suite.class)
+@SuiteClasses({ TestIntersectionDatasetCollector.class, TestUnionDatasetCollector.class })
+public class TS_DatasetCollectors {
+}
diff --git a/jena-arq/src/test/java/org/apache/jena/sparql/util/compose/TestDatasetCollector.java b/jena-arq/src/test/java/org/apache/jena/sparql/util/compose/TestDatasetCollector.java
new file mode 100644
index 0000000000..c0e4578071
--- /dev/null
+++ b/jena-arq/src/test/java/org/apache/jena/sparql/util/compose/TestDatasetCollector.java
@@ -0,0 +1,79 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util.compose;
+
+import static org.apache.jena.rdf.model.ModelFactory.createModelForGraph;
+import static org.apache.jena.sparql.sse.SSE.parseGraph;
+
+import java.util.stream.Stream;
+
+import org.apache.jena.graph.*;
+import org.apache.jena.query.Dataset;
+import org.apache.jena.query.DatasetFactory;
+import org.apache.jena.rdf.model.Model;
+import org.apache.jena.sparql.util.compose.DatasetCollector;
+import org.junit.Assert;
+import org.junit.Test;
+
+public abstract class TestDatasetCollector extends Assert {
+
+    public abstract DatasetCollector testInstance();
+
+    @Test
+    public void collectionOfEmptyStreamShouldBeEmpty() {
+        final Dataset collected = Stream.<Dataset>empty().collect(testInstance());
+        assertTrue(collected.isEmpty());
+    }
+
+    @Test
+    public void collectionOfStreamOfEmptyDatasetsShouldBeEmpty() {
+        Stream<Dataset> stream = Stream.<Dataset>builder()
+                .add(DatasetFactory.create())
+                .add(DatasetFactory.create())
+                .add(DatasetFactory.create()).build();
+        final Dataset collected = stream.collect(testInstance());
+        assertTrue(collected.isEmpty());
+    }
+
+    @Test(expected=NullPointerException.class)
+    public void noNullDatasetsAllowed() {
+        Stream.<Dataset>builder().add(null).build().collect(testInstance());
+    }
+    
+    @Test
+    public void collectingOneDatasetGivesThatDataset() {
+        Graph graph = parseGraph("(graph (triple <s1> <p1> <o1> ))");
+        Model model = createModelForGraph(graph);
+        Dataset dataset = DatasetFactory.create(model);
+        Node graphName = NodeFactory.createBlankNode();
+        dataset.addNamedModel(graphName.toString(), model);
+        Dataset collection = Stream.<Dataset>builder().add(dataset).build().collect(testInstance());
+        assertDatasetsAreIsomorphicPerGraph(dataset, collection);
+    }
+
+    protected static void assertDatasetsAreIsomorphicPerGraph(Dataset dataset1, Dataset dataset2) {
+        assertGraphsAreIsomorphic(dataset1.getDefaultModel(), dataset2.getDefaultModel());
+        dataset1.listNames().forEachRemaining(graphName ->
+            assertGraphsAreIsomorphic(dataset1.getNamedModel(graphName), dataset2.getNamedModel(graphName)));
+    }
+    
+    protected static void assertGraphsAreIsomorphic(Model graph1, Model graph2) {
+        assertTrue(graph1.isIsomorphicWith(graph2));
+    }
+}
diff --git a/jena-arq/src/test/java/org/apache/jena/sparql/util/compose/TestIntersectionDatasetCollector.java b/jena-arq/src/test/java/org/apache/jena/sparql/util/compose/TestIntersectionDatasetCollector.java
new file mode 100644
index 0000000000..ffa48bd6c6
--- /dev/null
+++ b/jena-arq/src/test/java/org/apache/jena/sparql/util/compose/TestIntersectionDatasetCollector.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util.compose;
+
+import static org.apache.jena.graph.NodeFactory.createBlankNode;
+import static org.apache.jena.rdf.model.ModelFactory.createModelForGraph;
+import static org.apache.jena.sparql.sse.SSE.parseGraph;
+
+import java.util.stream.Stream;
+
+import org.apache.jena.query.Dataset;
+import org.apache.jena.query.DatasetFactory;
+import org.apache.jena.rdf.model.Model;
+import org.apache.jena.sparql.util.compose.DatasetCollector;
+import org.apache.jena.sparql.util.compose.DatasetLib;
+import org.junit.Test;
+
+public class TestIntersectionDatasetCollector extends TestDatasetCollector {
+
+    @Override
+    public DatasetCollector testInstance() {
+        return DatasetLib.collectors().intersect();
+    }
+
+    @Test
+    public void testIntersection() {
+        final Model m1 = createModelForGraph(parseGraph("(graph (triple <s1> <p1> <o1> ))"));
+        final Dataset ds1 = DatasetFactory.create(m1);
+        final String graphName1 = createBlankNode().toString();
+        ds1.addNamedModel(graphName1, m1);
+        final Model m2 = createModelForGraph(parseGraph("(graph (triple <s2> <p2> <o2> ))"));
+        final Dataset ds2 = DatasetFactory.create(m2);
+        final String graphName2 = createBlankNode().toString();
+        ds2.addNamedModel(graphName2, m2);
+        final Model m3 = createModelForGraph(parseGraph("(graph (triple <s3> <p3> <o3> ))"));
+        final String graphName3 = createBlankNode().toString();
+        ds1.addNamedModel(graphName3, m3);
+        ds2.addNamedModel(graphName3, m3);
+        
+        final Stream<Dataset> stream = Stream.<Dataset>builder().add(ds1).add(ds2).build();
+        Dataset ds = stream.collect(testInstance());
+        
+        assertTrue(ds.getDefaultModel().isEmpty());
+        assertTrue(ds.getNamedModel(graphName1).isEmpty());
+        assertTrue(ds.getNamedModel(graphName2).isEmpty());
+        assertTrue(m3.isIsomorphicWith(ds.getNamedModel(graphName3)));
+    }
+
+}
diff --git a/jena-arq/src/test/java/org/apache/jena/sparql/util/compose/TestUnionDatasetCollector.java b/jena-arq/src/test/java/org/apache/jena/sparql/util/compose/TestUnionDatasetCollector.java
new file mode 100644
index 0000000000..656b124635
--- /dev/null
+++ b/jena-arq/src/test/java/org/apache/jena/sparql/util/compose/TestUnionDatasetCollector.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.sparql.util.compose;
+
+import static org.apache.jena.rdf.model.ModelFactory.createModelForGraph;
+import static org.apache.jena.sparql.sse.SSE.parseGraph;
+
+import java.util.List;
+import java.util.stream.Stream;
+
+import org.apache.jena.atlas.iterator.Iter;
+import org.apache.jena.graph.Graph;
+import org.apache.jena.graph.NodeFactory;
+import org.apache.jena.query.Dataset;
+import org.apache.jena.query.DatasetFactory;
+import org.apache.jena.rdf.model.Model;
+import org.apache.jena.rdf.model.Statement;
+import org.apache.jena.sparql.util.compose.DatasetCollector;
+import org.apache.jena.sparql.util.compose.DatasetLib;
+import org.junit.Assert;
+import org.junit.Test;
+
+public class TestUnionDatasetCollector extends TestDatasetCollector {
+
+    @Override
+    public DatasetCollector testInstance() {
+        return DatasetLib.collectors().union();
+    }
+
+    @Test
+    public void testUnion() {
+        final Graph g1 = parseGraph("(graph (triple <s1> <p1> <o1> ))");
+        final Model m1 = createModelForGraph(g1);
+        final Dataset dsg1 = DatasetFactory.create(m1);
+        final String graphName1 = NodeFactory.createBlankNode().toString();
+        dsg1.addNamedModel(graphName1, m1);
+        final Graph g2 = parseGraph("(graph (triple <s2> <p2> <o2> ))");
+        final Dataset dsg2 = DatasetFactory.create(createModelForGraph(g2));
+        final Model m2 = createModelForGraph(g2);
+        final String graphName2 = NodeFactory.createBlankNode().toString();
+        dsg2.addNamedModel(graphName2, m2);
+        final Stream<Dataset> stream = Stream.<Dataset>builder().add(dsg1).add(dsg2).build();
+        Dataset dataset = stream.collect(testInstance());
+
+        assertEquals(2, Iter.count(dataset.listNames()));
+        assertTrue(m1.isIsomorphicWith(dataset.getNamedModel(graphName1)));
+        assertTrue(m2.isIsomorphicWith(dataset.getNamedModel(graphName2)));
+        // all statements in any input should be present in the union
+        m1.listStatements().mapWith(dataset.getDefaultModel()::contains).forEachRemaining(Assert::assertTrue);
+        m2.listStatements().mapWith(dataset.getDefaultModel()::contains).forEachRemaining(Assert::assertTrue);
+        // all statements in the union should be present in an input
+        List<Statement> leftovers = dataset.getDefaultModel().listStatements()
+                .filterDrop(m1::contains)
+                .filterDrop(m2::contains).toList();
+        assertTrue(leftovers.isEmpty());
+    }
+}
diff --git a/jena-base/src/main/java/org/apache/jena/atlas/iterator/Iter.java b/jena-base/src/main/java/org/apache/jena/atlas/iterator/Iter.java
index 2dbc734e6a..cb9871b033 100644
--- a/jena-base/src/main/java/org/apache/jena/atlas/iterator/Iter.java
+++ b/jena-base/src/main/java/org/apache/jena/atlas/iterator/Iter.java
@@ -614,11 +614,11 @@ public static <T> Iter<T> concat(Iter<T> iter1, Iter<T> iter2) {
     /** An {@code Iterator} of 2 {@code Iterator}'s.
      * See also {@link IteratorConcat}.
      */
-    public static <T> Iterator<T> concat(Iterator<T> iter1, Iterator<T> iter2) {
+    public static <T> Iter<T> concat(Iterator<T> iter1, Iterator<T> iter2) {
         if ( iter1 == null )
-            return iter2 ;
+            return iter(iter2) ;
         if ( iter2 == null )
-            return iter1 ;
+            return iter(iter1) ;
         return iter(iter1).append(iter(iter2)) ;
     }
 
diff --git a/jena-base/src/main/java/org/apache/jena/atlas/lib/IdentityFinishCollector.java b/jena-base/src/main/java/org/apache/jena/atlas/lib/IdentityFinishCollector.java
new file mode 100644
index 0000000000..790df23c06
--- /dev/null
+++ b/jena-base/src/main/java/org/apache/jena/atlas/lib/IdentityFinishCollector.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.atlas.lib;
+
+import static java.util.stream.Collector.Characteristics.CONCURRENT;
+import static java.util.stream.Collector.Characteristics.IDENTITY_FINISH;
+import static java.util.stream.Collector.Characteristics.UNORDERED;
+
+import java.util.Set;
+import java.util.function.Function;
+import java.util.stream.Collector;
+
+import org.apache.jena.ext.com.google.common.collect.ImmutableSet;
+
+public interface IdentityFinishCollector<T, A> extends Collector<T, A, A> {
+
+    @Override
+    default Function<A, A> finisher() {
+        return Function.identity();
+    }
+
+    @Override
+    default Set<Characteristics> characteristics() {
+        return ImmutableSet.of(IDENTITY_FINISH);
+    }
+
+    public interface UnorderedIdentityFinishCollector<T, A> extends IdentityFinishCollector<T, A> {
+
+        @Override
+        default Set<Characteristics> characteristics() {
+            return ImmutableSet.of(UNORDERED, IDENTITY_FINISH);
+        }
+    }
+
+    public interface ConcurrentUnorderedIdentityFinishCollector<T, A> extends UnorderedIdentityFinishCollector<T, A> {
+
+        @Override
+        default Set<Characteristics> characteristics() {
+            return ImmutableSet.of(CONCURRENT, UNORDERED, IDENTITY_FINISH);
+        }
+
+    }
+}
diff --git a/jena-base/src/main/java/org/apache/jena/atlas/lib/Pair.java b/jena-base/src/main/java/org/apache/jena/atlas/lib/Pair.java
index b472f3d249..4e248c8e66 100644
--- a/jena-base/src/main/java/org/apache/jena/atlas/lib/Pair.java
+++ b/jena-base/src/main/java/org/apache/jena/atlas/lib/Pair.java
@@ -60,5 +60,5 @@ public boolean equals(Object other)
     }
     
     @Override 
-    public String toString() { return "("+str(a)+", "+str(b)+")" ; }  
+    public String toString() { return "("+str(a)+", "+str(b)+")" ; }
 }
diff --git a/jena-base/src/main/java/org/apache/jena/atlas/lib/PairOfSameType.java b/jena-base/src/main/java/org/apache/jena/atlas/lib/PairOfSameType.java
new file mode 100644
index 0000000000..5386fe0195
--- /dev/null
+++ b/jena-base/src/main/java/org/apache/jena/atlas/lib/PairOfSameType.java
@@ -0,0 +1,45 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.atlas.lib;
+
+import java.util.function.*;
+
+public class PairOfSameType<T> extends Pair<T, T> {
+
+    public PairOfSameType(T a, T b) {
+        super(a, b);
+    }
+
+    public void forEach(Consumer<T> op) {
+        op.accept(a);
+        op.accept(b);
+    }
+
+    public boolean both(Function<T, Boolean> op) {
+        return apply(Boolean::logicalAnd, op);
+    }
+
+    public boolean either(Function<T, Boolean> op) {
+        return apply(Boolean::logicalOr, op);
+    }
+    
+    public <S, X> S apply(BiFunction<X, X, S> f, Function<T, X> op) {
+        return f.apply(op.apply(a), op.apply(b));
+    }
+}
\ No newline at end of file
diff --git a/jena-core/src/main/java/org/apache/jena/util/ModelCollector.java b/jena-core/src/main/java/org/apache/jena/util/ModelCollector.java
new file mode 100644
index 0000000000..24bc3095e3
--- /dev/null
+++ b/jena-core/src/main/java/org/apache/jena/util/ModelCollector.java
@@ -0,0 +1,85 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.util;
+
+import java.util.function.BiConsumer;
+import java.util.function.BinaryOperator;
+import java.util.function.Supplier;
+
+import org.apache.jena.atlas.lib.IdentityFinishCollector.UnorderedIdentityFinishCollector;
+import org.apache.jena.rdf.model.Model;
+import org.apache.jena.rdf.model.ModelFactory;
+
+public abstract class ModelCollector implements UnorderedIdentityFinishCollector<Model, Model> {
+
+    @Override
+    public Supplier<Model> supplier() {
+        return ModelFactory::createDefaultModel;
+    }
+    
+    public ConcurrentModelCollector concurrent() {
+        return new ConcurrentModelCollector(this);
+    }
+
+    public static class ConcurrentModelCollector extends ModelCollector
+            implements ConcurrentUnorderedIdentityFinishCollector<Model, Model> {
+
+        private final ModelCollector collector;
+
+        public ConcurrentModelCollector(ModelCollector col) {
+            this.collector = col;
+        }
+
+        @Override
+        public BiConsumer<Model, Model> accumulator() {
+            return (m1, m2) -> m2.executeInTxn(() -> m1.executeInTxn(() -> collector.accumulator().accept(m1, m2)));
+        }
+
+        @Override
+        public BinaryOperator<Model> combiner() {
+            return (m1, m2) -> m2.calculateInTxn(() -> m1.calculateInTxn(() -> collector.combiner().apply(m1, m2)));
+        }
+    }
+
+    public static class UnionModelCollector extends ModelCollector {
+
+        @Override
+        public BinaryOperator<Model> combiner() {
+            return ModelFactory::createUnion;
+        }
+
+        @Override
+        public BiConsumer<Model, Model> accumulator() {
+            return Model::add;
+        }
+    }
+
+    public static class IntersectionModelCollector extends ModelCollector {
+
+        @Override
+        public BinaryOperator<Model> combiner() {
+            return Model::intersection;
+        }
+
+        @Override
+        public BiConsumer<Model, Model> accumulator() {
+            return (m1, m2) -> m1.remove(m1.difference(m2));
+        }
+    }
+}
diff --git a/jena-core/src/test/java/org/apache/jena/util/TestModelCollector.java b/jena-core/src/test/java/org/apache/jena/util/TestModelCollector.java
new file mode 100644
index 0000000000..91d2a64ac5
--- /dev/null
+++ b/jena-core/src/test/java/org/apache/jena/util/TestModelCollector.java
@@ -0,0 +1,133 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.util;
+
+import static java.util.Collections.singleton;
+import static java.util.stream.Collector.Characteristics.*;
+import static java.util.stream.Collectors.groupingBy;
+import static java.util.stream.Stream.generate;
+import static java.util.stream.Stream.iterate;
+import static org.apache.jena.ext.com.google.common.collect.Lists.newArrayList;
+import static org.apache.jena.graph.NodeFactory.createLiteralByValue;
+import static org.apache.jena.rdf.model.ModelFactory.createDefaultModel;
+import static org.apache.jena.rdf.model.ModelFactory.createModelForGraph;
+
+import java.util.*;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Supplier;
+import java.util.stream.Collector.Characteristics;
+import java.util.stream.Stream;
+
+import org.apache.jena.atlas.junit.BaseTest;
+import org.apache.jena.datatypes.RDFDatatype;
+import org.apache.jena.datatypes.TypeMapper;
+import org.apache.jena.ext.com.google.common.collect.ImmutableSet;
+import org.apache.jena.graph.*;
+import org.apache.jena.graph.impl.CollectionGraph;
+import org.apache.jena.rdf.model.Model;
+import org.apache.jena.rdf.model.ModelFactory;
+import org.apache.jena.util.ModelCollector.*;
+import org.junit.Test;
+
+import junit.framework.JUnit4TestAdapter;
+
+public class TestModelCollector extends BaseTest {
+    
+    public static junit.framework.Test suite() {
+        return new JUnit4TestAdapter(TestModelCollector.class) ;
+    }
+
+    private static final Model EMPTY_MODEL = ModelFactory.createDefaultModel();
+    private static final Node PREDICATE = NodeFactory.createURI("p");
+    private static final Node SUBJECT = NodeFactory.createURI("s");
+    private static final RDFDatatype INTEGER_TYPE = TypeMapper.getInstance().getTypeByValue(555);
+
+    @Test
+    public void testCharacteristics() {
+        Set<Characteristics> characteristics = ImmutableSet.of(UNORDERED, IDENTITY_FINISH);
+        assertEquals(characteristics, new UnionModelCollector().characteristics());
+        assertEquals(characteristics, new IntersectionModelCollector().characteristics());
+        characteristics = ImmutableSet.of(CONCURRENT, UNORDERED, IDENTITY_FINISH);
+        assertEquals(characteristics, new ConcurrentModelCollector(null).characteristics());
+    }
+
+    Stream<Model> fromTriples(Supplier<Triple> kernel, byte size) {
+        AtomicInteger count = new AtomicInteger();
+        return generate(kernel).collect(groupingBy(x -> count.incrementAndGet() / size)).values().stream()
+                .map(CollectionGraph::new).map(ModelFactory::createModelForGraph);
+    }
+
+    private static void test(Stream<Model> data, Model expectedResults, ModelCollector testCollector) {
+        assertTrue(data.collect(testCollector).isIsomorphicWith(expectedResults));
+    }
+
+    @Test
+    public void unionOfEmptyStreamOfModelsIsEmpty() {
+        collectors().forEach(this::unionOfEmptyStreamOfModelsIsEmpty);
+    }
+
+    private void unionOfEmptyStreamOfModelsIsEmpty(ModelCollector testCollector) {
+        assertTrue(Stream.<Model>empty().collect(testCollector).isEmpty());
+    }
+
+    private static ArrayList<ModelCollector> collectors() {
+        return newArrayList(new UnionModelCollector(), new IntersectionModelCollector());
+    }
+
+    @Test
+    public void unionOfStreamOfEmptyModelsIsEmpty() {
+        collectors().forEach(this::unionOfStreamOfEmptyModelsIsEmpty);
+
+    }
+
+    private void unionOfStreamOfEmptyModelsIsEmpty(ModelCollector testCollector) {
+        Stream<Model> models = numbers().limit(10).map(x -> createDefaultModel());
+        test(models, EMPTY_MODEL, testCollector);
+    }
+
+    private Triple sampleFromNum(int i) {
+        return Triple.create(SUBJECT, PREDICATE, createLiteralByValue(i, INTEGER_TYPE));
+    }
+
+    @Test
+    public void allStatementsPresentInUnionOfDisjointModels() {
+        ModelCollector testCollector = new UnionModelCollector();
+        Model expectedResults = createDefaultModel();
+        Stream<Triple> addTestStatementsToRubric = numbers().limit(10).map(this::sampleFromNum)
+                .peek(t -> expectedResults.add(expectedResults.asStatement(t)));
+        Stream<Model> models = addTestStatementsToRubric.map(this::intoModel);
+        test(models, expectedResults, testCollector);
+    }
+
+    private static Stream<Integer> numbers() {
+        return generate(new AtomicInteger()::getAndIncrement);
+    }
+
+    @Test
+    public void noStatementsPresentInIntersectionOfDisjointModels() {
+        ModelCollector testCollector = new IntersectionModelCollector();
+        Stream<Model> models = iterate(0, i -> i + 1).limit(10).map(this::sampleFromNum).map(this::intoModel);
+        test(models, EMPTY_MODEL, testCollector);
+    }
+    
+    private Model intoModel(Triple t) {
+        return createModelForGraph(new CollectionGraph(singleton(t)));
+    }
+
+}
diff --git a/jena-core/src/test/java/org/apache/jena/util/TestPackage.java b/jena-core/src/test/java/org/apache/jena/util/TestPackage.java
index 22d5a58530..bca8337b07 100644
--- a/jena-core/src/test/java/org/apache/jena/util/TestPackage.java
+++ b/jena-core/src/test/java/org/apache/jena/util/TestPackage.java
@@ -45,6 +45,7 @@ private TestPackage() {
         addTest( TestIteratorCollection.suite() );
         addTest( "TestSplitIRI_XML",      TestSplitIRI_XML.suite()) ;
         addTest( "TestSplitIRI_TTL",      TestSplitIRI_TTL.suite()) ;
+        addTest( "TestModelCollector",    TestModelCollector.suite()) ;
         addTestSuite( TestLocators.class );
         addTestSuite( TestOneToManyMap.class );
     }
