diff --git a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/AbstractCredentialsAuthenticator.java b/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/AbstractCredentialsAuthenticator.java
deleted file mode 100644
index daa3fef94c..0000000000
--- a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/AbstractCredentialsAuthenticator.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jena.atlas.web.auth;
-
-import java.net.URI;
-
-import org.apache.http.HttpHost;
-import org.apache.http.auth.AuthScope;
-import org.apache.http.auth.Credentials;
-import org.apache.http.auth.UsernamePasswordCredentials;
-import org.apache.http.client.CredentialsProvider;
-import org.apache.http.impl.client.AbstractHttpClient;
-import org.apache.http.impl.client.BasicCredentialsProvider;
-import org.apache.http.protocol.HttpContext;
-
-/**
- * Abstract authenticator that uses user name and password credentials
- * 
- */
-public abstract class AbstractCredentialsAuthenticator implements HttpAuthenticator {
-
-    @Override
-    public void apply(AbstractHttpClient client, HttpContext context, URI target) {
-        // At least a user name is required or no authentication will be done
-        if (!this.hasUserName(target))
-            return;
-
-        // Be careful to scope credentials to the specific URI so that
-        // HttpClient won't try and send them to other servers
-        HttpHost host = new HttpHost(target.getHost(), target.getPort());
-        CredentialsProvider provider = new BasicCredentialsProvider();
-
-        provider.setCredentials(new AuthScope(host), this.createCredentials(target));
-
-        client.setCredentialsProvider(provider);
-    }
-
-    @Override
-    public void invalidate() {
-        // Does nothing by default
-    }
-
-    /**
-     * Creates the credentials used to authenticate
-     * <p>
-     * This default implementation simply returns a
-     * {@link UsernamePasswordCredentials} instance, derived implementations may
-     * need to override this
-     * </p>
-     * 
-     * @param target
-     *            Target URI
-     * @return Credentials
-     */
-    protected Credentials createCredentials(URI target) {
-        String user = this.getUserName(target);
-        char[] password = this.getPassword(target);
-        return password != null ? new UsernamePasswordCredentials(user, new String(password)) : new UsernamePasswordCredentials(
-                user, "");
-    }
-
-    /**
-     * Gets whether there is a user name available for the target URI
-     * 
-     * @param target
-     *            Target
-     * @return True if a user name is available, false otherwise
-     */
-    protected abstract boolean hasUserName(URI target);
-
-    /**
-     * Gets the user name for the target URI
-     * 
-     * @param target
-     *            Target
-     * @return User name or null if none available
-     */
-    protected abstract String getUserName(URI target);
-
-    /**
-     * Gets whether there is a password available for the target URI
-     * 
-     * @param target
-     *            Target
-     * @return True if a password is available, false otherwise
-     */
-    protected abstract boolean hasPassword(URI target);
-
-    /**
-     * Gets the password for the target URI
-     * 
-     * @param target
-     *            Target
-     * @return Password or null if none available
-     */
-    protected abstract char[] getPassword(URI target);
-
-}
\ No newline at end of file
diff --git a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/AbstractScopedAuthenticator.java b/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/AbstractScopedAuthenticator.java
deleted file mode 100644
index c3892f0207..0000000000
--- a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/AbstractScopedAuthenticator.java
+++ /dev/null
@@ -1,151 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.jena.atlas.web.auth;
-
-import java.net.URI;
-import java.net.URISyntaxException;
-
-/**
- * <p>
- * An abstract helper for authenticators which scope credentials to URIs
- * </p>
- * <h3>Credentials Scope</h3>
- * <p>
- * Note that credentials are not necessarily considered to be exclusively scoped
- * to the exact URI rather they are scoped to any URI derived from the given
- * URI. For example if you declared credentials for {@code http://example.org}
- * they would also apply to {@code http://example.org/some/path/}. When
- * determining credentials the longest match applies, so in the previous example
- * you could define different credentials for the two URIs and URIs derived from
- * {@code http://example.org/some/path/} would prefer the credentials for that
- * URI over those for {@code http://example.org}
- * </p>
- * <p>
- * Implementations that wish to follow the above scoping policy should make use
- * of the findCredentials method
- * </p>
- * 
- * @param <T>
- *            Type used to store credential information
- */
-public abstract class AbstractScopedAuthenticator<T> extends AbstractCredentialsAuthenticator {
-
-    @Override
-    protected final String getUserName(URI target) {
-        return getUserNameFromCredentials(this.findCredentials(target));
-    }
-
-    @Override
-    protected final char[] getPassword(URI target) {
-        return getPasswordFromCredentials(this.findCredentials(target));
-    }
-
-    @Override
-    protected final boolean hasUserName(URI target) {
-        return this.getUserName(target) != null;
-    }
-
-    @Override
-    protected final boolean hasPassword(URI target) {
-        return this.getPassword(target) != null;
-    }
-
-    /**
-     * Gets the credentials associated with the exact URI given
-     * <p>
-     * Called from {@link #findCredentials(URI)} as part of the credential
-     * lookup process
-     * </p>
-     * 
-     * @param target
-     *            Target URI
-     * @return Credentials
-     */
-    protected abstract T getCredentials(URI target);
-
-    /**
-     * Extract the user name from the given credentials
-     * 
-     * @param credentials
-     *            Credentials
-     * @return User Name
-     */
-    protected abstract String getUserNameFromCredentials(T credentials);
-
-    /**
-     * Extract the password from the given credentials
-     * 
-     * @param credentials
-     *            Credentials
-     * @return Password
-     */
-    protected abstract char[] getPasswordFromCredentials(T credentials);
-
-    /**
-     * Finds credentials for the given URI using a longest match approach
-     * 
-     * @param target
-     * @return T
-     */
-    protected final T findCredentials(URI target) {
-        // Try URI as-is to start with
-        T creds = this.getCredentials(target);
-
-        try {
-            // If that fails strip down the URI recursively
-            while (creds == null) {
-                if (target.getFragment() != null) {
-                    // If it has a fragment strip that off
-                    target = new URI(target.getScheme(), target.getUserInfo(), target.getHost(), target.getPort(),
-                            target.getPath(), target.getQuery(), null);
-                } else if (target.getQuery() != null) {
-                    // If it has a query string strip that off
-                    target = new URI(target.getScheme(), target.getUserInfo(), target.getHost(), target.getPort(),
-                            target.getPath(), null, null);
-                } else if (target.getPath() != null) {
-                    // Try and strip off last segment of the path
-                    String currPath = target.getPath();
-                    if (currPath.endsWith("/")) {
-                        currPath = currPath.substring(0, currPath.length() - 1);
-                        if (currPath.length() == 0)
-                            currPath = null;
-                        target = new URI(target.getScheme(), target.getUserInfo(), target.getHost(), target.getPort(), currPath,
-                                null, null);
-                    } else if (currPath.contains("/")) {
-                        currPath = currPath.substring(0, currPath.lastIndexOf('/') + 1);
-                        if (currPath.length() == 0)
-                            currPath = null;
-                        target = new URI(target.getScheme(), target.getUserInfo(), target.getHost(), target.getPort(), currPath,
-                                null, null);
-                    } else {
-                        // If path is non-null it must always contain a /
-                        // otherwise it would be an invalid path
-                        // In this case bail out
-                        return null;
-                    }
-                }
-
-                creds = this.getCredentials(target);
-            }
-            return creds;
-        } catch (URISyntaxException e) {
-            // If we generate a malformed URL then bail out
-            return null;
-        }
-    }
-}
\ No newline at end of file
diff --git a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/ApacheModAuthFormLogin.java b/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/ApacheModAuthFormLogin.java
deleted file mode 100644
index bd9f421241..0000000000
--- a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/ApacheModAuthFormLogin.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.jena.atlas.web.auth;
-
-/**
- * Represents form login credentials where form logins are against Apache
- * mod_auth_form secured servers using default form field configuration
- * 
- */
-public class ApacheModAuthFormLogin extends FormLogin {
-
-    /**
-     * Default user field used by Apache mod_auth_form configurations
-     */
-    public static final String USER_FIELD = "httpd_username";
-    /**
-     * Default password field used by Apache mod_auth_form configurations
-     */
-    public static final String PASSWORD_FIELD = "httpd_password";
-
-    /**
-     * Creates new form login credentials
-     * 
-     * @param loginFormURL
-     *            Login Form URL
-     * @param username
-     *            User name
-     * @param password
-     *            Password
-     */
-    public ApacheModAuthFormLogin(String loginFormURL, String username, char[] password) {
-        super(loginFormURL, USER_FIELD, PASSWORD_FIELD, username, password);
-    }
-}
diff --git a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/DelegatingAuthenticator.java b/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/DelegatingAuthenticator.java
deleted file mode 100644
index 9373c6ece0..0000000000
--- a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/DelegatingAuthenticator.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jena.atlas.web.auth;
-
-import java.net.URI;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.http.impl.client.AbstractHttpClient;
-import org.apache.http.protocol.HttpContext;
-
-/**
- * A scoped authenticator which is actually a wrapper around other
- * authenticators and thus can be used to mix and match different authentication
- * mechanisms to different services as desired
- * 
- */
-public class DelegatingAuthenticator extends AbstractScopedAuthenticator<HttpAuthenticator> {
-
-    private Map<URI, HttpAuthenticator> authenticators = new HashMap<>();
-
-    /**
-     * Creates a new delegating authenticator
-     * 
-     * @param target
-     *            Target URI
-     * @param authenticator
-     *            Authenticator to delegate to
-     */
-    public DelegatingAuthenticator(URI target, HttpAuthenticator authenticator) {
-        if (target == null)
-            throw new IllegalArgumentException("Target URI cannot be null");
-        this.authenticators.put(target, authenticator);
-    }
-
-    /**
-     * Creates a new delegating authenticator
-     * 
-     * @param authenticators
-     *            Mapping between URIs and authenticators
-     */
-    public DelegatingAuthenticator(Map<URI, HttpAuthenticator> authenticators) {
-        this.authenticators.putAll(authenticators);
-    }
-
-    @Override
-    public void apply(AbstractHttpClient client, HttpContext context, URI target) {
-        HttpAuthenticator authenticator = this.findCredentials(target);
-        if (authenticator != null) {
-            authenticator.apply(client, context, target);
-        }
-    }
-
-    @Override
-    protected HttpAuthenticator getCredentials(URI target) {
-        return this.authenticators.get(target);
-    }
-
-    @Override
-    protected String getUserNameFromCredentials(HttpAuthenticator credentials) {
-        // Not used by this implementation because we override apply() so this
-        // will never be needed and regardless isn't available
-        return null;
-    }
-
-    @Override
-    protected char[] getPasswordFromCredentials(HttpAuthenticator credentials) {
-        // Not used by this implementation because we override apply() so this
-        // will never be needed and regardless isn't available
-        return null;
-    }
-
-}
diff --git a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/FormLogin.java b/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/FormLogin.java
deleted file mode 100644
index db08864ca7..0000000000
--- a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/FormLogin.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.jena.atlas.web.auth;
-
-import java.io.UnsupportedEncodingException;
-import java.util.ArrayList;
-import java.util.List;
-
-import org.apache.http.HttpEntity;
-import org.apache.http.NameValuePair;
-import org.apache.http.client.CookieStore;
-import org.apache.http.client.entity.UrlEncodedFormEntity;
-import org.apache.http.message.BasicNameValuePair;
-
-/**
- * Represents form login credentials
- * 
- */
-public class FormLogin {
-
-    private String loginForm, loginUserField, loginPasswordField, username;
-    private char[] password;
-    private CookieStore cookies;
-
-    /**
-     * Creates new form login credentials
-     * 
-     * @param loginFormURL
-     *            Login Form URL
-     * @param loginUserField
-     *            Login Form User field name
-     * @param loginPasswordField
-     *            Login Form Password field name
-     * @param username
-     *            User name
-     * @param password
-     *            Password
-     */
-    public FormLogin(String loginFormURL, String loginUserField, String loginPasswordField, String username, char[] password) {
-        this.loginForm = loginFormURL;
-        this.loginUserField = loginUserField;
-        this.loginPasswordField = loginPasswordField;
-        this.username = username;
-        this.password = password;
-    }
-
-    /**
-     * Gets the login form URL
-     * 
-     * @return Login Form URL
-     */
-    public String getLoginFormURL() {
-        return this.loginForm;
-    }
-
-    /**
-     * Gets the HTTP Entity for the Login request
-     * 
-     * @return Login request entity
-     * @throws UnsupportedEncodingException
-     *             Thrown if the platform does not support UTF-8
-     */
-    public HttpEntity getLoginEntity() throws UnsupportedEncodingException {
-        List<NameValuePair> nvps = new ArrayList<>();
-        nvps.add(new BasicNameValuePair(this.loginUserField, this.username));
-        nvps.add(new BasicNameValuePair(this.loginPasswordField, new String(this.password)));
-
-        return new UrlEncodedFormEntity(nvps, "UTF-8");
-    }
-
-    /**
-     * Gets whether any cookies are associated with this login
-     * 
-     * @return True if there are cookies, false otherwise
-     */
-    public boolean hasCookies() {
-        return this.cookies != null;
-    }
-
-    /**
-     * Gets cookies associated with this login
-     * 
-     * @return Cookies
-     */
-    public CookieStore getCookies() {
-        return this.cookies;
-    }
-
-    /**
-     * Sets cookies associated with this login
-     * 
-     * @param cookies
-     */
-    public void setCookies(CookieStore cookies) {
-        this.cookies = cookies;
-    }
-
-    /**
-     * Clears cookies associated with login, may be useful if you need to force
-     * a fresh login attempt for any reason.
-     */
-    public void clearCookies() {
-        this.cookies = null;
-    }
-}
diff --git a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/FormsAuthenticator.java b/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/FormsAuthenticator.java
deleted file mode 100644
index 17a93aeedb..0000000000
--- a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/FormsAuthenticator.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jena.atlas.web.auth;
-
-import java.io.IOException;
-import java.io.UnsupportedEncodingException;
-import java.net.URI;
-import java.util.Calendar;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.http.HttpResponse;
-import org.apache.http.client.CookieStore;
-import org.apache.http.client.methods.HttpPost;
-import org.apache.http.impl.client.AbstractHttpClient;
-import org.apache.http.impl.client.BasicCookieStore;
-import org.apache.http.protocol.HttpContext;
-import org.apache.jena.atlas.web.HttpException;
-import org.apache.jena.riot.web.HttpOp;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-/**
- * <p>
- * An authenticator capable of making Form based logins and using cookies to
- * maintain authentication state. Different logins may be used for different
- * services as required.
- * </p>
- * <h3>Login Scope</h3>
- * <p>
- * Note that logins are not exclusively scoped to the exact URI rather they are
- * scoped to any URI derived from the given URI. For example if you declared
- * logins for {@code http://example.org} they would also apply to
- * {@code http://example.org/some/path/}. When determining credentials the
- * longest match applies, so in the previous example you could define different
- * logins for the two URIs and URIs derived from
- * {@code http://example.org/some/path/} would prefer the login for that URI
- * over those for {@code http://example.org}
- * </p>
- * 
- */
-public class FormsAuthenticator extends AbstractScopedAuthenticator<FormLogin> {
-
-    private static final Logger LOG = LoggerFactory.getLogger(FormsAuthenticator.class);
-
-    private Map<URI, FormLogin> logins = new HashMap<>();
-
-    /**
-     * Creates a new authenticator with the given login
-     * 
-     * @param target
-     *            Target URI
-     * @param login
-     *            Login
-     */
-    public FormsAuthenticator(URI target, FormLogin login) {
-        if (target == null)
-            throw new IllegalArgumentException("Target URI cannot be null");
-        this.logins.put(target, login);
-    }
-
-    /**
-     * Creates a new authenticator with the given logins
-     * 
-     * @param logins
-     *            Logins
-     */
-    public FormsAuthenticator(Map<URI, FormLogin> logins) {
-        this.logins.putAll(logins);
-    }
-
-    @Override
-    public void apply(AbstractHttpClient client, HttpContext httpContext, URI target) {
-        if (client == null)
-            return;
-
-        // Do we have a login available for the target server?
-        FormLogin login = this.findCredentials(target);
-        if (login == null)
-            return;
-
-        // We need to synchronize on the login because making a login attempt
-        // may take a while and there is no point making multiple login attempts
-        // against the same server
-        synchronized (login) {
-
-            // Have we already logged into this server?
-            if (login.hasCookies()) {
-                // Use existing cookies
-                LOG.info("Using existing cookies to authenticate access to " + target.toString());
-                CookieStore store = login.getCookies();
-                if (store != null)
-                    client.setCookieStore(store);
-
-                // Check if any of the cookies have expired
-                if (!store.clearExpired(Calendar.getInstance().getTime())) {
-                    // No cookies were cleared so our cookies are still fresh
-                    // and we don't need to login again
-                    return;
-                }
-
-                // If we reach here then some of our cookies have expired and we
-                // may no longer be logged in and should login again instead of
-                // proceeding with the existing cookies
-            }
-
-            try {
-                // Use a fresh Cookie Store for new login attempts
-                CookieStore store = new BasicCookieStore();
-                client.setCookieStore(store);
-
-                // Try to login
-                LOG.info("Making login attempt against " + login.getLoginFormURL() + " to obtain authentication for access to "
-                        + target.toString());
-                HttpPost post = new HttpPost(login.getLoginFormURL());
-                post.setEntity(login.getLoginEntity());
-                HttpResponse response = client.execute(post, httpContext);
-
-				// Always read the payload to ensure reusable connections
-				final String payload = HttpOp.readPayload(response.getEntity());
-
-				// Check for successful login
-                if (response.getStatusLine().getStatusCode() >= 400) {
-                    LOG.warn("Failed to login against " + login.getLoginFormURL() + " to obtain authentication for access to "
-                            + target.toString());
-                    throw new HttpException(response.getStatusLine().getStatusCode(), "Login attempt failed - "
-                            + response.getStatusLine().getReasonPhrase(), payload);
-                }
-
-                // Otherwise assume a successful login
-                LOG.info("Successfully logged in against " + login.getLoginFormURL()
-                        + " and obtained authentication for access to " + target.toString());
-                login.setCookies(client.getCookieStore());
-
-            } catch (UnsupportedEncodingException e) {
-                throw new HttpException("UTF-8 encoding not supported on your platform", e);
-            } catch (IOException e) {
-                throw new HttpException("Error making login request", e);
-            }
-        }
-    }
-    
-    @Override
-    public void invalidate() {
-        // Discard all cookies we have currently
-        for (FormLogin login : this.logins.values()) {
-            login.clearCookies();
-        }
-    }
-
-    /**
-     * Adds a login to the authenticator preserving any existing cookies
-     * associated with the login
-     * 
-     * @param target
-     *            Target URI
-     * @param login
-     *            Login
-     */
-    public void addLogin(URI target, FormLogin login) {
-        if (target == null)
-            throw new IllegalArgumentException("Target URI cannot be null");
-        this.logins.put(target, login);
-
-    }
-
-    @Override
-    protected FormLogin getCredentials(URI target) {
-        return this.logins.get(target);
-    }
-
-    @Override
-    protected String getUserNameFromCredentials(FormLogin credentials) {
-        // Not used by this implementation because we override apply() so this
-        // will never be needed and regardless isn't available
-        return null;
-    }
-
-    @Override
-    protected char[] getPasswordFromCredentials(FormLogin credentials) {
-        // Not used by this implementation because we override apply() so this
-        // will never be needed and regardless isn't available
-        return null;
-    }
-
-}
diff --git a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/HttpAuthenticator.java b/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/HttpAuthenticator.java
deleted file mode 100644
index d287492a19..0000000000
--- a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/HttpAuthenticator.java
+++ /dev/null
@@ -1,69 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jena.atlas.web.auth;
-
-import java.net.URI;
-
-import org.apache.http.client.HttpClient;
-import org.apache.http.impl.client.AbstractHttpClient;
-import org.apache.http.protocol.HttpContext;
-
-/**
- * Interface for classes that are able to apply some form of authentication to a
- * {@link HttpClient} instance. Provides a unified mechanism for applying
- * authentication that is agnostic of the actual authentication mechanism being
- * used.
- * 
- */
-public interface HttpAuthenticator {
-
-    /**
-     * Applies any necessary authentication methods to the given HTTP Client
-     * <p>
-     * The {@code target} parameter indicates the URI to which the request is
-     * being made and so may be used by an authenticator to determine whether it
-     * actually needs to apply any authentication or to scope authentication
-     * appropriately.
-     * </p>
-     * 
-     * @param client
-     *            HTTP Client
-     * @param httpContext
-     *            HTTP Context
-     * @param target
-     *            Target URI to which code wants to authenticate
-     */
-    public void apply(AbstractHttpClient client, HttpContext httpContext, URI target);
-
-    /**
-     * Invalidates the authenticator
-     * <p>
-     * Allows code to inform the authenticator that any cached authentication
-     * information should be invalidated. This can be useful after an
-     * authentication attempt fails or after a certain amount of time is passed.
-     * For many authenticators this may actually be a no-op since when using
-     * standard HTTP authentication typically you authenticate on every request
-     * and there are no cached authentication information. However more complex
-     * authentication mechanisms such as Form Based authentication may have
-     * cached information that discarding will force subsequent requests to
-     * re-authenticate.
-     * </p>
-     */
-    public void invalidate();
-}
diff --git a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/PreemptiveBasicAuthenticator.java b/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/PreemptiveBasicAuthenticator.java
deleted file mode 100644
index fb029b9275..0000000000
--- a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/PreemptiveBasicAuthenticator.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.jena.atlas.web.auth;
-
-import java.net.URI;
-
-import org.apache.http.HttpHost;
-import org.apache.http.auth.ChallengeState;
-import org.apache.http.client.AuthCache;
-import org.apache.http.client.protocol.ClientContext;
-import org.apache.http.impl.auth.BasicScheme;
-import org.apache.http.impl.client.AbstractHttpClient;
-import org.apache.http.impl.client.BasicAuthCache;
-import org.apache.http.protocol.HttpContext;
-
-/**
- * A decorator for other authenticators that may be used to enable preemptive
- * basic authentication.
- * <p>
- * This can <strong>only</strong> be used with servers that support Basic HTTP
- * authentication.  For any other authentication scheme the use of this
- * authenticator will result in authentication failures.
- * </p>
- * <h3>Security Concerns</h3>
- * <p>
- * It is <strong>important</strong> to note that preemptive basic authentication
- * is less secure because it can expose credentials to servers that do not
- * require them.
- * </p>
- * <h3>Standard vs Proxy Authentication</h3>
- * <p>
- * Doing preemptive authentication requires knowing in advance whether you will
- * be doing standard or proxy authentication i.e. whether the remote server will
- * challenge with 401 or 407. If you need both you can take advantage of this
- * being a decorator and simply layer multiple instances of this.
- * </p>
- * <p>
- * However you must remember that this <strong>only</strong> works for Basic
- * HTTP authentication, any other authentication scheme cannot be done
- * preemptively because it requires a more complex and secure challenge response
- * process.
- * </p>
- */
-public class PreemptiveBasicAuthenticator implements HttpAuthenticator {
-
-    private HttpAuthenticator authenticator;
-    private boolean isProxy = false;
-
-    /**
-     * Creates a new decorator over the given authenticator
-     * 
-     * @param authenticator
-     *            Authenticator to decorate
-     */
-    public PreemptiveBasicAuthenticator(HttpAuthenticator authenticator) {
-        this(authenticator, false);
-    }
-
-    /**
-     * Creates a new decorator over the given authenticator
-     * 
-     * @param authenticator
-     *            Authenticator to decorate
-     * @param forProxy
-     *            Whether preemptive authentication is for a proxy
-     */
-    public PreemptiveBasicAuthenticator(HttpAuthenticator authenticator, boolean forProxy) {
-        if (authenticator == null)
-            throw new IllegalArgumentException("Must provide an authenticator to decorate");
-        this.authenticator = authenticator;
-    }
-
-    @Override
-    public void apply(AbstractHttpClient client, HttpContext httpContext, URI target) {
-        this.authenticator.apply(client, httpContext, target);
-
-        // Enable preemptive basic authentication
-        // For nice layering we need to respect existing auth cache if present
-        AuthCache authCache = (AuthCache) httpContext.getAttribute(ClientContext.AUTH_CACHE);
-        if (authCache == null)
-            authCache = new BasicAuthCache();
-        BasicScheme basicAuth = new BasicScheme(this.isProxy ? ChallengeState.PROXY : ChallengeState.TARGET);
-        // TODO It is possible that this overwrites existing cached credentials
-        // so potentially not ideal.
-        authCache.put(new HttpHost(target.getHost(), target.getPort()), basicAuth);
-        httpContext.setAttribute(ClientContext.AUTH_CACHE, authCache);
-    }
-
-    @Override
-    public void invalidate() {
-        // Does nothing
-    }
-
-}
diff --git a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/ScopedAuthenticator.java b/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/ScopedAuthenticator.java
deleted file mode 100644
index 31f38293f0..0000000000
--- a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/ScopedAuthenticator.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jena.atlas.web.auth;
-
-import java.net.URI;
-import java.util.HashMap;
-import java.util.Map;
-
-import org.apache.jena.atlas.lib.Pair;
-
-/**
- * <p>
- * A credentials based authenticator where credentials are scoped to URIs. This
- * allows for a single authenticator to present different credentials to
- * different URIs as appropriate. Works with the basic and digest HTTP
- * authentication schemes.
- * </p>
- * <p>
- * See {@link ScopedNTAuthenticator} for an implementation that works for the
- * NTLM authentication scheme.
- * </p>
- * 
- */
-public class ScopedAuthenticator extends AbstractScopedAuthenticator<Pair<String, char[]>> {
-
-    private Map<URI, Pair<String, char[]>> credentials = new HashMap<>();
-
-    /**
-     * Creates an authenticator with credentials for the given URI
-     * 
-     * @param target
-     *            URI
-     * @param username
-     *            User name
-     * @param password
-     *            Password
-     */
-    public ScopedAuthenticator(URI target, String username, char[] password) {
-        if (target == null)
-            throw new IllegalArgumentException("Target URI cannot be null");
-        this.credentials.put(target, Pair.create(username, password));
-    }
-
-    /**
-     * Creates an authenticator with a set of credentials for URIs
-     * 
-     * @param credentials
-     *            Credentials
-     */
-    public ScopedAuthenticator(Map<URI, Pair<String, char[]>> credentials) {
-        this.credentials.putAll(credentials);
-    }
-
-    /**
-     * Adds/Overwrites credentials for a given URI
-     * 
-     * @param target
-     *            Target
-     * @param username
-     *            User name
-     * @param password
-     *            Password
-     */
-    public void addCredentials(URI target, String username, char[] password) {
-        if (target == null)
-            throw new IllegalArgumentException("Target URI cannot be null");
-        this.credentials.put(target, Pair.create(username, password));
-    }
-
-    @Override
-    protected Pair<String, char[]> getCredentials(URI target) {
-        return this.credentials.get(target);
-    }
-
-    @Override
-    protected String getUserNameFromCredentials(Pair<String, char[]> credentials) {
-        return credentials != null ? credentials.getLeft() : null;
-    }
-
-    @Override
-    protected char[] getPasswordFromCredentials(Pair<String, char[]> credentials) {
-        return credentials != null ? credentials.getRight() : null;
-    }
-
-}
diff --git a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/ScopedNTAuthenticator.java b/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/ScopedNTAuthenticator.java
deleted file mode 100644
index f3898550c0..0000000000
--- a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/ScopedNTAuthenticator.java
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jena.atlas.web.auth;
-
-import java.net.URI;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Map.Entry;
-
-import org.apache.http.auth.Credentials;
-import org.apache.http.auth.NTCredentials;
-import org.apache.jena.atlas.lib.Pair;
-import org.apache.jena.atlas.lib.tuple.Tuple ;
-import org.apache.jena.atlas.lib.tuple.TupleFactory ;
-
-/**
- * <p>
- * A credentials based authenticator where credentials are scoped to URIs. This
- * allows for a single authenticator to present different credentials to
- * different URIs as appropriate. Works with the NTLM authentication schemes.
- * </p>
- * <p>
- * See {@link ScopedAuthenticator} for an implementation that works for the
- * Basic and Digest authentication schemes.
- * </p>
- * 
- */
-public class ScopedNTAuthenticator extends AbstractScopedAuthenticator<Pair<Tuple<String>, char[]>> {
-
-    private Map<URI, Pair<Tuple<String>, char[]>> credentials = new HashMap<>();
-
-    /**
-     * Creates an authenticator with credentials for the given URI
-     * 
-     * @param target
-     *            URI
-     * @param username
-     *            User name
-     * @param password
-     *            Password
-     * @param workstation
-     *            Workstation, this is the ID of your local workstation
-     * @param domain
-     *            Domain, this is the domain you are authenticating in which may
-     *            not necessarily be the domain your workstation is in
-     */
-    public ScopedNTAuthenticator(URI target, String username, char[] password, String workstation, String domain) {
-        if (target == null)
-            throw new IllegalArgumentException("Target URI cannot be null");
-        this.credentials.put(target, Pair.create(TupleFactory.tuple(username, workstation, domain), password));
-    }
-
-    /**
-     * Creates an authenticator with a set of credentials for URIs
-     * 
-     * @param credentials
-     *            Credentials, the left of the pair should be a tuple with at
-     *            least three fields where the first contains the user name, the
-     *            second the workstation and the third the domain. The right of
-     *            the pair should be the password.
-     */
-    public ScopedNTAuthenticator(Map<URI, Pair<Tuple<String>, char[]>> credentials) {
-        for (Entry<URI, Pair<Tuple<String>, char[]>> entry : credentials.entrySet()) {
-            if (entry.getValue() == null)
-                continue;
-            if (entry.getValue().getLeft() == null)
-                throw new IllegalArgumentException("Credentials tuple should be non-null");
-            if (entry.getValue().getLeft().len() < 3)
-                throw new IllegalArgumentException(
-                        "Credentials tuple should contain at least three fields, 0 = user name, 1 = workstation, 2 = domain");
-            this.credentials.put(entry.getKey(), entry.getValue());
-        }
-    }
-
-    /**
-     * Adds/Overwrites credentials for a given URI
-     * 
-     * @param target
-     *            Target
-     * @param username
-     *            User name
-     * @param password
-     *            Password
-     * @param workstation
-     *            Workstation, this is the ID of your local workstation
-     * @param domain
-     *            Domain, this is the domain you are authenticating in which may
-     *            not necessarily be the domain your workstation is in
-     */
-    public void addCredentials(URI target, String username, char[] password, String workstation, String domain) {
-        if (target == null)
-            throw new IllegalArgumentException("Target URI cannot be null");
-        this.credentials.put(target, Pair.create(TupleFactory.tuple(username, workstation, domain), password));
-    }
-
-    @Override
-    protected Credentials createCredentials(URI target) {
-        Pair<Tuple<String>, char[]> credentials = this.getCredentials(target);
-        if (credentials == null)
-            return super.createCredentials(target);
-
-        return new NTCredentials(credentials.getLeft().get(0), new String(credentials.getRight()), credentials.getLeft().get(1),
-                credentials.getLeft().get(2));
-    }
-
-    @Override
-    protected Pair<Tuple<String>, char[]> getCredentials(URI target) {
-        return this.credentials.get(target);
-    }
-
-    @Override
-    protected String getUserNameFromCredentials(Pair<Tuple<String>, char[]> credentials) {
-        return credentials != null ? credentials.getLeft().get(0) : null;
-    }
-
-    @Override
-    protected char[] getPasswordFromCredentials(Pair<Tuple<String>, char[]> credentials) {
-        return credentials != null ? credentials.getRight() : null;
-    }
-
-}
diff --git a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/ServiceAuthenticator.java b/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/ServiceAuthenticator.java
deleted file mode 100644
index 17ba04d615..0000000000
--- a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/ServiceAuthenticator.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jena.atlas.web.auth;
-
-import java.net.URI;
-import java.util.Map;
-
-import org.apache.jena.query.ARQ ;
-import org.apache.jena.sparql.engine.http.Service ;
-import org.apache.jena.sparql.util.Context ;
-
-/**
- * <p>
- * A HTTP authenticator which selects credentials based upon service context
- * found in the provided {@link Context}. May also optionally use fallback
- * credentials for URIs for which authentication has not been explicitly
- * configured. This works only with the Basic and Digest authentication schemes
- * so you may need to use an alternative authenticator if you need to use
- * another authentication scheme.
- * </p>
- */
-public class ServiceAuthenticator extends AbstractScopedAuthenticator<Context> {
-
-    private Context context;
-    private String username;
-    private char[] password;
-
-    /**
-     * Creates new authenticator using the standard ARQ context
-     */
-    public ServiceAuthenticator() {
-        this(ARQ.getContext(), null, null);
-    }
-
-    /**
-     * Creates a new authenticator using the standard ARQ context, the provided
-     * credentials are used as fallback if the context contains no registered
-     * credentials for a target URI
-     * 
-     * @param username
-     *            Fallback user name
-     * @param password
-     *            Fallback password
-     */
-    public ServiceAuthenticator(String username, char[] password) {
-        this(ARQ.getContext(), username, password);
-    }
-
-    /**
-     * Creates a new authenticator using the given context
-     * 
-     * @param context
-     *            Context
-     */
-    public ServiceAuthenticator(Context context) {
-        this(context, null, null);
-    }
-
-    /**
-     * Creates a new authenticator using the given context, the provided
-     * credentials are used as fallback if the context contains no registered
-     * credentials for a target URI
-     * 
-     * @param context
-     *            Context
-     * @param username
-     *            Fallback user name
-     * @param password
-     *            Fallback password
-     */
-    public ServiceAuthenticator(Context context, String username, char[] password) {
-        this.context = context;
-        this.username = username;
-        this.password = password;
-    }
-
-    @SuppressWarnings("unchecked")
-    private Map<String, Context> getServiceContextMap() {
-        return (Map<String, Context>) this.context.get(Service.serviceContext);
-
-    }
-
-    @Override
-    protected Context getCredentials(URI target) {
-        Map<String, Context> serviceContextMap = this.getServiceContextMap();
-        if (serviceContextMap == null)
-            return null;
-        return serviceContextMap.get(target.toString());
-    }
-
-    @Override
-    protected String getUserNameFromCredentials(Context credentials) {
-        if (credentials != null) {
-            // Use user name from service context
-            return credentials.getAsString(Service.queryAuthUser);
-        } else {
-            // Use fallback user name
-            return this.username;
-        }
-    }
-
-    @Override
-    protected char[] getPasswordFromCredentials(Context credentials) {
-        if (credentials != null) {
-            // Use password from service context
-            String pwd = credentials.getAsString(Service.queryAuthPwd);
-            return pwd != null ? pwd.toCharArray() : null;
-        } else {
-            // Use fallback password
-            return this.password;
-        }
-    }
-}
diff --git a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/SimpleAuthenticator.java b/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/SimpleAuthenticator.java
deleted file mode 100644
index 2e2980eec4..0000000000
--- a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/SimpleAuthenticator.java
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jena.atlas.web.auth;
-
-import java.net.URI;
-
-/**
- * <p>
- * A HTTP Authenticator which provides authentication via user name and password
- * combinations. Works with the basic and digest HTTP authentication schemes.
- * </p>
- * <p>
- * See {@link SimpleNTAuthenticator} for an implementation that works for the
- * NTLM authentication scheme.
- * </p>
- * <p>
- * This authenticator will present the given credentials to any server that
- * request authentication even though the credentials may not be valid there. It
- * is typically more secure to use the {@link ScopedAuthenticator} instead which
- * only presents credentials to specific servers.
- * </p>
- * 
- */
-public class SimpleAuthenticator extends AbstractCredentialsAuthenticator {
-
-    String username;
-    char[] password;
-
-    /**
-     * Creates a new authenticator
-     * 
-     * @param username
-     *            Username
-     * @param password
-     *            Password
-     */
-    public SimpleAuthenticator(String username, char[] password) {
-        this.username = username;
-        this.password = password;
-    }
-
-    @Override
-    protected boolean hasUserName(URI target) {
-        return this.username != null;
-    }
-
-    @Override
-    protected String getUserName(URI target) {
-        return this.username;
-    }
-
-    @Override
-    protected boolean hasPassword(URI target) {
-        return this.password != null;
-    }
-
-    @Override
-    protected char[] getPassword(URI target) {
-        return this.password;
-    }
-
-}
diff --git a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/SimpleNTAuthenticator.java b/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/SimpleNTAuthenticator.java
deleted file mode 100644
index b7bd4c1da0..0000000000
--- a/jena-arq/src/main/java/org/apache/jena/atlas/web/auth/SimpleNTAuthenticator.java
+++ /dev/null
@@ -1,71 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one
- * or more contributor license agreements.  See the NOTICE file
- * distributed with this work for additional information
- * regarding copyright ownership.  The ASF licenses this file
- * to you under the Apache License, Version 2.0 (the
- * "License"); you may not use this file except in compliance
- * with the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.apache.jena.atlas.web.auth;
-
-import java.net.URI;
-
-import org.apache.http.auth.Credentials;
-import org.apache.http.auth.NTCredentials;
-
-/**
- * <p>
- * A HTTP Authenticator which provides authentication via user name and password
- * combinations. Works with the NTLM authentication scheme.
- * </p>
- * <p>
- * Use the parent class {@link SimpleAuthenticator} if you just need to do
- * Basic/Digest authentication.
- * </p>
- * <p>
- * This authenticator will present the given credentials to any server that
- * request authentication even though the credentials may not be valid there. It
- * is typically more secure to use the {@link ScopedNTAuthenticator} instead
- * which only presents credentials to specific servers.
- * </p>
- * 
- */
-public class SimpleNTAuthenticator extends SimpleAuthenticator {
-
-    private String workstation, domain;
-
-    /**
-     * Creates a new authenticator
-     * 
-     * @param username
-     *            Username
-     * @param password
-     *            Password
-     * @param workstation
-     *            Workstation, this is the ID of your local workstation
-     * @param domain
-     *            Domain, this is the domain you are authenticating in which may
-     *            not necessarily be the domain your workstation is in
-     */
-    public SimpleNTAuthenticator(String username, char[] password, String workstation, String domain) {
-        super(username, password);
-        this.workstation = workstation;
-        this.domain = domain;
-    }
-
-    @Override
-    protected Credentials createCredentials(URI target) {
-        return new NTCredentials(this.getUserName(target), new String(this.getPassword(target)), this.workstation, this.domain);
-    }
-
-}
diff --git a/jena-arq/src/main/java/org/apache/jena/query/DatasetAccessorFactory.java b/jena-arq/src/main/java/org/apache/jena/query/DatasetAccessorFactory.java
index 31ab4e8f85..c954019ef0 100644
--- a/jena-arq/src/main/java/org/apache/jena/query/DatasetAccessorFactory.java
+++ b/jena-arq/src/main/java/org/apache/jena/query/DatasetAccessorFactory.java
@@ -18,7 +18,7 @@
 
 package org.apache.jena.query;
 
-import org.apache.jena.atlas.web.auth.HttpAuthenticator;
+import org.apache.http.client.HttpClient;
 import org.apache.jena.sparql.core.DatasetGraph ;
 import org.apache.jena.web.DatasetAdapter ;
 import org.apache.jena.web.DatasetGraphAccessor ;
@@ -42,14 +42,14 @@ public static DatasetAccessor createHTTP(String serviceURI)
     }
     
     /**
-     * Create an accessor for a remote HTTP service that requires authentication
+     * Create an accessor for a remote HTTP service that requires a custom client (e.g. for authentication)
      * @param serviceURI Service URI
-     * @param authenticator HTTP authenticator
+     * @param client HTTP client
      * @return Accessor
      */
-    public static DatasetAccessor createHTTP(String serviceURI, HttpAuthenticator authenticator)
+    public static DatasetAccessor createHTTP(String serviceURI, HttpClient client)
     {
-        return adapt(new DatasetGraphAccessorHTTP(serviceURI, authenticator));
+        return adapt(new DatasetGraphAccessorHTTP(serviceURI, client));
     }
 
     /**
diff --git a/jena-arq/src/main/java/org/apache/jena/query/QueryExecutionFactory.java b/jena-arq/src/main/java/org/apache/jena/query/QueryExecutionFactory.java
index bda6a80d31..37380996dd 100644
--- a/jena-arq/src/main/java/org/apache/jena/query/QueryExecutionFactory.java
+++ b/jena-arq/src/main/java/org/apache/jena/query/QueryExecutionFactory.java
@@ -19,8 +19,8 @@
 package org.apache.jena.query;
 import java.util.List ;
 
+import org.apache.http.client.HttpClient;
 import org.apache.jena.atlas.logging.Log ;
-import org.apache.jena.atlas.web.auth.HttpAuthenticator ;
 import org.apache.jena.rdf.model.Model ;
 import org.apache.jena.sparql.core.DatasetGraph ;
 import org.apache.jena.sparql.engine.Plan ;
@@ -278,19 +278,19 @@ static public QueryExecution create(String queryStr, Syntax syntax, Dataset data
      * @return QueryExecution
      */ 
     static public QueryExecution sparqlService(String service, String query) {
-        return sparqlService(service, query, (HttpAuthenticator)null) ;
+        return sparqlService(service, query, (HttpClient)null) ;
     }
     
     /** Create a QueryExecution that will access a SPARQL service over HTTP
      * @param service   URL of the remote service 
      * @param query     Query string to execute 
-     * @param authenticator HTTP Authenticator
+     * @param client    HTTP client
      * @return QueryExecution
      */ 
-    static public QueryExecution sparqlService(String service, String query, HttpAuthenticator authenticator) {
+    static public QueryExecution sparqlService(String service, String query, HttpClient client) {
         checkNotNull(service, "URL for service is null") ;
         checkArg(query) ;
-        return sparqlService(service, QueryFactory.create(query), authenticator) ;
+        return sparqlService(service, QueryFactory.create(query), client) ;
     }
     
     /** Create a QueryExecution that will access a SPARQL service over HTTP
@@ -307,14 +307,14 @@ static public QueryExecution sparqlService(String service, String query, String
      * @param service       URL of the remote service 
      * @param query         Query string to execute
      * @param defaultGraph  URI of the default graph
-     * @param authenticator HTTP Authenticator
+     * @param client        HTTP client
      * @return QueryExecution
      */ 
-    static public QueryExecution sparqlService(String service, String query, String defaultGraph, HttpAuthenticator authenticator) {
+    static public QueryExecution sparqlService(String service, String query, String defaultGraph, HttpClient client) {
         checkNotNull(service, "URL for service is null") ;
         // checkNotNull(defaultGraph, "IRI for default graph is null") ;
         checkArg(query) ;
-        return sparqlService(service, QueryFactory.create(query), defaultGraph, authenticator) ;
+        return sparqlService(service, QueryFactory.create(query), defaultGraph, client) ;
     }
     
     /** Create a QueryExecution that will access a SPARQL service over HTTP
@@ -333,16 +333,16 @@ static public QueryExecution sparqlService(String service, String query, List<St
      * @param query             Query string to execute
      * @param defaultGraphURIs  List of URIs to make up the default graph
      * @param namedGraphURIs    List of URIs to make up the named graphs
-     * @param authenticator     HTTP Authenticator
+     * @param client            HTTP client
      * @return QueryExecution
      */ 
     static public QueryExecution sparqlService(String service, String query, List<String> defaultGraphURIs, List<String> namedGraphURIs,
-                                               HttpAuthenticator authenticator) {
+                                               HttpClient client) {
         checkNotNull(service, "URL for service is null") ;
         // checkNotNull(defaultGraphURIs, "List of default graph URIs is null") ;
         // checkNotNull(namedGraphURIs, "List of named graph URIs is null") ;
         checkArg(query) ;
-        return sparqlService(service, QueryFactory.create(query), defaultGraphURIs, namedGraphURIs, authenticator) ;
+        return sparqlService(service, QueryFactory.create(query), defaultGraphURIs, namedGraphURIs, client) ;
     }
     
     /** Create a QueryExecution that will access a SPARQL service over HTTP
@@ -351,19 +351,19 @@ static public QueryExecution sparqlService(String service, String query, List<St
      * @return QueryExecution
      */ 
     static public QueryExecution sparqlService(String service, Query query) {
-        return sparqlService(service, query, (HttpAuthenticator)null) ;
+        return sparqlService(service, query, (HttpClient)null) ;
     }
     
     /** Create a QueryExecution that will access a SPARQL service over HTTP
      * @param service   URL of the remote service 
      * @param query     Query to execute 
-     * @param authenticator HTTP Authenticator
+     * @param client    HTTP client
      * @return QueryExecution
      */ 
-    static public QueryExecution sparqlService(String service, Query query, HttpAuthenticator authenticator) {
+    static public QueryExecution sparqlService(String service, Query query, HttpClient client) {
         checkNotNull(service, "URL for service is null") ;
         checkArg(query) ;
-        return createServiceRequest(service, query, authenticator) ;
+        return createServiceRequest(service, query, client) ;
     }
     
     /** Create a QueryExecution that will access a SPARQL service over HTTP
@@ -382,16 +382,16 @@ static public QueryExecution sparqlService(String service, Query query, List<Str
      * @param query             Query to execute
      * @param defaultGraphURIs  List of URIs to make up the default graph
      * @param namedGraphURIs    List of URIs to make up the named graphs
-     * @param authenticator     HTTP Authenticator
+     * @param client            HTTP client
      * @return QueryExecution
      */ 
     static public QueryExecution sparqlService(String service, Query query, List<String> defaultGraphURIs, List<String> namedGraphURIs,
-                                               HttpAuthenticator authenticator) {
+                                               HttpClient client) {
         checkNotNull(service, "URL for service is null") ;
         // checkNotNull(defaultGraphURIs, "List of default graph URIs is null") ;
         // checkNotNull(namedGraphURIs, "List of named graph URIs is null") ;
         checkArg(query) ;
-        QueryEngineHTTP qe = createServiceRequest(service, query, authenticator) ;
+        QueryEngineHTTP qe = createServiceRequest(service, query, client) ;
         if ( defaultGraphURIs != null )
             qe.setDefaultGraphURIs(defaultGraphURIs) ;
         if ( namedGraphURIs != null )
@@ -413,14 +413,14 @@ static public QueryExecution sparqlService(String service, Query query, String d
      * @param service       URL of the remote service 
      * @param query         Query to execute
      * @param defaultGraph  URI of the default graph
-     * @param authenticator HTTP Authenticator
+     * @param client        HTTP client
      * @return QueryExecution
      */ 
-    static public QueryExecution sparqlService(String service, Query query, String defaultGraph, HttpAuthenticator authenticator) {
+    static public QueryExecution sparqlService(String service, Query query, String defaultGraph, HttpClient client) {
         checkNotNull(service, "URL for service is null") ;
         // checkNotNull(defaultGraph, "IRI for default graph is null") ;
         checkArg(query) ;
-        QueryEngineHTTP qe = createServiceRequest(service, query, authenticator) ;
+        QueryEngineHTTP qe = createServiceRequest(service, query, client) ;
         qe.addDefaultGraph(defaultGraph) ;
         return qe ;
     }
@@ -441,11 +441,11 @@ static public QueryEngineHTTP createServiceRequest(String service, Query query)
      * allows various HTTP specific parameters to be set. 
      * @param service Endpoint URL
      * @param query Query
-     * @param authenticator HTTP Authenticator 
+     * @param client HTTP client 
      * @return Remote Query Engine
      */
-    static public QueryEngineHTTP createServiceRequest(String service, Query query, HttpAuthenticator authenticator) {
-        QueryEngineHTTP qe = new QueryEngineHTTP(service, query, authenticator) ;
+    static public QueryEngineHTTP createServiceRequest(String service, Query query, HttpClient client) {
+        QueryEngineHTTP qe = new QueryEngineHTTP(service, query, client) ;
         return qe ;
     }
 
diff --git a/jena-arq/src/main/java/org/apache/jena/riot/web/HttpOp.java b/jena-arq/src/main/java/org/apache/jena/riot/web/HttpOp.java
index 52d1562723..7830f9a471 100644
--- a/jena-arq/src/main/java/org/apache/jena/riot/web/HttpOp.java
+++ b/jena-arq/src/main/java/org/apache/jena/riot/web/HttpOp.java
@@ -22,8 +22,6 @@
 
 import java.io.IOException ;
 import java.io.InputStream ;
-import java.net.URI ;
-import java.net.URISyntaxException ;
 import java.nio.charset.StandardCharsets ;
 import java.util.ArrayList ;
 import java.util.List ;
@@ -33,26 +31,20 @@
 import org.apache.http.client.HttpClient ;
 import org.apache.http.client.entity.UrlEncodedFormEntity ;
 import org.apache.http.client.methods.* ;
-import org.apache.http.conn.ClientConnectionManager ;
 import org.apache.http.entity.ContentType ;
 import org.apache.http.entity.InputStreamEntity ;
 import org.apache.http.entity.StringEntity ;
-import org.apache.http.impl.client.AbstractHttpClient ;
+import org.apache.http.impl.client.CloseableHttpClient;
 import org.apache.http.impl.client.HttpClientBuilder ;
-import org.apache.http.impl.client.SystemDefaultHttpClient ;
-import org.apache.http.impl.conn.PoolingClientConnectionManager ;
-import org.apache.http.impl.conn.SchemeRegistryFactory ;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.http.impl.client.cache.CachingHttpClientBuilder;
 import org.apache.http.message.BasicNameValuePair ;
-import org.apache.http.protocol.BasicHttpContext ;
 import org.apache.http.protocol.HttpContext ;
 import org.apache.http.util.EntityUtils ;
 import org.apache.jena.atlas.io.IO ;
 import org.apache.jena.atlas.web.HttpException ;
 import org.apache.jena.atlas.web.TypedInputStream ;
-import org.apache.jena.atlas.web.auth.HttpAuthenticator ;
-import org.apache.jena.atlas.web.auth.ServiceAuthenticator ;
 import org.apache.jena.query.ARQ ;
-import org.apache.jena.riot.RiotException ;
 import org.apache.jena.riot.WebContent ;
 import org.apache.jena.sparql.engine.http.Params ;
 import org.apache.jena.sparql.engine.http.Params.Pair ;
@@ -89,8 +81,8 @@ public class HttpOp {
      * Test are in Fuseki (need a server to test against)
      * 
      * Pattern of functions provided: 1/ The full operation (includes
-     * HttpClient, HttpContext, HttpAuthenticator) any of which can be null for
-     * "default" 2/ Provide common use options without those three arguments.
+     * HttpClient, HttpContext) either of which can be null for
+     * "default" 2/ Provide common use options without those two arguments.
      * These all become the full operation. 3/ All calls go via exec for logging
      * and debugging.
      */
@@ -104,20 +96,10 @@ public class HttpOp {
     static private AtomicLong counter = new AtomicLong(0);
 
     /**
-     * Default HttpClient. This is used only if there is no authentication set.
+     * Default HttpClient.
      */
     static private HttpClient defaultHttpClient = null;
 
-    /**
-     * Whether the default HttpClient is used in conjunction with authentication
-     */
-    static private boolean useDefaultClientWithAuthentication = false;
-
-    /**
-     * Default authenticator used for HTTP authentication
-     */
-    static private HttpAuthenticator defaultAuthenticator = new ServiceAuthenticator();
-
     /**
      * Constant for the default User-Agent header that ARQ will use
      */
@@ -157,13 +139,38 @@ public String get() {
      */
     public static class CaptureInput implements HttpCaptureResponse<TypedInputStream> {
         private TypedInputStream stream;
+        
+        private boolean closeClient = false;
+        
+        private CloseableHttpClient client;
+        
+        public void setClient(CloseableHttpClient client) {
+            this.client = client;
+        }
+
+        private static class ClientRetainingTypedInputStream extends TypedInputStream {
+
+            private final CloseableHttpClient retainedClient;
+            
+            public ClientRetainingTypedInputStream(InputStream in, String contentType, CloseableHttpClient client) {
+                super(in, contentType);
+                this.retainedClient = client;
+            }
+
+            @Override
+            public void close() {
+                IO.close(retainedClient);
+                super.close();
+            }
+            
+        }
 
         @Override
         public void handle(String baseIRI, HttpResponse response) throws IOException {
-
             HttpEntity entity = response.getEntity();
             String ct = (entity.getContentType() == null) ? null : entity.getContentType().getValue();
-            stream = new TypedInputStream(entity.getContent(), ct);
+            stream = closeClient ? new ClientRetainingTypedInputStream(entity.getContent(), ct, client)
+                    : new TypedInputStream(entity.getContent(), ct);
         }
 
         @Override
@@ -172,29 +179,6 @@ public TypedInputStream get() {
         }
     }
 
-    /**
-     * Gets the default authenticator used for authenticate requests if no
-     * specific authenticator is provided.
-     * 
-     * @return HTTP authenticator
-     */
-    public static HttpAuthenticator getDefaultAuthenticator() {
-        return defaultAuthenticator;
-    }
-
-    /**
-     * Sets the default authenticator used for authenticate requests if no
-     * specific authenticator is provided. May be set to null to turn off
-     * default authentication, when set to null users must manually configure
-     * authentication.
-     * 
-     * @param authenticator
-     *            Authenticator
-     */
-    public static void setDefaultAuthenticator(HttpAuthenticator authenticator) {
-        defaultAuthenticator = authenticator;
-    }
-
     /**
      * Return the current default {@link HttpClient}. This may be null, meaning
      * a new {@link HttpClient} is created each time, if none is provided
@@ -214,13 +198,6 @@ public static HttpClient getDefaultHttpClient() {
      * sensitive).
      * </p>
      * <p>
-     * The default HttpClient is not used if an HttpAuthenticator is provided
-     * since this can potentially leak authentication credentials to be leaked
-     * between requests to different services. However in some cases it may be
-     * valuable to share the client regardless in which case you can also set
-     * the
-     * </p>
-     * <p>
      * Set to "null" to create a new HttpClient for each call (default
      * behaviour, more reliable, but slower when many HTTP operation are
      * attempted).
@@ -233,42 +210,11 @@ public static HttpClient getDefaultHttpClient() {
     public static void setDefaultHttpClient(HttpClient httpClient) {
         defaultHttpClient = httpClient;
     }
-
-    /**
-     * Gets whether the configured default HttpClient will be used in
-     * conjunction with authentication.
-     * <p>
-     * This defaults to false because this can potentially leak authentication
-     * credentials between requests to different services. However in some cases
-     * it may be valuable to share the client regardless e.g. when you have a
-     * specially configured HttpClient for your environment.
-     * </p>
-     * 
-     * @return True if the configured default client will be used with
-     *         authentication, false otherwise
-     */
-    public static boolean getUseDefaultClientWithAuthentication() {
-        return useDefaultClientWithAuthentication;
-    }
-
+    
     /**
-     * Sets whether the configured default HttpClient will be used in
-     * conjunction with authentication.
-     * <p>
-     * This defaults to false because this can potentially leak authentication
-     * credentials between requests to different services. However in some cases
-     * it may be valuable to share the client regardless e.g. when you have a
-     * specially configured HttpClient for your environment.
-     * </p>
-     * 
-     * @param useWithAuth
-     *            True if the configured default client should be used with
-     *            authentication, false if it should not
+     * Create an HttpClient that performs connection pooling. This can be used
+     * with {@link #setDefaultHttpClient} or provided in the HttpOp calls.
      */
-    public static void setUseDefaultClientWithAuthentication(boolean useWithAuth) {
-        useDefaultClientWithAuthentication = useWithAuth;
-    }
-
     public static HttpClient createPoolingHttpClient() {
         String s = System.getProperty("http.maxConnections", "5");
         int max = Integer.parseInt(s);
@@ -278,34 +224,17 @@ public static HttpClient createPoolingHttpClient() {
             .build() ;
     }
     
-//    /** @deprecated Use {@link #createPoolingHttpClient()} */
-//    @Deprecated
-//    public static HttpClient createCachingHttpClient() {
-//        return createPoolingHttpClient() ; 
-//    }
-    
     /**
-     * Create an HttpClient that performs connection pooling. This can be used
+     * Create an HttpClient that performs client-side caching and conection pooling. This can be used
      * with {@link #setDefaultHttpClient} or provided in the HttpOp calls.
      */
-    @SuppressWarnings("deprecation")
-    public static HttpClient createCachingHttpClient() {
-        return new SystemDefaultHttpClient() {
-            /**
-             * See SystemDefaultHttpClient (4.2). This version always sets the
-             * connection cache
-             */
-            @Override
-            protected ClientConnectionManager createClientConnectionManager() {
-                PoolingClientConnectionManager connmgr = 
-                    new PoolingClientConnectionManager(SchemeRegistryFactory.createSystemDefault());
-                String s = System.getProperty("http.maxConnections", "5");
-                int max = Integer.parseInt(s);
-                connmgr.setDefaultMaxPerRoute(max);
-                connmgr.setMaxTotal(2 * max);
-                return connmgr;
-            }
-        };
+    public static CloseableHttpClient createCachingHttpClient() {
+        String s = System.getProperty("http.maxConnections", "5");
+        int max = Integer.parseInt(s);
+        return CachingHttpClientBuilder.create()
+            .setMaxConnPerRoute(max)
+            .setMaxConnTotal(2*max)
+            .build() ;
     }
 
     /**
@@ -342,26 +271,7 @@ public static void setUserAgent(String userAgent) {
      *            Response Handler
      */
     public static void execHttpGet(String url, String acceptHeader, HttpResponseHandler handler) {
-        execHttpGet(url, acceptHeader, handler, null, null, null);
-    }
-
-    /**
-     * Executes a HTTP Get request handling the response with the given handler.
-     * <p>
-     * HTTP responses 400 and 500 become exceptions.
-     * </p>
-     * 
-     * @param url
-     *            URL
-     * @param acceptHeader
-     *            Accept Header
-     * @param handler
-     *            Response Handler
-     * @param authenticator
-     *            HTTP Authenticator
-     */
-    public static void execHttpGet(String url, String acceptHeader, HttpResponseHandler handler, HttpAuthenticator authenticator) {
-        execHttpGet(url, acceptHeader, handler, null, null, authenticator);
+        execHttpGet(url, acceptHeader, handler, null, null);
     }
 
     /**
@@ -385,14 +295,12 @@ public static void execHttpGet(String url, String acceptHeader, HttpResponseHand
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      */
     public static void execHttpGet(String url, String acceptHeader, HttpResponseHandler handler, HttpClient httpClient,
-            HttpContext httpContext, HttpAuthenticator authenticator) {
+            HttpContext httpContext) {
         String requestURI = determineRequestURI(url);
         HttpGet httpget = new HttpGet(requestURI);
-        exec(url, httpget, acceptHeader, handler, httpClient, httpContext, authenticator);
+        exec(url, httpget, acceptHeader, handler, httpClient, httpContext);
     }
 
     /**
@@ -408,7 +316,7 @@ public static void execHttpGet(String url, String acceptHeader, HttpResponseHand
      */
     public static TypedInputStream execHttpGet(String url) {
         HttpCaptureResponse<TypedInputStream> handler = new CaptureInput();
-        execHttpGet(url, null, handler, null, null, null);
+        execHttpGet(url, null, handler, null, null);
         return handler.get();
     }
 
@@ -427,7 +335,7 @@ public static TypedInputStream execHttpGet(String url) {
      */
     public static TypedInputStream execHttpGet(String url, String acceptHeader) {
         HttpCaptureResponse<TypedInputStream> handler = new CaptureInput();
-        execHttpGet(url, acceptHeader, handler, null, null, null);
+        execHttpGet(url, acceptHeader, handler, null, null);
         return handler.get();
     }
 
@@ -446,15 +354,12 @@ public static TypedInputStream execHttpGet(String url, String acceptHeader) {
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      * @return TypedInputStream or null if the URL returns 404.
      */
-    public static TypedInputStream execHttpGet(String url, String acceptHeader, HttpClient httpClient, HttpContext httpContext,
-            HttpAuthenticator authenticator) {
+    public static TypedInputStream execHttpGet(String url, String acceptHeader, HttpClient httpClient, HttpContext httpContext) {
         HttpCaptureResponse<TypedInputStream> handler = new CaptureInput();
         try {
-            execHttpGet(url, acceptHeader, handler, httpClient, httpContext, authenticator);
+            execHttpGet(url, acceptHeader, handler, httpClient, httpContext);
         } catch (HttpException ex) {
             if (ex.getResponseCode() == HttpSC.NOT_FOUND_404)
                 return null;
@@ -510,7 +415,7 @@ public static String execHttpGetString(String url, String acceptHeader) {
      *            Content to POST
      */
     public static void execHttpPost(String url, String contentType, String content) {
-        execHttpPost(url, contentType, content, null, nullHandler, null, null, defaultAuthenticator);
+        execHttpPost(url, contentType, content, null, nullHandler, null, null);
     }
 
     /**
@@ -526,7 +431,7 @@ public static void execHttpPost(String url, String contentType, String content)
      *            Accept Type
      */
     public static TypedInputStream execHttpPostStream(String url, String contentType, String content, String acceptType) {
-        return execHttpPostStream(url, contentType, content, acceptType, null, null, null) ;
+        return execHttpPostStream(url, contentType, content, acceptType, null, null) ;
     }
 
     /**
@@ -543,19 +448,17 @@ public static TypedInputStream execHttpPostStream(String url, String contentType
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      */
     public static void execHttpPost(String url, String contentType, String content, HttpClient httpClient,
-                                    HttpContext httpContext, HttpAuthenticator authenticator) {
-        execHttpPost(url, contentType, content, null, nullHandler, httpClient, httpContext, authenticator);
+                                    HttpContext httpContext) {
+        execHttpPost(url, contentType, content, null, nullHandler, httpClient, httpContext);
     }
 
     public static TypedInputStream execHttpPostStream(String url, String contentType, String content, String acceptType,
-                                                      HttpClient httpClient, HttpContext httpContext, HttpAuthenticator authenticator) {
+                                                      HttpClient httpClient, HttpContext httpContext) {
         CaptureInput handler = new CaptureInput();
         try {
-            execHttpPost(url, contentType, content, acceptType, handler, httpClient, httpContext, authenticator);
+            execHttpPost(url, contentType, content, acceptType, handler, httpClient, httpContext);
         } catch (HttpException ex) {
             if (ex.getResponseCode() == HttpSC.NOT_FOUND_404)
                 return null;
@@ -583,16 +486,14 @@ public static TypedInputStream execHttpPostStream(String url, String contentType
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      */
     public static void execHttpPost(String url, String contentType, String content, String acceptType,
-            HttpResponseHandler handler, HttpClient httpClient, HttpContext httpContext, HttpAuthenticator authenticator) {
+            HttpResponseHandler handler, HttpClient httpClient, HttpContext httpContext) {
         StringEntity e = null;
         try {
             e = new StringEntity(content, StandardCharsets.UTF_8);
             e.setContentType(contentType);
-            execHttpPost(url, e, acceptType, handler, httpClient, httpContext, authenticator);
+            execHttpPost(url, e, acceptType, handler, httpClient, httpContext);
         }
         finally {
             closeEntity(e);
@@ -627,7 +528,7 @@ public static void execHttpPost(String url, String contentType, String content,
      * 
      */
     public static void execHttpPost(String url, String contentType, InputStream input, long length) {
-        execHttpPost(url, contentType, input, length, null, nullHandler, null, null, defaultAuthenticator);
+        execHttpPost(url, contentType, input, length, null, nullHandler, null, null);
     }
 
     /**
@@ -652,7 +553,7 @@ public static void execHttpPost(String url, String contentType, InputStream inpu
      */
     public static void execHttpPost(String url, String contentType, InputStream input, long length, String acceptType,
             HttpResponseHandler handler) {
-        execHttpPost(url, contentType, input, length, acceptType, handler, null, null, null);
+        execHttpPost(url, contentType, input, length, acceptType, handler, null, null);
     }
 
     /**
@@ -678,16 +579,15 @@ public static void execHttpPost(String url, String contentType, InputStream inpu
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
+     *
      */
     public static void execHttpPost(String url, String contentType, InputStream input, long length, String acceptType,
-            HttpResponseHandler handler, HttpClient httpClient, HttpContext httpContext, HttpAuthenticator authenticator) {
+            HttpResponseHandler handler, HttpClient httpClient, HttpContext httpContext) {
         InputStreamEntity e = new InputStreamEntity(input, length);
         e.setContentType(contentType);
         e.setContentEncoding("UTF-8");
         try {
-            execHttpPost(url, e, acceptType, handler, httpClient, httpContext, authenticator);
+            execHttpPost(url, e, acceptType, handler, httpClient, httpContext);
         } finally {
             closeEntity(e);
         }
@@ -732,7 +632,7 @@ public static TypedInputStream execHttpPostStream(String url, HttpEntity entity,
      *            Response Handler
      */
     public static void execHttpPost(String url, HttpEntity entity, String acceptString, HttpResponseHandler handler) {
-        execHttpPost(url, entity, acceptString, handler, null, null, null);
+        execHttpPost(url, entity, acceptString, handler, null, null);
     }
 
     /**
@@ -751,13 +651,10 @@ public static void execHttpPost(String url, HttpEntity entity, String acceptStri
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      */
-    public static void execHttpPost(String url, HttpEntity entity, HttpClient httpClient, HttpContext httpContext,
-            HttpAuthenticator authenticator) {
+    public static void execHttpPost(String url, HttpEntity entity, HttpClient httpClient, HttpContext httpContext) {
 
-        execHttpPost(url, entity, null, nullHandler, httpClient, httpContext, authenticator);
+        execHttpPost(url, entity, null, nullHandler, httpClient, httpContext);
     }
 
     /**
@@ -778,13 +675,11 @@ public static void execHttpPost(String url, HttpEntity entity, HttpClient httpCl
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      */
     public static TypedInputStream execHttpPostStream(String url, HttpEntity entity, String acceptHeader,
-                                    HttpClient httpClient, HttpContext httpContext, HttpAuthenticator authenticator) {
+                                    HttpClient httpClient, HttpContext httpContext) {
         CaptureInput handler = new CaptureInput();
-        execHttpPost(url, entity, acceptHeader, handler, httpClient, httpContext, authenticator) ;
+        execHttpPost(url, entity, acceptHeader, handler, httpClient, httpContext) ;
         return handler.get() ;
     }
 
@@ -808,16 +703,14 @@ public static TypedInputStream execHttpPostStream(String url, HttpEntity entity,
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      */
     public static void execHttpPost(String url, HttpEntity entity, String acceptHeader, HttpResponseHandler handler,
-            HttpClient httpClient, HttpContext httpContext, HttpAuthenticator authenticator) {
+            HttpClient httpClient, HttpContext httpContext) {
         String requestURI = determineRequestURI(url);
         HttpPost httppost = new HttpPost(requestURI);
         if (entity != null)
             httppost.setEntity(entity);
-        exec(url, httppost, acceptHeader, handler, httpClient, httpContext, authenticator);
+        exec(url, httppost, acceptHeader, handler, httpClient, httpContext);
     }
     
     
@@ -847,7 +740,7 @@ public static void execHttpPostForm(String url, Params params) {
      * @param acceptHeader
      */
     public static TypedInputStream execHttpPostFormStream(String url, Params params, String acceptHeader) {
-        return execHttpPostFormStream(url, params, acceptHeader, null, null, null);
+        return execHttpPostFormStream(url, params, acceptHeader, null, null);
     }
 
     
@@ -902,14 +795,12 @@ public static TypedInputStream execHttpPostFormStream(String url, Params params,
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      */
     public static TypedInputStream execHttpPostFormStream(String url, Params params, String acceptHeader, HttpClient httpClient,
-            HttpContext httpContext, HttpAuthenticator authenticator) {
+            HttpContext httpContext) {
         CaptureInput handler = new CaptureInput();
         try {
-            execHttpPostForm(url, params, acceptHeader, handler, httpClient, httpContext, authenticator);
+            execHttpPostForm(url, params, acceptHeader, handler, httpClient, httpContext);
         } catch (HttpException ex) {
             if (ex.getResponseCode() == HttpSC.NOT_FOUND_404)
                 return null;
@@ -931,7 +822,7 @@ public static TypedInputStream execHttpPostFormStream(String url, Params params,
      *            Response handler called to process the response
      */
     public static void execHttpPostForm(String url, Params params, String acceptString, HttpResponseHandler handler) {
-        execHttpPostForm(url, params, acceptString, handler, null, null, null);
+        execHttpPostForm(url, params, acceptString, handler, null, null);
     }
 
     /**
@@ -949,17 +840,15 @@ public static void execHttpPostForm(String url, Params params, String acceptStri
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      */
     public static void execHttpPostForm(String url, Params params, String acceptHeader, HttpResponseHandler handler,
-            HttpClient httpClient, HttpContext httpContext, HttpAuthenticator authenticator) {
+            HttpClient httpClient, HttpContext httpContext) {
         if (handler == null)
             throw new IllegalArgumentException("A HttpResponseHandler must be provided (e.g. HttpResponseLib.nullhandler)");
         String requestURI = url;
         HttpPost httppost = new HttpPost(requestURI);
         httppost.setEntity(convertFormParams(params));
-        exec(url, httppost, acceptHeader, handler, httpClient, httpContext, authenticator);
+        exec(url, httppost, acceptHeader, handler, httpClient, httpContext);
     }
 
     /**
@@ -973,7 +862,7 @@ public static void execHttpPostForm(String url, Params params, String acceptHead
      *            Content for the PUT
      */
     public static void execHttpPut(String url, String contentType, String content) {
-        execHttpPut(url, contentType, content, null, null, defaultAuthenticator);
+        execHttpPut(url, contentType, content, null, null);
     }
 
     /**
@@ -989,16 +878,14 @@ public static void execHttpPut(String url, String contentType, String content) {
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      */
     public static void execHttpPut(String url, String contentType, String content, HttpClient httpClient,
-            HttpContext httpContext, HttpAuthenticator authenticator) {
+            HttpContext httpContext) {
         StringEntity e = null;
         try {
             e = new StringEntity(content, StandardCharsets.UTF_8);
             e.setContentType(contentType);
-            execHttpPut(url, e, httpClient, httpContext, authenticator);
+            execHttpPut(url, e, httpClient, httpContext);
         }
         finally {
             closeEntity(e);
@@ -1018,7 +905,7 @@ public static void execHttpPut(String url, String contentType, String content, H
      *            Amount of content to PUT
      */
     public static void execHttpPut(String url, String contentType, InputStream input, long length) {
-        execHttpPut(url, contentType, input, length, null, null, null);
+        execHttpPut(url, contentType, input, length, null, null);
     }
 
     /**
@@ -1036,16 +923,14 @@ public static void execHttpPut(String url, String contentType, InputStream input
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      */
     public static void execHttpPut(String url, String contentType, InputStream input, long length, HttpClient httpClient,
-            HttpContext httpContext, HttpAuthenticator authenticator) {
+            HttpContext httpContext) {
         InputStreamEntity e = new InputStreamEntity(input, length);
         e.setContentType(contentType);
         e.setContentEncoding("UTF-8");
         try {
-            execHttpPut(url, e, httpClient, httpContext, authenticator);
+            execHttpPut(url, e, httpClient, httpContext);
         } finally {
             closeEntity(e);
         }
@@ -1060,7 +945,7 @@ public static void execHttpPut(String url, String contentType, InputStream input
      *            HTTP Entity to PUT
      */
     public static void execHttpPut(String url, HttpEntity entity) {
-        execHttpPut(url, entity, null, null, null);
+        execHttpPut(url, entity, null, null);
     }
 
     /**
@@ -1074,15 +959,12 @@ public static void execHttpPut(String url, HttpEntity entity) {
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      */
-    public static void execHttpPut(String url, HttpEntity entity, HttpClient httpClient, HttpContext httpContext,
-            HttpAuthenticator authenticator) {
+    public static void execHttpPut(String url, HttpEntity entity, HttpClient httpClient, HttpContext httpContext) {
         String requestURI = determineRequestURI(url);
         HttpPut httpput = new HttpPut(requestURI);
         httpput.setEntity(entity);
-        exec(url, httpput, null, nullHandler, httpClient, httpContext, authenticator);
+        exec(url, httpput, null, nullHandler, httpClient, httpContext);
     }
 
     /**
@@ -1106,7 +988,7 @@ public static void execHttpHead(String url) {
      *            Response Handler
      */
     public static void execHttpHead(String url, String acceptString, HttpResponseHandler handler) {
-        execHttpHead(url, acceptString, handler, null, null, null);
+        execHttpHead(url, acceptString, handler, null, null);
     }
 
     /**
@@ -1122,15 +1004,13 @@ public static void execHttpHead(String url, String acceptString, HttpResponseHan
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      */
 
     public static void execHttpHead(String url, String acceptString, HttpResponseHandler handler, HttpClient httpClient,
-            HttpContext httpContext, HttpAuthenticator authenticator) {
+            HttpContext httpContext) {
         String requestURI = determineRequestURI(url);
         HttpHead httpHead = new HttpHead(requestURI);
-        exec(url, httpHead, acceptString, handler, httpClient, httpContext, authenticator);
+        exec(url, httpHead, acceptString, handler, httpClient, httpContext);
     }
 
     /**
@@ -1152,7 +1032,7 @@ public static void execHttpDelete(String url) {
      *            Response Handler
      */
     public static void execHttpDelete(String url, HttpResponseHandler handler) {
-        execHttpDelete(url, handler, null, null, null);
+        execHttpDelete(url, handler, null, null);
     }
 
     /**
@@ -1166,34 +1046,32 @@ public static void execHttpDelete(String url, HttpResponseHandler handler) {
      *            HTTP Client
      * @param httpContext
      *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
      */
-    public static void execHttpDelete(String url, HttpResponseHandler handler, HttpClient httpClient, HttpContext httpContext,
-            HttpAuthenticator authenticator) {
+    public static void execHttpDelete(String url, HttpResponseHandler handler, HttpClient httpClient, HttpContext httpContext) {
         HttpUriRequest httpDelete = new HttpDelete(url);
-        exec(url, httpDelete, null, handler, null, httpContext, authenticator);
+        exec(url, httpDelete, null, handler, null, httpContext);
     }
 
     // ---- Perform the operation!
-
-    private static void exec(String url, HttpUriRequest request, String acceptHeader, HttpResponseHandler handler,
-                             HttpClient httpClient, HttpContext httpContext, HttpAuthenticator authenticator) {
-        // Prepare authentication, if any.
-        httpClient = ensureClient(httpClient, authenticator);
-        httpContext = ensureContext(httpContext);
-        applyAuthentication(asAbstractClient(httpClient), url, httpContext, authenticator);
-        exec(url, request, acceptHeader, handler, httpClient, httpContext); 
-    }
-    
     private static void exec(String url, HttpUriRequest request, String acceptHeader, HttpResponseHandler handler, HttpClient httpClient, HttpContext httpContext) {
+        // whether we should close the client after request execution
+        // only true if we built the client right here
+        boolean closeClient = false;
+        if (httpClient == null) {
+            if (getDefaultHttpClient() == null ) {
+                httpClient = HttpClients.createMinimal();
+                closeClient = true;
+            }
+            else httpClient = getDefaultHttpClient();
+        }
+        // and also only true if the handler won't close the client for us
+        closeClient = closeClient && !(handler instanceof CaptureInput);
         try {
             if (handler == null)
                 // This cleans up.
                 handler = nullHandler;
 
             long id = counter.incrementAndGet();
-            String requestURI = determineRequestURI(url);
             String baseURI = determineBaseIRI(url);
             if (log.isDebugEnabled())
                 log.debug(format("[%d] %s %s", id, request.getMethod(), request.getURI().toString()));
@@ -1218,69 +1096,17 @@ private static void exec(String url, HttpUriRequest request, String acceptHeader
             // Redirects are followed by HttpClient.
             if (handler != null)
                 handler.handle(baseURI, response);
+            // the cast below is safe because if closeClient then we built the client in this method 
+            if (closeClient) IO.close((CloseableHttpClient) httpClient);
         } catch (IOException ex) {
             throw new HttpException(ex);
         }
     }
 
 	public static String readPayload(HttpEntity entity) throws IOException {
-		if (entity == null) {
-			return null;
-		}
-		return EntityUtils.toString(entity, ContentType.getOrDefault(entity).getCharset());
+        return entity == null ? null : EntityUtils.toString(entity, ContentType.getOrDefault(entity).getCharset());
 	}
 
-    /**
-     * Ensures that a HTTP Client is non-null
-     * <p>
-     * Prefers the {@link HttpClient} provided for the request if available.
-     * Then it tries to use a Jena-wide user configurable
-     * {@link HttpClient} if available. This is used only when no
-     * authentication is required unless the user has indicated they want to use
-     * the default client with authentication regardless.
-     * </p>
-     * <p>
-     * In all other cases it creates a fresh instance of a
-     * {@link SystemDefaultHttpClient} each time.
-     * </p>
-     * 
-     * @param client
-     *            HTTP Client
-     * @return HTTP Client
-     */
-    private static HttpClient ensureClient(HttpClient client, HttpAuthenticator auth) {
-        // Use user provided client if available
-        if (client != null)
-            return client;
-
-        // Use configured default client if no authentication involved or
-        // configured to use it with authentication
-        if (defaultHttpClient != null && (auth == null || useDefaultClientWithAuthentication))
-            return defaultHttpClient;
-
-        // Otherwise use a fresh client each time
-        return new SystemDefaultHttpClient();
-    }
-
-    private static AbstractHttpClient asAbstractClient(HttpClient client) {
-        if (AbstractHttpClient.class.isAssignableFrom(client.getClass())) {
-            return (AbstractHttpClient) client;
-        }
-        return null;
-    }
-
-    /**
-     * Ensures that a context is non-null, uses a new {@link BasicHttpContext}
-     * if none is provided
-     * 
-     * @param context
-     *            HTTP Context
-     * @return Non-null HTTP Context
-     */
-    private static HttpContext ensureContext(HttpContext context) {
-        return context != null ? context : new BasicHttpContext();
-    }
-
     /**
      * Applies the configured User-Agent string to the HTTP request
      * 
@@ -1293,48 +1119,6 @@ public static void applyUserAgent(HttpMessage message) {
         }
     }
 
-    /**
-     * Applies authentication to the given client as appropriate
-     * <p>
-     * If a null authenticator is provided this method tries to use the
-     * registered default authenticator which may be set via the
-     * {@link HttpOp#setDefaultAuthenticator(HttpAuthenticator)} method.
-     * </p>
-     * 
-     * @param client
-     *            HTTP Client
-     * @param target
-     *            Target URI
-     * @param context
-     *            HTTP Context
-     * @param authenticator
-     *            HTTP Authenticator
-     */
-    public static void applyAuthentication(AbstractHttpClient client, String target, HttpContext context,
-            HttpAuthenticator authenticator) {
-        // Cannot apply to null client
-        if (client == null)
-            return;
-
-        // Fallback to default authenticator if null authenticator provided
-        if (authenticator == null)
-            authenticator = defaultAuthenticator;
-
-        // Authenticator could still be null even if we fell back to default
-        if (authenticator == null)
-            return;
-
-        try {
-            // Apply the authenticator
-            URI uri = new URI(target);
-            authenticator.apply(client, context, uri);
-        } catch (URISyntaxException e) {
-            throw new RiotException("Invalid request URI", e);
-        } catch (NullPointerException e) {
-            throw new RiotException("Null request URI", e);
-        }
-    }
-
     private static HttpEntity convertFormParams(Params params) {
         List<NameValuePair> nvps = new ArrayList<>();
         for (Pair p : params.pairs())
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/HttpQuery.java b/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/HttpQuery.java
index 153417d140..d16e1d4704 100644
--- a/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/HttpQuery.java
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/HttpQuery.java
@@ -21,26 +21,20 @@
 import java.io.InputStream ;
 import java.net.MalformedURLException ;
 import java.net.URL ;
-import java.util.concurrent.TimeUnit ;
+import java.util.Map;
 import java.util.regex.Pattern ;
 
 import org.apache.http.client.HttpClient ;
-import org.apache.http.conn.params.ConnManagerPNames ;
-import org.apache.http.impl.client.AbstractHttpClient ;
-import org.apache.http.impl.client.DecompressingHttpClient ;
-import org.apache.http.impl.client.SystemDefaultHttpClient ;
-import org.apache.http.params.CoreConnectionPNames ;
-import org.apache.http.protocol.BasicHttpContext ;
-import org.apache.http.protocol.HttpContext ;
+import org.apache.http.client.config.RequestConfig;
+import org.apache.http.client.protocol.HttpClientContext;
 import org.apache.jena.atlas.web.HttpException ;
 import org.apache.jena.atlas.web.TypedInputStream ;
-import org.apache.jena.atlas.web.auth.HttpAuthenticator ;
-import org.apache.jena.atlas.web.auth.SimpleAuthenticator ;
 import org.apache.jena.query.ARQ ;
 import org.apache.jena.query.QueryExecException ;
 import org.apache.jena.riot.WebContent ;
 import org.apache.jena.riot.web.HttpOp ;
 import org.apache.jena.shared.JenaException ;
+import org.apache.jena.sparql.util.Context;
 import org.slf4j.Logger ;
 import org.slf4j.LoggerFactory ;
 
@@ -51,7 +45,7 @@
  * 
  * If the query string is large, then HTTP POST is used.
  */
-@SuppressWarnings("deprecation")
+
 public class HttpQuery extends Params {
     static final Logger log = LoggerFactory.getLogger(HttpQuery.class.getName());
 
@@ -65,7 +59,6 @@ public class HttpQuery extends Params {
     // An object indicate no value associated with parameter name
     final static Object noValue = new Object();
 
-    private HttpAuthenticator authenticator = null;
     private int responseCode = 0;
     private String responseMessage = null;
     private boolean forcePOST = false;
@@ -73,10 +66,10 @@ public class HttpQuery extends Params {
     private boolean serviceParams = false;
     private final Pattern queryParamPattern = Pattern.compile(".+[&|\\?]query=.*");
     private int connectTimeout = 0, readTimeout = 0;
-    private boolean allowGZip = false;
-    private boolean allowDeflate = false;
+    private boolean allowCompression = false;
     private HttpClient client;
-    private boolean requireClientShutdown = true;
+
+    private HttpClientContext context;
 
     /**
      * Create a execution object for a whole model GET
@@ -162,46 +155,30 @@ public String getResponseMessage() {
     }
 
     /**
-     * Sets whether the HTTP request will include a Accept-Encoding: gzip header
-     * 
-     * @param allow
-     *            Whether to allow GZip encoding
-     */
-    public void setAllowGZip(boolean allow) {
-        allowGZip = allow;
-    }
-
-    /**
-     * Sets whether the HTTP request will include a Accept-Encoding: deflate
+     * Sets whether the HTTP request will include compressed encoding
      * header
      * 
      * @param allow
-     *            Whether to allow Deflate encoding
+     *            Whether to allow compressed encoding
      */
-    public void setAllowDeflate(boolean allow) {
-        allowDeflate = allow;
+    public void setAllowCompression(boolean allow) {
+        allowCompression = allow;
     }
 
     /**
-     * Sets basic authentication. It may be preferable to use the
-     * {@link #setAuthenticator(HttpAuthenticator)} method since that provides
-     * more flexibility in the type of authentication supported.
-     * 
-     * @param user
-     *            User name
-     * @param password
-     *            Password
+     * Sets the client to use
+     * @param client Client
      */
-    public void setBasicAuthentication(String user, char[] password) {
-        this.setAuthenticator(new SimpleAuthenticator(user, password));
+    public void setClient(HttpClient client) {
+        this.client = client;
     }
-
+    
     /**
-     * Sets the authenticator to use
-     * @param authenticator Authenticator
+     * Sets the context to use
+     * @param context HTTP context
      */
-    public void setAuthenticator(HttpAuthenticator authenticator) {
-        this.authenticator = authenticator;
+    public void setContext(HttpClientContext context) {
+        this.context = context;
     }
     
     /**
@@ -209,15 +186,25 @@ public void setAuthenticator(HttpAuthenticator authenticator) {
      * @return HTTP Client or null
      */
     public HttpClient getClient() {
-        return this.client;
+        Context arqContext = ARQ.getContext();
+        if (arqContext.isDefined(Service.serviceContext)) {
+            @SuppressWarnings("unchecked")
+            Map<String, Context> context = (Map<String, Context>) arqContext.get(Service.serviceContext);
+            if (context.containsKey(serviceURL)) {
+                Context serviceContext = context.get(serviceURL);
+                if (serviceContext.isDefined(Service.queryClient)) return serviceContext.get(Service.queryClient);
+            }
+        }
+        return client;
     }
     
     /**
-     * Gets whether the HTTP client used should be shutdown
-     * @return True if the client should be shutdown, false otherwise
+     * Gets the HTTP context that is being used, or sets and returns a default
+     * @return the {@code HttpClientContext} in scope
      */
-    public boolean shouldShutdownClient() {
-        return this.requireClientShutdown;
+    public HttpClientContext getContext() {
+        if (context == null) context = new HttpClientContext();
+        return context;
     }
 
     /**
@@ -286,6 +273,9 @@ public int getReadTimeout() {
      * @throws QueryExceptionHTTP
      */
     public InputStream exec() throws QueryExceptionHTTP {
+        // Select the appropriate HttpClient to use
+        contextualizeCompressionSettings();
+        contextualizeTimeoutSettings();
         try {
             if (usesPOST())
                 return execPost();
@@ -298,6 +288,19 @@ public InputStream exec() throws QueryExceptionHTTP {
             throw jEx;
         }
     }
+    
+    private void contextualizeCompressionSettings() {
+        final RequestConfig.Builder builder = RequestConfig.copy(getContext().getRequestConfig());
+        builder.setContentCompressionEnabled(allowCompression);
+        context.setRequestConfig(builder.build());
+    }
+    
+    private void contextualizeTimeoutSettings() {
+        final RequestConfig.Builder builder = RequestConfig.copy(context.getRequestConfig());
+        if (connectTimeout > 0) builder.setConnectTimeout(connectTimeout);
+
+        context.setRequestConfig(builder.build());
+    }
 
     private InputStream execGet() throws QueryExceptionHTTP {
         URL target = null;
@@ -314,34 +317,10 @@ private InputStream execGet() throws QueryExceptionHTTP {
             throw new QueryExceptionHTTP(0, "Malformed URL: " + malEx);
         }
         log.trace("GET " + target.toExternalForm());
-
         try {
             try {
-                // Select the appropriate HttpClient to use
-                this.selectClient();
-                
-                // Always apply a 10 second timeout to obtaining a connection lease from HTTP Client
-                // This prevents a potential lock up
-                this.client.getParams().setLongParameter(ConnManagerPNames.TIMEOUT, TimeUnit.SECONDS.toMillis(10));
-                
-                // If user has specified time outs apply them now
-                if (this.connectTimeout > 0)
-                    this.client.getParams().setIntParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, this.connectTimeout);
-                if (this.readTimeout > 0)
-                    this.client.getParams().setIntParameter(CoreConnectionPNames.SO_TIMEOUT, this.readTimeout);
-                
-                // Enable compression support appropriately
-                HttpContext context = new BasicHttpContext();
-                if (allowGZip || allowDeflate) {
-                    // Apply auth early as the decompressing client we're about
-                    // to add will block this being applied later
-                    HttpOp.applyAuthentication((AbstractHttpClient) client, serviceURL, context, authenticator);
-                    client = new DecompressingHttpClient(client);
-                }
-                
                 // Get the actual response stream
-                TypedInputStream stream = HttpOp.execHttpGet(target.toString(), contentTypeResult, client, context,
-                        this.authenticator);
+                TypedInputStream stream = HttpOp.execHttpGet(target.toString(), contentTypeResult, client, getContext());
                 if (stream == null)
                     throw new QueryExceptionHTTP(404);
                 return execCommon(stream);
@@ -368,30 +347,8 @@ private InputStream execPost() throws QueryExceptionHTTP {
         ARQ.getHttpRequestLogger().trace(target.toExternalForm());
 
         try {
-            // Select the appropriate HttpClient to use
-            this.selectClient();
-                    
-            // Always apply a 10 second timeout to obtaining a connection lease from HTTP Client
-            // This prevents a potential lock up
-            this.client.getParams().setLongParameter(ConnManagerPNames.TIMEOUT, TimeUnit.SECONDS.toMillis(10));
-            
-            // If user has specified time outs apply them now
-            if (this.connectTimeout > 0)
-                this.client.getParams().setIntParameter(CoreConnectionPNames.CONNECTION_TIMEOUT, this.connectTimeout);
-            if (this.readTimeout > 0)
-                this.client.getParams().setIntParameter(CoreConnectionPNames.SO_TIMEOUT, this.readTimeout);
-            
-            // Enable compression support appropriately
-            HttpContext context = new BasicHttpContext();
-            if (allowGZip || allowDeflate) {
-                // Apply auth early as the decompressing client we're about
-                // to add will block this being applied later
-                HttpOp.applyAuthentication((AbstractHttpClient) client, serviceURL, context, authenticator);
-                this.client = new DecompressingHttpClient(client);
-            }
-
             // Get the actual response stream
-            TypedInputStream stream = HttpOp.execHttpPostFormStream(serviceURL, this, contentTypeResult, client, context, authenticator);
+            TypedInputStream stream = HttpOp.execHttpPostFormStream(serviceURL, this, contentTypeResult, client, getContext());
             if (stream == null)
                 throw new QueryExceptionHTTP(404);
             return execCommon(stream);
@@ -420,19 +377,6 @@ private QueryExceptionHTTP rewrap(HttpException httpEx) {
         	return new QueryExceptionHTTP("Unexpected error making the query", httpEx);
         }
     }
-    
-    private void selectClient() {
-        // May use configured default client where appropriate
-        this.client = HttpOp.getDefaultHttpClient();
-        if (this.client == null || (this.authenticator != null && !HttpOp.getUseDefaultClientWithAuthentication())) {
-            // If no configured default or authentication is in-use and the user has not configured
-            // to use authentication with the default client use a fresh SystemDefaultHttpClient instance
-            this.client = new SystemDefaultHttpClient();
-        } else {
-            // When using the configured default client we don't want to shut it down at the end of a request
-            this.requireClientShutdown = false;
-        }
-    }
 
     private InputStream execCommon(TypedInputStream stream) throws QueryExceptionHTTP {
         // Assume response code must be 200 if we got here
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/Params.java b/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/Params.java
index ab25b9ad09..dce789a3af 100644
--- a/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/Params.java
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/Params.java
@@ -18,9 +18,10 @@
 
 package org.apache.jena.sparql.engine.http;
 
+import static java.util.stream.Collectors.toList;
+
 import java.nio.charset.StandardCharsets ;
 import java.util.* ;
-
 import org.apache.http.NameValuePair ;
 import org.apache.http.client.utils.URLEncodedUtils ;
 
@@ -60,19 +61,14 @@ public void merge(Params other)
     /** Add a parameter.
      * @param name  Name of the parameter
      * @param value Value - May be null to indicate none - the name still goes.
+     * @return this Params for continued operation
      */
-    
-    public void addParam(String name, String value)
+    public Params addParam(String name, String value)
     {
         Pair p = new Pair(name, value) ;
         paramList.add(p) ;
-        List<String> x = params.get(name) ;
-        if ( x == null )
-        {
-            x = new ArrayList<>() ;
-            params.put(name, x) ;
-        }
-        x.add(value) ;
+        params.computeIfAbsent(name, n -> new ArrayList<>()).add(value);
+        return this;
     }
 
     /** Valueless parameter */
@@ -98,12 +94,7 @@ public List<String> getValues(String name)
     public void remove(String name)
     {
         // Absolute record
-        for ( Iterator<Pair> iter = paramList.iterator() ; iter.hasNext() ; )
-        {
-            Pair p = iter.next() ;
-            if ( p.getName().equals(name) )
-                iter.remove() ;
-        }
+        paramList.removeIf(p -> p.getName().equals(name));
         // Map
         params.remove(name) ;
     }
@@ -119,15 +110,7 @@ public List<Pair> pairs()
     /** Get the names of parameters - one ocurrence */ 
     public List<String> names()
     {
-        List<String> names = new ArrayList<>() ;
-        for (Pair pair : paramList)
-        {
-            String s = pair.getName() ;
-            if ( names.contains(s) )
-                continue ;
-            names.add(s) ;
-        }
-        return names ; 
+        return paramList.stream().map(Pair::getName).distinct().collect(toList()); 
     }
 
     /** Query string, without leading "?" */ 
@@ -145,19 +128,11 @@ static class MultiValueException extends RuntimeException
         MultiValueException(String msg) { super(msg) ; }
     }
         
-    public static class Pair implements NameValuePair
-    { 
-        String name ;
-        String value ;
-
-        Pair(String name, String value) { setName(name) ; setValue(value) ; }
+    public static class Pair extends org.apache.jena.atlas.lib.Pair<String, String> implements NameValuePair { 
+        public Pair(String name, String value) { super(name, value); }    
         @Override
-        public String getName()  { return name ;  }
+        public String getName()  { return getLeft() ;  }
         @Override
-        public String getValue() { return value ; }
-
-        void setName(String name)   { this.name = name ; }
-        void setValue(String value) { this.value = value ; }
-        
+        public String getValue() { return getRight() ; }     
     }
 }
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/QueryEngineHTTP.java b/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/QueryEngineHTTP.java
index b196f83139..417e32767c 100644
--- a/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/QueryEngineHTTP.java
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/QueryEngineHTTP.java
@@ -27,11 +27,10 @@
 import java.util.concurrent.TimeUnit ;
 
 import org.apache.http.client.HttpClient ;
+import org.apache.http.client.protocol.HttpClientContext;
 import org.apache.jena.atlas.RuntimeIOException;
 import org.apache.jena.atlas.io.IO ;
 import org.apache.jena.atlas.lib.Pair ;
-import org.apache.jena.atlas.web.auth.HttpAuthenticator ;
-import org.apache.jena.atlas.web.auth.SimpleAuthenticator ;
 import org.apache.jena.graph.Triple ;
 import org.apache.jena.query.* ;
 import org.apache.jena.rdf.model.Model ;
@@ -39,7 +38,6 @@
 import org.apache.jena.riot.RDFDataMgr ;
 import org.apache.jena.riot.RDFLanguages ;
 import org.apache.jena.riot.WebContent ;
-import org.apache.jena.riot.web.HttpOp ;
 import org.apache.jena.sparql.ARQException ;
 import org.apache.jena.sparql.core.Quad;
 import org.apache.jena.sparql.engine.ResultSetCheckCondition ;
@@ -72,7 +70,8 @@ public class QueryEngineHTTP implements QueryExecution {
     // Protocol
     private List<String> defaultGraphURIs = new ArrayList<>();
     private List<String> namedGraphURIs = new ArrayList<>();
-    private HttpAuthenticator authenticator;
+    private HttpClient client;
+    private HttpClientContext httpContext;
 
     private boolean closed = false;
 
@@ -83,8 +82,7 @@ public class QueryEngineHTTP implements QueryExecution {
     private TimeUnit readTimeoutUnit = TimeUnit.MILLISECONDS;
 
     // Compression Support
-    private boolean allowGZip = true;
-    private boolean allowDeflate = true;
+    private boolean allowCompression = true;
 
     // Content Types
     private String selectContentType    = defaultSelectHeader();
@@ -111,43 +109,39 @@ public class QueryEngineHTTP implements QueryExecution {
     // and will close when the engine is closed
     private InputStream retainedConnection = null;
 
-    private HttpClient retainedClient;
-
     public QueryEngineHTTP(String serviceURI, Query query) {
         this(serviceURI, query, query.toString());
     }
     
-    public QueryEngineHTTP(String serviceURI, Query query, HttpAuthenticator authenticator) {
-        this(serviceURI, query, query.toString(), authenticator);
+    public QueryEngineHTTP(String serviceURI, Query query, HttpClient client) {
+        this(serviceURI, query, query.toString(), client);
     }
 
     public QueryEngineHTTP(String serviceURI, String queryString) {
         this(serviceURI, null, queryString);
     }
     
-    public QueryEngineHTTP(String serviceURI, String queryString, HttpAuthenticator authenticator) {
-        this(serviceURI, null, queryString, authenticator);
+    public QueryEngineHTTP(String serviceURI, String queryString, HttpClient client) {
+        this(serviceURI, null, queryString, client);
     }
     
     private QueryEngineHTTP(String serviceURI, Query query, String queryString) {
         this(serviceURI, query, queryString, null);
     }
 
-    private QueryEngineHTTP(String serviceURI, Query query, String queryString, HttpAuthenticator authenticator) {
+    private QueryEngineHTTP(String serviceURI, Query query, String queryString, HttpClient client) {
         this.query = query;
         this.queryString = queryString;
         this.service = serviceURI;
-        // Copy the global context to freeze it.
-        this.context = new Context(ARQ.getContext());
+        this.context = ARQ.getContext().copy();
 
         // Apply service configuration if relevant
-        QueryEngineHTTP.applyServiceConfig(serviceURI, this);
+        applyServiceConfig(serviceURI, this);
         
-        // Don't want to overwrite credentials we may have picked up from
+        // Don't want to overwrite client config we may have picked up from
         // service context in the parent constructor if the specified
-        // authenticator is null
-        if (authenticator != null)
-            this.setAuthenticator(authenticator);
+        // client is null
+        if (client != null) setClient(client);
     }
 
     /**
@@ -178,20 +172,16 @@ private static void applyServiceConfig(String serviceURI, QueryEngineHTTP engine
                 log.debug("Endpoint URI {} has SERVICE Context: {} ", serviceURI, serviceContext);
 
             // Apply behavioral options
-            engine.setAllowGZip(serviceContext.isTrueOrUndef(Service.queryGzip));
-            engine.setAllowDeflate(serviceContext.isTrueOrUndef(Service.queryDeflate));
+            engine.setAllowCompression(serviceContext.isTrueOrUndef(Service.queryCompression));
             applyServiceTimeouts(engine, serviceContext);
 
-            // Apply authentication settings
-            String user = serviceContext.getAsString(Service.queryAuthUser);
-            String pwd = serviceContext.getAsString(Service.queryAuthPwd);
+            // Apply context-supplied client settings
+            HttpClient client = serviceContext.get(Service.queryClient);
 
-            if (user != null || pwd != null) {
-                user = user == null ? "" : user;
-                pwd = pwd == null ? "" : pwd;
+            if (client != null) {
                 if (log.isDebugEnabled())
-                    log.debug("Setting basic HTTP authentication for endpoint URI {} with username: {} ", serviceURI, user);
-                engine.setBasicAuthentication(user, pwd.toCharArray());
+                    log.debug("Using context-supplied HTTP client for endpoint URI {}", serviceURI);
+                engine.setClient(client);
             }
         }
     }
@@ -263,17 +253,10 @@ public void setNamedGraphURIs(List<String> namedGraphURIs) {
     }
 
     /**
-     * Sets whether the HTTP request will specify Accept-Encoding: gzip
-     */
-    public void setAllowGZip(boolean allowed) {
-        allowGZip = allowed;
-    }
-
-    /**
-     * Sets whether the HTTP requests will specify Accept-Encoding: deflate
+     * Sets whether the HTTP requests will permit compressed encoding
      */
-    public void setAllowDeflate(boolean allowed) {
-        allowDeflate = allowed;
+    public void setAllowCompression(boolean allowed) {
+        allowCompression = allowed;
     }
 
     public void addParam(String field, String value) {
@@ -303,44 +286,41 @@ public void addNamedGraph(String name) {
     }
 
     /**
-     * Gets whether an authentication mechanism has been provided.
-     * <p>
-     * Even if this returns false authentication may still be used if the
-     * default authenticator applies, this is controlled via the
-     * {@link HttpOp#setDefaultAuthenticator(HttpAuthenticator)} method
-     * </p>
+     * Sets the HTTP client to use, if none is set then the default
+     * client is used.
      * 
-     * @return True if an authenticator has been provided
+     * @param client
+     *            HTTP client
      */
-    public boolean isUsingBasicAuthentication() {
-        return this.authenticator != null;
+    public void setClient(HttpClient client) {
+        this.client = client;
     }
-
+    
     /**
-     * Set user and password for basic authentication. After the request is made
-     * (one of the exec calls), the application can overwrite the password array
-     * to remove details of the secret.
-     * <p>
-     * Note that it may be more flexible to
-     * </p>
+     * Get the HTTP client in use, if none is set then null.
      * 
-     * @param user
-     * @param password
+     * @return client HTTP client
      */
-    public void setBasicAuthentication(String user, char[] password) {
-        this.authenticator = new SimpleAuthenticator(user, password);
+    public HttpClient getClient() {
+        return client;
     }
-
+    
     /**
-     * Sets the HTTP authenticator to use, if none is set then the default
-     * authenticator is used. This may be configured via the
-     * {@link HttpOp#setDefaultAuthenticator(HttpAuthenticator)} method.
+     * Sets the HTTP context to use, if none is set then the default context is used.
      * 
-     * @param authenticator
-     *            HTTP authenticator
+     * @param context HTTP context
      */
-    public void setAuthenticator(HttpAuthenticator authenticator) {
-        this.authenticator = authenticator;
+    public void setHttpContext(HttpClientContext context) {
+        this.httpContext = context;
+    }
+    
+    /**
+     * Get the HTTP context in use, if none is set then null.
+     * 
+     * @return the {@code HttpClientContext} in scope
+     */
+    public HttpClientContext getHttpContext() {
+        return httpContext;
     }
 
     /** The Content-Type response header received (null before the remote operation is attempted). */
@@ -369,7 +349,6 @@ private ResultSet execResultSetInner() {
         }
 
         retainedConnection = in; // This will be closed on close()
-        retainedClient = httpQuery.shouldShutdownClient() ? httpQuery.getClient() : null;
 
         // Don't assume the endpoint actually gives back the
         // content type we asked for
@@ -596,24 +575,14 @@ public long getTimeout2() {
         return asMillis(connectTimeout, connectTimeoutUnit);
     }
 
-    /**
-     * Gets whether HTTP requests will indicate to the remote server that GZip
-     * encoding of responses is accepted
-     * 
-     * @return True if GZip encoding will be accepted
-     */
-    public boolean getAllowGZip() {
-        return allowGZip;
-    }
-
     /**
      * Gets whether HTTP requests will indicate to the remote server that
-     * Deflate encoding of responses is accepted
+     * compressed encoding of responses is accepted
      * 
-     * @return True if Deflate encoding will be accepted
+     * @return True if compressed encoding will be accepted
      */
-    public boolean getAllowDeflate() {
-        return allowDeflate;
+    public boolean getAllowCompression() {
+        return allowCompression;
     }
 
     private static long asMillis(long duration, TimeUnit timeUnit) {
@@ -637,24 +606,25 @@ private HttpQuery makeHttpQuery() {
             httpQuery.addParam( HttpParams.pNamedGraph, name );
         }
 
-        if (params != null)
-            httpQuery.merge(params);
-
-        if (allowGZip)
-            httpQuery.setAllowGZip(true);
+        if (params != null) httpQuery.merge(params);
 
-        if (allowDeflate)
-            httpQuery.setAllowDeflate(true);
-
-        httpQuery.setAuthenticator(this.authenticator);
-
-        // Apply timeouts
-        if (connectTimeout > 0) {
-            httpQuery.setConnectTimeout((int) connectTimeoutUnit.toMillis(connectTimeout));
-        }
-        if (readTimeout > 0) {
-            httpQuery.setReadTimeout((int) readTimeoutUnit.toMillis(readTimeout));
+        httpQuery.setAllowCompression(allowCompression);
+        
+        // check for service context overrides
+        if (context.isDefined(Service.serviceContext)) {
+            Map<String, Context> servicesContext = context.get(Service.serviceContext);
+            if (servicesContext.containsKey(service)) {
+                Context serviceContext = servicesContext.get(service);
+                if (serviceContext.isDefined(Service.queryClient)) client = serviceContext.get(Service.queryClient);
+            }
         }
+        httpQuery.setClient(client);
+        httpQuery.setContext(getHttpContext());
+        
+        // Apply timeouts
+        if (connectTimeout > 0) httpQuery.setConnectTimeout((int) connectTimeoutUnit.toMillis(connectTimeout));
+
+        if (readTimeout > 0) httpQuery.setReadTimeout((int) readTimeoutUnit.toMillis(readTimeout));
 
         return httpQuery;
     }
@@ -698,30 +668,9 @@ public void abort() {
         }
     }
 
-    @SuppressWarnings("deprecation")
     @Override
     public void close() {
         closed = true ;
-
-        // JENA-1063
-        // If we are going to shut down the HTTP client do this first as otherwise
-        // HTTP Client will by default try to re-use the connection and it will
-        // consume any outstanding response data in order to do this which can cause 
-        // the close() on the InputStream to hang for an extremely long time
-        // This also causes resources to continue to be consumed on the server regardless
-        // of the fact that the client has called our close() method and so clearly
-        // does not care about any remaining response
-        // i.e. if we don't do this we are badly behaved towards both the caller and 
-        // the remote server we're interacting with
-        if (retainedClient != null) {
-            try {
-                retainedClient.getConnectionManager().shutdown();
-            } catch (RuntimeException e) {
-                log.debug("Failed to shutdown HTTP client", e);
-            } finally {
-                retainedClient = null;
-            }
-        }
         
         if (retainedConnection != null) {
             try {
@@ -733,7 +682,6 @@ public void close() {
                 // warning to the logs
                 if (retainedConnection.read() != -1)
                     log.warn("HTTP response not fully consumed, if HTTP Client is reusing connections (its default behaviour) then it will consume the remaining response data which may take a long time and cause this application to become unresponsive");
-                
                 retainedConnection.close();
             } catch (RuntimeIOException e) {
                 // If we are closing early and the underlying stream is chunk encoded
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/Service.java b/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/Service.java
index 162aa0d6a0..ae3f1536e3 100644
--- a/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/Service.java
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/engine/http/Service.java
@@ -23,6 +23,7 @@
 import java.util.Map;
 import java.util.Set;
 
+import org.apache.http.client.HttpClient;
 import org.apache.jena.atlas.io.IO;
 import org.apache.jena.query.Query ;
 import org.apache.jena.query.QueryExecException ;
@@ -49,24 +50,14 @@ public class Service {
     public static final String base = "http://jena.hpl.hp.com/Service#";
 
     /**
-     * Use to set the HttpQuery.allowDeflate flag.
+     * Use to set the HttpQuery.allowCompression flag.
      */
-    public static final Symbol queryDeflate = SystemARQ.allocSymbol(base, "queryDeflate");
+    public static final Symbol queryCompression = SystemARQ.allocSymbol(base, "queryCompression");
 
     /**
-     * Use to set the HttpQuery.allowGZip flag.
+     * Use to set the HTTP client for a service.
      */
-    public static final Symbol queryGzip = SystemARQ.allocSymbol(base, "queryGzip");
-
-    /**
-     * Use to set the user id for basic auth.
-     */
-    public static final Symbol queryAuthUser = SystemARQ.allocSymbol(base, "queryAuthUser");
-
-    /**
-     * Use to set the user password for basic auth.
-     */
-    public static final Symbol queryAuthPwd = SystemARQ.allocSymbol(base, "queryAuthPwd");
+    public static final Symbol queryClient = SystemARQ.allocSymbol(base, "queryClient");
 
     /**
      * Use this Symbol to allow passing additional service context variables
@@ -231,17 +222,10 @@ private static HttpQuery configureQuery(String uri, Context parentContext, Query
         // configure the query object.
         httpQuery.merge(QueryEngineHTTP.getServiceParams(uri, context));
         httpQuery.addParam(HttpParams.pQuery, query.toString());
-        httpQuery.setAllowGZip(context.isTrueOrUndef(queryGzip));
-        httpQuery.setAllowDeflate(context.isTrueOrUndef(queryDeflate));
+        httpQuery.setAllowCompression(context.isTrueOrUndef(queryCompression));
 
-        String user = context.getAsString(queryAuthUser);
-        String pwd = context.getAsString(queryAuthPwd);
-
-        if (user != null || pwd != null) {
-            user = user == null ? "" : user;
-            pwd = pwd == null ? "" : pwd;
-            httpQuery.setBasicAuthentication(user, pwd.toCharArray());
-        }
+        HttpClient client = context.get(queryClient);
+        if (client != null) httpQuery.setClient(client);    
 
         setAnyTimeouts(httpQuery, context);
 
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/modify/UpdateProcessRemote.java b/jena-arq/src/main/java/org/apache/jena/sparql/modify/UpdateProcessRemote.java
index e05f24513e..506de60fee 100644
--- a/jena-arq/src/main/java/org/apache/jena/sparql/modify/UpdateProcessRemote.java
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/modify/UpdateProcessRemote.java
@@ -18,7 +18,7 @@
 
 package org.apache.jena.sparql.modify;
 
-import org.apache.jena.atlas.web.auth.HttpAuthenticator;
+import org.apache.http.client.HttpClient;
 import org.apache.jena.riot.WebContent ;
 import org.apache.jena.riot.web.HttpOp ;
 import org.apache.jena.sparql.ARQException ;
@@ -46,16 +46,15 @@ public UpdateProcessRemote(UpdateRequest request, String endpoint, Context conte
      * @param request Update request
      * @param endpoint Update endpoint
      * @param context Context
-     * @param authenticator HTTP Authenticator
+     * @param client HTTP client
      */
-    public UpdateProcessRemote(UpdateRequest request, String endpoint, Context context, HttpAuthenticator authenticator)
+    public UpdateProcessRemote(UpdateRequest request, String endpoint, Context context, HttpClient client)
     {
         this(request, endpoint, context);
-        // Don't want to overwrite credentials we may have picked up from
+        // Don't want to overwrite config we may have picked up from
         // service context in the parent constructor if the specified
-        // authenticator is null
-        if (authenticator != null)
-            this.setAuthenticator(authenticator);
+        // client is null
+        if (client != null) this.setClient(client);
     }
 
     @Override
@@ -76,7 +75,7 @@ public void execute()
         
         // Execution
         String reqStr = this.getUpdateRequest().toString() ;
-        HttpOp.execHttpPost(endpoint, WebContent.contentTypeSPARQLUpdate, reqStr, null, getHttpContext(), getAuthenticator()) ;
+        HttpOp.execHttpPost(endpoint, WebContent.contentTypeSPARQLUpdate, reqStr, getClient(), getHttpContext()) ;
     }
 }
 
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/modify/UpdateProcessRemoteBase.java b/jena-arq/src/main/java/org/apache/jena/sparql/modify/UpdateProcessRemoteBase.java
index a58117996a..8e18cd1ede 100644
--- a/jena-arq/src/main/java/org/apache/jena/sparql/modify/UpdateProcessRemoteBase.java
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/modify/UpdateProcessRemoteBase.java
@@ -22,9 +22,8 @@
 import java.util.List ;
 import java.util.Map ;
 
+import org.apache.http.client.HttpClient;
 import org.apache.http.protocol.HttpContext ;
-import org.apache.jena.atlas.web.auth.HttpAuthenticator ;
-import org.apache.jena.atlas.web.auth.SimpleAuthenticator ;
 import org.apache.jena.riot.web.HttpOp ;
 import org.apache.jena.sparql.core.DatasetGraph ;
 import org.apache.jena.sparql.engine.http.HttpParams ;
@@ -55,7 +54,7 @@ public abstract class UpdateProcessRemoteBase implements UpdateProcessor {
     private final UpdateRequest request;
     private final String endpoint;
     private final Context context;
-    private HttpAuthenticator authenticator;
+    private HttpClient client;
     private Params params;
 
     protected List<String> defaultGraphURIs = new ArrayList<>();
@@ -106,17 +105,13 @@ private static void applyServiceConfig(String serviceURI, UpdateProcessRemoteBas
             if (log.isDebugEnabled())
                 log.debug("Endpoint URI {} has SERVICE Context: {} ", serviceURI, serviceContext);
 
-            // Apply authentication settings
-            String user = serviceContext.getAsString(Service.queryAuthUser);
-            String pwd = serviceContext.getAsString(Service.queryAuthPwd);
+            // Apply client settings
+            HttpClient client = serviceContext.get(Service.queryClient);
 
-            if (user != null || pwd != null) {
-                user = user == null ? "" : user;
-                pwd = pwd == null ? "" : pwd;
+            if (client != null) {
                 if (log.isDebugEnabled())
-                    log.debug("Setting basic HTTP authentication for endpoint URI {} with username: {} ", serviceURI, user);
-
-                engine.setAuthentication(user, pwd.toCharArray());
+                    log.debug("Using context-supplied client for endpoint URI {}", serviceURI);
+                engine.setClient(client);
             }
         }
     }
@@ -263,56 +258,31 @@ public Context getContext() {
     }
 
     /**
-     * Sets authentication credentials for remote updates
+     * Sets the client to use
      * <p>
-     * May be better to use {@link #setAuthenticator(HttpAuthenticator)} as that
-     * allows for more complex authentication to be used
+     * Note that you can globally set an client via
+     * {@link HttpOp#setDefaultHttpClient(HttpClient)} to avoid the
+     * need to set client on a per-request basis
      * </p>
      * 
-     * @param username
-     *            User name
-     * @param password
-     *            Password
+     * @param client
+     *            HTTP client
      */
-    public void setAuthentication(String username, char[] password) {
-        this.setAuthenticator(new SimpleAuthenticator(username, password));
+    public void setClient(HttpClient client) {
+        this.client = client;
     }
 
     /**
-     * Sets the authenticator to use
+     * Gets the client that has been set (if any)
      * <p>
-     * Note that you can globally set an authenticator via
-     * {@link HttpOp#setDefaultAuthenticator(HttpAuthenticator)} to avoid the
-     * need to set authentication on a per-request basis
-     * </p>
-     * 
-     * @param authenticator
-     *            HTTP Authenticator
-     */
-    public void setAuthenticator(HttpAuthenticator authenticator) {
-        this.authenticator = authenticator;
-    }
-
-    /**
-     * Gets the authenticator that has been set (if any)
-     * <p>
-     * If no authenticator is used then the default authenticator will be used,
+     * If no client is used then the default client will be used,
      * this can be configured via the
-     * {@link HttpOp#setDefaultAuthenticator(HttpAuthenticator)} method.
+     * {@link HttpOp#setDefaultHttpClient(HttpClient)} method.
      * </p>
      * 
-     * @return HTTP Authenticator if set, null otherwise
-     */
-    public HttpAuthenticator getAuthenticator() {
-        return this.authenticator;
-    }
-
-    /**
-     * Gets whether any authenticator has been set
-     * 
-     * @return True if an authenticator has been set, false otherwise
+     * @return HTTP client if set, null otherwise
      */
-    public boolean isUsingAuthentication() {
-        return this.authenticator != null;
+    public HttpClient getClient() {
+        return this.client;
     }
 }
\ No newline at end of file
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/modify/UpdateProcessRemoteForm.java b/jena-arq/src/main/java/org/apache/jena/sparql/modify/UpdateProcessRemoteForm.java
index 77fd27f6cc..de3a67d544 100644
--- a/jena-arq/src/main/java/org/apache/jena/sparql/modify/UpdateProcessRemoteForm.java
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/modify/UpdateProcessRemoteForm.java
@@ -18,8 +18,9 @@
 
 package org.apache.jena.sparql.modify;
 
-import org.apache.jena.atlas.web.auth.HttpAuthenticator;
-import org.apache.jena.riot.web.HttpOp;
+import static org.apache.jena.riot.web.HttpOp.execHttpPostForm;
+
+import org.apache.http.client.HttpClient;
 import org.apache.jena.riot.web.HttpResponseLib;
 import org.apache.jena.sparql.ARQException ;
 import org.apache.jena.sparql.engine.http.HttpParams ;
@@ -59,16 +60,15 @@ public UpdateProcessRemoteForm(UpdateRequest request, String endpoint, Context c
      *            Update endpoint
      * @param context
      *            Context
-     * @param authenticator
-     *            HTTP Authenticator
+     * @param client
+     *            HTTP Client
      */
-    public UpdateProcessRemoteForm(UpdateRequest request, String endpoint, Context context, HttpAuthenticator authenticator) {
+    public UpdateProcessRemoteForm(UpdateRequest request, String endpoint, Context context, HttpClient client) {
         this(request, endpoint, context);
-        // Don't want to overwrite credentials we may have picked up from
+        // Don't want to overwrite config we may have picked up from
         // service context in the parent constructor if the specified
-        // authenticator is null
-        if (authenticator != null)
-            this.setAuthenticator(authenticator);
+        // client is null
+        if (client != null) this.setClient(client);
     }
 
     @Override
@@ -83,7 +83,6 @@ public void execute() {
         String reqStr = this.getUpdateRequest().toString();
         Params ps = new Params(this.getParams());
         ps.addParam(HttpParams.pUpdate, reqStr);
-        HttpOp.execHttpPostForm(this.getEndpoint(), ps, null, HttpResponseLib.nullResponse, null, getHttpContext(),
-                getAuthenticator());
+        execHttpPostForm(this.getEndpoint(), ps, null, HttpResponseLib.nullResponse, getClient(), getHttpContext());
     }
 }
diff --git a/jena-arq/src/main/java/org/apache/jena/sparql/util/Context.java b/jena-arq/src/main/java/org/apache/jena/sparql/util/Context.java
index 6cb0e305d2..cfaae9cee5 100644
--- a/jena-arq/src/main/java/org/apache/jena/sparql/util/Context.java
+++ b/jena-arq/src/main/java/org/apache/jena/sparql/util/Context.java
@@ -65,10 +65,11 @@ public Context copy() {
     }
 
     // -- basic operations
-
+    
     /** Get the object value of a property or null */
-    public Object get(Symbol property) {
-        return context.get(property) ;
+    @SuppressWarnings("unchecked")
+    public <T> T get(Symbol property) {
+        return (T) context.get(property) ;
     }
 
     /**
diff --git a/jena-arq/src/main/java/org/apache/jena/update/UpdateExecutionFactory.java b/jena-arq/src/main/java/org/apache/jena/update/UpdateExecutionFactory.java
index 38da4974fe..a30ac4b1ce 100644
--- a/jena-arq/src/main/java/org/apache/jena/update/UpdateExecutionFactory.java
+++ b/jena-arq/src/main/java/org/apache/jena/update/UpdateExecutionFactory.java
@@ -18,7 +18,7 @@
 
 package org.apache.jena.update;
 
-import org.apache.jena.atlas.web.auth.HttpAuthenticator ;
+import org.apache.http.client.HttpClient;
 import org.apache.jena.query.ARQ ;
 import org.apache.jena.query.Dataset ;
 import org.apache.jena.query.QuerySolution ;
@@ -290,12 +290,12 @@ public static UpdateProcessor createRemote(Update update, String remoteEndpoint)
     /** Create an UpdateProcessor that sends the update to a remote SPARQL Update service.
      * @param update Updates
      * @param remoteEndpoint Endpoint URL
-     * @param authenticator HTTP Authenticator
+     * @param client HTTP client
      * @return Remote Update processor
      */
-    public static UpdateProcessor createRemote(Update update, String remoteEndpoint, HttpAuthenticator authenticator)
+    public static UpdateProcessor createRemote(Update update, String remoteEndpoint, HttpClient client)
     {
-        return createRemote(new UpdateRequest(update), remoteEndpoint, null, authenticator) ;
+        return createRemote(new UpdateRequest(update), remoteEndpoint, null, client) ;
     }
     
     /** Create an UpdateProcessor that sends the update to a remote SPARQL Update service.
@@ -313,12 +313,12 @@ public static UpdateProcessor createRemote(Update update, String remoteEndpoint,
      * @param update Updates
      * @param remoteEndpoint Endpoint URL
      * @param context Context
-     * @param authenticator HTTP Authenticator
+     * @param client HTTP client
      * @return Remote Update processor
      */
-    public static UpdateProcessor createRemote(Update update, String remoteEndpoint, Context context, HttpAuthenticator authenticator)
+    public static UpdateProcessor createRemote(Update update, String remoteEndpoint, Context context, HttpClient client)
     {
-        return createRemote(new UpdateRequest(update), remoteEndpoint, context, authenticator) ;
+        return createRemote(new UpdateRequest(update), remoteEndpoint, context, client) ;
     }
         
     /** Create an UpdateProcessor that sends the update request to a remote SPARQL Update service.
@@ -334,12 +334,12 @@ public static UpdateProcessor createRemote(UpdateRequest updateRequest, String r
     /** Create an UpdateProcessor that sends the update request to a remote SPARQL Update service.
      * @param updateRequest Updates
      * @param remoteEndpoint Endpoint URL
-     * @param authenticator HTTP Authenticator
+     * @param client HTTP client
      * @return Remote Update processor
      */
-    public static UpdateProcessor createRemote(UpdateRequest updateRequest, String remoteEndpoint, HttpAuthenticator authenticator)
+    public static UpdateProcessor createRemote(UpdateRequest updateRequest, String remoteEndpoint, HttpClient client)
     {
-        return createRemote(updateRequest, remoteEndpoint, null, authenticator) ;
+        return createRemote(updateRequest, remoteEndpoint, null, client) ;
     }
 
     /** Create an UpdateProcessor that sends the update request to a remote SPARQL Update service.
@@ -357,12 +357,12 @@ public static UpdateProcessor createRemote(UpdateRequest updateRequest, String r
      * @param updateRequest Updates
      * @param remoteEndpoint Endpoint URL
      * @param context Context
-     * @param authenticator HTTP Authenticator
+     * @param client HTTP client
      * @return Remote Update processor
      */
-    public static UpdateProcessor createRemote(UpdateRequest updateRequest, String remoteEndpoint, Context context, HttpAuthenticator authenticator)
+    public static UpdateProcessor createRemote(UpdateRequest updateRequest, String remoteEndpoint, Context context, HttpClient client)
     {
-        return new UpdateProcessRemote(updateRequest, remoteEndpoint, context, authenticator) ;
+        return new UpdateProcessRemote(updateRequest, remoteEndpoint, context, client) ;
     }
     
     /** Create an UpdateProcessor that sends the update request to a remote SPARQL Update service using an HTML form
@@ -378,12 +378,12 @@ public static UpdateProcessor createRemoteForm(Update update, String remoteEndpo
     /** Create an UpdateProcessor that sends the update request to a remote SPARQL Update service using an HTML form
      * @param update Updates
      * @param remoteEndpoint Endpoint URL
-     * @param authenticator HTTP Authenticator
+     * @param client HTTP client
      * @return Remote Update processor
      */
-    public static UpdateProcessor createRemoteForm(Update update, String remoteEndpoint, HttpAuthenticator authenticator)
+    public static UpdateProcessor createRemoteForm(Update update, String remoteEndpoint, HttpClient client)
     {
-        return createRemoteForm(update, remoteEndpoint, null, null) ;
+        return createRemoteForm(update, remoteEndpoint, null, client) ;
     }
     
     /** Create an UpdateProcessor that sends the update request to a remote SPARQL Update service using an HTML form
@@ -394,19 +394,19 @@ public static UpdateProcessor createRemoteForm(Update update, String remoteEndpo
      */
     public static UpdateProcessor createRemoteForm(Update update, String remoteEndpoint, Context context)
     {
-        return createRemoteForm(new UpdateRequest(update), remoteEndpoint, null, null) ;
+        return createRemoteForm(new UpdateRequest(update), remoteEndpoint, context, null) ;
     }
     
     /** Create an UpdateProcessor that sends the update request to a remote SPARQL Update service using an HTML form
      * @param update Updates
      * @param remoteEndpoint Endpoint URL
      * @param context Context
-     * @param authenticator HTTP Authenticator
+     * @param client HTTP client
      * @return Remote Update processor
      */
-    public static UpdateProcessor createRemoteForm(Update update, String remoteEndpoint, Context context, HttpAuthenticator authenticator)
+    public static UpdateProcessor createRemoteForm(Update update, String remoteEndpoint, Context context, HttpClient client)
     {
-        return createRemoteForm(new UpdateRequest(update), remoteEndpoint, null, authenticator) ;
+        return createRemoteForm(new UpdateRequest(update), remoteEndpoint, null, client) ;
     }
     
     /** Create an UpdateProcessor that sends the update request to a remote SPARQL Update service using an HTML form
@@ -422,12 +422,12 @@ public static UpdateProcessor createRemoteForm(UpdateRequest updateRequest, Stri
     /** Create an UpdateProcessor that sends the update request to a remote SPARQL Update service using an HTML form
      * @param updateRequest Updates
      * @param remoteEndpoint Endpoint URL
-     * @param authenticator HTTP Authenticator
+     * @param client HTTP client
      * @return Remote Update processor
      */
-    public static UpdateProcessor createRemoteForm(UpdateRequest updateRequest, String remoteEndpoint, HttpAuthenticator authenticator)
+    public static UpdateProcessor createRemoteForm(UpdateRequest updateRequest, String remoteEndpoint, HttpClient client)
     {
-        return createRemoteForm(updateRequest, remoteEndpoint, null, authenticator) ;
+        return createRemoteForm(updateRequest, remoteEndpoint, null, client) ;
     }
     
     /** Create an UpdateProcessor that sends the update request to a remote SPARQL Update service using an HTML form
@@ -445,11 +445,11 @@ public static UpdateProcessor createRemoteForm(UpdateRequest updateRequest, Stri
      * @param updateRequest Updates
      * @param remoteEndpoint Endpoint URL
      * @param context Context
-     * @param authenticator HTTP Authenticator
+     * @param client HTTP client
      * @return Remote Update processor
      */
-    public static UpdateProcessor createRemoteForm(UpdateRequest updateRequest, String remoteEndpoint, Context context, HttpAuthenticator authenticator)
+    public static UpdateProcessor createRemoteForm(UpdateRequest updateRequest, String remoteEndpoint, Context context, HttpClient client)
     {
-        return new UpdateProcessRemoteForm(updateRequest, remoteEndpoint, context, authenticator) ;
+        return new UpdateProcessRemoteForm(updateRequest, remoteEndpoint, context, client) ;
     }
 }
diff --git a/jena-arq/src/main/java/org/apache/jena/web/DatasetGraphAccessorHTTP.java b/jena-arq/src/main/java/org/apache/jena/web/DatasetGraphAccessorHTTP.java
index 80f1232959..32afa09bfb 100644
--- a/jena-arq/src/main/java/org/apache/jena/web/DatasetGraphAccessorHTTP.java
+++ b/jena-arq/src/main/java/org/apache/jena/web/DatasetGraphAccessorHTTP.java
@@ -21,14 +21,11 @@
 import java.io.OutputStream ;
 
 import org.apache.http.HttpEntity ;
-import org.apache.http.client.methods.HttpHead ;
-import org.apache.http.client.methods.HttpUriRequest ;
+import org.apache.http.client.HttpClient;
 import org.apache.http.entity.ContentProducer ;
 import org.apache.http.entity.EntityTemplate ;
 import org.apache.jena.atlas.lib.IRILib ;
 import org.apache.jena.atlas.web.HttpException ;
-import org.apache.jena.atlas.web.auth.HttpAuthenticator ;
-import org.apache.jena.atlas.web.auth.SimpleAuthenticator ;
 import org.apache.jena.graph.Graph ;
 import org.apache.jena.graph.Node ;
 import org.apache.jena.riot.RDFDataMgr ;
@@ -49,7 +46,7 @@ public class DatasetGraphAccessorHTTP implements DatasetGraphAccessor {
     private static final RDFFormat           defaultSendLang   = RDFFormat.RDFXML_PLAIN ;
 
     private final String                     remote ;
-    private HttpAuthenticator                authenticator ;
+    private HttpClient                client ;
 
     private RDFFormat                        formatPutPost     = defaultSendLang ;
 
@@ -78,7 +75,7 @@ public class DatasetGraphAccessorHTTP implements DatasetGraphAccessor {
      *            Remote URL
      */
     public DatasetGraphAccessorHTTP(String remote) {
-        this.remote = remote ;
+        this(remote, HttpOp.getDefaultHttpClient());
     }
 
     /**
@@ -86,34 +83,21 @@ public DatasetGraphAccessorHTTP(String remote) {
      * 
      * @param remote
      *            Remote URL
-     * @param authenticator
-     *            HTTP Authenticator
+     * @param client
+     *            HTTP Client
      */
-    public DatasetGraphAccessorHTTP(String remote, HttpAuthenticator authenticator) {
-        this(remote) ;
-        this.setAuthenticator(authenticator) ;
-    }
-
-    /**
-     * Sets authentication credentials for the remote URL
-     * 
-     * @param username
-     *            User name
-     * @param password
-     *            Password
-     */
-    public void setAuthentication(String username, char[] password) {
-        this.setAuthenticator(new SimpleAuthenticator(username, password)) ;
+    public DatasetGraphAccessorHTTP(String remote, HttpClient client) {
+        this.remote = remote ;
+        this.setClient(client) ;
     }
 
     /**
-     * Sets an authenticator to use for authentication to the remote URL
+     * Sets an HTTP client for use to this dataset
      * 
-     * @param authenticator
-     *            Authenticator
+     * @param client Client
      */
-    public void setAuthenticator(HttpAuthenticator authenticator) {
-        this.authenticator = authenticator ;
+    public void setClient(HttpClient client) {
+        this.client = client ;
     }
 
     @Override
@@ -129,7 +113,7 @@ public Graph httpGet(Node graphName) {
     protected Graph doGet(String url) {
         HttpCaptureResponse<Graph> graph = HttpResponseLib.graphHandler() ;
         try {
-            HttpOp.execHttpGet(url, graphAcceptHeader, graph, this.authenticator) ;
+            HttpOp.execHttpGet(url, graphAcceptHeader, graph, client, null) ;
         } catch (HttpException ex) {
             if ( ex.getResponseCode() == HttpSC.NOT_FOUND_404 )
                 return null ;
@@ -149,9 +133,8 @@ public boolean httpHead(Node graphName) {
     }
 
     protected boolean doHead(String url) {
-        HttpUriRequest httpHead = new HttpHead(url) ;
         try {
-            HttpOp.execHttpHead(url, WebContent.defaultGraphAcceptHeader, noResponse, null, null, this.authenticator) ;
+            HttpOp.execHttpHead(url, WebContent.defaultGraphAcceptHeader, noResponse, client, null) ;
             return true ;
         } catch (HttpException ex) {
             if ( ex.getResponseCode() == HttpSC.NOT_FOUND_404 )
@@ -172,7 +155,7 @@ public void httpPut(Node graphName, Graph data) {
 
     protected void doPut(String url, Graph data) {
         HttpEntity entity = graphToHttpEntity(data) ;
-        HttpOp.execHttpPut(url, entity, null, null, this.authenticator) ;
+        HttpOp.execHttpPut(url, entity, client, null) ;
     }
 
     @Override
@@ -187,7 +170,7 @@ public void httpDelete(Node graphName) {
 
     protected void doDelete(String url) {
         try {
-            HttpOp.execHttpDelete(url, noResponse, null, null, this.authenticator) ;
+            HttpOp.execHttpDelete(url, noResponse, client, null) ;
         } catch (HttpException ex) {
             if ( ex.getResponseCode() == HttpSC.NOT_FOUND_404 )
                 return ;
@@ -206,7 +189,7 @@ public void httpPost(Node graphName, Graph data) {
 
     protected void doPost(String url, Graph data) {
         HttpEntity entity = graphToHttpEntity(data) ;
-        HttpOp.execHttpPost(url, entity, null, null, this.authenticator) ;
+        HttpOp.execHttpPost(url, entity, client, null) ;
     }
 
     @Override
diff --git a/jena-arq/src/test/java/org/apache/jena/sparql/engine/http/TestService.java b/jena-arq/src/test/java/org/apache/jena/sparql/engine/http/TestService.java
index 8bd9588c96..9a10fd42ca 100644
--- a/jena-arq/src/test/java/org/apache/jena/sparql/engine/http/TestService.java
+++ b/jena-arq/src/test/java/org/apache/jena/sparql/engine/http/TestService.java
@@ -22,7 +22,9 @@
 import java.util.HashMap ;
 import java.util.Map ;
 
+import org.apache.http.client.HttpClient;
 import org.apache.http.conn.ConnectTimeoutException ;
+import org.apache.http.impl.client.HttpClients;
 import org.apache.jena.graph.Node ;
 import org.apache.jena.graph.NodeFactory ;
 import org.apache.jena.graph.Triple ;
@@ -152,9 +154,8 @@ public void query_service_context_application_01() {
         // Check that no settings were changed
         Assert.assertEquals(-1, engine.getTimeout1());
         Assert.assertEquals(-1, engine.getTimeout2());
-        Assert.assertTrue(engine.getAllowGZip());
-        Assert.assertTrue(engine.getAllowDeflate());
-        Assert.assertFalse(engine.isUsingBasicAuthentication());
+        Assert.assertTrue(engine.getAllowCompression());
+        Assert.assertNull(engine.getClient());
     }
 
     @SuppressWarnings("unchecked")
@@ -172,8 +173,8 @@ public void query_service_context_application_02() {
         }
         Context serviceContext = serviceContextMap.get(SERVICE);
         try {
-            serviceContext.put(Service.queryAuthUser, "user");
-            serviceContext.put(Service.queryAuthPwd, "password");
+            HttpClient testClient = HttpClients.custom().build();
+            serviceContext.put(Service.queryClient, testClient);
 
             Query q = QueryFactory.create("ASK { }");
             QueryEngineHTTP engine = QueryExecutionFactory.createServiceRequest(SERVICE, q);
@@ -182,13 +183,11 @@ public void query_service_context_application_02() {
             // Check that no settings were changed
             Assert.assertEquals(-1, engine.getTimeout1());
             Assert.assertEquals(-1, engine.getTimeout2());
-            Assert.assertTrue(engine.getAllowGZip());
-            Assert.assertTrue(engine.getAllowDeflate());
-            Assert.assertTrue(engine.isUsingBasicAuthentication());
+            Assert.assertTrue(engine.getAllowCompression());
+            Assert.assertEquals(testClient, engine.getClient());
 
         } finally {
-            serviceContext.remove(Service.queryAuthUser);
-            serviceContext.remove(Service.queryAuthPwd);
+            serviceContext.remove(Service.queryClient);
         }
     }
 
@@ -215,9 +214,8 @@ public void query_service_context_application_03() {
             // Check that no settings were changed
             Assert.assertEquals(-1, engine.getTimeout1());
             Assert.assertEquals(10, engine.getTimeout2());
-            Assert.assertTrue(engine.getAllowGZip());
-            Assert.assertTrue(engine.getAllowDeflate());
-            Assert.assertFalse(engine.isUsingBasicAuthentication());
+            Assert.assertTrue(engine.getAllowCompression());
+            Assert.assertNull(engine.getClient());
         } finally {
             serviceContext.remove(Service.queryTimeout);
         }
@@ -246,9 +244,8 @@ public void query_service_context_application_04() {
             // Check that no settings were changed
             Assert.assertEquals(20, engine.getTimeout1());
             Assert.assertEquals(10, engine.getTimeout2());
-            Assert.assertTrue(engine.getAllowGZip());
-            Assert.assertTrue(engine.getAllowDeflate());
-            Assert.assertFalse(engine.isUsingBasicAuthentication());
+            Assert.assertTrue(engine.getAllowCompression());
+            Assert.assertNull(engine.getClient());
         } finally {
             serviceContext.remove(Service.queryTimeout);
         }
@@ -268,8 +265,7 @@ public void query_service_context_application_05() {
         }
         Context serviceContext = serviceContextMap.get(SERVICE);
         try {
-            serviceContext.put(Service.queryGzip, false);
-            serviceContext.put(Service.queryDeflate, false);
+            serviceContext.put(Service.queryCompression, false);
 
             Query q = QueryFactory.create("ASK { }");
             QueryEngineHTTP engine = QueryExecutionFactory.createServiceRequest(SERVICE, q);
@@ -278,12 +274,10 @@ public void query_service_context_application_05() {
             // Check that no settings were changed
             Assert.assertEquals(-1, engine.getTimeout1());
             Assert.assertEquals(-1, engine.getTimeout2());
-            Assert.assertFalse(engine.getAllowGZip());
-            Assert.assertFalse(engine.getAllowDeflate());
-            Assert.assertFalse(engine.isUsingBasicAuthentication());
+            Assert.assertFalse(engine.getAllowCompression());
+            Assert.assertNull(engine.getClient());
         } finally {
-            serviceContext.remove(Service.queryGzip);
-            serviceContext.remove(Service.queryDeflate);
+            serviceContext.remove(Service.queryCompression);
         }
     }
 
@@ -301,7 +295,7 @@ public void update_service_context_application_01() {
         Assert.assertNotNull(engine);
 
         // Check that no settings were changed
-        Assert.assertFalse(engine.isUsingAuthentication());
+        Assert.assertNull(engine.getClient());
     }
 
     @SuppressWarnings("unchecked")
@@ -318,19 +312,18 @@ public void update_service_context_application_02() {
         }
         Context serviceContext = serviceContextMap.get(SERVICE);
         try {
-            serviceContext.put(Service.queryAuthUser, "user");
-            serviceContext.put(Service.queryAuthPwd, "password");
+            HttpClient testClient = HttpClients.custom().build();
+            serviceContext.put(Service.queryClient, testClient);
 
             UpdateRequest updates = UpdateFactory.create("CREATE GRAPH <http://example>");
             UpdateProcessRemoteBase engine = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(updates, SERVICE);
             Assert.assertNotNull(engine);
 
-            // Check that auth settings were changed
-            Assert.assertTrue(engine.isUsingAuthentication());
+            // Check that client settings were changed
+            Assert.assertEquals(testClient, engine.getClient());
 
         } finally {
-            serviceContext.remove(Service.queryAuthUser);
-            serviceContext.remove(Service.queryAuthPwd);
+            serviceContext.remove(Service.queryClient);
         }
     }
 }
diff --git a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/ServerCtl.java b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/ServerCtl.java
new file mode 100644
index 0000000000..da957a4c73
--- /dev/null
+++ b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/ServerCtl.java
@@ -0,0 +1,108 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.apache.jena.fuseki;
+
+import org.apache.http.client.HttpClient ;
+import org.apache.http.impl.client.CloseableHttpClient ;
+import org.apache.jena.atlas.io.IO ;
+import org.apache.jena.riot.web.HttpOp ;
+
+public class ServerCtl {
+    static { Fuseki.init(); }
+    
+    /* Put this in each test class using the Fuseki server:
+    @BeforeClass public static void ctlBeforeClass() { ServerCtl.ctlBeforeClass(); }
+    @AfterClass  public static void ctlAfterClass()  { ServerCtl.ctlAfterClass(); }
+    @Before      public void ctlBeforeTest()         { ServerCtl.ctlBeforeTest(); }
+    @After       public void ctlAfterTest()          { ServerCtl.ctlAfterTest(); } 
+    */
+    
+    static HttpClient defaultHttpClient = HttpOp.getDefaultHttpClient();
+
+    // 2 choices: server over whole test suite or server over each test class.
+    // Preferred "true" - stop-start server between test classes.
+    // Note: it is import to cleanly close a PoolingHttpClient across server restarts
+    // otherwise the pooled connections remian for the old server. 
+    
+    static final boolean SERVER_PER_CLASS = true ;  
+    public static void ctlBeforeTestSuite() {
+        if ( ! SERVER_PER_CLASS ) {
+            setPoolingHttpClient() ;
+            ServerTest.allocServer();
+        }
+    }
+    
+    public static void ctlAfterTestSuite()  {
+        if ( ! SERVER_PER_CLASS ) {
+            ServerTest.freeServer();
+            resetDefaultHttpClient() ;
+        }
+    }
+    
+    /**
+     * Setup for the tests by allocating a Fuseki instance to work with
+     */
+    public static void ctlBeforeClass() {
+        if ( SERVER_PER_CLASS ) {
+            setPoolingHttpClient() ;
+            ServerTest.allocServer();
+        }
+    }
+    
+    /**
+     * Clean up after tests by de-allocating the Fuseki instance
+     */
+    public static void ctlAfterClass() {
+        if ( SERVER_PER_CLASS ) {
+            ServerTest.freeServer();
+            resetDefaultHttpClient() ;
+        }
+    }
+
+    /**
+     * Placeholder.
+     */
+    public static void ctlBeforeTest() {
+    }
+
+    /**
+     * Clean up after each test by resetting the Fuseki dataset
+     */
+    public static void ctlAfterTest() {
+        ServerTest.resetServer();
+    }
+
+    /** Set a PoolingHttpClient */
+    private static void setPoolingHttpClient() {
+        setHttpClient(HttpOp.createPoolingHttpClient()) ;
+    }
+
+    /** Restore the original setup */
+    private static void resetDefaultHttpClient() {
+        setHttpClient(defaultHttpClient);
+    }
+    
+    /** Set the HttpClient - close the old one if appropriate */
+    private static void setHttpClient(HttpClient newHttpClient) {
+        HttpClient hc = HttpOp.getDefaultHttpClient() ;
+        if ( hc instanceof CloseableHttpClient )
+            IO.close((CloseableHttpClient)hc) ;
+        HttpOp.setDefaultHttpClient(newHttpClient) ;
+    }
+}
diff --git a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/ServerTest.java b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/ServerTest.java
index 03b06b0015..38b51bb404 100644
--- a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/ServerTest.java
+++ b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/ServerTest.java
@@ -20,7 +20,7 @@
 
 import java.io.IOException ;
 import java.net.ServerSocket ;
-import java.util.Arrays ;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import org.apache.jena.fuseki.server.DatasetRegistry ;
 import org.apache.jena.graph.Graph ;
@@ -33,6 +33,7 @@
 import org.apache.jena.sparql.modify.request.Target ;
 import org.apache.jena.sparql.modify.request.UpdateDrop ;
 import org.apache.jena.sparql.sse.SSE ;
+import org.apache.jena.system.Txn ;
 import org.apache.jena.update.Update ;
 import org.apache.jena.update.UpdateExecutionFactory ;
 import org.apache.jena.update.UpdateProcessor ;
@@ -42,15 +43,15 @@
  * <pre>
     \@BeforeClass public static void beforeClass() { ServerTest.allocServer() ; }
     \@AfterClass  public static void afterClass()  { ServerTest.freeServer() ; }
-    \@Before      public void beforeTest()         { ServerTest.resetServer() ; }
+    \@After       public void after()              { ServerTest.resetServer() ; }
     </pre>
  */
 public class ServerTest
 {
-    // Abstraction that runs a SPARQL server for tests.
+    static { Fuseki.init(); }
     
-    // Different to the Fuseki2 test ports.
-    public static final int port             = choosePort(3635, 3634, 3653, 3652, 103635, 103634, 103653, 103652) ;
+    // Abstraction that runs a SPARQL server for tests.
+    public static final int port             = choosePort() ;   // Different to the Fuseki2 test ports.
     public static final String urlRoot       = "http://localhost:"+port+"/" ;
     public static final String datasetPath   = "/dataset" ;
     public static final String serviceUpdate = "http://localhost:"+port+datasetPath+"/update" ; 
@@ -75,26 +76,26 @@
     private static EmbeddedFusekiServer1 server = null ;
     
     // reference count of start/stop server
-    private static int countServer = 0 ; 
+    private static AtomicInteger countServer = new AtomicInteger() ; 
     
-    static public void allocServer() {
-        if ( countServer == 0 )
+    /*package*/ static void allocServer() {
+        if ( countServer.getAndIncrement() == 0 )
             setupServer() ;
-        countServer++ ;
     }
     
-    static public void freeServer() {
-        if ( countServer >= 0 ) {
-            countServer -- ;
-            if ( countServer == 0 )
-                teardownServer() ;
-        }
+    /*package*/ static void freeServer() {
+        if ( countServer.decrementAndGet() == 0 )
+            teardownServer() ;
     }
     
+    // Whether to use a transaction on the dataset or to use SPARQL Update. 
+    static boolean CLEAR_DSG_DIRECTLY = true ;
+    static private DatasetGraph dsgTesting ;
+    
     @SuppressWarnings("deprecation")
     protected static void setupServer() {
-        DatasetGraph dsg = DatasetGraphFactory.create() ;
-        server = EmbeddedFusekiServer1.create(port, dsg, datasetPath) ;
+        dsgTesting = DatasetGraphFactory.createTxnMem() ;
+        server = EmbeddedFusekiServer1.create(port, dsgTesting, datasetPath) ;
         server.start() ;
     }
     
@@ -105,25 +106,25 @@ protected static void teardownServer() {
             server.stop() ;
         server = null ;
     }
-    public static void resetServer() {
-        Update clearRequest = new UpdateDrop(Target.ALL) ;
-        UpdateProcessor proc = UpdateExecutionFactory.createRemote(clearRequest, ServerTest.serviceUpdate) ;
-        proc.execute() ;
+
+    /*package*/ static void resetServer() {
+        if (countServer.get() == 0)  
+            throw new RuntimeException("No server started!");
+        if ( CLEAR_DSG_DIRECTLY ) {
+            Txn.executeWrite(dsgTesting, ()->dsgTesting.clear()) ;   
+        } else {
+            Update clearRequest = new UpdateDrop(Target.ALL) ;
+            UpdateProcessor proc = UpdateExecutionFactory.createRemote(clearRequest, ServerTest.serviceUpdate) ;
+            try {proc.execute() ; }
+            catch (Throwable e) {e.printStackTrace(); throw e;}
+        }
     }
     
-    // Imperfect probing for a port.
-    // There is a race condition on finding a free port and using it in the tests. 
-    private static int choosePort(int... ports) {
-        for (int port : ports) {
-            try {
-                @SuppressWarnings("resource")
-                ServerSocket s = new ServerSocket(port) ;
-                s.close();
-                return s.getLocalPort() ; // OK to call after close.
-            } catch (IOException ex) { 
-                continue;
-            }
+    static int choosePort() {
+        try (ServerSocket s = new ServerSocket(0)) {
+            return s.getLocalPort();
+        } catch (IOException ex) {
+            throw new FusekiException("Failed to find a port for tests!");
         }
-        throw new FusekiException("Failed to find a port in :"+Arrays.asList(ports)) ;
     }
-}
+}
\ No newline at end of file
diff --git a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TS_Fuseki.java b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TS_Fuseki.java
index 693217f8c0..8cfe64936b 100644
--- a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TS_Fuseki.java
+++ b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TS_Fuseki.java
@@ -18,12 +18,9 @@
 
 package org.apache.jena.fuseki;
 
-import org.apache.http.client.HttpClient ;
-import org.apache.jena.atlas.logging.LogCtl ;
 import org.apache.jena.fuseki.http.TestDatasetAccessorHTTP ;
 import org.apache.jena.fuseki.http.TestDatasetGraphAccessorHTTP ;
 import org.apache.jena.fuseki.http.TestHttpOp ;
-import org.apache.jena.riot.web.HttpOp ;
 import org.junit.AfterClass ;
 import org.junit.BeforeClass ;
 import org.junit.runner.RunWith ;
@@ -38,24 +35,16 @@
     , TestQuery.class
     , TestAuth.class
 })
+
 public class TS_Fuseki extends ServerTest
 {
-    // Use HttpOp caching of connections during testing to stop
-    // swamping  kernel socket management (seems to be most
-    // acute on Java 1.6)
-    
-    static HttpClient defaultHttpClient = HttpOp.getDefaultHttpClient() ;
-    // Used for all tests except auth tests.
-    static HttpClient globalCachingClient = HttpOp.createCachingHttpClient() ;
-    
-    @BeforeClass public static void beforeClassAbstract1() {
-        HttpOp.setDefaultHttpClient(globalCachingClient) ;
+    @BeforeClass
+    static public void beforeClass() {
+        ServerCtl.ctlBeforeTestSuite(); 
     }
-    
-    @AfterClass public static void afterClassAbstract1() {
-        HttpOp.setDefaultHttpClient(defaultHttpClient) ;
+
+    @AfterClass
+    static public void afterClass() {
+        ServerCtl.ctlAfterTestSuite(); 
     }
-    
-    @BeforeClass static public void beforeClass() { LogCtl.disable(Fuseki.requestLogName) ; }
-    @AfterClass static public void afterClass()   { LogCtl.setInfo(Fuseki.requestLogName) ;}
 }
diff --git a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TestAuth.java b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TestAuth.java
index 0452b72025..a2e9928aa9 100644
--- a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TestAuth.java
+++ b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TestAuth.java
@@ -26,12 +26,18 @@
 import java.util.HashMap ;
 import java.util.Map ;
 
+import org.apache.http.HttpHost;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.AuthCache;
+import org.apache.http.client.HttpClient;
+import org.apache.http.client.protocol.HttpClientContext;
+import org.apache.http.impl.auth.BasicScheme;
+import org.apache.http.impl.client.BasicAuthCache;
+import org.apache.http.impl.client.BasicCredentialsProvider;
+import org.apache.http.impl.client.HttpClients;
 import org.apache.jena.atlas.logging.LogCtl ;
 import org.apache.jena.atlas.web.HttpException ;
-import org.apache.jena.atlas.web.auth.PreemptiveBasicAuthenticator ;
-import org.apache.jena.atlas.web.auth.ScopedAuthenticator ;
-import org.apache.jena.atlas.web.auth.ServiceAuthenticator ;
-import org.apache.jena.atlas.web.auth.SimpleAuthenticator ;
 import org.apache.jena.fuseki.server.FusekiConfig ;
 import org.apache.jena.fuseki.server.SPARQLServer ;
 import org.apache.jena.fuseki.server.ServerConfig ;
@@ -40,6 +46,7 @@
 import org.apache.jena.query.DatasetAccessorFactory ;
 import org.apache.jena.query.QueryExecutionFactory ;
 import org.apache.jena.rdf.model.Model ;
+import org.apache.jena.riot.web.HttpOp;
 import org.apache.jena.sparql.core.DatasetGraph ;
 import org.apache.jena.sparql.core.DatasetGraphFactory ;
 import org.apache.jena.sparql.engine.http.QueryEngineHTTP ;
@@ -61,9 +68,9 @@
 public class TestAuth {
     // Use different port etc because sometimes the previous testing servers
     // don't release ports fast enough (OS issue / Linux)
-    public static final int authPort             = ServerTest.port+10 ;
+    public static final int authPort             = ServerTest.choosePort() ;
     public static final String authUrlRoot       = "http://localhost:"+authPort+"/" ;
-    public static final String authDatasetPath   = "/dataset" ;
+    public static final String authDatasetPath   = "/authDataset" ;
     public static final String authServiceUpdate = "http://localhost:"+authPort+authDatasetPath+"/update" ; 
     public static final String authServiceQuery  = "http://localhost:"+authPort+authDatasetPath+"/query" ; 
     public static final String authServiceREST   = "http://localhost:"+authPort+authDatasetPath+"/data" ;
@@ -78,6 +85,7 @@ public class TestAuth {
      */
     @BeforeClass
     public static void setup() throws IOException {
+        HttpOp.setDefaultHttpClient(null);
         realmFile = File.createTempFile("realm", ".properties");
 
         try(FileWriter writer = new FileWriter(realmFile)) {
@@ -106,22 +114,34 @@ public static void setup() throws IOException {
     @AfterClass
     public static void teardown() {
         server.stop();
-
         realmFile.delete();
     }
-
+    
+    private static HttpClient withCreds(String uname, String password) {
+        BasicCredentialsProvider credsProv = new BasicCredentialsProvider();
+        credsProv.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(uname, password));
+        return HttpClients.custom().setDefaultCredentialsProvider(credsProv).build();
+    }
+    
+    private static HttpClient withCreds(URI scope, String uname, String password) {
+        BasicCredentialsProvider credsProv = new BasicCredentialsProvider();
+        credsProv.setCredentials(new AuthScope(scope.getHost(), scope.getPort()),
+                new UsernamePasswordCredentials(uname, password));
+        return HttpClients.custom().setDefaultCredentialsProvider(credsProv).build();
+    }
+    
     @Test(expected = QueryExceptionHTTP.class)
     public void query_with_auth_01() {
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
         // No auth credentials should result in an error
-        qe.execAsk();
+        qe.execAsk();   
     }
 
     @Test(expected = QueryExceptionHTTP.class)
     public void query_with_auth_02() {
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
         // Auth credentials for valid user with bad password
-        qe.setBasicAuthentication("allowed", "incorrect".toCharArray());
+        qe.setClient(withCreds("allowed", "incorrect"));
         qe.execAsk();
     }
 
@@ -129,16 +149,15 @@ public void query_with_auth_02() {
     public void query_with_auth_03() {
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
         // Auth credentials for valid user with correct password
-        qe.setBasicAuthentication("allowed", "password".toCharArray());
+        qe.setClient(withCreds("allowed", "password"));
         Assert.assertTrue(qe.execAsk());
     }
 
     @Test(expected = QueryExceptionHTTP.class)
     public void query_with_auth_04() {
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
-        // Auth credentials for valid user with correct password BUT not in
-        // correct role
-        qe.setBasicAuthentication("forbidden", "password".toCharArray());
+        // Auth credentials for valid user with correct password BUT not in correct role
+        qe.setClient(withCreds("forbidden", "password"));
         qe.execAsk();
     }
 
@@ -146,11 +165,9 @@ public void query_with_auth_04() {
     public void query_with_auth_05() {
         // Uses auth and enables compression
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
-        qe.setAllowDeflate(true);
-        qe.setAllowGZip(true);
-
+        qe.setAllowCompression(true);
         // Auth credentials for valid user with correct password
-        qe.setBasicAuthentication("allowed", "password".toCharArray());
+        qe.setClient(withCreds("allowed", "password"));
         Assert.assertTrue(qe.execAsk());
     }
 
@@ -158,103 +175,87 @@ public void query_with_auth_05() {
     public void query_with_auth_06() {
         // Uses auth and enables compression
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
-        qe.setAllowDeflate(true);
-        qe.setAllowGZip(true);
-
+        qe.setAllowCompression(true);
         // Auth credentials for valid user with bad password
-        qe.setBasicAuthentication("allowed", "incorrect".toCharArray());
+        qe.setClient(withCreds("allowed", "incorrect"));
         qe.execAsk();
     }
 
     @Test(expected = QueryExceptionHTTP.class)
     public void query_with_auth_07() throws URISyntaxException {
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
-
-        // Auth credentials for valid user with correct password but scoped to
-        // wrong URI
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI("http://example"), "allowed",
-                "password".toCharArray());
-        qe.setAuthenticator(authenticator);
+        // Auth credentials for valid user with correct password but scoped to wrong URI
+        qe.setClient(withCreds(new URI("http://example"), "allowed", "password"));
         qe.execAsk();
     }
 
     @Test
     public void query_with_auth_08() throws URISyntaxException {
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
-
-        // Auth credentials for valid user with correct password and scoped to
-        // correct URI
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI(authServiceQuery), "allowed", "password".toCharArray());
-        qe.setAuthenticator(authenticator);
+        // Auth credentials for valid user with correct password and scoped to correct URI
+        qe.setClient(withCreds(new URI(authServiceQuery), "allowed", "password"));
         Assert.assertTrue(qe.execAsk());
     }
 
     @Test
-    public void query_with_auth_09() throws URISyntaxException {
+    public void query_with_auth_09() {
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
-
-        // Auth credentials for valid user with correct password using
-        // pre-emptive auth
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI(authServiceQuery), "allowed", "password".toCharArray());
-        qe.setAuthenticator(new PreemptiveBasicAuthenticator(authenticator));
+        // Auth credentials for valid user with correct password using pre-emptive auth
+        BasicCredentialsProvider credsProv = new BasicCredentialsProvider();
+        URI scope = URI.create(authServiceUpdate);
+        credsProv.setCredentials(new AuthScope(scope.getHost(), scope.getPort()),
+                new UsernamePasswordCredentials("allowed", "password"));
+        // Create AuthCache instance
+        AuthCache authCache = new BasicAuthCache();
+        // Generate BASIC scheme object and add it to the local auth cache
+        BasicScheme basicAuth = new BasicScheme();
+        authCache.put(new HttpHost(scope.getHost()), basicAuth);
+
+        // Add AuthCache to the execution context
+        HttpClientContext context = HttpClientContext.create();
+        context.setCredentialsProvider(credsProv);
+        context.setAuthCache(authCache);
+        HttpClient client = HttpClients.custom().setDefaultCredentialsProvider(credsProv).build();
+        qe.setClient(client);
+        qe.setHttpContext(context);
+        qe.setClient(withCreds(URI.create(authServiceQuery), "allowed", "password"));
         Assert.assertTrue(qe.execAsk());
     }
 
     @Test
     public void query_with_auth_10() {
-        Context ctx = ARQ.getContext();
-        try {
-            QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
-
-            // Auth credentials for valid user with correct password and scoped
-            // to correct URI
-            // Provided via Service Context and its associated authenticator
-            Map<String, Context> serviceContext = new HashMap<String, Context>();
-            Context authContext = new Context();
-            authContext.put(Service.queryAuthUser, "allowed");
-            authContext.put(Service.queryAuthPwd, "password");
-            serviceContext.put(authServiceQuery, authContext);
-            ctx.put(Service.serviceContext, serviceContext);
-
-            qe.setAuthenticator(new ServiceAuthenticator());
-            Assert.assertTrue(qe.execAsk());
-        } finally {
-            ctx.remove(Service.serviceContext);
-        }
+        QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
+
+        // Auth credentials for valid user with correct password and scoped to correct URI
+        // Provided via Service Context
+        Map<String, Context> serviceContext = new HashMap<>();
+        Context authContext = new Context();
+        authContext.put(Service.queryClient, withCreds("allowed", "password"));
+        serviceContext.put(authServiceQuery, authContext);
+        qe.getContext().put(Service.serviceContext, serviceContext);
+        Assert.assertTrue(qe.execAsk());
     }
     
     @Test
     public void query_with_auth_11() {
-        Context ctx = ARQ.getContext();
-        try {
-            QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
-
-            // Auth credentials for valid user with correct password and scoped
-            // to base URI of the actual service URL
-            // Provided via Service Context and its associated authenticator
-            Map<String, Context> serviceContext = new HashMap<String, Context>();
-            Context authContext = new Context();
-            authContext.put(Service.queryAuthUser, "allowed");
-            authContext.put(Service.queryAuthPwd, "password");
-            serviceContext.put(authUrlRoot, authContext);
-            ctx.put(Service.serviceContext, serviceContext);
-
-            qe.setAuthenticator(new ServiceAuthenticator());
-            Assert.assertTrue(qe.execAsk());
-        } finally {
-            ctx.remove(Service.serviceContext);
-        }
+        QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
+
+        // Auth credentials for valid user with correct password and scoped to base URI of the actual service URL
+        // Provided via Service Context
+        Map<String, Context> serviceContext = new HashMap<>();
+        Context authContext = new Context();
+        authContext.put(Service.queryClient, withCreds(URI.create(authUrlRoot), "allowed", "password"));
+        serviceContext.put(authServiceQuery, authContext);
+        qe.getContext().put(Service.serviceContext, serviceContext);
+        Assert.assertTrue(qe.execAsk());
     }
     
     @Test
     public void query_with_auth_12() {
         ARQ.getContext().remove(Service.serviceContext);
-
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
-
         // Auth credentials for valid user with correct password
-        // Use service authenticator with fallback credentials.
-        qe.setAuthenticator(new ServiceAuthenticator("allowed", "password".toCharArray()));
+        qe.setClient(withCreds("allowed", "password"));
         Assert.assertTrue(qe.execAsk());
      }
     
@@ -262,10 +263,8 @@ public void query_with_auth_12() {
     public void query_with_auth_13() throws URISyntaxException {
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
 
-        // Auth credentials for valid user with correct password and scoped to
-        // base URI of the actual service URL
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI(authUrlRoot), "allowed", "password".toCharArray());
-        qe.setAuthenticator(authenticator);
+        // Auth credentials for valid user with correct password and scoped to base URI of the actual service URL
+        qe.setClient(withCreds(new URI(authUrlRoot), "allowed", "password"));
         Assert.assertTrue(qe.execAsk());
     }
     
@@ -273,10 +272,8 @@ public void query_with_auth_13() throws URISyntaxException {
     public void query_with_auth_14() throws URISyntaxException {
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
 
-        // Auth credentials for valid user with correct password and scoped to
-        // base URI of the actual service URL
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI("http://localhost:" + authPort), "allowed", "password".toCharArray());
-        qe.setAuthenticator(authenticator);
+        // Auth credentials for valid user with correct password and scoped to base URI of the actual service URL
+        qe.setClient(withCreds(new URI("http://localhost:" + authPort), "allowed", "password"));
         Assert.assertTrue(qe.execAsk());
     }
 
@@ -293,7 +290,7 @@ public void update_with_auth_02() {
         UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(updates, authServiceUpdate);
         // Auth credentials for valid user with bad password
-        ue.setAuthentication("allowed", "incorrect".toCharArray());
+        ue.setClient(withCreds("allowed", "incorrect"));
         ue.execute();
     }
 
@@ -302,7 +299,7 @@ public void update_with_auth_03() {
         UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(updates, authServiceUpdate);
         // Auth credentials for valid user with correct password
-        ue.setAuthentication("allowed", "password".toCharArray());
+        ue.setClient(withCreds("allowed", "password"));
         ue.execute();
     }
 
@@ -310,9 +307,8 @@ public void update_with_auth_03() {
     public void update_with_auth_04() {
         UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(updates, authServiceUpdate);
-        // Auth credentials for valid user with correct password BUT not in
-        // correct role
-        ue.setAuthentication("forbidden", "password".toCharArray());
+        // Auth credentials for valid user with correct password BUT not in correct role
+        ue.setClient(withCreds("forbidden", "password"));
         ue.execute();
     }
 
@@ -329,7 +325,7 @@ public void update_with_auth_06() {
         UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemoteForm(updates, authServiceUpdate);
         // Auth credentials for valid user with bad password
-        ue.setAuthentication("allowed", "incorrect".toCharArray());
+        ue.setClient(withCreds("allowed", "incorrect"));
         ue.execute();
     }
 
@@ -338,7 +334,7 @@ public void update_with_auth_07() {
         UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemoteForm(updates, authServiceUpdate);
         // Auth credentials for valid user with correct password
-        ue.setAuthentication("allowed", "password".toCharArray());
+        ue.setClient(withCreds("allowed", "password"));
         ue.execute();
     }
 
@@ -346,47 +342,55 @@ public void update_with_auth_07() {
     public void update_with_auth_08() {
         UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemoteForm(updates, authServiceUpdate);
-        // Auth credentials for valid user with correct password BUT not in
-        // correct role
-        ue.setAuthentication("forbidden", "password".toCharArray());
+        // Auth credentials for valid user with correct password BUT not in correct role
+        ue.setClient(withCreds("forbidden", "password"));
         ue.execute();
     }
 
     @Test(expected = HttpException.class)
-    public void update_with_auth_09() throws URISyntaxException {
+    public void update_with_auth_09() {
         UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(updates, authServiceUpdate);
-
-        // Auth credentials for valid user with correct password but scoped to
-        // wrong URI
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI("http://example"), "allowed",
-                "password".toCharArray());
-        ue.setAuthenticator(authenticator);
+        // Auth credentials for valid user with correct password but scoped to wrong URI
+        ue.setClient(withCreds(URI.create("http://example"), "allowed", "password"));
         ue.execute();
     }
 
     @Test
-    public void update_with_auth_10() throws URISyntaxException {
+    public void update_with_auth_10() {
         UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(updates, authServiceUpdate);
 
-        // Auth credentials for valid user with correct password scoped to
-        // correct URI
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI(authServiceUpdate), "allowed", "password".toCharArray());
-        ue.setAuthenticator(authenticator);
+        // Auth credentials for valid user with correct password scoped to correct URI
+        ue.setClient(withCreds(URI.create(authServiceUpdate), "allowed", "password"));
         ue.execute();
     }
 
     @Test
-    public void update_with_auth_11() throws URISyntaxException {
+    public void update_with_auth_11() {
         UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
-        UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(updates, authServiceUpdate);
+        UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(updates,
+                authServiceUpdate);
 
-        // Auth credentials for valid user with correct password scoped to
-        // correct URI
+        // Auth credentials for valid user with correct password scoped to correct URI
         // Also using pre-emptive auth
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI(authServiceUpdate), "allowed", "password".toCharArray());
-        ue.setAuthenticator(new PreemptiveBasicAuthenticator(authenticator));
+        BasicCredentialsProvider credsProv = new BasicCredentialsProvider();
+        URI scope = URI.create(authServiceUpdate);
+        credsProv.setCredentials(new AuthScope(scope.getHost(), scope.getPort()),
+                new UsernamePasswordCredentials("allowed", "password"));
+        // Create AuthCache instance
+        AuthCache authCache = new BasicAuthCache();
+        // Generate BASIC scheme object and add it to the local auth cache
+        BasicScheme basicAuth = new BasicScheme();
+        authCache.put(new HttpHost(scope.getHost()), basicAuth);
+
+        // Add AuthCache to the execution context
+        HttpClientContext context = HttpClientContext.create();
+        context.setCredentialsProvider(credsProv);
+        context.setAuthCache(authCache);
+        HttpClient client = HttpClients.custom().setDefaultCredentialsProvider(credsProv).build();
+        ue.setClient(client);
+        ue.setHttpContext(context);
         ue.execute();
     }
     
@@ -400,14 +404,14 @@ public void graphstore_with_auth_01() {
     @Test(expected = HttpException.class)
     public void graphstore_with_auth_02() {
         // Incorrect auth credentials
-        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST, new SimpleAuthenticator("allowed", "incorrect".toCharArray()));
+        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST, withCreds("allowed", "incorrect"));
         accessor.getModel();
     }
     
     @Test
     public void graphstore_with_auth_03() {
         // Correct auth credentials
-        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST, new SimpleAuthenticator("allowed", "password".toCharArray()));
+        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST, withCreds("allowed", "password"));
         Model m = accessor.getModel();
         Assert.assertTrue(m.isEmpty());
     }
@@ -415,14 +419,14 @@ public void graphstore_with_auth_03() {
     @Test(expected = HttpException.class)
     public void graphstore_with_auth_04() throws URISyntaxException {
         // Correct auth credentials scoped to wrong URI
-        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST, new ScopedAuthenticator(new URI("http://example.org/"), "allowed", "password".toCharArray()));
+        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST, withCreds(new URI("http://example.org/"), "allowed", "password"));
         accessor.getModel();
     }
     
     @Test
     public void graphstore_with_auth_05() throws URISyntaxException {
         // Correct auth credentials scoped to correct URI
-        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST, new ScopedAuthenticator(new URI(authServiceREST), "allowed", "password".toCharArray()));
+        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST, withCreds(new URI(authServiceREST), "allowed", "password"));
         accessor.getModel();
     }
 }
diff --git a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TestQuery.java b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TestQuery.java
index 5c0674f6f1..7124592423 100644
--- a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TestQuery.java
+++ b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TestQuery.java
@@ -31,7 +31,6 @@
 import org.apache.jena.query.* ;
 import org.apache.jena.sparql.core.Var ;
 import org.apache.jena.sparql.engine.binding.Binding ;
-import org.apache.jena.sparql.resultset.ResultSetCompare ;
 import org.apache.jena.sparql.sse.Item ;
 import org.apache.jena.sparql.sse.SSE ;
 import org.apache.jena.sparql.sse.builders.BuilderResultSet ;
@@ -46,19 +45,14 @@ public class TestQuery extends BaseTest
     }
     
     // DRY - test protocol?
-    @BeforeClass public static void beforeClass()
-    {
+    @BeforeClass public static void beforeClass() {
         ServerTest.allocServer() ;
-        ServerTest.resetServer() ;
         DatasetAccessor du = DatasetAccessorFactory.createHTTP(serviceREST) ;
         du.putModel(model1) ;
         du.putModel(gn1, model2) ;
     }
     
-    @AfterClass public static void afterClass()
-    {
-        DatasetAccessor du = DatasetAccessorFactory.createHTTP(serviceREST) ;
-        du.deleteDefault() ;
+    @AfterClass public static void afterClass() {
         ServerTest.freeServer() ;
     }
     
@@ -105,12 +99,4 @@ private void execQuery(String queryString, int exceptedRowCount)
         int x = ResultSetFormatter.consume(rs) ;
         assertEquals(exceptedRowCount, x) ;
     }
-    
-    private void execQuery(String queryString, ResultSet expectedResultSet)
-    {
-        QueryExecution qExec = QueryExecutionFactory.sparqlService(serviceQuery, queryString) ;
-        ResultSet rs = qExec.execSelect() ;
-        boolean b = ResultSetCompare.equalsByTerm(rs, expectedResultSet) ;
-        assertTrue("Result sets different", b) ;
-    }
 }
diff --git a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TestSPARQLProtocol.java b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TestSPARQLProtocol.java
index cffc8c4c1d..b58d8dba84 100644
--- a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TestSPARQLProtocol.java
+++ b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/TestSPARQLProtocol.java
@@ -37,7 +37,6 @@ public class TestSPARQLProtocol extends BaseTest
     @BeforeClass public static void beforeClass()
     {
         ServerTest.allocServer() ;
-        ServerTest.resetServer() ;
         // Load some data.
         DatasetAccessor du = DatasetAccessorFactory.createHTTP(serviceREST) ;
         du.putModel(model1) ;
@@ -46,7 +45,6 @@ public class TestSPARQLProtocol extends BaseTest
     
     @AfterClass public static void afterClass()
     {
-        ServerTest.resetServer() ;
         ServerTest.freeServer() ;
     }
     
diff --git a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/http/TestDatasetAccessorHTTP.java b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/http/TestDatasetAccessorHTTP.java
index f7a652e370..7b2e168165 100644
--- a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/http/TestDatasetAccessorHTTP.java
+++ b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/http/TestDatasetAccessorHTTP.java
@@ -19,8 +19,10 @@
 package org.apache.jena.fuseki.http;
 
 import static org.apache.jena.fuseki.ServerTest.* ;
+
 import org.apache.jena.atlas.junit.BaseTest ;
 import org.apache.jena.atlas.web.HttpException ;
+import org.apache.jena.fuseki.ServerCtl ;
 import org.apache.jena.fuseki.ServerTest ;
 import org.apache.jena.query.DatasetAccessor ;
 import org.apache.jena.query.DatasetAccessorFactory ;
@@ -28,10 +30,7 @@
 import org.apache.jena.rdf.model.ModelFactory ;
 import org.apache.jena.riot.web.HttpOp ;
 import org.apache.jena.web.HttpSC ;
-import org.junit.AfterClass ;
-import org.junit.Before ;
-import org.junit.BeforeClass ;
-import org.junit.Test ;
+import org.junit.* ;
 
 
 public class TestDatasetAccessorHTTP extends BaseTest 
@@ -40,9 +39,10 @@ public class TestDatasetAccessorHTTP extends BaseTest
     static final String datasetURI_not_2    = serviceREST+"/not" ;
     static final String datasetURI_not_3    = "http://localhost:"+port+datasetPath+"/not/data" ;
     
-    @BeforeClass public static void beforeClass()   { ServerTest.allocServer() ; }
-    @AfterClass public static void afterClass()     { ServerTest.freeServer() ; }
-    @Before public void before()                    { ServerTest.resetServer() ; }
+    @BeforeClass public static void ctlBeforeClass() { ServerCtl.ctlBeforeClass(); }
+    @AfterClass  public static void ctlAfterClass()  { ServerCtl.ctlAfterClass(); }
+    @Before      public void ctlBeforeTest()         { ServerCtl.ctlBeforeTest(); }
+    @After       public void ctlAfterTest()          { ServerCtl.ctlAfterTest(); } 
     
     @Test(expected=HttpException.class)
     public void test_ds_1()
diff --git a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/http/TestDatasetGraphAccessorHTTP.java b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/http/TestDatasetGraphAccessorHTTP.java
index 8794ba37ed..ef548d6d08 100644
--- a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/http/TestDatasetGraphAccessorHTTP.java
+++ b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/http/TestDatasetGraphAccessorHTTP.java
@@ -18,19 +18,22 @@
 
 package org.apache.jena.fuseki.http;
 
+import org.apache.jena.fuseki.ServerCtl ;
 import org.apache.jena.fuseki.ServerTest ;
 import org.apache.jena.web.AbstractTestDatasetGraphAccessor ;
 import org.apache.jena.web.DatasetGraphAccessor ;
 import org.apache.jena.web.DatasetGraphAccessorHTTP ;
+import org.junit.After ;
 import org.junit.AfterClass ;
 import org.junit.Before ;
 import org.junit.BeforeClass ;
 
 public class TestDatasetGraphAccessorHTTP extends AbstractTestDatasetGraphAccessor
 {
-    @BeforeClass public static void beforeClass() { ServerTest.allocServer() ; }
-    @AfterClass public static void afterClass()   { ServerTest.freeServer() ; }
-    @Before public void before()                  { ServerTest.resetServer() ; } 
+    @BeforeClass public static void ctlBeforeClass() { ServerCtl.ctlBeforeClass(); }
+    @AfterClass  public static void ctlAfterClass()  { ServerCtl.ctlAfterClass(); }
+    @Before      public void ctlBeforeTest()         { ServerCtl.ctlBeforeTest(); }
+    @After       public void ctlAfterTest()          { ServerCtl.ctlAfterTest(); } 
     
     @Override
     protected DatasetGraphAccessor getDatasetUpdater()
diff --git a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/http/TestHttpOp.java b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/http/TestHttpOp.java
index 47047c1041..ad3acc91a2 100644
--- a/jena-fuseki1/src/test/java/org/apache/jena/fuseki/http/TestHttpOp.java
+++ b/jena-fuseki1/src/test/java/org/apache/jena/fuseki/http/TestHttpOp.java
@@ -25,28 +25,28 @@
 import org.apache.jena.atlas.lib.IRILib ;
 import org.apache.jena.atlas.web.HttpException ;
 import org.apache.jena.atlas.web.TypedInputStream ;
+import org.apache.jena.fuseki.ServerCtl ;
 import org.apache.jena.fuseki.ServerTest ;
 import org.apache.jena.riot.WebContent ;
 import org.apache.jena.riot.web.HttpOp ;
 import org.apache.jena.sparql.engine.http.Params ;
 import org.apache.jena.util.FileUtils ;
 import org.apache.jena.web.HttpSC ;
-import org.junit.AfterClass ;
-import org.junit.BeforeClass ;
-import org.junit.Test ;
+import org.junit.* ;
 
 // This a mixture of testing HttpOp and testing basic operation of the SPARQL server
 // especially error cases and unusual usage that the higher level APIs don't use.
 public class TestHttpOp extends BaseTest {
     
-    static String pingURL = ServerTest.urlRoot+"ping.txt" ;
-    @BeforeClass public static void beforeClass() { ServerTest.allocServer() ; }
-    @AfterClass  public static void afterClass()  { ServerTest.freeServer() ; }
-    
-    static String graphURL = ServerTest.serviceREST+"?default" ;
-    static String queryURL = ServerTest.serviceQuery ;
-    static String updateURL = ServerTest.serviceUpdate ;
+    @BeforeClass public static void ctlBeforeClass() { ServerCtl.ctlBeforeClass(); }
+    @AfterClass  public static void ctlAfterClass()  { ServerCtl.ctlAfterClass(); }
+    @Before      public void ctlBeforeTest()         { ServerCtl.ctlBeforeTest(); }
+    @After       public void ctlAfterTest()          { ServerCtl.ctlAfterTest(); } 
     
+    static String pingURL     = ServerTest.urlRoot + "ping.txt" ;
+    static String graphURL    = ServerTest.serviceREST + "?default" ;
+    static String queryURL    = ServerTest.serviceQuery ;
+    static String updateURL   = ServerTest.serviceUpdate ;
     static String simpleQuery = queryURL+"?query="+IRILib.encodeUriComponent("ASK{}") ;
     
     // Basic operations
diff --git a/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/FusekiTest.java b/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/FusekiTest.java
index d963296c66..3cd38da6bb 100644
--- a/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/FusekiTest.java
+++ b/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/FusekiTest.java
@@ -26,12 +26,11 @@
 import org.apache.http.client.methods.HttpOptions ;
 import org.apache.http.client.methods.HttpUriRequest ;
 import org.apache.http.impl.client.CloseableHttpClient ;
-import org.apache.http.impl.client.HttpClientBuilder ;
+import org.apache.http.impl.client.HttpClients;
 import org.apache.http.protocol.HttpContext ;
 import org.apache.http.util.EntityUtils ;
 import org.apache.jena.atlas.web.HttpException ;
 import org.apache.jena.riot.web.HttpNames ;
-import org.apache.jena.riot.web.HttpResponseHandler ;
 import org.apache.jena.riot.web.HttpResponseLib ;
 import org.apache.jena.web.HttpSC ;
 import org.junit.Assert ;
@@ -42,7 +41,6 @@ public class FusekiTest {
     public static void assertStringList(String str, String... expected) {
         str = str.replace(" ", "") ;
         String[] x = str.split(",") ;
-        int count = 0 ;
         for ( String ex : expected ) {
             Assert.assertTrue("Got: "+str+" - Does not contain "+ex, containsStr(ex, x)) ;
         }
@@ -63,9 +61,7 @@ public static boolean containsStr(String v, String[] strings) {
     /** Do an HTTP Options. */
     public static String execOptions(String url) {
         // Prepare and execute
-        HttpResponseHandler handler = HttpResponseLib.nullResponse ;
-
-        try ( CloseableHttpClient httpClient = HttpClientBuilder.create().build() ) {
+        try ( CloseableHttpClient httpClient = HttpClients.createDefault() ) {
             HttpUriRequest request = new HttpOptions(url) ;
             HttpResponse response = httpClient.execute(request, (HttpContext)null);
 
@@ -77,10 +73,9 @@ public static String execOptions(String url) {
                 String contentPayload = "" ;
                 if ( response.getEntity() != null )
                     contentPayload = EntityUtils.toString(response.getEntity()) ;
-                throw new HttpException(statusLine.getStatusCode(), statusLine.getReasonPhrase(), contentPayload);
+                throw new HttpException(statusCode, statusLine.getReasonPhrase(), contentPayload);
             }
-            if (handler != null)
-                handler.handle(url, response);
+            HttpResponseLib.nullResponse.handle(url, response);
             return response.getFirstHeader(HttpNames.hAllow).getValue() ;
         } catch (IOException ex) { 
             throw new HttpException(ex);
diff --git a/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/ServerTest.java b/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/ServerTest.java
index 39591f0780..d36f1047e6 100644
--- a/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/ServerTest.java
+++ b/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/ServerTest.java
@@ -167,13 +167,10 @@ public static void resetServer() {
     private static int choosePort(int... ports) {
         for (int port : ports) {
             try {
-                @SuppressWarnings("resource")
                 ServerSocket s = new ServerSocket(port) ;
                 s.close();
                 return s.getLocalPort() ; // OK to call after close.
-            } catch (IOException ex) { 
-                continue;
-            }
+            } catch (IOException ex) { }
         }
         throw new FusekiException("Failed to find a port in :"+Arrays.asList(ports)) ;
     }
diff --git a/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/TestAuth.java b/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/TestAuth.java
index 00fe231bec..1a4f517cfd 100644
--- a/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/TestAuth.java
+++ b/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/TestAuth.java
@@ -18,21 +18,22 @@
 
 package org.apache.jena.fuseki;
 
+import static org.apache.http.auth.AuthScope.ANY;
+
 import java.io.File ;
 import java.io.FileWriter ;
 import java.io.IOException ;
-import java.net.URI ;
 import java.net.URISyntaxException ;
 import java.util.HashMap ;
 import java.util.Map ;
 
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.HttpClient;
+import org.apache.http.impl.client.BasicCredentialsProvider;
+import org.apache.http.impl.client.HttpClientBuilder;
 import org.apache.jena.atlas.logging.LogCtl ;
 import org.apache.jena.atlas.web.HttpException ;
-import org.apache.jena.atlas.web.auth.PreemptiveBasicAuthenticator ;
-import org.apache.jena.atlas.web.auth.ScopedAuthenticator ;
-import org.apache.jena.atlas.web.auth.ServiceAuthenticator ;
-import org.apache.jena.atlas.web.auth.SimpleAuthenticator ;
-import org.apache.jena.query.ARQ ;
 import org.apache.jena.query.DatasetAccessor ;
 import org.apache.jena.query.DatasetAccessorFactory ;
 import org.apache.jena.query.QueryExecutionFactory ;
@@ -55,6 +56,7 @@
  */
 public class TestAuth {
     
+
     // Use different port etc because sometimes the previous testing servers
     // don't release ports fast enough (OS issue / Linux)
     public static final int authPort             = ServerTest.port+10 ;
@@ -100,12 +102,19 @@ public void query_with_auth_01() {
         // No auth credentials should result in an error
         qe.execAsk();
     }
+    
+    private static HttpClient withBasicAuth(AuthScope scope, String user, String passwd) {
+        BasicCredentialsProvider provider = new BasicCredentialsProvider();
+        UsernamePasswordCredentials credentials = new UsernamePasswordCredentials(user, passwd);
+        provider.setCredentials(scope, credentials);
+        return HttpClientBuilder.create().setDefaultCredentialsProvider(provider).build();
+    }
 
     @Test(expected = QueryExceptionHTTP.class)
     public void query_with_auth_02() {
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
         // Auth credentials for valid user with bad password
-        qe.setBasicAuthentication("allowed", "incorrect".toCharArray());
+        qe.setClient(withBasicAuth(ANY, "allowed", "incorrect"));
         qe.execAsk();
     }
 
@@ -113,7 +122,7 @@ public void query_with_auth_02() {
     public void query_with_auth_03() {
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
         // Auth credentials for valid user with correct password
-        qe.setBasicAuthentication("allowed", "password".toCharArray());
+        qe.setClient(withBasicAuth(ANY, "allowed", "password"));
         Assert.assertTrue(qe.execAsk());
     }
 
@@ -122,7 +131,7 @@ public void query_with_auth_04() {
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
         // Auth credentials for valid user with correct password BUT not in
         // correct role
-        qe.setBasicAuthentication("forbidden", "password".toCharArray());
+        qe.setClient(withBasicAuth(ANY, "forbidden", "password"));
         qe.execAsk();
     }
 
@@ -130,11 +139,10 @@ public void query_with_auth_04() {
     public void query_with_auth_05() {
         // Uses auth and enables compression
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
-        qe.setAllowDeflate(true);
-        qe.setAllowGZip(true);
+        qe.setAllowCompression(true);
 
         // Auth credentials for valid user with correct password
-        qe.setBasicAuthentication("allowed", "password".toCharArray());
+        qe.setClient(withBasicAuth(ANY, "allowed", "password"));
         Assert.assertTrue(qe.execAsk());
     }
 
@@ -142,11 +150,10 @@ public void query_with_auth_05() {
     public void query_with_auth_06() {
         // Uses auth and enables compression
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
-        qe.setAllowDeflate(true);
-        qe.setAllowGZip(true);
+        qe.setAllowCompression(true);
 
         // Auth credentials for valid user with bad password
-        qe.setBasicAuthentication("allowed", "incorrect".toCharArray());
+        qe.setClient(withBasicAuth(ANY, "allowed", "incorrect"));
         qe.execAsk();
     }
 
@@ -156,9 +163,7 @@ public void query_with_auth_07() throws URISyntaxException {
 
         // Auth credentials for valid user with correct password but scoped to
         // wrong URI
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI("http://example"), "allowed",
-                "password".toCharArray());
-        qe.setAuthenticator(authenticator);
+        qe.setClient(withBasicAuth(new AuthScope("example", authPort), "allowed", "password"));
         qe.execAsk();
     }
 
@@ -168,8 +173,7 @@ public void query_with_auth_08() throws URISyntaxException {
 
         // Auth credentials for valid user with correct password and scoped to
         // correct URI
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI(authServiceQuery), "allowed", "password".toCharArray());
-        qe.setAuthenticator(authenticator);
+        qe.setClient(withBasicAuth(new AuthScope("localhost", authPort), "allowed", "password"));
         Assert.assertTrue(qe.execAsk());
     }
 
@@ -177,70 +181,44 @@ public void query_with_auth_08() throws URISyntaxException {
     public void query_with_auth_09() throws URISyntaxException {
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
 
-        // Auth credentials for valid user with correct password using
-        // pre-emptive auth
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI(authServiceQuery), "allowed", "password".toCharArray());
-        qe.setAuthenticator(new PreemptiveBasicAuthenticator(authenticator));
+        // Auth credentials for valid user with correct password
+        qe.setClient(withBasicAuth(new AuthScope("localhost", authPort), "allowed", "password"));
         Assert.assertTrue(qe.execAsk());
     }
 
     @Test
     public void query_with_auth_10() {
-        Context ctx = ARQ.getContext();
-        try {
-            QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
-
-            // Auth credentials for valid user with correct password and scoped
-            // to correct URI
-            // Provided via Service Context and its associated authenticator
-            Map<String, Context> serviceContext = new HashMap<String, Context>();
-            Context authContext = new Context();
-            authContext.put(Service.queryAuthUser, "allowed");
-            authContext.put(Service.queryAuthPwd, "password");
-            serviceContext.put(authServiceQuery, authContext);
-            ctx.put(Service.serviceContext, serviceContext);
-
-            qe.setAuthenticator(new ServiceAuthenticator());
-            Assert.assertTrue(qe.execAsk());
-        } finally {
-            ctx.remove(Service.serviceContext);
-        }
+        QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
+
+        // Auth credentials for valid user with correct password and scoped
+        // to correct URI
+        // Provided via Service Context and its associated authenticator
+        Map<String, Context> serviceContext = new HashMap<>();
+        Context authContext = new Context();
+
+        HttpClient client = withBasicAuth(ANY, "allowed", "password");
+        authContext.put(Service.queryClient, client);
+        serviceContext.put(authServiceQuery, authContext);
+        qe.getContext().put(Service.serviceContext, serviceContext);
+        Assert.assertTrue(qe.execAsk());
     }
     
     @Test
     public void query_with_auth_11() {
-        Context ctx = ARQ.getContext();
-        try {
-            QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
-
-            // Auth credentials for valid user with correct password and scoped
-            // to base URI of the actual service URL
-            // Provided via Service Context and its associated authenticator
-            Map<String, Context> serviceContext = new HashMap<String, Context>();
-            Context authContext = new Context();
-            authContext.put(Service.queryAuthUser, "allowed");
-            authContext.put(Service.queryAuthPwd, "password");
-            serviceContext.put(authUrlRoot, authContext);
-            ctx.put(Service.serviceContext, serviceContext);
-
-            qe.setAuthenticator(new ServiceAuthenticator());
-            Assert.assertTrue(qe.execAsk());
-        } finally {
-            ctx.remove(Service.serviceContext);
-        }
-    }
-    
-    @Test
-    public void query_with_auth_12() {
-        ARQ.getContext().remove(Service.serviceContext);
-
         QueryEngineHTTP qe = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(authServiceQuery, "ASK { }");
 
-        // Auth credentials for valid user with correct password
-        // Use service authenticator with fallback credentials.
-        qe.setAuthenticator(new ServiceAuthenticator("allowed", "password".toCharArray()));
+        // Auth credentials for valid user with correct password and scoped
+        // to base URI of the actual service URL
+        // Provided via Service Context and its associated authenticator
+        Map<String, Context> serviceContext = new HashMap<>();
+        Context authContext = new Context();
+
+        HttpClient client = withBasicAuth(ANY, "allowed", "password");
+        authContext.put(Service.queryClient, client);
+        serviceContext.put(authServiceQuery, authContext);
+        qe.getContext().put(Service.serviceContext, serviceContext);
         Assert.assertTrue(qe.execAsk());
-     }
+    }
     
     @Test
     public void query_with_auth_13() throws URISyntaxException {
@@ -248,8 +226,7 @@ public void query_with_auth_13() throws URISyntaxException {
 
         // Auth credentials for valid user with correct password and scoped to
         // base URI of the actual service URL
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI(authUrlRoot), "allowed", "password".toCharArray());
-        qe.setAuthenticator(authenticator);
+        qe.setClient(withBasicAuth(new AuthScope("localhost" , authPort),"allowed", "password"));
         Assert.assertTrue(qe.execAsk());
     }
     
@@ -259,8 +236,7 @@ public void query_with_auth_14() throws URISyntaxException {
 
         // Auth credentials for valid user with correct password and scoped to
         // base URI of the actual service URL
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI("http://localhost:" + authPort), "allowed", "password".toCharArray());
-        qe.setAuthenticator(authenticator);
+        qe.setClient(withBasicAuth(new AuthScope("localhost" , authPort),"allowed", "password"));
         Assert.assertTrue(qe.execAsk());
     }
 
@@ -277,7 +253,7 @@ public void update_with_auth_02() {
         UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(updates, authServiceUpdate);
         // Auth credentials for valid user with bad password
-        ue.setAuthentication("allowed", "incorrect".toCharArray());
+        ue.setClient(withBasicAuth(ANY, "allowed", "incorrect"));
         ue.execute();
     }
 
@@ -286,7 +262,7 @@ public void update_with_auth_03() {
         UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(updates, authServiceUpdate);
         // Auth credentials for valid user with correct password
-        ue.setAuthentication("allowed", "password".toCharArray());
+        ue.setClient(withBasicAuth(ANY, "allowed", "password")); 
         ue.execute();
     }
 
@@ -296,7 +272,7 @@ public void update_with_auth_04() {
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(updates, authServiceUpdate);
         // Auth credentials for valid user with correct password BUT not in
         // correct role
-        ue.setAuthentication("forbidden", "password".toCharArray());
+        ue.setClient(withBasicAuth(ANY, "forbidden", "password"));
         ue.execute();
     }
 
@@ -313,7 +289,7 @@ public void update_with_auth_06() {
         UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemoteForm(updates, authServiceUpdate);
         // Auth credentials for valid user with bad password
-        ue.setAuthentication("allowed", "incorrect".toCharArray());
+        ue.setClient(withBasicAuth(ANY, "allowed", "incorrect"));
         ue.execute();
     }
 
@@ -322,7 +298,7 @@ public void update_with_auth_07() {
         UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemoteForm(updates, authServiceUpdate);
         // Auth credentials for valid user with correct password
-        ue.setAuthentication("allowed", "password".toCharArray());
+        ue.setClient(withBasicAuth(ANY, "allowed", "password"));
         ue.execute();
     }
 
@@ -332,7 +308,7 @@ public void update_with_auth_08() {
         UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemoteForm(updates, authServiceUpdate);
         // Auth credentials for valid user with correct password BUT not in
         // correct role
-        ue.setAuthentication("forbidden", "password".toCharArray());
+        ue.setClient(withBasicAuth(ANY, "forbidden", "password"));
         ue.execute();
     }
 
@@ -343,9 +319,7 @@ public void update_with_auth_09() throws URISyntaxException {
 
         // Auth credentials for valid user with correct password but scoped to
         // wrong URI
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI("http://example"), "allowed",
-                "password".toCharArray());
-        ue.setAuthenticator(authenticator);
+        ue.setClient(withBasicAuth(new AuthScope("example" , authPort),"allowed", "password"));
         ue.execute();
     }
 
@@ -356,21 +330,7 @@ public void update_with_auth_10() throws URISyntaxException {
 
         // Auth credentials for valid user with correct password scoped to
         // correct URI
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI(authServiceUpdate), "allowed", "password".toCharArray());
-        ue.setAuthenticator(authenticator);
-        ue.execute();
-    }
-
-    @Test
-    public void update_with_auth_11() throws URISyntaxException {
-        UpdateRequest updates = UpdateFactory.create("CREATE SILENT GRAPH <http://graph>");
-        UpdateProcessRemoteBase ue = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(updates, authServiceUpdate);
-
-        // Auth credentials for valid user with correct password scoped to
-        // correct URI
-        // Also using pre-emptive auth
-        ScopedAuthenticator authenticator = new ScopedAuthenticator(new URI(authServiceUpdate), "allowed", "password".toCharArray());
-        ue.setAuthenticator(new PreemptiveBasicAuthenticator(authenticator));
+        ue.setClient(withBasicAuth(new AuthScope("localhost" , authPort),"allowed", "password"));
         ue.execute();
     }
     
@@ -384,14 +344,16 @@ public void graphstore_with_auth_01() {
     @Test(expected = HttpException.class)
     public void graphstore_with_auth_02() {
         // Incorrect auth credentials
-        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST, new SimpleAuthenticator("allowed", "incorrect".toCharArray()));
+        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST,
+                withBasicAuth(ANY, "allowed", "incorrect"));
         accessor.getModel();
     }
     
     @Test
     public void graphstore_with_auth_03() {
         // Correct auth credentials
-        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST, new SimpleAuthenticator("allowed", "password".toCharArray()));
+        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST,
+                withBasicAuth(ANY, "allowed", "password"));
         Model m = accessor.getModel();
         Assert.assertTrue(m.isEmpty());
     }
@@ -399,14 +361,17 @@ public void graphstore_with_auth_03() {
     @Test(expected = HttpException.class)
     public void graphstore_with_auth_04() throws URISyntaxException {
         // Correct auth credentials scoped to wrong URI
-        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST, new ScopedAuthenticator(new URI("http://example.org/"), "allowed", "password".toCharArray()));
+        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST,
+                withBasicAuth(new AuthScope("example.org", authPort), "allowed", "password"));
         accessor.getModel();
     }
     
     @Test
     public void graphstore_with_auth_05() throws URISyntaxException {
         // Correct auth credentials scoped to correct URI
-        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST, new ScopedAuthenticator(new URI(authServiceREST), "allowed", "password".toCharArray()));
+        DatasetAccessor accessor = DatasetAccessorFactory.createHTTP(authServiceREST,
+                withBasicAuth(new AuthScope("localhost", authPort), "allowed", "password"));
         accessor.getModel();
     }
+    
 }
diff --git a/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/TestHttpOperations.java b/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/TestHttpOperations.java
index 5042576e8f..2f5b751cbc 100644
--- a/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/TestHttpOperations.java
+++ b/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/TestHttpOperations.java
@@ -21,29 +21,17 @@
 import static org.apache.jena.fuseki.ServerTest.* ;
 import static org.apache.jena.fuseki.ServerTest.serviceUpdate ;
 
-import org.apache.jena.atlas.junit.BaseTest ;
 import org.apache.jena.atlas.web.HttpException ;
 import org.apache.jena.atlas.web.TypedInputStream ;
 import org.apache.jena.riot.WebContent ;
 import org.apache.jena.riot.web.HttpOp ;
 import org.apache.jena.sparql.engine.http.Params ;
 import org.apache.jena.sparql.util.Convert ;
-import org.junit.AfterClass ;
 import org.junit.Assert ;
-import org.junit.BeforeClass ;
 import org.junit.Test ;
 
 /** Operation by HTTP - test dispatch - lower level than TestSPARQLProtocol */
-public class TestHttpOperations extends BaseTest {
-    @BeforeClass
-    public static void beforeClass() {
-        ServerTest.allocServer() ;
-    }
-
-    @AfterClass
-    public static void afterClass() {
-        ServerTest.freeServer() ;
-    }
+public class TestHttpOperations extends AbstractFusekiTest {
     
     // XXX and directly on dataset
     
@@ -75,10 +63,8 @@ public void query_by_post_2() {
 
     @Test 
     public void query_by_form_1() {
-        String qs = Convert.encWWWForm("ASK{}") ;
         String u = serviceQuery ;
-        Params params = new Params();
-        params.addParam("query", "ASK{}") ;
+        Params params = new Params().addParam("query", "ASK{}") ;
         try (TypedInputStream in = HttpOp.execHttpPostFormStream(u, params, "*") ) { 
             Assert.assertNotNull(in);
         }
@@ -87,8 +73,7 @@ public void query_by_form_1() {
     @Test(expected=HttpException.class) 
     public void query_by_form_2() {
         String u = serviceQuery ;
-        Params params = new Params();
-        params.addParam("foobar", "ASK{}") ;    // Wrong.
+        Params params = new Params().addParam("foobar", "ASK{}") ;    // Wrong.
         try (TypedInputStream in = HttpOp.execHttpPostFormStream(u, params, "*") ) { 
             Assert.assertNotNull(in);
         }
@@ -113,8 +98,7 @@ public void update_by_post_1() {
     @Test
     public void update_by_form_1() {
         String u = serviceUpdate ;
-        Params params = new Params();
-        params.addParam("update", "INSERT DATA{}") ;
+        Params params = new Params().addParam("update", "INSERT DATA{}") ;
         try (TypedInputStream in = HttpOp.execHttpPostFormStream(u, params, "*") ) { 
             Assert.assertNotNull(in);
         }
@@ -123,8 +107,7 @@ public void update_by_form_1() {
     @Test(expected=HttpException.class)
     public void update_by_form_2() {
         String u = serviceUpdate ;
-        Params params = new Params();
-        params.addParam("query", "INSERT DATA{}") ;  // Wrong paramater
+        Params params = new Params().addParam("query", "INSERT DATA{}") ;  // Wrong paramater
         try (TypedInputStream in = HttpOp.execHttpPostFormStream(u, params, "*") ) { 
             Assert.assertNotNull(in);
         }
@@ -134,7 +117,6 @@ public void update_by_form_2() {
     
     @Test 
     public void ds_query_by_get_1() {
-        String qs = Convert.encWWWForm("ASK{}") ;
         String u = urlDataset ;
         try (TypedInputStream in = HttpOp.execHttpGet(u)) {
             Assert.assertNotNull(in);
diff --git a/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/http/TestHttpOp.java b/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/http/TestHttpOp.java
index 488c517ebe..062f9ef250 100644
--- a/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/http/TestHttpOp.java
+++ b/jena-fuseki2/jena-fuseki-core/src/test/java/org/apache/jena/fuseki/http/TestHttpOp.java
@@ -18,11 +18,12 @@
 
 package org.apache.jena.fuseki.http;
 
+import static org.apache.jena.fuseki.FusekiTest.exec404;
+import static org.apache.jena.fuseki.FusekiTest.execWithHttpException;
+
 import org.apache.jena.atlas.lib.IRILib ;
-import org.apache.jena.atlas.web.HttpException ;
 import org.apache.jena.atlas.web.TypedInputStream ;
 import org.apache.jena.fuseki.AbstractFusekiTest ;
-import org.apache.jena.fuseki.FusekiTest ;
 import org.apache.jena.fuseki.ServerTest ;
 import org.apache.jena.riot.WebContent ;
 import org.apache.jena.riot.web.HttpOp ;
@@ -46,18 +47,16 @@ public class TestHttpOp extends AbstractFusekiTest {
     // Basic operations
     
     @Test public void httpGet_01() {
-        try ( TypedInputStream in = HttpOp.execHttpGet(pingURL) ) {}
+        assertNotNull(HttpOp.execHttpGetString(pingURL));
     }
     
     @Test
     public void httpGet_02() {
-        FusekiTest.exec404(() -> {
-            try (TypedInputStream in = HttpOp.execHttpGet(ServerTest.urlRoot + "does-not-exist")) {}
-        });
+        exec404(() -> HttpOp.execHttpGet(ServerTest.urlRoot + "does-not-exist"));
     }
 
     @Test public void httpGet_03() {
-        String x = HttpOp.execHttpGetString(pingURL) ;
+        assertNotNull(HttpOp.execHttpGetString(pingURL));
     }   
     
     @Test public void httpGet_04() {
@@ -66,76 +65,49 @@ public void httpGet_02() {
     }
     
     @Test public void httpGet_05() {
-        try ( TypedInputStream in = HttpOp.execHttpGet(simpleQuery) ) {}
+        assertNotNull(HttpOp.execHttpGetString(simpleQuery));
     }
     
     // SPARQL Query
     
     @Test public void queryGet_01() {
-        try ( TypedInputStream in = HttpOp.execHttpGet(simpleQuery) ) {}
+        assertNotNull(HttpOp.execHttpGetString(simpleQuery));
     }
 
-    @Test(expected=HttpException.class)
     public void queryGet_02() {
         // No query.
-        try ( TypedInputStream in = HttpOp.execHttpGet(queryURL+"?query=") ) {}
-        catch (HttpException ex) {
-            assertEquals(ex.getResponseCode(), HttpSC.BAD_REQUEST_400) ;
-            throw ex ; 
-        }
+        execWithHttpException(HttpSC.BAD_REQUEST_400, () -> HttpOp.execHttpGetString(queryURL + "?query="));
     }
 
-    @Test(expected=HttpException.class)
     public void httpPost_01() {
-        try {
-            HttpOp.execHttpPost(queryURL, "ASK{}", "text/plain") ;
-        } catch (HttpException ex) {
-            assertEquals(ex.getResponseCode(), HttpSC.UNSUPPORTED_MEDIA_TYPE_415) ;
-            throw ex ;
-        }
+        execWithHttpException(HttpSC.UNSUPPORTED_MEDIA_TYPE_415,
+                () -> HttpOp.execHttpPost(queryURL, "ASK{}", "text/plain"));
     }
     
-    @Test(expected=HttpException.class)
     public void httpPost_02() {
-        try {
-            HttpOp.execHttpPost(queryURL, "ASK{}", WebContent.contentTypeSPARQLQuery) ;
-        } catch (HttpException ex) {
-            assertEquals(ex.getResponseCode(), HttpSC.UNSUPPORTED_MEDIA_TYPE_415) ;
-            throw ex ;
-        }
+        execWithHttpException(HttpSC.UNSUPPORTED_MEDIA_TYPE_415,
+                () -> HttpOp.execHttpPost(queryURL, "ASK{}", WebContent.contentTypeSPARQLQuery));
     }
     
-    @Test(expected=HttpException.class)
     public void httpPost_03() {
-        try {
-            HttpOp.execHttpPost(queryURL, "ASK{}", WebContent.contentTypeOctets) ;
-        } catch (HttpException ex) {
-            assertEquals(ex.getResponseCode(), HttpSC.UNSUPPORTED_MEDIA_TYPE_415) ;
-            throw ex ;
-        }
+        execWithHttpException(HttpSC.UNSUPPORTED_MEDIA_TYPE_415,
+                () -> HttpOp.execHttpPost(queryURL, "ASK{}", WebContent.contentTypeOctets));
     }
         
     @Test public void httpPost_04() {
-        Params params = new Params() ;
-        params.addParam("query", "ASK{}") ;
+        Params params = new Params().addParam("query", "ASK{}") ;
         try ( TypedInputStream in = HttpOp.execHttpPostFormStream(queryURL, params, WebContent.contentTypeResultsJSON) ) {}
     }
     
-    @Test(expected=HttpException.class)
     public void httpPost_05() {
-        Params params = new Params() ;
-        params.addParam("query", "ASK{}") ;
+        Params params = new Params().addParam("query", "ASK{}") ;
         // Query to Update
-        try ( TypedInputStream in = HttpOp.execHttpPostFormStream(updateURL, params, WebContent.contentTypeResultsJSON) ) { }
-        catch (HttpException ex) {
-            assertEquals(ex.getResponseCode(), HttpSC.BAD_REQUEST_400) ;
-            throw ex ;
-        }
+        execWithHttpException(HttpSC.BAD_REQUEST_400,
+                () -> HttpOp.execHttpPostFormStream(updateURL, params, WebContent.contentTypeResultsJSON));
     }
     
     @Test public void httpPost_06() {
-        Params params = new Params() ;
-        params.addParam("request", "CLEAR ALL") ;
+        Params params = new Params().addParam("request", "CLEAR ALL") ;
         HttpOp.execHttpPostForm(updateURL, params) ;
     }
     
@@ -190,18 +162,13 @@ public void httpPost_05() {
         String s3 = HttpOp.execHttpGetString(defaultGraphURL, WebContent.contentTypeNTriples) ;
         assertTrue(s3.isEmpty()) ;
         
-        FusekiTest.exec404(()->HttpOp.execHttpDelete(namedGraphURL)) ;
+        exec404(()->HttpOp.execHttpDelete(namedGraphURL)) ;
     }
 
     // Extended GSP - no ?default, no ?graph acts on the datasets as a whole.  
    
     @Test public void gsp_10() {
-        try {
-            HttpOp.execHttpDelete(gspServiceURL) ;
-            fail("Expected 405") ;
-        } catch (HttpException ex) {
-            assertEquals(ex.getResponseCode(), HttpSC.METHOD_NOT_ALLOWED_405) ;
-        }
+        execWithHttpException(HttpSC.METHOD_NOT_ALLOWED_405, () -> HttpOp.execHttpDelete(gspServiceURL));
     }
         
     @Test public void gsp_11() {
diff --git a/jena-jdbc/jena-jdbc-core/src/test/java/org/apache/jena/jdbc/connections/AbstractJenaConnectionTests.java b/jena-jdbc/jena-jdbc-core/src/test/java/org/apache/jena/jdbc/connections/AbstractJenaConnectionTests.java
index e59d01d6fa..76696ceca6 100644
--- a/jena-jdbc/jena-jdbc-core/src/test/java/org/apache/jena/jdbc/connections/AbstractJenaConnectionTests.java
+++ b/jena-jdbc/jena-jdbc-core/src/test/java/org/apache/jena/jdbc/connections/AbstractJenaConnectionTests.java
@@ -130,7 +130,7 @@ public void connection_create_close_01() throws SQLException {
      */
     @Test
     public void connection_create_close_02() throws SQLException {
-        JenaConnection conn = this.getConnection(DatasetFactory.createMem());
+        JenaConnection conn = this.getConnection(DatasetFactory.createTxnMem());
         Assert.assertFalse(conn.isClosed());
         conn.close();
         Assert.assertTrue(conn.isClosed());
@@ -228,7 +228,7 @@ public void connection_statement_query_select_01() throws SQLException {
     @Test
     public void connection_statement_query_select_02() throws SQLException {
         // Prepare a dataset
-        Dataset ds = DatasetFactory.createMem();
+        Dataset ds = DatasetFactory.createTxnMem();
         ds.asDatasetGraph().add(
                 new Quad(NodeFactory.createURI("http://example/graph"), NodeFactory.createURI("http://example/subject"),
                         NodeFactory.createURI("http://example/predicate"), NodeFactory.createURI("http://example/object")));
@@ -272,7 +272,7 @@ public void connection_statement_query_select_02() throws SQLException {
     @Test
     public void connection_statement_query_select_03() throws SQLException {
         // Prepare a dataset
-        Dataset ds = DatasetFactory.createMem();
+        Dataset ds = DatasetFactory.createTxnMem();
         ds.asDatasetGraph().add(
                 new Quad(NodeFactory.createURI("http://example/graph"), NodeFactory.createURI("http://example/subject"),
                         NodeFactory.createURI("http://example/predicate"), NodeFactory.createURI("http://example/object")));
@@ -317,7 +317,7 @@ public void connection_statement_query_select_03() throws SQLException {
     @Test
     public void connection_statement_query_select_04() throws SQLException {
         // Prepare a dataset
-        Dataset ds = DatasetFactory.createMem();
+        Dataset ds = DatasetFactory.createTxnMem();
         ds.asDatasetGraph().add(
                 new Quad(NodeFactory.createURI("http://example/graph"), NodeFactory.createURI("http://example/subject"),
                         NodeFactory.createURI("http://example/predicate"), NodeFactory.createURI("http://example/object")));
@@ -362,7 +362,7 @@ public void connection_statement_query_select_04() throws SQLException {
     @Test
     public void connection_prepared_statement_select_01() throws SQLException, MalformedURLException {
         // Prepare a dataset
-        Dataset ds = DatasetFactory.createMem();
+        Dataset ds = DatasetFactory.createTxnMem();
         ds.asDatasetGraph().add(
                 new Quad(NodeFactory.createURI("http://example/graph"), NodeFactory.createURI("http://example/subject"),
                         NodeFactory.createURI("http://example/predicate"), NodeFactory.createURI("http://example/object")));
@@ -410,7 +410,7 @@ public void connection_prepared_statement_select_01() throws SQLException, Malfo
     @Test
     public void connection_prepared_statement_select_02() throws SQLException {
         // Prepare a dataset
-        Dataset ds = DatasetFactory.createMem();
+        Dataset ds = DatasetFactory.createTxnMem();
         ds.asDatasetGraph().add(
                 new Quad(NodeFactory.createURI("http://example/graph"), NodeFactory.createURI("http://example/subject"),
                         NodeFactory.createURI("http://example/predicate"), NodeFactory.createLiteral("value")));
@@ -458,7 +458,7 @@ public void connection_prepared_statement_select_02() throws SQLException {
     @Test
     public void connection_prepared_statement_select_03() throws SQLException {
         // Prepare a dataset
-        Dataset ds = DatasetFactory.createMem();
+        Dataset ds = DatasetFactory.createTxnMem();
         ds.asDatasetGraph().add(
                 new Quad(NodeFactory.createURI("http://example/graph"), NodeFactory.createURI("http://example/subject"),
                         NodeFactory.createURI("http://example/predicate"), NodeFactory.createLiteral("value")));
@@ -886,7 +886,7 @@ public void connection_statement_query_construct_01() throws SQLException {
     @Test
     public void connection_statement_query_construct_02() throws SQLException {
         // Prepare a dataset
-        Dataset ds = DatasetFactory.createMem();
+        Dataset ds = DatasetFactory.createTxnMem();
         ds.asDatasetGraph().add(
                 new Quad(NodeFactory.createURI("http://example/graph"), NodeFactory.createURI("http://example/subject"),
                         NodeFactory.createURI("http://example/predicate"), NodeFactory.createURI("http://example/object")));
@@ -959,7 +959,7 @@ public void connection_statement_query_describe_01() throws SQLException {
     @Test
     public void connection_statement_query_describe_02() throws SQLException {
         // Prepare a dataset
-        Dataset ds = DatasetFactory.createMem();
+        Dataset ds = DatasetFactory.createTxnMem();
         ds.asDatasetGraph().add(
                 new Quad(NodeFactory.createURI("http://example/graph"), NodeFactory.createURI("http://example/subject"),
                         NodeFactory.createURI("http://example/predicate"), NodeFactory.createURI("http://example/object")));
@@ -1010,7 +1010,7 @@ protected void checkConstructDescribeMetadata(ResultSet results) throws SQLExcep
     @Test
     public void connection_transactions_01() throws SQLException {
         // Set up connection
-        JenaConnection conn = this.getConnection(DatasetFactory.createMem());
+        JenaConnection conn = this.getConnection(DatasetFactory.createTxnMem());
         Assume.assumeNotNull(conn.getMetaData());
         Assume.assumeTrue(conn.getMetaData().supportsTransactions());
         conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
@@ -1044,7 +1044,7 @@ public void connection_transactions_01() throws SQLException {
     @Test
     public void connection_transactions_02() throws SQLException {
         // Set up connection
-        JenaConnection conn = this.getConnection(DatasetFactory.createMem());
+        JenaConnection conn = this.getConnection(DatasetFactory.createTxnMem());
         Assume.assumeNotNull(conn.getMetaData());
         Assume.assumeTrue(conn.getMetaData().supportsTransactions());
         conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
@@ -1082,7 +1082,7 @@ public void connection_transactions_02() throws SQLException {
     @Test
     public void connection_transactions_03() throws SQLException {
         // Set up connection
-        JenaConnection conn = this.getConnection(DatasetFactory.createMem());
+        JenaConnection conn = this.getConnection(DatasetFactory.createTxnMem());
         Assume.assumeNotNull(conn.getMetaData());
         Assume.assumeTrue(conn.getMetaData().supportsTransactions());
         conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);
diff --git a/jena-jdbc/jena-jdbc-core/src/test/java/org/apache/jena/jdbc/results/AbstractResultSetTests.java b/jena-jdbc/jena-jdbc-core/src/test/java/org/apache/jena/jdbc/results/AbstractResultSetTests.java
index bd468cfec1..6e93244030 100644
--- a/jena-jdbc/jena-jdbc-core/src/test/java/org/apache/jena/jdbc/results/AbstractResultSetTests.java
+++ b/jena-jdbc/jena-jdbc-core/src/test/java/org/apache/jena/jdbc/results/AbstractResultSetTests.java
@@ -3413,13 +3413,9 @@ public void results_bad_updates_59() throws SQLException {
      */
     @Test(expected = SQLFeatureNotSupportedException.class)
     public void results_bad_updates_60() throws SQLException {
-        ResultSet rset = this.createResults(ds, "SELECT * WHERE { ?s ?p ?o }");
-
-        try {
+        try (ResultSet rset = this.createResults(ds, "SELECT * WHERE { ?s ?p ?o }")) {
             rset.updateNCharacterStream("s", (Reader) null);
-        } finally {
-            rset.close();
-        }
+        } 
     }
 
     /**
diff --git a/jena-jdbc/jena-jdbc-core/src/test/java/org/apache/jena/jdbc/utils/TestUtils.java b/jena-jdbc/jena-jdbc-core/src/test/java/org/apache/jena/jdbc/utils/TestUtils.java
index ea7fcc5acb..85ba997427 100644
--- a/jena-jdbc/jena-jdbc-core/src/test/java/org/apache/jena/jdbc/utils/TestUtils.java
+++ b/jena-jdbc/jena-jdbc-core/src/test/java/org/apache/jena/jdbc/utils/TestUtils.java
@@ -18,10 +18,12 @@
 
 package org.apache.jena.jdbc.utils;
 
+import static org.apache.jena.graph.Node.ANY;
+import static org.apache.jena.sparql.core.Quad.defaultGraphIRI;
+
 import java.util.Iterator;
 
-import org.apache.jena.atlas.web.auth.HttpAuthenticator;
-import org.apache.jena.graph.Node ;
+import org.apache.http.client.HttpClient;
 import org.apache.jena.query.Dataset ;
 import org.apache.jena.query.DatasetAccessor ;
 import org.apache.jena.query.DatasetAccessorFactory ;
@@ -29,7 +31,6 @@
 import org.apache.jena.rdf.model.Model ;
 import org.apache.jena.rdf.model.ModelFactory ;
 import org.apache.jena.sparql.core.DatasetGraph ;
-import org.apache.jena.sparql.core.Quad ;
 
 /**
  * Test utility methods
@@ -53,7 +54,7 @@ public static Dataset generateDataset(int numGraphs, int triplesPerGraph, boolea
         if (triplesPerGraph <= 0)
             throw new IllegalArgumentException("Number of triples per graph must be >= 1");
 
-        Dataset ds = DatasetFactory.createMem();
+        Dataset ds = DatasetFactory.createTxnMem();
         if (createDefaultGraph) {
             numGraphs--;
             Model def = ModelFactory.createDefaultModel();
@@ -103,21 +104,15 @@ public static void copyDataset(Dataset source, Dataset target) {
     public static void copyDataset(Dataset source, Dataset target, boolean copyDefaultAsQuads) {
         // Copy the default graph
         if (copyDefaultAsQuads) {
-            Iterator<Quad> quads = source.asDatasetGraph().find(Quad.defaultGraphIRI, Node.ANY, Node.ANY, Node.ANY);
             DatasetGraph targetDSG = target.asDatasetGraph();
-            while (quads.hasNext()) {
-                targetDSG.add(quads.next());
-            }
+            source.asDatasetGraph().find(defaultGraphIRI, ANY, ANY, ANY).forEachRemaining(targetDSG::add);
         } else {
             target.setDefaultModel(source.getDefaultModel());
         }
 
         // Copy named graphs
-        Iterator<String> uris = source.listNames();
-        while (uris.hasNext()) {
-            String uri = uris.next();
-            target.addNamedModel(uri, source.getNamedModel(uri));
-        }
+        source.listNames().forEachRemaining(uri->target.addNamedModel(uri, source.getNamedModel(uri)));
+
     }
 
     /**
@@ -144,8 +139,8 @@ public static void copyToRemoteDataset(Dataset source, String service) {
      * @param authenticator
      *            HTTP Authenticator
      */
-    public static void copyToRemoteDataset(Dataset source, String service, HttpAuthenticator authenticator) {
-        DatasetAccessor target = DatasetAccessorFactory.createHTTP(service, authenticator);
+    public static void copyToRemoteDataset(Dataset source, String service, HttpClient client) {
+        DatasetAccessor target = DatasetAccessorFactory.createHTTP(service, client);
         target.putModel(source.getDefaultModel());
         Iterator<String> uris = source.listNames();
         while (uris.hasNext()) {
@@ -168,7 +163,7 @@ public static void copyToRemoteDataset(Dataset source, String service, HttpAuthe
      * @return New Dataset
      */
     public static Dataset renameGraph(Dataset ds, String oldUri, String newUri) {
-        Dataset dest = DatasetFactory.createMem();
+        Dataset dest = DatasetFactory.createTxnMem();
         if (oldUri == null) {
             // Rename default graph
             dest.addNamedModel(newUri, ds.getDefaultModel());
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/RemoteEndpointDriver.java b/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/RemoteEndpointDriver.java
index 74e91d400a..2526cae2ce 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/RemoteEndpointDriver.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/RemoteEndpointDriver.java
@@ -23,16 +23,19 @@
 import java.sql.DriverManager;
 import java.sql.DriverPropertyInfo;
 import java.sql.SQLException;
-import java.util.HashMap;
 import java.util.List;
-import java.util.Map;
 import java.util.Properties;
 
-import org.apache.jena.atlas.web.auth.* ;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.HttpClient;
+import org.apache.http.impl.client.BasicCredentialsProvider;
+import org.apache.http.impl.client.HttpClients;
 import org.apache.jena.jdbc.JdbcCompatibility;
 import org.apache.jena.jdbc.JenaDriver;
 import org.apache.jena.jdbc.connections.JenaConnection;
 import org.apache.jena.jdbc.remote.connections.RemoteEndpointConnection;
+import org.apache.jena.riot.web.HttpOp;
 import org.apache.jena.system.JenaSystem ;
 
 /**
@@ -87,29 +90,12 @@
  * <p>
  * The driver also supports the standard JDBC {@code user} and {@code password}
  * parameters which are used to set user credentials for authenticating to the
- * remote HTTP server. This uses the ARQ HTTP authenticator API behind the
- * scenes so the following parameters may also be used to configure desired
- * behavior:
+ * remote HTTP server.
  * </p>
- * <ul>
- * <li>{@code preemptive-auth} - Sets a boolean indicating whether preemptive
- * basic authentication should be enabled, disabled by default.</li>
- * <li>{@code form-url} - Sets a URL to use for form based login.</li>
- * <li>{@code form-user-field} - Sets the name of the user name field used for
- * form based login. If omitted but {@code form-url} is used then the default
- * value {@code httpd_username} is used i.e. we assume you are communicating
- * with a Apache mod_auth_form protected site that uses the default form
- * configuration.</li>
- * <li>{@code form-password-field} - Sets the name of the password field used
- * for form based login. If omitted but {@code form-url} is used then the
- * default value {@code httpd_password} is used i.e. we assume you are
- * communicating with a Apache mod_auth_form protected site that uses the
- * default form configuration.</li>
- * </ul>
  * <p>
- * Alternatively you may use the {@code authenticator} parameter to set a
- * specific authenticator implementation to use, must be passed an instance of
- * {@link HttpAuthenticator} so can only be passed via the {@link Properties}
+ * Alternatively you may use the {@code client} parameter to set a
+ * specific client implementation to use, must be passed an instance of
+ * {@link HttpClient} so can only be passed via the {@link Properties}
  * object and not via the connection URL. If this parameter is used then all
  * other authentication parameters are ignored.
  * </p>
@@ -176,40 +162,17 @@ public class RemoteEndpointDriver extends JenaDriver {
     public static final String PARAM_MODEL_RESULTS_TYPE = "model-results-type";
 
     /**
-     * Constant for the connection URL parameter that sets the URL to use for
-     * form based login.
-     */
-    public static final String PARAM_FORMS_LOGIN_URL = "form-url";
-
-    /**
-     * Constant for the connection URL parameter that sets the user name field
-     * to use for form based logins
-     */
-    public static final String PARAM_FORMS_LOGIN_USER_FIELD = "form-user-field";
-
-    /**
-     * Constant for the connection URL parameter that sets the password field to
-     * use for form based logins
-     */
-    public static final String PARAM_FORMS_LOGIN_PASSWORD_FIELD = "form-password-field";
-
-    /**
-     * Constant for the connection URL parameter that sets that preemptive
-     * authentication should be enabled.
-     */
-    public static final String PARAM_PREEMPTIVE_AUTH = "preemptive-auth";
-
-    /**
-     * Constant for the parameter used to specify an authenticator used.
+     * Constant for the parameter used to specify a client used.
      * <p>
      * It is <strong>important</strong> to be aware that you must pass in an
-     * actual instance of a {@link HttpAuthenticator} for this parameter so you
+     * actual instance of a {@link HttpClient} for this parameter so you
      * cannot use directly in the Connection URL and must pass in via the
      * {@link Properties} object.
      * </p>
      */
-    public static final String PARAM_AUTHENTICATOR = "authenticator";
+    public static final String PARAM_CLIENT = "client";
 
+    
     /**
      * Static initializer block which ensures the driver gets registered
      */
@@ -271,7 +234,7 @@ protected JenaConnection connect(Properties props, int compatibilityLevel) throw
         List<String> usingNamedGraphs = this.getValues(props, PARAM_USING_NAMED_GRAPH_URI);
 
         // Authentication settings
-        HttpAuthenticator authenticator = this.configureAuthenticator(queryEndpoint, updateEndpoint, props);
+        HttpClient client = this.configureClient(props);
 
         // Result Types
         String selectResultsType = props.getProperty(PARAM_SELECT_RESULTS_TYPE, null);
@@ -279,88 +242,33 @@ protected JenaConnection connect(Properties props, int compatibilityLevel) throw
 
         // Create connection
         return openConnection(queryEndpoint, updateEndpoint, defaultGraphs, namedGraphs, usingGraphs, usingNamedGraphs,
-                authenticator, JenaConnection.DEFAULT_HOLDABILITY, compatibilityLevel, selectResultsType, modelResultsType);
+                client, JenaConnection.DEFAULT_HOLDABILITY, compatibilityLevel, selectResultsType, modelResultsType);
     }
-
-    protected HttpAuthenticator configureAuthenticator(String queryEndpoint, String updateEndpoint, Properties props)
-            throws SQLException {
-        // Is there a specific authenticator to use?
-        Object authObj = props.get(PARAM_AUTHENTICATOR);
-        if (authObj != null) {
-            if (authObj instanceof HttpAuthenticator) {
-                return (HttpAuthenticator) authObj;
-            } else {
-                throw new SQLException(
-                        "The "
-                                + PARAM_AUTHENTICATOR
-                                + " parameter is specified but the value is not an object implementing the required HttpAuthenticator interface");
-            }
-        }
-
-        // Otherwise get credentials to use
+    
+    protected HttpClient configureClient(Properties props) throws SQLException {
+        // Try to get credentials to use
         String user = props.getProperty(PARAM_USERNAME, null);
-        if (user != null && user.trim().length() == 0)
-            user = null;
+        if (user != null && user.trim().isEmpty()) user = null;
         String password = props.getProperty(PARAM_PASSWORD, null);
-        if (password != null && password.trim().length() == 0)
-            password = null;
-
-        // If no credentials then we won't configure anything
-        if (user == null || password == null)
-            return null;
+        if (password != null && password.trim().isEmpty()) password = null;
 
-        // Are we using HTTP or form based login?
-        String loginURL = props.getProperty(PARAM_FORMS_LOGIN_URL);
-        if (loginURL != null) {
-            // Determine login fields
-            String userField = props.getProperty(PARAM_FORMS_LOGIN_USER_FIELD, ApacheModAuthFormLogin.USER_FIELD);
-            String pwdField = props.getProperty(PARAM_FORMS_LOGIN_PASSWORD_FIELD, ApacheModAuthFormLogin.PASSWORD_FIELD);
-
-            // Create logins
-            Map<URI, FormLogin> logins = new HashMap<URI, FormLogin>();
-            String baseUri = this.getCommonBase(queryEndpoint, updateEndpoint);
-            if (baseUri != null) {
-                // One/both endpoints are specified and they have a common
-                // Base URI so we'll create a single login
-                try {
-                    logins.put(new URI(baseUri), new FormLogin(loginURL, userField, pwdField, user, password.toCharArray()));
-                } catch (URISyntaxException e) {
-                    throw new SQLException("Unable to configure form based login due to invalid Base URI", e);
-                }
-            } else {
-                // Only one endpoint is specified or they did not share a common
-                // base
-                if (queryEndpoint != null) {
-                    // Add a query endpoint specific login
-                    try {
-                        logins.put(new URI(queryEndpoint),
-                                new FormLogin(loginURL, userField, pwdField, user, password.toCharArray()));
-                    } catch (URISyntaxException e) {
-                        throw new SQLException("Unable to configure form based login due to invalid Query Endpoint URI", e);
-                    }
-                }
-                if (updateEndpoint != null) {
-                    // Add an update endpoint specific login
-                    try {
-                        logins.put(new URI(updateEndpoint),
-                                new FormLogin(loginURL, userField, pwdField, user, password.toCharArray()));
-                    } catch (URISyntaxException e) {
-                        throw new SQLException("Unable to configure form based login due to invalid Update Endpoint URI", e);
-                    }
-                }
-            }
-            return new FormsAuthenticator(logins);
-        } else {
-            // Do we want preemptive authentication?
-            if (this.isTrue(props, PARAM_PREEMPTIVE_AUTH)) {
-                return new PreemptiveBasicAuthenticator(new SimpleAuthenticator(user, password.toCharArray()));
-            } else {
-                // Use simple authenticator
-                return new SimpleAuthenticator(user, password.toCharArray());
-            }
+        // If credentials then we use them
+        if (user != null && password != null) {
+            BasicCredentialsProvider credsProv = new BasicCredentialsProvider();
+            credsProv.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(user, password));
+            return HttpClients.custom().setDefaultCredentialsProvider(credsProv).build();
+        }
+        // else use a supplied or default client
+        Object client = props.get(PARAM_CLIENT);
+        if (client != null) {
+            if (!(client instanceof HttpClient)) throw new SQLException("The " + PARAM_CLIENT
+                    + " parameter is specified but the value is not an object implementing the required HttpClient interface");
+            return (HttpClient) client;
         }
+        return null;
     }
 
+
     /**
      * Determines the common base of the two URIs if there is one. The common
      * base will have irrelevant components (fragment and query string) stripped
@@ -522,10 +430,10 @@ private String stripIrrelevantComponents(String input) {
      * @throws SQLException
      */
     protected RemoteEndpointConnection openConnection(String queryEndpoint, String updateEndpoint, List<String> defaultGraphs,
-            List<String> namedGraphs, List<String> usingGraphs, List<String> usingNamedGraphs, HttpAuthenticator authenticator,
+            List<String> namedGraphs, List<String> usingGraphs, List<String> usingNamedGraphs, HttpClient client,
             int holdability, int compatibilityLevel, String selectResultsType, String modelResultsType) throws SQLException {
         return new RemoteEndpointConnection(queryEndpoint, updateEndpoint, defaultGraphs, namedGraphs, usingGraphs,
-                usingNamedGraphs, authenticator, holdability, compatibilityLevel, selectResultsType, modelResultsType);
+                usingNamedGraphs, client, holdability, compatibilityLevel, selectResultsType, modelResultsType);
     }
 
     @Override
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/connections/RemoteEndpointConnection.java b/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/connections/RemoteEndpointConnection.java
index 85a0115615..c39a76c8fc 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/connections/RemoteEndpointConnection.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/connections/RemoteEndpointConnection.java
@@ -25,7 +25,7 @@
 import java.sql.SQLFeatureNotSupportedException;
 import java.util.List;
 
-import org.apache.jena.atlas.web.auth.HttpAuthenticator;
+import org.apache.http.client.HttpClient;
 import org.apache.jena.jdbc.JdbcCompatibility;
 import org.apache.jena.jdbc.connections.JenaConnection;
 import org.apache.jena.jdbc.remote.metadata.RemoteEndpointMetadata;
@@ -47,7 +47,7 @@ public class RemoteEndpointConnection extends JenaConnection {
     private List<String> namedGraphUris;
     private List<String> usingGraphUris;
     private List<String> usingNamedGraphUris;
-    private HttpAuthenticator authenticator;
+    private HttpClient client;
     private DatabaseMetaData metadata;
     private String selectResultsType, modelResultsType;
 
@@ -85,8 +85,8 @@ public RemoteEndpointConnection(String queryEndpoint, String updateEndpoint, int
      *            Default Graph URIs for SPARQL updates
      * @param usingNamedGraphUris
      *            Named Graph URIs for SPARQL updates
-     * @param authenticator
-     *            HTTP Authenticator
+     * @param client
+     *            HTTP client
      * @param holdability
      *            Result Set holdability
      * @param compatibilityLevel
@@ -102,7 +102,7 @@ public RemoteEndpointConnection(String queryEndpoint, String updateEndpoint, int
      */
     public RemoteEndpointConnection(String queryEndpoint, String updateEndpoint, List<String> defaultGraphUris,
             List<String> namedGraphUris, List<String> usingGraphUris, List<String> usingNamedGraphUris,
-            HttpAuthenticator authenticator, int holdability, int compatibilityLevel, String selectResultsType,
+            HttpClient client, int holdability, int compatibilityLevel, String selectResultsType,
             String modelResultsType) throws SQLException {
         super(holdability, true, Connection.TRANSACTION_NONE, compatibilityLevel);
         if (queryEndpoint == null && updateEndpoint == null)
@@ -114,7 +114,7 @@ public RemoteEndpointConnection(String queryEndpoint, String updateEndpoint, Lis
         this.namedGraphUris = namedGraphUris;
         this.usingGraphUris = usingGraphUris;
         this.usingNamedGraphUris = usingNamedGraphUris;
-        this.authenticator = authenticator;
+        this.client = client;
         this.metadata = new RemoteEndpointMetadata(this);
         this.selectResultsType = selectResultsType;
         this.modelResultsType = modelResultsType;
@@ -211,7 +211,7 @@ protected JenaStatement createStatementInternal(int resultSetType, int resultSet
                     "Remote endpoint backed connection do not support scroll sensitive result sets");
         if (resultSetConcurrency != ResultSet.CONCUR_READ_ONLY)
             throw new SQLFeatureNotSupportedException("Remote endpoint backed connections only support read-only result sets");
-        return new RemoteEndpointStatement(this, this.authenticator, resultSetType, ResultSet.FETCH_FORWARD, 0,
+        return new RemoteEndpointStatement(this, this.client, resultSetType, ResultSet.FETCH_FORWARD, 0,
                 resultSetHoldability);
     }
 
@@ -225,7 +225,7 @@ protected JenaPreparedStatement createPreparedStatementInternal(String sparql, i
                     "Remote endpoint backed connection do not support scroll sensitive result sets");
         if (resultSetConcurrency != ResultSet.CONCUR_READ_ONLY)
             throw new SQLFeatureNotSupportedException("Remote endpoint backed connections only support read-only result sets");
-        return new RemoteEndpointPreparedStatement(sparql, this, this.authenticator, resultSetType, ResultSet.FETCH_FORWARD, 0,
+        return new RemoteEndpointPreparedStatement(sparql, this, this.client, resultSetType, ResultSet.FETCH_FORWARD, 0,
                 resultSetHoldability);
     }
 
@@ -281,15 +281,4 @@ protected void checkTransactionIsolation(int level) throws SQLException {
             throw new SQLFeatureNotSupportedException("Transactions are not supported for remote endpoint backed connections");
         }
     }
-
-    /**
-     * Gets whether any HTTP authenticator has been provided. Note that the
-     * provision of an authenticator does not guarantee authentication since
-     * that will be down to the configuration of the given authenticator.
-     * 
-     * @return True if an authenticator is provided, false otherwise
-     */
-    public boolean isUsingAuthentication() {
-        return this.authenticator != null;
-    }
 }
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/statements/RemoteEndpointPreparedStatement.java b/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/statements/RemoteEndpointPreparedStatement.java
index 5d923d98c0..347b1dcd80 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/statements/RemoteEndpointPreparedStatement.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/statements/RemoteEndpointPreparedStatement.java
@@ -22,7 +22,7 @@
 import java.sql.SQLException;
 import java.sql.SQLFeatureNotSupportedException;
 
-import org.apache.jena.atlas.web.auth.HttpAuthenticator;
+import org.apache.http.client.HttpClient;
 import org.apache.jena.jdbc.remote.connections.RemoteEndpointConnection;
 import org.apache.jena.jdbc.statements.JenaPreparedStatement;
 import org.apache.jena.query.Query ;
@@ -42,7 +42,7 @@
 public class RemoteEndpointPreparedStatement extends JenaPreparedStatement {
 
     private RemoteEndpointConnection remoteConn;
-    private HttpAuthenticator authenticator;
+    private HttpClient client;
 
     /**
      * Creates a new statement
@@ -65,8 +65,8 @@ public RemoteEndpointPreparedStatement(String sparql, RemoteEndpointConnection c
      *            SPARQL command
      * @param connection
      *            Connection
-     * @param authenticator
-     *            HTTP Authenticator
+     * @param client
+     *            HTTP client
      * @param type
      *            Result Set type for result sets produced by this statement
      * @param fetchDir
@@ -79,11 +79,11 @@ public RemoteEndpointPreparedStatement(String sparql, RemoteEndpointConnection c
      *             Thrown if there is an error with the statement parameters
      * 
      */
-    public RemoteEndpointPreparedStatement(String sparql, RemoteEndpointConnection connection, HttpAuthenticator authenticator,
+    public RemoteEndpointPreparedStatement(String sparql, RemoteEndpointConnection connection, HttpClient client,
             int type, int fetchDir, int fetchSize, int holdability) throws SQLException {
         super(sparql, connection, type, fetchDir, fetchSize, holdability, false, Connection.TRANSACTION_NONE);
         this.remoteConn = connection;
-        this.authenticator = authenticator;
+        this.client = client;
     }
 
     @Override
@@ -94,9 +94,9 @@ protected QueryExecution createQueryExecution(Query q) throws SQLException {
         // Create basic execution
         QueryEngineHTTP exec = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(this.remoteConn.getQueryEndpoint(), q);
 
-        // Apply authentication settings
-        if (this.authenticator != null) {
-            exec.setAuthenticator(this.authenticator);
+        // Apply HTTP settings
+        if (this.client != null) {
+            exec.setClient(this.client);
         }
 
         // Apply default and named graphs if appropriate
@@ -124,9 +124,9 @@ protected UpdateProcessor createUpdateProcessor(UpdateRequest u) {
         UpdateProcessRemoteBase proc = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(u,
                 this.remoteConn.getUpdateEndpoint());
 
-        // Apply authentication settings
-        if (this.authenticator != null) {
-            proc.setAuthenticator(this.authenticator);
+        // Apply HTTP settings
+        if (this.client != null) {
+            proc.setClient(this.client);
         }
 
         // Apply default and named graphs if appropriate
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/statements/RemoteEndpointStatement.java b/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/statements/RemoteEndpointStatement.java
index 1f08e453e8..5fa5c7e242 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/statements/RemoteEndpointStatement.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/main/java/org/apache/jena/jdbc/remote/statements/RemoteEndpointStatement.java
@@ -22,7 +22,7 @@
 import java.sql.SQLException;
 import java.sql.SQLFeatureNotSupportedException;
 
-import org.apache.jena.atlas.web.auth.HttpAuthenticator;
+import org.apache.http.client.HttpClient;
 import org.apache.jena.jdbc.remote.connections.RemoteEndpointConnection;
 import org.apache.jena.jdbc.statements.JenaStatement;
 import org.apache.jena.query.Query ;
@@ -42,7 +42,7 @@
 public class RemoteEndpointStatement extends JenaStatement {
 
     private RemoteEndpointConnection remoteConn;
-    private HttpAuthenticator authenticator;
+    private HttpClient client;
 
     /**
      * Creates a new statement
@@ -63,7 +63,8 @@ public RemoteEndpointStatement(RemoteEndpointConnection connection) throws SQLEx
      *            Connection
      * @param type
      *            Result Set type for result sets produced by this statement
-     * @param authenticator HTTP Authenticator
+     * @param client
+     *            HTTP client
      * @param fetchDir
      *            Fetch Direction
      * @param fetchSize
@@ -74,11 +75,11 @@ public RemoteEndpointStatement(RemoteEndpointConnection connection) throws SQLEx
      *             Thrown if there is an error with the statement parameters
      * 
      */
-    public RemoteEndpointStatement(RemoteEndpointConnection connection, HttpAuthenticator authenticator, int type, int fetchDir,
+    public RemoteEndpointStatement(RemoteEndpointConnection connection, HttpClient client, int type, int fetchDir,
             int fetchSize, int holdability) throws SQLException {
         super(connection, type, fetchDir, fetchSize, holdability, false, Connection.TRANSACTION_NONE);
         this.remoteConn = connection;
-        this.authenticator = authenticator;
+        this.client = client;
     }
 
     @Override
@@ -89,9 +90,9 @@ protected QueryExecution createQueryExecution(Query q) throws SQLException {
         // Create basic execution
         QueryEngineHTTP exec = (QueryEngineHTTP) QueryExecutionFactory.sparqlService(this.remoteConn.getQueryEndpoint(), q);
 
-        // Apply authentication settings
-        if (this.authenticator != null) {
-            exec.setAuthenticator(authenticator);
+        // Apply HTTP settings
+        if (this.client != null) {
+            exec.setClient(client);
         }
 
         // Apply default and named graphs if appropriate
@@ -119,9 +120,9 @@ protected UpdateProcessor createUpdateProcessor(UpdateRequest u) {
         UpdateProcessRemoteBase proc = (UpdateProcessRemoteBase) UpdateExecutionFactory.createRemote(u,
                 this.remoteConn.getUpdateEndpoint());
 
-        // Apply authentication settings
-        if (this.authenticator != null) {
-            proc.setAuthenticator(this.authenticator);
+        // Apply HTTP settings
+        if (this.client != null) {
+            proc.setClient(this.client);
         }
 
         // Apply default and named graphs if appropriate
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/TS_JdbcDriverRemote.java b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/TS_JdbcDriverRemote.java
index b29bc9dbcf..372f379187 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/TS_JdbcDriverRemote.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/TS_JdbcDriverRemote.java
@@ -17,6 +17,7 @@
  */
 package org.apache.jena.jdbc.remote;
 
+import org.apache.jena.fuseki.ServerCtl ;
 import org.apache.jena.jdbc.remote.connections.TestRemoteEndpointConnection;
 import org.apache.jena.jdbc.remote.connections.TestRemoteEndpointConnectionWithAuth;
 import org.apache.jena.jdbc.remote.connections.TestRemoteEndpointConnectionWithGraphUris;
@@ -27,6 +28,8 @@
 import org.apache.jena.jdbc.remote.results.TestRemoteEndpointResultsWithGraphUris;
 import org.apache.jena.jdbc.remote.results.TestRemoteEndpointResultsWithResultSetTypes;
 import org.apache.jena.jdbc.remote.statements.TestRemoteEndpointStatements;
+import org.junit.AfterClass;
+import org.junit.BeforeClass;
 import org.junit.runner.RunWith;
 import org.junit.runners.Suite;
 
@@ -37,12 +40,15 @@
 @RunWith(Suite.class)
 @Suite.SuiteClasses({
     TestRemoteEndpointDriver.class,
+    
     TestRemoteEndpointConnection.class,
     TestRemoteEndpointConnectionWithAuth.class,
     TestRemoteEndpointConnectionWithGraphUris.class,
-    TestRemoteEndpointConnectionWithResultSetTypes.class,
+    TestRemoteEndpointConnectionWithResultSetTypes.class
+    ,
     TestRemoteConnectionMetadata.class,
-    TestRemoteEndpointStatements.class,
+    TestRemoteEndpointStatements.class
+    ,
     TestRemoteEndpointResults.class,
     TestRemoteEndpointResultsWithAuth.class,
     TestRemoteEndpointResultsWithGraphUris.class,
@@ -51,4 +57,14 @@
 
 
 public class TS_JdbcDriverRemote {
+
+    @BeforeClass
+    public static void beforeClassAbstract1() {
+        ServerCtl.ctlBeforeTestSuite() ;
+    }
+
+    @AfterClass
+    public static void afterClassAbstract1() {
+        ServerCtl.ctlAfterTestSuite() ;
+    }
 }
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/AbstractRemoteEndpointConnectionTests.java b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/AbstractRemoteEndpointConnectionTests.java
index 8d7e83c2ff..ea66abb8bd 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/AbstractRemoteEndpointConnectionTests.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/AbstractRemoteEndpointConnectionTests.java
@@ -15,20 +15,12 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 package org.apache.jena.jdbc.remote.connections;
 
-import org.apache.jena.fuseki.Fuseki;
 import org.apache.jena.jdbc.connections.AbstractJenaConnectionTests;
 
 /**
  * Abstract tests for remote endpoint driver connections
- *
  */
 public abstract class AbstractRemoteEndpointConnectionTests extends AbstractJenaConnectionTests {
-    
-    static {
-        Fuseki.init();
-    }
-
 }
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnection.java b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnection.java
index 21ce9e1d48..dcc4f3c2c1 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnection.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnection.java
@@ -20,14 +20,15 @@
 
 import java.sql.SQLException;
 
+import org.apache.jena.fuseki.ServerCtl ;
 import org.apache.jena.fuseki.ServerTest;
 import org.apache.jena.jdbc.JdbcCompatibility;
 import org.apache.jena.jdbc.connections.JenaConnection;
-import org.apache.jena.jdbc.remote.connections.RemoteEndpointConnection;
 import org.apache.jena.jdbc.utils.TestUtils;
 import org.apache.jena.query.Dataset ;
 import org.junit.After;
 import org.junit.AfterClass;
+import org.junit.Before ;
 import org.junit.BeforeClass;
 
 /**
@@ -36,29 +37,10 @@
  */
 public class TestRemoteEndpointConnection extends AbstractRemoteEndpointConnectionTests {
         
-    /**
-     * Setup for the tests by allocating a Fuseki instance to work with
-     */
-    @BeforeClass
-    public static void setup() {
-        ServerTest.allocServer();
-    }
-    
-    /**
-     * Clean up after each test by resetting the Fuseki instance
-     */
-    @After
-    public void cleanupTest() {
-        ServerTest.resetServer();
-    }
-    
-    /**
-     * Clean up after tests by de-allocating the Fuseki instance
-     */
-    @AfterClass
-    public static void cleanup() {
-        ServerTest.freeServer();
-    }
+    @BeforeClass public static void ctlBeforeClass() { ServerCtl.ctlBeforeClass(); }
+    @AfterClass  public static void ctlAfterClass()  { ServerCtl.ctlAfterClass(); }
+    @Before      public void ctlBeforeTest()         { ServerCtl.ctlBeforeTest(); }
+    @After       public void ctlAfterTest()          { ServerCtl.ctlAfterTest(); } 
     
     @Override
     protected boolean supportsTimeouts() {
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnectionWithAuth.java b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnectionWithAuth.java
index 2355c7a45f..62a76def78 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnectionWithAuth.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnectionWithAuth.java
@@ -23,8 +23,11 @@
 import java.io.IOException ;
 import java.sql.SQLException ;
 
-import org.apache.jena.atlas.web.auth.HttpAuthenticator ;
-import org.apache.jena.atlas.web.auth.SimpleAuthenticator ;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.HttpClient;
+import org.apache.http.impl.client.BasicCredentialsProvider;
+import org.apache.http.impl.client.HttpClients;
 import org.apache.jena.fuseki.ServerTest ;
 import org.apache.jena.fuseki.server.FusekiConfig ;
 import org.apache.jena.fuseki.server.SPARQLServer ;
@@ -57,7 +60,7 @@ public class TestRemoteEndpointConnectionWithAuth extends AbstractRemoteEndpoint
     private static String PASSWORD = "letmein";
     private static File realmFile;
     private static SPARQLServer server;
-    private static HttpAuthenticator authenticator;
+    private static HttpClient client;
 
     /**
      * Setup for the tests by allocating a Fuseki instance to work with
@@ -65,8 +68,10 @@ public class TestRemoteEndpointConnectionWithAuth extends AbstractRemoteEndpoint
      */
     @BeforeClass
     public static void setup() throws IOException {
-        authenticator = new SimpleAuthenticator(USER, PASSWORD.toCharArray());
-        
+        BasicCredentialsProvider credsProv = new BasicCredentialsProvider();
+        credsProv.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(USER, PASSWORD));
+        client = HttpClients.custom().setDefaultCredentialsProvider(credsProv).build();
+
         realmFile = File.createTempFile("realm", ".properties");
 
         try(FileWriter writer = new FileWriter(realmFile)) {
@@ -74,6 +79,7 @@ public static void setup() throws IOException {
         }
 
         DatasetGraph dsg = DatasetGraphFactory.create();
+
         // This must agree with ServerTest
         ServerConfig conf = FusekiConfig.defaultConfiguration(ServerTest.datasetPath, dsg, true, false);
         conf.port = ServerTest.port;
@@ -90,7 +96,7 @@ public static void setup() throws IOException {
     @After
     public void cleanupTest() {
         Update clearRequest = new UpdateDrop(Target.ALL) ;
-        UpdateProcessor proc = UpdateExecutionFactory.createRemote(clearRequest, ServerTest.serviceUpdate, authenticator) ;
+        UpdateProcessor proc = UpdateExecutionFactory.createRemote(clearRequest, ServerTest.serviceUpdate, client) ;
         proc.execute() ;
     }
 
@@ -113,16 +119,16 @@ protected boolean supportsTimeouts() {
     @Override
     protected JenaConnection getConnection() throws SQLException {
         return new RemoteEndpointConnection(ServerTest.serviceQuery, ServerTest.serviceUpdate, null, null, null, null,
-                authenticator, JenaConnection.DEFAULT_HOLDABILITY,
+                client, JenaConnection.DEFAULT_HOLDABILITY,
                 JdbcCompatibility.DEFAULT, null, null);
     }
 
     @Override
     protected JenaConnection getConnection(Dataset ds) throws SQLException {
         // Set up the dataset
-        TestUtils.copyToRemoteDataset(ds, ServerTest.serviceREST, authenticator);
+        TestUtils.copyToRemoteDataset(ds, ServerTest.serviceREST, client);
         return new RemoteEndpointConnection(ServerTest.serviceQuery, ServerTest.serviceUpdate, null, null, null, null,
-                authenticator, JenaConnection.DEFAULT_HOLDABILITY,
+                client, JenaConnection.DEFAULT_HOLDABILITY,
                 JdbcCompatibility.DEFAULT, null, null);
     }
 }
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnectionWithGraphUris.java b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnectionWithGraphUris.java
index f01cd3fac7..b6183e1d5b 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnectionWithGraphUris.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnectionWithGraphUris.java
@@ -23,16 +23,13 @@
 import java.util.Iterator;
 import java.util.List;
 
+import org.apache.jena.fuseki.ServerCtl ;
 import org.apache.jena.fuseki.ServerTest;
 import org.apache.jena.jdbc.JdbcCompatibility;
 import org.apache.jena.jdbc.connections.JenaConnection;
-import org.apache.jena.jdbc.remote.connections.RemoteEndpointConnection;
 import org.apache.jena.jdbc.utils.TestUtils;
 import org.apache.jena.query.Dataset ;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Assert;
-import org.junit.BeforeClass;
+import org.junit.* ;
 
 /**
  * Tests for the {@link RemoteEndpointConnection} where we force the default
@@ -47,29 +44,10 @@ public class TestRemoteEndpointConnectionWithGraphUris extends AbstractRemoteEnd
      */
     private static final String DEFAULT_GRAPH_URI = "http://example.org/defaultGraph";
 
-    /**
-     * Setup for the tests by allocating a Fuseki instance to work with
-     */
-    @BeforeClass
-    public static void setup() {
-        ServerTest.allocServer();
-    }
-
-    /**
-     * Clean up after each test by resetting the Fuseki instance
-     */
-    @After
-    public void cleanupTest() {
-        ServerTest.resetServer();
-    }
-
-    /**
-     * Clean up after tests by de-allocating the Fuseki instance
-     */
-    @AfterClass
-    public static void cleanup() {
-        ServerTest.freeServer();
-    }
+    @BeforeClass public static void ctlBeforeClass() { ServerCtl.ctlBeforeClass(); }
+    @AfterClass  public static void ctlAfterClass()  { ServerCtl.ctlAfterClass(); }
+    @Before      public void ctlBeforeTest()         { ServerCtl.ctlBeforeTest(); }
+    @After       public void ctlAfterTest()          { ServerCtl.ctlAfterTest(); } 
 
     @Override
     protected boolean supportsTimeouts() {
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnectionWithResultSetTypes.java b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnectionWithResultSetTypes.java
index e0478cc682..0fbb1482e0 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnectionWithResultSetTypes.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/connections/TestRemoteEndpointConnectionWithResultSetTypes.java
@@ -20,15 +20,16 @@
 
 import java.sql.SQLException;
 
+import org.apache.jena.fuseki.ServerCtl ;
 import org.apache.jena.fuseki.ServerTest;
 import org.apache.jena.jdbc.JdbcCompatibility;
 import org.apache.jena.jdbc.connections.JenaConnection;
-import org.apache.jena.jdbc.remote.connections.RemoteEndpointConnection;
 import org.apache.jena.jdbc.utils.TestUtils;
 import org.apache.jena.query.Dataset ;
 import org.apache.jena.riot.WebContent;
 import org.junit.After;
 import org.junit.AfterClass;
+import org.junit.Before ;
 import org.junit.BeforeClass;
 
 /**
@@ -37,29 +38,10 @@
  */
 public class TestRemoteEndpointConnectionWithResultSetTypes extends AbstractRemoteEndpointConnectionTests {
         
-    /**
-     * Setup for the tests by allocating a Fuseki instance to work with
-     */
-    @BeforeClass
-    public static void setup() {
-        ServerTest.allocServer();
-    }
-    
-    /**
-     * Clean up after each test by resetting the Fuseki instance
-     */
-    @After
-    public void cleanupTest() {
-        ServerTest.resetServer();
-    }
-    
-    /**
-     * Clean up after tests by de-allocating the Fuseki instance
-     */
-    @AfterClass
-    public static void cleanup() {
-        ServerTest.freeServer();
-    }
+    @BeforeClass public static void ctlBeforeClass() { ServerCtl.ctlBeforeClass(); }
+    @AfterClass  public static void ctlAfterClass()  { ServerCtl.ctlAfterClass(); }
+    @Before      public void ctlBeforeTest()         { ServerCtl.ctlBeforeTest(); }
+    @After       public void ctlAfterTest()          { ServerCtl.ctlAfterTest(); } 
     
     @Override
     protected boolean supportsTimeouts() {
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/metadata/TestRemoteConnectionMetadata.java b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/metadata/TestRemoteConnectionMetadata.java
index 65b11107da..e3e6c86571 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/metadata/TestRemoteConnectionMetadata.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/metadata/TestRemoteConnectionMetadata.java
@@ -23,7 +23,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import org.apache.jena.fuseki.Fuseki;
+import org.apache.jena.fuseki.ServerCtl ;
 import org.apache.jena.fuseki.ServerTest;
 import org.apache.jena.jdbc.JdbcCompatibility;
 import org.apache.jena.jdbc.connections.JenaConnection;
@@ -31,6 +31,7 @@
 import org.apache.jena.jdbc.remote.connections.RemoteEndpointConnection;
 import org.junit.After;
 import org.junit.AfterClass;
+import org.junit.Before ;
 import org.junit.BeforeClass;
 
 /**
@@ -39,33 +40,10 @@
  */
 public class TestRemoteConnectionMetadata extends AbstractDatabaseMetadataTests {
     
-    static {
-        Fuseki.init();
-    }
-
-    /**
-     * Setup for the tests by allocating a Fuseki instance to work with
-     */
-    @BeforeClass
-    public static void setup() {
-        ServerTest.allocServer();
-    }
-    
-    /**
-     * Clean up after each test by resetting the Fuseki instance
-     */
-    @After
-    public void cleanupTest() {
-        ServerTest.resetServer();
-    }
-    
-    /**
-     * Clean up after tests by de-allocating the Fuseki instance
-     */
-    @AfterClass
-    public static void cleanup() {
-        ServerTest.freeServer();
-    }
+    @BeforeClass public static void ctlBeforeClass() { ServerCtl.ctlBeforeClass(); }
+    @AfterClass  public static void ctlAfterClass()  { ServerCtl.ctlAfterClass(); }
+    @Before      public void ctlBeforeTest()         { ServerCtl.ctlBeforeTest(); }
+    @After       public void ctlAfterTest()          { ServerCtl.ctlAfterTest(); } 
 
     @Override
     protected JenaConnection getConnection() throws SQLException {
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/AbstractRemoteEndpointResultSetTests.java b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/AbstractRemoteEndpointResultSetTests.java
index 53d507bfc4..085ad10d96 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/AbstractRemoteEndpointResultSetTests.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/AbstractRemoteEndpointResultSetTests.java
@@ -21,7 +21,6 @@
 import org.apache.http.client.HttpClient;
 import org.apache.jena.fuseki.Fuseki;
 import org.apache.jena.jdbc.results.AbstractResultSetTests;
-import org.apache.jena.query.ARQ ;
 import org.apache.jena.riot.web.HttpOp;
 import org.apache.jena.system.JenaSystem ;
 import org.junit.AfterClass;
@@ -35,12 +34,12 @@ public abstract class AbstractRemoteEndpointResultSetTests extends AbstractResul
 
 	static HttpClient defaultHttpClient = HttpOp.getDefaultHttpClient() ;
 	// Used for all tests except auth tests.
-	static HttpClient globalCachingClient = HttpOp.createCachingHttpClient() ;
+	static HttpClient globalPoolingClient = HttpOp.createPoolingHttpClient() ;
 	
 	@BeforeClass public static void beforeClassAbstract1() {
         JenaSystem.init() ;
         Fuseki.init();
-		HttpOp.setDefaultHttpClient(globalCachingClient) ;
+		HttpOp.setDefaultHttpClient(globalPoolingClient) ;
     }
 	
 	@AfterClass public static void afterClassAbstract1() {
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResults.java b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResults.java
index 0418858fef..fe56c28356 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResults.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResults.java
@@ -22,6 +22,7 @@
 import java.sql.SQLException;
 import java.sql.Statement;
 
+import org.apache.jena.fuseki.ServerCtl ;
 import org.apache.jena.fuseki.ServerTest;
 import org.apache.jena.jdbc.JdbcCompatibility;
 import org.apache.jena.jdbc.connections.JenaConnection;
@@ -30,6 +31,7 @@
 import org.apache.jena.query.Dataset ;
 import org.junit.After;
 import org.junit.AfterClass;
+import org.junit.Before ;
 import org.junit.BeforeClass;
 
 /**
@@ -40,25 +42,22 @@ public class TestRemoteEndpointResults extends AbstractRemoteEndpointResultSetTe
     
     private static RemoteEndpointConnection connection;
     
+    //@BeforeClass public static void ctlBeforeClass() { ServerCtl.ctlBeforeClass(); }
+    //@AfterClass  public static void ctlAfterClass()  { ServerCtl.ctlAfterClass(); }
+    @Before      public void ctlBeforeTest()         { ServerCtl.ctlBeforeTest(); }
+    @After       public void ctlAfterTest()          { ServerCtl.ctlAfterTest(); } 
+
     /**
      * Setup for the tests by allocating a Fuseki instance to work with
      * @throws SQLException 
      */
     @BeforeClass
     public static void setup() throws SQLException {
-    	ServerTest.allocServer();
-        
+        ServerCtl.ctlBeforeClass();
         connection = new RemoteEndpointConnection(ServerTest.serviceQuery, ServerTest.serviceUpdate, JenaConnection.DEFAULT_HOLDABILITY, JdbcCompatibility.DEFAULT);
         connection.setJdbcCompatibilityLevel(JdbcCompatibility.HIGH);
     }
     
-    /**
-     * Clean up after each test by resetting the Fuseki instance
-     */
-    @After
-    public void cleanupTest() {
-        ServerTest.resetServer();
-    }
     /**
      * Clean up after tests by de-allocating the Fuseki instance
      * @throws SQLException 
@@ -66,7 +65,7 @@ public void cleanupTest() {
     @AfterClass
     public static void cleanup() throws SQLException {
         connection.close();
-        ServerTest.freeServer();
+        ServerCtl.ctlAfterClass();
     }
 
     @Override
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResultsWithAuth.java b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResultsWithAuth.java
index 8295116944..f4241e5398 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResultsWithAuth.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResultsWithAuth.java
@@ -25,8 +25,11 @@
 import java.sql.SQLException;
 import java.sql.Statement;
 
-import org.apache.jena.atlas.web.auth.HttpAuthenticator;
-import org.apache.jena.atlas.web.auth.SimpleAuthenticator;
+import org.apache.http.auth.AuthScope;
+import org.apache.http.auth.UsernamePasswordCredentials;
+import org.apache.http.client.HttpClient;
+import org.apache.http.impl.client.BasicCredentialsProvider;
+import org.apache.http.impl.client.HttpClients;
 import org.apache.jena.fuseki.ServerTest;
 import org.apache.jena.fuseki.server.FusekiConfig;
 import org.apache.jena.fuseki.server.SPARQLServer;
@@ -61,7 +64,7 @@ public class TestRemoteEndpointResultsWithAuth extends AbstractRemoteEndpointRes
     private static String PASSWORD = "letmein";
     private static File realmFile;
     private static SPARQLServer server;
-    private static HttpAuthenticator authenticator;
+    private static HttpClient client;
 
     /**
      * Setup for the tests by allocating a Fuseki instance to work with
@@ -71,7 +74,10 @@ public class TestRemoteEndpointResultsWithAuth extends AbstractRemoteEndpointRes
      */
     @BeforeClass
     public static void setup() throws SQLException, IOException {
-        authenticator = new SimpleAuthenticator(USER, PASSWORD.toCharArray());
+
+        BasicCredentialsProvider credsProv = new BasicCredentialsProvider();
+        credsProv.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(USER, PASSWORD));
+        client = HttpClients.custom().setDefaultCredentialsProvider(credsProv).build();
 
         realmFile = File.createTempFile("realm", ".properties");
 
@@ -80,6 +86,7 @@ public static void setup() throws SQLException, IOException {
         }
 
         DatasetGraph dsg = DatasetGraphFactory.create();
+
         // This must agree with ServerTest
         ServerConfig conf = FusekiConfig.defaultConfiguration(ServerTest.datasetPath, dsg, true, false);
         conf.port = ServerTest.port;
@@ -90,7 +97,7 @@ public static void setup() throws SQLException, IOException {
         server.start();
 
         connection = new RemoteEndpointConnection(ServerTest.serviceQuery, ServerTest.serviceUpdate, null, null, null, null,
-                authenticator, JenaConnection.DEFAULT_HOLDABILITY, JdbcCompatibility.DEFAULT, null, null);
+                client, JenaConnection.DEFAULT_HOLDABILITY, JdbcCompatibility.DEFAULT, null, null);
         connection.setJdbcCompatibilityLevel(JdbcCompatibility.HIGH);
     }
 
@@ -100,7 +107,7 @@ public static void setup() throws SQLException, IOException {
     @After
     public void cleanupTest() {
         Update clearRequest = new UpdateDrop(Target.ALL) ;
-        UpdateProcessor proc = UpdateExecutionFactory.createRemote(clearRequest, ServerTest.serviceUpdate, authenticator) ;
+        UpdateProcessor proc = UpdateExecutionFactory.createRemote(clearRequest, ServerTest.serviceUpdate, client) ;
         proc.execute() ;
     }
 
@@ -126,7 +133,7 @@ protected ResultSet createResults(Dataset ds, String query) throws SQLException
 
     @Override
     protected ResultSet createResults(Dataset ds, String query, int resultSetType) throws SQLException {
-        TestUtils.copyToRemoteDataset(ds, ServerTest.serviceREST, authenticator);
+        TestUtils.copyToRemoteDataset(ds, ServerTest.serviceREST, client);
         Statement stmt = connection.createStatement(resultSetType, ResultSet.CONCUR_READ_ONLY);
         return stmt.executeQuery(query);
     }
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResultsWithGraphUris.java b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResultsWithGraphUris.java
index 67c399d490..7d7e5549ef 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResultsWithGraphUris.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResultsWithGraphUris.java
@@ -21,9 +21,10 @@
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Statement;
-import java.util.ArrayList;
 import java.util.List;
 
+import org.apache.jena.ext.com.google.common.collect.Lists;
+import org.apache.jena.fuseki.ServerCtl ;
 import org.apache.jena.fuseki.ServerTest;
 import org.apache.jena.jdbc.JdbcCompatibility;
 import org.apache.jena.jdbc.connections.JenaConnection;
@@ -32,6 +33,7 @@
 import org.apache.jena.query.Dataset ;
 import org.junit.After;
 import org.junit.AfterClass;
+import org.junit.Before ;
 import org.junit.BeforeClass;
 
 /**
@@ -40,6 +42,12 @@
  */
 public class TestRemoteEndpointResultsWithGraphUris extends AbstractRemoteEndpointResultSetTests {
     
+    //@BeforeClass public static void ctlBeforeClass() { ServerCtl.ctlBeforeClass(); }
+    //@AfterClass  public static void ctlAfterClass()  { ServerCtl.ctlAfterClass(); }
+    @Before      public void ctlBeforeTest()  { ServerCtl.ctlBeforeTest(); }
+    @After       public void ctlAfterTest()   { ServerCtl.ctlAfterTest(); } 
+
+
     /**
      * Constant for default graph URI used in these tests
      */
@@ -53,22 +61,12 @@ public class TestRemoteEndpointResultsWithGraphUris extends AbstractRemoteEndpoi
      */
     @BeforeClass
     public static void setup() throws SQLException {
-        ServerTest.allocServer();
-        
-        List<String> defaultGraphUris = new ArrayList<String>();
-        defaultGraphUris.add(DEFAULT_GRAPH_URI);
+        ServerCtl.ctlBeforeClass();
+        List<String> defaultGraphUris = Lists.newArrayList(DEFAULT_GRAPH_URI);
         connection = new RemoteEndpointConnection(ServerTest.serviceQuery, ServerTest.serviceUpdate, defaultGraphUris, null, defaultGraphUris, null, null, JenaConnection.DEFAULT_HOLDABILITY, JdbcCompatibility.DEFAULT, null, null);
         connection.setJdbcCompatibilityLevel(JdbcCompatibility.HIGH);
     }
     
-    /**
-     * Clean up after each test by resetting the Fuseki instance
-     */
-    @After
-    public void cleanupTest() {
-        ServerTest.resetServer();
-    }
-    
     /**
      * Clean up after tests by de-allocating the Fuseki instance
      * @throws SQLException 
@@ -76,7 +74,7 @@ public void cleanupTest() {
     @AfterClass
     public static void cleanup() throws SQLException {
         connection.close();
-        ServerTest.freeServer();
+        ServerCtl.ctlAfterClass();
     }
 
     @Override
@@ -91,6 +89,4 @@ protected ResultSet createResults(Dataset ds, String query, int resultSetType) t
         Statement stmt = connection.createStatement(resultSetType, ResultSet.CONCUR_READ_ONLY);
         return stmt.executeQuery(query);
     }
-    
-
 }
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResultsWithResultSetTypes.java b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResultsWithResultSetTypes.java
index 7367f2a384..5cc0b4c68b 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResultsWithResultSetTypes.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/results/TestRemoteEndpointResultsWithResultSetTypes.java
@@ -22,6 +22,7 @@
 import java.sql.SQLException;
 import java.sql.Statement;
 
+import org.apache.jena.fuseki.ServerCtl ;
 import org.apache.jena.fuseki.ServerTest;
 import org.apache.jena.jdbc.JdbcCompatibility;
 import org.apache.jena.jdbc.connections.JenaConnection;
@@ -31,6 +32,7 @@
 import org.apache.jena.riot.WebContent;
 import org.junit.After;
 import org.junit.AfterClass;
+import org.junit.Before ;
 import org.junit.BeforeClass;
 
 /**
@@ -38,7 +40,12 @@
  *
  */
 public class TestRemoteEndpointResultsWithResultSetTypes extends AbstractRemoteEndpointResultSetTests {
-    
+
+    //@BeforeClass public static void ctlBeforeClass() { ServerCtl.ctlBeforeClass(); }
+    //@AfterClass  public static void ctlAfterClass()  { ServerCtl.ctlAfterClass(); }
+    @Before      public void ctlBeforeTest()  { ServerCtl.ctlBeforeTest(); }
+    @After       public void ctlAfterTest()   { ServerCtl.ctlAfterTest(); } 
+
     private static RemoteEndpointConnection connection;
     
     /**
@@ -47,31 +54,19 @@ public class TestRemoteEndpointResultsWithResultSetTypes extends AbstractRemoteE
      */
     @BeforeClass
     public static void setup() throws SQLException {
-        ServerTest.allocServer();
-
+        ServerCtl.ctlBeforeClass();
         connection = new RemoteEndpointConnection(ServerTest.serviceQuery, ServerTest.serviceUpdate, null, null, null, null, null, JenaConnection.DEFAULT_HOLDABILITY, JdbcCompatibility.DEFAULT, WebContent.contentTypeTextTSV, WebContent.contentTypeRdfJson);
         connection.setJdbcCompatibilityLevel(JdbcCompatibility.HIGH);
     }
     
-    /**
-     * Clean up after each test by resetting the Fuseki instance
-     */
-    @After
-    public void cleanupTest() {
-        ServerTest.resetServer();
-    }
-    
     /**
      * Clean up after tests by de-allocating the Fuseki instance
      * @throws SQLException 
      */
     @AfterClass
     public static void cleanup() throws SQLException {
-        
-        // Sleep attempts to avoid a intermittent timing issue on the build server that can result in hung builds
-        
         connection.close();
-        ServerTest.freeServer();
+        ServerCtl.ctlAfterClass();
     }
 
     @Override
diff --git a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/statements/TestRemoteEndpointStatements.java b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/statements/TestRemoteEndpointStatements.java
index 4c6f52c4b8..b04fbaf058 100644
--- a/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/statements/TestRemoteEndpointStatements.java
+++ b/jena-jdbc/jena-jdbc-driver-remote/src/test/java/org/apache/jena/jdbc/remote/statements/TestRemoteEndpointStatements.java
@@ -20,7 +20,7 @@
 
 import java.sql.SQLException;
 
-import org.apache.jena.fuseki.Fuseki;
+import org.apache.jena.fuseki.ServerCtl ;
 import org.apache.jena.fuseki.ServerTest;
 import org.apache.jena.jdbc.JdbcCompatibility;
 import org.apache.jena.jdbc.connections.JenaConnection;
@@ -28,6 +28,7 @@
 import org.apache.jena.jdbc.statements.AbstractJenaStatementTests;
 import org.junit.After;
 import org.junit.AfterClass;
+import org.junit.Before ;
 import org.junit.BeforeClass;
 
 /**
@@ -35,34 +36,11 @@
  *
  */
 public class TestRemoteEndpointStatements extends AbstractJenaStatementTests {
-    
-    static {
-        Fuseki.init();
-    }
-        
-    /**
-     * Setup for the tests by allocating a Fuseki instance to work with
-     */
-    @BeforeClass
-    public static void setup() {
-        ServerTest.allocServer();
-    }
-    
-    /**
-     * Clean up after each test by resetting the Fuseki instance
-     */
-    @After
-    public void cleanupTest() {
-        ServerTest.resetServer();
-    }
-    
-    /**
-     * Clean up after tests by de-allocating the Fuseki instance
-     */
-    @AfterClass
-    public static void cleanup() {
-        ServerTest.freeServer();
-    }
+
+    @BeforeClass public static void ctlBeforeClass() { ServerCtl.ctlBeforeClass(); }
+    @AfterClass  public static void ctlAfterClass()  { ServerCtl.ctlAfterClass(); }
+    @Before      public void ctlBeforeTest()         { ServerCtl.ctlBeforeTest(); }
+    @After       public void ctlAfterTest()          { ServerCtl.ctlAfterTest(); } 
 
     @Override
     protected JenaConnection getConnection() throws SQLException {
