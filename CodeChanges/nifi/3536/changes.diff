diff --git a/nifi-api/src/main/java/org/apache/nifi/components/AbstractConfigurableComponent.java b/nifi-api/src/main/java/org/apache/nifi/components/AbstractConfigurableComponent.java
index d0e5a3b8dcc..25ffae5d126 100644
--- a/nifi-api/src/main/java/org/apache/nifi/components/AbstractConfigurableComponent.java
+++ b/nifi-api/src/main/java/org/apache/nifi/components/AbstractConfigurableComponent.java
@@ -84,12 +84,14 @@ public final Collection<ValidationResult> validate(final ValidationContext conte
         // goes through supported properties
         final Collection<ValidationResult> results = new ArrayList<>();
         final List<PropertyDescriptor> supportedDescriptors = getSupportedPropertyDescriptors();
+
         if (null != supportedDescriptors) {
             for (final PropertyDescriptor descriptor : supportedDescriptors) {
                 String value = context.getProperty(descriptor).getValue();
                 if (value == null) {
                     value = descriptor.getDefaultValue();
                 }
+
                 if (value == null && descriptor.isRequired()) {
                     String displayName = descriptor.getDisplayName();
                     ValidationResult.Builder builder = new ValidationResult.Builder().valid(false).input(null).subject(displayName != null ? displayName : descriptor.getName());
diff --git a/nifi-api/src/main/java/org/apache/nifi/components/ValidationContext.java b/nifi-api/src/main/java/org/apache/nifi/components/ValidationContext.java
index 444d1bd62a5..95a8c09649e 100644
--- a/nifi-api/src/main/java/org/apache/nifi/components/ValidationContext.java
+++ b/nifi-api/src/main/java/org/apache/nifi/components/ValidationContext.java
@@ -16,13 +16,14 @@
  */
 package org.apache.nifi.components;
 
-import java.util.Map;
-
 import org.apache.nifi.context.PropertyContext;
 import org.apache.nifi.controller.ControllerService;
 import org.apache.nifi.controller.ControllerServiceLookup;
 import org.apache.nifi.expression.ExpressionLanguageCompiler;
 
+import java.util.Collection;
+import java.util.Map;
+
 public interface ValidationContext extends PropertyContext {
 
     /**
@@ -93,4 +94,16 @@ public interface ValidationContext extends PropertyContext {
      * @return the identifier of the ProcessGroup that the component being validated lives in
      */
     String getProcessGroupIdentifier();
+
+    /**
+     * Returns a Collection containing the names of all Parameters that are referenced by the property with the given name
+     * @return  a Collection containing the names of all Parameters that are referenced by the property with the given name
+     */
+    Collection<String> getReferencedParameters(String propertyName);
+
+    /**
+     * @param parameterName the name of the Parameter
+     * @return <code>true</code> if a Parameter with the given name is defined in the currently selected Parameter Context
+     */
+    boolean isParameterDefined(String parameterName);
 }
diff --git a/nifi-api/src/main/java/org/apache/nifi/parameter/Parameter.java b/nifi-api/src/main/java/org/apache/nifi/parameter/Parameter.java
new file mode 100644
index 00000000000..70f61af8056
--- /dev/null
+++ b/nifi-api/src/main/java/org/apache/nifi/parameter/Parameter.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import java.util.Objects;
+
+public class Parameter {
+    private final ParameterDescriptor descriptor;
+    private final String value;
+
+    public Parameter(final ParameterDescriptor descriptor, final String value) {
+        this.descriptor = descriptor;
+        this.value = value;
+    }
+
+    public ParameterDescriptor getDescriptor() {
+        return descriptor;
+    }
+
+    public String getValue() {
+        return value;
+    }
+
+    @Override
+    public boolean equals(final Object o) {
+        if (this == o) {
+            return true;
+        }
+
+        if (o == null || getClass() != o.getClass()) {
+            return false;
+        }
+
+        final Parameter parameter = (Parameter) o;
+        return Objects.equals(descriptor, parameter.descriptor) && Objects.equals(value, parameter.value);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(descriptor, value);
+    }
+}
diff --git a/nifi-api/src/main/java/org/apache/nifi/parameter/ParameterDescriptor.java b/nifi-api/src/main/java/org/apache/nifi/parameter/ParameterDescriptor.java
new file mode 100644
index 00000000000..bf785bf7279
--- /dev/null
+++ b/nifi-api/src/main/java/org/apache/nifi/parameter/ParameterDescriptor.java
@@ -0,0 +1,115 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import java.util.Objects;
+
+/**
+ * An immutable class that holds information about a Parameter. Parameters are constructed through use of the {@link ParameterDescriptor.Builder} class.
+ */
+public class ParameterDescriptor {
+    private final String name;
+    private final String description;
+    private final boolean sensitive;
+
+    private ParameterDescriptor(final Builder builder) {
+        this.name = builder.name;
+        this.description = builder.description;
+        this.sensitive = builder.sensitive;
+    }
+
+    /**
+     * @return the name of the parameter
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @return a description of the parameter
+     */
+    public String getDescription() {
+        return description;
+    }
+
+    /**
+     * @return whether or not the parameter is considered sensitive.
+     */
+    public boolean isSensitive() {
+        return sensitive;
+    }
+
+
+    @Override
+    public boolean equals(final Object o) {
+        if (this == o){
+            return true;
+        }
+
+        if (o == null || getClass() != o.getClass()){
+            return false;
+        }
+
+
+        final ParameterDescriptor other = (ParameterDescriptor) o;
+        return Objects.equals(this.name, other.name);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(name);
+    }
+
+
+    public static class Builder {
+        private String name;
+        private String description;
+        private boolean sensitive;
+
+        public Builder name(final String name) {
+            Objects.requireNonNull(name);
+
+            this.name = name.trim();
+            return this;
+        }
+
+        public Builder description(final String description) {
+            this.description = description == null ? null : description.trim();
+            return this;
+        }
+
+        public Builder sensitive(final boolean sensitive) {
+            this.sensitive = sensitive;
+            return this;
+        }
+
+        public Builder from(final ParameterDescriptor descriptor) {
+            name(descriptor.getName());
+            description(descriptor.getDescription());
+            sensitive(descriptor.isSensitive());
+            return this;
+        }
+
+        public ParameterDescriptor build() {
+            if (name == null) {
+                throw new IllegalStateException("Must specify Parameter Name");
+            }
+
+            return new ParameterDescriptor(this);
+        }
+    }
+}
diff --git a/nifi-bootstrap/src/main/java/org/apache/nifi/bootstrap/NotificationServiceManager.java b/nifi-bootstrap/src/main/java/org/apache/nifi/bootstrap/NotificationServiceManager.java
index 6e917512d33..6e2fa35a4e3 100644
--- a/nifi-bootstrap/src/main/java/org/apache/nifi/bootstrap/NotificationServiceManager.java
+++ b/nifi-bootstrap/src/main/java/org/apache/nifi/bootstrap/NotificationServiceManager.java
@@ -16,27 +16,7 @@
  */
 package org.apache.nifi.bootstrap;
 
-import java.io.BufferedInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.Executors;
-import java.util.concurrent.ScheduledExecutorService;
-import java.util.concurrent.ThreadFactory;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicInteger;
-
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.bootstrap.notification.NotificationContext;
 import org.apache.nifi.bootstrap.notification.NotificationInitializationContext;
@@ -57,6 +37,26 @@
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ScheduledExecutorService;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+
 public class NotificationServiceManager {
     private static final Logger logger = LoggerFactory.getLogger(NotificationServiceManager.class);
     private final Map<String, ConfiguredNotificationService> servicesById = new HashMap<>();
@@ -256,7 +256,7 @@ public PropertyValue getProperty(final PropertyDescriptor descriptor) {
                     configuredValue = fullPropDescriptor.getDefaultValue();
                 }
 
-                return new StandardPropertyValue(configuredValue, null, variableRegistry);
+                return new StandardPropertyValue(configuredValue, null, ParameterLookup.EMPTY, variableRegistry);
             }
 
             @Override
@@ -376,7 +376,7 @@ public PropertyValue getProperty(final PropertyDescriptor descriptor) {
                         value = descriptor.getDefaultValue();
                     }
 
-                    return new StandardPropertyValue(value, null, variableRegistry);
+                    return new StandardPropertyValue(value, null, ParameterLookup.EMPTY, variableRegistry);
                 }
 
                 @Override
diff --git a/nifi-bootstrap/src/main/java/org/apache/nifi/bootstrap/notification/NotificationValidationContext.java b/nifi-bootstrap/src/main/java/org/apache/nifi/bootstrap/notification/NotificationValidationContext.java
index 6d3ef537a68..8f7eda0e31d 100644
--- a/nifi-bootstrap/src/main/java/org/apache/nifi/bootstrap/notification/NotificationValidationContext.java
+++ b/nifi-bootstrap/src/main/java/org/apache/nifi/bootstrap/notification/NotificationValidationContext.java
@@ -16,11 +16,7 @@
  */
 package org.apache.nifi.bootstrap.notification;
 
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.Query;
 import org.apache.nifi.attribute.expression.language.Query.Range;
 import org.apache.nifi.attribute.expression.language.StandardExpressionLanguageCompiler;
@@ -33,6 +29,13 @@
 import org.apache.nifi.expression.ExpressionLanguageCompiler;
 import org.apache.nifi.registry.VariableRegistry;
 
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+
 public class NotificationValidationContext implements ValidationContext {
     private final NotificationContext context;
     private final Map<String, Boolean> expressionLanguageSupported;
@@ -52,13 +55,13 @@ public NotificationValidationContext(final NotificationContext processContext, V
 
     @Override
     public PropertyValue newPropertyValue(final String rawValue) {
-        return new StandardPropertyValue(rawValue, null, variableRegistry);
+        return new StandardPropertyValue(rawValue, null, ParameterLookup.EMPTY, variableRegistry);
     }
 
     @Override
     public ExpressionLanguageCompiler newExpressionLanguageCompiler() {
 
-        return new StandardExpressionLanguageCompiler(null);
+        return new StandardExpressionLanguageCompiler(null, ParameterLookup.EMPTY);
     }
 
     @Override
@@ -120,4 +123,14 @@ public boolean isExpressionLanguageSupported(final String propertyName) {
     public String getProcessGroupIdentifier() {
         return null;
     }
+
+    @Override
+    public Collection<String> getReferencedParameters(final String propertyName) {
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean isParameterDefined(final String parameterName) {
+        return false;
+    }
 }
diff --git a/nifi-commons/nifi-expression-language/pom.xml b/nifi-commons/nifi-expression-language/pom.xml
index a20ce3691c1..606bd86adf9 100644
--- a/nifi-commons/nifi-expression-language/pom.xml
+++ b/nifi-commons/nifi-expression-language/pom.xml
@@ -49,7 +49,7 @@
                         <exclude>src/test/resources/json/address-book.json</exclude>
                     </excludes>
                 </configuration>
-            </plugin>            
+            </plugin>
         </plugins>
     </build>
     <dependencies>
@@ -63,6 +63,11 @@
             <artifactId>nifi-api</artifactId>
             <version>1.10.0-SNAPSHOT</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.nifi</groupId>
+            <artifactId>nifi-parameter</artifactId>
+            <version>1.10.0-SNAPSHOT</version>
+        </dependency>
         <dependency>
             <groupId>org.apache.nifi</groupId>
             <artifactId>nifi-utils</artifactId>
diff --git a/nifi-commons/nifi-expression-language/src/main/antlr3/org/apache/nifi/attribute/expression/language/antlr/AttributeExpressionLexer.g b/nifi-commons/nifi-expression-language/src/main/antlr3/org/apache/nifi/attribute/expression/language/antlr/AttributeExpressionLexer.g
index d1b22e92c05..3b8e65f8efc 100644
--- a/nifi-commons/nifi-expression-language/src/main/antlr3/org/apache/nifi/attribute/expression/language/antlr/AttributeExpressionLexer.g
+++ b/nifi-commons/nifi-expression-language/src/main/antlr3/org/apache/nifi/attribute/expression/language/antlr/AttributeExpressionLexer.g
@@ -66,7 +66,10 @@ lexer grammar AttributeExpressionLexer;
 
 // PUNCTUATION & SPECIAL CHARACTERS
 WHITESPACE : (' '|'\t'|'\n'|'\r')+ { $channel = HIDDEN; };
-COMMENT : '#' ( ~('\n') )* '\n' { $channel = HIDDEN; };
+COMMENT : '#' ( ~('{') ) ( ~('\n') )* '\n' { $channel = HIDDEN; };
+
+// PARAMETERS
+PARAMETER_REFERENCE_START : '#{';
 
 DOLLAR : '$';
 LPAREN	: '(';
diff --git a/nifi-commons/nifi-expression-language/src/main/antlr3/org/apache/nifi/attribute/expression/language/antlr/AttributeExpressionParser.g b/nifi-commons/nifi-expression-language/src/main/antlr3/org/apache/nifi/attribute/expression/language/antlr/AttributeExpressionParser.g
index 0c63c553ce0..2728e364ac3 100644
--- a/nifi-commons/nifi-expression-language/src/main/antlr3/org/apache/nifi/attribute/expression/language/antlr/AttributeExpressionParser.g
+++ b/nifi-commons/nifi-expression-language/src/main/antlr3/org/apache/nifi/attribute/expression/language/antlr/AttributeExpressionParser.g
@@ -29,6 +29,7 @@ tokens {
 	EXPRESSION;
 	MULTI_ATTRIBUTE_REFERENCE;
 	QUOTED_ATTR_NAME;
+	PARAMETER_REFERENCE;
 }
 
 @header {
@@ -101,7 +102,9 @@ stringFunctionRef : zeroArgString | oneArgString | twoArgString | fiveArgString;
 booleanFunctionRef : zeroArgBool | oneArgBool | multiArgBool;
 numberFunctionRef : zeroArgNum | oneArgNum | oneOrTwoArgNum | zeroOrOneOrTwoArgNum;
 
-anyArg : WHOLE_NUMBER | DECIMAL | numberFunctionRef | STRING_LITERAL | zeroArgString | oneArgString | twoArgString | fiveArgString | booleanLiteral | zeroArgBool | oneArgBool | multiArgBool | expression;
+anyArg : WHOLE_NUMBER | DECIMAL | numberFunctionRef | STRING_LITERAL | zeroArgString | oneArgString | twoArgString | fiveArgString | booleanLiteral | zeroArgBool | oneArgBool | multiArgBool
+                | expression | parameterReference;
+
 stringArg : STRING_LITERAL | zeroArgString | oneArgString | twoArgString | expression;
 functionRef : stringFunctionRef | booleanFunctionRef | numberFunctionRef;
 
@@ -133,10 +136,15 @@ oneArgStandaloneFunction : ((TO_LITERAL | MATH | GET_STATE_VALUE)^ LPAREN! anyAr
                            (HOSTNAME^ LPAREN! booleanLiteral RPAREN!);
 standaloneFunction : zeroArgStandaloneFunction | oneArgStandaloneFunction;
 
-attributeRefOrFunctionCall	: (attributeRef | standaloneFunction);
+attributeRefOrFunctionCall	: (attributeRef | standaloneFunction | parameterReference);
+
+referenceOrFunction : DOLLAR LBRACE attributeRefOrFunctionCall (COLON functionCall)* RBRACE ->
+                      	^(EXPRESSION attributeRefOrFunctionCall functionCall*);
+
+parameterReference : PARAMETER_REFERENCE_START ATTRIBUTE_NAME RBRACE ->
+    ^(PARAMETER_REFERENCE ATTRIBUTE_NAME);
 
-expression : DOLLAR LBRACE attributeRefOrFunctionCall (COLON functionCall)* RBRACE ->
-	^(EXPRESSION attributeRefOrFunctionCall functionCall*);
+expression : referenceOrFunction;
 
 query : expression EOF ->
 	^(QUERY expression);
\ No newline at end of file
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/CompiledExpression.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/CompiledExpression.java
index 52fcb1f9d6e..74741b157ff 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/CompiledExpression.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/CompiledExpression.java
@@ -17,13 +17,12 @@
 
 package org.apache.nifi.attribute.expression.language;
 
-import java.util.Map;
-import java.util.Set;
-
 import org.antlr.runtime.tree.Tree;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.expression.AttributeValueDecorator;
 
+import java.util.Set;
+
 public class CompiledExpression implements Expression {
     private final Evaluator<?> rootEvaluator;
     private final Tree tree;
@@ -54,7 +53,7 @@ public Set<Evaluator<?>> getAllEvaluators() {
     }
 
     @Override
-    public String evaluate(final Map<String, String> variables, final AttributeValueDecorator decorator, final Map<String, String> stateVariables) {
-        return Query.evaluateExpression(tree, rootEvaluator, expression, variables, decorator, stateVariables);
+    public String evaluate(final EvaluationContext evaluationContext, final AttributeValueDecorator decorator) {
+        return Query.evaluateExpression(tree, rootEvaluator, expression, evaluationContext, decorator);
     }
 }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/EmptyPreparedQuery.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/EmptyPreparedQuery.java
index e9ac03b5704..d746e7b9f30 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/EmptyPreparedQuery.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/EmptyPreparedQuery.java
@@ -17,8 +17,6 @@
 package org.apache.nifi.attribute.expression.language;
 
 
-import java.util.Map;
-
 import org.apache.nifi.expression.AttributeValueDecorator;
 import org.apache.nifi.processor.exception.ProcessException;
 
@@ -31,12 +29,7 @@ public class EmptyPreparedQuery implements PreparedQuery {
     }
 
     @Override
-    public String evaluateExpressions(Map<String, String> valueLookup, AttributeValueDecorator decorator) throws ProcessException {
-        return value;
-    }
-
-    @Override
-    public String evaluateExpressions(Map<String, String> attributes, AttributeValueDecorator decorator, Map<String, String> stateVariables) throws ProcessException {
+    public String evaluateExpressions(final EvaluationContext evaluationContext, final AttributeValueDecorator decorator) throws ProcessException {
         return value;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/EvaluationContext.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/EvaluationContext.java
new file mode 100644
index 00000000000..83e67ded954
--- /dev/null
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/EvaluationContext.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.attribute.expression.language;
+
+import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.parameter.Parameter;
+
+import java.util.Set;
+
+public interface EvaluationContext {
+    /**
+     * Returns the name of an attribute, variable, environment variable, or system variable that can be referenced in the Expression Language
+     * @param name the name of the attribute, variable, etc.
+     * @return the value assigned to the attribute, variable, etc. or <code>null</code> if no such value exists
+     */
+    String getExpressionValue(String name);
+
+    /**
+     * Returns the names of all attributes, variables, etc. that can be used in Expression Language
+     * @return the names of all keys that can be used in Expression Language
+     */
+    Set<String> getExpressionKeys();
+
+    String getState(String key);
+
+    Parameter getParameter(String parameterName);
+
+    EvaluatorState getEvaluatorState();
+}
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/Expression.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/Expression.java
index d229986ddac..188c503ced5 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/Expression.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/Expression.java
@@ -17,18 +17,15 @@
 
 package org.apache.nifi.attribute.expression.language;
 
-import java.util.Map;
-
 import org.apache.nifi.expression.AttributeValueDecorator;
 
 public interface Expression {
     /**
      * Evaluates this Expression against the given variables, attribute decorator, and state variables
      *
-     * @param variables variables to be evaluated
+     * @param evaluationContext the context used to evaluate the Expression
      * @param decorator decorator to decorate variable values
-     * @param stateVariables state variables to include in evaluation
      * @return the evaluated value
      */
-    String evaluate(Map<String, String> variables, AttributeValueDecorator decorator, Map<String, String> stateVariables);
+    String evaluate(EvaluationContext evaluationContext, AttributeValueDecorator decorator);
 }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/InvalidPreparedQuery.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/InvalidPreparedQuery.java
index 8ef996b96c8..9a3ec32d287 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/InvalidPreparedQuery.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/InvalidPreparedQuery.java
@@ -17,8 +17,6 @@
 package org.apache.nifi.attribute.expression.language;
 
 
-import java.util.Map;
-
 import org.apache.nifi.attribute.expression.language.exception.AttributeExpressionLanguageException;
 import org.apache.nifi.expression.AttributeValueDecorator;
 import org.apache.nifi.processor.exception.ProcessException;
@@ -40,12 +38,7 @@ public InvalidPreparedQuery(final String query, final String explanation) {
     }
 
     @Override
-    public String evaluateExpressions(final Map<String,String> valueLookup, final AttributeValueDecorator decorator) throws ProcessException {
-        throw new AttributeExpressionLanguageException("Invalid Expression: " + query + " due to " + explanation);
-    }
-
-    @Override
-    public String evaluateExpressions( Map<String, String> valueLookup, AttributeValueDecorator decorator, Map<String, String> stateVariables) throws ProcessException {
+    public String evaluateExpressions(final EvaluationContext evaluationContext, final AttributeValueDecorator decorator) throws ProcessException {
         throw new AttributeExpressionLanguageException("Invalid Expression: " + query + " due to " + explanation);
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/ParameterExpression.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/ParameterExpression.java
new file mode 100644
index 00000000000..914a4d51c98
--- /dev/null
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/ParameterExpression.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.attribute.expression.language;
+
+import org.apache.nifi.expression.AttributeValueDecorator;
+import org.apache.nifi.parameter.Parameter;
+
+public class ParameterExpression implements Expression {
+    private final String parameterName;
+
+    public ParameterExpression(final String parameterName) {
+        this.parameterName = parameterName;
+    }
+
+    @Override
+    public String evaluate(final EvaluationContext evaluationContext, final AttributeValueDecorator decorator) {
+        final Parameter parameter = evaluationContext.getParameter(parameterName);
+        return parameter == null || parameter.getDescriptor().isSensitive() ? null : parameter.getValue();
+    }
+}
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/PreparedQuery.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/PreparedQuery.java
index c51656d0281..7bdd287a302 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/PreparedQuery.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/PreparedQuery.java
@@ -17,16 +17,12 @@
 package org.apache.nifi.attribute.expression.language;
 
 
-import java.util.Map;
-
 import org.apache.nifi.expression.AttributeValueDecorator;
 import org.apache.nifi.processor.exception.ProcessException;
 
 public interface PreparedQuery {
 
-    String evaluateExpressions(Map<String, String> valueLookup, AttributeValueDecorator decorator) throws ProcessException;
-
-    String evaluateExpressions(final Map<String, String> valueLookup, final AttributeValueDecorator decorator, final Map<String, String> stateVariables) throws ProcessException;
+    String evaluateExpressions(EvaluationContext evaluationContext, AttributeValueDecorator decorator) throws ProcessException;
 
     boolean isExpressionLanguagePresent();
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/Query.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/Query.java
index b7c5259dad9..e0f4cf0407b 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/Query.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/Query.java
@@ -18,16 +18,23 @@
 
 import org.antlr.runtime.tree.Tree;
 import org.apache.nifi.attribute.expression.language.compile.ExpressionCompiler;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
+import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.selection.AttributeEvaluator;
 import org.apache.nifi.attribute.expression.language.exception.AttributeExpressionLanguageParsingException;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 import org.apache.nifi.expression.AttributeValueDecorator;
+import org.apache.nifi.parameter.ExpressionLanguageAwareParameterParser;
+import org.apache.nifi.parameter.ParameterLookup;
+import org.apache.nifi.parameter.ParameterParser;
+import org.apache.nifi.parameter.ParameterReference;
+import org.apache.nifi.parameter.ParameterToken;
+import org.apache.nifi.parameter.ParameterTokenList;
 import org.apache.nifi.processor.exception.ProcessException;
 
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.List;
 import java.util.Map;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -85,12 +92,21 @@ public static List<String> extractExpressions(final String value) throws Attribu
         return expressions;
     }
 
+
     public static List<Range> extractExpressionRanges(final String value) throws AttributeExpressionLanguageParsingException {
+        return extractExpressionRanges(value, false);
+    }
+
+    public static List<Range> extractEscapedRanges(final String value) throws AttributeExpressionLanguageParsingException {
+        return extractExpressionRanges(value, true);
+    }
+
+    private static List<Range> extractExpressionRanges(final String value, final boolean extractEscapeSequences) throws AttributeExpressionLanguageParsingException {
         final List<Range> ranges = new ArrayList<>();
         char lastChar = 0;
         int embeddedCount = 0;
         int expressionStart = -1;
-        boolean oddDollarCount = false;
+        int dollarCount = 0;
         int backslashCount = 0;
 
         charLoop:
@@ -108,9 +124,10 @@ public static List<Range> extractExpressionRanges(final String value) throws Att
                 }
 
                 if (c == '{') {
-                    if (oddDollarCount && lastChar == '$') {
+                    final boolean evenDollarCount = dollarCount % 2 == 0;
+                    if ((evenDollarCount == extractEscapeSequences) && lastChar == '$') {
                         if (embeddedCount == 0) {
-                            expressionStart = i - 1;
+                            expressionStart = i - (extractEscapeSequences ? dollarCount : 1);
                         }
                     }
 
@@ -137,11 +154,11 @@ public static List<Range> extractExpressionRanges(final String value) throws Att
                         expressionStart = -1;
                     }
                 } else if (c == '$') {
-                    oddDollarCount = !oddDollarCount;
+                    dollarCount++;
                 } else if (c == '\\') {
                     backslashCount++;
                 } else {
-                    oddDollarCount = false;
+                    dollarCount = 0;
                 }
 
                 lastChar = c;
@@ -201,10 +218,11 @@ static int findEndQuoteChar(final String value, final int quoteStart) {
         return -1;
     }
 
-    static String evaluateExpression(final Tree tree, Evaluator<?> rootEvaluator, final String queryText, final Map<String, String> valueMap, final AttributeValueDecorator decorator,
-                                     final Map<String, String> stateVariables) throws ProcessException {
+    static String evaluateExpression(final Tree tree, final Evaluator<?> rootEvaluator, final String queryText, final EvaluationContext evaluationContext, final AttributeValueDecorator decorator)
+                throws ProcessException {
+
         Query query = new Query(queryText, tree, rootEvaluator);
-        final Object evaluated = query.evaluate(valueMap, stateVariables).getValue();
+        final Object evaluated = query.evaluate(evaluationContext).getValue();
         if (evaluated == null) {
             return null;
         }
@@ -213,17 +231,18 @@ static String evaluateExpression(final Tree tree, Evaluator<?> rootEvaluator, fi
         return decorator == null ? value : decorator.decorate(value);
     }
 
-    static String evaluateExpressions(final String rawValue, Map<String, String> expressionMap, final AttributeValueDecorator decorator, final Map<String, String> stateVariables)
-            throws ProcessException {
-        return Query.prepare(rawValue).evaluateExpressions(expressionMap, decorator, stateVariables);
+    static String evaluateExpressions(final String rawValue, Map<String, String> expressionMap, final AttributeValueDecorator decorator, final Map<String, String> stateVariables,
+                                      final ParameterLookup parameterLookup) throws ProcessException {
+        return Query.prepare(rawValue).evaluateExpressions(new StandardEvaluationContext(expressionMap, stateVariables, parameterLookup), decorator);
     }
 
-    static String evaluateExpressions(final String rawValue, final Map<String, String> valueLookup) throws ProcessException {
-        return evaluateExpressions(rawValue, valueLookup, null);
+    static String evaluateExpressions(final String rawValue, final Map<String, String> valueLookup, final ParameterLookup parameterLookup) throws ProcessException {
+        return evaluateExpressions(rawValue, valueLookup, null, parameterLookup);
     }
 
-    static String evaluateExpressions(final String rawValue, final Map<String, String> valueLookup, final AttributeValueDecorator decorator) throws ProcessException {
-        return Query.prepare(rawValue).evaluateExpressions(valueLookup, decorator);
+    static String evaluateExpressions(final String rawValue, final Map<String, String> valueLookup, final AttributeValueDecorator decorator, final ParameterLookup parameterLookup)
+            throws ProcessException {
+        return Query.prepare(rawValue).evaluateExpressions(new StandardEvaluationContext(valueLookup, Collections.emptyMap(), parameterLookup), decorator);
     }
 
 
@@ -279,19 +298,61 @@ private static String unescapeTrailingDollarSigns(final String value, final bool
     }
 
 
+    public static PreparedQuery prepareWithParametersPreEvaluated(final String query) throws AttributeExpressionLanguageParsingException {
+        return prepare(query, true);
+    }
+
     public static PreparedQuery prepare(final String query) throws AttributeExpressionLanguageParsingException {
-        if (query == null) {
+        return prepare(query, false);
+    }
+
+    private static PreparedQuery prepare(final String rawQuery, final boolean escapeParameterReferences) throws AttributeExpressionLanguageParsingException {
+        if (rawQuery == null) {
             return new EmptyPreparedQuery(null);
         }
 
+        final ParameterParser parameterParser = new ExpressionLanguageAwareParameterParser();
+
+        final String query;
+        if (escapeParameterReferences) {
+            query = parameterParser.parseTokens(rawQuery).escape();
+        } else {
+            query = rawQuery;
+        }
+
         final List<Range> ranges = extractExpressionRanges(query);
 
         if (ranges.isEmpty()) {
-            // While in the other cases below, we are simply replacing "$$" with "$", we have to do this
-            // a bit differently. We want to treat $$ as an escaped $ only if it immediately precedes the
-            // start of an Expression, which is the case below. Here, we did not detect the start of an Expression
-            // and as such as must use the #unescape method instead of a simple replace() function.
-            return new EmptyPreparedQuery(unescape(query));
+            final List<Expression> expressions = new ArrayList<>();
+
+            final List<Range> escapedRanges = extractEscapedRanges(query);
+            int lastIndex = 0;
+            for (final Range range : escapedRanges) {
+                final String treeText = unescapeLeadingDollarSigns(query.substring(range.getStart(), range.getEnd() + 1));
+
+                if (range.getStart() > lastIndex) {
+                    String substring = unescapeLeadingDollarSigns(query.substring(lastIndex, range.getStart()));
+                    addLiteralsAndParameters(parameterParser, substring, expressions);
+                }
+
+                addLiteralsAndParameters(parameterParser, treeText, expressions);
+            }
+
+            if (escapedRanges.isEmpty()) {
+                addLiteralsAndParameters(parameterParser, query, expressions);
+            } else {
+                final Range lastRange = escapedRanges.get(escapedRanges.size() - 1);
+                if (lastRange.getEnd() + 1 < query.length()) {
+                    final String treeText = unescapeLeadingDollarSigns(query.substring(lastRange.getEnd() + 1));
+                    addLiteralsAndParameters(parameterParser, treeText, expressions);
+                }
+            }
+
+            if (expressions.isEmpty()) {
+                return new EmptyPreparedQuery(query);
+            }
+
+            return new StandardPreparedQuery(expressions);
         }
 
         final ExpressionCompiler compiler = new ExpressionCompiler();
@@ -314,7 +375,7 @@ public static PreparedQuery prepare(final String query) throws AttributeExpressi
                         substring = unescapeTrailingDollarSigns(substring, false);
                     }
 
-                    expressions.add(new StringLiteralExpression(substring));
+                    addLiteralsAndParameters(parameterParser, substring, expressions);
                 }
 
                 expressions.add(compiledExpression);
@@ -325,7 +386,7 @@ public static PreparedQuery prepare(final String query) throws AttributeExpressi
             final Range lastRange = ranges.get(ranges.size() - 1);
             if (lastRange.getEnd() + 1 < query.length()) {
                 final String treeText = unescapeLeadingDollarSigns(query.substring(lastRange.getEnd() + 1));
-                expressions.add(new StringLiteralExpression(treeText));
+                addLiteralsAndParameters(parameterParser, treeText, expressions);
             }
 
             return new StandardPreparedQuery(expressions);
@@ -334,6 +395,43 @@ public static PreparedQuery prepare(final String query) throws AttributeExpressi
         }
     }
 
+    private static void addLiteralsAndParameters(final ParameterParser parser, final String input, final List<Expression> expressions) {
+        final ParameterTokenList references = parser.parseTokens(input);
+        int index = 0;
+
+        ParameterToken lastReference = null;
+        for (final ParameterToken token : references) {
+            if (token.isEscapeSequence()) {
+                expressions.add(new StringLiteralExpression(token.getValue(ParameterLookup.EMPTY)));
+                index = token.getEndOffset() + 1;
+                lastReference = token;
+                continue;
+            }
+
+            final int start = token.getStartOffset();
+
+            if (start > index) {
+                expressions.add(new StringLiteralExpression(input.substring(index, start)));
+            }
+
+            if (token.isParameterReference()) {
+                final ParameterReference parameterReference = (ParameterReference) token;
+                expressions.add(new ParameterExpression(parameterReference.getParameterName()));
+            } else {
+                expressions.add(new StringLiteralExpression(token.getValue(ParameterLookup.EMPTY)));
+            }
+
+            index = token.getEndOffset() + 1;
+            lastReference = token;
+        }
+
+        if (lastReference == null) {
+            expressions.add(new StringLiteralExpression(input));
+        } else if (input.length() > lastReference.getEndOffset() + 1) {
+            expressions.add(new StringLiteralExpression(input.substring(lastReference.getEndOffset() + 1)));
+        }
+    }
+
     public static Query compile(final String query) throws AttributeExpressionLanguageParsingException {
         try {
             final ExpressionCompiler compiler = new ExpressionCompiler();
@@ -351,20 +449,12 @@ public ResultType getResultType() {
         return evaluator.getResultType();
     }
 
-    QueryResult<?> evaluate(final Map<String, String> map) {
-        return evaluate(map, null);
-    }
-
-    QueryResult<?> evaluate(final Map<String, String> attributes, final Map<String, String> stateMap) {
+    QueryResult<?> evaluate(final EvaluationContext evaluationContext) {
         if (evaluated.getAndSet(true)) {
             throw new IllegalStateException("A Query cannot be evaluated more than once");
         }
-        if (stateMap != null) {
-            AttributesAndState attributesAndState = new AttributesAndState(attributes, stateMap);
-            return evaluator.evaluate(attributesAndState, context);
-        } else {
-            return evaluator.evaluate(attributes, context);
-        }
+
+        return evaluator.evaluate(evaluationContext);
     }
 
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardAttributeExpression.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardAttributeExpression.java
index a7ed184a13d..983392ec6bb 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardAttributeExpression.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardAttributeExpression.java
@@ -19,22 +19,23 @@
 import org.apache.nifi.expression.AttributeExpression;
 import org.apache.nifi.expression.AttributeValueDecorator;
 import org.apache.nifi.flowfile.FlowFile;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.processor.exception.ProcessException;
 import org.apache.nifi.registry.VariableRegistry;
 
+import java.util.Collections;
+
 public class StandardAttributeExpression implements AttributeExpression {
 
     private final Query query;
     private final VariableRegistry variableRegistry;
+    private final ParameterLookup parameterLookup;
 
-    public StandardAttributeExpression(final Query query) {
-        this.query = query;
-        this.variableRegistry = null;
-    }
 
-    public StandardAttributeExpression(final Query query, final VariableRegistry variableRegistry) {
+    public StandardAttributeExpression(final Query query, final VariableRegistry variableRegistry, final ParameterLookup parameterLookup) {
         this.query = query;
         this.variableRegistry = variableRegistry;
+        this.parameterLookup = parameterLookup;
     }
 
     @Override
@@ -60,7 +61,9 @@ public String evaluate(final FlowFile flowFile) throws ProcessException {
     @Override
     public String evaluate(final FlowFile flowFile, final AttributeValueDecorator decorator) throws ProcessException {
         final ValueLookup lookup = new ValueLookup(variableRegistry, flowFile);
-        final Object evaluationResult = query.evaluate(lookup).getValue();
+        final EvaluationContext evaluationContext = new StandardEvaluationContext(lookup, Collections.emptyMap(), parameterLookup);
+
+        final Object evaluationResult = query.evaluate(evaluationContext).getValue();
         if (evaluationResult == null) {
             return "";
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardEvaluationContext.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardEvaluationContext.java
new file mode 100644
index 00000000000..c93efa205f4
--- /dev/null
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardEvaluationContext.java
@@ -0,0 +1,71 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.attribute.expression.language;
+
+import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterLookup;
+import org.apache.nifi.registry.VariableRegistry;
+
+import java.util.Map;
+import java.util.Set;
+
+public class StandardEvaluationContext implements EvaluationContext {
+    private final ValueLookup valueLookup;
+    private final Map<String, String> stateMap;
+    private final ParameterLookup parameterLookup;
+    private final EvaluatorState evaluatorState = new EvaluatorState();
+
+    public StandardEvaluationContext(final Map<String, String> variables) {
+        this(variables, null, ParameterLookup.EMPTY);
+    }
+
+    public StandardEvaluationContext(final Map<String, String> variables, final Map<String, String> stateMap, final ParameterLookup parameterLookup) {
+        this(new ValueLookup(VariableRegistry.ENVIRONMENT_SYSTEM_REGISTRY, null, variables), stateMap, parameterLookup);
+    }
+
+    public StandardEvaluationContext(final ValueLookup valueLookup, final Map<String, String> stateMap, final ParameterLookup parameterLookup) {
+        this.valueLookup = valueLookup;
+        this.stateMap = stateMap;
+        this.parameterLookup = parameterLookup;
+    }
+
+    @Override
+    public String getExpressionValue(final String name) {
+        return valueLookup.get(name);
+    }
+
+    @Override
+    public Set<String> getExpressionKeys() {
+        return valueLookup.getKeysAddressableByMultiMatch();
+    }
+
+    @Override
+    public String getState(final String key) {
+        return stateMap.get(key);
+    }
+
+    @Override
+    public Parameter getParameter(final String parameterName) {
+        return parameterLookup.getParameter(parameterName).orElse(null);
+    }
+
+    @Override
+    public EvaluatorState getEvaluatorState() {
+        return evaluatorState;
+    }
+}
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardExpressionLanguageCompiler.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardExpressionLanguageCompiler.java
index 01a4eb9a6e4..fe95d871bba 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardExpressionLanguageCompiler.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardExpressionLanguageCompiler.java
@@ -18,26 +18,25 @@
 
 import org.apache.nifi.attribute.expression.language.exception.AttributeExpressionLanguageParsingException;
 import org.apache.nifi.expression.AttributeExpression;
-import org.apache.nifi.expression.ExpressionLanguageCompiler;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
+import org.apache.nifi.expression.ExpressionLanguageCompiler;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.registry.VariableRegistry;
 
 public class StandardExpressionLanguageCompiler implements ExpressionLanguageCompiler {
 
     private final VariableRegistry variableRegistry;
+    private final ParameterLookup parameterLookup;
 
-    public StandardExpressionLanguageCompiler() {
-        this.variableRegistry = VariableRegistry.EMPTY_REGISTRY;
-    }
-
-    public StandardExpressionLanguageCompiler(final VariableRegistry variableRegistry) {
+    public StandardExpressionLanguageCompiler(final VariableRegistry variableRegistry, final ParameterLookup parameterLookup) {
         this.variableRegistry = variableRegistry;
+        this.parameterLookup = parameterLookup;
     }
 
     @Override
     public AttributeExpression compile(final String expression) throws IllegalArgumentException {
         try {
-            return new StandardAttributeExpression(Query.compile(expression),variableRegistry);
+            return new StandardAttributeExpression(Query.compile(expression), variableRegistry, parameterLookup);
         } catch (final AttributeExpressionLanguageParsingException e) {
             throw new IllegalArgumentException(e.getMessage());
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardPreparedQuery.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardPreparedQuery.java
index b9fa720f40d..545be0f14e5 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardPreparedQuery.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardPreparedQuery.java
@@ -16,7 +16,6 @@
  */
 package org.apache.nifi.attribute.expression.language;
 
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.literals.StringLiteralEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.selection.AllAttributesEvaluator;
@@ -32,7 +31,6 @@
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
 
 public class StandardPreparedQuery implements PreparedQuery {
@@ -46,19 +44,19 @@ public StandardPreparedQuery(final List<Expression> expressions) {
     }
 
     @Override
-    public String evaluateExpressions(final Map<String, String> valMap, final AttributeValueDecorator decorator, final Map<String, String> stateVariables) throws ProcessException {
+    public String evaluateExpressions(final EvaluationContext evaluationContext, final AttributeValueDecorator decorator) throws ProcessException {
         if (expressions.isEmpty()) {
             return EMPTY_STRING;
         }
         if (expressions.size() == 1) {
-            final String evaluated = expressions.get(0).evaluate(valMap, decorator, stateVariables);
+            final String evaluated = expressions.get(0).evaluate(evaluationContext, decorator);
             return evaluated == null ? EMPTY_STRING : evaluated;
         }
 
         final StringBuilder sb = new StringBuilder();
 
         for (final Expression expression : expressions) {
-            final String evaluated = expression.evaluate(valMap, decorator, stateVariables);
+            final String evaluated = expression.evaluate(evaluationContext, decorator);
 
             if (evaluated != null) {
                 sb.append(evaluated);
@@ -68,11 +66,6 @@ public String evaluateExpressions(final Map<String, String> valMap, final Attrib
         return sb.toString();
     }
 
-    @Override
-    public String evaluateExpressions(final Map<String, String> valMap, final AttributeValueDecorator decorator)
-            throws ProcessException {
-        return evaluateExpressions(valMap, decorator, null);
-    }
 
     @Override
     public boolean isExpressionLanguagePresent() {
@@ -100,7 +93,7 @@ public VariableImpact getVariableImpact() {
                     final Evaluator<String> nameEval = attributeEval.getNameEvaluator();
 
                     if (nameEval instanceof StringLiteralEvaluator) {
-                        final String referencedVar = nameEval.evaluate(Collections.emptyMap(), new EvaluatorState()).getValue();
+                        final String referencedVar = nameEval.evaluate(new StandardEvaluationContext(Collections.emptyMap())).getValue();
                         variables.add(referencedVar);
                     }
                 } else if (evaluator instanceof AllAttributesEvaluator) {
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardPropertyValue.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardPropertyValue.java
index f6b6c706995..4ffce2b194a 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardPropertyValue.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StandardPropertyValue.java
@@ -16,32 +16,34 @@
  */
 package org.apache.nifi.attribute.expression.language;
 
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-
 import org.apache.nifi.components.PropertyValue;
 import org.apache.nifi.controller.ControllerService;
 import org.apache.nifi.controller.ControllerServiceLookup;
 import org.apache.nifi.expression.AttributeValueDecorator;
 import org.apache.nifi.flowfile.FlowFile;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.processor.DataUnit;
 import org.apache.nifi.processor.exception.ProcessException;
 import org.apache.nifi.registry.VariableRegistry;
 import org.apache.nifi.util.FormatUtils;
 
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
 public class StandardPropertyValue implements PropertyValue {
 
     private final String rawValue;
     private final ControllerServiceLookup serviceLookup;
     private final PreparedQuery preparedQuery;
     private final VariableRegistry variableRegistry;
+    private final ParameterLookup parameterLookup;
 
-    public StandardPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup) {
-        this(rawValue, serviceLookup, Query.prepare(rawValue), VariableRegistry.EMPTY_REGISTRY);
+    public StandardPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup, final ParameterLookup parameterLookup) {
+        this(rawValue, serviceLookup, parameterLookup, Query.prepare(rawValue), VariableRegistry.EMPTY_REGISTRY);
     }
 
-    public StandardPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup, final VariableRegistry variableRegistry) {
-        this(rawValue, serviceLookup, Query.prepare(rawValue), variableRegistry);
+    public StandardPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup, final ParameterLookup parameterLookup, final VariableRegistry variableRegistry) {
+        this(rawValue, serviceLookup, parameterLookup, Query.prepare(rawValue), variableRegistry);
     }
 
     /**
@@ -49,7 +51,7 @@ public StandardPropertyValue(final String rawValue, final ControllerServiceLooku
      * lookup and indicates whether or not the rawValue contains any NiFi
      * Expressions. If it is unknown whether or not the value contains any NiFi
      * Expressions, the
-     * {@link #StandardPropertyValue(String, ControllerServiceLookup, VariableRegistry)}
+     * {@link #StandardPropertyValue(String, ControllerServiceLookup, ParameterLookup, VariableRegistry)}
      * constructor should be used or <code>true</code> should be passed.
      * However, if it is known that the value contains no NiFi Expression, that
      * information should be provided so that calls to
@@ -57,15 +59,17 @@ public StandardPropertyValue(final String rawValue, final ControllerServiceLooku
      *
      * @param rawValue value
      * @param serviceLookup lookup
+     * @param  parameterLookup the parameter lookup
      * @param preparedQuery query
      * @param variableRegistry variableRegistry
      */
-    public StandardPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup, final PreparedQuery preparedQuery,
+    public StandardPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup, final ParameterLookup parameterLookup, final PreparedQuery preparedQuery,
             final VariableRegistry variableRegistry) {
         this.rawValue = rawValue;
         this.serviceLookup = serviceLookup;
         this.preparedQuery = preparedQuery;
         this.variableRegistry = variableRegistry;
+        this.parameterLookup = parameterLookup == null ? ParameterLookup.EMPTY : parameterLookup;
     }
 
     @Override
@@ -157,8 +161,10 @@ public PropertyValue evaluateAttributeExpressions(FlowFile flowFile, Map<String,
         }
 
         final ValueLookup lookup = new ValueLookup(variableRegistry, flowFile, additionalAttributes);
-        final String evaluated = preparedQuery.evaluateExpressions(lookup, decorator, stateValues);
-        return new StandardPropertyValue(evaluated, serviceLookup, new EmptyPreparedQuery(evaluated), null);
+        final EvaluationContext evaluationContext = new StandardEvaluationContext(lookup, stateValues, parameterLookup);
+        final String evaluated = preparedQuery.evaluateExpressions(evaluationContext, decorator);
+
+        return new StandardPropertyValue(evaluated, serviceLookup, parameterLookup, new EmptyPreparedQuery(evaluated), null);
     }
 
     @Override
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StringLiteralExpression.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StringLiteralExpression.java
index 74dafceca99..d6a87d58dd7 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StringLiteralExpression.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/StringLiteralExpression.java
@@ -17,8 +17,6 @@
 
 package org.apache.nifi.attribute.expression.language;
 
-import java.util.Map;
-
 import org.apache.nifi.expression.AttributeValueDecorator;
 
 public class StringLiteralExpression implements Expression {
@@ -29,7 +27,7 @@ public StringLiteralExpression(final String value) {
     }
 
     @Override
-    public String evaluate(Map<String, String> variables, AttributeValueDecorator decorator, Map<String, String> stateVariables) {
+    public String evaluate(final EvaluationContext evaluationContext, AttributeValueDecorator decorator) {
         return value;
     }
 }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/ValueLookup.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/ValueLookup.java
index 06c187711c8..29225e7f44a 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/ValueLookup.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/ValueLookup.java
@@ -16,6 +16,10 @@
  */
 package org.apache.nifi.attribute.expression.language;
 
+import org.apache.nifi.flowfile.FlowFile;
+import org.apache.nifi.registry.VariableDescriptor;
+import org.apache.nifi.registry.VariableRegistry;
+
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
@@ -24,9 +28,6 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import org.apache.nifi.flowfile.FlowFile;
-import org.apache.nifi.registry.VariableDescriptor;
-import org.apache.nifi.registry.VariableRegistry;
 
 /**
  * A convenience class to encapsulate the logic of variable substitution
@@ -35,8 +36,8 @@
  */
 final class ValueLookup implements Map<String, String> {
 
-    final List<Map<String, String>> maps = new ArrayList<>();
-    final VariableRegistry registry;
+    private final List<Map<String, String>> maps = new ArrayList<>();
+    private final VariableRegistry registry;
 
     /**
      * Constructs a ValueLookup where values are looked up first based any
@@ -56,6 +57,7 @@ final class ValueLookup implements Map<String, String> {
                 maps.add(map);
             }
         }
+
         if (flowFile != null) {
             maps.add(ValueLookup.extractFlowFileProperties(flowFile));
             maps.add(flowFile.getAttributes());
@@ -146,6 +148,14 @@ public void clear() {
         throw new UnsupportedOperationException();
     }
 
+    public Set<String> getKeysAddressableByMultiMatch() {
+        final Set<String> keys = new HashSet<>();
+        for (final Map<String, String> map : maps) {
+            keys.addAll(map.keySet());
+        }
+        return keys;
+    }
+
     @Override
     public Set<String> keySet() {
         final Set<String> keySet = new HashSet<>();
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/compile/ExpressionCompiler.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/compile/ExpressionCompiler.java
index 749c3be35f1..eb258a4e06d 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/compile/ExpressionCompiler.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/compile/ExpressionCompiler.java
@@ -24,11 +24,11 @@
 import org.apache.nifi.attribute.expression.language.CompiledExpression;
 import org.apache.nifi.attribute.expression.language.Query;
 import org.apache.nifi.attribute.expression.language.Query.Range;
+import org.apache.nifi.attribute.expression.language.StandardEvaluationContext;
 import org.apache.nifi.attribute.expression.language.antlr.AttributeExpressionLexer;
 import org.apache.nifi.attribute.expression.language.antlr.AttributeExpressionParser;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.DateEvaluator;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.cast.BooleanCastEvaluator;
@@ -118,6 +118,7 @@
 import org.apache.nifi.attribute.expression.language.evaluation.selection.MultiAttributeEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.selection.MultiMatchAttributeEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.selection.MultiNamedAttributeEvaluator;
+import org.apache.nifi.attribute.expression.language.evaluation.selection.ParameterEvaluator;
 import org.apache.nifi.attribute.expression.language.exception.AttributeExpressionLanguageException;
 import org.apache.nifi.attribute.expression.language.exception.AttributeExpressionLanguageParsingException;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
@@ -125,6 +126,7 @@
 
 import java.net.UnknownHostException;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
@@ -186,6 +188,7 @@
 import static org.apache.nifi.attribute.expression.language.antlr.AttributeExpressionParser.NOT_NULL;
 import static org.apache.nifi.attribute.expression.language.antlr.AttributeExpressionParser.NOW;
 import static org.apache.nifi.attribute.expression.language.antlr.AttributeExpressionParser.OR;
+import static org.apache.nifi.attribute.expression.language.antlr.AttributeExpressionParser.PARAMETER_REFERENCE;
 import static org.apache.nifi.attribute.expression.language.antlr.AttributeExpressionParser.PLUS;
 import static org.apache.nifi.attribute.expression.language.antlr.AttributeExpressionParser.PREPEND;
 import static org.apache.nifi.attribute.expression.language.antlr.AttributeExpressionParser.RANDOM;
@@ -299,7 +302,7 @@ private void verifyMappingEvaluatorReduced(final Evaluator<?> evaluator) {
         }
 
         final Evaluator<?> rootEvaluator = getRootSubjectEvaluator(evaluator);
-        if (rootEvaluator != null && rootEvaluator instanceof MultiAttributeEvaluator) {
+        if (rootEvaluator instanceof MultiAttributeEvaluator) {
             final MultiAttributeEvaluator multiAttrEval = (MultiAttributeEvaluator) rootEvaluator;
             switch (multiAttrEval.getEvaluationType()) {
                 case ALL_ATTRIBUTES:
@@ -925,6 +928,12 @@ public Evaluator<?> buildEvaluator(final Tree tree) {
             case EXPRESSION: {
                 return buildExpressionEvaluator(tree);
             }
+            case PARAMETER_REFERENCE: {
+                final String parameterName = tree.getChild(0).getText();
+                final ParameterEvaluator parameterEvaluator = new ParameterEvaluator(parameterName);
+                evaluators.add(parameterEvaluator);
+                return parameterEvaluator;
+            }
             case ATTRIBUTE_REFERENCE: {
                 final Evaluator<?> childEvaluator = buildEvaluator(tree.getChild(0));
                 if (childEvaluator instanceof MultiAttributeEvaluator) {
@@ -948,7 +957,7 @@ public Evaluator<?> buildEvaluator(final Tree tree) {
 
                 final List<String> attributeNames = new ArrayList<>();
                 for (int i = 1; i < tree.getChildCount(); i++) {  // skip the first child because that's the name of the multi-attribute function
-                    attributeNames.add(newStringLiteralEvaluator(tree.getChild(i).getText()).evaluate(null, new EvaluatorState()).getValue());
+                    attributeNames.add(newStringLiteralEvaluator(tree.getChild(i).getText()).evaluate(new StandardEvaluationContext(Collections.emptyMap())).getValue());
                 }
 
                 switch (multiAttrType) {
@@ -1099,7 +1108,8 @@ private Evaluator<String> newStringLiteralEvaluator(final String literalValue) {
 
         final List<Range> ranges = Query.extractExpressionRanges(literalValue);
         if (ranges.isEmpty()) {
-            return addToken(new StringLiteralEvaluator(literalValue), literalValue);
+            final List<Range> escapedRanges = Query.extractEscapedRanges(literalValue);
+            return newStringLiteralEvaluatorForEscapedRanges(literalValue, escapedRanges);
         }
 
         final List<Evaluator<?>> evaluators = new ArrayList<>();
@@ -1142,6 +1152,44 @@ private Evaluator<String> newStringLiteralEvaluator(final String literalValue) {
         return lastEvaluator;
     }
 
+    private Evaluator<String> newStringLiteralEvaluatorForEscapedRanges(final String literalValue, final List<Range> escapedRanges) {
+        if (escapedRanges.isEmpty()) {
+            return addToken(new StringLiteralEvaluator(literalValue), literalValue);
+        }
+
+        int lastIndex = 0;
+        final List<Evaluator<?>> evaluators = new ArrayList<>();
+        for (final Range range : escapedRanges) {
+            final String treeText = literalValue.substring(range.getStart(), range.getEnd() + 1);
+
+            if (range.getStart() > lastIndex) {
+                evaluators.add(new StringLiteralEvaluator(literalValue.substring(lastIndex, range.getStart())));
+            }
+
+            final Evaluator<?> evaluator = new StringLiteralEvaluator(Query.unescape(treeText));
+            evaluators.add(evaluator);
+            lastIndex = range.getEnd() + 1;
+        }
+
+
+        final Range lastRange = escapedRanges.get(escapedRanges.size() - 1);
+        if (lastRange.getEnd() + 1 < literalValue.length()) {
+            final String treeText = literalValue.substring(lastRange.getEnd() + 1);
+            evaluators.add(new StringLiteralEvaluator(treeText));
+        }
+
+        if (evaluators.size() == 1) {
+            return toStringEvaluator(evaluators.get(0));
+        }
+
+        Evaluator<String> lastEvaluator = toStringEvaluator(evaluators.get(0));
+        for (int i = 1; i < evaluators.size(); i++) {
+            lastEvaluator = new AppendEvaluator(lastEvaluator, toStringEvaluator(evaluators.get(i)));
+        }
+
+        this.evaluators.addAll(evaluators);
+        return lastEvaluator;
+    }
 
     private Evaluator<Boolean> buildBooleanEvaluator(final Tree tree) {
         switch (tree.getType()) {
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/BooleanEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/BooleanEvaluator.java
index 5e63d168255..c75427f184b 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/BooleanEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/BooleanEvaluator.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation;
 
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 
 public abstract class BooleanEvaluator implements Evaluator<Boolean> {
@@ -27,7 +28,7 @@ public ResultType getResultType() {
     }
 
     @Override
-    public int getEvaluationsRemaining(final EvaluatorState context) {
+    public int getEvaluationsRemaining(final EvaluationContext context) {
         return 0;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/DateEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/DateEvaluator.java
index 352952e110b..4e48025ee24 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/DateEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/DateEvaluator.java
@@ -16,10 +16,11 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation;
 
-import java.util.Date;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 
+import java.util.Date;
+
 public abstract class DateEvaluator implements Evaluator<Date> {
     private String token;
 
@@ -29,7 +30,7 @@ public ResultType getResultType() {
     }
 
     @Override
-    public int getEvaluationsRemaining(final EvaluatorState context) {
+    public int getEvaluationsRemaining(final EvaluationContext context) {
         return 0;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/DateQueryResult.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/DateQueryResult.java
index a77bbe9592b..3d55e2ab51e 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/DateQueryResult.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/DateQueryResult.java
@@ -16,10 +16,10 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation;
 
-import java.util.Date;
-
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 
+import java.util.Date;
+
 public class DateQueryResult implements QueryResult<Date> {
 
     private final Date date;
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/DecimalEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/DecimalEvaluator.java
index 760269000b7..1134fb67fd9 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/DecimalEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/DecimalEvaluator.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation;
 
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 
 public abstract class DecimalEvaluator implements Evaluator<Double> {
@@ -27,7 +28,7 @@ public ResultType getResultType() {
     }
 
     @Override
-    public int getEvaluationsRemaining(final EvaluatorState context) {
+    public int getEvaluationsRemaining(final EvaluationContext context) {
         return 0;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/Evaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/Evaluator.java
index 499f93debf3..332f7b80484 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/Evaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/Evaluator.java
@@ -16,17 +16,16 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 
 public interface Evaluator<T> {
 
-    QueryResult<T> evaluate(Map<String, String> attributes, EvaluatorState context);
+    QueryResult<T> evaluate(EvaluationContext evaluationContext);
 
     ResultType getResultType();
 
-    int getEvaluationsRemaining(EvaluatorState context);
+    int getEvaluationsRemaining(EvaluationContext context);
 
     Evaluator<?> getSubjectEvaluator();
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/NumberEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/NumberEvaluator.java
index 99d054f0f3b..d1f931a76b8 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/NumberEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/NumberEvaluator.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation;
 
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 
 public abstract class NumberEvaluator implements Evaluator<Number> {
@@ -27,7 +28,7 @@ public ResultType getResultType() {
     }
 
     @Override
-    public int getEvaluationsRemaining(final EvaluatorState context) {
+    public int getEvaluationsRemaining(final EvaluationContext context) {
         return 0;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/StringEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/StringEvaluator.java
index e3cdad449c7..2948a8477d5 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/StringEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/StringEvaluator.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation;
 
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 
 public abstract class StringEvaluator implements Evaluator<String> {
@@ -27,7 +28,7 @@ public ResultType getResultType() {
     }
 
     @Override
-    public int getEvaluationsRemaining(EvaluatorState context) {
+    public int getEvaluationsRemaining(EvaluationContext context) {
         return 0;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/WholeNumberEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/WholeNumberEvaluator.java
index 1389dbccb87..2cab771d95c 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/WholeNumberEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/WholeNumberEvaluator.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation;
 
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 
 public abstract class WholeNumberEvaluator implements Evaluator<Long> {
@@ -27,7 +28,7 @@ public ResultType getResultType() {
     }
 
     @Override
-    public int getEvaluationsRemaining(final EvaluatorState context) {
+    public int getEvaluationsRemaining(final EvaluationContext context) {
         return 0;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/BooleanCastEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/BooleanCastEvaluator.java
index 7d0928c3d23..7371dffa1d2 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/BooleanCastEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/BooleanCastEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.cast;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -34,8 +32,8 @@ public BooleanCastEvaluator(final StringEvaluator subjectEvaluator) {
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final QueryResult<String> result = subjectEvaluator.evaluate(attributes, context);
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final QueryResult<String> result = subjectEvaluator.evaluate(evaluationContext);
         if (result.getValue() == null) {
             return new BooleanQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/DateCastEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/DateCastEvaluator.java
index 33c82a18ba0..b7c4428e6d0 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/DateCastEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/DateCastEvaluator.java
@@ -16,17 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.cast;
 
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.Map;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.DateEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.DateQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberQueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
@@ -35,6 +27,13 @@
 import org.apache.nifi.attribute.expression.language.exception.AttributeExpressionLanguageParsingException;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 public class DateCastEvaluator extends DateEvaluator {
 
     public static final String DATE_TO_STRING_FORMAT = "EEE MMM dd HH:mm:ss zzz yyyy";
@@ -57,8 +56,8 @@ public DateCastEvaluator(final Evaluator<?> subjectEvaluator) {
     }
 
     @Override
-    public QueryResult<Date> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final QueryResult<?> result = subjectEvaluator.evaluate(attributes, context);
+    public QueryResult<Date> evaluate(final EvaluationContext evaluationContext) {
+        final QueryResult<?> result = subjectEvaluator.evaluate(evaluationContext);
         if (result.getValue() == null) {
             return new DateQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/DecimalCastEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/DecimalCastEvaluator.java
index 5cbfde2a13b..6f84bc684fb 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/DecimalCastEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/DecimalCastEvaluator.java
@@ -16,10 +16,10 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.cast;
 
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.DateQueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.DecimalEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.DecimalQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberQueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
@@ -29,8 +29,6 @@
 import org.apache.nifi.attribute.expression.language.exception.AttributeExpressionLanguageParsingException;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 
-import java.util.Map;
-
 public class DecimalCastEvaluator extends DecimalEvaluator {
 
     private final Evaluator<?> subjectEvaluator;
@@ -43,8 +41,8 @@ public DecimalCastEvaluator(final Evaluator<?> subjectEvaluator) {
     }
 
     @Override
-    public QueryResult<Double> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final QueryResult<?> result = subjectEvaluator.evaluate(attributes, context);
+    public QueryResult<Double> evaluate(final EvaluationContext evaluationContext) {
+        final QueryResult<?> result = subjectEvaluator.evaluate(evaluationContext);
         if (result.getValue() == null) {
             return new DecimalQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/NumberCastEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/NumberCastEvaluator.java
index c9bda44dda8..5de82a1bc34 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/NumberCastEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/NumberCastEvaluator.java
@@ -16,9 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.cast;
 
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.DateQueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.DecimalQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberQueryResult;
@@ -29,8 +29,6 @@
 import org.apache.nifi.attribute.expression.language.exception.AttributeExpressionLanguageParsingException;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 
-import java.util.Map;
-
 public class NumberCastEvaluator extends NumberEvaluator {
 
     private final Evaluator<?> subjectEvaluator;
@@ -43,8 +41,8 @@ public NumberCastEvaluator(final Evaluator<?> subjectEvaluator) {
     }
 
     @Override
-    public QueryResult<Number> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final QueryResult<?> result = subjectEvaluator.evaluate(attributes, context);
+    public QueryResult<Number> evaluate(final EvaluationContext evaluationContext) {
+        final QueryResult<?> result = subjectEvaluator.evaluate(evaluationContext);
         if (result.getValue() == null) {
             return new NumberQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/StringCastEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/StringCastEvaluator.java
index 37ff48579df..ff36b522abe 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/StringCastEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/StringCastEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.cast;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -33,8 +31,8 @@ public StringCastEvaluator(final Evaluator<?> subjectEvaluator) {
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final QueryResult<?> result = subjectEvaluator.evaluate(attributes, context);
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final QueryResult<?> result = subjectEvaluator.evaluate(evaluationContext);
         if (result.getValue() == null) {
             return new StringQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/WholeNumberCastEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/WholeNumberCastEvaluator.java
index 4dfefea683f..d74ff180724 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/WholeNumberCastEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/cast/WholeNumberCastEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.cast;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.DateQueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.DecimalQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberQueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
@@ -43,8 +41,8 @@ public WholeNumberCastEvaluator(final Evaluator<?> subjectEvaluator) {
     }
 
     @Override
-    public QueryResult<Long> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final QueryResult<?> result = subjectEvaluator.evaluate(attributes, context);
+    public QueryResult<Long> evaluate(final EvaluationContext evaluationContext) {
+        final QueryResult<?> result = subjectEvaluator.evaluate(evaluationContext);
         if (result.getValue() == null) {
             return new WholeNumberQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/AndEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/AndEvaluator.java
index db4f000f7e9..ae326dac3bd 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/AndEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/AndEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -35,8 +33,8 @@ public AndEvaluator(final Evaluator<Boolean> subjectEvaluator, final Evaluator<B
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final QueryResult<Boolean> subjectValue = subjectEvaluator.evaluate(attributes, context);
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final QueryResult<Boolean> subjectValue = subjectEvaluator.evaluate(evaluationContext);
         if (subjectValue == null) {
             return new BooleanQueryResult(null);
         }
@@ -48,19 +46,19 @@ public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final
         // Returning previously evaluated result.
         // The same AndEvaluator can be evaluated multiple times if subjectEvaluator is IteratingEvaluator.
         // In that case, it's enough to evaluate the right hand side.
-        final BooleanQueryResult rhsResult = context.getState(this, BooleanQueryResult.class);
+        final BooleanQueryResult rhsResult = evaluationContext.getEvaluatorState().getState(this, BooleanQueryResult.class);
         if (rhsResult != null) {
             return rhsResult;
         }
 
-        final QueryResult<Boolean> rhsValue = rhsEvaluator.evaluate(attributes, context);
+        final QueryResult<Boolean> rhsValue = rhsEvaluator.evaluate(evaluationContext);
         BooleanQueryResult result;
         if (rhsValue == null) {
             result = new BooleanQueryResult(false);
         } else {
             result = new BooleanQueryResult(rhsValue.getValue());
         }
-        context.putState(this, result);
+        evaluationContext.getEvaluatorState().putState(this, result);
         return result;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/AppendEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/AppendEvaluator.java
index 55413988333..cdb74086420 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/AppendEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/AppendEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -35,9 +33,9 @@ public AppendEvaluator(final Evaluator<String> subject, final Evaluator<String>
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
-        final String appendValue = appendEvaluator.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
+        final String appendValue = appendEvaluator.evaluate(evaluationContext).getValue();
 
         final String result = (subjectValue == null ? "" : subjectValue)
                 + (appendValue == null ? "" : appendValue);
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/Base64DecodeEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/Base64DecodeEvaluator.java
index 39147c2bf01..fdf360dc356 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/Base64DecodeEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/Base64DecodeEvaluator.java
@@ -16,16 +16,15 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.io.UnsupportedEncodingException;
-import java.util.Base64;
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.StringQueryResult;
 
+import java.io.UnsupportedEncodingException;
+import java.util.Base64;
+
 public class Base64DecodeEvaluator extends StringEvaluator {
 
     private final Evaluator<String> subject;
@@ -35,8 +34,8 @@ public Base64DecodeEvaluator(final Evaluator<String> subject) {
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/Base64EncodeEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/Base64EncodeEvaluator.java
index 7fef9805a2a..4ed4ecbcb70 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/Base64EncodeEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/Base64EncodeEvaluator.java
@@ -16,16 +16,15 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.io.UnsupportedEncodingException;
-import java.util.Base64;
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.StringQueryResult;
 
+import java.nio.charset.StandardCharsets;
+import java.util.Base64;
+
 public class Base64EncodeEvaluator extends StringEvaluator {
 
     private final Evaluator<String> subject;
@@ -35,17 +34,13 @@ public Base64EncodeEvaluator(final Evaluator<String> subject) {
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult(null);
         }
 
-        try {
-            return new StringQueryResult(Base64.getEncoder().encodeToString(subjectValue.getBytes("UTF-8")));
-        } catch (final UnsupportedEncodingException e) {
-            return null;    // won't happen.
-        }
+        return new StringQueryResult(Base64.getEncoder().encodeToString(subjectValue.getBytes(StandardCharsets.UTF_8)));
     }
 
     @Override
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/CharSequenceTranslatorEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/CharSequenceTranslatorEvaluator.java
index fbd3e8ac828..3ca05262ea2 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/CharSequenceTranslatorEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/CharSequenceTranslatorEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
 import org.apache.commons.text.StringEscapeUtils;
 import org.apache.commons.text.translate.CharSequenceTranslator;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -76,8 +74,8 @@ public CharSequenceTranslatorEvaluator(final Evaluator<String> subject, CharSequ
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         return new StringQueryResult(subjectValue == null ? "" : method.translate(subjectValue));
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ContainsEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ContainsEvaluator.java
index 4de3dd4fd2f..df4fd298e57 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ContainsEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ContainsEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -35,13 +33,13 @@ public ContainsEvaluator(final Evaluator<String> subject, final Evaluator<String
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new BooleanQueryResult(false);
         }
 
-        final String searchString = search.evaluate(attributes, context).getValue();
+        final String searchString = search.evaluate(evaluationContext).getValue();
         return new BooleanQueryResult(searchString == null ? false : subjectValue.contains(searchString));
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/DivideEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/DivideEvaluator.java
index 396c30cdcfc..5ee5cec44b5 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/DivideEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/DivideEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberQueryResult;
@@ -35,13 +33,13 @@ public DivideEvaluator(final Evaluator<Number> subject, final Evaluator<Number>
     }
 
     @Override
-    public QueryResult<Number> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Number subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Number> evaluate(final EvaluationContext evaluationContext) {
+        final Number subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new NumberQueryResult(null);
         }
 
-        final Number divide = divideValue.evaluate(attributes, context).getValue();
+        final Number divide = divideValue.evaluate(evaluationContext).getValue();
         if (divide == null) {
             return new NumberQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/EndsWithEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/EndsWithEvaluator.java
index c40cb1d1033..3d915bbe0c1 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/EndsWithEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/EndsWithEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -35,13 +33,13 @@ public EndsWithEvaluator(final Evaluator<String> subject, final Evaluator<String
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new BooleanQueryResult(false);
         }
 
-        final String searchString = search.evaluate(attributes, context).getValue();
+        final String searchString = search.evaluate(evaluationContext).getValue();
         return new BooleanQueryResult(searchString == null ? false : subjectValue.endsWith(searchString));
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/EqualsEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/EqualsEvaluator.java
index a00a96a0e2e..597bfd78e41 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/EqualsEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/EqualsEvaluator.java
@@ -16,16 +16,15 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Date;
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 
+import java.util.Date;
+
 public class EqualsEvaluator extends BooleanEvaluator {
 
     private final Evaluator<?> subject;
@@ -37,13 +36,13 @@ public EqualsEvaluator(final Evaluator<?> subject, final Evaluator<?> compareTo)
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Object a = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final Object a = subject.evaluate(evaluationContext).getValue();
         if (a == null) {
             return new BooleanQueryResult(false);
         }
 
-        final Object b = compareTo.evaluate(attributes, context).getValue();
+        final Object b = compareTo.evaluate(evaluationContext).getValue();
         if (b == null) {
             return new BooleanQueryResult(false);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/EqualsIgnoreCaseEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/EqualsIgnoreCaseEvaluator.java
index b2364ddcb6c..af6a6e1654a 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/EqualsIgnoreCaseEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/EqualsIgnoreCaseEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -35,13 +33,13 @@ public EqualsIgnoreCaseEvaluator(final Evaluator<?> subject, final Evaluator<?>
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Object a = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final Object a = subject.evaluate(evaluationContext).getValue();
         if (a == null) {
             return new BooleanQueryResult(false);
         }
 
-        final Object b = compareTo.evaluate(attributes, context).getValue();
+        final Object b = compareTo.evaluate(evaluationContext).getValue();
         if (b == null) {
             return new BooleanQueryResult(false);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/FindEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/FindEvaluator.java
index 7b10153a45e..2193b8c4d00 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/FindEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/FindEvaluator.java
@@ -16,16 +16,17 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-import java.util.regex.Pattern;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
+import org.apache.nifi.attribute.expression.language.StandardEvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.literals.StringLiteralEvaluator;
 
+import java.util.Collections;
+import java.util.regex.Pattern;
+
 public class FindEvaluator extends BooleanEvaluator {
 
     private final Evaluator<String> subject;
@@ -40,21 +41,21 @@ public FindEvaluator(final Evaluator<String> subject, final Evaluator<String> se
         // if the search string is a literal, we don't need to evaluate it each time; we can just
         // pre-compile it. Otherwise, it must be compiled every time.
         if (search instanceof StringLiteralEvaluator) {
-            this.compiledPattern = Pattern.compile(search.evaluate(null, new EvaluatorState()).getValue());
+            this.compiledPattern = Pattern.compile(search.evaluate(new StandardEvaluationContext(Collections.emptyMap())).getValue());
         } else {
             this.compiledPattern = null;
         }
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new BooleanQueryResult(false);
         }
         final Pattern pattern;
         if (compiledPattern == null) {
-            String expression = search.evaluate(attributes, context).getValue();
+            String expression = search.evaluate(evaluationContext).getValue();
             if (expression == null) {
                 return new BooleanQueryResult(false);
             }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/FormatEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/FormatEvaluator.java
index 53540bb8066..1daa427d378 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/FormatEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/FormatEvaluator.java
@@ -16,19 +16,18 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.Map;
-import java.util.TimeZone;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.DateEvaluator;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.StringQueryResult;
 
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+
 public class FormatEvaluator extends StringEvaluator {
 
     private final DateEvaluator subject;
@@ -42,13 +41,13 @@ public FormatEvaluator(final DateEvaluator subject, final Evaluator<String> form
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Date subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final Date subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult(null);
         }
 
-        final QueryResult<String> formatResult = format.evaluate(attributes, context);
+        final QueryResult<String> formatResult = format.evaluate(evaluationContext);
         final String format = formatResult.getValue();
         if (format == null) {
             return null;
@@ -57,7 +56,7 @@ public QueryResult<String> evaluate(final Map<String, String> attributes, final
         final SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.US);
 
         if(timeZone != null) {
-            final QueryResult<String> tzResult = timeZone.evaluate(attributes, context);
+            final QueryResult<String> tzResult = timeZone.evaluate(evaluationContext);
             final String tz = tzResult.getValue();
             if(tz != null && TimeZone.getTimeZone(tz) != null) {
                 sdf.setTimeZone(TimeZone.getTimeZone(tz));
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/FromRadixEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/FromRadixEvaluator.java
index 2470b5bbf5a..47c31e20ebe 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/FromRadixEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/FromRadixEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.WholeNumberEvaluator;
@@ -35,13 +33,13 @@ public FromRadixEvaluator(final Evaluator<String> subject, final Evaluator<Long>
     }
 
     @Override
-    public QueryResult<Long> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String result = numberEvaluator.evaluate(attributes, context).getValue();
+    public QueryResult<Long> evaluate(final EvaluationContext evaluationContext) {
+        final String result = numberEvaluator.evaluate(evaluationContext).getValue();
         if (result == null) {
             return new WholeNumberQueryResult(null);
         }
 
-        final Long radix = radixEvaluator.evaluate(attributes, context).getValue();
+        final Long radix = radixEvaluator.evaluate(evaluationContext).getValue();
         if (radix == null) {
             return new WholeNumberQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GetDelimitedFieldEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GetDelimitedFieldEvaluator.java
index cc715de72b6..f6144b8eda4 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GetDelimitedFieldEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GetDelimitedFieldEvaluator.java
@@ -17,9 +17,7 @@
 
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -65,13 +63,13 @@ public GetDelimitedFieldEvaluator(final Evaluator<String> subject, final Evaluat
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subject = subjectEval.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subject = subjectEval.evaluate(evaluationContext).getValue();
         if (subject == null || subject.isEmpty()) {
             return new StringQueryResult("");
         }
 
-        final Long index = indexEval.evaluate(attributes, context).getValue();
+        final Long index = indexEval.evaluate(evaluationContext).getValue();
         if (index == null) {
             throw new AttributeExpressionLanguageException("Cannot evaluate getDelimitedField function because the index (which field to obtain) was not specified");
         }
@@ -79,7 +77,7 @@ public QueryResult<String> evaluate(final Map<String, String> attributes, final
             return new StringQueryResult("");
         }
 
-        final String delimiter = delimiterEval.evaluate(attributes, context).getValue();
+        final String delimiter = delimiterEval.evaluate(evaluationContext).getValue();
         if (delimiter == null || delimiter.isEmpty()) {
             throw new AttributeExpressionLanguageException("Cannot evaluate getDelimitedField function because the delimiter was not specified");
         } else if (delimiter.length() > 1) {
@@ -87,7 +85,7 @@ public QueryResult<String> evaluate(final Map<String, String> attributes, final
                 + "\", but only a single character is allowed.");
         }
 
-        final String quoteString = quoteCharEval.evaluate(attributes, context).getValue();
+        final String quoteString = quoteCharEval.evaluate(evaluationContext).getValue();
         if (quoteString == null || quoteString.isEmpty()) {
             throw new AttributeExpressionLanguageException("Cannot evaluate getDelimitedField function because the quote character "
                 + "(which character is used to enclose values that contain the delimiter) was not specified");
@@ -96,7 +94,7 @@ public QueryResult<String> evaluate(final Map<String, String> attributes, final
                 + "(which character is used to enclose values that contain the delimiter) evaluated to \"" + quoteString + "\", but only a single character is allowed.");
         }
 
-        final String escapeString = escapeCharEval.evaluate(attributes, context).getValue();
+        final String escapeString = escapeCharEval.evaluate(evaluationContext).getValue();
         if (escapeString == null || escapeString.isEmpty()) {
             throw new AttributeExpressionLanguageException("Cannot evaluate getDelimitedField function because the escape character "
                 + "(which character is used to escape the quote character or delimiter) was not specified");
@@ -105,7 +103,7 @@ public QueryResult<String> evaluate(final Map<String, String> attributes, final
                 + "(which character is used to escape the quote character or delimiter) evaluated to \"" + escapeString + "\", but only a single character is allowed.");
         }
 
-        Boolean stripChars = stripCharsEval.evaluate(attributes, context).getValue();
+        Boolean stripChars = stripCharsEval.evaluate(evaluationContext).getValue();
         if (stripChars == null) {
             stripChars = Boolean.FALSE;
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GetStateVariableEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GetStateVariableEvaluator.java
index 8bf7111ccf9..8f3b0d0fe4c 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GetStateVariableEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GetStateVariableEvaluator.java
@@ -17,10 +17,7 @@
 
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.AttributesAndState;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -35,21 +32,13 @@ public GetStateVariableEvaluator(final Evaluator<String> subject) {
     }
 
     @Override
-    public QueryResult<String> evaluate(Map<String, String> attributes, final EvaluatorState context) {
-        if (!(attributes instanceof AttributesAndState)){
-            return new StringQueryResult(null);
-        }
-
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult(null);
         }
 
-        AttributesAndState attributesAndState = (AttributesAndState) attributes;
-
-        Map<String, String> stateMap = attributesAndState.getStateMap();
-        String stateValue = stateMap.get(subjectValue);
-
+        final String stateValue = evaluationContext.getState(subjectValue);
         return new StringQueryResult(stateValue);
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GreaterThanEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GreaterThanEvaluator.java
index 51c14f16ce7..265a98a4226 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GreaterThanEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GreaterThanEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -35,13 +33,13 @@ public GreaterThanEvaluator(final Evaluator<Number> subject, final Evaluator<Num
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Number subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final Number subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new BooleanQueryResult(false);
         }
 
-        final Number comparisonValue = comparison.evaluate(attributes, context).getValue();
+        final Number comparisonValue = comparison.evaluate(evaluationContext).getValue();
         if (comparisonValue == null) {
             return new BooleanQueryResult(false);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GreaterThanOrEqualEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GreaterThanOrEqualEvaluator.java
index fcb4db5c735..05b4ae79a14 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GreaterThanOrEqualEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/GreaterThanOrEqualEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -35,13 +33,13 @@ public GreaterThanOrEqualEvaluator(final Evaluator<Number> subject, final Evalua
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Number subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final Number subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new BooleanQueryResult(false);
         }
 
-        final Number comparisonValue = comparison.evaluate(attributes, context).getValue();
+        final Number comparisonValue = comparison.evaluate(evaluationContext).getValue();
         if (comparisonValue == null) {
             return new BooleanQueryResult(false);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/HostnameEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/HostnameEvaluator.java
index c0c1e5a1496..f7d517653c2 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/HostnameEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/HostnameEvaluator.java
@@ -16,16 +16,16 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.StringQueryResult;
 
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
+
 public class HostnameEvaluator extends StringEvaluator {
 
     private final StringQueryResult hostname;
@@ -47,7 +47,7 @@ public HostnameEvaluator(final boolean preferFQDN) throws UnknownHostException {
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
         return hostname;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IPEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IPEvaluator.java
index dcde5269eaf..f6e12491925 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IPEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IPEvaluator.java
@@ -16,16 +16,15 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.net.InetAddress;
-import java.net.UnknownHostException;
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.StringQueryResult;
 
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+
 public class IPEvaluator extends StringEvaluator {
 
     private final StringQueryResult ipAddress;
@@ -35,7 +34,7 @@ public IPEvaluator() throws UnknownHostException {
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
         return ipAddress;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IfElseEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IfElseEvaluator.java
index b1e21a9314e..9eee405ee4e 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IfElseEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IfElseEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -37,12 +35,12 @@ public IfElseEvaluator(final Evaluator<Boolean> subject, final Evaluator<String>
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final QueryResult<Boolean> subjectValue = subject.evaluate(attributes, context);
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final QueryResult<Boolean> subjectValue = subject.evaluate(evaluationContext);
         if (subjectValue == null) {
             return new StringQueryResult(null);
         }
-        final String ifElseValue = (Boolean.TRUE.equals(subjectValue.getValue())) ? trueEvaluator.evaluate(attributes, context).getValue() : falseEvaluator.evaluate(attributes, context).getValue();
+        final String ifElseValue = (Boolean.TRUE.equals(subjectValue.getValue())) ? trueEvaluator.evaluate(evaluationContext).getValue() : falseEvaluator.evaluate(evaluationContext).getValue();
         return new StringQueryResult(ifElseValue);
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/InEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/InEvaluator.java
index 8fc81e4e94c..a62fa70dcbb 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/InEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/InEvaluator.java
@@ -16,15 +16,14 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.List;
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
+import java.util.List;
+
 public class InEvaluator extends BooleanEvaluator {
 
     private final Evaluator<String> subject;
@@ -36,15 +35,15 @@ public InEvaluator(final Evaluator<String> subject, final List<Evaluator<String>
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new BooleanQueryResult(false);
         }
 
         boolean isInList = false;
         for (Evaluator<String> evaluator : search) {
-            final String searchString = evaluator.evaluate(attributes, context).getValue();
+            final String searchString = evaluator.evaluate(evaluationContext).getValue();
             isInList = searchString == null ? false : subjectValue.equals(searchString);
             if(isInList) {
                 break;
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IndexOfEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IndexOfEvaluator.java
index 7979afbe56f..229d096f78c 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IndexOfEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IndexOfEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.WholeNumberEvaluator;
@@ -35,13 +33,12 @@ public IndexOfEvaluator(final Evaluator<String> subject, final Evaluator<String>
     }
 
     @Override
-    public QueryResult<Long> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Long> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new WholeNumberQueryResult(-1L);
         }
-        final String indexEvalValue = indexEvaluator.evaluate(attributes, context).getValue();
-
+        final String indexEvalValue = indexEvaluator.evaluate(evaluationContext).getValue();
         return new WholeNumberQueryResult((long) subjectValue.indexOf(indexEvalValue));
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IsEmptyEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IsEmptyEvaluator.java
index 9253a03c38f..228b7f5483f 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IsEmptyEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IsEmptyEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -33,8 +31,8 @@ public IsEmptyEvaluator(final Evaluator<?> subjectEvaluator) {
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Object subjectValue = subjectEvaluator.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final Object subjectValue = subjectEvaluator.evaluate(evaluationContext).getValue();
         return new BooleanQueryResult(subjectValue == null || subjectValue.toString().trim().isEmpty());
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IsNullEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IsNullEvaluator.java
index 22f16bc67b1..6955b32f9fc 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IsNullEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/IsNullEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -33,8 +31,8 @@ public IsNullEvaluator(final Evaluator<?> subject) {
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Object subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final Object subjectValue = subject.evaluate(evaluationContext).getValue();
         return new BooleanQueryResult(subjectValue == null);
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/JsonPathEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/JsonPathEvaluator.java
index a085af44313..aadb3242f4d 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/JsonPathEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/JsonPathEvaluator.java
@@ -16,11 +16,14 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import com.jayway.jsonpath.Configuration;
+import com.jayway.jsonpath.DocumentContext;
+import com.jayway.jsonpath.InvalidJsonException;
+import com.jayway.jsonpath.JsonPath;
+import com.jayway.jsonpath.spi.json.JacksonJsonProvider;
+import com.jayway.jsonpath.spi.json.JsonProvider;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
+import org.apache.nifi.attribute.expression.language.StandardEvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -28,12 +31,10 @@
 import org.apache.nifi.attribute.expression.language.evaluation.literals.StringLiteralEvaluator;
 import org.apache.nifi.attribute.expression.language.exception.AttributeExpressionLanguageException;
 
-import com.jayway.jsonpath.Configuration;
-import com.jayway.jsonpath.DocumentContext;
-import com.jayway.jsonpath.InvalidJsonException;
-import com.jayway.jsonpath.JsonPath;
-import com.jayway.jsonpath.spi.json.JacksonJsonProvider;
-import com.jayway.jsonpath.spi.json.JsonProvider;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
 
 
 public class JsonPathEvaluator extends StringEvaluator {
@@ -53,7 +54,7 @@ public JsonPathEvaluator(final Evaluator<String> subject, final Evaluator<String
         // time; we can just
         // pre-compile it. Otherwise, it must be compiled every time.
         if (jsonPathExp instanceof StringLiteralEvaluator) {
-            precompiledJsonPathExp = compileJsonPathExpression(jsonPathExp.evaluate(null, new EvaluatorState()).getValue());
+            precompiledJsonPathExp = compileJsonPathExpression(jsonPathExp.evaluate(new StandardEvaluationContext(Collections.emptyMap())).getValue());
         } else {
             precompiledJsonPathExp = null;
         }
@@ -61,8 +62,8 @@ public JsonPathEvaluator(final Evaluator<String> subject, final Evaluator<String
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null || subjectValue.length() == 0) {
             throw new  AttributeExpressionLanguageException("Subject is empty");
         }
@@ -77,7 +78,7 @@ public QueryResult<String> evaluate(final Map<String, String> attributes, final
         if (precompiledJsonPathExp != null) {
             compiledJsonPath = precompiledJsonPathExp;
         } else {
-            compiledJsonPath = compileJsonPathExpression(jsonPathExp.evaluate(attributes, context).getValue());
+            compiledJsonPath = compileJsonPathExpression(jsonPathExp.evaluate(evaluationContext).getValue());
         }
 
         Object result = null;
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LastIndexOfEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LastIndexOfEvaluator.java
index fe311b0375c..8209c4ab6a6 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LastIndexOfEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LastIndexOfEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.WholeNumberEvaluator;
@@ -35,12 +33,12 @@ public LastIndexOfEvaluator(final Evaluator<String> subject, final Evaluator<Str
     }
 
     @Override
-    public QueryResult<Long> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Long> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new WholeNumberQueryResult(-1L);
         }
-        final String indexEvalValue = indexEvaluator.evaluate(attributes, context).getValue();
+        final String indexEvalValue = indexEvaluator.evaluate(evaluationContext).getValue();
 
         return new WholeNumberQueryResult((long) subjectValue.lastIndexOf(indexEvalValue));
     }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LengthEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LengthEvaluator.java
index 8e4d2a80c97..d0f513b7c49 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LengthEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LengthEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.WholeNumberEvaluator;
@@ -33,8 +31,8 @@ public LengthEvaluator(final Evaluator<String> subject) {
     }
 
     @Override
-    public QueryResult<Long> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Long> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         return new WholeNumberQueryResult((long) (subjectValue == null ? 0 : subjectValue.length()));
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LessThanEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LessThanEvaluator.java
index 59a014e67d8..fd123d1d75e 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LessThanEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LessThanEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -35,13 +33,13 @@ public LessThanEvaluator(final Evaluator<Number> subject, final Evaluator<Number
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Number subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final Number subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new BooleanQueryResult(false);
         }
 
-        final Number comparisonValue = comparison.evaluate(attributes, context).getValue();
+        final Number comparisonValue = comparison.evaluate(evaluationContext).getValue();
         if (comparisonValue == null) {
             return new BooleanQueryResult(false);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LessThanOrEqualEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LessThanOrEqualEvaluator.java
index 3ce14bdb0eb..6ffba46e8df 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LessThanOrEqualEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/LessThanOrEqualEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -35,13 +33,13 @@ public LessThanOrEqualEvaluator(final Evaluator<Number> subject, final Evaluator
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Number subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final Number subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new BooleanQueryResult(false);
         }
 
-        final Number comparisonValue = comparison.evaluate(attributes, context).getValue();
+        final Number comparisonValue = comparison.evaluate(evaluationContext).getValue();
         if (comparisonValue == null) {
             return new BooleanQueryResult(false);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MatchesEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MatchesEvaluator.java
index b9709059dfa..5aac0deafca 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MatchesEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MatchesEvaluator.java
@@ -16,16 +16,17 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-import java.util.regex.Pattern;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
+import org.apache.nifi.attribute.expression.language.StandardEvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.literals.StringLiteralEvaluator;
 
+import java.util.Collections;
+import java.util.regex.Pattern;
+
 public class MatchesEvaluator extends BooleanEvaluator {
 
     private final Evaluator<String> subject;
@@ -40,21 +41,21 @@ public MatchesEvaluator(final Evaluator<String> subject, final Evaluator<String>
         // if the search string is a literal, we don't need to evaluate it each time; we can just
         // pre-compile it. Otherwise, it must be compiled every time.
         if (search instanceof StringLiteralEvaluator) {
-            this.compiledPattern = Pattern.compile(search.evaluate(null, new EvaluatorState()).getValue());
+            this.compiledPattern = Pattern.compile(search.evaluate(new StandardEvaluationContext(Collections.emptyMap())).getValue());
         } else {
             this.compiledPattern = null;
         }
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new BooleanQueryResult(false);
         }
         final Pattern pattern;
         if (compiledPattern == null) {
-            String expression = search.evaluate(attributes, context).getValue();
+            String expression = search.evaluate(evaluationContext).getValue();
             if (expression == null) {
                 return new BooleanQueryResult(false);
             }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MathEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MathEvaluator.java
index 96bc3a6e6cf..709a8ebeb53 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MathEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MathEvaluator.java
@@ -16,17 +16,16 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberQueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.exception.AttributeExpressionLanguageException;
 
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
 public class MathEvaluator extends NumberEvaluator {
 
     private final Evaluator<Number> subject;
@@ -40,15 +39,15 @@ public MathEvaluator(final Evaluator<Number> subject, final Evaluator<String> me
     }
 
     @Override
-    public QueryResult<Number> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String methodNamedValue = methodName.evaluate(attributes, context).getValue();
+    public QueryResult<Number> evaluate(final EvaluationContext evaluationContext) {
+        final String methodNamedValue = methodName.evaluate(evaluationContext).getValue();
         if (methodNamedValue == null) {
             return new NumberQueryResult(null);
         }
 
         final Number subjectValue;
         if(subject != null) {
-            subjectValue = subject.evaluate(attributes, context).getValue();
+            subjectValue = subject.evaluate(evaluationContext).getValue();
             if(subjectValue == null){
                 return new NumberQueryResult(null);
             }
@@ -58,7 +57,7 @@ public QueryResult<Number> evaluate(final Map<String, String> attributes, final
 
         final Number optionalArgValue;
         if(optionalArg != null) {
-            optionalArgValue = optionalArg.evaluate(attributes, context).getValue();
+            optionalArgValue = optionalArg.evaluate(evaluationContext).getValue();
 
             if(optionalArgValue == null) {
                 return new NumberQueryResult(null);
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MinusEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MinusEvaluator.java
index 7011496aa09..0095104bb3a 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MinusEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MinusEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberQueryResult;
@@ -35,13 +33,13 @@ public MinusEvaluator(final Evaluator<Number> subject, final Evaluator<Number> m
     }
 
     @Override
-    public QueryResult<Number> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Number subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Number> evaluate(final EvaluationContext evaluationContext) {
+        final Number subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new NumberQueryResult(null);
         }
 
-        final Number minus = minusValue.evaluate(attributes, context).getValue();
+        final Number minus = minusValue.evaluate(evaluationContext).getValue();
         if (minus == null) {
             return new NumberQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ModEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ModEvaluator.java
index 3652327280e..b36ec237b74 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ModEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ModEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberQueryResult;
@@ -35,13 +33,13 @@ public ModEvaluator(final Evaluator<Number> subject, final Evaluator<Number> mod
     }
 
     @Override
-    public QueryResult<Number> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Number subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Number> evaluate(final EvaluationContext evaluationContext) {
+        final Number subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new NumberQueryResult(null);
         }
 
-        final Number mod = modValue.evaluate(attributes, context).getValue();
+        final Number mod = modValue.evaluate(evaluationContext).getValue();
         if (mod == null) {
             return new NumberQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MultiplyEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MultiplyEvaluator.java
index 9ee42f16b32..a704ec0ce6a 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MultiplyEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/MultiplyEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberQueryResult;
@@ -35,13 +33,13 @@ public MultiplyEvaluator(final Evaluator<Number> subject, final Evaluator<Number
     }
 
     @Override
-    public QueryResult<Number> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Number subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Number> evaluate(final EvaluationContext evaluationContext) {
+        final Number subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new NumberQueryResult(null);
         }
 
-        final Number multiply = multiplyValue.evaluate(attributes, context).getValue();
+        final Number multiply = multiplyValue.evaluate(evaluationContext).getValue();
         if (multiply == null) {
             return new NumberQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NotEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NotEvaluator.java
index 05cbcdcb111..cb47cccf49e 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NotEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NotEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -33,8 +31,8 @@ public NotEvaluator(final Evaluator<Boolean> subjectEvaluator) {
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final QueryResult<Boolean> subjectValue = subjectEvaluator.evaluate(attributes, context);
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final QueryResult<Boolean> subjectValue = subjectEvaluator.evaluate(evaluationContext);
         if (subjectValue == null) {
             return new BooleanQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NotNullEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NotNullEvaluator.java
index 47823b14e64..cefc21b82dc 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NotNullEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NotNullEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -33,8 +31,8 @@ public NotNullEvaluator(final Evaluator<?> subject) {
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Object subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final Object subjectValue = subject.evaluate(evaluationContext).getValue();
         return new BooleanQueryResult(subjectValue != null);
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NowEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NowEvaluator.java
index a8bfb125add..43d84cc1a84 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NowEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NowEvaluator.java
@@ -16,19 +16,18 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Date;
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.DateEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.DateQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
+import java.util.Date;
+
 public class NowEvaluator extends DateEvaluator {
 
     @Override
-    public QueryResult<Date> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
+    public QueryResult<Date> evaluate(final EvaluationContext evaluationContext) {
         return new DateQueryResult(new Date());
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NumberToDateEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NumberToDateEvaluator.java
index b06b0cc9347..731a22526d2 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NumberToDateEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/NumberToDateEvaluator.java
@@ -16,15 +16,14 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Date;
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.DateEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.DateQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
+import java.util.Date;
+
 public class NumberToDateEvaluator extends DateEvaluator {
 
     private final Evaluator<Long> subject;
@@ -34,8 +33,8 @@ public NumberToDateEvaluator(final Evaluator<Long> subject) {
     }
 
     @Override
-    public QueryResult<Date> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final QueryResult<Long> result = subject.evaluate(attributes, context);
+    public QueryResult<Date> evaluate(final EvaluationContext evaluationContext) {
+        final QueryResult<Long> result = subject.evaluate(evaluationContext);
         final Long value = result.getValue();
         if (value == null) {
             return new DateQueryResult(null);
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/OneUpSequenceEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/OneUpSequenceEvaluator.java
index d364bfcbfd7..62bde1aaed3 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/OneUpSequenceEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/OneUpSequenceEvaluator.java
@@ -16,21 +16,20 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-import java.util.concurrent.atomic.AtomicLong;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.WholeNumberEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.WholeNumberQueryResult;
 
+import java.util.concurrent.atomic.AtomicLong;
+
 public class OneUpSequenceEvaluator extends WholeNumberEvaluator {
 
     private static final AtomicLong value = new AtomicLong(0L);
 
     @Override
-    public QueryResult<Long> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
+    public QueryResult<Long> evaluate(final EvaluationContext evaluationContext) {
         return new WholeNumberQueryResult(value.getAndIncrement());
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/OrEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/OrEvaluator.java
index 71f34174734..f9769f91fef 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/OrEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/OrEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -35,8 +33,8 @@ public OrEvaluator(final Evaluator<Boolean> subjectEvaluator, final Evaluator<Bo
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final QueryResult<Boolean> subjectValue = subjectEvaluator.evaluate(attributes, context);
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final QueryResult<Boolean> subjectValue = subjectEvaluator.evaluate(evaluationContext);
         if (subjectValue == null) {
             return new BooleanQueryResult(null);
         }
@@ -48,19 +46,19 @@ public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final
         // Returning previously evaluated result.
         // The same OrEvaluator can be evaluated multiple times if subjectEvaluator is IteratingEvaluator.
         // In that case, it's enough to evaluate the right hand side.
-        final BooleanQueryResult rhsResult = context.getState(this, BooleanQueryResult.class);
+        final BooleanQueryResult rhsResult = evaluationContext.getEvaluatorState().getState(this, BooleanQueryResult.class);
         if (rhsResult != null) {
             return rhsResult;
         }
 
-        final QueryResult<Boolean> rhsValue = rhsEvaluator.evaluate(attributes, context);
+        final QueryResult<Boolean> rhsValue = rhsEvaluator.evaluate(evaluationContext);
         BooleanQueryResult result;
         if (rhsValue == null) {
             result = new BooleanQueryResult(false);
         } else {
             result = new BooleanQueryResult(rhsValue.getValue());
         }
-        context.putState(this, result);
+        evaluationContext.getEvaluatorState().putState(this, result);
         return result;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/PlusEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/PlusEvaluator.java
index 86492891a00..c9ca323cb28 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/PlusEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/PlusEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.NumberQueryResult;
@@ -35,13 +33,13 @@ public PlusEvaluator(final Evaluator<Number> subject, final Evaluator<Number> pl
     }
 
     @Override
-    public QueryResult<Number> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Number subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Number> evaluate(final EvaluationContext evaluationContext) {
+        final Number subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new NumberQueryResult(null);
         }
 
-        final Number plus = plusValue.evaluate(attributes, context).getValue();
+        final Number plus = plusValue.evaluate(evaluationContext).getValue();
         if (plus == null) {
             return new NumberQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/PrependEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/PrependEvaluator.java
index 6a6fdd1135d..0dcc05eb1e3 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/PrependEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/PrependEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -35,9 +33,9 @@ public PrependEvaluator(final Evaluator<String> subject, final Evaluator<String>
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
-        final String prependValue = prependEvaluator.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
+        final String prependValue = prependEvaluator.evaluate(evaluationContext).getValue();
 
         final String result = (prependValue == null ? "" : prependValue) + (subjectValue == null ? "" : subjectValue);
         return new StringQueryResult(result);
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/RandomNumberGeneratorEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/RandomNumberGeneratorEvaluator.java
index d68d491d066..739bccda0f0 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/RandomNumberGeneratorEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/RandomNumberGeneratorEvaluator.java
@@ -16,22 +16,21 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-import java.util.Random;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.WholeNumberEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.WholeNumberQueryResult;
 
+import java.util.Random;
+
 public class RandomNumberGeneratorEvaluator extends WholeNumberEvaluator {
 
     private static final Random RNG = new Random();
 
 
     @Override
-    public QueryResult<Long> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
+    public QueryResult<Long> evaluate(final EvaluationContext evaluationContext) {
         return new WholeNumberQueryResult(Math.abs(RNG.nextLong()));
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceAllEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceAllEvaluator.java
index 5c9c85f6967..aa0caaf8c7a 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceAllEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceAllEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -37,13 +35,13 @@ public ReplaceAllEvaluator(final Evaluator<String> subject, final Evaluator<Stri
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult(null);
         }
-        final String searchValue = search.evaluate(attributes, context).getValue();
-        final String replacementValue = replacement.evaluate(attributes, context).getValue();
+        final String searchValue = search.evaluate(evaluationContext).getValue();
+        final String replacementValue = replacement.evaluate(evaluationContext).getValue();
 
         return new StringQueryResult(subjectValue.replaceAll(searchValue, replacementValue));
     }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceEmptyEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceEmptyEvaluator.java
index 9528aa5b650..4157cc46118 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceEmptyEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceEmptyEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -34,12 +32,12 @@ public ReplaceEmptyEvaluator(final Evaluator<String> subjectEvaluator, final Eva
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final QueryResult<String> subjectResult = subjectEvaluator.evaluate(attributes, context);
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final QueryResult<String> subjectResult = subjectEvaluator.evaluate(evaluationContext);
         final String subjectValue = subjectResult.getValue();
         final boolean isEmpty = subjectValue == null || subjectValue.toString().trim().isEmpty();
         if (isEmpty) {
-            return replacementEvaluator.evaluate(attributes, context);
+            return replacementEvaluator.evaluate(evaluationContext);
         } else {
             return subjectResult;
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceEvaluator.java
index b95fc50d2ea..00b70381950 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -37,13 +35,13 @@ public ReplaceEvaluator(final Evaluator<String> subject, final Evaluator<String>
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult(null);
         }
-        final String searchValue = search.evaluate(attributes, context).getValue();
-        final String replacementValue = replacement.evaluate(attributes, context).getValue();
+        final String searchValue = search.evaluate(evaluationContext).getValue();
+        final String replacementValue = replacement.evaluate(evaluationContext).getValue();
 
         return new StringQueryResult(subjectValue.replace(searchValue, replacementValue));
     }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceFirstEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceFirstEvaluator.java
index 490c32c0dfa..10eaeabb7ba 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceFirstEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceFirstEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -37,13 +35,13 @@ public ReplaceFirstEvaluator(final Evaluator<String> subject, final Evaluator<St
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult(null);
         }
-        final String searchValue = search.evaluate(attributes, context).getValue();
-        final String replacementValue = replacement.evaluate(attributes, context).getValue();
+        final String searchValue = search.evaluate(evaluationContext).getValue();
+        final String replacementValue = replacement.evaluate(evaluationContext).getValue();
 
         return new StringQueryResult(subjectValue.replaceFirst(searchValue, replacementValue));
     }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceNullEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceNullEvaluator.java
index f044454ac55..d9c76a07cf4 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceNullEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ReplaceNullEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -35,9 +33,9 @@ public ReplaceNullEvaluator(final Evaluator<String> subject, final Evaluator<Str
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
-        return new StringQueryResult(subjectValue == null ? resultEvaluator.evaluate(attributes, context).getValue() : subjectValue);
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
+        return new StringQueryResult(subjectValue == null ? resultEvaluator.evaluate(evaluationContext).getValue() : subjectValue);
     }
 
     @Override
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/StartsWithEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/StartsWithEvaluator.java
index f17047ade8c..8c6e394d049 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/StartsWithEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/StartsWithEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -35,13 +33,13 @@ public StartsWithEvaluator(final Evaluator<String> subject, final Evaluator<Stri
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new BooleanQueryResult(false);
         }
 
-        final String searchString = search.evaluate(attributes, context).getValue();
+        final String searchString = search.evaluate(evaluationContext).getValue();
         return new BooleanQueryResult(searchString == null ? false : subjectValue.startsWith(searchString));
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/StringToDateEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/StringToDateEvaluator.java
index e87fb17b89e..f20c0840e43 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/StringToDateEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/StringToDateEvaluator.java
@@ -16,20 +16,19 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
-import java.util.Map;
-import java.util.TimeZone;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.DateEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.DateQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.exception.IllegalAttributeException;
 
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.Locale;
+import java.util.TimeZone;
+
 public class StringToDateEvaluator extends DateEvaluator {
 
     private final Evaluator<String> subject;
@@ -43,9 +42,9 @@ public StringToDateEvaluator(final Evaluator<String> subject, final Evaluator<St
     }
 
     @Override
-    public QueryResult<Date> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
-        final String formatValue = format.evaluate(attributes, context).getValue();
+    public QueryResult<Date> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
+        final String formatValue = format.evaluate(evaluationContext).getValue();
         if (subjectValue == null || formatValue == null) {
             return new DateQueryResult(null);
         }
@@ -53,7 +52,7 @@ public QueryResult<Date> evaluate(final Map<String, String> attributes, final Ev
         final SimpleDateFormat sdf = new SimpleDateFormat(formatValue, Locale.US);
 
         if(timeZone != null) {
-            final QueryResult<String> tzResult = timeZone.evaluate(attributes, context);
+            final QueryResult<String> tzResult = timeZone.evaluate(evaluationContext);
             final String tz = tzResult.getValue();
             if(tz != null && TimeZone.getTimeZone(tz) != null) {
                 sdf.setTimeZone(TimeZone.getTimeZone(tz));
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringAfterEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringAfterEvaluator.java
index 9c51d121b38..f4f24c08256 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringAfterEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringAfterEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -35,12 +33,12 @@ public SubstringAfterEvaluator(final Evaluator<String> subject, final Evaluator<
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult("");
         }
-        final String afterValue = afterEvaluator.evaluate(attributes, context).getValue();
+        final String afterValue = afterEvaluator.evaluate(evaluationContext).getValue();
         if (afterValue == null || afterValue.length() == 0) {
             return new StringQueryResult(subjectValue);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringAfterLastEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringAfterLastEvaluator.java
index 37dce3de86f..ba282bd3801 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringAfterLastEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringAfterLastEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -35,12 +33,12 @@ public SubstringAfterLastEvaluator(final Evaluator<String> subject, final Evalua
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult("");
         }
-        final String afterValue = afterEvaluator.evaluate(attributes, context).getValue();
+        final String afterValue = afterEvaluator.evaluate(evaluationContext).getValue();
         final int index = subjectValue.lastIndexOf(afterValue);
         if (index < 0 || index >= subjectValue.length()) {
             return new StringQueryResult(subjectValue);
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringBeforeEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringBeforeEvaluator.java
index 2b8e8b854cf..2b69bc396e5 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringBeforeEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringBeforeEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -35,12 +33,12 @@ public SubstringBeforeEvaluator(final Evaluator<String> subject, final Evaluator
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult("");
         }
-        final String beforeValue = beforeEvaluator.evaluate(attributes, context).getValue();
+        final String beforeValue = beforeEvaluator.evaluate(evaluationContext).getValue();
         if (beforeValue == null || beforeValue.length() == 0) {
             return new StringQueryResult(subjectValue);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringBeforeLastEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringBeforeLastEvaluator.java
index 664fc37e189..87e01098325 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringBeforeLastEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringBeforeLastEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -35,12 +33,12 @@ public SubstringBeforeLastEvaluator(final Evaluator<String> subject, final Evalu
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult("");
         }
-        final String beforeValue = beforeEvaluator.evaluate(attributes, context).getValue();
+        final String beforeValue = beforeEvaluator.evaluate(evaluationContext).getValue();
         final int index = subjectValue.lastIndexOf(beforeValue);
         if (index < 0) {
             return new StringQueryResult(subjectValue);
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringEvaluator.java
index a617c3b7cad..23990fb9e48 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/SubstringEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -43,16 +41,16 @@ public SubstringEvaluator(final Evaluator<String> subject, final Evaluator<Long>
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult("");
         }
-        final int startIndexValue = startIndex.evaluate(attributes, context).getValue().intValue();
+        final int startIndexValue = startIndex.evaluate(evaluationContext).getValue().intValue();
         if (endIndex == null) {
             return new StringQueryResult(subjectValue.substring(startIndexValue));
         } else {
-            final int endIndexValue = endIndex.evaluate(attributes, context).getValue().intValue();
+            final int endIndexValue = endIndex.evaluate(evaluationContext).getValue().intValue();
             return new StringQueryResult(subjectValue.substring(startIndexValue, endIndexValue));
         }
     }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ThreadEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ThreadEvaluator.java
index 3413309ef5f..8e1cd873b6b 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ThreadEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ThreadEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -27,7 +25,7 @@
 public class ThreadEvaluator extends StringEvaluator {
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
         // See org.apache.nifi.engine.FlowEngine
         return new StringQueryResult(Thread.currentThread().getName());
     }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToLowerEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToLowerEvaluator.java
index 6941f464d95..13043f46dae 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToLowerEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToLowerEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -33,8 +31,8 @@ public ToLowerEvaluator(final Evaluator<String> subject) {
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         return new StringQueryResult(subjectValue == null ? null : subjectValue.toLowerCase());
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToRadixEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToRadixEvaluator.java
index 3a0db499e50..d9afb166a87 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToRadixEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToRadixEvaluator.java
@@ -16,15 +16,14 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Arrays;
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.StringQueryResult;
 
+import java.util.Arrays;
+
 public class ToRadixEvaluator extends StringEvaluator {
 
     private final Evaluator<Long> numberEvaluator;
@@ -42,20 +41,20 @@ public ToRadixEvaluator(final Evaluator<Long> subject, final Evaluator<Long> rad
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Long result = numberEvaluator.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final Long result = numberEvaluator.evaluate(evaluationContext).getValue();
         if (result == null) {
             return new StringQueryResult(null);
         }
 
-        final Long radix = radixEvaluator.evaluate(attributes, context).getValue();
+        final Long radix = radixEvaluator.evaluate(evaluationContext).getValue();
         if (radix == null) {
             return new StringQueryResult(null);
         }
 
         String stringValue = Long.toString(result.longValue(), radix.intValue());
         if (minimumWidthEvaluator != null) {
-            final Long minimumWidth = minimumWidthEvaluator.evaluate(attributes, context).getValue();
+            final Long minimumWidth = minimumWidthEvaluator.evaluate(evaluationContext).getValue();
             if (minimumWidth != null) {
                 final int paddingWidth = minimumWidth.intValue() - stringValue.length();
                 if (paddingWidth > 0) {
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToStringEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToStringEvaluator.java
index bc8f5a87933..b80fe5b2fdb 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToStringEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToStringEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -33,8 +31,8 @@ public ToStringEvaluator(final Evaluator<?> subject) {
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Object result = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final Object result = subject.evaluate(evaluationContext).getValue();
         return new StringQueryResult(result == null ? null : result.toString());
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToUpperEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToUpperEvaluator.java
index 342ab2b0dcd..287062343ba 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToUpperEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/ToUpperEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -33,8 +31,8 @@ public ToUpperEvaluator(final Evaluator<String> subject) {
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         return new StringQueryResult(subjectValue == null ? null : subjectValue.toUpperCase());
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/TrimEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/TrimEvaluator.java
index ad96892620b..436019f5cd5 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/TrimEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/TrimEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -33,8 +31,8 @@ public TrimEvaluator(final Evaluator<String> subject) {
     }
 
     @Override
-    public QueryResult<String> evaluate(Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         return new StringQueryResult(subjectValue == null ? null : subjectValue.trim());
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/UrlDecodeEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/UrlDecodeEvaluator.java
index 61156c4bd87..c422318b1c3 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/UrlDecodeEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/UrlDecodeEvaluator.java
@@ -16,16 +16,15 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.io.UnsupportedEncodingException;
-import java.net.URLDecoder;
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.StringQueryResult;
 
+import java.io.UnsupportedEncodingException;
+import java.net.URLDecoder;
+
 public class UrlDecodeEvaluator extends StringEvaluator {
 
     private final Evaluator<String> subject;
@@ -35,8 +34,8 @@ public UrlDecodeEvaluator(final Evaluator<String> subject) {
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/UrlEncodeEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/UrlEncodeEvaluator.java
index ceed25d4df1..7ca88120ce8 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/UrlEncodeEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/UrlEncodeEvaluator.java
@@ -16,16 +16,15 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.io.UnsupportedEncodingException;
-import java.net.URLEncoder;
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.StringQueryResult;
 
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+
 public class UrlEncodeEvaluator extends StringEvaluator {
 
     private final Evaluator<String> subject;
@@ -35,8 +34,8 @@ public UrlEncodeEvaluator(final Evaluator<String> subject) {
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String subjectValue = subject.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String subjectValue = subject.evaluate(evaluationContext).getValue();
         if (subjectValue == null) {
             return new StringQueryResult(null);
         }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/UuidEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/UuidEvaluator.java
index bbe5866e911..e2dbf23bba4 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/UuidEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/functions/UuidEvaluator.java
@@ -16,19 +16,18 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.functions;
 
-import java.util.Map;
-import java.util.UUID;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.StringQueryResult;
 
+import java.util.UUID;
+
 public class UuidEvaluator extends StringEvaluator {
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
         return new StringQueryResult(UUID.randomUUID().toString());
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/BooleanLiteralEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/BooleanLiteralEvaluator.java
index cd04eecaf84..d144e3a7ee1 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/BooleanLiteralEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/BooleanLiteralEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.literals;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -33,7 +31,7 @@ public BooleanLiteralEvaluator(final boolean value) {
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
         return new BooleanQueryResult(value);
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/DecimalLiteralEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/DecimalLiteralEvaluator.java
index cf351ebba75..f9dc34f2738 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/DecimalLiteralEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/DecimalLiteralEvaluator.java
@@ -16,14 +16,12 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.literals;
 
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.DecimalEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.DecimalQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
-import java.util.Map;
-
 
 public class DecimalLiteralEvaluator extends DecimalEvaluator {
 
@@ -34,7 +32,7 @@ public DecimalLiteralEvaluator(final String value) {
     }
 
     @Override
-    public QueryResult<Double> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
+    public QueryResult<Double> evaluate(final EvaluationContext evaluationContext) {
         return new DecimalQueryResult(literal);
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/StringLiteralEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/StringLiteralEvaluator.java
index 9c0c0ab43df..410449b59a8 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/StringLiteralEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/StringLiteralEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.literals;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -66,7 +64,7 @@ public StringLiteralEvaluator(final String value) {
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
         return new StringQueryResult(value);
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/ToLiteralEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/ToLiteralEvaluator.java
index f44591af1d7..7f430eba9ce 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/ToLiteralEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/ToLiteralEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.literals;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -32,8 +30,8 @@ public ToLiteralEvaluator(final Evaluator<?> argEvaluator) {
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final Object result = argEvaluator.evaluate(attributes, context);
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final Object result = argEvaluator.evaluate(evaluationContext);
         return new StringQueryResult(result == null ? null : result.toString());
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/WholeNumberLiteralEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/WholeNumberLiteralEvaluator.java
index f476ba081e3..c22a484cb02 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/WholeNumberLiteralEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/literals/WholeNumberLiteralEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.literals;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.WholeNumberEvaluator;
@@ -33,7 +31,7 @@ public WholeNumberLiteralEvaluator(final String value) {
     }
 
     @Override
-    public QueryResult<Long> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
+    public QueryResult<Long> evaluate(final EvaluationContext evaluationContext) {
         return new WholeNumberQueryResult(literal);
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/reduce/CountEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/reduce/CountEvaluator.java
index 59df3b98046..37a745108de 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/reduce/CountEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/reduce/CountEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.reduce;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.WholeNumberEvaluator;
@@ -34,9 +32,9 @@ public CountEvaluator(final Evaluator<?> subjectEvaluator) {
     }
 
     @Override
-    public QueryResult<Long> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final QueryResult<?> result = subjectEvaluator.evaluate(attributes, context);
-        Long count = context.getState(this, Long.class);
+    public QueryResult<Long> evaluate(final EvaluationContext evaluationContext) {
+        final QueryResult<?> result = subjectEvaluator.evaluate(evaluationContext);
+        Long count = evaluationContext.getEvaluatorState().getState(this, Long.class);
         if (count == null) {
             count = 0L;
         }
@@ -49,7 +47,7 @@ public QueryResult<Long> evaluate(final Map<String, String> attributes, final Ev
         }
 
         count++;
-        context.putState(this, count);
+        evaluationContext.getEvaluatorState().putState(this, count);
         return new WholeNumberQueryResult(count);
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/reduce/JoinEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/reduce/JoinEvaluator.java
index 8b7cdf42f53..62d249e421e 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/reduce/JoinEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/reduce/JoinEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.reduce;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -35,17 +33,17 @@ public JoinEvaluator(final Evaluator<String> subject, final Evaluator<String> de
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        String subject = subjectEvaluator.evaluate(attributes, context).getValue();
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        String subject = subjectEvaluator.evaluate(evaluationContext).getValue();
         if (subject == null) {
             subject = "";
         }
 
-        final String delimiter = delimiterEvaluator.evaluate(attributes, context).getValue();
-        State state = context.getState(this, State.class);
+        final String delimiter = delimiterEvaluator.evaluate(evaluationContext).getValue();
+        State state = evaluationContext.getEvaluatorState().getState(this, State.class);
         if (state == null) {
             state = new State();
-            context.putState(this, state);
+            evaluationContext.getEvaluatorState().putState(this, state);
         }
         if (state.evalCount > 0) {
             state.sb.append(delimiter);
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/AllAttributesEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/AllAttributesEvaluator.java
index c2a7144ea2e..6b4331b7861 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/AllAttributesEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/AllAttributesEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.selection;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -35,8 +33,8 @@ public AllAttributesEvaluator(final BooleanEvaluator booleanEvaluator, final Mul
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        QueryResult<Boolean> attributeValueQuery = booleanEvaluator.evaluate(attributes, context);
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        QueryResult<Boolean> attributeValueQuery = booleanEvaluator.evaluate(evaluationContext);
         Boolean result = attributeValueQuery.getValue();
         if (result == null) {
             return new BooleanQueryResult(false);
@@ -46,8 +44,8 @@ public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final
             return new BooleanQueryResult(false);
         }
 
-        while (multiAttributeEvaluator.getEvaluationsRemaining(context) > 0) {
-            attributeValueQuery = booleanEvaluator.evaluate(attributes, context);
+        while (multiAttributeEvaluator.getEvaluationsRemaining(evaluationContext) > 0) {
+            attributeValueQuery = booleanEvaluator.evaluate(evaluationContext);
             result = attributeValueQuery.getValue();
             if (result != null && !result) {
                 return attributeValueQuery;
@@ -58,7 +56,7 @@ public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final
     }
 
     @Override
-    public int getEvaluationsRemaining(final EvaluatorState context) {
+    public int getEvaluationsRemaining(final EvaluationContext context) {
         return 0;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/AnyAttributeEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/AnyAttributeEvaluator.java
index a800b45bd9d..1fd8fad06e2 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/AnyAttributeEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/AnyAttributeEvaluator.java
@@ -16,11 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.selection;
 
-import java.util.Map;
-
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanEvaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.BooleanQueryResult;
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 
@@ -35,8 +33,8 @@ public AnyAttributeEvaluator(final BooleanEvaluator booleanEvaluator, final Mult
     }
 
     @Override
-    public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        QueryResult<Boolean> attributeValueQuery = booleanEvaluator.evaluate(attributes, context);
+    public QueryResult<Boolean> evaluate(final EvaluationContext evaluationContext) {
+        QueryResult<Boolean> attributeValueQuery = booleanEvaluator.evaluate(evaluationContext);
         Boolean result = attributeValueQuery.getValue();
         if (result == null) {
             return new BooleanQueryResult(false);
@@ -46,8 +44,8 @@ public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final
             return new BooleanQueryResult(true);
         }
 
-        while (multiAttributeEvaluator.getEvaluationsRemaining(context) > 0) {
-            attributeValueQuery = booleanEvaluator.evaluate(attributes, context);
+        while (multiAttributeEvaluator.getEvaluationsRemaining(evaluationContext) > 0) {
+            attributeValueQuery = booleanEvaluator.evaluate(evaluationContext);
             result = attributeValueQuery.getValue();
             if (result != null && result) {
                 return attributeValueQuery;
@@ -58,7 +56,7 @@ public QueryResult<Boolean> evaluate(final Map<String, String> attributes, final
     }
 
     @Override
-    public int getEvaluationsRemaining(final EvaluatorState context) {
+    public int getEvaluationsRemaining(final EvaluationContext context) {
         return 0;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/AttributeEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/AttributeEvaluator.java
index 41c98538910..ba89349865a 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/AttributeEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/AttributeEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.selection;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
@@ -33,9 +31,9 @@ public AttributeEvaluator(final Evaluator<String> nameEvaluator) {
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        final String nameValue = nameEvaluator.evaluate(attributes, context).getValue();
-        final String attributeValue = attributes.get(nameValue);
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final String nameValue = nameEvaluator.evaluate(evaluationContext).getValue();
+        final String attributeValue = evaluationContext.getExpressionValue(nameValue);
         return new StringQueryResult(attributeValue);
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/DelineatedAttributeEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/DelineatedAttributeEvaluator.java
index 5dd7b4532a5..18583339f00 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/DelineatedAttributeEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/DelineatedAttributeEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.selection;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringQueryResult;
@@ -36,20 +34,20 @@ public DelineatedAttributeEvaluator(final Evaluator<String> subjectEvaluator, fi
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        State state = context.getState(this, State.class);
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        State state = evaluationContext.getEvaluatorState().getState(this, State.class);
         if (state == null) {
             state = new State();
-            context.putState(this, state);
+            evaluationContext.getEvaluatorState().putState(this, state);
         }
         if (state.delineatedValues == null) {
-            final QueryResult<String> subjectValue = subjectEvaluator.evaluate(attributes, context);
+            final QueryResult<String> subjectValue = subjectEvaluator.evaluate(evaluationContext);
             if (subjectValue.getValue() == null) {
                 state.evaluationsLeft = 0;
                 return new StringQueryResult(null);
             }
 
-            final QueryResult<String> delimiterValue = delimiterEvaluator.evaluate(attributes, context);
+            final QueryResult<String> delimiterValue = delimiterEvaluator.evaluate(evaluationContext);
             if (delimiterValue.getValue() == null) {
                 state.evaluationsLeft = 0;
                 return new StringQueryResult(null);
@@ -74,11 +72,11 @@ public Evaluator<?> getLogicEvaluator() {
     }
 
     @Override
-    public int getEvaluationsRemaining(final EvaluatorState context) {
-        State state = context.getState(this, State.class);
+    public int getEvaluationsRemaining(final EvaluationContext evaluationContext) {
+        State state = evaluationContext.getEvaluatorState().getState(this, State.class);
         if (state == null) {
             state = new State();
-            context.putState(this, state);
+            evaluationContext.getEvaluatorState().putState(this, state);
         }
         return state.evaluationsLeft;
     }
@@ -93,7 +91,7 @@ public int getEvaluationType() {
         return evaluationType;
     }
 
-    private class State {
+    private static class State {
         private String[] delineatedValues;
         private int evaluationCount = 0;
         private int evaluationsLeft = 1;
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/MappingEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/MappingEvaluator.java
index 9ea578d92d2..632df63cbff 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/MappingEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/MappingEvaluator.java
@@ -16,9 +16,7 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.selection;
 
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.reduce.ReduceEvaluator;
@@ -35,11 +33,11 @@ public MappingEvaluator(final ReduceEvaluator<T> mappingEvaluator, final MultiAt
     }
 
     @Override
-    public QueryResult<T> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        QueryResult<T> result = mappingEvaluator.evaluate(attributes, context);
+    public QueryResult<T> evaluate(final EvaluationContext evaluationContext) {
+        QueryResult<T> result = mappingEvaluator.evaluate(evaluationContext);
 
-        while (multiAttributeEvaluator.getEvaluationsRemaining(context) > 0) {
-            result = mappingEvaluator.evaluate(attributes, context);
+        while (multiAttributeEvaluator.getEvaluationsRemaining(evaluationContext) > 0) {
+            result = mappingEvaluator.evaluate(evaluationContext);
         }
 
         return result;
@@ -51,7 +49,7 @@ public ResultType getResultType() {
     }
 
     @Override
-    public int getEvaluationsRemaining(final EvaluatorState context) {
+    public int getEvaluationsRemaining(final EvaluationContext context) {
         return 0;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/MultiMatchAttributeEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/MultiMatchAttributeEvaluator.java
index 9b3dcb95f20..d8da2a3ead3 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/MultiMatchAttributeEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/MultiMatchAttributeEvaluator.java
@@ -16,16 +16,15 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.selection;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.regex.Pattern;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringQueryResult;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Pattern;
+
 public class MultiMatchAttributeEvaluator extends MultiAttributeEvaluator {
 
     private final List<Pattern> attributePatterns;
@@ -46,25 +45,25 @@ public MultiMatchAttributeEvaluator(final List<String> attributeRegexes, final i
      * @return number of remaining evaluations
      */
     @Override
-    public int getEvaluationsRemaining(final EvaluatorState context) {
-        State state = context.getState(this, State.class);
+    public int getEvaluationsRemaining(final EvaluationContext context) {
+        State state = context.getEvaluatorState().getState(this, State.class);
         if (state == null) {
             state = new State();
-            context.putState(this, state);
+            context.getEvaluatorState().putState(this, state);
         }
         return state.attributeNames.size() - state.evaluationCount;
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        State state = context.getState(this, State.class);
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        State state = evaluationContext.getEvaluatorState().getState(this, State.class);
         if (state == null) {
             state = new State();
-            context.putState(this, state);
+            evaluationContext.getEvaluatorState().putState(this, state);
         }
         if (state.evaluationCount == 0) {
             for (final Pattern pattern : attributePatterns) {
-                for (final String attrName : attributes.keySet()) {
+                for (final String attrName : evaluationContext.getExpressionKeys()) {
                     if (pattern.matcher(attrName).matches()) {
                         state.attributeNames.add(attrName);
                     }
@@ -76,7 +75,8 @@ public QueryResult<String> evaluate(final Map<String, String> attributes, final
             return new StringQueryResult(null);
         }
 
-        return new StringQueryResult(attributes.get(state.attributeNames.get(state.evaluationCount++)));
+        final String attributeName = state.attributeNames.get(state.evaluationCount++);
+        return new StringQueryResult(evaluationContext.getExpressionValue(attributeName));
     }
 
     @Override
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/MultiNamedAttributeEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/MultiNamedAttributeEvaluator.java
index 523376a4ea3..3658e5f71ea 100644
--- a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/MultiNamedAttributeEvaluator.java
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/MultiNamedAttributeEvaluator.java
@@ -16,15 +16,15 @@
  */
 package org.apache.nifi.attribute.expression.language.evaluation.selection;
 
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
+import org.apache.nifi.attribute.expression.language.evaluation.EvaluatorState;
 import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
 import org.apache.nifi.attribute.expression.language.evaluation.StringQueryResult;
 
+import java.util.ArrayList;
+import java.util.List;
+
 public class MultiNamedAttributeEvaluator extends MultiAttributeEvaluator {
 
     private final List<String> attributeNames;
@@ -36,11 +36,11 @@ public MultiNamedAttributeEvaluator(final List<String> attributeNames, final int
     }
 
     @Override
-    public QueryResult<String> evaluate(final Map<String, String> attributes, final EvaluatorState context) {
-        State state = context.getState(this, State.class);
+    public QueryResult<String> evaluate(EvaluationContext evaluationContext) {
+        State state = evaluationContext.getEvaluatorState().getState(this, State.class);
         if (state == null) {
             state = new State();
-            context.putState(this, state);
+            evaluationContext.getEvaluatorState().putState(this, state);
         }
         state.matchingAttributeNames = new ArrayList<>(attributeNames);
 
@@ -48,15 +48,16 @@ public QueryResult<String> evaluate(final Map<String, String> attributes, final
             return new StringQueryResult(null);
         }
 
-        return new StringQueryResult(attributes.get(state.matchingAttributeNames.get(state.evaluationCount++)));
+        return new StringQueryResult(evaluationContext.getExpressionValue(state.matchingAttributeNames.get(state.evaluationCount++)));
     }
 
     @Override
-    public int getEvaluationsRemaining(final EvaluatorState context) {
-        State state = context.getState(this, State.class);
+    public int getEvaluationsRemaining(final EvaluationContext context) {
+        final EvaluatorState evaluatorState = context.getEvaluatorState();
+        State state = evaluatorState.getState(this, State.class);
         if (state == null) {
             state = new State();
-            context.putState(this, state);
+            evaluatorState.putState(this, state);
         }
         return state.matchingAttributeNames.size() - state.evaluationCount;
     }
diff --git a/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/ParameterEvaluator.java b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/ParameterEvaluator.java
new file mode 100644
index 00000000000..a5f2585ac25
--- /dev/null
+++ b/nifi-commons/nifi-expression-language/src/main/java/org/apache/nifi/attribute/expression/language/evaluation/selection/ParameterEvaluator.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.attribute.expression.language.evaluation.selection;
+
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
+import org.apache.nifi.attribute.expression.language.evaluation.Evaluator;
+import org.apache.nifi.attribute.expression.language.evaluation.QueryResult;
+import org.apache.nifi.attribute.expression.language.evaluation.StringEvaluator;
+import org.apache.nifi.attribute.expression.language.evaluation.StringQueryResult;
+import org.apache.nifi.parameter.Parameter;
+
+public class ParameterEvaluator extends StringEvaluator {
+    private final String parameterName;
+
+    public ParameterEvaluator(final String parameterName) {
+        this.parameterName = parameterName;
+    }
+
+    @Override
+    public QueryResult<String> evaluate(final EvaluationContext evaluationContext) {
+        final Parameter parameter = evaluationContext.getParameter(parameterName);
+        return new StringQueryResult(parameter == null ? null : parameter.getValue());
+    }
+
+    @Override
+    public Evaluator<?> getSubjectEvaluator() {
+        return null;
+    }
+}
diff --git a/nifi-commons/nifi-expression-language/src/test/groovy/org/apache/nifi/attribute/expression/language/QueryGroovyTest.groovy b/nifi-commons/nifi-expression-language/src/test/groovy/org/apache/nifi/attribute/expression/language/QueryGroovyTest.groovy
index bdd704d9b0f..78de467c8cc 100644
--- a/nifi-commons/nifi-expression-language/src/test/groovy/org/apache/nifi/attribute/expression/language/QueryGroovyTest.groovy
+++ b/nifi-commons/nifi-expression-language/src/test/groovy/org/apache/nifi/attribute/expression/language/QueryGroovyTest.groovy
@@ -75,10 +75,10 @@ public class QueryGroovyTest extends GroovyTestCase {
         Query replaceRepeatingQuery = Query.compile(REPLACE_REPEATING_EXPRESSION)
 
         // Act
-        QueryResult<?> replaceSingleResult = replaceSingleQuery.evaluate(attributes)
+        QueryResult<?> replaceSingleResult = replaceSingleQuery.evaluate(new StandardEvaluationContext(attributes))
         logger.info("Replace single result: ${replaceSingleResult.value}")
 
-        QueryResult<?> replaceRepeatingResult = replaceRepeatingQuery.evaluate(attributes)
+        QueryResult<?> replaceRepeatingResult = replaceRepeatingQuery.evaluate(new StandardEvaluationContext(attributes))
         logger.info("Replace repeating result: ${replaceRepeatingResult.value}")
 
         // Assert
@@ -115,10 +115,10 @@ public class QueryGroovyTest extends GroovyTestCase {
         Query replaceRepeatingQuery = Query.compile(REPLACE_REPEATING_EXPRESSION)
 
         // Act
-        QueryResult<?> replaceSingleResult = replaceSingleQuery.evaluate(attributes)
+        QueryResult<?> replaceSingleResult = replaceSingleQuery.evaluate(new StandardEvaluationContext(attributes))
         logger.info("Replace single result: ${replaceSingleResult.value}")
 
-        QueryResult<?> replaceRepeatingResult = replaceRepeatingQuery.evaluate(attributes)
+        QueryResult<?> replaceRepeatingResult = replaceRepeatingQuery.evaluate(new StandardEvaluationContext(attributes))
         logger.info("Replace repeating result: ${replaceRepeatingResult.value}")
 
         // Assert
@@ -155,10 +155,10 @@ public class QueryGroovyTest extends GroovyTestCase {
         Query replaceRepeatingQuery = Query.compile(REPLACE_REPEATING_EXPRESSION)
 
         // Act
-        QueryResult<?> replaceSingleResult = replaceSingleQuery.evaluate(attributes)
+        QueryResult<?> replaceSingleResult = replaceSingleQuery.evaluate(new StandardEvaluationContext(attributes))
         logger.info("Replace single result: ${replaceSingleResult.value}")
 
-        QueryResult<?> replaceRepeatingResult = replaceRepeatingQuery.evaluate(attributes)
+        QueryResult<?> replaceRepeatingResult = replaceRepeatingQuery.evaluate(new StandardEvaluationContext(attributes))
         logger.info("Replace repeating result: ${replaceRepeatingResult.value}")
 
         // Assert
@@ -187,7 +187,7 @@ public class QueryGroovyTest extends GroovyTestCase {
         final String REPLACE_ONLY_FIRST_PATTERN = /\w+\s\w+\b??/
 
         // Act
-        
+
         // Execute on both single and repeating with String#replace()
         String replaceSingleResult = attributes.single.replace(REPLACE_ONLY_FIRST_PATTERN, REPLACEMENT_VALUE)
         logger.info("Replace single result: ${replaceSingleResult}")
diff --git a/nifi-commons/nifi-expression-language/src/test/java/org/apache/nifi/attribute/expression/language/TestQuery.java b/nifi-commons/nifi-expression-language/src/test/java/org/apache/nifi/attribute/expression/language/TestQuery.java
index 1c679a4b2a5..fcd636a2076 100644
--- a/nifi-commons/nifi-expression-language/src/test/java/org/apache/nifi/attribute/expression/language/TestQuery.java
+++ b/nifi-commons/nifi-expression-language/src/test/java/org/apache/nifi/attribute/expression/language/TestQuery.java
@@ -24,6 +24,9 @@
 import org.apache.nifi.attribute.expression.language.exception.AttributeExpressionLanguageParsingException;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
 import org.apache.nifi.flowfile.FlowFile;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterDescriptor;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.registry.VariableRegistry;
 import org.junit.Assert;
 import org.junit.Ignore;
@@ -43,6 +46,7 @@
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
+import java.util.Optional;
 
 import static java.lang.Double.NEGATIVE_INFINITY;
 import static java.lang.Double.NaN;
@@ -74,18 +78,19 @@ public void testCompilation() {
         //System.out.println(Query.compile("").evaluate(null));
     }
 
+
     @Test
     public void testPrepareWithEscapeChar() {
         final Map<String, String> variables = Collections.singletonMap("foo", "bar");
 
-        assertEquals("bar${foo}$bar", Query.prepare("${foo}$${foo}$$${foo}").evaluateExpressions(variables, null));
+        assertEquals("bar${foo}$bar", Query.prepare("${foo}$${foo}$$${foo}").evaluateExpressions(new StandardEvaluationContext(variables), null));
 
         final PreparedQuery onlyEscapedQuery = Query.prepare("$${foo}");
-        final String onlyEscapedEvaluated = onlyEscapedQuery.evaluateExpressions(variables, null);
+        final String onlyEscapedEvaluated = onlyEscapedQuery.evaluateExpressions(new StandardEvaluationContext(variables), null);
         assertEquals("${foo}", onlyEscapedEvaluated);
 
         final PreparedQuery mixedQuery = Query.prepare("${foo}$${foo}");
-        final String mixedEvaluated = mixedQuery.evaluateExpressions(variables, null);
+        final String mixedEvaluated = mixedQuery.evaluateExpressions(new StandardEvaluationContext(variables), null);
         assertEquals("bar${foo}", mixedEvaluated);
     }
 
@@ -229,7 +234,7 @@ public void testDateToNumber() {
         final Map<String, String> attributes = new HashMap<>();
         attributes.put("dateTime", "2013/11/18 10:22:27.678");
 
-        final QueryResult<?> result = query.evaluate(attributes);
+        final QueryResult<?> result = query.evaluate(new StandardEvaluationContext(attributes));
         assertEquals(ResultType.WHOLE_NUMBER, result.getResultType());
         assertEquals(1384788147678L, result.getValue());
     }
@@ -258,7 +263,7 @@ public void implicitDateConversion() {
         final Date roundedToNearestSecond = new Date(date.getTime() - millis);
         final String formatted = sdf.format(roundedToNearestSecond);
 
-        final QueryResult<?> result = query.evaluate(attributes);
+        final QueryResult<?> result = query.evaluate(new StandardEvaluationContext(attributes));
         assertEquals(ResultType.STRING, result.getResultType());
         assertEquals(formatted, result.getValue());
     }
@@ -278,6 +283,18 @@ public void testEmbeddedExpressionsAndQuotes() {
         assertEquals("true", Query.evaluateExpressions("${x:equals(\"${a}\")}", attributes, null));
     }
 
+    @Test
+    public void testParameterReference() {
+        final Map<String, String> attributes = Collections.emptyMap();
+        final Map<String, String> stateValues = Collections.emptyMap();
+        final Map<String, String> parameters = new HashMap<>();
+        parameters.put("test", "unit");
+
+        verifyEquals("${#{test}}", attributes, stateValues, parameters,"unit");
+        verifyEquals("${#{test}:append(' - '):append(#{test})}", attributes, stateValues, parameters,"unit - unit");
+    }
+
+
     @Test
     public void testJsonPath() throws IOException {
         final Map<String, String> attributes = new HashMap<>();
@@ -398,7 +415,7 @@ private String evaluateQueryForEscape(final String queryString, final Map<String
         Mockito.when(mockFlowFile.getLineageStartDate()).thenReturn(System.currentTimeMillis());
 
         final ValueLookup lookup = new ValueLookup(VariableRegistry.EMPTY_REGISTRY, mockFlowFile);
-        return Query.evaluateExpressions(queryString, lookup);
+        return Query.evaluateExpressions(queryString, lookup, ParameterLookup.EMPTY);
     }
 
     @Test
@@ -671,7 +688,7 @@ public void testNewLinesAndTabsInQuery() {
         final String query = "${ abc:equals('abc'):or( \n\t${xx:isNull()}\n) }";
         assertEquals(ResultType.BOOLEAN, Query.getResultType(query));
         Query.validateExpression(query, false);
-        assertEquals("true", Query.evaluateExpressions(query, Collections.emptyMap()));
+        assertEquals("true", Query.evaluateExpressions(query, Collections.emptyMap(), ParameterLookup.EMPTY));
     }
 
     @Test
@@ -697,12 +714,12 @@ public void testComments() {
                 + "}";
 
         Query query = Query.compile(expression);
-        QueryResult<?> result = query.evaluate(attributes);
+        QueryResult<?> result = query.evaluate(new StandardEvaluationContext(attributes));
         assertEquals(ResultType.STRING, result.getResultType());
         assertEquals("xyz", result.getValue());
 
         query = Query.compile("${abc:append('# hello') #good-bye \n}");
-        result = query.evaluate(attributes);
+        result = query.evaluate(new StandardEvaluationContext(attributes));
         assertEquals(ResultType.STRING, result.getResultType());
         assertEquals("xyz# hello", result.getValue());
     }
@@ -1602,7 +1619,7 @@ public void testEvaluateWithinCurlyBraces() {
         final List<String> expressions = Query.extractExpressions(query);
         assertEquals(1, expressions.size());
         assertEquals("${abc}", expressions.get(0));
-        assertEquals("{ xyz }", Query.evaluateExpressions(query, attributes));
+        assertEquals("{ xyz }", Query.evaluateExpressions(query, attributes, ParameterLookup.EMPTY));
     }
 
     @Test
@@ -1652,7 +1669,7 @@ public void testRandomFunction() {
 
     QueryResult<?> getResult(String expr, Map<String, String> attrs) {
         final Query query = Query.compile(expr);
-        final QueryResult<?> result = query.evaluate(attrs);
+        final QueryResult<?> result = query.evaluate(new StandardEvaluationContext(attrs));
         return result;
     }
 
@@ -1823,15 +1840,26 @@ public void testThread() {
     }
 
     private void verifyEquals(final String expression, final Map<String, String> attributes, final Object expectedResult) {
-        verifyEquals(expression,attributes, null, expectedResult);
+        verifyEquals(expression,attributes, null, ParameterLookup.EMPTY, expectedResult);
     }
 
     private void verifyEquals(final String expression, final Map<String, String> attributes, final Map<String, String> stateValues, final Object expectedResult) {
+        verifyEquals(expression, attributes, stateValues, ParameterLookup.EMPTY, expectedResult);
+    }
+
+    private void verifyEquals(final String expression, final Map<String, String> attributes, final Map<String, String> stateValues, final Map<String, String> parameters,
+                              final Object expectedResult) {
+
+        verifyEquals(expression, attributes, stateValues, new MapParameterLookup(parameters), expectedResult);
+    }
+
+    private void verifyEquals(final String expression, final Map<String, String> attributes, final Map<String, String> stateValues, final ParameterLookup parameterLookup,
+                              final Object expectedResult) {
         Query.validateExpression(expression, false);
-        assertEquals(String.valueOf(expectedResult), Query.evaluateExpressions(expression, attributes, null, stateValues));
+        assertEquals(String.valueOf(expectedResult), Query.evaluateExpressions(expression, attributes, null, stateValues, parameterLookup));
 
         final Query query = Query.compile(expression);
-        final QueryResult<?> result = query.evaluate(attributes, stateValues);
+        final QueryResult<?> result = query.evaluate(new StandardEvaluationContext(attributes, stateValues, parameterLookup));
 
         if (expectedResult instanceof Long) {
             if (ResultType.NUMBER.equals(result.getResultType())) {
@@ -1879,4 +1907,28 @@ private String getResourceAsString(String resourceName) throws IOException {
             return sb.toString();
         }
     }
+
+
+    private static class MapParameterLookup implements ParameterLookup {
+        private final Map<String, String> parameters;
+
+        public MapParameterLookup(final Map<String, String> parameters) {
+            this.parameters = parameters;
+        }
+
+        @Override
+        public Optional<Parameter> getParameter(final String parameterName) {
+            final String value = parameters.get(parameterName);
+            if (value == null) {
+                return Optional.empty();
+            }
+
+            return Optional.of(new Parameter(new ParameterDescriptor.Builder().name(parameterName).build(), value));
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return parameters.isEmpty();
+        }
+    }
 }
diff --git a/nifi-commons/nifi-expression-language/src/test/java/org/apache/nifi/attribute/expression/language/TestStandardPreparedQuery.java b/nifi-commons/nifi-expression-language/src/test/java/org/apache/nifi/attribute/expression/language/TestStandardPreparedQuery.java
index 556066fa227..d6767ba754d 100644
--- a/nifi-commons/nifi-expression-language/src/test/java/org/apache/nifi/attribute/expression/language/TestStandardPreparedQuery.java
+++ b/nifi-commons/nifi-expression-language/src/test/java/org/apache/nifi/attribute/expression/language/TestStandardPreparedQuery.java
@@ -16,9 +16,9 @@
  */
 package org.apache.nifi.attribute.expression.language;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import org.apache.nifi.parameter.ParameterLookup;
+import org.junit.Ignore;
+import org.junit.Test;
 
 import java.util.HashMap;
 import java.util.HashSet;
@@ -26,8 +26,9 @@
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 
-import org.junit.Ignore;
-import org.junit.Test;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 public class TestStandardPreparedQuery {
 
@@ -58,7 +59,7 @@ public void test10MIterations() {
         final StandardPreparedQuery prepared = (StandardPreparedQuery) Query.prepare("${xx}");
         final long start = System.nanoTime();
         for (int i = 0; i < 10000000; i++) {
-            assertEquals("world", prepared.evaluateExpressions(attrs, null));
+            assertEquals("world", prepared.evaluateExpressions(new StandardEvaluationContext(attrs), null));
         }
         final long nanos = System.nanoTime() - start;
         System.out.println(TimeUnit.NANOSECONDS.toMillis(nanos));
@@ -72,7 +73,7 @@ public void test10MIterationsWithQuery() {
 
         final long start = System.nanoTime();
         for (int i = 0; i < 10000000; i++) {
-            assertEquals("world", Query.evaluateExpressions("${xx}", attrs));
+            assertEquals("world", Query.evaluateExpressions("${xx}", attrs, ParameterLookup.EMPTY));
         }
         final long nanos = System.nanoTime() - start;
         System.out.println(TimeUnit.NANOSECONDS.toMillis(nanos));
@@ -95,12 +96,12 @@ public void testPreparedQueryWithReducingFunctionAny() {
         attributes.put("comma", ",");
         attributes.put("question", " how are you?");
         final StandardPreparedQuery prepared = (StandardPreparedQuery) Query.prepare("${anyAttribute('comma', 'question'):matches('hello')}");
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("audience", "bla");
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("comma", "hello");
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
     }
 
     @Test
@@ -109,12 +110,12 @@ public void testPreparedQueryWithReducingFunctionAll() {
         attributes.put("comma", ",");
         attributes.put("question", " how are you?");
         final StandardPreparedQuery prepared = (StandardPreparedQuery) Query.prepare("${allAttributes('comma', 'question'):matches('hello')}");
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("comma", "hello");
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("question", "hello");
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
     }
 
     @Test
@@ -123,12 +124,12 @@ public void testPreparedQueryWithReducingFunctionAnyMatching() {
         attributes.put("comma", ",");
         attributes.put("question", " how are you?");
         final StandardPreparedQuery prepared = (StandardPreparedQuery) Query.prepare("${anyMatchingAttribute('audi.*'):matches('hello')}");
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("audience", "bla");
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("auditorium", "hello");
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
     }
 
     @Test
@@ -137,12 +138,12 @@ public void testPreparedQueryWithReducingFunctionAllMatching() {
         attributes.put("comma", "hello");
         attributes.put("question", "hello");
         final StandardPreparedQuery prepared = (StandardPreparedQuery) Query.prepare("${allMatchingAttributes('.*'):matches('hello')}");
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("audience", "bla");
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.remove("audience");
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
     }
 
     @Test
@@ -150,12 +151,12 @@ public void testPreparedQueryWithReducingFunctionAnyDelineated() {
         final Map<String, String> attributes = new HashMap<>();
         attributes.put("number_list", "1,2,3,4,5,6,7");
         final StandardPreparedQuery prepared = (StandardPreparedQuery) Query.prepare("${anyDelineatedValue(${number_list}, ','):contains('5')}");
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("number_list", "1,2,3");
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("number_list", "5");
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
     }
 
     @Test
@@ -163,12 +164,12 @@ public void testPreparedQueryWithReducingFunctionAllDelineated() {
         final Map<String, String> attributes = new HashMap<>();
         attributes.put("word_list", "beach,bananas,web");
         final StandardPreparedQuery prepared = (StandardPreparedQuery) Query.prepare("${allDelineatedValues(${word_list}, ','):contains('b')}");
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("word_list", "beach,party,web");
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("word_list", "bee");
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
     }
 
     @Test
@@ -177,9 +178,9 @@ public void testPreparedQueryWithReducingFunctionJoin() {
         attributes.put("hello", "Hello");
         attributes.put("boat", "World!");
         final StandardPreparedQuery prepared = (StandardPreparedQuery) Query.prepare("${allAttributes('hello', 'boat'):join(' ')}");
-        assertEquals("Hello World!", prepared.evaluateExpressions(attributes, null));
+        assertEquals("Hello World!", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("boat", "Friend.");
-        assertEquals("Hello Friend.", prepared.evaluateExpressions(attributes, null));
+        assertEquals("Hello Friend.", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
     }
 
     @Test
@@ -188,9 +189,9 @@ public void testPreparedQueryWithReducingFunctionCount() {
         attributes.put("hello", "Hello");
         attributes.put("boat", "World!");
         final StandardPreparedQuery prepared = (StandardPreparedQuery) Query.prepare("${allAttributes('hello', 'boat'):contains('e'):count()}");
-        assertEquals("1", prepared.evaluateExpressions(attributes, null));
+        assertEquals("1", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("boat", "end");
-        assertEquals("2", prepared.evaluateExpressions(attributes, null));
+        assertEquals("2", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
     }
 
     @Test
@@ -199,9 +200,9 @@ public void testPreparedQueryWithSelectingAnd() {
         attributes.put("hello", "Hello");
         attributes.put("boat", "World!");
         final StandardPreparedQuery prepared = (StandardPreparedQuery) Query.prepare("${allAttributes('hello', 'boat'):isEmpty():not():and(${hello:contains('o')})}");
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("hello", "hi");
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
     }
 
     @Test
@@ -209,9 +210,9 @@ public void testPreparedQueryWithAnd() {
         final Map<String, String> attributes = new HashMap<>();
         attributes.put("hello", "Hello");
         final StandardPreparedQuery prepared = (StandardPreparedQuery) Query.prepare("${hello:contains('H'):and(${hello:contains('o')})}");
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("hello", "Hell");
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
     }
 
     @Test
@@ -220,9 +221,9 @@ public void testPreparedQueryWithSelectingOr() {
         attributes.put("hello", "Hello");
         attributes.put("boat", "World!");
         final StandardPreparedQuery prepared = (StandardPreparedQuery) Query.prepare("${allAttributes('hello', 'boat'):matches('strict'):or(${hello:contains('o')})}");
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("hello", "hi");
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
     }
 
     @Test
@@ -230,9 +231,9 @@ public void testPreparedQueryWithOr() {
         final Map<String, String> attributes = new HashMap<>();
         attributes.put("hello", "Hello");
         final StandardPreparedQuery prepared = (StandardPreparedQuery) Query.prepare("${hello:contains('X'):or(${hello:contains('o')})}");
-        assertEquals("true", prepared.evaluateExpressions(attributes, null));
+        assertEquals("true", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
         attributes.put("hello", "Hell");
-        assertEquals("false", prepared.evaluateExpressions(attributes, null));
+        assertEquals("false", prepared.evaluateExpressions(new StandardEvaluationContext(attributes), null));
     }
 
     @Test
@@ -272,7 +273,7 @@ public void testVariableImpacted() {
     }
 
     private String evaluate(final String query, final Map<String, String> attrs) {
-        final String evaluated = ((StandardPreparedQuery) Query.prepare(query)).evaluateExpressions(attrs, null);
+        final String evaluated = ((StandardPreparedQuery) Query.prepare(query)).evaluateExpressions(new StandardEvaluationContext(attrs), null);
         return evaluated;
     }
 
diff --git a/nifi-commons/nifi-expression-language/src/test/java/org/apache/nifi/attribute/expression/language/TestValueLookup.java b/nifi-commons/nifi-expression-language/src/test/java/org/apache/nifi/attribute/expression/language/TestValueLookup.java
index 1010ac776f7..97935fdfb8c 100644
--- a/nifi-commons/nifi-expression-language/src/test/java/org/apache/nifi/attribute/expression/language/TestValueLookup.java
+++ b/nifi-commons/nifi-expression-language/src/test/java/org/apache/nifi/attribute/expression/language/TestValueLookup.java
@@ -16,14 +16,16 @@
  */
 package org.apache.nifi.attribute.expression.language;
 
-import java.util.HashMap;
-import java.util.Map;
 import org.apache.nifi.flowfile.FlowFile;
 import org.apache.nifi.registry.VariableRegistry;
 import org.junit.Test;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.assertFalse;
+
+import java.util.HashMap;
+import java.util.Map;
+
 import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
 
 public class TestValueLookup {
 
diff --git a/nifi-commons/nifi-parameter/pom.xml b/nifi-commons/nifi-parameter/pom.xml
new file mode 100644
index 00000000000..d37bfc0ad7c
--- /dev/null
+++ b/nifi-commons/nifi-parameter/pom.xml
@@ -0,0 +1,37 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Licensed to the Apache Software Foundation (ASF) under one or more
+  contributor license agreements.  See the NOTICE file distributed with
+  this work for additional information regarding copyright ownership.
+  The ASF licenses this file to You under the Apache License, Version 2.0
+  (the "License"); you may not use this file except in compliance with
+  the License.  You may obtain a copy of the License at
+      http://www.apache.org/licenses/LICENSE-2.0
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+
+    <parent>
+        <artifactId>nifi-commons</artifactId>
+        <groupId>org.apache.nifi</groupId>
+        <version>1.10.0-SNAPSHOT</version>
+    </parent>
+    <modelVersion>4.0.0</modelVersion>
+
+    <artifactId>nifi-parameter</artifactId>
+
+    <dependencies>
+        <dependency>
+            <groupId>org.apache.nifi</groupId>
+            <artifactId>nifi-api</artifactId>
+            <version>1.10.0-SNAPSHOT</version>
+        </dependency>
+    </dependencies>
+
+</project>
\ No newline at end of file
diff --git a/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/AbstractParameterParser.java b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/AbstractParameterParser.java
new file mode 100644
index 00000000000..fd740e7abf2
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/AbstractParameterParser.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import java.util.List;
+
+public abstract class AbstractParameterParser implements ParameterParser {
+    protected static final char START_TAG = '#';
+    protected static final char OPEN_BRACE = '{';
+    protected static final char CLOSE_BRACE = '}';
+
+
+    protected ParameterToken parseParameterToken(final String input, final int startIndex, final int sequentialStartTags, final List<ParameterToken> tokens) {
+        int startCharIndex = startIndex - sequentialStartTags;
+        final int endCharIndex = input.indexOf(CLOSE_BRACE, startIndex);
+        if (endCharIndex < 0) {
+            return null;
+        }
+
+
+        final int numEscapedStartTags = (sequentialStartTags - 1)/2;
+        final int startOffset = startCharIndex + numEscapedStartTags * 2;
+        final String referenceText = input.substring(startOffset, endCharIndex + 1);
+
+        // If we have multiple escapes before the start tag, we need to add a StartCharacterEscape for each one.
+        // For example, if we have ###{foo}, then we should end up with a StartCharacterEscape followed by an actual Parameter Reference.
+        for (int escapes=0; escapes < numEscapedStartTags; escapes++) {
+            tokens.add(new StartCharacterEscape(startCharIndex + escapes * 2));
+        }
+
+        final ParameterToken token;
+        if (sequentialStartTags % 2 == 1) {
+            final String parameterName = input.substring(startCharIndex + sequentialStartTags + 1, endCharIndex);
+            token = new StandardParameterReference(parameterName, startOffset, endCharIndex, referenceText);
+        } else {
+            token = new EscapedParameterReference(startOffset, endCharIndex, referenceText);
+        }
+
+        tokens.add(token);
+        return token;
+    }
+}
diff --git a/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/EscapedParameterReference.java b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/EscapedParameterReference.java
new file mode 100644
index 00000000000..7417303671d
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/EscapedParameterReference.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+public class EscapedParameterReference implements ParameterToken {
+    private final int startOffset;
+    private final int endOffset;
+    private final String referenceText;
+
+    public EscapedParameterReference(final int startOffset, final int endOffset, final String referenceText) {
+        this.startOffset = startOffset;
+        this.endOffset = endOffset;
+        this.referenceText = referenceText;
+    }
+
+    @Override
+    public int getStartOffset() {
+        return startOffset;
+    }
+
+    @Override
+    public int getEndOffset() {
+        return endOffset;
+    }
+
+    @Override
+    public String getText() {
+        return referenceText;
+    }
+
+    @Override
+    public boolean isEscapeSequence() {
+        return true;
+    }
+
+    @Override
+    public boolean isParameterReference() {
+        return false;
+    }
+
+    @Override
+    public String getValue(final ParameterLookup parameterLookup) {
+        return referenceText.replace("##", "#");
+    }
+}
diff --git a/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ExpressionLanguageAgnosticParameterParser.java b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ExpressionLanguageAgnosticParameterParser.java
new file mode 100644
index 00000000000..2f280863563
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ExpressionLanguageAgnosticParameterParser.java
@@ -0,0 +1,71 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class ExpressionLanguageAgnosticParameterParser extends AbstractParameterParser {
+    private static final Logger logger = LoggerFactory.getLogger(ExpressionLanguageAgnosticParameterParser.class);
+
+    @Override
+    public ParameterTokenList parseTokens(final String input) {
+        if (input == null || input.isEmpty()) {
+            return new StandardParameterTokenList(input, Collections.emptyList());
+        }
+
+        final List<ParameterToken> references = new ArrayList<>();
+        int sequentialStartTags = 0;
+
+        for (int i=0; i < input.length(); i++) {
+            final char c = input.charAt(i);
+
+            switch (c) {
+                case START_TAG:
+                    // If last character was a # character, then the previous character along with this character
+                    // represent an escaped literal # character. Otherwise, this character potentially represents
+                    // the start of a Parameter Reference.
+                    sequentialStartTags++;
+                    break;
+                case OPEN_BRACE:
+                    if (sequentialStartTags > 0) {
+                        final ParameterToken token = parseParameterToken(input, i, sequentialStartTags, references);
+
+                        // If we found a reference, skip 'i' to the end of the reference, since there can't be any other references before that point.
+                        if (token != null) {
+                            i = token.getEndOffset();
+                        }
+                    }
+
+                    break;
+                default:
+                    break;
+            }
+
+            if (c != START_TAG) {
+                sequentialStartTags = 0;
+            }
+        }
+
+        logger.debug("For input {} found {} Parameter references: {}", input, references.size(), references);
+        return new StandardParameterTokenList(input, references);
+    }
+}
diff --git a/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ExpressionLanguageAwareParameterParser.java b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ExpressionLanguageAwareParameterParser.java
new file mode 100644
index 00000000000..79dddcfa551
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ExpressionLanguageAwareParameterParser.java
@@ -0,0 +1,110 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class ExpressionLanguageAwareParameterParser extends AbstractParameterParser implements ParameterParser {
+    private static final Logger logger = LoggerFactory.getLogger(ExpressionLanguageAwareParameterParser.class);
+    private static final char DOLLAR_SIGN = '$';
+
+
+    @Override
+    public ParameterTokenList parseTokens(final String input) {
+        if (input == null || input.isEmpty()) {
+            return new StandardParameterTokenList(input, Collections.emptyList());
+        }
+
+        final List<ParameterToken> tokens = new ArrayList<>();
+
+        int sequentialStartTags = 0;
+        boolean oddDollarCount = false;
+        char lastChar = 0;
+        int embeddedElCount = 0;
+        int expressionStart = -1;
+
+        for (int i=0; i < input.length(); i++) {
+            final char c = input.charAt(i);
+
+            switch (c) {
+                case START_TAG:
+                    // If last character was a # character, then the previous character along with this character
+                    // represent an escaped literal # character. Otherwise, this character potentially represents
+                    // the start of a Parameter Reference.
+                    sequentialStartTags++;
+                    break;
+                case OPEN_BRACE:
+                    if (oddDollarCount && lastChar == '$') {
+                        if (embeddedElCount == 0) {
+                            expressionStart = i - 1;
+                        }
+                    }
+
+                    // Keep track of the number of opening curly braces that we are embedded within,
+                    // if we are within an Expression. If we are outside of an Expression, we can just ignore
+                    // curly braces. This allows us to ignore the first character if the value is something
+                    // like: { ${abc} }
+                    // However, we will count the curly braces if we have something like: ${ $${abc} }
+                    if (expressionStart > -1) {
+                        embeddedElCount++;
+                        continue;
+                    }
+
+
+                    if (sequentialStartTags > 0) {
+                        final ParameterToken token = parseParameterToken(input, i, sequentialStartTags, tokens);
+
+                        // If we found a reference, skip 'i' to the end of the reference, since there can't be any other references before that point.
+                        if (token != null) {
+                            i = token.getEndOffset();
+                        }
+                    }
+
+                    break;
+                case CLOSE_BRACE:
+                    if (embeddedElCount <= 0) {
+                        continue;
+                    }
+
+                    if (--embeddedElCount == 0) {
+                        expressionStart = -1;
+                    }
+                    break;
+                case DOLLAR_SIGN:
+                    oddDollarCount = !oddDollarCount;
+                    break;
+                default:
+                    break;
+            }
+
+            if (c != START_TAG) {
+                sequentialStartTags = 0;
+            }
+
+            lastChar = c;
+        }
+
+        logger.debug("For input {} found {} Parameter references: {}", input, tokens.size(), tokens);
+        return new StandardParameterTokenList(input, tokens);
+    }
+
+}
diff --git a/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterLookup.java b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterLookup.java
new file mode 100644
index 00000000000..3d97170050c
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterLookup.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import java.util.Optional;
+
+public interface ParameterLookup {
+
+    /**
+     * Returns the Parameter with the given name
+     * @param parameterName the name of the Parameter
+     * @return the Parameter with the given name or an empty Optional if no Parameter exists with that name
+     */
+    Optional<Parameter> getParameter(String parameterName);
+
+    /**
+     * Returns false if any Parameters are available, true if no Parameters have been defined
+     * @return true if empty
+     */
+    boolean isEmpty();
+
+
+    ParameterLookup EMPTY = new ParameterLookup() {
+        @Override
+        public Optional<Parameter> getParameter(final String parameterName) {
+            return Optional.empty();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return true;
+        }
+    };
+}
diff --git a/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterParser.java b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterParser.java
new file mode 100644
index 00000000000..e15735359e3
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterParser.java
@@ -0,0 +1,27 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+public interface ParameterParser {
+    /**
+     * Parses the given input, returning a ParameterTokenList that contains all Parameter tokens that were identified.
+     *
+     * @param input the input to parse
+     * @return a ParameterTokenList containing all parameter tokens identified
+     */
+    ParameterTokenList parseTokens(String input);
+}
diff --git a/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterReference.java b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterReference.java
new file mode 100644
index 00000000000..b8dd2350149
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterReference.java
@@ -0,0 +1,24 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+public interface ParameterReference extends ParameterToken {
+    /**
+     * @return the name of the Parameter that is referenced
+     */
+    String getParameterName();
+}
diff --git a/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterToken.java b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterToken.java
new file mode 100644
index 00000000000..f4e1b19d311
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterToken.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+/**
+ * A token encountered when parsing Strings for Parameter references. A Token may be a reference to a Parameter,
+ * or it may be an "escaped reference" / non-reference.
+ */
+public interface ParameterToken {
+    /**
+     * @return the 0-based index in the String at which the token begins
+     */
+    int getStartOffset();
+
+    /**
+     * @return the 0-based index in the String at which the token ends
+     */
+    int getEndOffset();
+
+    /**
+     * @return the portion of the input text that corresponds to this token
+     */
+    String getText();
+
+    /**
+     * @return <code>true</code> if this token represents an escape sequence such as ##{param} or ## in the case of ###{param} or ####{param}, false if this
+     * token does not represent an escape sequence.
+     */
+    boolean isEscapeSequence();
+
+    /**
+     * @return <code>true</code> if this token represents a reference to a Parameter. If this method returns <code>true</code>, then this token can be cast
+     * as a {@link ParameterReference}.
+     */
+    boolean isParameterReference();
+
+    /**
+     * Returns the 'value' of the token. If this token is a parameter reference, it will return the value of the
+     * Parameter, according to the given Parameter Context. If this token is an Escape Sequence, it will return the
+     * un-escaped version of the escape sequence.
+     * @param lookup the Parameter Lookup to use for looking up values
+     * @return the value of the Token
+     */
+    String getValue(ParameterLookup lookup);
+}
diff --git a/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterTokenList.java b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterTokenList.java
new file mode 100644
index 00000000000..b8f7052c921
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/ParameterTokenList.java
@@ -0,0 +1,30 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import java.util.List;
+
+public interface ParameterTokenList extends Iterable<ParameterToken> {
+
+    String substitute(ParameterLookup parameterLookup);
+
+    String escape();
+
+    List<ParameterToken> toList();
+
+    List<ParameterReference> toReferenceList();
+}
diff --git a/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/StandardParameterReference.java b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/StandardParameterReference.java
new file mode 100644
index 00000000000..4f270f1340d
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/StandardParameterReference.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import java.util.Optional;
+
+public class StandardParameterReference implements ParameterReference {
+    private final String parameterName;
+    private final int startOffset;
+    private final int endOffset;
+    private final String referenceText;
+
+    public StandardParameterReference(final String parameterName, final int startOffset, final int endOffset, final String referenceText) {
+        this.parameterName = parameterName;
+        this.startOffset = startOffset;
+        this.endOffset = endOffset;
+        this.referenceText = referenceText;
+    }
+
+    @Override
+    public String getParameterName() {
+        return parameterName;
+    }
+
+    @Override
+    public int getStartOffset() {
+        return startOffset;
+    }
+
+    @Override
+    public int getEndOffset() {
+        return endOffset;
+    }
+
+    @Override
+    public String getText() {
+        return referenceText;
+    }
+
+    @Override
+    public boolean isEscapeSequence() {
+        return false;
+    }
+
+    @Override
+    public boolean isParameterReference() {
+        return true;
+    }
+
+    @Override
+    public String getValue(final ParameterLookup parameterLookup) {
+        if (parameterLookup == null) {
+            return referenceText;
+        }
+
+        final Optional<Parameter> parameter = parameterLookup.getParameter(parameterName);
+        return parameter.map(Parameter::getValue).orElse(referenceText);
+    }
+}
diff --git a/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/StandardParameterTokenList.java b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/StandardParameterTokenList.java
new file mode 100644
index 00000000000..f9c0a0fd055
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/StandardParameterTokenList.java
@@ -0,0 +1,105 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+
+public class StandardParameterTokenList implements ParameterTokenList {
+    private final String input;
+    private final List<ParameterToken> tokens;
+    private final List<ParameterReference> referenceList;
+
+    public StandardParameterTokenList(final String input, final List<ParameterToken> tokens) {
+        this.input = input;
+        this.tokens = tokens;
+        this.referenceList = tokens.stream()
+            .filter(ParameterToken::isParameterReference)
+            .map(token -> (ParameterReference) token)
+            .collect(Collectors.toList());
+    }
+
+    @Override
+    public List<ParameterReference> toReferenceList() {
+        return this.referenceList;
+    }
+
+    @Override
+    public String substitute(final ParameterLookup parameterLookup) {
+        if (input == null) {
+            return null;
+        }
+
+        if (tokens.isEmpty()) {
+            return input;
+        }
+
+        return substitute(reference -> reference.getValue(parameterLookup));
+    }
+
+    @Override
+    public String escape() {
+        if (input == null) {
+            return null;
+        }
+
+        return substitute(reference -> {
+            if (reference.isEscapeSequence()) {
+                if (reference.getText().equals("##")) {
+                    return "####";
+                } else {
+                    return "##" + reference.getText();
+                }
+            } else {
+                return "#" + reference.getText();
+            }
+        });
+    }
+
+    private String substitute(final Function<ParameterToken, String> transform) {
+        final StringBuilder sb = new StringBuilder();
+
+        int lastEndOffset = -1;
+        for (final ParameterToken token : tokens) {
+            final int startOffset = token.getStartOffset();
+
+            sb.append(input, lastEndOffset + 1, startOffset);
+            sb.append(transform.apply(token));
+
+            lastEndOffset = token.getEndOffset();
+        }
+
+        if (input.length() > lastEndOffset + 1) {
+            sb.append(input, lastEndOffset + 1, input.length());
+        }
+
+        return sb.toString();
+    }
+
+    @Override
+    public List<ParameterToken> toList() {
+        return Collections.unmodifiableList(tokens);
+    }
+
+    @Override
+    public Iterator<ParameterToken> iterator() {
+        return tokens.iterator();
+    }
+}
diff --git a/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/StartCharacterEscape.java b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/StartCharacterEscape.java
new file mode 100644
index 00000000000..9ff50968b67
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/main/java/org/apache/nifi/parameter/StartCharacterEscape.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+public class StartCharacterEscape implements ParameterToken {
+    private final int startOffset;
+
+    public StartCharacterEscape(final int startOffset) {
+        this.startOffset = startOffset;
+    }
+
+    @Override
+    public int getStartOffset() {
+        return startOffset;
+    }
+
+    @Override
+    public int getEndOffset() {
+        return startOffset + 1;
+    }
+
+    @Override
+    public String getText() {
+        return "##";
+    }
+
+    @Override
+    public boolean isEscapeSequence() {
+        return true;
+    }
+
+    @Override
+    public boolean isParameterReference() {
+        return false;
+    }
+
+    @Override
+    public String getValue(final ParameterLookup parameterLookup) {
+        return "#";
+    }
+}
diff --git a/nifi-commons/nifi-parameter/src/test/java/org/apache/nifi/parameter/TestExpressionLanguageAgnosticParameterParser.java b/nifi-commons/nifi-parameter/src/test/java/org/apache/nifi/parameter/TestExpressionLanguageAgnosticParameterParser.java
new file mode 100644
index 00000000000..f129c5a3458
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/test/java/org/apache/nifi/parameter/TestExpressionLanguageAgnosticParameterParser.java
@@ -0,0 +1,190 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import org.junit.Test;
+
+import java.util.List;
+
+import static junit.framework.TestCase.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+public class TestExpressionLanguageAgnosticParameterParser {
+
+    @Test
+    public void testProperReferences() {
+        final ParameterParser parameterParser = new ExpressionLanguageAgnosticParameterParser();
+        final ParameterTokenList references = parameterParser.parseTokens("#{foo}");
+
+        for (final ParameterReference reference : references.toReferenceList()) {
+            assertEquals("foo", reference.getParameterName());
+            assertEquals(0, reference.getStartOffset());
+            assertEquals(5, reference.getEndOffset());
+            assertEquals("#{foo}", reference.getText());
+        }
+
+        List<ParameterReference> referenceList = parameterParser.parseTokens("/#{foo}").toReferenceList();
+        assertEquals(1, referenceList.size());
+
+        ParameterReference reference = referenceList.get(0);
+        assertEquals("foo", reference.getParameterName());
+        assertEquals(1, reference.getStartOffset());
+        assertEquals(6, reference.getEndOffset());
+        assertEquals("#{foo}", reference.getText());
+
+        referenceList = parameterParser.parseTokens("/#{foo}/").toReferenceList();
+        assertEquals(1, referenceList.size());
+        reference = referenceList.get(0);
+        assertEquals("foo", reference.getParameterName());
+        assertEquals(1, reference.getStartOffset());
+        assertEquals(6, reference.getEndOffset());
+        assertEquals("#{foo}", reference.getText());
+
+        referenceList = parameterParser.parseTokens("/#{foo}/#{bar}#{baz}").toReferenceList();
+        assertEquals(3, referenceList.size());
+
+        reference = referenceList.get(0);
+        assertEquals("foo", reference.getParameterName());
+        assertEquals(1, reference.getStartOffset());
+        assertEquals(6, reference.getEndOffset());
+        assertEquals("#{foo}", reference.getText());
+
+        reference = referenceList.get(1);
+        assertEquals("bar", reference.getParameterName());
+        assertEquals(8, reference.getStartOffset());
+        assertEquals(13, reference.getEndOffset());
+        assertEquals("#{bar}", reference.getText());
+
+        reference = referenceList.get(2);
+        assertEquals("baz", reference.getParameterName());
+        assertEquals(14, reference.getStartOffset());
+        assertEquals(19, reference.getEndOffset());
+        assertEquals("#{baz}", reference.getText());
+    }
+
+    @Test
+    public void testEscapeSequences() {
+        final ParameterParser parameterParser = new ExpressionLanguageAgnosticParameterParser();
+        List<ParameterToken> tokenList = parameterParser.parseTokens("#{foo}").toList();
+        assertEquals(1, tokenList.size());
+
+        ParameterToken token = tokenList.get(0);
+        assertTrue(token.isParameterReference());
+        assertEquals("foo", ((ParameterReference) token).getParameterName());
+        assertEquals(0, token.getStartOffset());
+        assertEquals(5, token.getEndOffset());
+        assertEquals("#{foo}", token.getText());
+        assertFalse(token.isEscapeSequence());
+
+        tokenList = parameterParser.parseTokens("##{foo}").toList();
+        assertEquals(1, tokenList.size());
+
+        token = tokenList.get(0);
+        assertFalse(token.isParameterReference());
+        assertEquals(0, token.getStartOffset());
+        assertEquals(6, token.getEndOffset());
+        assertEquals("##{foo}", token.getText());
+        assertTrue(token.isEscapeSequence());
+
+        tokenList = parameterParser.parseTokens("###{foo}").toList();
+        assertEquals(2, tokenList.size());
+
+        token = tokenList.get(0);
+        assertFalse(token.isParameterReference());
+        assertEquals(0, token.getStartOffset());
+        assertEquals(1, token.getEndOffset());
+        assertEquals("##", token.getText());
+        assertTrue(token.isEscapeSequence());
+
+        token = tokenList.get(1);
+        assertTrue(token.isParameterReference());
+        assertEquals("foo", ((ParameterReference) token).getParameterName());
+        assertEquals(2, token.getStartOffset());
+        assertEquals(7, token.getEndOffset());
+        assertFalse(token.isEscapeSequence());
+
+        // Test an escaped # followed by an escaped #{foo}
+        tokenList = parameterParser.parseTokens("####{foo}").toList();
+        assertEquals(2, tokenList.size());
+
+        token = tokenList.get(0);
+        assertFalse(token.isParameterReference());
+        assertEquals(0, token.getStartOffset());
+        assertEquals(1, token.getEndOffset());
+        assertEquals("##", token.getText());
+        assertTrue(token.isEscapeSequence());
+
+        token = tokenList.get(1);
+        assertFalse(token.isParameterReference());
+        assertEquals(2, token.getStartOffset());
+        assertEquals(8, token.getEndOffset());
+        assertTrue(token.isEscapeSequence());
+
+        // Test multiple escaped # followed by a reference of #{foo}
+        tokenList = parameterParser.parseTokens("#####{foo}").toList();
+        assertEquals(3, tokenList.size());
+
+        token = tokenList.get(0);
+        assertFalse(token.isParameterReference());
+        assertEquals(0, token.getStartOffset());
+        assertEquals(1, token.getEndOffset());
+        assertEquals("##", token.getText());
+        assertTrue(token.isEscapeSequence());
+
+        token = tokenList.get(1);
+        assertFalse(token.isParameterReference());
+        assertEquals(2, token.getStartOffset());
+        assertEquals(3, token.getEndOffset());
+        assertEquals("##", token.getText());
+        assertTrue(token.isEscapeSequence());
+
+        token = tokenList.get(2);
+        assertTrue(token.isParameterReference());
+        assertEquals("foo", ((ParameterReference) token).getParameterName());
+        assertEquals(4, token.getStartOffset());
+        assertEquals(9, token.getEndOffset());
+        assertFalse(token.isEscapeSequence());
+    }
+
+    @Test
+    public void testNonReferences() {
+        final ParameterParser parameterParser = new ExpressionLanguageAgnosticParameterParser();
+
+        for (final String input : new String[] {"#foo", "Some text #{blah foo", "#foo}", "#}foo{", "#f{oo}", "#", "##", "###", "####", "#####", "#{", "##{", "###{"}) {
+            assertEquals(0, parameterParser.parseTokens(input).toList().size());
+        }
+    }
+
+    @Test
+    public void testReferenceWithinExpressionLanguage() {
+        final ParameterParser parameterParser = new ExpressionLanguageAgnosticParameterParser();
+        final List<ParameterToken> tokens = parameterParser.parseTokens("${#{hello}:toUpper()}").toList();
+        assertEquals(1, tokens.size());
+    }
+
+    @Test
+    public void testReferenceInsideAndOutsideExpressionLanguage() {
+        final ParameterParser parameterParser = new ExpressionLanguageAgnosticParameterParser();
+        final List<ParameterToken> tokens = parameterParser.parseTokens("#{hello}${#{hello}:toUpper()}#{hello}").toList();
+        assertEquals(3, tokens.size());
+
+        for (final ParameterToken token : tokens) {
+            assertEquals("hello", ((ParameterReference) token).getParameterName());
+        }
+    }
+}
diff --git a/nifi-commons/nifi-parameter/src/test/java/org/apache/nifi/parameter/TestExpressionLanguageAwareParameterParser.java b/nifi-commons/nifi-parameter/src/test/java/org/apache/nifi/parameter/TestExpressionLanguageAwareParameterParser.java
new file mode 100644
index 00000000000..d4cf0588044
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/test/java/org/apache/nifi/parameter/TestExpressionLanguageAwareParameterParser.java
@@ -0,0 +1,201 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import org.junit.Test;
+
+import java.util.List;
+
+import static junit.framework.TestCase.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+
+public class TestExpressionLanguageAwareParameterParser {
+
+    @Test
+    public void testProperReferences() {
+        final ParameterParser parameterParser = new ExpressionLanguageAwareParameterParser();
+        final ParameterTokenList references = parameterParser.parseTokens("#{foo}");
+
+        for (final ParameterReference reference : references.toReferenceList()) {
+            assertEquals("foo", reference.getParameterName());
+            assertEquals(0, reference.getStartOffset());
+            assertEquals(5, reference.getEndOffset());
+            assertEquals("#{foo}", reference.getText());
+        }
+
+        List<ParameterReference> referenceList = parameterParser.parseTokens("/#{foo}").toReferenceList();
+        assertEquals(1, referenceList.size());
+
+        ParameterReference reference = referenceList.get(0);
+        assertEquals("foo", reference.getParameterName());
+        assertEquals(1, reference.getStartOffset());
+        assertEquals(6, reference.getEndOffset());
+        assertEquals("#{foo}", reference.getText());
+
+        referenceList = parameterParser.parseTokens("/#{foo}/").toReferenceList();
+        assertEquals(1, referenceList.size());
+        reference = referenceList.get(0);
+        assertEquals("foo", reference.getParameterName());
+        assertEquals(1, reference.getStartOffset());
+        assertEquals(6, reference.getEndOffset());
+        assertEquals("#{foo}", reference.getText());
+
+        referenceList = parameterParser.parseTokens("/#{foo}/#{bar}#{baz}").toReferenceList();
+        assertEquals(3, referenceList.size());
+
+        reference = referenceList.get(0);
+        assertEquals("foo", reference.getParameterName());
+        assertEquals(1, reference.getStartOffset());
+        assertEquals(6, reference.getEndOffset());
+        assertEquals("#{foo}", reference.getText());
+
+        reference = referenceList.get(1);
+        assertEquals("bar", reference.getParameterName());
+        assertEquals(8, reference.getStartOffset());
+        assertEquals(13, reference.getEndOffset());
+        assertEquals("#{bar}", reference.getText());
+
+        reference = referenceList.get(2);
+        assertEquals("baz", reference.getParameterName());
+        assertEquals(14, reference.getStartOffset());
+        assertEquals(19, reference.getEndOffset());
+        assertEquals("#{baz}", reference.getText());
+    }
+
+    @Test
+    public void testEscapeSequences() {
+        final ParameterParser parameterParser = new ExpressionLanguageAwareParameterParser();
+        List<ParameterToken> tokenList = parameterParser.parseTokens("#{foo}").toList();
+        assertEquals(1, tokenList.size());
+
+        ParameterToken token = tokenList.get(0);
+        assertTrue(token.isParameterReference());
+        assertEquals("foo", ((ParameterReference) token).getParameterName());
+        assertEquals(0, token.getStartOffset());
+        assertEquals(5, token.getEndOffset());
+        assertEquals("#{foo}", token.getText());
+        assertFalse(token.isEscapeSequence());
+
+        tokenList = parameterParser.parseTokens("##{foo}").toList();
+        assertEquals(1, tokenList.size());
+
+        token = tokenList.get(0);
+        assertFalse(token.isParameterReference());
+        assertEquals(0, token.getStartOffset());
+        assertEquals(6, token.getEndOffset());
+        assertEquals("##{foo}", token.getText());
+        assertTrue(token.isEscapeSequence());
+
+        tokenList = parameterParser.parseTokens("###{foo}").toList();
+        assertEquals(2, tokenList.size());
+
+        token = tokenList.get(0);
+        assertFalse(token.isParameterReference());
+        assertEquals(0, token.getStartOffset());
+        assertEquals(1, token.getEndOffset());
+        assertEquals("##", token.getText());
+        assertTrue(token.isEscapeSequence());
+
+        token = tokenList.get(1);
+        assertTrue(token.isParameterReference());
+        assertEquals("foo", ((ParameterReference) token).getParameterName());
+        assertEquals(2, token.getStartOffset());
+        assertEquals(7, token.getEndOffset());
+        assertFalse(token.isEscapeSequence());
+
+        // Test an escaped # followed by an escaped #{foo}
+        tokenList = parameterParser.parseTokens("####{foo}").toList();
+        assertEquals(2, tokenList.size());
+
+        token = tokenList.get(0);
+        assertFalse(token.isParameterReference());
+        assertEquals(0, token.getStartOffset());
+        assertEquals(1, token.getEndOffset());
+        assertEquals("##", token.getText());
+        assertTrue(token.isEscapeSequence());
+
+        token = tokenList.get(1);
+        assertFalse(token.isParameterReference());
+        assertEquals(2, token.getStartOffset());
+        assertEquals(8, token.getEndOffset());
+        assertTrue(token.isEscapeSequence());
+
+        // Test multiple escaped # followed by a reference of #{foo}
+        tokenList = parameterParser.parseTokens("#####{foo}").toList();
+        assertEquals(3, tokenList.size());
+
+        token = tokenList.get(0);
+        assertFalse(token.isParameterReference());
+        assertEquals(0, token.getStartOffset());
+        assertEquals(1, token.getEndOffset());
+        assertEquals("##", token.getText());
+        assertTrue(token.isEscapeSequence());
+
+        token = tokenList.get(1);
+        assertFalse(token.isParameterReference());
+        assertEquals(2, token.getStartOffset());
+        assertEquals(3, token.getEndOffset());
+        assertEquals("##", token.getText());
+        assertTrue(token.isEscapeSequence());
+
+        token = tokenList.get(2);
+        assertTrue(token.isParameterReference());
+        assertEquals("foo", ((ParameterReference) token).getParameterName());
+        assertEquals(4, token.getStartOffset());
+        assertEquals(9, token.getEndOffset());
+        assertFalse(token.isEscapeSequence());
+    }
+
+    @Test
+    public void testNonReferences() {
+        final ParameterParser parameterParser = new ExpressionLanguageAwareParameterParser();
+
+        for (final String input : new String[] {"#foo", "Some text #{blah foo", "#foo}", "#}foo{", "#f{oo}", "#", "##", "###", "####", "#####", "#{", "##{", "###{"}) {
+            assertEquals(0, parameterParser.parseTokens(input).toList().size());
+        }
+    }
+
+    @Test
+    public void testReferenceWithinExpressionLanguage() {
+        final ParameterParser parameterParser = new ExpressionLanguageAwareParameterParser();
+        final List<ParameterToken> tokens = parameterParser.parseTokens("${#{hello}:toUpper()}").toList();
+        assertEquals(0, tokens.size());
+    }
+
+    @Test
+    public void testReferenceInsideAndOutsideExpressionLanguage() {
+        final ParameterParser parameterParser = new ExpressionLanguageAwareParameterParser();
+        final List<ParameterToken> tokens = parameterParser.parseTokens("#{hello}${#{hello}:toUpper()}#{hello}").toList();
+        assertEquals(2, tokens.size());
+
+        for (final ParameterToken token : tokens) {
+            assertEquals("hello", ((ParameterReference) token).getParameterName());
+        }
+    }
+
+    @Test
+    public void testReferenceOutsideExpressionLanguage() {
+        final ParameterParser parameterParser = new ExpressionLanguageAwareParameterParser();
+        final List<ParameterToken> tokens = parameterParser.parseTokens("#{hello}").toList();
+        assertEquals(1, tokens.size());
+
+        for (final ParameterToken token : tokens) {
+            assertEquals("hello", ((ParameterReference) token).getParameterName());
+        }
+    }
+}
diff --git a/nifi-commons/nifi-parameter/src/test/java/org/apache/nifi/parameter/TestStandardParameterTokenList.java b/nifi-commons/nifi-parameter/src/test/java/org/apache/nifi/parameter/TestStandardParameterTokenList.java
new file mode 100644
index 00000000000..bfac6114c84
--- /dev/null
+++ b/nifi-commons/nifi-parameter/src/test/java/org/apache/nifi/parameter/TestStandardParameterTokenList.java
@@ -0,0 +1,106 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import org.junit.Test;
+import org.mockito.Mockito;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+
+import static org.junit.Assert.assertEquals;
+
+public class TestStandardParameterTokenList {
+
+    @Test
+    public void testSubstitute() {
+        final List<ParameterToken> referenceList = new ArrayList<>();
+        referenceList.add(new StandardParameterReference("foo", 0, 5, "#{foo}"));
+
+        final ParameterLookup paramLookup = Mockito.mock(ParameterLookup.class);
+        Mockito.when(paramLookup.getParameter("foo")).thenReturn(Optional.of(new Parameter(new ParameterDescriptor.Builder().name("foo").build(), "bar")));
+        Mockito.when(paramLookup.getParameter("bazz")).thenReturn(Optional.of(new Parameter(new ParameterDescriptor.Builder().name("bazz").build(), "baz")));
+
+        StandardParameterTokenList references = new StandardParameterTokenList("#{foo}", referenceList);
+        assertEquals("bar", references.substitute(paramLookup));
+
+        referenceList.add(new StandardParameterReference("bazz", 6, 12, "#{bazz}"));
+
+        references = new StandardParameterTokenList("#{foo}#{bazz}", referenceList);
+        assertEquals("barbaz", references.substitute(paramLookup));
+
+        references = new StandardParameterTokenList("#{foo}#{bazz}Hello, World!", referenceList);
+        assertEquals("barbazHello, World!", references.substitute(paramLookup));
+
+        referenceList.clear();
+        referenceList.add(new StandardParameterReference("foo", 0, 5, "#{foo}"));
+    }
+
+    @Test
+    public void testSubstituteWithReferenceToNonExistentParameter() {
+        final List<ParameterToken> referenceList = new ArrayList<>();
+        referenceList.add(new StandardParameterReference("foo", 0, 5, "#{foo}"));
+
+        final ParameterLookup paramContext = Mockito.mock(ParameterLookup.class);
+        Mockito.when(paramContext.getParameter(Mockito.anyString())).thenReturn(Optional.empty());
+        final StandardParameterTokenList references = new StandardParameterTokenList("#{foo}", referenceList);
+
+        assertEquals("#{foo}", references.substitute(paramContext));
+    }
+
+    @Test
+    public void testSubstituteWithEscapes() {
+        final List<ParameterToken> referenceList = new ArrayList<>();
+        referenceList.add(new StartCharacterEscape(0));
+        referenceList.add(new EscapedParameterReference(2, 8, "##{foo}"));
+
+        final ParameterLookup paramContext = Mockito.mock(ParameterLookup.class);
+        Mockito.when(paramContext.getParameter("foo")).thenReturn(Optional.of(new Parameter(new ParameterDescriptor.Builder().name("foo").build(), "bar")));
+
+        StandardParameterTokenList references = new StandardParameterTokenList("####{foo}", referenceList);
+        assertEquals("##{foo}", references.substitute(paramContext));
+
+        referenceList.add(new StandardParameterReference("foo", 12, 17, "#{foo}"));
+        references = new StandardParameterTokenList("####{foo}***#{foo}", referenceList);
+        assertEquals("##{foo}***bar", references.substitute(paramContext));
+    }
+
+    @Test
+    public void testEscape() {
+        final List<ParameterToken> referenceList = new ArrayList<>();
+
+        assertEquals("Hello", new StandardParameterTokenList("Hello", referenceList).escape());
+
+        referenceList.add(new StandardParameterReference("abc", 0, 5, "#{abc}"));
+        assertEquals("##{abc}", new StandardParameterTokenList("#{abc}", referenceList).escape());
+
+        referenceList.clear();
+        referenceList.add(new EscapedParameterReference(0, 6, "##{abc}"));
+        assertEquals("####{abc}", new StandardParameterTokenList("##{abc}", referenceList).escape());
+
+        referenceList.clear();
+        referenceList.add(new StartCharacterEscape(0));
+        referenceList.add(new StandardParameterReference("abc", 2, 7, "#{abc}"));
+        assertEquals("######{abc}", new StandardParameterTokenList("###{abc}", referenceList).escape());
+
+        referenceList.clear();
+        referenceList.add(new StartCharacterEscape(0));
+        referenceList.add(new EscapedParameterReference(2, 8, "##{abc}"));
+        assertEquals("########{abc}", new StandardParameterTokenList("####{abc}", referenceList).escape());
+    }
+}
diff --git a/nifi-commons/pom.xml b/nifi-commons/pom.xml
index 9441d8d98a6..fec6996a641 100644
--- a/nifi-commons/pom.xml
+++ b/nifi-commons/pom.xml
@@ -40,5 +40,6 @@
     	<module>nifi-record</module>
         <module>nifi-record-path</module>
         <module>nifi-metrics</module>
+        <module>nifi-parameter</module>
     </modules>
-</project>
\ No newline at end of file
+</project>
diff --git a/nifi-mock/pom.xml b/nifi-mock/pom.xml
index d725b3e3e59..430aabe8db9 100644
--- a/nifi-mock/pom.xml
+++ b/nifi-mock/pom.xml
@@ -32,6 +32,11 @@
             <artifactId>nifi-framework-api</artifactId>
             <version>1.10.0-SNAPSHOT</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.nifi</groupId>
+            <artifactId>nifi-parameter</artifactId>
+            <version>1.10.0-SNAPSHOT</version>
+        </dependency>
         <dependency>
             <groupId>org.apache.nifi</groupId>
             <artifactId>nifi-utils</artifactId>
diff --git a/nifi-mock/src/main/java/org/apache/nifi/util/MockPropertyValue.java b/nifi-mock/src/main/java/org/apache/nifi/util/MockPropertyValue.java
index ec2d08be569..209559b5e63 100644
--- a/nifi-mock/src/main/java/org/apache/nifi/util/MockPropertyValue.java
+++ b/nifi-mock/src/main/java/org/apache/nifi/util/MockPropertyValue.java
@@ -16,12 +16,8 @@
  */
 package org.apache.nifi.util;
 
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.TimeUnit;
-
 import org.apache.nifi.annotation.behavior.InputRequirement;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.Query;
 import org.apache.nifi.attribute.expression.language.Query.Range;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
@@ -36,6 +32,11 @@
 import org.apache.nifi.processor.exception.ProcessException;
 import org.apache.nifi.registry.VariableRegistry;
 
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.TimeUnit;
+
 public class MockPropertyValue implements PropertyValue {
     private final String rawValue;
     private final Boolean expectExpressions;
@@ -65,7 +66,7 @@ public MockPropertyValue(final String rawValue, final ControllerServiceLookup se
 
     private MockPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup, final PropertyDescriptor propertyDescriptor, final boolean alreadyEvaluated,
             final VariableRegistry variableRegistry) {
-        this.stdPropValue = new StandardPropertyValue(rawValue, serviceLookup, variableRegistry);
+        this.stdPropValue = new StandardPropertyValue(rawValue, serviceLookup, ParameterLookup.EMPTY, variableRegistry);
         this.rawValue = rawValue;
         this.serviceLookup = (MockControllerServiceLookup) serviceLookup;
         this.expectExpressions = propertyDescriptor == null ? null : propertyDescriptor.isExpressionLanguageSupported();
diff --git a/nifi-mock/src/main/java/org/apache/nifi/util/MockValidationContext.java b/nifi-mock/src/main/java/org/apache/nifi/util/MockValidationContext.java
index 72820ee94b5..87389be7973 100644
--- a/nifi-mock/src/main/java/org/apache/nifi/util/MockValidationContext.java
+++ b/nifi-mock/src/main/java/org/apache/nifi/util/MockValidationContext.java
@@ -16,12 +16,8 @@
  */
 package org.apache.nifi.util;
 
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
+import org.apache.nifi.parameter.ExpressionLanguageAgnosticParameterParser;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.Query;
 import org.apache.nifi.attribute.expression.language.Query.Range;
 import org.apache.nifi.attribute.expression.language.StandardExpressionLanguageCompiler;
@@ -32,8 +28,18 @@
 import org.apache.nifi.controller.ControllerService;
 import org.apache.nifi.controller.ControllerServiceLookup;
 import org.apache.nifi.expression.ExpressionLanguageCompiler;
+import org.apache.nifi.parameter.ParameterParser;
+import org.apache.nifi.parameter.ParameterReference;
+import org.apache.nifi.parameter.ExpressionLanguageAwareParameterParser;
 import org.apache.nifi.registry.VariableRegistry;
 
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
 
 public class MockValidationContext extends MockControllerServiceLookup implements ValidationContext, ControllerServiceLookup {
 
@@ -70,7 +76,7 @@ public PropertyValue newPropertyValue(final String rawValue) {
 
     @Override
     public ExpressionLanguageCompiler newExpressionLanguageCompiler() {
-        return new StandardExpressionLanguageCompiler(variableRegistry);
+        return new StandardExpressionLanguageCompiler(variableRegistry, ParameterLookup.EMPTY);
     }
 
     @Override
@@ -160,4 +166,23 @@ public String getProcessGroupIdentifier() {
         return "unit test";
     }
 
+    @Override
+    public Collection<String> getReferencedParameters(final String propertyName) {
+        final String rawPropertyValue = context.getProperty(propertyName).getValue();
+        final boolean elSupported = isExpressionLanguageSupported(propertyName);
+
+        final ParameterParser parser = elSupported ? new ExpressionLanguageAwareParameterParser() : new ExpressionLanguageAgnosticParameterParser();
+
+        final List<ParameterReference> references = parser.parseTokens(rawPropertyValue).toReferenceList();
+        return references.stream()
+            .map(ParameterReference::getParameterName)
+            .collect(Collectors.toList());
+    }
+
+    @Override
+    public boolean isParameterDefined(final String parameterName) {
+        // TODO: Implement
+        return false;
+    }
+
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/AffectedComponentDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/AffectedComponentDTO.java
index dd7c6c43db4..ebfcadd72e5 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/AffectedComponentDTO.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/AffectedComponentDTO.java
@@ -116,4 +116,9 @@ public String getState() {
     public void setState(String state) {
         this.state = state;
     }
+
+    @Override
+    public String toString() {
+        return "AffectedComponent[type=" + referenceType + ", id=" + id + ", name=" + name + ", processGroup=" + processGroupId + "]";
+    }
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/AsynchronousRequestDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/AsynchronousRequestDTO.java
new file mode 100644
index 00000000000..180d4f563a6
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/AsynchronousRequestDTO.java
@@ -0,0 +1,116 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.dto;
+
+import io.swagger.annotations.ApiModelProperty;
+
+import java.util.Date;
+import java.util.List;
+
+public abstract class AsynchronousRequestDTO<T extends UpdateStepDTO> {
+    private String requestId;
+    private String uri;
+    private Date submissionTime;
+    private Date lastUpdated;
+    private boolean complete = false;
+    private String failureReason;
+    private int percentCompleted;
+    private String state;
+    private List<T> updateSteps;
+
+
+    @ApiModelProperty(value = "The ID of the request", readOnly = true)
+    public String getRequestId() {
+        return requestId;
+    }
+
+    public void setRequestId(final String requestId) {
+        this.requestId = requestId;
+    }
+
+    @ApiModelProperty(value = "The URI for the request", readOnly = true)
+    public String getUri() {
+        return uri;
+    }
+
+    public void setUri(final String uri) {
+        this.uri = uri;
+    }
+
+    @ApiModelProperty(value = "The timestamp of when the request was submitted", readOnly =  true)
+    public Date getSubmissionTime() {
+        return submissionTime;
+    }
+
+    public void setSubmissionTime(final Date submissionTime) {
+        this.submissionTime = submissionTime;
+    }
+
+    @ApiModelProperty(value = "The timestamp of when the request was last updated", readOnly = true)
+    public Date getLastUpdated() {
+        return lastUpdated;
+    }
+
+    public void setLastUpdated(final Date lastUpdated) {
+        this.lastUpdated = lastUpdated;
+    }
+
+    @ApiModelProperty(value = "Whether or not the request is completed", readOnly = true)
+    public boolean isComplete() {
+        return complete;
+    }
+
+    public void setComplete(final boolean complete) {
+        this.complete = complete;
+    }
+
+    @ApiModelProperty(value = "The reason for the request failing, or null if the request has not failed", readOnly = true)
+    public String getFailureReason() {
+        return failureReason;
+    }
+
+    public void setFailureReason(final String failureReason) {
+        this.failureReason = failureReason;
+    }
+
+    @ApiModelProperty(value = "A value between 0 and 100 (inclusive) indicating how close the request is to completion", readOnly = true)
+    public int getPercentCompleted() {
+        return percentCompleted;
+    }
+
+    public void setPercentCompleted(final int percentCompleted) {
+        this.percentCompleted = percentCompleted;
+    }
+
+    @ApiModelProperty(value = "A description of the current state of the request", readOnly = true)
+    public String getState() {
+        return state;
+    }
+
+    public void setState(final String state) {
+        this.state = state;
+    }
+
+    @ApiModelProperty(value = "The steps that are required in order to complete the request, along with the status of each", readOnly = true)
+    public List<T> getUpdateSteps() {
+        return updateSteps;
+    }
+
+    public void setUpdateSteps(List<T> updateSteps) {
+        this.updateSteps = updateSteps;
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ComponentValidationResultDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ComponentValidationResultDTO.java
new file mode 100644
index 00000000000..3da52b5a97f
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ComponentValidationResultDTO.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.dto;
+
+import io.swagger.annotations.ApiModelProperty;
+
+import javax.xml.bind.annotation.XmlType;
+import java.util.Collection;
+
+@XmlType(name = "componentValidationResult")
+public class ComponentValidationResultDTO extends AffectedComponentDTO {
+    private Boolean currentlyValid;
+    private Boolean resultsValid;
+    private Collection<String> resultantValidationErrors;
+
+    @ApiModelProperty("Whether or not the component is currently valid")
+    public Boolean getCurrentlyValid() {
+        return currentlyValid;
+    }
+
+    public void setCurrentlyValid(final Boolean currentlyValid) {
+        this.currentlyValid = currentlyValid;
+    }
+
+    @ApiModelProperty("Whether or not the component will be valid if the Parameter Context is changed")
+    public Boolean getResultsValid() {
+        return resultsValid;
+    }
+
+    public void setResultsValid(final Boolean resultsValid) {
+        this.resultsValid = resultsValid;
+    }
+
+    @ApiModelProperty("The validation errors that will apply to the component if the Parameter Context is changed")
+    public Collection<String> getResultantValidationErrors() {
+        return resultantValidationErrors;
+    }
+
+    public void setResultantValidationErrors(final Collection<String> resultantValidationErrors) {
+        this.resultantValidationErrors = resultantValidationErrors;
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextDTO.java
new file mode 100644
index 00000000000..d40fa31b6c2
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextDTO.java
@@ -0,0 +1,83 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.dto;
+
+import io.swagger.annotations.ApiModelProperty;
+import org.apache.nifi.web.api.entity.ParameterEntity;
+import org.apache.nifi.web.api.entity.ProcessGroupEntity;
+
+import javax.xml.bind.annotation.XmlType;
+import java.util.Set;
+
+@XmlType(name = "parameterContext")
+public class ParameterContextDTO {
+    private String identifier;
+    private String name;
+    private String description;
+    private Set<ParameterEntity> parameters;
+    private Set<ProcessGroupEntity> boundProcessGroups;
+
+    public void setId(String id) {
+        this.identifier = id;
+    }
+
+    @ApiModelProperty(value = "The ID the Parameter Context.", readOnly = true)
+    public String getId() {
+        return identifier;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    @ApiModelProperty("The Name of the Parameter Context.")
+    public String getName() {
+        return name;
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    @ApiModelProperty("The Description of the Parameter Context.")
+    public String getDescription() {
+        return description;
+    }
+
+    public void setParameters(final Set<ParameterEntity> parameters) {
+        this.parameters = parameters;
+    }
+
+    @ApiModelProperty("The Parameters for the Parameter Context")
+    public Set<ParameterEntity> getParameters() {
+        return parameters;
+    }
+
+    public void setBoundProcessGroups(final Set<ProcessGroupEntity> boundProcessGroups) {
+        this.boundProcessGroups = boundProcessGroups;
+    }
+
+    @ApiModelProperty(value = "The Process Groups that are bound to this Parameter Context", readOnly = true)
+    public Set<ProcessGroupEntity> getBoundProcessGroups() {
+        return boundProcessGroups;
+    }
+
+    @Override
+    public String toString() {
+        return "ParameterContext[id=" + identifier + ", name=" + name + ", parameters=" + parameters + "]";
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextReferenceDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextReferenceDTO.java
new file mode 100644
index 00000000000..9d6241f16b0
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextReferenceDTO.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.dto;
+
+import io.swagger.annotations.ApiModelProperty;
+
+import javax.xml.bind.annotation.XmlType;
+
+@XmlType(name = "parameterContextReference")
+public class ParameterContextReferenceDTO {
+    private String id;
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    @ApiModelProperty("The ID of the Parameter Context")
+    public String getId() {
+        return id;
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextUpdateRequestDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextUpdateRequestDTO.java
new file mode 100644
index 00000000000..76acc8d054c
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextUpdateRequestDTO.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.dto;
+
+import io.swagger.annotations.ApiModelProperty;
+import org.apache.nifi.web.api.entity.AffectedComponentEntity;
+
+import javax.xml.bind.annotation.XmlType;
+import java.util.Set;
+
+@XmlType(name = "parameterContextUpdateRequest")
+public class ParameterContextUpdateRequestDTO extends AsynchronousRequestDTO<ParameterContextUpdateStepDTO> {
+    private ParameterContextDTO parameterContext;
+    private Set<AffectedComponentEntity> affectedComponents;
+
+    @ApiModelProperty(value = "The Parameter Context that is being operated on. This may not be populated until the request has successfully completed.", readOnly = true)
+    public ParameterContextDTO getParameterContext() {
+        return parameterContext;
+    }
+
+    public void setParameterContext(final ParameterContextDTO parameterContext) {
+        this.parameterContext = parameterContext;
+    }
+
+    @ApiModelProperty(value = "The components that are affected by the update.", readOnly = true)
+    public Set<AffectedComponentEntity> getAffectedComponents() {
+        return affectedComponents;
+    }
+
+    public void setAffectedComponents(final Set<AffectedComponentEntity> affectedComponents) {
+        this.affectedComponents = affectedComponents;
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextUpdateStepDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextUpdateStepDTO.java
new file mode 100644
index 00000000000..e1059583a99
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextUpdateStepDTO.java
@@ -0,0 +1,23 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.dto;
+
+import javax.xml.bind.annotation.XmlType;
+
+@XmlType(name = "parameterContextUpdateStep")
+public class ParameterContextUpdateStepDTO extends UpdateStepDTO {
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextValidationRequestDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextValidationRequestDTO.java
new file mode 100644
index 00000000000..c475286bf6f
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextValidationRequestDTO.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.dto;
+
+import io.swagger.annotations.ApiModelProperty;
+import org.apache.nifi.web.api.entity.ComponentValidationResultsEntity;
+
+import javax.xml.bind.annotation.XmlType;
+
+@XmlType(name = "parameterContextValidationRequest")
+public class ParameterContextValidationRequestDTO extends AsynchronousRequestDTO<ParameterContextValidationStepDTO> {
+    private ParameterContextDTO parameterContext;
+    private ComponentValidationResultsEntity componentValidationResults;
+
+    @ApiModelProperty(value = "The Validation Results that were calculated for each component. This value may not be set until the request completes.", readOnly = true)
+    public ComponentValidationResultsEntity getComponentValidationResults() {
+        return componentValidationResults;
+    }
+
+    public void setComponentValidationResults(final ComponentValidationResultsEntity componentValidationResults) {
+        this.componentValidationResults = componentValidationResults;
+    }
+
+    @ApiModelProperty("The Parameter Context that is being operated on.")
+    public ParameterContextDTO getParameterContext() {
+        return parameterContext;
+    }
+
+    public void setParameterContext(final ParameterContextDTO parameterContext) {
+        this.parameterContext = parameterContext;
+    }
+
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextValidationResultsDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextValidationResultsDTO.java
new file mode 100644
index 00000000000..b4fb1c1e0a2
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextValidationResultsDTO.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.dto;
+
+import javax.xml.bind.annotation.XmlType;
+import java.util.List;
+
+@XmlType(name = "parameterContextValidationResults")
+public class ParameterContextValidationResultsDTO {
+    private List<ComponentValidationResultDTO> componentValidationResults;
+
+    public void setComponentValidationResults(List<ComponentValidationResultDTO> componentValidationResults) {
+        this.componentValidationResults = componentValidationResults;
+    }
+
+    public List<ComponentValidationResultDTO> getComponentValidationResults() {
+        return componentValidationResults;
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextValidationStepDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextValidationStepDTO.java
new file mode 100644
index 00000000000..76af7522daf
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterContextValidationStepDTO.java
@@ -0,0 +1,23 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.dto;
+
+import javax.xml.bind.annotation.XmlType;
+
+@XmlType(name = "parameterContextValidationStep")
+public class ParameterContextValidationStepDTO extends UpdateStepDTO {
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterDTO.java
new file mode 100644
index 00000000000..4cbeb6ffcdd
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ParameterDTO.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.dto;
+
+import io.swagger.annotations.ApiModelProperty;
+import org.apache.nifi.web.api.entity.AffectedComponentEntity;
+
+import javax.xml.bind.annotation.XmlType;
+import java.util.Set;
+
+@XmlType(name = "parameter")
+public class ParameterDTO {
+    private String name;
+    private String description;
+    private Boolean sensitive;
+    private String value;
+    private Set<AffectedComponentEntity> referencingComponents;
+
+    @ApiModelProperty("The name of the Parameter")
+    public String getName() {
+        return name;
+    }
+
+    public void setName(final String name) {
+        this.name = name;
+    }
+
+    @ApiModelProperty("The description of the Parameter")
+    public String getDescription() {
+        return description;
+    }
+
+    public void setDescription(final String description) {
+        this.description = description;
+    }
+
+    @ApiModelProperty("Whether or not the Parameter is sensitive")
+    public Boolean getSensitive() {
+        return sensitive;
+    }
+
+    public void setSensitive(final Boolean sensitive) {
+        this.sensitive = sensitive;
+    }
+
+    @ApiModelProperty("The value of the Parameter")
+    public String getValue() {
+        return value;
+    }
+
+    public void setValue(final String value) {
+        this.value = value;
+    }
+
+    @ApiModelProperty("The set of all components in the flow that are referencing this Parameter")
+    public Set<AffectedComponentEntity> getReferencingComponents() {
+        return referencingComponents;
+    }
+
+    public void setReferencingComponents(final Set<AffectedComponentEntity> referencingComponents) {
+        this.referencingComponents = referencingComponents;
+    }
+
+    @Override
+    public String toString() {
+        return "ParameterDTO[name=" + name + ", sensitive=" + sensitive + ", value=" + (sensitive ? "********" : value) + "]";
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ProcessGroupDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ProcessGroupDTO.java
index 3fe61d491a6..f5a4e353b88 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ProcessGroupDTO.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/ProcessGroupDTO.java
@@ -32,6 +32,7 @@ public class ProcessGroupDTO extends ComponentDTO {
     private String comments;
     private Map<String, String> variables;
     private VersionControlInformationDTO versionControlInformation;
+    private ParameterContextReferenceDTO parameterContext;
 
     private Integer runningCount;
     private Integer stoppedCount;
@@ -341,4 +342,13 @@ public VersionControlInformationDTO getVersionControlInformation() {
     public void setVersionControlInformation(final VersionControlInformationDTO versionControlInformation) {
         this.versionControlInformation = versionControlInformation;
     }
+
+    @ApiModelProperty("The Parameter Context that this Process Group is bound to.")
+    public ParameterContextReferenceDTO getParameterContext() {
+        return parameterContext;
+    }
+
+    public void setParameterContext(final ParameterContextReferenceDTO parameterContext) {
+        this.parameterContext = parameterContext;
+    }
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/TemplateDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/TemplateDTO.java
index 02792af64c7..da358a6dd00 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/TemplateDTO.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/TemplateDTO.java
@@ -29,7 +29,7 @@
  */
 @XmlRootElement(name = "template")
 public class TemplateDTO {
-    public static final String MAX_ENCODING_VERSION = "1.2";
+    public static final String MAX_ENCODING_VERSION = "1.3";
 
     private String uri;
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/UpdateStepDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/UpdateStepDTO.java
new file mode 100644
index 00000000000..25e3f1ff8aa
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/UpdateStepDTO.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.dto;
+
+import io.swagger.annotations.ApiModelProperty;
+
+public abstract class UpdateStepDTO {
+    private String description;
+    private boolean complete;
+    private String failureReason;
+
+    @ApiModelProperty(value = "Explanation of what happens in this step", readOnly = true)
+    public String getDescription() {
+        return description;
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    @ApiModelProperty(value = "Whether or not this step has completed", readOnly = true)
+    public boolean isComplete() {
+        return complete;
+    }
+
+    public void setComplete(boolean complete) {
+        this.complete = complete;
+    }
+
+    @ApiModelProperty(value = "An explanation of why this step failed, or null if this step did not fail", readOnly = true)
+    public String getFailureReason() {
+        return failureReason;
+    }
+
+    public void setFailureReason(String reason) {
+        this.failureReason = reason;
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/VariableRegistryUpdateRequestDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/VariableRegistryUpdateRequestDTO.java
index 24400e616f3..9e4bb61b1e9 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/VariableRegistryUpdateRequestDTO.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/VariableRegistryUpdateRequestDTO.java
@@ -18,25 +18,14 @@
 package org.apache.nifi.web.api.dto;
 
 import io.swagger.annotations.ApiModelProperty;
-import org.apache.nifi.web.api.dto.util.TimestampAdapter;
 import org.apache.nifi.web.api.entity.AffectedComponentEntity;
 
 import javax.xml.bind.annotation.XmlType;
-import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
-import java.util.Date;
-import java.util.List;
 import java.util.Set;
 
 @XmlType(name = "variableRegistryUpdateRequest")
-public class VariableRegistryUpdateRequestDTO {
-    private String requestId;
+public class VariableRegistryUpdateRequestDTO extends AsynchronousRequestDTO<VariableRegistryUpdateStepDTO> {
     private String processGroupId;
-    private String uri;
-    private Date submissionTime;
-    private Date lastUpdated;
-    private boolean complete = false;
-    private String failureReason;
-    private List<VariableRegistryUpdateStepDTO> updateSteps;
     private Set<AffectedComponentEntity> affectedComponents;
 
     @ApiModelProperty("The unique ID of the Process Group that the variable registry belongs to")
@@ -48,71 +37,6 @@ public void setProcessGroupId(String processGroupId) {
         this.processGroupId = processGroupId;
     }
 
-    @ApiModelProperty(value = "The unique ID of this request.", readOnly = true)
-    public String getRequestId() {
-        return requestId;
-    }
-
-    public void setRequestId(String requestId) {
-        this.requestId = requestId;
-    }
-
-    @ApiModelProperty(value = "The URI for future requests to this drop request.", readOnly = true)
-    public String getUri() {
-        return uri;
-    }
-
-    public void setUri(String uri) {
-        this.uri = uri;
-    }
-
-    @XmlJavaTypeAdapter(TimestampAdapter.class)
-    @ApiModelProperty(value = "The time at which this request was submitted.", dataType = "string", readOnly = true)
-    public Date getSubmissionTime() {
-        return submissionTime;
-    }
-
-    public void setSubmissionTime(Date submissionTime) {
-        this.submissionTime = submissionTime;
-    }
-
-    @XmlJavaTypeAdapter(TimestampAdapter.class)
-    @ApiModelProperty(value = "The last time this request was updated.", dataType = "string", readOnly = true)
-    public Date getLastUpdated() {
-        return lastUpdated;
-    }
-
-    public void setLastUpdated(Date lastUpdated) {
-        this.lastUpdated = lastUpdated;
-    }
-
-    @ApiModelProperty(value = "The steps that are required in order to complete the request, along with the status of each", readOnly = true)
-    public List<VariableRegistryUpdateStepDTO> getUpdateSteps() {
-        return updateSteps;
-    }
-
-    public void setUpdateSteps(List<VariableRegistryUpdateStepDTO> updateSteps) {
-        this.updateSteps = updateSteps;
-    }
-
-    @ApiModelProperty(value = "Whether or not this request has completed", readOnly = true)
-    public boolean isComplete() {
-        return complete;
-    }
-
-    public void setComplete(boolean complete) {
-        this.complete = complete;
-    }
-
-    @ApiModelProperty(value = "An explanation of why this request failed, or null if this request has not failed", readOnly = true)
-    public String getFailureReason() {
-        return failureReason;
-    }
-
-    public void setFailureReason(String reason) {
-        this.failureReason = reason;
-    }
-
     @ApiModelProperty(value = "A set of all components that will be affected if the value of this variable is changed", readOnly = true)
     public Set<AffectedComponentEntity> getAffectedComponents() {
         return affectedComponents;
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/VariableRegistryUpdateStepDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/VariableRegistryUpdateStepDTO.java
index 81e0057f4ba..2dd172c4117 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/VariableRegistryUpdateStepDTO.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/VariableRegistryUpdateStepDTO.java
@@ -17,43 +17,9 @@
 
 package org.apache.nifi.web.api.dto;
 
-import io.swagger.annotations.ApiModelProperty;
-
 import javax.xml.bind.annotation.XmlType;
 
 @XmlType(name = "varaibleRegistryUpdateStep")
-public class VariableRegistryUpdateStepDTO {
-    private String description;
-    private boolean complete;
-    private String failureReason;
-
-    public VariableRegistryUpdateStepDTO() {
-    }
-
-    @ApiModelProperty(value = "Explanation of what happens in this step", readOnly = true)
-    public String getDescription() {
-        return description;
-    }
-
-    public void setDescription(String description) {
-        this.description = description;
-    }
-
-    @ApiModelProperty(value = "Whether or not this step has completed", readOnly = true)
-    public boolean isComplete() {
-        return complete;
-    }
-
-    public void setComplete(boolean complete) {
-        this.complete = complete;
-    }
-
-    @ApiModelProperty(value = "An explanation of why this step failed, or null if this step did not fail", readOnly = true)
-    public String getFailureReason() {
-        return failureReason;
-    }
+public class VariableRegistryUpdateStepDTO extends UpdateStepDTO {
 
-    public void setFailureReason(String reason) {
-        this.failureReason = reason;
-    }
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/flow/ProcessGroupFlowDTO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/flow/ProcessGroupFlowDTO.java
index 2ef6115aaed..479375e425d 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/flow/ProcessGroupFlowDTO.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/dto/flow/ProcessGroupFlowDTO.java
@@ -33,6 +33,7 @@ public class ProcessGroupFlowDTO {
     private String id;
     private String uri;
     private String parentGroupId;
+    private String parameterContextId;
     private FlowBreadcrumbEntity breadcrumb;
     private FlowDTO flow;
     private Date lastRefreshed;
@@ -125,4 +126,13 @@ public Date getLastRefreshed() {
     public void setLastRefreshed(Date lastRefreshed) {
         this.lastRefreshed = lastRefreshed;
     }
+
+    @ApiModelProperty("The ID of the Parameter Context, or null if no Parameter Context has been bound to the Process Group")
+    public String getParameterContextId() {
+        return parameterContextId;
+    }
+
+    public void setParameterContextId(String parameterContextId) {
+        this.parameterContextId = parameterContextId;
+    }
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/AffectedComponentEntity.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/AffectedComponentEntity.java
index e0d8496bf8d..efb750560bd 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/AffectedComponentEntity.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/AffectedComponentEntity.java
@@ -41,4 +41,9 @@ public AffectedComponentDTO getComponent() {
     public void setComponent(AffectedComponentDTO component) {
         this.component = component;
     }
+
+    @Override
+    public String toString() {
+        return component == null ? "AffectedComponent[No Component]" : component.toString();
+    }
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ComponentValidationResultEntity.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ComponentValidationResultEntity.java
new file mode 100644
index 00000000000..d7a5718c12b
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ComponentValidationResultEntity.java
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.entity;
+
+import org.apache.nifi.web.api.dto.ComponentValidationResultDTO;
+
+import javax.xml.bind.annotation.XmlRootElement;
+
+@XmlRootElement(name = "componentValidationResultEntity")
+public class ComponentValidationResultEntity extends ComponentEntity implements Permissible<ComponentValidationResultDTO> {
+    private ComponentValidationResultDTO validationResult;
+
+    /**
+     * @return variable referencing components that is being serialized
+     */
+    public ComponentValidationResultDTO getComponent() {
+        return validationResult;
+    }
+
+    public void setComponent(ComponentValidationResultDTO component) {
+        this.validationResult = component;
+    }
+
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ComponentValidationResultsEntity.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ComponentValidationResultsEntity.java
new file mode 100644
index 00000000000..7648a23d2f0
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ComponentValidationResultsEntity.java
@@ -0,0 +1,36 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.entity;
+
+import io.swagger.annotations.ApiModelProperty;
+
+import javax.xml.bind.annotation.XmlRootElement;
+import java.util.List;
+
+@XmlRootElement(name = "componentValidationResults")
+public class ComponentValidationResultsEntity extends Entity {
+    private List<ComponentValidationResultEntity> componentValidationResults;
+
+    @ApiModelProperty("A List of ComponentValidationResultEntity, one for each component that is validated")
+    public List<ComponentValidationResultEntity> getValidationResults() {
+        return componentValidationResults;
+    }
+
+    public void setValidationResults(final List<ComponentValidationResultEntity> componentValidationResults) {
+        this.componentValidationResults = componentValidationResults;
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterContextEntity.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterContextEntity.java
new file mode 100644
index 00000000000..e74ec10d05d
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterContextEntity.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.entity;
+
+import io.swagger.annotations.ApiModelProperty;
+import org.apache.nifi.web.api.dto.ParameterContextDTO;
+
+import javax.xml.bind.annotation.XmlRootElement;
+
+@XmlRootElement(name = "parameterContextEntity")
+public class ParameterContextEntity extends ComponentEntity {
+    private ParameterContextDTO parameterContextDTO;
+
+    @ApiModelProperty("The Parameter Context")
+    public ParameterContextDTO getComponent() {
+        return parameterContextDTO;
+    }
+
+    public void setComponent(ParameterContextDTO parameterContext) {
+        this.parameterContextDTO = parameterContext;
+    }
+
+    @Override
+    public String toString() {
+        return parameterContextDTO == null ? "ParameterContextEntity[No Component]" : parameterContextDTO.toString();
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterContextUpdateRequestEntity.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterContextUpdateRequestEntity.java
new file mode 100644
index 00000000000..a86cba8479c
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterContextUpdateRequestEntity.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.entity;
+
+import io.swagger.annotations.ApiModelProperty;
+import org.apache.nifi.web.api.dto.ParameterContextUpdateRequestDTO;
+import org.apache.nifi.web.api.dto.RevisionDTO;
+
+import javax.xml.bind.annotation.XmlRootElement;
+
+@XmlRootElement(name = "parameterContextUpdateRequestEntity")
+public class ParameterContextUpdateRequestEntity extends Entity {
+    private RevisionDTO parameterContextRevision;
+    private ParameterContextUpdateRequestDTO request;
+
+    @ApiModelProperty("The Revision of the Parameter Context")
+    public RevisionDTO getParameterContextRevision() {
+        return parameterContextRevision;
+    }
+
+    public void setParameterContextRevision(final RevisionDTO parameterContextRevision) {
+        this.parameterContextRevision = parameterContextRevision;
+    }
+
+    @ApiModelProperty("The Update Request")
+    public ParameterContextUpdateRequestDTO getRequest() {
+        return request;
+    }
+
+    public void setRequest(final ParameterContextUpdateRequestDTO request) {
+        this.request = request;
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterContextValidationRequestEntity.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterContextValidationRequestEntity.java
new file mode 100644
index 00000000000..a5aeece3e70
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterContextValidationRequestEntity.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.entity;
+
+import io.swagger.annotations.ApiModelProperty;
+import org.apache.nifi.web.api.dto.ParameterContextValidationRequestDTO;
+
+import javax.xml.bind.annotation.XmlRootElement;
+
+@XmlRootElement(name = "parameterContextValidationRequestEntity")
+public class ParameterContextValidationRequestEntity extends Entity {
+    private ParameterContextValidationRequestDTO request;
+    private Boolean disconnectedNodeAcknowledged;
+
+    @ApiModelProperty("The Update Request")
+    public ParameterContextValidationRequestDTO getRequest() {
+        return request;
+    }
+
+    public void setRequest(final ParameterContextValidationRequestDTO request) {
+        this.request = request;
+    }
+
+    @ApiModelProperty("Acknowledges that this node is disconnected to allow for mutable requests to proceed.")
+    public Boolean isDisconnectedNodeAcknowledged() {
+        return disconnectedNodeAcknowledged;
+    }
+
+    public void setDisconnectedNodeAcknowledged(Boolean disconnectedNodeAcknowledged) {
+        this.disconnectedNodeAcknowledged = disconnectedNodeAcknowledged;
+    }
+
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterContextsEntity.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterContextsEntity.java
new file mode 100644
index 00000000000..3f581af4766
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterContextsEntity.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.entity;
+
+import io.swagger.annotations.ApiModelProperty;
+import org.apache.nifi.web.api.dto.util.TimeAdapter;
+
+import javax.xml.bind.annotation.XmlRootElement;
+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
+import java.util.Date;
+import java.util.Set;
+
+@XmlRootElement(name = "parameterContexts")
+public class ParameterContextsEntity extends Entity {
+    private Set<ParameterContextEntity> parameterContexts;
+    private Date currentTime;
+
+    @ApiModelProperty("The Parameter Contexts")
+    public Set<ParameterContextEntity> getParameterContexts() {
+        return parameterContexts;
+    }
+
+    public void setParameterContexts(final Set<ParameterContextEntity> parameterContexts) {
+        this.parameterContexts = parameterContexts;
+    }
+
+    @XmlJavaTypeAdapter(TimeAdapter.class)
+    @ApiModelProperty(
+        value = "The current time on the system.",
+        dataType = "string",
+        readOnly = true
+    )
+    public Date getCurrentTime() {
+        return currentTime;
+    }
+
+    public void setCurrentTime(Date currentTime) {
+        this.currentTime = currentTime;
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterEntity.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterEntity.java
new file mode 100644
index 00000000000..e77c0ae7599
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-client-dto/src/main/java/org/apache/nifi/web/api/entity/ParameterEntity.java
@@ -0,0 +1,49 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.entity;
+
+import io.swagger.annotations.ApiModelProperty;
+import org.apache.nifi.web.api.dto.ParameterDTO;
+import org.apache.nifi.web.api.dto.WritablePermission;
+
+import javax.xml.bind.annotation.XmlRootElement;
+
+@XmlRootElement(name = "parameterEntity")
+public class ParameterEntity extends Entity implements WritablePermission {
+    private Boolean canWrite;
+    private ParameterDTO parameter;
+
+    @ApiModelProperty("The parameter information")
+    public ParameterDTO getParameter() {
+        return parameter;
+    }
+
+    public void setParameter(final ParameterDTO parameter) {
+        this.parameter = parameter;
+    }
+
+    @Override
+    @ApiModelProperty(value = "Indicates whether the user can write a given resource.", readOnly = true)
+    public Boolean getCanWrite() {
+        return canWrite;
+    }
+
+    @Override
+    public void setCanWrite(final Boolean canWrite) {
+        this.canWrite = canWrite;
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/main/java/org/apache/nifi/authorization/FileAccessPolicyProvider.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/main/java/org/apache/nifi/authorization/FileAccessPolicyProvider.java
index 3174e34c78a..d29a669a7e7 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/main/java/org/apache/nifi/authorization/FileAccessPolicyProvider.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/main/java/org/apache/nifi/authorization/FileAccessPolicyProvider.java
@@ -16,39 +16,6 @@
  */
 package org.apache.nifi.authorization;
 
-import java.io.ByteArrayInputStream;
-import java.io.File;
-import java.io.IOException;
-import java.io.StringWriter;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Date;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.atomic.AtomicReference;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import javax.xml.XMLConstants;
-import javax.xml.bind.JAXBContext;
-import javax.xml.bind.JAXBElement;
-import javax.xml.bind.JAXBException;
-import javax.xml.bind.Marshaller;
-import javax.xml.bind.Unmarshaller;
-import javax.xml.parsers.DocumentBuilder;
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.parsers.ParserConfigurationException;
-import javax.xml.stream.XMLOutputFactory;
-import javax.xml.stream.XMLStreamException;
-import javax.xml.stream.XMLStreamReader;
-import javax.xml.stream.XMLStreamWriter;
-import javax.xml.transform.stream.StreamSource;
-import javax.xml.validation.Schema;
-import javax.xml.validation.SchemaFactory;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.nifi.authorization.annotation.AuthorizerContext;
 import org.apache.nifi.authorization.exception.AuthorizationAccessException;
@@ -76,6 +43,40 @@
 import org.w3c.dom.NodeList;
 import org.xml.sax.SAXException;
 
+import javax.xml.XMLConstants;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.JAXBElement;
+import javax.xml.bind.JAXBException;
+import javax.xml.bind.Marshaller;
+import javax.xml.bind.Unmarshaller;
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.parsers.ParserConfigurationException;
+import javax.xml.stream.XMLOutputFactory;
+import javax.xml.stream.XMLStreamException;
+import javax.xml.stream.XMLStreamReader;
+import javax.xml.stream.XMLStreamWriter;
+import javax.xml.transform.stream.StreamSource;
+import javax.xml.validation.Schema;
+import javax.xml.validation.SchemaFactory;
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.io.StringWriter;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Date;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
 public class FileAccessPolicyProvider implements ConfigurableAccessPolicyProvider {
 
     private static final Logger logger = LoggerFactory.getLogger(FileAccessPolicyProvider.class);
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/main/java/org/apache/nifi/authorization/FileUserGroupProvider.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/main/java/org/apache/nifi/authorization/FileUserGroupProvider.java
index d2066a979db..5ff2d49dd82 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/main/java/org/apache/nifi/authorization/FileUserGroupProvider.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/main/java/org/apache/nifi/authorization/FileUserGroupProvider.java
@@ -93,7 +93,7 @@ private static JAXBContext initializeJaxbContext(final String contextPath) {
         try {
             return JAXBContext.newInstance(contextPath, FileAuthorizer.class.getClassLoader());
         } catch (JAXBException e) {
-            throw new RuntimeException("Unable to create JAXBContext.");
+            throw new RuntimeException("Unable to create JAXBContext.", e);
         }
     }
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/test/java/org/apache/nifi/authorization/FileAccessPolicyProviderTest.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/test/java/org/apache/nifi/authorization/FileAccessPolicyProviderTest.java
index 9d14af394f6..2f500512517 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/test/java/org/apache/nifi/authorization/FileAccessPolicyProviderTest.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/test/java/org/apache/nifi/authorization/FileAccessPolicyProviderTest.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.authorization;
 
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.authorization.exception.AuthorizerCreationException;
 import org.apache.nifi.authorization.resource.ResourceFactory;
@@ -186,11 +187,13 @@ public void setup() throws IOException {
 
         // this same configuration is being used for both the user group provider and the access policy provider
         configurationContext = mock(AuthorizerConfigurationContext.class);
-        when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_AUTHORIZATIONS_FILE))).thenReturn(new StandardPropertyValue(primaryAuthorizations.getPath(), null));
-        when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_TENANTS_FILE))).thenReturn(new StandardPropertyValue(primaryTenants.getPath(), null));
-        when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY))).thenReturn(new StandardPropertyValue(null, null));
-        when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE))).thenReturn(new StandardPropertyValue(null, null));
-        when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_USER_GROUP_PROVIDER))).thenReturn(new StandardPropertyValue("user-group-provider", null));
+        when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_AUTHORIZATIONS_FILE))).thenReturn(new StandardPropertyValue(primaryAuthorizations.getPath(), null,
+            ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_TENANTS_FILE))).thenReturn(new StandardPropertyValue(primaryTenants.getPath(), null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY))).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE))).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_USER_GROUP_PROVIDER))).thenReturn(new StandardPropertyValue("user-group-provider", null,
+            ParameterLookup.EMPTY));
         when(configurationContext.getProperties()).then((invocation) -> {
             final Map<String, String> properties = new HashMap<>();
 
@@ -275,7 +278,7 @@ public void cleanup() throws Exception {
     @Test
     public void testOnConfiguredWhenLegacyUsersFileProvidedWithOverlappingRoles() throws Exception {
         when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users-multirole.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users-multirole.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -298,7 +301,7 @@ public void testOnConfiguredWhenLegacyUsersFileProvidedAndFlowHasNoPorts() throw
         when(properties.getFlowConfigurationFile()).thenReturn(flowNoPorts);
 
         when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -320,7 +323,7 @@ public void testOnConfiguredWhenLegacyUsersFileProvidedAndFlowHasNoPorts() throw
     @Test
     public void testOnConfiguredWhenLegacyUsersFileProvided() throws Exception {
         when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -467,7 +470,7 @@ public void testOnConfiguredWhenLegacyUsersFileProvidedWithIdentityMappings() th
         accessPolicyProvider.setNiFiProperties(properties);
 
         when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users-with-dns.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users-with-dns.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -502,7 +505,7 @@ public void testOnConfiguredWhenLegacyUsersFileProvidedWithIdentityMappings() th
     @Test(expected = AuthorizerCreationException.class)
     public void testOnConfiguredWhenBadLegacyUsersFileProvided() throws Exception {
         when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/does-not-exist.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/does-not-exist.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -513,10 +516,10 @@ public void testOnConfiguredWhenBadLegacyUsersFileProvided() throws Exception {
     public void testOnConfiguredWhenInitialAdminAndLegacyUsersProvided() throws Exception {
         final String adminIdentity = "admin-user";
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
 
         when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -540,7 +543,7 @@ public void testOnConfiguredWhenInitialAdminProvided() throws Exception {
         final String adminIdentity = "admin-user";
 
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -580,7 +583,7 @@ public void testOnConfiguredWhenInitialAdminProvidedAndNoFlowExists() throws Exc
 
         final String adminIdentity = "admin-user";
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -620,7 +623,7 @@ public void testOnConfiguredWhenInitialAdminProvidedAndFlowIsNull() throws Excep
 
         final String adminIdentity = "admin-user";
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -663,7 +666,7 @@ public void testOnConfiguredWhenInitialAdminProvidedWithIdentityMapping() throws
 
         final String adminIdentity = "CN=localhost, OU=Apache NiFi, O=Apache, L=Santa Monica, ST=CA, C=US";
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -683,18 +686,18 @@ public void testOnConfiguredWhenNodeIdentitiesProvided() throws Exception {
         final String nodeIdentity2 = "node2";
 
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_NODE_IDENTITY_PREFIX + "1")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity1, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity1, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_NODE_IDENTITY_PREFIX + "2")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity2, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity2, null, ParameterLookup.EMPTY));
 
         when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_INITIAL_USER_IDENTITY_PREFIX + "1")))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_INITIAL_USER_IDENTITY_PREFIX + "2")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity1, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity1, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_INITIAL_USER_IDENTITY_PREFIX + "3")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity2, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity2, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -719,18 +722,18 @@ public void testOnConfiguredWhenNodeIdentitiesProvidedAndUsersAlreadyExist() thr
         final String nodeIdentity2 = "node2";
 
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_NODE_IDENTITY_PREFIX + "1")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity1, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity1, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_NODE_IDENTITY_PREFIX + "2")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity2, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity2, null, ParameterLookup.EMPTY));
 
         when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_INITIAL_USER_IDENTITY_PREFIX + "1")))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_INITIAL_USER_IDENTITY_PREFIX + "2")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity1, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity1, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_INITIAL_USER_IDENTITY_PREFIX + "3")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity2, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity2, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, TENANTS_FOR_ADMIN_AND_NODES);
@@ -757,9 +760,9 @@ public void testOnConfiguredWhenNodeGroupProvided() throws Exception {
         final String nodeIdentity2 = "node2";
 
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_NODE_GROUP_NAME)))
-                .thenReturn(new StandardPropertyValue(nodeGroupName, null));
+                .thenReturn(new StandardPropertyValue(nodeGroupName, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, TENANTS_FOR_ADMIN_AND_NODE_GROUP);
@@ -782,9 +785,9 @@ public void testOnConfiguredWhenNodeGroupEmpty() throws Exception {
         final String nodeGroupIdentifier = "cluster-nodes";
 
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-            .thenReturn(new StandardPropertyValue(adminIdentity, null));
+            .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_NODE_GROUP_NAME)))
-            .thenReturn(new StandardPropertyValue("", null));
+            .thenReturn(new StandardPropertyValue("", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, TENANTS_FOR_ADMIN_AND_NODE_GROUP);
@@ -800,9 +803,9 @@ public void testOnConfiguredWhenNodeGroupDoesNotExist() throws Exception {
         final String adminIdentity = "admin-user";
 
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-            .thenReturn(new StandardPropertyValue(adminIdentity, null));
+            .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(eq(FileAccessPolicyProvider.PROP_NODE_GROUP_NAME)))
-            .thenReturn(new StandardPropertyValue("nonexistent", null));
+            .thenReturn(new StandardPropertyValue("nonexistent", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, TENANTS_FOR_ADMIN_AND_NODE_GROUP);
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/test/java/org/apache/nifi/authorization/FileAuthorizerTest.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/test/java/org/apache/nifi/authorization/FileAuthorizerTest.java
index a1d477c1a87..e83e97ae2f6 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/test/java/org/apache/nifi/authorization/FileAuthorizerTest.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/test/java/org/apache/nifi/authorization/FileAuthorizerTest.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.authorization;
 
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.authorization.AuthorizationResult.Result;
 import org.apache.nifi.authorization.exception.AuthorizerCreationException;
@@ -189,8 +190,9 @@ public void setup() throws IOException {
         when(properties.getFlowConfigurationFile()).thenReturn(flow);
 
         configurationContext = mock(AuthorizerConfigurationContext.class);
-        when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_AUTHORIZATIONS_FILE))).thenReturn(new StandardPropertyValue(primaryAuthorizations.getPath(), null));
-        when(configurationContext.getProperty(Mockito.eq(FileUserGroupProvider.PROP_TENANTS_FILE))).thenReturn(new StandardPropertyValue(primaryTenants.getPath(), null));
+        when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_AUTHORIZATIONS_FILE))).thenReturn(new StandardPropertyValue(primaryAuthorizations.getPath(), null,
+            ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(Mockito.eq(FileUserGroupProvider.PROP_TENANTS_FILE))).thenReturn(new StandardPropertyValue(primaryTenants.getPath(), null, ParameterLookup.EMPTY));
         when(configurationContext.getProperties()).then((invocation) -> {
             final Map<String, String> properties = new HashMap<>();
 
@@ -244,7 +246,7 @@ public void cleanup() throws Exception {
     @Test
     public void testOnConfiguredWhenLegacyUsersFileProvidedWithOverlappingRoles() throws Exception {
         when(configurationContext.getProperty(Mockito.eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users-multirole.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users-multirole.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -269,7 +271,7 @@ public void testOnConfiguredWhenLegacyUsersFileProvidedAndFlowHasNoPorts() throw
         when(properties.getFlowConfigurationFile()).thenReturn(flowNoPorts);
 
         when(configurationContext.getProperty(Mockito.eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -289,7 +291,7 @@ public void testOnConfiguredWhenLegacyUsersFileProvidedAndFlowHasNoPorts() throw
     @Test
     public void testOnConfiguredWhenLegacyUsersFileProvided() throws Exception {
         when(configurationContext.getProperty(Mockito.eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -453,7 +455,7 @@ public void testOnConfiguredWhenLegacyUsersFileProvidedWithIdentityMappings() th
         authorizer.setNiFiProperties(properties);
 
         when(configurationContext.getProperty(Mockito.eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users-with-dns.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users-with-dns.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -503,7 +505,7 @@ public void testOnConfiguredWhenLegacyUsersFileProvidedWithIdentityMappings() th
     @Test(expected = AuthorizerCreationException.class)
     public void testOnConfiguredWhenBadLegacyUsersFileProvided() throws Exception {
         when(configurationContext.getProperty(Mockito.eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/does-not-exist.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/does-not-exist.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -514,10 +516,10 @@ public void testOnConfiguredWhenBadLegacyUsersFileProvided() throws Exception {
     public void testOnConfiguredWhenInitialAdminAndLegacyUsersProvided() throws Exception {
         final String adminIdentity = "admin-user";
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
 
         when(configurationContext.getProperty(Mockito.eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -542,7 +544,7 @@ public void testOnConfiguredWhenInitialAdminProvided() throws Exception {
         final String adminIdentity = "admin-user";
 
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -580,7 +582,7 @@ public void testOnConfiguredWhenInitialAdminProvidedAndNoFlowExists() throws Exc
 
         final String adminIdentity = "admin-user";
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -618,7 +620,7 @@ public void testOnConfiguredWhenInitialAdminProvidedAndFlowIsNull() throws Excep
 
         final String adminIdentity = "admin-user";
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -659,7 +661,7 @@ public void testOnConfiguredWhenInitialAdminProvidedWithIdentityMapping() throws
 
         final String adminIdentity = "CN=localhost, OU=Apache NiFi, O=Apache, L=Santa Monica, ST=CA, C=US";
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -679,11 +681,11 @@ public void testOnConfiguredWhenNodeIdentitiesProvided() throws Exception {
         final String nodeIdentity2 = "node2";
 
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_NODE_IDENTITY_PREFIX + "1")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity1, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity1, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_NODE_IDENTITY_PREFIX + "2")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity2, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity2, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
@@ -712,11 +714,11 @@ public void testOnConfiguredWhenNodeIdentitiesProvidedAndUsersAlreadyExist() thr
         final String nodeIdentity2 = "node2";
 
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_NODE_IDENTITY_PREFIX + "1")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity1, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity1, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_NODE_IDENTITY_PREFIX + "2")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity2, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity2, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, TENANTS_FOR_ADMIN_AND_NODES);
@@ -756,11 +758,11 @@ public void testOnConfiguredWhenNodeIdentitiesProvidedWithIdentityMappings() thr
         final String nodeIdentity2 = "CN=node2, OU=Apache NiFi, O=Apache, L=Santa Monica, ST=CA, C=US";
 
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_INITIAL_ADMIN_IDENTITY)))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_NODE_IDENTITY_PREFIX + "1")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity1, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity1, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(Mockito.eq(FileAccessPolicyProvider.PROP_NODE_IDENTITY_PREFIX + "2")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity2, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity2, null, ParameterLookup.EMPTY));
 
         writeFile(primaryAuthorizations, EMPTY_AUTHORIZATIONS_CONCISE);
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/test/java/org/apache/nifi/authorization/FileUserGroupProviderTest.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/test/java/org/apache/nifi/authorization/FileUserGroupProviderTest.java
index 8be051ef606..71d376d68d0 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/test/java/org/apache/nifi/authorization/FileUserGroupProviderTest.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-file-authorizer/src/test/java/org/apache/nifi/authorization/FileUserGroupProviderTest.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.authorization;
 
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.authorization.exception.AuthorizerCreationException;
 import org.apache.nifi.components.PropertyValue;
@@ -109,8 +110,8 @@ public void setup() throws IOException {
         when(properties.getRestoreDirectory()).thenReturn(restoreTenants.getParentFile());
 
         configurationContext = mock(AuthorizerConfigurationContext.class);
-        when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE))).thenReturn(new StandardPropertyValue(null, null));
-        when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_TENANTS_FILE))).thenReturn(new StandardPropertyValue(primaryTenants.getPath(), null));
+        when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE))).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_TENANTS_FILE))).thenReturn(new StandardPropertyValue(primaryTenants.getPath(), null, ParameterLookup.EMPTY));
         when(configurationContext.getProperties()).then((invocation) -> {
             final Map<String, String> properties = new HashMap<>();
 
@@ -152,7 +153,7 @@ public void cleanup() throws Exception {
     @Test
     public void testOnConfiguredWhenLegacyUsersFileProvided() throws Exception {
         when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
         userGroupProvider.onConfigured(configurationContext);
@@ -197,7 +198,7 @@ public void testOnConfiguredWhenLegacyUsersFileProvidedWithIdentityMappings() th
         userGroupProvider.setNiFiProperties(properties);
 
         when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users-with-dns.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users-with-dns.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
         userGroupProvider.onConfigured(configurationContext);
@@ -243,7 +244,7 @@ public void testOnConfiguredWhenLegacyUsersFileProvidedWithIdentityMappingsAndTr
         userGroupProvider.setNiFiProperties(properties);
 
         when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users-with-dns.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/authorized-users-with-dns.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
         userGroupProvider.onConfigured(configurationContext);
@@ -276,7 +277,7 @@ public void testOnConfiguredWhenLegacyUsersFileProvidedWithIdentityMappingsAndTr
     @Test(expected = AuthorizerCreationException.class)
     public void testOnConfiguredWhenBadLegacyUsersFileProvided() throws Exception {
         when(configurationContext.getProperty(eq(FileAuthorizer.PROP_LEGACY_AUTHORIZED_USERS_FILE)))
-                .thenReturn(new StandardPropertyValue("src/test/resources/does-not-exist.xml", null));
+                .thenReturn(new StandardPropertyValue("src/test/resources/does-not-exist.xml", null, ParameterLookup.EMPTY));
 
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
         userGroupProvider.onConfigured(configurationContext);
@@ -298,11 +299,11 @@ public void testOnConfiguredWhenInitialUsersProvided() throws Exception {
         final String nodeIdentity2 = "node-identity-2";
 
         when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_INITIAL_USER_IDENTITY_PREFIX + "1")))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_INITIAL_USER_IDENTITY_PREFIX + "2")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity1, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity1, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_INITIAL_USER_IDENTITY_PREFIX + "3")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity2, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity2, null, ParameterLookup.EMPTY));
 
         writeFile(primaryTenants, EMPTY_TENANTS_CONCISE);
         userGroupProvider.onConfigured(configurationContext);
@@ -323,11 +324,11 @@ public void testOnConfiguredWhenTenantsExistAndInitialUsersProvided() throws Exc
 
         // despite setting initial users, they will not be loaded as the tenants file is non-empty
         when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_INITIAL_USER_IDENTITY_PREFIX + "1")))
-                .thenReturn(new StandardPropertyValue(adminIdentity, null));
+                .thenReturn(new StandardPropertyValue(adminIdentity, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_INITIAL_USER_IDENTITY_PREFIX + "2")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity1, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity1, null, ParameterLookup.EMPTY));
         when(configurationContext.getProperty(eq(FileUserGroupProvider.PROP_INITIAL_USER_IDENTITY_PREFIX + "3")))
-                .thenReturn(new StandardPropertyValue(nodeIdentity2, null));
+                .thenReturn(new StandardPropertyValue(nodeIdentity2, null, ParameterLookup.EMPTY));
 
         writeFile(primaryTenants, SIMPLE_TENANTS_BY_USER);
         userGroupProvider.onConfigured(configurationContext);
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/main/java/org/apache/nifi/authorization/StandardAuthorizerConfigurationContext.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/main/java/org/apache/nifi/authorization/StandardAuthorizerConfigurationContext.java
index 3010c921df8..a1a25118a40 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/main/java/org/apache/nifi/authorization/StandardAuthorizerConfigurationContext.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/main/java/org/apache/nifi/authorization/StandardAuthorizerConfigurationContext.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.authorization;
 
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.components.PropertyValue;
 
@@ -48,7 +49,7 @@ public Map<String, String> getProperties() {
 
     @Override
     public PropertyValue getProperty(String property) {
-        return new StandardPropertyValue(properties.get(property), null);
+        return new StandardPropertyValue(properties.get(property), null, ParameterLookup.EMPTY);
     }
 
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/main/java/org/apache/nifi/authorization/resource/ResourceFactory.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/main/java/org/apache/nifi/authorization/resource/ResourceFactory.java
index 9d3b532d8dc..386f90a30c1 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/main/java/org/apache/nifi/authorization/resource/ResourceFactory.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/main/java/org/apache/nifi/authorization/resource/ResourceFactory.java
@@ -262,6 +262,25 @@ public String getSafeDescription() {
         }
     };
 
+    private final static Resource PARAMETER_CONTEXTS_RESOURCE = new Resource() {
+
+        @Override
+        public String getIdentifier() {
+            return ResourceType.ParameterContext.getValue();
+        }
+
+        @Override
+        public String getName() {
+            return "Parameter Contexts";
+        }
+
+        @Override
+        public String getSafeDescription() {
+            return "parameter contexts";
+        }
+    };
+
+
     /**
      * Gets the Resource for accessing the Controller. This includes Controller level configuration, bulletins, reporting tasks, and the cluster.
      *
@@ -289,6 +308,14 @@ public static Resource getCountersResource() {
         return COUNTERS_RESOURCE;
     }
 
+    /**
+     * Gets the Resource for accessing the Parameter Contexts.
+     * @return The resource for access Parameter Contexts
+     */
+    public static Resource getParameterContextsResource() {
+        return PARAMETER_CONTEXTS_RESOURCE;
+    }
+
     /**
      * Gets the Resource for accessing provenance. Access to this Resource allows the user to access data provenance. However, additional authorization
      * is required based on the component that generated the event and the attributes of the event.
@@ -525,6 +552,9 @@ public String getSafeDescription() {
                     case Label:
                         componentType = "Label";
                         break;
+                    case ParameterContext:
+                        componentType = "Parameter Context";
+                        break;
                     default:
                         componentType = "Component";
                         break;
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/main/java/org/apache/nifi/authorization/resource/ResourceType.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/main/java/org/apache/nifi/authorization/resource/ResourceType.java
index a24b904ee42..45582fceeaf 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/main/java/org/apache/nifi/authorization/resource/ResourceType.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/main/java/org/apache/nifi/authorization/resource/ResourceType.java
@@ -41,7 +41,8 @@ public enum ResourceType {
     RestrictedComponents("/restricted-components"),
     Operation("/operation"),
     Template("/templates"),
-    Tenant("/tenants");
+    Tenant("/tenants"),
+    ParameterContext("/parameter-contexts");
 
     final String value;
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/CompositeConfigurableUserGroupProviderTest.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/CompositeConfigurableUserGroupProviderTest.java
index bb4f988f733..aa96bee3fdb 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/CompositeConfigurableUserGroupProviderTest.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/CompositeConfigurableUserGroupProviderTest.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.authorization;
 
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.authorization.exception.AuthorizerCreationException;
 import org.junit.Test;
@@ -47,14 +48,14 @@ public class CompositeConfigurableUserGroupProviderTest extends CompositeUserGro
     @Test(expected = AuthorizerCreationException.class)
     public void testNoConfigurableUserGroupProviderSpecified() throws Exception {
         initCompositeUserGroupProvider(new CompositeConfigurableUserGroupProvider(), null, configurationContext -> {
-            when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue(null, null));
+            when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
         });
     }
 
     @Test(expected = AuthorizerCreationException.class)
     public void testUnknownConfigurableUserGroupProvider() throws Exception {
         initCompositeUserGroupProvider(new CompositeConfigurableUserGroupProvider(), null, configurationContext -> {
-            when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue("unknown-user-group-provider", null));
+            when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue("unknown-user-group-provider", null, ParameterLookup.EMPTY));
         });
     }
 
@@ -63,7 +64,7 @@ public void testNonConfigurableUserGroupProvider() throws Exception {
         initCompositeUserGroupProvider(new CompositeConfigurableUserGroupProvider(), lookup -> {
             when(lookup.getUserGroupProvider(eq(NOT_CONFIGURABLE_USER_GROUP_PROVIDER))).thenReturn(mock(UserGroupProvider.class));
         }, configurationContext -> {
-            when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue(NOT_CONFIGURABLE_USER_GROUP_PROVIDER, null));
+            when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue(NOT_CONFIGURABLE_USER_GROUP_PROVIDER, null, ParameterLookup.EMPTY));
         });
     }
 
@@ -81,7 +82,7 @@ public void testDuplicateProviders() throws Exception {
 
         // Mock AuthorizerConfigurationContext to introduce the duplicate provider ids
         final AuthorizerConfigurationContext configurationContext = mock(AuthorizerConfigurationContext.class);
-        when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue(CONFIGURABLE_USER_GROUP_PROVIDER, null));
+        when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue(CONFIGURABLE_USER_GROUP_PROVIDER, null, ParameterLookup.EMPTY));
         Map<String, String> configurationContextProperties = new HashMap<>();
         configurationContextProperties.put(PROP_USER_GROUP_PROVIDER_PREFIX + "1", CONFIGURABLE_USER_GROUP_PROVIDER);
         configurationContextProperties.put(PROP_USER_GROUP_PROVIDER_PREFIX + "2", NOT_CONFIGURABLE_USER_GROUP_PROVIDER);
@@ -98,7 +99,7 @@ public void testConfigurableUserGroupProviderOnly() throws Exception {
         final UserGroupProvider userGroupProvider = initCompositeUserGroupProvider(new CompositeConfigurableUserGroupProvider(), lookup -> {
             when(lookup.getUserGroupProvider(eq(CONFIGURABLE_USER_GROUP_PROVIDER))).thenReturn(getConfigurableUserGroupProvider());
         }, configurationContext -> {
-            when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue(CONFIGURABLE_USER_GROUP_PROVIDER, null));
+            when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue(CONFIGURABLE_USER_GROUP_PROVIDER, null, ParameterLookup.EMPTY));
         });
 
         // users and groups
@@ -123,7 +124,7 @@ public void testConfigurableUserGroupProviderWithConflictingUserGroupProvider()
         final UserGroupProvider userGroupProvider = initCompositeUserGroupProvider(new CompositeConfigurableUserGroupProvider(), lookup -> {
             when(lookup.getUserGroupProvider(eq(CONFIGURABLE_USER_GROUP_PROVIDER))).thenReturn(getConfigurableUserGroupProvider());
         }, configurationContext -> {
-            when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue(CONFIGURABLE_USER_GROUP_PROVIDER, null));
+            when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue(CONFIGURABLE_USER_GROUP_PROVIDER, null, ParameterLookup.EMPTY));
         }, getConflictingUserGroupProvider());
 
         // users and groups
@@ -162,7 +163,7 @@ public void testConfigurableUserGroupProviderWithCollaboratingUserGroupProvider(
         final UserGroupProvider userGroupProvider = initCompositeUserGroupProvider(new CompositeConfigurableUserGroupProvider(), lookup -> {
             when(lookup.getUserGroupProvider(eq(CONFIGURABLE_USER_GROUP_PROVIDER))).thenReturn(getConfigurableUserGroupProvider());
         }, configurationContext -> {
-            when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue(CONFIGURABLE_USER_GROUP_PROVIDER, null));
+            when(configurationContext.getProperty(PROP_CONFIGURABLE_USER_GROUP_PROVIDER)).thenReturn(new StandardPropertyValue(CONFIGURABLE_USER_GROUP_PROVIDER, null, ParameterLookup.EMPTY));
         }, getCollaboratingUserGroupProvider());
 
         // users and groups
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/CompositeUserGroupProviderTest.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/CompositeUserGroupProviderTest.java
index 032590d9208..674808f1734 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/CompositeUserGroupProviderTest.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/CompositeUserGroupProviderTest.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.authorization;
 
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.authorization.exception.AuthorizerCreationException;
 import org.junit.Test;
@@ -54,7 +55,7 @@ public UserGroupProvider getUserGroupProvider(String identifier) {
 
         // configuration
         final AuthorizerConfigurationContext configurationContext = mock(AuthorizerConfigurationContext.class);
-        when(configurationContext.getProperty(eq(PROP_USER_GROUP_PROVIDER_PREFIX + "1"))).thenReturn(new StandardPropertyValue(String.valueOf("1"), null));
+        when(configurationContext.getProperty(eq(PROP_USER_GROUP_PROVIDER_PREFIX + "1"))).thenReturn(new StandardPropertyValue(String.valueOf("1"), null, ParameterLookup.EMPTY));
         mockProperties(configurationContext);
 
         final CompositeUserGroupProvider compositeUserGroupProvider = new CompositeUserGroupProvider();
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/CompositeUserGroupProviderTestBase.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/CompositeUserGroupProviderTestBase.java
index a3f3bb2df09..c11e5e92e1d 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/CompositeUserGroupProviderTestBase.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/CompositeUserGroupProviderTestBase.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.authorization;
 
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.components.PropertyValue;
 
@@ -220,7 +221,7 @@ protected UserGroupProvider initCompositeUserGroupProvider(
         final AuthorizerConfigurationContext configurationContext = mock(AuthorizerConfigurationContext.class);
 
         for (int i = 1; i <= providers.length; i++) {
-            when(configurationContext.getProperty(eq(PROP_USER_GROUP_PROVIDER_PREFIX + i))).thenReturn(new StandardPropertyValue(String.valueOf(i), null));
+            when(configurationContext.getProperty(eq(PROP_USER_GROUP_PROVIDER_PREFIX + i))).thenReturn(new StandardPropertyValue(String.valueOf(i), null, ParameterLookup.EMPTY));
         }
 
         // allow callers to mock additional properties
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/StandardManagedAuthorizerTest.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/StandardManagedAuthorizerTest.java
index 7dd9d9777ec..36c3724a770 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/StandardManagedAuthorizerTest.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-authorization/src/test/java/org/apache/nifi/authorization/StandardManagedAuthorizerTest.java
@@ -16,7 +16,7 @@
  */
 package org.apache.nifi.authorization;
 
-
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.authorization.exception.AuthorizationAccessException;
 import org.apache.nifi.authorization.exception.AuthorizerCreationException;
@@ -422,7 +422,7 @@ private StandardManagedAuthorizer getStandardManagedAuthorizer(final AccessPolic
         final StandardManagedAuthorizer managedAuthorizer = new StandardManagedAuthorizer();
 
         final AuthorizerConfigurationContext configurationContext = mock(AuthorizerConfigurationContext.class);
-        when(configurationContext.getProperty("Access Policy Provider")).thenReturn(new StandardPropertyValue("access-policy-provider", null));
+        when(configurationContext.getProperty("Access Policy Provider")).thenReturn(new StandardPropertyValue("access-policy-provider", null, ParameterLookup.EMPTY));
 
         final AccessPolicyProviderLookup accessPolicyProviderLookup = mock(AccessPolicyProviderLookup.class);
         when(accessPolicyProviderLookup.getAccessPolicyProvider("access-policy-provider")).thenReturn(accessPolicyProvider);
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/StandardHttpResponseMapper.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/StandardHttpResponseMapper.java
index 0cd550b913c..78cd8033f52 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/StandardHttpResponseMapper.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/StandardHttpResponseMapper.java
@@ -44,6 +44,10 @@
 import org.apache.nifi.cluster.coordination.http.endpoints.LabelsEndpointMerger;
 import org.apache.nifi.cluster.coordination.http.endpoints.ListFlowFilesEndpointMerger;
 import org.apache.nifi.cluster.coordination.http.endpoints.OutputPortsEndpointMerger;
+import org.apache.nifi.cluster.coordination.http.endpoints.ParameterContextEndpointMerger;
+import org.apache.nifi.cluster.coordination.http.endpoints.ParameterContextUpdateEndpointMerger;
+import org.apache.nifi.cluster.coordination.http.endpoints.ParameterContextValidationMerger;
+import org.apache.nifi.cluster.coordination.http.endpoints.ParameterContextsEndpointMerger;
 import org.apache.nifi.cluster.coordination.http.endpoints.PortEndpointMerger;
 import org.apache.nifi.cluster.coordination.http.endpoints.PortStatusEndpointMerger;
 import org.apache.nifi.cluster.coordination.http.endpoints.PrioritizerTypesEndpointMerger;
@@ -157,6 +161,10 @@ public StandardHttpResponseMapper(final NiFiProperties nifiProperties) {
         endpointMergers.add(new SearchUsersEndpointMerger());
         endpointMergers.add(new VariableRegistryEndpointMerger());
         endpointMergers.add(new ProcessorDiagnosticsEndpointMerger(snapshotMillis));
+        endpointMergers.add(new ParameterContextValidationMerger());
+        endpointMergers.add(new ParameterContextsEndpointMerger());
+        endpointMergers.add(new ParameterContextEndpointMerger());
+        endpointMergers.add(new ParameterContextUpdateEndpointMerger());
     }
 
     @Override
@@ -178,7 +186,7 @@ public NodeResponse mapResponses(final URI uri, final String httpMethod, final S
         }
 
         // Determine which responses are successful
-        final Set<NodeResponse> successResponses = nodeResponses.stream().filter(p -> p.is2xx()).collect(Collectors.toSet());
+        final Set<NodeResponse> successResponses = nodeResponses.stream().filter(NodeResponse::is2xx).collect(Collectors.toSet());
         final Set<NodeResponse> problematicResponses = nodeResponses.stream().filter(p -> !p.is2xx()).collect(Collectors.toSet());
 
         final NodeResponse clientResponse;
@@ -192,7 +200,7 @@ public NodeResponse mapResponses(final URI uri, final String httpMethod, final S
             clientResponse = successResponses.iterator().next();
         }
 
-        if (merge == false) {
+        if (!merge) {
             return clientResponse;
         }
 
@@ -215,7 +223,7 @@ public Set<NodeResponse> getProblematicNodeResponses(final Set<NodeResponse> all
             return allResponses.stream().filter(p -> !p.is2xx()).collect(Collectors.toSet());
         } else {
             // If no node is successful, we consider a problematic response to be only those that are 5xx
-            return allResponses.stream().filter(p -> p.is5xx()).collect(Collectors.toSet());
+            return allResponses.stream().filter(NodeResponse::is5xx).collect(Collectors.toSet());
         }
     }
 
@@ -229,7 +237,7 @@ private EndpointResponseMerger getEndpointResponseMerger(final URI uri, final St
     }
 
     private boolean hasSuccessfulResponse(final Set<NodeResponse> allResponses) {
-        return allResponses.stream().anyMatch(p -> p.is2xx());
+        return allResponses.stream().anyMatch(NodeResponse::is2xx);
     }
 
     private void drainResponses(final Set<NodeResponse> responses, final NodeResponse exclude) {
@@ -237,7 +245,7 @@ private void drainResponses(final Set<NodeResponse> responses, final NodeRespons
                 .parallel() // "parallelize" the draining of the responses, since we have multiple streams to consume
                 .filter(response -> response != exclude) // don't include the explicitly excluded node
                 .filter(response -> response.getStatus() != RequestReplicator.NODE_CONTINUE_STATUS_CODE) // don't include any continue responses because they contain no content
-                .forEach(response -> drainResponse(response)); // drain all node responses that didn't get filtered out
+                .forEach(this::drainResponse); // drain all node responses that didn't get filtered out
     }
 
     private void drainResponse(final NodeResponse response) {
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextEndpointMerger.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextEndpointMerger.java
new file mode 100644
index 00000000000..47199658128
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextEndpointMerger.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.cluster.coordination.http.endpoints;
+
+import org.apache.nifi.cluster.coordination.http.EndpointResponseMerger;
+import org.apache.nifi.cluster.manager.NodeResponse;
+import org.apache.nifi.cluster.protocol.NodeIdentifier;
+import org.apache.nifi.web.api.entity.ParameterContextEntity;
+
+import java.net.URI;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+public class ParameterContextEndpointMerger extends AbstractSingleEntityEndpoint<ParameterContextEntity> implements EndpointResponseMerger {
+    private static final Pattern PARAMETER_CONTEXT_URI = Pattern.compile("/nifi-api/parameter-contexts/[a-f0-9\\-]{36}");
+
+    @Override
+    public boolean canHandle(final URI uri, final String method) {
+        return ("GET".equalsIgnoreCase(method) || "DELETE".equalsIgnoreCase(method)) && PARAMETER_CONTEXT_URI.matcher(uri.getPath()).matches();
+    }
+
+    @Override
+    protected Class<ParameterContextEntity> getEntityClass() {
+        return ParameterContextEntity.class;
+    }
+
+    @Override
+    protected void mergeResponses(final ParameterContextEntity clientEntity, final Map<NodeIdentifier, ParameterContextEntity> entityMap, final Set<NodeResponse> successfulResponses,
+                                  final Set<NodeResponse> problematicResponses) {
+
+        ParameterContextMerger.merge(clientEntity, entityMap);
+
+    }
+
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextMerger.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextMerger.java
new file mode 100644
index 00000000000..7278b542893
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextMerger.java
@@ -0,0 +1,155 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.cluster.coordination.http.endpoints;
+
+import org.apache.nifi.cluster.manager.PermissionsDtoMerger;
+import org.apache.nifi.cluster.manager.StatusMerger;
+import org.apache.nifi.cluster.protocol.NodeIdentifier;
+import org.apache.nifi.web.api.dto.AffectedComponentDTO;
+import org.apache.nifi.web.api.dto.ParameterContextDTO;
+import org.apache.nifi.web.api.dto.ParameterDTO;
+import org.apache.nifi.web.api.entity.AffectedComponentEntity;
+import org.apache.nifi.web.api.entity.ParameterContextEntity;
+import org.apache.nifi.web.api.entity.ParameterEntity;
+import org.apache.nifi.web.api.entity.ProcessGroupEntity;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+public class ParameterContextMerger {
+
+    public static void merge(final ParameterContextEntity target, final Map<NodeIdentifier, ParameterContextEntity> entityMap) {
+        final Map<NodeIdentifier, ParameterContextDTO> dtoMap = new HashMap<>();
+
+        for (final Map.Entry<NodeIdentifier, ParameterContextEntity> entry : entityMap.entrySet()) {
+            final NodeIdentifier nodeId = entry.getKey();
+            final ParameterContextEntity entity = entry.getValue();
+
+            PermissionsDtoMerger.mergePermissions(entity.getPermissions(), entity.getPermissions());
+
+            if (entity.getComponent() == null) {
+                target.setComponent(null);
+                continue;
+            }
+
+            dtoMap.put(nodeId, entity.getComponent());
+        }
+
+        if (target.getComponent() != null) {
+            merge(target.getComponent(), dtoMap);
+        }
+    }
+
+    public static void merge(final ParameterContextDTO target, final Map<NodeIdentifier, ParameterContextDTO> entityMap) {
+        final Map<String, ProcessGroupEntity> mergedBoundGroups = new HashMap<>();
+        final Map<String, Map<String, AffectedComponentEntity>> affectedComponentsByParameterName = new HashMap<>();
+
+        final Set<String> unwritableParameters = new HashSet<>();
+        for (final Map.Entry<NodeIdentifier, ParameterContextDTO> entry : entityMap.entrySet()) {
+            final NodeIdentifier nodeId = entry.getKey();
+            final ParameterContextDTO contextDto = entry.getValue();
+            if (contextDto == null) {
+                continue;
+            }
+
+            Set<ProcessGroupEntity> boundGroupEntities = contextDto.getBoundProcessGroups();
+            if (boundGroupEntities != null) {
+                for (final ProcessGroupEntity groupEntity : boundGroupEntities) {
+                    ProcessGroupEntity merged = mergedBoundGroups.get(groupEntity.getId());
+                    if (merged == null) {
+                        mergedBoundGroups.put(groupEntity.getId(), groupEntity);
+                        continue;
+                    }
+
+                    merge(merged, nodeId, groupEntity);
+                }
+            }
+
+            if (contextDto.getParameters() != null) {
+                for (final ParameterEntity parameterEntity : contextDto.getParameters()) {
+                    final ParameterDTO parameterDto = parameterEntity.getParameter();
+
+                    if (!parameterEntity.getCanWrite()) {
+                        unwritableParameters.add(parameterDto.getName());
+                    }
+
+                    final Map<String, AffectedComponentEntity> affectedComponentsById = affectedComponentsByParameterName.computeIfAbsent(parameterDto.getName(), key -> new HashMap<>());
+
+                    for (final AffectedComponentEntity referencingComponent : parameterDto.getReferencingComponents()) {
+                        AffectedComponentEntity mergedAffectedComponent = affectedComponentsById.get(referencingComponent.getId());
+                        if (mergedAffectedComponent == null) {
+                            affectedComponentsById.put(referencingComponent.getId(), referencingComponent);
+                            continue;
+                        }
+
+                        merge(mergedAffectedComponent, referencingComponent);
+                    }
+                }
+            }
+        }
+
+        target.setBoundProcessGroups(new HashSet<>(mergedBoundGroups.values()));
+
+        // Set the merged parameter dto's
+        for (final ParameterEntity parameterEntity : target.getParameters()) {
+            final ParameterDTO parameterDto = parameterEntity.getParameter();
+            final boolean unwritable = unwritableParameters.contains(parameterDto.getName());
+            if (unwritable) {
+                parameterEntity.setCanWrite(false);
+            }
+
+            final Map<String, AffectedComponentEntity> componentMap = affectedComponentsByParameterName.get(parameterDto.getName());
+            parameterDto.setReferencingComponents(new HashSet<>(componentMap.values()));
+        }
+    }
+
+
+    private static void merge(final ProcessGroupEntity merged, final NodeIdentifier additionalNodeId, final ProcessGroupEntity additional) {
+        PermissionsDtoMerger.mergePermissions(merged.getPermissions(), additional.getPermissions());
+
+        if (!Boolean.TRUE.equals(merged.getPermissions().getCanRead()) || additional.getComponent() == null) {
+            merged.setComponent(null);
+        }
+
+        StatusMerger.merge(merged.getStatus(), merged.getPermissions().getCanRead(), additional.getStatus(), additional.getPermissions().getCanRead(), additionalNodeId.getId(),
+            additionalNodeId.getApiAddress(), additionalNodeId.getApiPort());
+    }
+
+    static void merge(final AffectedComponentEntity merged, final AffectedComponentEntity additional) {
+        PermissionsDtoMerger.mergePermissions(merged.getPermissions(), additional.getPermissions());
+
+        if (!Boolean.TRUE.equals(merged.getPermissions().getCanRead()) || additional.getComponent() == null) {
+            merged.setComponent(null);
+            return;
+        }
+
+        final AffectedComponentDTO mergedComponent = merged.getComponent();
+        final AffectedComponentDTO additionalComponent = additional.getComponent();
+        mergedComponent.setActiveThreadCount(mergedComponent.getActiveThreadCount() + additionalComponent.getActiveThreadCount());
+
+        if (mergedComponent.getValidationErrors() == null) {
+            mergedComponent.setValidationErrors(new ArrayList<>());
+        }
+
+        if (additionalComponent.getValidationErrors() != null) {
+            mergedComponent.getValidationErrors().addAll(additionalComponent.getValidationErrors());
+        }
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextUpdateEndpointMerger.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextUpdateEndpointMerger.java
new file mode 100644
index 00000000000..3ea4aac58aa
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextUpdateEndpointMerger.java
@@ -0,0 +1,87 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.cluster.coordination.http.endpoints;
+
+import org.apache.nifi.cluster.coordination.http.EndpointResponseMerger;
+import org.apache.nifi.cluster.manager.NodeResponse;
+import org.apache.nifi.cluster.protocol.NodeIdentifier;
+import org.apache.nifi.web.api.dto.ParameterContextDTO;
+import org.apache.nifi.web.api.dto.ParameterContextUpdateRequestDTO;
+import org.apache.nifi.web.api.entity.AffectedComponentEntity;
+import org.apache.nifi.web.api.entity.ParameterContextUpdateRequestEntity;
+
+import java.net.URI;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+public class ParameterContextUpdateEndpointMerger extends AbstractSingleEntityEndpoint<ParameterContextUpdateRequestEntity> implements EndpointResponseMerger {
+    private static final Pattern PARAMETER_CONTEXT_URI = Pattern.compile("/nifi-api/parameter-contexts/[a-f0-9\\-]{36}");
+    private static final String PARAMETER_CONTEXTS_URI = "/nifi-api/parameter-contexts";
+
+    @Override
+    public boolean canHandle(final URI uri, final String method) {
+        return ("GET".equalsIgnoreCase(method) || "DELETE".equalsIgnoreCase(method)) && PARAMETER_CONTEXT_URI.matcher(uri.getPath()).matches()
+            || "POST".equalsIgnoreCase(method) && PARAMETER_CONTEXTS_URI.equals(method);
+    }
+
+    @Override
+    protected Class<ParameterContextUpdateRequestEntity> getEntityClass() {
+        return ParameterContextUpdateRequestEntity.class;
+    }
+
+    @Override
+    protected void mergeResponses(final ParameterContextUpdateRequestEntity clientEntity, final Map<NodeIdentifier, ParameterContextUpdateRequestEntity> entityMap,
+                                  final Set<NodeResponse> successfulResponses, final Set<NodeResponse> problematicResponses) {
+
+        final ParameterContextUpdateRequestDTO clientUpdateRequestDto = clientEntity.getRequest();
+
+        final Map<String, AffectedComponentEntity> affectedComponentEntities = new HashMap<>();
+        for (final ParameterContextUpdateRequestEntity requestEntity : entityMap.values()) {
+            final ParameterContextUpdateRequestDTO updateRequestDto = requestEntity.getRequest();
+            clientUpdateRequestDto.setComplete(clientUpdateRequestDto.isComplete() && updateRequestDto.isComplete());
+
+            if (updateRequestDto.getFailureReason() != null) {
+                clientUpdateRequestDto.setFailureReason(updateRequestDto.getFailureReason());
+            }
+
+            clientUpdateRequestDto.setLastUpdated(new Date(Math.min(clientUpdateRequestDto.getLastUpdated().getTime(), updateRequestDto.getLastUpdated().getTime())));
+            clientUpdateRequestDto.setPercentCompleted(Math.min(clientUpdateRequestDto.getPercentCompleted(), updateRequestDto.getPercentCompleted()));
+
+            // Merge the Affected Components.
+            for (final AffectedComponentEntity entity : requestEntity.getRequest().getAffectedComponents()) {
+                final AffectedComponentEntity mergedAffectedComponentEntity = affectedComponentEntities.get(entity.getId());
+                if (mergedAffectedComponentEntity == null) {
+                    affectedComponentEntities.put(entity.getId(), entity);
+                    return;
+                }
+
+                ParameterContextMerger.merge(mergedAffectedComponentEntity, entity);
+            }
+        }
+
+        final Map<NodeIdentifier, ParameterContextDTO> contextDtoMap = new HashMap<>();
+        entityMap.forEach( (nodeId, entity) -> contextDtoMap.put(nodeId, entity.getRequest().getParameterContext()));
+
+        ParameterContextMerger.merge(clientUpdateRequestDto.getParameterContext(), contextDtoMap);
+        clientUpdateRequestDto.setAffectedComponents(new HashSet<>(affectedComponentEntities.values()));
+    }
+
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextValidationMerger.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextValidationMerger.java
new file mode 100644
index 00000000000..d925d4b13e0
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextValidationMerger.java
@@ -0,0 +1,156 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.cluster.coordination.http.endpoints;
+
+import org.apache.nifi.cluster.coordination.http.EndpointResponseMerger;
+import org.apache.nifi.cluster.manager.NodeResponse;
+import org.apache.nifi.cluster.manager.PermissionsDtoMerger;
+import org.apache.nifi.cluster.protocol.NodeIdentifier;
+import org.apache.nifi.web.api.dto.ComponentValidationResultDTO;
+import org.apache.nifi.web.api.dto.ParameterContextValidationRequestDTO;
+import org.apache.nifi.web.api.entity.ComponentValidationResultEntity;
+import org.apache.nifi.web.api.entity.ComponentValidationResultsEntity;
+import org.apache.nifi.web.api.entity.ParameterContextValidationRequestEntity;
+
+import java.net.URI;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+public class ParameterContextValidationMerger extends AbstractSingleEntityEndpoint<ParameterContextValidationRequestEntity> implements EndpointResponseMerger {
+    public static final Pattern REQUESTS_URI_PATTERN = Pattern.compile("/nifi-api/parameter-contexts/validation-requests");
+    public static final Pattern REQUEST_BY_ID_URI_PATTERN = Pattern.compile("/nifi-api/parameter-contexts/validation-requests/[a-f0-9\\-]{36}");
+
+    @Override
+    public boolean canHandle(final URI uri, final String method) {
+        if ("POST".equalsIgnoreCase(method) && REQUESTS_URI_PATTERN.matcher(uri.getPath()).matches()) {
+            return true;
+        }
+
+        return (REQUEST_BY_ID_URI_PATTERN.matcher(uri.getPath()).matches());
+    }
+
+    @Override
+    protected Class<ParameterContextValidationRequestEntity> getEntityClass() {
+        return ParameterContextValidationRequestEntity.class;
+    }
+
+    @Override
+    protected void mergeResponses(final ParameterContextValidationRequestEntity clientEntity, final Map<NodeIdentifier, ParameterContextValidationRequestEntity> entityMap,
+                                  final Set<NodeResponse> successfulResponses, final Set<NodeResponse> problematicResponses) {
+
+        final ParameterContextValidationRequestDTO validationRequest = clientEntity.getRequest();
+
+        for (final ParameterContextValidationRequestEntity requestEntity : entityMap.values()) {
+            final ParameterContextValidationRequestDTO requestDto = requestEntity.getRequest();
+
+            if (!requestDto.isComplete()) {
+                validationRequest.setComplete(false);
+            }
+            if (requestDto.getFailureReason() != null) {
+                validationRequest.setFailureReason(requestDto.getFailureReason());
+            }
+            if (requestDto.getLastUpdated() != null && (validationRequest.getLastUpdated() == null || requestDto.getLastUpdated().after(validationRequest.getLastUpdated()))) {
+                validationRequest.setLastUpdated(requestDto.getLastUpdated());
+            }
+            if (requestDto.getPercentCompleted() < validationRequest.getPercentCompleted()) {
+                validationRequest.setPercentCompleted(requestDto.getPercentCompleted());
+                validationRequest.setState(requestDto.getState());
+            }
+        }
+
+        final ComponentValidationResultsEntity resultsEntity = validationRequest.getComponentValidationResults();
+        if (resultsEntity == null) {
+            return;
+        }
+
+        final List<ComponentValidationResultEntity> resultsEntities = resultsEntity.getValidationResults();
+        if (resultsEntities == null) {
+            return;
+        }
+
+        final Map<String, ComponentValidationResultEntity> resultsById = new HashMap<>();
+        for (final ComponentValidationResultEntity resultEntity : resultsEntities) {
+            resultsById.put(resultEntity.getId(), resultEntity);
+        }
+
+        for (final ParameterContextValidationRequestEntity requestEntity : entityMap.values()) {
+            final ComponentValidationResultsEntity validationResultsEntity = requestEntity.getRequest().getComponentValidationResults();
+            if (validationResultsEntity == null) {
+                continue;
+            }
+
+            for (final ComponentValidationResultEntity resultEntity : validationResultsEntity.getValidationResults()) {
+                final ComponentValidationResultEntity mergedResultEntity = resultsById.get(resultEntity.getId());
+                if (mergedResultEntity == null) {
+                    resultsById.put(resultEntity.getId(), resultEntity);
+                } else {
+                    merge(mergedResultEntity, resultEntity);
+                }
+            }
+        }
+
+        resultsEntity.setValidationResults(new ArrayList<>(resultsById.values()));
+    }
+
+    private void merge(final ComponentValidationResultEntity merged, final ComponentValidationResultEntity additional) {
+        if (merged.getComponent() == null) {
+            return;
+        }
+
+        PermissionsDtoMerger.mergePermissions(merged.getPermissions(), additional.getPermissions());
+
+        // If either entity doesn't have the component, then we cannot return the component because it was filtered out due to permissions.
+        if (additional.getComponent() == null) {
+            merged.setComponent(null);
+            return;
+        }
+
+        final ComponentValidationResultDTO mergedResultDto = merged.getComponent();
+        final ComponentValidationResultDTO additionalResultDto = additional.getComponent();
+
+        mergedResultDto.setActiveThreadCount(mergedResultDto.getActiveThreadCount() + additionalResultDto.getActiveThreadCount());
+
+        // Merge validation errors
+        Collection<String> mergedValidationErrors = mergedResultDto.getValidationErrors();
+        if (mergedValidationErrors == null) {
+            mergedValidationErrors = new ArrayList<>();
+            mergedResultDto.setValidationErrors(mergedValidationErrors);
+        }
+        if (additionalResultDto.getValidationErrors() != null) {
+            mergedValidationErrors.addAll(additionalResultDto.getValidationErrors());
+        }
+
+        // Merge resultant validation errors
+        Collection<String> mergedResultantValidationErrors = mergedResultDto.getResultantValidationErrors();
+        if (mergedResultantValidationErrors == null) {
+            mergedResultantValidationErrors = new ArrayList<>();
+            mergedResultDto.setResultantValidationErrors(mergedResultantValidationErrors);
+        }
+        if (additionalResultDto.getResultantValidationErrors() != null) {
+            mergedResultantValidationErrors.addAll(additionalResultDto.getResultantValidationErrors());
+        }
+
+        // Merge currently valid & results valid fields
+        mergedResultDto.setCurrentlyValid(mergedValidationErrors.isEmpty());
+        mergedResultDto.setResultsValid(mergedResultantValidationErrors.isEmpty());
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextsEndpointMerger.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextsEndpointMerger.java
new file mode 100644
index 00000000000..cf95580f2bd
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/http/endpoints/ParameterContextsEndpointMerger.java
@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.cluster.coordination.http.endpoints;
+
+import org.apache.nifi.cluster.coordination.http.EndpointResponseMerger;
+import org.apache.nifi.cluster.manager.NodeResponse;
+import org.apache.nifi.cluster.manager.PermissionsDtoMerger;
+import org.apache.nifi.cluster.protocol.NodeIdentifier;
+import org.apache.nifi.web.api.entity.ParameterContextEntity;
+import org.apache.nifi.web.api.entity.ParameterContextsEntity;
+
+import java.net.URI;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+public class ParameterContextsEndpointMerger extends AbstractSingleEntityEndpoint<ParameterContextsEntity> implements EndpointResponseMerger {
+    private static final String PARAMETER_CONTEXTS_URI = "/nifi-api/parameter-contexts";
+
+    @Override
+    public boolean canHandle(final URI uri, final String method) {
+        return "GET".equalsIgnoreCase(method) && PARAMETER_CONTEXTS_URI.equals(uri.getPath());
+    }
+
+    @Override
+    protected Class<ParameterContextsEntity> getEntityClass() {
+        return ParameterContextsEntity.class;
+    }
+
+    @Override
+    protected void mergeResponses(final ParameterContextsEntity clientEntity, final Map<NodeIdentifier, ParameterContextsEntity> entityMap, final Set<NodeResponse> successfulResponses,
+                                  final Set<NodeResponse> problematicResponses) {
+
+        final Map<String, ParameterContextEntity> contextEntities = new HashMap<>();
+        for (final ParameterContextsEntity contextsEntity : entityMap.values()) {
+            for (final ParameterContextEntity entity : contextsEntity.getParameterContexts()) {
+                final ParameterContextEntity mergedEntity = contextEntities.get(entity.getId());
+                if (mergedEntity == null) {
+                    contextEntities.put(entity.getId(), entity);
+                    continue;
+                }
+
+                merge(mergedEntity, entity);
+            }
+        }
+
+        clientEntity.setParameterContexts(new HashSet<>(contextEntities.values()));
+    }
+
+    private void merge(final ParameterContextEntity merged, final ParameterContextEntity additional) {
+        PermissionsDtoMerger.mergePermissions(merged.getPermissions(), additional.getPermissions());
+
+        if (merged.getComponent() == null || additional.getComponent() == null) {
+            merged.setComponent(null);
+        }
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/node/NodeClusterCoordinator.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/node/NodeClusterCoordinator.java
index 66eec26dec5..2ca8ef81a46 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/node/NodeClusterCoordinator.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/coordination/node/NodeClusterCoordinator.java
@@ -22,6 +22,7 @@
 import com.fasterxml.jackson.databind.ObjectMapper;
 import org.apache.commons.collections4.queue.CircularFifoQueue;
 import org.apache.commons.lang3.StringUtils;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.cluster.coordination.ClusterCoordinator;
 import org.apache.nifi.cluster.coordination.ClusterTopologyEventListener;
 import org.apache.nifi.cluster.coordination.flow.FlowElection;
@@ -34,8 +35,8 @@
 import org.apache.nifi.cluster.exception.NoClusterCoordinatorException;
 import org.apache.nifi.cluster.firewall.ClusterNodeFirewall;
 import org.apache.nifi.cluster.manager.NodeResponse;
-import org.apache.nifi.cluster.manager.exception.IllegalNodeOffloadException;
 import org.apache.nifi.cluster.manager.exception.IllegalNodeDisconnectionException;
+import org.apache.nifi.cluster.manager.exception.IllegalNodeOffloadException;
 import org.apache.nifi.cluster.protocol.ComponentRevision;
 import org.apache.nifi.cluster.protocol.ConnectionRequest;
 import org.apache.nifi.cluster.protocol.ConnectionResponse;
@@ -50,10 +51,10 @@
 import org.apache.nifi.cluster.protocol.message.ClusterWorkloadResponseMessage;
 import org.apache.nifi.cluster.protocol.message.ConnectionRequestMessage;
 import org.apache.nifi.cluster.protocol.message.ConnectionResponseMessage;
-import org.apache.nifi.cluster.protocol.message.OffloadMessage;
 import org.apache.nifi.cluster.protocol.message.DisconnectMessage;
 import org.apache.nifi.cluster.protocol.message.NodeConnectionStatusResponseMessage;
 import org.apache.nifi.cluster.protocol.message.NodeStatusChangeMessage;
+import org.apache.nifi.cluster.protocol.message.OffloadMessage;
 import org.apache.nifi.cluster.protocol.message.ProtocolMessage;
 import org.apache.nifi.cluster.protocol.message.ProtocolMessage.MessageType;
 import org.apache.nifi.cluster.protocol.message.ReconnectionRequestMessage;
@@ -126,7 +127,7 @@ public NodeClusterCoordinator(final ClusterCoordinationProtocolSenderListener se
                                   final FlowElection flowElection, final ClusterNodeFirewall firewall, final RevisionManager revisionManager, final NiFiProperties nifiProperties,
                                   final ExtensionManager extensionManager, final NodeProtocolSender nodeProtocolSender) throws IOException {
         this(senderListener, eventReporter, leaderElectionManager, flowElection, firewall, revisionManager, nifiProperties, nodeProtocolSender,
-            StandardStateManagerProvider.create(nifiProperties, VariableRegistry.EMPTY_REGISTRY, extensionManager));
+            StandardStateManagerProvider.create(nifiProperties, VariableRegistry.EMPTY_REGISTRY, extensionManager, ParameterLookup.EMPTY));
     }
 
     public NodeClusterCoordinator(final ClusterCoordinationProtocolSenderListener senderListener, final EventReporter eventReporter, final LeaderElectionManager leaderElectionManager,
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/manager/StatusMerger.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/manager/StatusMerger.java
index 0043ca06852..946295a45b9 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/manager/StatusMerger.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/main/java/org/apache/nifi/cluster/manager/StatusMerger.java
@@ -96,6 +96,10 @@ public static void updatePrettyPrintedFields(final ControllerStatusDTO target) {
 
     public static void merge(final ProcessGroupStatusDTO target, final boolean targetReadablePermission, final ProcessGroupStatusDTO toMerge, final boolean toMergeReadablePermission,
                              final String nodeId, final String nodeAddress, final Integer nodeApiPort) {
+        if (toMerge == null) {
+            return;
+        }
+
         if (targetReadablePermission && !toMergeReadablePermission) {
             target.setId(toMerge.getId());
             target.setName(toMerge.getName());
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/test/java/org/apache/nifi/cluster/coordination/flow/TestPopularVoteFlowElection.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/test/java/org/apache/nifi/cluster/coordination/flow/TestPopularVoteFlowElection.java
index 962f521d4c5..fe675dcfda6 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/test/java/org/apache/nifi/cluster/coordination/flow/TestPopularVoteFlowElection.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-cluster/src/test/java/org/apache/nifi/cluster/coordination/flow/TestPopularVoteFlowElection.java
@@ -17,21 +17,6 @@
 
 package org.apache.nifi.cluster.coordination.flow;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.ArgumentMatchers.anyString;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import java.io.IOException;
-import java.nio.file.Files;
-import java.nio.file.Paths;
-import java.util.HashSet;
-import java.util.UUID;
-import java.util.concurrent.TimeUnit;
 import org.apache.nifi.cluster.protocol.DataFlow;
 import org.apache.nifi.cluster.protocol.NodeIdentifier;
 import org.apache.nifi.cluster.protocol.StandardDataFlow;
@@ -45,6 +30,22 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.HashSet;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.anyString;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
 public class TestPopularVoteFlowElection {
 
     /**
@@ -183,35 +184,6 @@ public void testAutoGeneratedVsPopulatedFlowElection() throws IOException {
         }
     }
 
-    @Test
-    public void testDifferentPopulatedFlowsElection() throws IOException {
-        final ExtensionManager extensionManager = new StandardExtensionDiscoveringManager();
-        final FingerprintFactory fingerprintFactory = new FingerprintFactory(createEncryptorFromProperties(getNiFiProperties()), extensionManager);
-        final PopularVoteFlowElection election = new PopularVoteFlowElection(1, TimeUnit.MINUTES, 4, fingerprintFactory);
-        final byte[] nonEmptyCandidateA = Files.readAllBytes(Paths.get("src/test/resources/conf/controller-service-flow.xml"));
-        final byte[] nonEmptyCandidateB = Files.readAllBytes(Paths.get("src/test/resources/conf/reporting-task-flow.xml"));
-
-        for (int i = 0; i < 4; i++) {
-            assertFalse(election.isElectionComplete());
-            assertNull(election.getElectedDataFlow());
-
-            final DataFlow dataFlow;
-            if (i % 2 == 0) {
-                dataFlow = createDataFlow(nonEmptyCandidateA);
-            } else {
-                dataFlow = createDataFlow(nonEmptyCandidateB);
-            }
-
-            final DataFlow electedDataFlow = election.castVote(dataFlow, createNodeId(i));
-
-            if (i == 3) {
-                assertNotNull(electedDataFlow);
-                assertEquals(new String(nonEmptyCandidateA), new String(electedDataFlow.getFlow()));
-            } else {
-                assertNull(electedDataFlow);
-            }
-        }
-    }
 
     private NiFiProperties getNiFiProperties() {
         final NiFiProperties nifiProperties = mock(NiFiProperties.class);
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/pom.xml b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/pom.xml
index 39d040f9b65..6371c7d313c 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/pom.xml
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/pom.xml
@@ -1,13 +1,13 @@
 <?xml version="1.0"?>
-<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor 
-license agreements. See the NOTICE file distributed with this work for additional 
-information regarding copyright ownership. The ASF licenses this file to 
-You under the Apache License, Version 2.0 (the "License"); you may not use 
-this file except in compliance with the License. You may obtain a copy of 
-the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required 
-by applicable law or agreed to in writing, software distributed under the 
-License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS 
-OF ANY KIND, either express or implied. See the License for the specific 
+<!-- Licensed to the Apache Software Foundation (ASF) under one or more contributor
+license agreements. See the NOTICE file distributed with this work for additional
+information regarding copyright ownership. The ASF licenses this file to
+You under the Apache License, Version 2.0 (the "License"); you may not use
+this file except in compliance with the License. You may obtain a copy of
+the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required
+by applicable law or agreed to in writing, software distributed under the
+License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS
+OF ANY KIND, either express or implied. See the License for the specific
 language governing permissions and limitations under the License. -->
 <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
     <modelVersion>4.0.0</modelVersion>
@@ -27,6 +27,10 @@ language governing permissions and limitations under the License. -->
             <artifactId>nifi-utils</artifactId>
             <version>1.10.0-SNAPSHOT</version>
         </dependency>
+        <dependency>
+            <groupId>org.apache.nifi</groupId>
+            <artifactId>nifi-parameter</artifactId>
+        </dependency>
         <dependency>
             <groupId>org.apache.nifi</groupId>
             <artifactId>nifi-client-dto</artifactId>
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/AbstractComponentNode.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/AbstractComponentNode.java
index d2032a2d82f..51ca3730fa9 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/AbstractComponentNode.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/AbstractComponentNode.java
@@ -32,6 +32,13 @@
 import org.apache.nifi.controller.service.ControllerServiceProvider;
 import org.apache.nifi.nar.ExtensionManager;
 import org.apache.nifi.nar.NarCloseable;
+import org.apache.nifi.parameter.ExpressionLanguageAgnosticParameterParser;
+import org.apache.nifi.parameter.ExpressionLanguageAwareParameterParser;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterParser;
+import org.apache.nifi.parameter.ParameterReference;
+import org.apache.nifi.parameter.ParameterTokenList;
 import org.apache.nifi.registry.ComponentVariableRegistry;
 import org.apache.nifi.util.CharacterFilterUtils;
 import org.apache.nifi.util.file.classloader.ClassLoaderUtils;
@@ -41,6 +48,7 @@
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedHashMap;
@@ -48,6 +56,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
@@ -76,11 +85,12 @@ public abstract class AbstractComponentNode implements ComponentNode {
     private final AtomicBoolean isExtensionMissing;
 
     private final Lock lock = new ReentrantLock();
-    private final ConcurrentMap<PropertyDescriptor, String> properties = new ConcurrentHashMap<>();
+    private final ConcurrentMap<PropertyDescriptor, PropertyConfiguration> properties = new ConcurrentHashMap<>();
     private volatile String additionalResourcesFingerprint;
     private final AtomicReference<ValidationState> validationState = new AtomicReference<>(new ValidationState(ValidationStatus.VALIDATING, Collections.emptyList()));
     private final ValidationTrigger validationTrigger;
     private volatile boolean triggerValidation = true;
+    private final Map<String, Integer> parameterReferenceCounts = new ConcurrentHashMap<>();
 
     // guaraded by lock
     private ValidationContext validationContext = null;
@@ -141,12 +151,18 @@ public void setAnnotationData(final String data) {
 
     @Override
     public Set<URL> getAdditionalClasspathResources(final List<PropertyDescriptor> propertyDescriptors) {
+        return getAdditionalClasspathResources((Collection<PropertyDescriptor>) propertyDescriptors);
+    }
+
+    private Set<URL> getAdditionalClasspathResources(final Collection<PropertyDescriptor> propertyDescriptors) {
         final Set<String> modulePaths = new LinkedHashSet<>();
         for (final PropertyDescriptor descriptor : propertyDescriptors) {
             if (descriptor.isDynamicClasspathModifier()) {
-                final String value = getProperty(descriptor);
+                final PropertyConfiguration propertyConfiguration = getProperty(descriptor);
+                final String value = propertyConfiguration == null ? null : propertyConfiguration.getEffectiveValue(getParameterContext());
+
                 if (!StringUtils.isEmpty(value)) {
-                    final StandardPropertyValue propertyValue = new StandardPropertyValue(value, null, variableRegistry);
+                    final StandardPropertyValue propertyValue = new StandardPropertyValue(value, null, getParameterLookup(), variableRegistry);
                     modulePaths.add(propertyValue.evaluateAttributeExpressions().getValue());
                 }
             }
@@ -156,9 +172,7 @@ public Set<URL> getAdditionalClasspathResources(final List<PropertyDescriptor> p
         try {
             final URL[] urls = ClassLoaderUtils.getURLsForClasspath(modulePaths, null, true);
             if (urls != null) {
-                for (final URL url : urls) {
-                    additionalUrls.add(url);
-                }
+                additionalUrls.addAll(Arrays.asList(urls));
             }
         } catch (MalformedURLException mfe) {
             getLogger().error("Error processing classpath resources for " + id + ": " + mfe.getMessage(), mfe);
@@ -166,6 +180,7 @@ public Set<URL> getAdditionalClasspathResources(final List<PropertyDescriptor> p
         return additionalUrls;
     }
 
+
     @Override
     public void setProperties(final Map<String, String> properties, final boolean allowRemovalOfRequiredProperties) {
         if (properties == null) {
@@ -174,7 +189,12 @@ public void setProperties(final Map<String, String> properties, final boolean al
 
         lock.lock();
         try {
-            verifyModifiable();
+            verifyCanUpdateProperties(properties);
+
+            // Keep track of counts of each parameter reference. This way, when we complete the updates to property values, we can
+            // update our counts easily.
+            final ParameterParser elAgnosticParameterParser = new ExpressionLanguageAgnosticParameterParser();
+            final ParameterParser elAwareParameterParser = new ExpressionLanguageAwareParameterParser();
 
             try (final NarCloseable narCloseable = NarCloseable.withComponentNarLoader(extensionManager, getComponent().getClass(), id)) {
                 boolean classpathChanged = false;
@@ -185,11 +205,38 @@ public void setProperties(final Map<String, String> properties, final boolean al
                         classpathChanged = true;
                     }
 
+                    final PropertyConfiguration currentConfiguration = this.properties.get(descriptor);
+                    if (currentConfiguration != null) {
+                        for (final ParameterReference reference : currentConfiguration.getParameterReferences()) {
+                            parameterReferenceCounts.merge(reference.getParameterName(), -1, (a, b) -> a == 1 ? null : a + b);
+                        }
+                    }
+
                     if (entry.getKey() != null && entry.getValue() == null) {
                         removeProperty(entry.getKey(), allowRemovalOfRequiredProperties);
                     } else if (entry.getKey() != null) {
                         final String updatedValue = CharacterFilterUtils.filterInvalidXmlCharacters(entry.getValue());
-                        setProperty(entry.getKey(), updatedValue, this.properties::get);
+
+                        // Use the EL-Agnostic Parameter Parser to gather the list of referenced Parameters. We do this because we want to to keep track of which parameters
+                        // are referenced, regardless of whether or not they are referenced from within an EL Expression. However, we also will need to derive a different ParameterTokenList
+                        // that we can provide to the PropertyConfiguration, so that when compiling the Expression Language Expressions, we are able to keep the Parameter Reference within
+                        // the Expression's text.
+                        final ParameterTokenList updatedValueReferences = elAgnosticParameterParser.parseTokens(updatedValue);
+                        final List<ParameterReference> parameterReferences = updatedValueReferences.toReferenceList();
+                        for (final ParameterReference reference : parameterReferences) {
+                            // increment count in map for this parameter
+                            parameterReferenceCounts.merge(reference.getParameterName(), 1, (a, b) -> a == -1 ? null : a + b);
+                        }
+
+                        final PropertyConfiguration propertyConfiguration;
+                        final boolean supportsEL = getPropertyDescriptor(entry.getKey()).isExpressionLanguageSupported();
+                        if (supportsEL) {
+                            propertyConfiguration = new PropertyConfiguration(updatedValue, elAwareParameterParser.parseTokens(updatedValue), parameterReferences);
+                        } else {
+                            propertyConfiguration = new PropertyConfiguration(updatedValue, updatedValueReferences, parameterReferences);
+                        }
+
+                        setProperty(entry.getKey(), propertyConfiguration, this.properties::get);
                     }
                 }
 
@@ -217,26 +264,93 @@ public void setProperties(final Map<String, String> properties, final boolean al
         }
     }
 
+    public void verifyCanUpdateProperties(final Map<String, String> properties) {
+        verifyModifiable();
+
+        final ParameterParser parameterParser = new ExpressionLanguageAgnosticParameterParser();
+
+        for (final Map.Entry<String, String> entry : properties.entrySet()) {
+            final String propertyName = entry.getKey();
+            final String value = entry.getValue();
+
+            final ParameterTokenList tokenList = parameterParser.parseTokens(value);
+            final List<ParameterReference> referenceList = tokenList.toReferenceList();
+
+            final PropertyDescriptor descriptor = getPropertyDescriptor(propertyName);
+
+            if (descriptor.isSensitive()) {
+                if (referenceList.size() > 1) {
+                    throw new IllegalArgumentException("The property '" + descriptor.getDisplayName() + "' cannot reference more than one Parameter because it is a sensitive property.");
+                }
+
+                if (referenceList.size() == 1) {
+                    final ParameterReference reference = referenceList.get(0);
+                    if (reference.getStartOffset() != 0 || reference.getEndOffset() != value.length() - 1) {
+                        throw new IllegalArgumentException("The property '" + descriptor.getDisplayName() + "' is a sensitive property so it can reference a Parameter only if there is no other " +
+                            "context around the value. For instance, the value '#{abc}' is allowed but 'password#{abc}' is not allowed.");
+                    }
+
+                    final ParameterContext parameterContext = getParameterContext();
+                    if (parameterContext != null) {
+                        final Optional<Parameter> parameter = parameterContext.getParameter(reference.getParameterName());
+                        if (parameter.isPresent() && !parameter.get().getDescriptor().isSensitive()) {
+                            throw new IllegalArgumentException("The property '" + descriptor.getDisplayName() + "' is a sensitive property, so it can only reference Parameters that are sensitive.");
+                        }
+                    }
+                }
+            } else {
+                final ParameterContext parameterContext = getParameterContext();
+                if (parameterContext != null) {
+                    for (final ParameterReference reference : referenceList) {
+                        final Optional<Parameter> parameter = parameterContext.getParameter(reference.getParameterName());
+                        if (parameter.isPresent() && parameter.get().getDescriptor().isSensitive()) {
+                            throw new IllegalArgumentException("The property '" + descriptor.getDisplayName() + "' cannot reference Parameter '" + parameter.get().getDescriptor().getName()
+                                + "' because Sensitive Parameters may only be referenced by Sensitive Properties.");
+                        }
+                    }
+                }
+            }
+
+            if (descriptor.getControllerServiceDefinition() != null) {
+                if (!referenceList.isEmpty()) {
+                    throw new IllegalArgumentException("The property '" + descriptor.getDisplayName() + "' cannot reference a Parameter because the property is a Controller Service reference. " +
+                        "Allowing Controller Service references to make use of Parameters could result in security issues and a poor user experience. As a result, this is not allowed.");
+                }
+            }
+        }
+    }
+
+    @Override
+    public Set<String> getReferencedParameterNames() {
+        return Collections.unmodifiableSet(parameterReferenceCounts.keySet());
+    }
+
+    @Override
+    public boolean isReferencingParameter() {
+        return !parameterReferenceCounts.isEmpty();
+    }
+
     // Keep setProperty/removeProperty private so that all calls go through setProperties
-    private void setProperty(final String name, final String value, final Function<PropertyDescriptor, String> valueToCompareFunction) {
-        if (null == name || null == value) {
+    private void setProperty(final String name, final PropertyConfiguration propertyConfiguration, final Function<PropertyDescriptor, PropertyConfiguration> valueToCompareFunction) {
+        if (name == null || propertyConfiguration == null || propertyConfiguration.getRawValue() == null) {
             throw new IllegalArgumentException("Name or Value can not be null");
         }
 
         final PropertyDescriptor descriptor = getComponent().getPropertyDescriptor(name);
-        final String propertyModComparisonValue = valueToCompareFunction.apply(descriptor);
-        final String oldValue = properties.put(descriptor, value);
+        final PropertyConfiguration propertyModComparisonValue = valueToCompareFunction.apply(descriptor);
+        final PropertyConfiguration oldConfiguration = properties.put(descriptor, propertyConfiguration);
+        final String effectiveValue = propertyConfiguration.getEffectiveValue(getParameterContext());
 
-        if (!value.equals(oldValue)) {
+        if (!propertyConfiguration.equals(oldConfiguration)) {
             if (descriptor.getControllerServiceDefinition() != null) {
-                if (oldValue != null) {
-                    final ControllerServiceNode oldNode = serviceProvider.getControllerServiceNode(oldValue);
+                if (oldConfiguration != null) {
+                    final ControllerServiceNode oldNode = serviceProvider.getControllerServiceNode(effectiveValue);
                     if (oldNode != null) {
                         oldNode.removeReference(this);
                     }
                 }
 
-                final ControllerServiceNode newNode = serviceProvider.getControllerServiceNode(value);
+                final ControllerServiceNode newNode = serviceProvider.getControllerServiceNode(effectiveValue);
                 if (newNode != null) {
                     newNode.addReference(this);
                 }
@@ -246,11 +360,13 @@ private void setProperty(final String name, final String value, final Function<P
         // In the case of a component "reload", we want to call onPropertyModified when the value is changed from the descriptor's default.
         // However, we do not want to update any controller service references because those are tied to the ComponentNode. We only want to
         // allow the newly created component's internal state to be updated.
-        if (!value.equals(propertyModComparisonValue)) {
+        if (!propertyConfiguration.equals(propertyModComparisonValue)) {
             try {
-                onPropertyModified(descriptor, oldValue, value);
+                final String oldValue = oldConfiguration == null ? null : oldConfiguration.getEffectiveValue(getParameterContext());
+                onPropertyModified(descriptor, oldValue, effectiveValue);
             } catch (final Exception e) {
                 // nothing really to do here...
+                logger.error("Failed to notify {} that property {} changed", this, descriptor, e);
             }
         }
     }
@@ -272,43 +388,48 @@ private boolean removeProperty(final String name, final boolean allowRemovalOfRe
         }
 
         final PropertyDescriptor descriptor = getComponent().getPropertyDescriptor(name);
-        String value = null;
 
         final boolean allowRemoval = allowRemovalOfRequiredProperties || !descriptor.isRequired();
-        if (allowRemoval && (value = properties.remove(descriptor)) != null) {
+        if (!allowRemoval) {
+            return false;
+        }
 
-            if (descriptor.getControllerServiceDefinition() != null) {
-                if (value != null) {
-                    final ControllerServiceNode oldNode = serviceProvider.getControllerServiceNode(value);
-                    if (oldNode != null) {
-                        oldNode.removeReference(this);
-                    }
-                }
-            }
+        final PropertyConfiguration propertyConfiguration = properties.remove(descriptor);
+        if (propertyConfiguration == null || propertyConfiguration.getRawValue() == null) {
+            return false;
+        }
 
-            try {
-                onPropertyModified(descriptor, value, null);
-            } catch (final Exception e) {
-                getLogger().error(e.getMessage(), e);
+        final String value = propertyConfiguration.getEffectiveValue(getParameterContext());
+        if (descriptor.getControllerServiceDefinition() != null) {
+            if (value != null) {
+                final ControllerServiceNode oldNode = serviceProvider.getControllerServiceNode(value);
+                if (oldNode != null) {
+                    oldNode.removeReference(this);
+                }
             }
+        }
 
-            return true;
+        try {
+            onPropertyModified(descriptor, value, null);
+        } catch (final Exception e) {
+            getLogger().error(e.getMessage(), e);
         }
 
-        return false;
+        return true;
     }
 
-    @Override
-    public Map<PropertyDescriptor, String> getProperties() {
+    public Map<PropertyDescriptor, PropertyConfiguration> getProperties() {
         try (final NarCloseable narCloseable = NarCloseable.withComponentNarLoader(extensionManager, getComponent().getClass(), getIdentifier())) {
             final List<PropertyDescriptor> supported = getComponent().getPropertyDescriptors();
             if (supported == null || supported.isEmpty()) {
                 return Collections.unmodifiableMap(properties);
             } else {
-                final Map<PropertyDescriptor, String> props = new LinkedHashMap<>();
+                final Map<PropertyDescriptor, PropertyConfiguration> props = new LinkedHashMap<>();
+
                 for (final PropertyDescriptor descriptor : supported) {
                     props.put(descriptor, null);
                 }
+
                 props.putAll(properties);
                 return props;
             }
@@ -316,8 +437,43 @@ public Map<PropertyDescriptor, String> getProperties() {
     }
 
     @Override
-    public String getProperty(final PropertyDescriptor property) {
-        return properties.get(property);
+    public Map<PropertyDescriptor, String> getRawPropertyValues() {
+        return getPropertyValues(PropertyConfiguration::getRawValue);
+    }
+
+    @Override
+    public Map<PropertyDescriptor, String> getEffectivePropertyValues() {
+        return getPropertyValues(config -> config.getEffectiveValue(getParameterContext()));
+    }
+
+    private Map<PropertyDescriptor, String> getPropertyValues(final Function<PropertyConfiguration, String> valueFunction) {
+        try (final NarCloseable narCloseable = NarCloseable.withComponentNarLoader(extensionManager, getComponent().getClass(), getIdentifier())) {
+            final List<PropertyDescriptor> supported = getComponent().getPropertyDescriptors();
+
+            final Map<PropertyDescriptor, String> props = new LinkedHashMap<>();
+            for (final PropertyDescriptor descriptor : supported) {
+                props.put(descriptor, null);
+            }
+
+            properties.forEach((descriptor, config) -> props.put(descriptor, valueFunction.apply(config)));
+            return props;
+        }
+    }
+
+    @Override
+    public PropertyConfiguration getProperty(final PropertyDescriptor property) {
+        final PropertyConfiguration configuration = properties.get(property);
+        return (configuration == null) ? PropertyConfiguration.EMPTY : configuration;
+    }
+
+    @Override
+    public String getEffectivePropertyValue(final PropertyDescriptor property) {
+        return getProperty(property).getEffectiveValue(getParameterContext());
+    }
+
+    @Override
+    public String getRawPropertyValue(final PropertyDescriptor property) {
+        return getProperty(property).getRawValue();
     }
 
     @Override
@@ -325,9 +481,22 @@ public void refreshProperties() {
         // use setProperty instead of setProperties so we can bypass the class loading logic.
         // Consider value changed if it is different than the PropertyDescriptor's default value because we need to call the #onPropertiesModified
         // method on the component if the current value is not the default value, since the component itself is being reloaded.
-        getProperties().entrySet().stream()
-                .filter(e -> e.getKey() != null && e.getValue() != null)
-                .forEach(e -> setProperty(e.getKey().getName(), e.getValue(), PropertyDescriptor::getDefaultValue));
+        for (final Map.Entry<PropertyDescriptor, PropertyConfiguration> entry : this.properties.entrySet()) {
+            final PropertyDescriptor propertyDescriptor = entry.getKey();
+            final PropertyConfiguration configuration = entry.getValue();
+
+            if (propertyDescriptor == null || configuration == null || configuration.getRawValue() == null) {
+                continue;
+            }
+
+            setProperty(propertyDescriptor.getName(), configuration, descriptor -> createPropertyConfiguration(descriptor.getDefaultValue(), descriptor.isExpressionLanguageSupported()));
+        }
+    }
+
+    private PropertyConfiguration createPropertyConfiguration(final String value, final boolean supportsEL) {
+        final ParameterParser parser = new ExpressionLanguageAwareParameterParser();
+        final ParameterTokenList references = parser.parseTokens(value);
+        return new PropertyConfiguration(value, references, references.toReferenceList());
     }
 
     /**
@@ -343,7 +512,7 @@ public synchronized void reloadAdditionalResourcesIfNecessary() {
             return;
         }
 
-        final List<PropertyDescriptor> descriptors = new ArrayList<>(this.getProperties().keySet());
+        final Set<PropertyDescriptor> descriptors = this.getProperties().keySet();
         final Set<URL> additionalUrls = this.getAdditionalClasspathResources(descriptors);
 
         final String newFingerprint = ClassLoaderUtils.generateAdditionalUrlsFingerprint(additionalUrls);
@@ -387,27 +556,34 @@ public String toString() {
         }
     }
 
+    @Override
+    public ValidationState performValidation(final Map<PropertyDescriptor, PropertyConfiguration> properties, final String annotationData, final ParameterContext parameterContext) {
+        final ValidationContext validationContext = validationContextFactory.newValidationContext(properties, annotationData, getProcessGroupIdentifier(), getIdentifier(), parameterContext);
+        return performValidation(validationContext);
+    }
+
+    @Override
+    public ValidationState performValidation(final ValidationContext validationContext) {
+        final Collection<ValidationResult> results;
+        try (final NarCloseable narCloseable = NarCloseable.withComponentNarLoader(extensionManager, getComponent().getClass(), getIdentifier())) {
+            results = computeValidationErrors(validationContext);
+        }
+
+        final ValidationStatus status = results.isEmpty() ? ValidationStatus.VALID : ValidationStatus.INVALID;
+        final ValidationState validationState = new ValidationState(status, results);
+        return validationState;
+    }
+
     @Override
     public final ValidationStatus performValidation() {
         while (true) {
             final ValidationState validationState = getValidationState();
 
             final ValidationContext validationContext = getValidationContext();
-            final Collection<ValidationResult> results = new ArrayList<>();
-            try (final NarCloseable narCloseable = NarCloseable.withComponentNarLoader(extensionManager, getComponent().getClass(), getIdentifier())) {
-                final Collection<ValidationResult> validationResults = computeValidationErrors(validationContext);
-                results.addAll(validationResults);
-
-                // validate selected controller services implement the API required by the processor
-                final Collection<ValidationResult> referencedServiceValidationResults = validateReferencedControllerServices(validationContext);
-                results.addAll(referencedServiceValidationResults);
-            }
-
-            final ValidationStatus status = results.isEmpty() ? ValidationStatus.VALID : ValidationStatus.INVALID;
-            final ValidationState updatedState = new ValidationState(status, results);
+            final ValidationState updatedState = performValidation(validationContext);
             final boolean replaced = replaceValidationState(validationState, updatedState);
             if (replaced) {
-                return status;
+                return updatedState.getStatus();
             }
         }
     }
@@ -415,10 +591,24 @@ public final ValidationStatus performValidation() {
     protected Collection<ValidationResult> computeValidationErrors(final ValidationContext validationContext) {
         Throwable failureCause = null;
         try {
+            final List<ValidationResult> invalidParameterResults = validateParameterReferences(validationContext);
+            if (!invalidParameterResults.isEmpty()) {
+                // At this point, we are not able to properly resolve all property values, so we will not attempt to perform
+                // any further validation. Doing so would result in values being reported as invalid and containing confusing explanations.
+                return invalidParameterResults;
+            }
+
+            final List<ValidationResult> validationResults = new ArrayList<>();
             final Collection<ValidationResult> results = getComponent().validate(validationContext);
-            logger.debug("Computed validation errors with Validation Context {}; results = {}", validationContext, results);
+            validationResults.addAll(results);
 
-            return results;
+            // validate selected controller services implement the API required by the processor
+            final Collection<ValidationResult> referencedServiceValidationResults = validateReferencedControllerServices(validationContext);
+            validationResults.addAll(referencedServiceValidationResults);
+
+            logger.debug("Computed validation errors with Validation Context {}; results = {}", validationContext, validationResults);
+
+            return validationResults;
         } catch (final ControllerServiceDisabledException e) {
             getLogger().debug("Failed to perform validation due to " + e, e);
             return Collections.singleton(
@@ -441,6 +631,40 @@ protected Collection<ValidationResult> computeValidationErrors(final ValidationC
             .build());
     }
 
+    private List<ValidationResult> validateParameterReferences(final ValidationContext validationContext) {
+        final List<ValidationResult> results = new ArrayList<>();
+
+        final ParameterContext parameterContext = getParameterContext();
+        final boolean assignedToProcessGroup = getProcessGroupIdentifier() != null;
+
+        for (final PropertyDescriptor propertyDescriptor : validationContext.getProperties().keySet()) {
+            final Collection<String> referencedParameters = validationContext.getReferencedParameters(propertyDescriptor.getName());
+
+            if (parameterContext == null && !referencedParameters.isEmpty()) {
+                results.add(new ValidationResult.Builder()
+                    .subject(propertyDescriptor.getDisplayName())
+                    .valid(false)
+                    .explanation(assignedToProcessGroup ? "Property references one or more Parameters but no Parameter Context is currently set on the Process Group"
+                        : "Property references one or more Parameters, but Parameters may be referenced only by Processors and Controller Services that reside within a Process Group.")
+                    .build());
+
+                continue;
+            }
+
+            for (final String paramName : referencedParameters) {
+                if (!validationContext.isParameterDefined(paramName)) {
+                    results.add(new ValidationResult.Builder()
+                        .subject(propertyDescriptor.getDisplayName())
+                        .valid(false)
+                        .explanation("Property references Parameter '" + paramName + "' but the currently selected Parameter Context does not have a Parameter with that name")
+                        .build());
+                }
+            }
+        }
+
+        return results;
+    }
+
     protected final Collection<ValidationResult> validateReferencedControllerServices(final ValidationContext validationContext) {
         final List<PropertyDescriptor> supportedDescriptors = getComponent().getPropertyDescriptors();
         if (supportedDescriptors == null) {
@@ -628,7 +852,8 @@ private boolean replaceValidationState(final ValidationState expectedState, fina
         }
     }
 
-    protected void resetValidationState() {
+    @Override
+    public void resetValidationState() {
         lock.lock();
         try {
             validationContext = null;
@@ -728,8 +953,7 @@ protected ValidationContext getValidationContext() {
                 return context;
             }
 
-            final Map<PropertyDescriptor, String> properties = getProperties();
-            context = getValidationContextFactory().newValidationContext(properties, getAnnotationData(), getProcessGroupIdentifier(), getIdentifier());
+            context = getValidationContextFactory().newValidationContext(getProperties(), getAnnotationData(), getProcessGroupIdentifier(), getIdentifier(), getParameterContext());
 
             this.validationContext = context;
             logger.debug("Updating validation context to {}", context);
@@ -772,4 +996,6 @@ protected void setAdditionalResourcesFingerprint(String additionalResourcesFinge
         this.additionalResourcesFingerprint = additionalResourcesFingerprint;
     }
 
+    protected abstract ParameterContext getParameterContext();
+
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/ComponentNode.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/ComponentNode.java
index 2357d41cd0c..c8b779c45ff 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/ComponentNode.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/ComponentNode.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.controller;
 
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.authorization.AccessDeniedException;
 import org.apache.nifi.authorization.AuthorizationResult;
 import org.apache.nifi.authorization.AuthorizationResult.Result;
@@ -28,8 +29,11 @@
 import org.apache.nifi.bundle.BundleCoordinate;
 import org.apache.nifi.components.ConfigurableComponent;
 import org.apache.nifi.components.PropertyDescriptor;
+import org.apache.nifi.components.ValidationContext;
 import org.apache.nifi.components.ValidationResult;
+import org.apache.nifi.components.validation.ValidationState;
 import org.apache.nifi.components.validation.ValidationStatus;
+import org.apache.nifi.parameter.ParameterContext;
 import org.apache.nifi.registry.ComponentVariableRegistry;
 
 import java.net.URL;
@@ -58,6 +62,15 @@ public default void setProperties(Map<String, String> properties) {
 
     public void setProperties(Map<String, String> properties, boolean allowRemovalOfRequiredProperties);
 
+    void verifyCanUpdateProperties(final Map<String, String> properties);
+
+    /**
+     * @return the Set of names of all Parameters that are referenced by this component
+     */
+    Set<String> getReferencedParameterNames();
+
+    boolean isReferencingParameter();
+
     /**
      * <p>
      * Pause triggering asynchronous validation to occur when the component is updated. Often times, it is necessary
@@ -91,9 +104,17 @@ public default void setProperties(Map<String, String> properties) {
      */
     void resumeValidationTrigger();
 
-    public Map<PropertyDescriptor, String> getProperties();
+    Map<PropertyDescriptor, String> getRawPropertyValues();
+
+    Map<PropertyDescriptor, String> getEffectivePropertyValues();
+
+    PropertyConfiguration getProperty(PropertyDescriptor property);
+
+    String getEffectivePropertyValue(PropertyDescriptor property);
+
+    String getRawPropertyValue(PropertyDescriptor property);
 
-    public String getProperty(final PropertyDescriptor property);
+    Map<PropertyDescriptor, PropertyConfiguration> getProperties();
 
     void reload(Set<URL> additionalUrls) throws Exception;
 
@@ -115,6 +136,8 @@ public default void setProperties(Map<String, String> properties) {
 
     void reloadAdditionalResourcesIfNecessary();
 
+    void resetValidationState();
+
     /**
      * @return the any validation errors for this connectable
      */
@@ -177,9 +200,25 @@ public default void setProperties(Map<String, String> properties) {
     public abstract ValidationStatus getValidationStatus(long timeout, TimeUnit unit);
 
     /**
-     * Asynchronously begins the validation process
+     * Validates the component against the current configuration
+     */
+    ValidationStatus performValidation();
+
+    /**
+     * Validates the component against the given ValidationContext
+     * @param validationContext the validation context to validate against
+     * @return the ValidationState that is the result of validating against the given context
      */
-    public abstract ValidationStatus performValidation();
+    ValidationState performValidation(ValidationContext validationContext);
+
+    /**
+     * Performs validation against the given set of properties, annotation data, and parameters
+     * @param properties the processor configuration
+     * @param annotationData the annotation data
+     * @param parameterContext the set of parameters
+     * @return the validation state that results from validating against the given values
+     */
+    ValidationState performValidation(Map<PropertyDescriptor, PropertyConfiguration> properties, String annotationData, ParameterContext parameterContext);
 
     /**
      * Returns a {@link List} of all {@link PropertyDescriptor}s that this
@@ -231,4 +270,6 @@ default void authorize(Authorizer authorizer, RequestAction action, NiFiUser use
         // defer to the base authorization check
         ComponentAuthorizable.super.authorize(authorizer, action, user, resourceContext);
     }
+
+    ParameterLookup getParameterLookup();
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/ProcessorNode.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/ProcessorNode.java
index 12eeb88f23b..9601fe590d3 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/ProcessorNode.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/ProcessorNode.java
@@ -40,6 +40,7 @@
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Supplier;
 
 public abstract class ProcessorNode extends AbstractComponentNode implements Connectable {
 
@@ -185,8 +186,8 @@ public ScheduledState getPhysicalScheduledState() {
      *            the amount of milliseconds to wait for administrative yield
      * @param timeoutMillis the number of milliseconds to wait after triggering the Processor's @OnScheduled methods before timing out and considering
      * the startup a failure. This will result in the thread being interrupted and trying again.
-     * @param processContext
-     *            the instance of {@link ProcessContext}
+     * @param processContextFactory
+     *            a factory for creating instances of {@link ProcessContext}
      * @param schedulingAgentCallback
      *            the callback provided by the {@link ProcessScheduler} to
      *            execute upon successful start of the Processor
@@ -195,7 +196,7 @@ public ScheduledState getPhysicalScheduledState() {
      *            value is <code>true</code> or if the Processor is in any state other than 'STOPPING' or 'RUNNING', then this method
      *            will throw an {@link IllegalStateException}.
      */
-    public abstract void start(ScheduledExecutorService scheduler, long administrativeYieldMillis, long timeoutMillis, ProcessContext processContext,
+    public abstract void start(ScheduledExecutorService scheduler, long administrativeYieldMillis, long timeoutMillis, Supplier<ProcessContext> processContextFactory,
                                SchedulingAgentCallback schedulingAgentCallback, boolean failIfStopping);
 
     /**
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/PropertyConfiguration.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/PropertyConfiguration.java
new file mode 100644
index 00000000000..9121d02c300
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/PropertyConfiguration.java
@@ -0,0 +1,125 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.controller;
+
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterReference;
+import org.apache.nifi.parameter.ParameterTokenList;
+import org.apache.nifi.parameter.StandardParameterTokenList;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Objects;
+import java.util.concurrent.atomic.AtomicReference;
+
+public class PropertyConfiguration {
+    public static PropertyConfiguration EMPTY = new PropertyConfiguration(null, new StandardParameterTokenList(null, Collections.emptyList()), Collections.emptyList());
+
+    private final String rawValue;
+    private final ParameterTokenList parameterTokenList;
+    private final List<ParameterReference> parameterReferences;
+    private final AtomicReference<ComputedEffectiveValue> effectiveValue = new AtomicReference<>();
+
+    public PropertyConfiguration(final String rawValue, final ParameterTokenList tokenList, final List<ParameterReference> parameterReferences) {
+        this.rawValue = rawValue;
+        this.parameterTokenList = tokenList;
+        this.parameterReferences = parameterReferences;
+    }
+
+    public String getRawValue() {
+        return rawValue;
+    }
+
+    public String getEffectiveValue(final ParameterContext parameterContext) {
+        if (rawValue == null) {
+            return null;
+        }
+
+        if (parameterTokenList == null) {
+            return rawValue;
+        }
+
+        // We don't want to perform the substitution every time this method is called. But we can't just always
+        // cache the Effective Value because we may have a different Parameter Context. So, we cache a Tuple of
+        // the Parameter Context and the effective value for that Parameter Context.
+        final ComputedEffectiveValue computedEffectiveValue = effectiveValue.get();
+        if (computedEffectiveValue != null && computedEffectiveValue.matches(parameterContext)) {
+            return computedEffectiveValue.getValue();
+        }
+
+        final String substituted = parameterTokenList.substitute(parameterContext);
+        final ComputedEffectiveValue updatedValue = new ComputedEffectiveValue(parameterContext, substituted);
+        effectiveValue.compareAndSet(computedEffectiveValue, updatedValue);
+        return substituted;
+    }
+
+    public List<ParameterReference> getParameterReferences() {
+        return parameterReferences;
+    }
+
+    @Override
+    public boolean equals(final Object o) {
+        if (this == o) {
+            return true;
+        }
+
+        if (o == null) {
+            return false;
+        }
+
+        if (!(o instanceof PropertyConfiguration)) {
+            return false;
+        }
+
+        final PropertyConfiguration that = (PropertyConfiguration) o;
+        return Objects.equals(rawValue, that.rawValue);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(rawValue);
+    }
+
+
+    public static class ComputedEffectiveValue {
+        private final ParameterContext parameterContext;
+        private final long contextVersion;
+        private final String value;
+
+        public ComputedEffectiveValue(final ParameterContext parameterContext, final String value) {
+            this.parameterContext = parameterContext;
+            this.contextVersion = parameterContext == null ? -1 : parameterContext.getVersion();
+            this.value = value;
+        }
+
+        public String getValue() {
+            return value;
+        }
+
+        public boolean matches(final ParameterContext context) {
+            if (!Objects.equals(context, this.parameterContext)) {
+                return false;
+            }
+
+            if (context == null) {
+                return true;
+            }
+
+            return context.getVersion() == contextVersion;
+        }
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/ValidationContextFactory.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/ValidationContextFactory.java
index 1f17d39d3e5..a0a2a86e2b8 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/ValidationContextFactory.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/ValidationContextFactory.java
@@ -16,17 +16,14 @@
  */
 package org.apache.nifi.controller;
 
-import java.util.Map;
-import java.util.Set;
-
 import org.apache.nifi.components.PropertyDescriptor;
 import org.apache.nifi.components.ValidationContext;
+import org.apache.nifi.parameter.ParameterContext;
 
-public interface ValidationContextFactory {
+import java.util.Map;
 
-    ValidationContext newValidationContext(Map<PropertyDescriptor, String> properties, String annotationData, String groupId, String componentId);
+public interface ValidationContextFactory {
 
-    ValidationContext newValidationContext(Set<String> serviceIdentifiersToNotValidate, Map<PropertyDescriptor, String> properties,
-        String annotationData, String groupId, String componentId);
+    ValidationContext newValidationContext(Map<PropertyDescriptor, PropertyConfiguration> properties, String annotationData, String groupId, String componentId, ParameterContext parameterContext);
 
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/flow/FlowManager.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/flow/FlowManager.java
index f2a9cf949f7..4d108e9c8aa 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/flow/FlowManager.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/controller/flow/FlowManager.java
@@ -29,6 +29,9 @@
 import org.apache.nifi.flowfile.FlowFilePrioritizer;
 import org.apache.nifi.groups.ProcessGroup;
 import org.apache.nifi.groups.RemoteProcessGroup;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterContextManager;
 import org.apache.nifi.web.api.dto.FlowSnippetDTO;
 
 import java.net.URL;
@@ -318,4 +321,8 @@ ControllerServiceNode createControllerService(String type, String id, BundleCoor
     ControllerServiceNode getRootControllerService(String serviceIdentifier);
 
     void removeRootControllerService(final ControllerServiceNode service);
+
+    ParameterContext createParameterContext(String id, String name, Set<Parameter> parameters);
+
+    ParameterContextManager getParameterContextManager();
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/groups/ProcessGroup.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/groups/ProcessGroup.java
index a5edfdd5c27..1c628bd46a3 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/groups/ProcessGroup.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/groups/ProcessGroup.java
@@ -29,9 +29,11 @@
 import org.apache.nifi.controller.ScheduledState;
 import org.apache.nifi.controller.Snippet;
 import org.apache.nifi.controller.Template;
+import org.apache.nifi.controller.Triggerable;
 import org.apache.nifi.controller.label.Label;
 import org.apache.nifi.controller.service.ControllerServiceNode;
 import org.apache.nifi.flowfile.FlowFile;
+import org.apache.nifi.parameter.ParameterContext;
 import org.apache.nifi.processor.Processor;
 import org.apache.nifi.registry.ComponentVariableRegistry;
 import org.apache.nifi.registry.flow.FlowRegistryClient;
@@ -65,7 +67,7 @@ public interface ProcessGroup extends ComponentAuthorizable, Positionable, Versi
     /**
      * Predicate for stopping eligible Processors.
      */
-    Predicate<ProcessorNode> STOP_PROCESSORS_FILTER = node -> node.isRunning();
+    Predicate<ProcessorNode> STOP_PROCESSORS_FILTER = Triggerable::isRunning;
 
     /**
      * Predicate for enabling eligible Processors.
@@ -385,7 +387,7 @@ public interface ProcessGroup extends ComponentAuthorizable, Positionable, Versi
      * Removes the given processor from this group, destroying the Processor.
      * The Processor is removed from the ProcessorRegistry, and any method in
      * the Processor that is annotated with the
-     * {@link org.apache.nifi.processor.annotation.OnRemoved OnRemoved} annotation will be
+     * {@link org.apache.nifi.annotation.lifecycle.OnRemoved OnRemoved} annotation will be
      * invoked. All outgoing connections will also be destroyed
      *
      * @param processor the Processor to remove
@@ -583,6 +585,14 @@ public interface ProcessGroup extends ComponentAuthorizable, Positionable, Versi
      */
     List<ProcessGroup> findAllProcessGroups();
 
+    /**
+     * Returns a List of all ProcessGroups that match the given filter. This performs a recursive search of all descendant Process Groups.
+     *
+     * @param filter the filter to match Process Groups against
+     * @return a List of all ProcessGroups that are children or descendants of this ProcessGroup and that match the given filter.
+     */
+    List<ProcessGroup> findAllProcessGroups(Predicate<ProcessGroup> filter);
+
     /**
      * @param id of the group
      * @return the RemoteProcessGroup with the given ID, if it exists as a child
@@ -1002,4 +1012,29 @@ public interface ProcessGroup extends ComponentAuthorizable, Positionable, Versi
      * Called whenever a component within this group or the group itself is modified
      */
     void onComponentModified();
+
+    /**
+     * Updates the Parameter Context that is to be used by this Process Group
+     * @param parameterContext the new Parameter Context to use
+     */
+    void setParameterContext(ParameterContext parameterContext);
+
+    /**
+     * Returns the ParameterContext that is associated with this Process Group
+     * @return Returns the ParameterContext that is associated with this Process Group, or <code>null</code> if no Parameter Context has been set
+     */
+    ParameterContext getParameterContext();
+
+    /**
+     * Ensures that a new Parameter Context can be set.
+     *
+     * @param parameterContext the new Parameter Context to set
+     * @throws IllegalStateException if unable to set the Parameter Context at this point in time
+     */
+    void verifyCanSetParameterContext(ParameterContext parameterContext);
+
+    /**
+     * Called to notify the Process Group whenever the Parameter Context that it is bound to has changed.
+     */
+    void onParameterContextUpdated();
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/parameter/ParameterContext.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/parameter/ParameterContext.java
new file mode 100644
index 00000000000..dae4d9e22d3
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/parameter/ParameterContext.java
@@ -0,0 +1,100 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import org.apache.nifi.authorization.resource.Authorizable;
+
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+
+public interface ParameterContext extends ParameterLookup, Authorizable {
+
+    /**
+     * @return the UUID for this Parameter Context
+     */
+    String getIdentifier();
+
+    /**
+     * @return the name of the Parameter Context
+     */
+    String getName();
+
+    /**
+     * Sets the name of the Parameter Context
+     * @param name the name of the Parameter Context
+     */
+    void setName(String name);
+
+    /**
+     * @return a user-supplied description for the Parameter Context
+     */
+    String getDescription();
+
+    /**
+     * Sets the description for the Parameter Context
+     * @param description the description
+     */
+    void setDescription(String description);
+
+    /**
+     * Updates the Parameters within this context to match the given set of Parameters.
+     * @param updatedParameters the updated set of parameters
+     * @throws IllegalStateException if any parameter is modified or removed and that parameter is being referenced by a running Processor or an enabled Controller Service, or if
+     * an update would result in changing the sensitivity of any parameter
+     */
+    void setParameters(Set<Parameter> updatedParameters);
+
+    /**
+     * Ensures that it is legal to update the Parameters for this Parameter Context to match the given set of Parameters
+     * @param parameters the Set of Parameters that are to become the new Parameters for this Parameter Context
+     * @throws IllegalStateException if setting the given set of Parameters is not legal
+     */
+    void verifyCanSetParameters(Set<Parameter> parameters);
+
+
+    /**
+     * Returns the Parameter with the given descriptor
+     *
+     * @param parameterDescriptor descriptor for the parameter
+     * @return the Parameter with the given name, or <code>null</code> if no parameter exists with the given descriptor
+     */
+    Optional<Parameter> getParameter(ParameterDescriptor parameterDescriptor);
+
+    /**
+     * Returns the Map of all Parameters in this context. Note that the Map that is returned may either be immutable or may be a defensive copy but
+     * modifying the Map that is returned will have no effect on the contents of this Parameter Context.
+     *
+     * @return a Map that contains all Parameters in the context keyed by their descriptors
+     */
+    Map<ParameterDescriptor, Parameter> getParameters();
+
+    /**
+     * Returns the ParameterReferenceManager that is associated with this ParameterContext
+     * @return the ParameterReferenceManager that is associated with this ParameterContext
+     */
+    ParameterReferenceManager getParameterReferenceManager();
+
+    /**
+     * Indicates the current Version of the Parameter Context. Each time that the Parameter Context is updated, its version is incremented. This allows
+     * other components to know whether or not the values have changed since some other point in time. The version may or may not be persisted across
+     * restarts of the application.
+     *
+     * @return the current version
+     */
+    long getVersion();
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/parameter/ParameterContextManager.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/parameter/ParameterContextManager.java
new file mode 100644
index 00000000000..a0ab6c466ae
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/parameter/ParameterContextManager.java
@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import java.util.Set;
+
+public interface ParameterContextManager {
+    ParameterContext getParameterContext(String id);
+
+    void addParameterContext(ParameterContext parameterContext);
+
+    ParameterContext removeParameterContext(String parameterContextId);
+
+    Set<ParameterContext> getParameterContexts();
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/parameter/ParameterReferenceManager.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/parameter/ParameterReferenceManager.java
new file mode 100644
index 00000000000..c1f724e771d
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/parameter/ParameterReferenceManager.java
@@ -0,0 +1,72 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import org.apache.nifi.controller.ProcessorNode;
+import org.apache.nifi.controller.service.ControllerServiceNode;
+import org.apache.nifi.groups.ProcessGroup;
+
+import java.util.Collections;
+import java.util.Set;
+
+/**
+ * A component that is responsible for tracking which components reference each Parameter
+ */
+public interface ParameterReferenceManager {
+
+    /**
+     * Returns the set of all Processors in the flow that reference the parameter with the given name
+     *
+     * @param  parameterContext the Parameter Context that the parameter belongs to
+     * @param parameterName the name of the parameter
+     * @return the set of all Processors in the flow that reference the parameter with the given name
+     */
+    Set<ProcessorNode> getProcessorsReferencing(ParameterContext parameterContext, String parameterName);
+
+    /**
+     * Returns the set of all ControllerServices in the flow that reference the parameter with the given name
+     *
+     * @param  parameterContext the Parameter Context that the parameter belongs to
+     * @param parameterName the name of the parameter
+     * @return the set of all ControllerServices in the flow that reference the parameter with the given name
+     */
+    Set<ControllerServiceNode> getControllerServicesReferencing(ParameterContext parameterContext, String parameterName);
+
+    /**
+     * Returns the set of all Process Groups that are bound to the given Parameter Context
+     * @param parameterContext the Parameter Context
+     * @return the set of all Process Groups that are bound to the given Parameter Context
+     */
+    Set<ProcessGroup> getProcessGroupsBound(ParameterContext parameterContext);
+
+    ParameterReferenceManager EMPTY = new ParameterReferenceManager() {
+        @Override
+        public Set<ProcessorNode> getProcessorsReferencing(final ParameterContext parameterContext, final String parameterName) {
+            return Collections.emptySet();
+        }
+
+        @Override
+        public Set<ControllerServiceNode> getControllerServicesReferencing(final ParameterContext parameterContext, final String parameterName) {
+            return Collections.emptySet();
+        }
+
+        @Override
+        public Set<ProcessGroup> getProcessGroupsBound(final ParameterContext parameterContext) {
+            return Collections.emptySet();
+        }
+    };
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/registry/flow/FlowRegistry.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/registry/flow/FlowRegistry.java
index 9821eaf112e..92fc8a1cbdc 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/registry/flow/FlowRegistry.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/main/java/org/apache/nifi/registry/flow/FlowRegistry.java
@@ -23,6 +23,7 @@
 
 import java.io.IOException;
 import java.util.Map;
+import java.util.Collection;
 import java.util.Set;
 
 public interface FlowRegistry {
@@ -133,6 +134,7 @@ public interface FlowRegistry {
      * @param snapshot the snapshot of the flow
      * @param externalControllerServices a mapping of of Controller Service identifier to ExternalControllerServiceReference for any Controller Service that is referenced by the flow but that are
      * not included as part of the VersionedProcessGroup
+     * @param parameterContexts the Parameter Contexts to include in the snapshot
      * @param comments any comments for the snapshot
      * @param expectedVersion the version of the flow that we expect to save this snapshot as
      * @return the versioned flow snapshot
@@ -141,7 +143,8 @@ public interface FlowRegistry {
      * @throws NullPointerException if the VersionedFlow is null, or if its bucket identifier is null, or if the flow to snapshot is null
      * @throws NiFiRegistryException if the flow does not exist
      */
-    VersionedFlowSnapshot registerVersionedFlowSnapshot(VersionedFlow flow, VersionedProcessGroup snapshot, Map<String, ExternalControllerServiceReference> externalControllerServices, String comments,
+    VersionedFlowSnapshot registerVersionedFlowSnapshot(VersionedFlow flow, VersionedProcessGroup snapshot, Map<String, ExternalControllerServiceReference> externalControllerServices,
+                                                        Collection<VersionedParameterContext> parameterContexts, String comments,
                                                         int expectedVersion, NiFiUser user) throws IOException, NiFiRegistryException;
 
     /**
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/test/java/org/apache/nifi/controller/TestAbstractComponentNode.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/test/java/org/apache/nifi/controller/TestAbstractComponentNode.java
index 49dfb8b612e..687d347f10e 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/test/java/org/apache/nifi/controller/TestAbstractComponentNode.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core-api/src/test/java/org/apache/nifi/controller/TestAbstractComponentNode.java
@@ -17,15 +17,7 @@
 
 package org.apache.nifi.controller;
 
-import static org.junit.Assert.assertEquals;
-
-import java.net.URL;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Set;
-import java.util.concurrent.TimeUnit;
-import java.util.concurrent.atomic.AtomicLong;
-
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.authorization.Resource;
 import org.apache.nifi.authorization.resource.Authorizable;
 import org.apache.nifi.bundle.BundleCoordinate;
@@ -36,10 +28,20 @@
 import org.apache.nifi.components.validation.ValidationTrigger;
 import org.apache.nifi.controller.service.ControllerServiceProvider;
 import org.apache.nifi.nar.StandardExtensionDiscoveringManager;
+import org.apache.nifi.parameter.ParameterContext;
 import org.apache.nifi.registry.ComponentVariableRegistry;
 import org.junit.Test;
 import org.mockito.Mockito;
 
+import java.net.URL;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Set;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
+
+import static org.junit.Assert.assertEquals;
+
 public class TestAbstractComponentNode {
 
     @Test(timeout = 5000)
@@ -140,6 +142,11 @@ public boolean isValidationNecessary() {
             return true;
         }
 
+        @Override
+        public ParameterLookup getParameterLookup() {
+            return ParameterLookup.EMPTY;
+        }
+
         @Override
         public String getProcessGroupIdentifier() {
             return "1234";
@@ -158,5 +165,10 @@ public Resource getResource() {
         @Override
         public void verifyModifiable() throws IllegalStateException {
         }
+
+        @Override
+        protected ParameterContext getParameterContext() {
+            return null;
+        }
     }
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/FlowController.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/FlowController.java
index b7a5d79ac7a..331e73ee20d 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/FlowController.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/FlowController.java
@@ -22,6 +22,7 @@
 import org.apache.nifi.annotation.lifecycle.OnShutdown;
 import org.apache.nifi.annotation.notification.OnPrimaryNodeStateChange;
 import org.apache.nifi.annotation.notification.PrimaryNodeState;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.authorization.Authorizer;
 import org.apache.nifi.authorization.Resource;
 import org.apache.nifi.authorization.resource.Authorizable;
@@ -137,6 +138,8 @@
 import org.apache.nifi.nar.ExtensionManager;
 import org.apache.nifi.nar.NarCloseable;
 import org.apache.nifi.nar.NarThreadContextClassLoader;
+import org.apache.nifi.parameter.ParameterContextManager;
+import org.apache.nifi.parameter.StandardParameterContextManager;
 import org.apache.nifi.processor.Processor;
 import org.apache.nifi.processor.Relationship;
 import org.apache.nifi.provenance.ComponentIdentifierLookup;
@@ -294,6 +297,7 @@ public class FlowController implements ReportingTaskProvider, Authorizable, Node
     private final ReloadComponent reloadComponent;
     private final ProvenanceAuthorizableFactory provenanceAuthorizableFactory;
     private final UserAwareEventAccess eventAccess;
+    private final ParameterContextManager parameterContextManager;
     private final StandardFlowManager flowManager;
     private final RepositoryContextFactory repositoryContextFactory;
 
@@ -478,7 +482,7 @@ private FlowController(
         }
 
         try {
-            this.stateManagerProvider = StandardStateManagerProvider.create(nifiProperties, this.variableRegistry, extensionManager);
+            this.stateManagerProvider = StandardStateManagerProvider.create(nifiProperties, this.variableRegistry, extensionManager, ParameterLookup.EMPTY);
         } catch (final IOException e) {
             throw new RuntimeException(e);
         }
@@ -486,8 +490,9 @@ private FlowController(
         processScheduler = new StandardProcessScheduler(timerDrivenEngineRef.get(), this, encryptor, stateManagerProvider, this.nifiProperties);
         eventDrivenWorkerQueue = new EventDrivenWorkerQueue(false, false, processScheduler);
 
+        parameterContextManager = new StandardParameterContextManager();
         repositoryContextFactory = new RepositoryContextFactory(contentRepository, flowFileRepository, flowFileEventRepository, counterRepositoryRef.get(), provenanceRepository);
-        this.flowManager = new StandardFlowManager(nifiProperties, sslContext, this, flowFileEventRepository);
+        flowManager = new StandardFlowManager(nifiProperties, sslContext, this, flowFileEventRepository, parameterContextManager);
 
         controllerServiceProvider = new StandardControllerServiceProvider(this, processScheduler, bulletinRepository);
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/StandardFlowSnippet.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/StandardFlowSnippet.java
index d466c9c8a1f..c18522dfe0e 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/StandardFlowSnippet.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/StandardFlowSnippet.java
@@ -36,6 +36,7 @@
 import org.apache.nifi.groups.RemoteProcessGroupPortDescriptor;
 import org.apache.nifi.logging.LogLevel;
 import org.apache.nifi.nar.ExtensionManager;
+import org.apache.nifi.parameter.ParameterContext;
 import org.apache.nifi.processor.Processor;
 import org.apache.nifi.processor.Relationship;
 import org.apache.nifi.registry.flow.StandardVersionControlInformation;
@@ -55,6 +56,7 @@
 import org.apache.nifi.web.api.dto.FlowSnippetDTO;
 import org.apache.nifi.web.api.dto.FunnelDTO;
 import org.apache.nifi.web.api.dto.LabelDTO;
+import org.apache.nifi.web.api.dto.ParameterContextReferenceDTO;
 import org.apache.nifi.web.api.dto.PortDTO;
 import org.apache.nifi.web.api.dto.PositionDTO;
 import org.apache.nifi.web.api.dto.ProcessGroupDTO;
@@ -456,6 +458,14 @@ public void instantiate(final FlowManager flowManager, final ProcessGroup group,
                 childGroup.setVariables(groupDTO.getVariables());
             }
 
+            final ParameterContextReferenceDTO parameterContextReferenceDto = groupDTO.getParameterContext();
+            if (parameterContextReferenceDto != null) {
+                final ParameterContext parameterContext = flowManager.getParameterContextManager().getParameterContext(parameterContextReferenceDto.getId());
+                if (parameterContext != null) {
+                    childGroup.setParameterContext(parameterContext);
+                }
+            }
+
             // If this Process Group is 'top level' then we do not set versioned component ID's.
             // We do this only if this component is the child of a Versioned Component.
             if (!topLevel) {
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/StandardFlowSynchronizer.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/StandardFlowSynchronizer.java
index f9e88834881..a2c8d4cfe73 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/StandardFlowSynchronizer.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/StandardFlowSynchronizer.java
@@ -58,6 +58,10 @@
 import org.apache.nifi.groups.RemoteProcessGroupPortDescriptor;
 import org.apache.nifi.logging.LogLevel;
 import org.apache.nifi.nar.ExtensionManager;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterContextManager;
+import org.apache.nifi.parameter.ParameterDescriptor;
 import org.apache.nifi.processor.Relationship;
 import org.apache.nifi.registry.flow.FlowRegistry;
 import org.apache.nifi.registry.flow.FlowRegistryClient;
@@ -81,6 +85,9 @@
 import org.apache.nifi.web.api.dto.FlowSnippetDTO;
 import org.apache.nifi.web.api.dto.FunnelDTO;
 import org.apache.nifi.web.api.dto.LabelDTO;
+import org.apache.nifi.web.api.dto.ParameterContextDTO;
+import org.apache.nifi.web.api.dto.ParameterContextReferenceDTO;
+import org.apache.nifi.web.api.dto.ParameterDTO;
 import org.apache.nifi.web.api.dto.PortDTO;
 import org.apache.nifi.web.api.dto.PositionDTO;
 import org.apache.nifi.web.api.dto.ProcessGroupDTO;
@@ -90,6 +97,7 @@
 import org.apache.nifi.web.api.dto.ReportingTaskDTO;
 import org.apache.nifi.web.api.dto.TemplateDTO;
 import org.apache.nifi.web.api.dto.VersionControlInformationDTO;
+import org.apache.nifi.web.api.entity.ParameterEntity;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.w3c.dom.Document;
@@ -120,6 +128,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
 import java.util.stream.Collectors;
@@ -152,14 +161,15 @@ public static boolean isEmpty(final DataFlow dataFlow) {
         final Element rootElement = document.getDocumentElement();
 
         final Element rootGroupElement = (Element) rootElement.getElementsByTagName("rootGroup").item(0);
-        final FlowEncodingVersion encodingVersion = FlowEncodingVersion.parse(rootGroupElement);
+        final FlowEncodingVersion encodingVersion = FlowEncodingVersion.parse(rootElement);
         final ProcessGroupDTO rootGroupDto = FlowFromDOMFactory.getProcessGroup(null, rootGroupElement, null, encodingVersion);
 
         final NodeList reportingTasks = rootElement.getElementsByTagName("reportingTask");
-        final ReportingTaskDTO reportingTaskDTO = reportingTasks.getLength() == 0 ? null : FlowFromDOMFactory.getReportingTask((Element)reportingTasks.item(0),null);
+        final ReportingTaskDTO reportingTaskDTO = reportingTasks.getLength() == 0 ? null : FlowFromDOMFactory.getReportingTask((Element)reportingTasks.item(0),null, encodingVersion);
 
         final NodeList controllerServices = rootElement.getElementsByTagName("controllerService");
-        final ControllerServiceDTO controllerServiceDTO = controllerServices.getLength() == 0 ? null : FlowFromDOMFactory.getControllerService((Element)controllerServices.item(0),null);
+        final ControllerServiceDTO controllerServiceDTO = controllerServices.getLength() == 0 ? null :
+            FlowFromDOMFactory.getControllerService((Element)controllerServices.item(0),null, encodingVersion);
 
         return isEmpty(rootGroupDto) && isEmpty(reportingTaskDTO) && isEmpty(controllerServiceDTO);
     }
@@ -193,7 +203,8 @@ public void sync(final FlowController controller, final DataFlow proposedFlow, f
                 existingFlowEmpty = root.isEmpty()
                     && flowManager.getAllReportingTasks().isEmpty()
                     && flowManager.getAllControllerServices().isEmpty()
-                    && controller.getFlowRegistryClient().getRegistryIdentifiers().isEmpty();
+                    && controller.getFlowRegistryClient().getRegistryIdentifiers().isEmpty()
+                    && controller.getFlowManager().getParameterContextManager().getParameterContexts().isEmpty();
             } else {
                 existingFlow = readFlowFromDisk();
                 if (existingFlow == null || existingFlow.length == 0) {
@@ -238,13 +249,23 @@ public void sync(final FlowController controller, final DataFlow proposedFlow, f
                         registriesPresent = !flowRegistryElems.isEmpty();
                     }
 
+                    final boolean parametersPresent;
+                    final Element parameterContextsElement = DomUtils.getChild(rootElement, "parameterContexts");
+                    if (parameterContextsElement == null) {
+                        parametersPresent = false;
+                    } else {
+                        final List<Element> contextList = DomUtils.getChildElementsByTagName(parameterContextsElement, "parameterContext");
+                        parametersPresent = !contextList.isEmpty();
+                    }
+
                     logger.trace("Parsing process group from DOM");
                     final Element rootGroupElement = (Element) rootElement.getElementsByTagName("rootGroup").item(0);
                     final ProcessGroupDTO rootGroupDto = FlowFromDOMFactory.getProcessGroup(null, rootGroupElement, encryptor, encodingVersion);
                     existingFlowEmpty = taskElements.isEmpty()
                         && unrootedControllerServiceElements.isEmpty()
                         && isEmpty(rootGroupDto)
-                        && !registriesPresent;
+                        && !registriesPresent
+                        && !parametersPresent;
                     logger.debug("Existing Flow Empty = {}", existingFlowEmpty);
                 }
             }
@@ -353,6 +374,15 @@ && isEmpty(rootGroupDto)
                                 client.addFlowRegistry(registryId, registryName, registryUrl, description);
                             }
                         }
+
+                        final Element parameterContextsElement = DomUtils.getChild(rootElement, "parameterContexts");
+                        if (parameterContextsElement != null) {
+                            final List<Element> contextElements = DomUtils.getChildElementsByTagName(parameterContextsElement, "parameterContext");
+                            for (final Element contextElement : contextElements) {
+                                final ParameterContextDTO parameterContextDto = FlowFromDOMFactory.getParameterContext(contextElement, encryptor);
+                                createParameterContext(parameterContextDto, controller.getFlowManager());
+                            }
+                        }
                     }
 
                     // if this controller isn't initialized or its empty, add the root group, otherwise update
@@ -391,7 +421,7 @@ && isEmpty(rootGroupDto)
                     // get/create all the reporting task nodes and DTOs, but don't apply their scheduled state yet
                     final Map<ReportingTaskNode, ReportingTaskDTO> reportingTaskNodesToDTOs = new HashMap<>();
                     for (final Element taskElement : reportingTaskElements) {
-                        final ReportingTaskDTO dto = FlowFromDOMFactory.getReportingTask(taskElement, encryptor);
+                        final ReportingTaskDTO dto = FlowFromDOMFactory.getReportingTask(taskElement, encryptor, encodingVersion);
                         final ReportingTaskNode reportingTask = getOrCreateReportingTask(controller, dto, flowAlreadySynchronized, existingFlowEmpty);
                         reportingTaskNodesToDTOs.put(reportingTask, dto);
                     }
@@ -406,14 +436,15 @@ && isEmpty(rootGroupDto)
                             // to the root Group. Otherwise, we want to use a null group, which indicates a Controller-level
                             // Controller Service.
                             final ProcessGroup group = (encodingVersion == null) ? rootGroup : null;
-                            final Map<ControllerServiceNode, Element> controllerServices = ControllerServiceLoader.loadControllerServices(serviceElements, controller, group, encryptor);
+                            final Map<ControllerServiceNode, Element> controllerServices = ControllerServiceLoader.loadControllerServices(
+                                serviceElements, controller, group, encryptor, encodingVersion);
 
                             // If we are moving controller services to the root group we also need to see if any reporting tasks
                             // reference them, and if so we need to clone the CS and update the reporting task reference
                             if (group != null) {
                                 // find all the controller service ids referenced by reporting tasks
                                 final Set<String> controllerServicesInReportingTasks = reportingTaskNodesToDTOs.keySet().stream()
-                                        .flatMap(r -> r.getProperties().entrySet().stream())
+                                        .flatMap(r -> r.getEffectivePropertyValues().entrySet().stream())
                                         .filter(e -> e.getKey().getControllerServiceDefinition() != null)
                                         .map(Map.Entry::getValue)
                                         .collect(Collectors.toSet());
@@ -439,7 +470,7 @@ && isEmpty(rootGroupDto)
                             }
 
                             // enable all the original controller services
-                            ControllerServiceLoader.enableControllerServices(controllerServices, controller, encryptor, autoResumeState);
+                            ControllerServiceLoader.enableControllerServices(controllerServices, controller, encryptor, autoResumeState, encodingVersion);
                         }
                     }
 
@@ -515,12 +546,33 @@ private boolean withinTemplate(final Element element) {
         }
     }
 
+    private ParameterContext createParameterContext(final ParameterContextDTO dto, final FlowManager flowManager) {
+        final Set<Parameter> parameters = dto.getParameters().stream()
+            .map(ParameterEntity::getParameter)
+            .map(this::createParameter)
+            .collect(Collectors.toSet());
+
+        final ParameterContext context = flowManager.createParameterContext(dto.getId(), dto.getName(), parameters);
+        context.setDescription(dto.getDescription());
+        return context;
+    }
+
+    private Parameter createParameter(final ParameterDTO dto) {
+        final ParameterDescriptor parameterDescriptor = new ParameterDescriptor.Builder()
+            .name(dto.getName())
+            .description(dto.getDescription())
+            .sensitive(Boolean.TRUE.equals(dto.getSensitive()))
+            .build();
+
+        return new Parameter(parameterDescriptor, dto.getValue());
+    }
+
     private void updateReportingTaskControllerServices(final Set<ReportingTaskNode> reportingTasks, final Map<String, ControllerServiceNode> controllerServiceMapping) {
         for (ReportingTaskNode reportingTask : reportingTasks) {
             if (reportingTask.getProperties() != null) {
                 reportingTask.pauseValidationTrigger();
                 try {
-                    final Set<Map.Entry<PropertyDescriptor, String>> propertyDescriptors = reportingTask.getProperties().entrySet().stream()
+                    final Set<Map.Entry<PropertyDescriptor, String>> propertyDescriptors = reportingTask.getEffectivePropertyValues().entrySet().stream()
                             .filter(e -> e.getKey().getControllerServiceDefinition() != null)
                             .filter(e -> controllerServiceMapping.containsKey(e.getValue()))
                             .collect(Collectors.toSet());
@@ -581,6 +633,8 @@ private static boolean isEmpty(final ProcessGroupDTO dto) {
             return true;
         }
 
+        final String parameterContextId = dto.getParameterContext() == null ? null : dto.getParameterContext().getId();
+
         return CollectionUtils.isEmpty(contents.getProcessors())
                 && CollectionUtils.isEmpty(contents.getConnections())
                 && CollectionUtils.isEmpty(contents.getFunnels())
@@ -588,7 +642,8 @@ private static boolean isEmpty(final ProcessGroupDTO dto) {
                 && CollectionUtils.isEmpty(contents.getOutputPorts())
                 && CollectionUtils.isEmpty(contents.getProcessGroups())
                 && CollectionUtils.isEmpty(contents.getProcessors())
-                && CollectionUtils.isEmpty(contents.getRemoteProcessGroups());
+                && CollectionUtils.isEmpty(contents.getRemoteProcessGroups())
+                && parameterContextId == null;
     }
 
     private static boolean isEmpty(final ReportingTaskDTO reportingTaskDTO){
@@ -786,15 +841,12 @@ private ProcessGroup updateProcessGroup(final FlowController controller, final P
         }
 
         // update the process group
-        final ProcessGroup group = flowManager.getGroup(processGroupDto.getId());
-        if (group == null) {
+        final ProcessGroup processGroup = flowManager.getGroup(processGroupDto.getId());
+        if (processGroup == null) {
             throw new IllegalStateException("No Group with ID " + processGroupDto.getId() + " exists");
         }
 
-        updateProcessGroup(group, processGroupDto);
-
-        // get the real process group and ID
-        final ProcessGroup processGroup = flowManager.getGroup(processGroupDto.getId());
+        updateProcessGroup(processGroup, processGroupDto, controller.getFlowManager().getParameterContextManager());
 
         // determine the scheduled state of all of the Controller Service
         final List<Element> controllerServiceNodeList = getChildrenByTagName(processGroupElement, "controllerService");
@@ -802,7 +854,7 @@ private ProcessGroup updateProcessGroup(final FlowController controller, final P
         final Set<ControllerServiceNode> toEnable = new HashSet<>();
 
         for (final Element serviceElement : controllerServiceNodeList) {
-            final ControllerServiceDTO dto = FlowFromDOMFactory.getControllerService(serviceElement, encryptor);
+            final ControllerServiceDTO dto = FlowFromDOMFactory.getControllerService(serviceElement, encryptor, encodingVersion);
             final ControllerServiceNode serviceNode = processGroup.getControllerService(dto.getId());
 
             // Check if the controller service is in the correct state. We consider it the correct state if
@@ -833,7 +885,7 @@ private ProcessGroup updateProcessGroup(final FlowController controller, final P
         // processors & ports cannot be updated - they must be the same. Except for the scheduled state.
         final List<Element> processorNodeList = getChildrenByTagName(processGroupElement, "processor");
         for (final Element processorElement : processorNodeList) {
-            final ProcessorDTO dto = FlowFromDOMFactory.getProcessor(processorElement, encryptor);
+            final ProcessorDTO dto = FlowFromDOMFactory.getProcessor(processorElement, encryptor, encodingVersion);
             final ProcessorNode procNode = processGroup.getProcessor(dto.getId());
 
             final ScheduledState procState = getScheduledState(procNode, controller);
@@ -1093,7 +1145,7 @@ private ProcessGroup updateProcessGroup(final FlowController controller, final P
      *
      * @throws NullPointerException if the DTO or its ID is null
      */
-    private void updateProcessGroup(final ProcessGroup group, final ProcessGroupDTO dto) {
+    private void updateProcessGroup(final ProcessGroup group, final ProcessGroupDTO dto, final ParameterContextManager parameterContextManager) {
         final String name = dto.getName();
         final PositionDTO position = dto.getPosition();
         final String comments = dto.getComments();
@@ -1107,6 +1159,16 @@ private void updateProcessGroup(final ProcessGroup group, final ProcessGroupDTO
         if (comments != null) {
             group.setComments(comments);
         }
+
+        final ParameterContextReferenceDTO parameterContextReference = dto.getParameterContext();
+        if (parameterContextReference != null && parameterContextReference.getId() != null) {
+            final String parameterContextId = parameterContextReference.getId();
+            final ParameterContext parameterContext = parameterContextManager.getParameterContext(parameterContextId);
+            if (!Objects.equals(parameterContext, group.getParameterContext())) {
+                group.setParameterContext(parameterContext);
+            }
+        }
+
     }
 
     private <T extends Connectable & Triggerable> ScheduledState getScheduledState(final T component, final FlowController flowController) {
@@ -1205,6 +1267,12 @@ private ProcessGroup addProcessGroup(final FlowController controller, final Proc
             parentGroup.addProcessGroup(processGroup);
         }
 
+        final String parameterContextId = getString(processGroupElement, "parameterContextId");
+        if (parameterContextId != null) {
+            final ParameterContext parameterContext = controller.getFlowManager().getParameterContextManager().getParameterContext(parameterContextId);
+            processGroup.setParameterContext(parameterContext);
+        }
+
         // Set the variables for the variable registry
         final Map<String, String> variables = new HashMap<>();
         final List<Element> variableElements = getChildrenByTagName(processGroupElement, "variable");
@@ -1238,14 +1306,14 @@ private ProcessGroup addProcessGroup(final FlowController controller, final Proc
         // Add Controller Services
         final List<Element> serviceNodeList = getChildrenByTagName(processGroupElement, "controllerService");
         if (!serviceNodeList.isEmpty()) {
-            final Map<ControllerServiceNode, Element> controllerServices = ControllerServiceLoader.loadControllerServices(serviceNodeList, controller, processGroup, encryptor);
-            ControllerServiceLoader.enableControllerServices(controllerServices, controller, encryptor, autoResumeState);
+            final Map<ControllerServiceNode, Element> controllerServices = ControllerServiceLoader.loadControllerServices(serviceNodeList, controller, processGroup, encryptor, encodingVersion);
+            ControllerServiceLoader.enableControllerServices(controllerServices, controller, encryptor, autoResumeState, encodingVersion);
         }
 
         // add processors
         final List<Element> processorNodeList = getChildrenByTagName(processGroupElement, "processor");
         for (final Element processorElement : processorNodeList) {
-            final ProcessorDTO processorDTO = FlowFromDOMFactory.getProcessor(processorElement, encryptor);
+            final ProcessorDTO processorDTO = FlowFromDOMFactory.getProcessor(processorElement, encryptor, encodingVersion);
 
             BundleCoordinate coordinate;
             try {
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/StandardProcessorNode.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/StandardProcessorNode.java
index f8cbd61c939..92805e7833b 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/StandardProcessorNode.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/StandardProcessorNode.java
@@ -56,6 +56,8 @@
 import org.apache.nifi.logging.LogRepositoryFactory;
 import org.apache.nifi.nar.ExtensionManager;
 import org.apache.nifi.nar.NarCloseable;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.processor.ProcessContext;
 import org.apache.nifi.processor.ProcessSessionFactory;
 import org.apache.nifi.processor.Processor;
@@ -99,6 +101,7 @@
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.Function;
+import java.util.function.Supplier;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
@@ -1013,9 +1016,10 @@ public boolean isRunning() {
 
     @Override
     public boolean isValidationNecessary() {
-        switch (getScheduledState()) {
+        switch (getPhysicalScheduledState()) {
             case STOPPED:
             case STOPPING:
+            case STARTING:
                 return true;
         }
 
@@ -1145,6 +1149,17 @@ public ProcessGroup getProcessGroup() {
         return processGroup.get();
     }
 
+    @Override
+    protected ParameterContext getParameterContext() {
+        final ProcessGroup processGroup = getProcessGroup();
+        return processGroup == null ? null : processGroup.getParameterContext();
+    }
+
+    @Override
+    public ParameterLookup getParameterLookup() {
+        return getParameterContext();
+    }
+
     @Override
     public synchronized void setProcessGroup(final ProcessGroup group) {
         this.processGroup.set(group);
@@ -1341,7 +1356,7 @@ public void disable() {
      * </p>
      */
     @Override
-    public void start(final ScheduledExecutorService taskScheduler, final long administrativeYieldMillis, final long timeoutMillis, final ProcessContext processContext,
+    public void start(final ScheduledExecutorService taskScheduler, final long administrativeYieldMillis, final long timeoutMillis, final Supplier<ProcessContext> processContextFactory,
             final SchedulingAgentCallback schedulingAgentCallback, final boolean failIfStopping) {
 
         final Processor processor = processorRef.get().getProcessor();
@@ -1366,7 +1381,7 @@ public void start(final ScheduledExecutorService taskScheduler, final long admin
         }
 
         if (starting) { // will ensure that the Processor represented by this node can only be started once
-            initiateStart(taskScheduler, administrativeYieldMillis, timeoutMillis, processContext, schedulingAgentCallback);
+            initiateStart(taskScheduler, administrativeYieldMillis, timeoutMillis, processContextFactory, schedulingAgentCallback);
         } else {
             final String procName = processorRef.get().toString();
             LOG.warn("Cannot start {} because it is not currently stopped. Current state is {}", procName, currentState);
@@ -1470,7 +1485,7 @@ public void verifyCanTerminate() {
 
 
     private void initiateStart(final ScheduledExecutorService taskScheduler, final long administrativeYieldMillis, final long timeoutMilis,
-            final ProcessContext processContext, final SchedulingAgentCallback schedulingAgentCallback) {
+            final Supplier<ProcessContext> processContextFactory, final SchedulingAgentCallback schedulingAgentCallback) {
 
         final Processor processor = getProcessor();
         final ComponentLog procLog = new SimpleProcessLogger(StandardProcessorNode.this.getIdentifier(), processor);
@@ -1480,6 +1495,8 @@ private void initiateStart(final ScheduledExecutorService taskScheduler, final l
 
         // Create a task to invoke the @OnScheduled annotation of the processor
         final Callable<Void> startupTask = () -> {
+            final ProcessContext processContext = processContextFactory.get();
+
             final ScheduledState currentScheduleState = scheduledState.get();
             if (currentScheduleState == ScheduledState.STOPPING || currentScheduleState == ScheduledState.STOPPED) {
                 LOG.debug("{} is stopped. Will not call @OnScheduled lifecycle methods or begin trigger onTrigger() method", StandardProcessorNode.this);
@@ -1493,7 +1510,7 @@ private void initiateStart(final ScheduledExecutorService taskScheduler, final l
                 LOG.debug("Cannot start {} because Processor is currently not valid; will try again after 5 seconds", StandardProcessorNode.this);
 
                 // re-initiate the entire process
-                final Runnable initiateStartTask = () -> initiateStart(taskScheduler, administrativeYieldMillis, timeoutMilis, processContext, schedulingAgentCallback);
+                final Runnable initiateStartTask = () -> initiateStart(taskScheduler, administrativeYieldMillis, timeoutMilis, processContextFactory, schedulingAgentCallback);
                 taskScheduler.schedule(initiateStartTask, 5, TimeUnit.SECONDS);
 
                 schedulingAgentCallback.onTaskComplete();
@@ -1565,7 +1582,7 @@ private void initiateStart(final ScheduledExecutorService taskScheduler, final l
                 // make sure we only continue retry loop if STOP action wasn't initiated
                 if (scheduledState.get() != ScheduledState.STOPPING) {
                     // re-initiate the entire process
-                    final Runnable initiateStartTask = () -> initiateStart(taskScheduler, administrativeYieldMillis, timeoutMilis, processContext, schedulingAgentCallback);
+                    final Runnable initiateStartTask = () -> initiateStart(taskScheduler, administrativeYieldMillis, timeoutMilis, processContextFactory, schedulingAgentCallback);
                     taskScheduler.schedule(initiateStartTask, administrativeYieldMillis, TimeUnit.MILLISECONDS);
                 } else {
                     scheduledState.set(ScheduledState.STOPPED);
@@ -1620,7 +1637,7 @@ public void run() {
      * STOPPING (e.g., the processor didn't finish @OnScheduled operation when
      * stop was called), the attempt will be made to transition processor's
      * scheduled state from STARTING to STOPPING which will allow
-     * {@link #start(ScheduledExecutorService, long, long, ProcessContext, SchedulingAgentCallback, boolean)}
+     * {@link #start(ScheduledExecutorService, long, long, Supplier, SchedulingAgentCallback, boolean)}
      * method to initiate processor's shutdown upon exiting @OnScheduled
      * operation, otherwise the processor's scheduled state will remain
      * unchanged ensuring that multiple calls to this method are idempotent.
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/TemplateUtils.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/TemplateUtils.java
index 7e319f5a96c..26db5c8d6d6 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/TemplateUtils.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/TemplateUtils.java
@@ -17,6 +17,9 @@
 
 package org.apache.nifi.controller;
 
+import org.apache.nifi.parameter.ParameterParser;
+import org.apache.nifi.parameter.ParameterTokenList;
+import org.apache.nifi.parameter.ExpressionLanguageAwareParameterParser;
 import org.apache.nifi.persistence.TemplateDeserializer;
 import org.apache.nifi.web.api.dto.ConnectableDTO;
 import org.apache.nifi.web.api.dto.ConnectionDTO;
@@ -40,6 +43,7 @@
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Collection;
+import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 
@@ -72,6 +76,67 @@ public static TemplateDTO parseDto(final byte[] bytes) {
         }
     }
 
+    /**
+     * If template was serialized in a version before Parameters were supported, ensures that any reference to a
+     * Parameter is escaped so that the value is treated as a literal value.
+     * @param templateDto the template
+     */
+    public static void escapeParameterReferences(final TemplateDTO templateDto) {
+        final String encodingVersion = templateDto.getEncodingVersion();
+        if (encodingVersion == null) {
+            escapeParameterReferences(templateDto.getSnippet());
+        } else {
+            switch (encodingVersion) {
+                case "1.0":
+                case "1.1":
+                case "1.2":
+                    escapeParameterReferences(templateDto.getSnippet());
+                    break;
+            }
+        }
+    }
+
+    private static void escapeParameterReferences(final FlowSnippetDTO flowSnippetDTO) {
+        flowSnippetDTO.getProcessors().forEach(TemplateUtils::escapeParameterReferences);
+        flowSnippetDTO.getControllerServices().forEach(TemplateUtils::escapeParameterReferences);
+
+        for (final ProcessGroupDTO groupDto : flowSnippetDTO.getProcessGroups()) {
+            escapeParameterReferences(groupDto.getContents());
+        }
+    }
+
+    private static void escapeParameterReferences(final ProcessorDTO processorDto) {
+        final ProcessorConfigDTO config = processorDto.getConfig();
+        if (config == null) {
+            return;
+        }
+
+        final ParameterParser parameterParser = new ExpressionLanguageAwareParameterParser();
+
+        final Map<String, String> escapedPropertyValues = new HashMap<>();
+        for (final Map.Entry<String, String> entry : config.getProperties().entrySet()) {
+            final ParameterTokenList references = parameterParser.parseTokens(entry.getValue());
+            final String escaped = references.escape();
+            escapedPropertyValues.put(entry.getKey(), escaped);
+        }
+
+        config.setProperties(escapedPropertyValues);
+    }
+
+    private static void escapeParameterReferences(final ControllerServiceDTO controllerServiceDTO) {
+        final ParameterParser parameterParser = new ExpressionLanguageAwareParameterParser();
+
+        final Map<String, String> escapedPropertyValues = new HashMap<>();
+        for (final Map.Entry<String, String> entry : controllerServiceDTO.getProperties().entrySet()) {
+            final ParameterTokenList references = parameterParser.parseTokens(entry.getValue());
+            final String escaped = references.escape();
+            escapedPropertyValues.put(entry.getKey(), escaped);
+        }
+
+        controllerServiceDTO.setProperties(escapedPropertyValues);
+    }
+
+
     /**
      * Scrubs the template prior to persisting in order to remove fields that shouldn't be included or are unnecessary.
      *
@@ -135,6 +200,7 @@ private static void scrubProcessGroups(final Set<ProcessGroupDTO> processGroups)
             processGroupDTO.setLocallyModifiedAndStaleCount(null);
             processGroupDTO.setSyncFailureCount(null);
             processGroupDTO.setVersionControlInformation(null);
+            processGroupDTO.setParameterContext(null);
 
             scrubSnippet(processGroupDTO.getContents());
         }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/flow/StandardFlowManager.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/flow/StandardFlowManager.java
index 9b326de2d63..a58559139bc 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/flow/StandardFlowManager.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/flow/StandardFlowManager.java
@@ -61,6 +61,12 @@
 import org.apache.nifi.logging.ReportingTaskLogObserver;
 import org.apache.nifi.nar.ExtensionManager;
 import org.apache.nifi.nar.NarCloseable;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterContextManager;
+import org.apache.nifi.parameter.ParameterReferenceManager;
+import org.apache.nifi.parameter.StandardParameterContext;
+import org.apache.nifi.parameter.StandardParameterReferenceManager;
 import org.apache.nifi.registry.VariableRegistry;
 import org.apache.nifi.registry.variable.MutableVariableRegistry;
 import org.apache.nifi.remote.PublicPort;
@@ -101,6 +107,7 @@ public class StandardFlowManager implements FlowManager {
     private final SSLContext sslContext;
     private final FlowController flowController;
     private final FlowFileEventRepository flowFileEventRepository;
+    private final ParameterContextManager parameterContextManager;
 
     private final boolean isSiteToSiteSecure;
 
@@ -114,7 +121,8 @@ public class StandardFlowManager implements FlowManager {
     private final ConcurrentMap<String, Port> allOutputPorts = new ConcurrentHashMap<>();
     private final ConcurrentMap<String, Funnel> allFunnels = new ConcurrentHashMap<>();
 
-    public StandardFlowManager(final NiFiProperties nifiProperties, final SSLContext sslContext, final FlowController flowController, final FlowFileEventRepository flowFileEventRepository) {
+    public StandardFlowManager(final NiFiProperties nifiProperties, final SSLContext sslContext, final FlowController flowController,
+                               final FlowFileEventRepository flowFileEventRepository, final ParameterContextManager parameterContextManager) {
         this.nifiProperties = nifiProperties;
         this.flowController = flowController;
         this.bulletinRepository = flowController.getBulletinRepository();
@@ -122,6 +130,7 @@ public StandardFlowManager(final NiFiProperties nifiProperties, final SSLContext
         this.authorizer = flowController.getAuthorizer();
         this.sslContext = sslContext;
         this.flowFileEventRepository = flowFileEventRepository;
+        this.parameterContextManager = parameterContextManager;
 
         this.isSiteToSiteSecure = Boolean.TRUE.equals(nifiProperties.isSiteToSiteSecure());
     }
@@ -582,7 +591,7 @@ public void removeReportingTask(final ReportingTaskNode reportingTaskNode) {
             ReflectionUtils.quietlyInvokeMethodsWithAnnotation(OnRemoved.class, reportingTaskNode.getReportingTask(), reportingTaskNode.getConfigurationContext());
         }
 
-        for (final Map.Entry<PropertyDescriptor, String> entry : reportingTaskNode.getProperties().entrySet()) {
+        for (final Map.Entry<PropertyDescriptor, String> entry : reportingTaskNode.getEffectivePropertyValues().entrySet()) {
             final PropertyDescriptor descriptor = entry.getKey();
             if (descriptor.getControllerServiceDefinition() != null) {
                 final String value = entry.getValue() == null ? descriptor.getDefaultValue() : entry.getValue();
@@ -638,7 +647,7 @@ public void removeRootControllerService(final ControllerServiceNode service) {
             ReflectionUtils.quietlyInvokeMethodsWithAnnotation(OnRemoved.class, service.getControllerServiceImplementation(), configurationContext);
         }
 
-        for (final Map.Entry<PropertyDescriptor, String> entry : service.getProperties().entrySet()) {
+        for (final Map.Entry<PropertyDescriptor, String> entry : service.getEffectivePropertyValues().entrySet()) {
             final PropertyDescriptor descriptor = entry.getKey();
             if (descriptor.getControllerServiceDefinition() != null) {
                 final String value = entry.getValue() == null ? descriptor.getDefaultValue() : entry.getValue();
@@ -656,7 +665,7 @@ public void removeRootControllerService(final ControllerServiceNode service) {
 
         extensionManager.removeInstanceClassLoader(service.getIdentifier());
 
-        logger.info("{} removed from Flow Controller", service, this);
+        logger.info("{} removed from Flow Controller", service);
     }
 
     public ControllerServiceNode createControllerService(final String type, final String id, final BundleCoordinate bundleCoordinate, final Set<URL> additionalUrls, final boolean firstTimeAdded,
@@ -721,4 +730,25 @@ public ControllerServiceNode getControllerServiceNode(final String id) {
         return flowController.getControllerServiceProvider().getControllerServiceNode(id);
     }
 
+    @Override
+    public ParameterContextManager getParameterContextManager() {
+        return parameterContextManager;
+    }
+
+    @Override
+    public ParameterContext createParameterContext(final String id, final String name, final Set<Parameter> parameters) {
+        final boolean namingConflict = parameterContextManager.getParameterContexts().stream()
+            .anyMatch(paramContext -> paramContext.getName().equals(name));
+
+        if (namingConflict) {
+            throw new IllegalStateException("Cannot create Parameter Context with name '" + name + "' because a Parameter Context already exists with that name");
+        }
+
+        final ParameterReferenceManager referenceManager = new StandardParameterReferenceManager(this);
+        final ParameterContext parameterContext = new StandardParameterContext(id, name, referenceManager, flowController);
+        parameterContext.setParameters(parameters);
+        parameterContextManager.addParameterContext(parameterContext);
+        return parameterContext;
+    }
+
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/reporting/AbstractReportingTaskNode.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/reporting/AbstractReportingTaskNode.java
index f1b585e5f41..469edfbda2d 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/reporting/AbstractReportingTaskNode.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/reporting/AbstractReportingTaskNode.java
@@ -17,6 +17,7 @@
 package org.apache.nifi.controller.reporting;
 
 import org.apache.nifi.annotation.configuration.DefaultSchedule;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.bundle.BundleCoordinate;
 import org.apache.nifi.components.ConfigurableComponent;
 import org.apache.nifi.components.ValidationResult;
@@ -306,4 +307,9 @@ public String toString() {
     public String getProcessGroupIdentifier() {
         return null;
     }
+
+    @Override
+    public ParameterLookup getParameterLookup() {
+        return ParameterLookup.EMPTY;
+    }
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/reporting/StandardReportingContext.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/reporting/StandardReportingContext.java
index 66ff5f7ea66..df28fbb1884 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/reporting/StandardReportingContext.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/reporting/StandardReportingContext.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.controller.reporting;
 
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.PreparedQuery;
 import org.apache.nifi.attribute.expression.language.Query;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
@@ -53,10 +54,11 @@ public class StandardReportingContext implements ReportingContext, ControllerSer
     private final Map<PropertyDescriptor, String> properties;
     private final Map<PropertyDescriptor, PreparedQuery> preparedQueries;
     private final VariableRegistry variableRegistry;
+    private final ParameterLookup parameterLookup;
 
     public StandardReportingContext(final FlowController flowController, final BulletinRepository bulletinRepository,
                                     final Map<PropertyDescriptor, String> properties, final ReportingTask reportingTask,
-                                    final VariableRegistry variableRegistry) {
+                                    final VariableRegistry variableRegistry, final ParameterLookup parameterLookup) {
         this.flowController = flowController;
         this.eventAccess = flowController.getEventAccess();
         this.bulletinRepository = bulletinRepository;
@@ -64,7 +66,9 @@ public StandardReportingContext(final FlowController flowController, final Bulle
         this.serviceProvider = flowController.getControllerServiceProvider();
         this.reportingTask = reportingTask;
         this.variableRegistry = variableRegistry;
+        this.parameterLookup = parameterLookup;
         preparedQueries = new HashMap<>();
+
         for (final Map.Entry<PropertyDescriptor, String> entry : properties.entrySet()) {
             final PropertyDescriptor desc = entry.getKey();
             String value = entry.getValue();
@@ -123,7 +127,7 @@ public PropertyValue getProperty(final PropertyDescriptor property) {
         }
 
         final String configuredValue = properties.get(property);
-        return new StandardPropertyValue(configuredValue == null ? descriptor.getDefaultValue() : configuredValue, this, preparedQueries.get(property), variableRegistry);
+        return new StandardPropertyValue(configuredValue == null ? descriptor.getDefaultValue() : configuredValue, this, parameterLookup, preparedQueries.get(property), variableRegistry);
     }
 
     @Override
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/reporting/StandardReportingTaskNode.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/reporting/StandardReportingTaskNode.java
index b63fffddd71..c906b22ca39 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/reporting/StandardReportingTaskNode.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/reporting/StandardReportingTaskNode.java
@@ -18,6 +18,7 @@
 
 import org.apache.nifi.annotation.behavior.Restricted;
 import org.apache.nifi.annotation.documentation.DeprecationNotice;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.authorization.Resource;
 import org.apache.nifi.authorization.resource.Authorizable;
 import org.apache.nifi.authorization.resource.ResourceFactory;
@@ -30,6 +31,7 @@
 import org.apache.nifi.controller.ReportingTaskNode;
 import org.apache.nifi.controller.ValidationContextFactory;
 import org.apache.nifi.nar.ExtensionManager;
+import org.apache.nifi.parameter.ParameterContext;
 import org.apache.nifi.registry.ComponentVariableRegistry;
 import org.apache.nifi.reporting.ReportingContext;
 import org.apache.nifi.reporting.ReportingTask;
@@ -82,6 +84,11 @@ public boolean isDeprecated() {
 
     @Override
     public ReportingContext getReportingContext() {
-        return new StandardReportingContext(flowController, flowController.getBulletinRepository(), getProperties(), getReportingTask(), getVariableRegistry());
+        return new StandardReportingContext(flowController, flowController.getBulletinRepository(), getEffectivePropertyValues(), getReportingTask(), getVariableRegistry(), ParameterLookup.EMPTY);
+    }
+
+    @Override
+    protected ParameterContext getParameterContext() {
+        return null;
     }
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/scheduling/StandardProcessScheduler.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/scheduling/StandardProcessScheduler.java
index a7d5fd8a1d6..e88b59fab87 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/scheduling/StandardProcessScheduler.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/scheduling/StandardProcessScheduler.java
@@ -63,6 +63,7 @@
 import java.util.concurrent.Future;
 import java.util.concurrent.ScheduledExecutorService;
 import java.util.concurrent.TimeUnit;
+import java.util.function.Supplier;
 
 import static java.util.Objects.requireNonNull;
 
@@ -293,16 +294,16 @@ public void run() {
 
     /**
      * Starts the given {@link Processor} by invoking its
-     * {@link ProcessorNode#start(ScheduledExecutorService, long, long, ProcessContext, SchedulingAgentCallback, boolean)}
+     * {@link ProcessorNode#start(ScheduledExecutorService, long, long, Supplier, SchedulingAgentCallback, boolean)}
      * method.
      *
-     * @see StandardProcessorNode#start(ScheduledExecutorService, long, long, ProcessContext, SchedulingAgentCallback, boolean)
+     * @see StandardProcessorNode#start(ScheduledExecutorService, long, long, Supplier, SchedulingAgentCallback, boolean)
      */
     @Override
     public synchronized CompletableFuture<Void> startProcessor(final ProcessorNode procNode, final boolean failIfStopping) {
         final LifecycleState lifecycleState = getLifecycleState(requireNonNull(procNode), true);
 
-        final StandardProcessContext processContext = new StandardProcessContext(procNode, getControllerServiceProvider(),
+        final Supplier<ProcessContext> processContextFactory = () -> new StandardProcessContext(procNode, getControllerServiceProvider(),
             this.encryptor, getStateManager(procNode.getIdentifier()), lifecycleState::isTerminated);
 
         final CompletableFuture<Void> future = new CompletableFuture<>();
@@ -327,7 +328,7 @@ public void onTaskComplete() {
         };
 
         LOG.info("Starting {}", procNode);
-        procNode.start(componentMonitoringThreadPool, administrativeYieldMillis, processorStartTimeoutMillis, processContext, callback, failIfStopping);
+        procNode.start(componentMonitoringThreadPool, administrativeYieldMillis, processorStartTimeoutMillis, processContextFactory, callback, failIfStopping);
         return future;
     }
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/serialization/FlowFromDOMFactory.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/serialization/FlowFromDOMFactory.java
index b43a24f311b..fa8bb8a50a4 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/serialization/FlowFromDOMFactory.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/serialization/FlowFromDOMFactory.java
@@ -22,6 +22,9 @@
 import org.apache.nifi.encrypt.EncryptionException;
 import org.apache.nifi.encrypt.StringEncryptor;
 import org.apache.nifi.groups.RemoteProcessGroupPortDescriptor;
+import org.apache.nifi.parameter.ExpressionLanguageAwareParameterParser;
+import org.apache.nifi.parameter.ParameterParser;
+import org.apache.nifi.parameter.ParameterTokenList;
 import org.apache.nifi.remote.StandardRemoteProcessGroupPortDescriptor;
 import org.apache.nifi.scheduling.ExecutionNode;
 import org.apache.nifi.scheduling.SchedulingStrategy;
@@ -33,6 +36,9 @@
 import org.apache.nifi.web.api.dto.FlowSnippetDTO;
 import org.apache.nifi.web.api.dto.FunnelDTO;
 import org.apache.nifi.web.api.dto.LabelDTO;
+import org.apache.nifi.web.api.dto.ParameterContextDTO;
+import org.apache.nifi.web.api.dto.ParameterContextReferenceDTO;
+import org.apache.nifi.web.api.dto.ParameterDTO;
 import org.apache.nifi.web.api.dto.PortDTO;
 import org.apache.nifi.web.api.dto.PositionDTO;
 import org.apache.nifi.web.api.dto.ProcessGroupDTO;
@@ -41,6 +47,7 @@
 import org.apache.nifi.web.api.dto.RemoteProcessGroupDTO;
 import org.apache.nifi.web.api.dto.ReportingTaskDTO;
 import org.apache.nifi.web.api.dto.VersionControlInformationDTO;
+import org.apache.nifi.web.api.entity.ParameterEntity;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 import org.w3c.dom.Element;
@@ -50,6 +57,7 @@
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
@@ -100,7 +108,7 @@ public static Map<String, String> getStyle(final Element stylesElement) {
         return styles;
     }
 
-    public static ControllerServiceDTO getControllerService(final Element element, final StringEncryptor encryptor) {
+    public static ControllerServiceDTO getControllerService(final Element element, final StringEncryptor encryptor, final FlowEncodingVersion flowEncodingVersion) {
         final ControllerServiceDTO dto = new ControllerServiceDTO();
 
         dto.setId(getString(element, "id"));
@@ -113,13 +121,13 @@ public static ControllerServiceDTO getControllerService(final Element element, f
         final boolean enabled = getBoolean(element, "enabled");
         dto.setState(enabled ? ControllerServiceState.ENABLED.name() : ControllerServiceState.DISABLED.name());
 
-        dto.setProperties(getProperties(element, encryptor));
+        dto.setProperties(getProperties(element, encryptor, flowEncodingVersion));
         dto.setAnnotationData(getString(element, "annotationData"));
 
         return dto;
     }
 
-    public static ReportingTaskDTO getReportingTask(final Element element, final StringEncryptor encryptor) {
+    public static ReportingTaskDTO getReportingTask(final Element element, final StringEncryptor encryptor, final FlowEncodingVersion flowEncodingVersion) {
         final ReportingTaskDTO dto = new ReportingTaskDTO();
 
         dto.setId(getString(element, "id"));
@@ -131,12 +139,41 @@ public static ReportingTaskDTO getReportingTask(final Element element, final Str
         dto.setState(getString(element, "scheduledState"));
         dto.setSchedulingStrategy(getString(element, "schedulingStrategy"));
 
-        dto.setProperties(getProperties(element, encryptor));
+        dto.setProperties(getProperties(element, encryptor, flowEncodingVersion));
         dto.setAnnotationData(getString(element, "annotationData"));
 
         return dto;
     }
 
+    public static ParameterContextDTO getParameterContext(final Element element, final StringEncryptor encryptor) {
+        final ParameterContextDTO dto = new ParameterContextDTO();
+
+        dto.setId(getString(element, "id"));
+        dto.setName(getString(element, "name"));
+        dto.setDescription(getString(element, "description"));
+
+        final Set<ParameterEntity> parameterDtos = new LinkedHashSet<>();
+        final List<Element> parameterElements = FlowFromDOMFactory.getChildrenByTagName(element, "parameter");
+        for (final Element parameterElement : parameterElements) {
+            final ParameterDTO parameterDto = new ParameterDTO();
+
+            parameterDto.setName(getString(parameterElement, "name"));
+            parameterDto.setDescription(getString(parameterElement, "description"));
+            parameterDto.setSensitive(getBoolean(parameterElement, "sensitive"));
+
+            final String value = decrypt(getString(parameterElement, "value"), encryptor);
+            parameterDto.setValue(value);
+
+            final ParameterEntity parameterEntity = new ParameterEntity();
+            parameterEntity.setParameter(parameterDto);
+            parameterDtos.add(parameterEntity);
+        }
+
+        dto.setParameters(parameterDtos);
+
+        return dto;
+    }
+
     public static ProcessGroupDTO getProcessGroup(final String parentId, final Element element, final StringEncryptor encryptor, final FlowEncodingVersion encodingVersion) {
         final ProcessGroupDTO dto = new ProcessGroupDTO();
         final String groupId = getString(element, "id");
@@ -160,6 +197,11 @@ public static ProcessGroupDTO getProcessGroup(final String parentId, final Eleme
         final Element versionControlInfoElement = DomUtils.getChild(element, "versionControlInformation");
         dto.setVersionControlInformation(getVersionControlInformation(versionControlInfoElement));
 
+        final String parameterContextId = getString(element, "parameterContextId");
+        final ParameterContextReferenceDTO parameterContextReference = new ParameterContextReferenceDTO();
+        parameterContextReference.setId(parameterContextId);
+        dto.setParameterContext(parameterContextReference);
+
         final Set<ProcessorDTO> processors = new HashSet<>();
         final Set<ConnectionDTO> connections = new HashSet<>();
         final Set<FunnelDTO> funnels = new HashSet<>();
@@ -171,7 +213,7 @@ public static ProcessGroupDTO getProcessGroup(final String parentId, final Eleme
 
         NodeList nodeList = DomUtils.getChildNodesByTagName(element, "processor");
         for (int i = 0; i < nodeList.getLength(); i++) {
-            processors.add(getProcessor((Element) nodeList.item(i), encryptor));
+            processors.add(getProcessor((Element) nodeList.item(i), encryptor, encodingVersion));
         }
 
         nodeList = DomUtils.getChildNodesByTagName(element, "funnel");
@@ -416,7 +458,7 @@ public static RemoteProcessGroupPortDescriptor getRemoteProcessGroupPort(final E
         return descriptor;
     }
 
-    public static ProcessorDTO getProcessor(final Element element, final StringEncryptor encryptor) {
+    public static ProcessorDTO getProcessor(final Element element, final StringEncryptor encryptor, final FlowEncodingVersion flowEncodingVersion) {
         final ProcessorDTO dto = new ProcessorDTO();
 
         dto.setId(getString(element, "id"));
@@ -461,7 +503,7 @@ public static ProcessorDTO getProcessor(final Element element, final StringEncry
             configDto.setRunDurationMillis(TimeUnit.NANOSECONDS.toMillis(runDurationNanos));
         }
 
-        configDto.setProperties(getProperties(element, encryptor));
+        configDto.setProperties(getProperties(element, encryptor, flowEncodingVersion));
         configDto.setAnnotationData(getString(element, "annotationData"));
 
         final Set<String> autoTerminatedRelationships = new HashSet<>();
@@ -474,16 +516,29 @@ public static ProcessorDTO getProcessor(final Element element, final StringEncry
         return dto;
     }
 
-    private static LinkedHashMap<String, String> getProperties(final Element element, final StringEncryptor encryptor) {
+    private static LinkedHashMap<String, String> getProperties(final Element element, final StringEncryptor encryptor, final FlowEncodingVersion flowEncodingVersion) {
         final LinkedHashMap<String, String> properties = new LinkedHashMap<>();
         final List<Element> propertyNodeList = getChildrenByTagName(element, "property");
+
+        final ParameterParser parameterParser = new ExpressionLanguageAwareParameterParser();
+
         for (final Element propertyElement : propertyNodeList) {
             final String name = getString(propertyElement, "name");
 
             final String rawPropertyValue = getString(propertyElement, "value");
             final String value = encryptor == null ? rawPropertyValue : decrypt(rawPropertyValue, encryptor);
-            properties.put(name, value);
+
+            if (flowEncodingVersion == null || (flowEncodingVersion.getMajorVersion() <= 1 && flowEncodingVersion.getMinorVersion() < 4)) {
+                // Version 1.4 introduced the #{paramName} syntax for referencing parameters. If the version is less than 1.4, we must escpae any
+                // #{...} reference that we find.
+                final ParameterTokenList parameterTokenList = parameterParser.parseTokens(value);
+                final String escaped = parameterTokenList.escape();
+                properties.put(name, escaped);
+            } else {
+                properties.put(name, value);
+            }
         }
+
         return properties;
     }
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/serialization/StandardFlowSerializer.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/serialization/StandardFlowSerializer.java
index 7337083e678..a5c31b705e3 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/serialization/StandardFlowSerializer.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/serialization/StandardFlowSerializer.java
@@ -35,6 +35,10 @@
 import org.apache.nifi.flowfile.FlowFilePrioritizer;
 import org.apache.nifi.groups.ProcessGroup;
 import org.apache.nifi.groups.RemoteProcessGroup;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterContextManager;
+import org.apache.nifi.parameter.ParameterDescriptor;
 import org.apache.nifi.persistence.TemplateSerializer;
 import org.apache.nifi.processor.Relationship;
 import org.apache.nifi.registry.VariableDescriptor;
@@ -76,7 +80,7 @@
  */
 public class StandardFlowSerializer implements FlowSerializer<Document> {
 
-    private static final String MAX_ENCODING_VERSION = "1.3";
+    private static final String MAX_ENCODING_VERSION = "1.4";
 
     private final StringEncryptor encryptor;
 
@@ -104,8 +108,12 @@ public Document transform(final FlowController controller, final ScheduledStateL
 
             final Element registriesElement = doc.createElement("registries");
             rootNode.appendChild(registriesElement);
-
             addFlowRegistries(registriesElement, controller.getFlowRegistryClient());
+
+            final Element parameterContextsElement = doc.createElement("parameterContexts");
+            rootNode.appendChild(parameterContextsElement);
+            addParameterContexts(parameterContextsElement, controller.getFlowManager().getParameterContextManager());
+
             addProcessGroup(rootNode, controller.getFlowManager().getRootGroup(), "rootGroup", scheduledStateLookup);
 
             // Add root-level controller services
@@ -147,6 +155,37 @@ public void serialize(final Document flowConfiguration, final OutputStream os) t
         }
     }
 
+    private void addParameterContexts(final Element parentElement, final ParameterContextManager parameterContextManager) {
+        for (final ParameterContext parameterContext : parameterContextManager.getParameterContexts()) {
+            final Element parameterContextElement = parentElement.getOwnerDocument().createElement("parameterContext");
+            parentElement.appendChild(parameterContextElement);
+
+            addStringElement(parameterContextElement, "id", parameterContext.getIdentifier());
+            addStringElement(parameterContextElement, "name", parameterContext.getName());
+            addStringElement(parameterContextElement, "description", parameterContext.getDescription());
+
+            for (final Parameter parameter : parameterContext.getParameters().values()) {
+                addParameter(parameterContextElement, parameter);
+            }
+        }
+    }
+
+    private void addParameter(final Element parentElement, final Parameter parameter) {
+        final Element parameterElement = parentElement.getOwnerDocument().createElement("parameter");
+        parentElement.appendChild(parameterElement);
+
+        final ParameterDescriptor descriptor = parameter.getDescriptor();
+        addStringElement(parameterElement, "name", descriptor.getName());
+        addStringElement(parameterElement, "description", descriptor.getDescription());
+        addStringElement(parameterElement, "sensitive", String.valueOf(descriptor.isSensitive()));
+
+        if (descriptor.isSensitive()) {
+            addStringElement(parameterElement, "value", ENC_PREFIX + encryptor.encrypt(parameter.getValue()) + ENC_SUFFIX);
+        } else {
+            addStringElement(parameterElement, "value", parameter.getValue());
+        }
+    }
+
     private void addFlowRegistries(final Element parentElement, final FlowRegistryClient registryClient) {
         for (final String registryId : registryClient.getRegistryIdentifiers()) {
             final FlowRegistry flowRegistry = registryClient.getFlowRegistry(registryId);
@@ -260,6 +299,11 @@ private void addProcessGroup(final Element parentElement, final ProcessGroup gro
         for (final Map.Entry<VariableDescriptor, String> entry : variableRegistry.getVariableMap().entrySet()) {
             addVariable(element, entry.getKey().getName(), entry.getValue());
         }
+
+        final ParameterContext parameterContext = group.getParameterContext();
+        if (parameterContext != null) {
+            addTextElement(element, "parameterContextId", parameterContext.getIdentifier());
+        }
     }
 
     private static void addVariable(final Element parentElement, final String variableName, final String variableValue) {
@@ -463,7 +507,7 @@ private void addProcessor(final Element parentElement, final ProcessorNode proce
         addTextElement(element, "executionNode", processor.getExecutionNode().name());
         addTextElement(element, "runDurationNanos", processor.getRunDuration(TimeUnit.NANOSECONDS));
 
-        addConfiguration(element, processor.getProperties(), processor.getAnnotationData(), encryptor);
+        addConfiguration(element, processor.getRawPropertyValues(), processor.getAnnotationData(), encryptor);
 
         for (final Relationship rel : processor.getAutoTerminatedRelationships()) {
             addTextElement(element, "autoTerminatedRelationship", rel.getName());
@@ -476,14 +520,14 @@ private static void addConfiguration(final Element element, final Map<PropertyDe
             final PropertyDescriptor descriptor = entry.getKey();
             String value = entry.getValue();
 
-            if (value != null && descriptor.isSensitive()) {
-                value = ENC_PREFIX + encryptor.encrypt(value) + ENC_SUFFIX;
-            }
-
             if (value == null) {
                 value = descriptor.getDefaultValue();
             }
 
+            if (value != null && descriptor.isSensitive()) {
+                value = ENC_PREFIX + encryptor.encrypt(value) + ENC_SUFFIX;
+            }
+
             final Element propElement = doc.createElement("property");
             addTextElement(propElement, "name", descriptor.getName());
             if (value != null) {
@@ -575,7 +619,7 @@ public void addControllerService(final Element element, final ControllerServiceN
         final boolean enabled = (state == ControllerServiceState.ENABLED || state == ControllerServiceState.ENABLING);
         addTextElement(serviceElement, "enabled", String.valueOf(enabled));
 
-        addConfiguration(serviceElement, serviceNode.getProperties(), serviceNode.getAnnotationData(), encryptor);
+        addConfiguration(serviceElement, serviceNode.getRawPropertyValues(), serviceNode.getAnnotationData(), encryptor);
 
         element.appendChild(serviceElement);
     }
@@ -593,7 +637,7 @@ public static void addReportingTask(final Element element, final ReportingTaskNo
         addTextElement(taskElement, "scheduledState", taskNode.getScheduledState().name());
         addTextElement(taskElement, "schedulingStrategy", taskNode.getSchedulingStrategy().name());
 
-        addConfiguration(taskElement, taskNode.getProperties(), taskNode.getAnnotationData(), encryptor);
+        addConfiguration(taskElement, taskNode.getRawPropertyValues(), taskNode.getAnnotationData(), encryptor);
 
         element.appendChild(taskElement);
     }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/ControllerServiceLoader.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/ControllerServiceLoader.java
index f226bb6fd11..06ea3a79b18 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/ControllerServiceLoader.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/ControllerServiceLoader.java
@@ -19,6 +19,7 @@
 import org.apache.nifi.bundle.BundleCoordinate;
 import org.apache.nifi.components.PropertyDescriptor;
 import org.apache.nifi.controller.FlowController;
+import org.apache.nifi.controller.serialization.FlowEncodingVersion;
 import org.apache.nifi.controller.serialization.FlowFromDOMFactory;
 import org.apache.nifi.encrypt.StringEncryptor;
 import org.apache.nifi.groups.ProcessGroup;
@@ -56,7 +57,7 @@ public class ControllerServiceLoader {
     private static final Logger logger = LoggerFactory.getLogger(ControllerServiceLoader.class);
 
     public static List<ControllerServiceNode> loadControllerServices(final FlowController controller, final InputStream serializedStream, final ProcessGroup parentGroup,
-        final StringEncryptor encryptor, final BulletinRepository bulletinRepo, final boolean autoResumeState) throws IOException {
+        final StringEncryptor encryptor, final BulletinRepository bulletinRepo, final boolean autoResumeState, final FlowEncodingVersion encodingVersion) throws IOException {
 
         final DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
         documentBuilderFactory.setNamespaceAware(true);
@@ -98,8 +99,8 @@ public void warning(final SAXParseException err) throws SAXParseException {
             final Element controllerServices = document.getDocumentElement();
             final List<Element> serviceElements = DomUtils.getChildElementsByTagName(controllerServices, "controllerService");
 
-            final Map<ControllerServiceNode, Element> controllerServiceMap = ControllerServiceLoader.loadControllerServices(serviceElements, controller, parentGroup, encryptor);
-            enableControllerServices(controllerServiceMap, controller, encryptor, autoResumeState);
+            final Map<ControllerServiceNode, Element> controllerServiceMap = ControllerServiceLoader.loadControllerServices(serviceElements, controller, parentGroup, encryptor, encodingVersion);
+            enableControllerServices(controllerServiceMap, controller, encryptor, autoResumeState, encodingVersion);
             return new ArrayList<>(controllerServiceMap.keySet());
         } catch (SAXException | ParserConfigurationException sxe) {
             throw new IOException(sxe);
@@ -107,11 +108,11 @@ public void warning(final SAXParseException err) throws SAXParseException {
     }
 
     public static Map<ControllerServiceNode, Element> loadControllerServices(final List<Element> serviceElements, final FlowController controller,
-                                                                             final ProcessGroup parentGroup, final StringEncryptor encryptor) {
+                                                                             final ProcessGroup parentGroup, final StringEncryptor encryptor, final FlowEncodingVersion encodingVersion) {
 
         final Map<ControllerServiceNode, Element> nodeMap = new HashMap<>();
         for (final Element serviceElement : serviceElements) {
-            final ControllerServiceNode serviceNode = createControllerService(controller, serviceElement, encryptor);
+            final ControllerServiceNode serviceNode = createControllerService(controller, serviceElement, encryptor, encodingVersion);
             if (parentGroup == null) {
                 controller.getFlowManager().addRootControllerService(serviceNode);
             } else {
@@ -123,14 +124,14 @@ public static Map<ControllerServiceNode, Element> loadControllerServices(final L
             nodeMap.put(serviceNode, (Element) serviceElement.cloneNode(true));
         }
         for (final Map.Entry<ControllerServiceNode, Element> entry : nodeMap.entrySet()) {
-            configureControllerService(entry.getKey(), entry.getValue(), encryptor);
+            configureControllerService(entry.getKey(), entry.getValue(), encryptor, encodingVersion);
         }
 
         return nodeMap;
     }
 
     public static void enableControllerServices(final Map<ControllerServiceNode, Element> nodeMap, final FlowController controller,
-                                                final StringEncryptor encryptor, final boolean autoResumeState) {
+                                                final StringEncryptor encryptor, final boolean autoResumeState, final FlowEncodingVersion encodingVersion) {
         // Start services
         if (autoResumeState) {
             final Set<ControllerServiceNode> nodesToEnable = new HashSet<>();
@@ -140,7 +141,7 @@ public static void enableControllerServices(final Map<ControllerServiceNode, Ele
 
                 final ControllerServiceDTO dto;
                 synchronized (controllerServiceElement.getOwnerDocument()) {
-                    dto = FlowFromDOMFactory.getControllerService(controllerServiceElement, encryptor);
+                    dto = FlowFromDOMFactory.getControllerService(controllerServiceElement, encryptor, encodingVersion);
                 }
 
                 final ControllerServiceState state = ControllerServiceState.valueOf(dto.getState());
@@ -181,7 +182,7 @@ public static ControllerServiceNode cloneControllerService(final FlowController
 
         if (controllerService.getProperties() != null) {
             Map<String,String> properties = new HashMap<>();
-            for (Map.Entry<PropertyDescriptor, String> propEntry : controllerService.getProperties().entrySet()) {
+            for (Map.Entry<PropertyDescriptor, String> propEntry : controllerService.getRawPropertyValues().entrySet()) {
                 properties.put(propEntry.getKey().getName(), propEntry.getValue());
             }
             clone.setProperties(properties);
@@ -190,8 +191,9 @@ public static ControllerServiceNode cloneControllerService(final FlowController
         return clone;
     }
 
-    private static ControllerServiceNode createControllerService(final FlowController flowController, final Element controllerServiceElement, final StringEncryptor encryptor) {
-        final ControllerServiceDTO dto = FlowFromDOMFactory.getControllerService(controllerServiceElement, encryptor);
+    private static ControllerServiceNode createControllerService(final FlowController flowController, final Element controllerServiceElement, final StringEncryptor encryptor,
+                                                                 final FlowEncodingVersion encodingVersion) {
+        final ControllerServiceDTO dto = FlowFromDOMFactory.getControllerService(controllerServiceElement, encryptor, encodingVersion);
 
         BundleCoordinate coordinate;
         try {
@@ -212,8 +214,9 @@ private static ControllerServiceNode createControllerService(final FlowControlle
         return node;
     }
 
-    private static void configureControllerService(final ControllerServiceNode node, final Element controllerServiceElement, final StringEncryptor encryptor) {
-        final ControllerServiceDTO dto = FlowFromDOMFactory.getControllerService(controllerServiceElement, encryptor);
+    private static void configureControllerService(final ControllerServiceNode node, final Element controllerServiceElement, final StringEncryptor encryptor,
+                                                   final FlowEncodingVersion encodingVersion) {
+        final ControllerServiceDTO dto = FlowFromDOMFactory.getControllerService(controllerServiceElement, encryptor, encodingVersion);
         node.pauseValidationTrigger();
         try {
             node.setAnnotationData(dto.getAnnotationData());
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/StandardConfigurationContext.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/StandardConfigurationContext.java
index 3ab74865f8b..0a6f80b436e 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/StandardConfigurationContext.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/StandardConfigurationContext.java
@@ -59,7 +59,7 @@ public StandardConfigurationContext(final ComponentNode component, final Control
         }
 
         preparedQueries = new HashMap<>();
-        for (final Map.Entry<PropertyDescriptor, String> entry : component.getProperties().entrySet()) {
+        for (final Map.Entry<PropertyDescriptor, String> entry : component.getEffectivePropertyValues().entrySet()) {
             final PropertyDescriptor desc = entry.getKey();
             String value = entry.getValue();
             if (value == null) {
@@ -73,7 +73,7 @@ public StandardConfigurationContext(final ComponentNode component, final Control
 
     @Override
     public PropertyValue getProperty(final PropertyDescriptor property) {
-        final String configuredValue = component.getProperty(property);
+        final String configuredValue = component.getEffectivePropertyValue(property);
         final String resolvedValue = (configuredValue == null) ? property.getDefaultValue() : configuredValue;
 
         if (resolvedValue == null) {
@@ -81,15 +81,15 @@ public PropertyValue getProperty(final PropertyDescriptor property) {
             // since the supplied PropertyDescriptor may have been built using only the name, and without the proper
             // default value.
             final PropertyDescriptor resolvedDescriptor = component.getPropertyDescriptor(property.getName());
-            return new StandardPropertyValue(resolvedDescriptor.getDefaultValue(), serviceLookup, preparedQueries.get(property), variableRegistry);
+            return new StandardPropertyValue(resolvedDescriptor.getDefaultValue(), serviceLookup, component.getParameterLookup(), preparedQueries.get(property), variableRegistry);
         }
 
-        return new StandardPropertyValue(resolvedValue, serviceLookup, preparedQueries.get(property), variableRegistry);
+        return new StandardPropertyValue(resolvedValue, serviceLookup, component.getParameterLookup(), preparedQueries.get(property), variableRegistry);
     }
 
     @Override
     public Map<PropertyDescriptor, String> getProperties() {
-        return component.getProperties();
+        return component.getEffectivePropertyValues();
     }
 
     @Override
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/StandardControllerServiceNode.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/StandardControllerServiceNode.java
index aae22ab14fc..83bcf2a52f8 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/StandardControllerServiceNode.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/StandardControllerServiceNode.java
@@ -43,6 +43,8 @@
 import org.apache.nifi.logging.ComponentLog;
 import org.apache.nifi.nar.ExtensionManager;
 import org.apache.nifi.nar.NarCloseable;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.processor.SimpleProcessLogger;
 import org.apache.nifi.registry.ComponentVariableRegistry;
 import org.apache.nifi.util.CharacterFilterUtils;
@@ -238,10 +240,18 @@ public void addReference(final ComponentNode referencingComponent) {
         }
     }
 
+
+    @Override
+    protected ParameterContext getParameterContext() {
+        final ProcessGroup processGroup = getProcessGroup();
+        return processGroup == null ? null : processGroup.getParameterContext();
+    }
+
+
     @Override
     public List<ControllerServiceNode> getRequiredControllerServices() {
         Set<ControllerServiceNode> requiredServices = new HashSet<>();
-        for (Entry<PropertyDescriptor, String> entry : getProperties().entrySet()) {
+        for (Entry<PropertyDescriptor, String> entry : getEffectivePropertyValues().entrySet()) {
             PropertyDescriptor descriptor = entry.getKey();
             if (descriptor.getControllerServiceDefinition() != null && entry.getValue() != null) {
                 ControllerServiceNode requiredNode = serviceProvider.getControllerServiceNode(entry.getValue());
@@ -392,11 +402,13 @@ public CompletableFuture<Void> enable(final ScheduledExecutorService scheduler,
                 this.active.set(true);
             }
 
+            final ControllerServiceProvider controllerServiceProvider = this.serviceProvider;
             final StandardControllerServiceNode service = this;
-            final ConfigurationContext configContext = new StandardConfigurationContext(this, this.serviceProvider, null, getVariableRegistry());
             scheduler.execute(new Runnable() {
                 @Override
                 public void run() {
+                    final ConfigurationContext configContext = new StandardConfigurationContext(StandardControllerServiceNode.this, controllerServiceProvider, null, getVariableRegistry());
+
                     if (!isActive()) {
                         LOG.debug("{} is no longer active so will not attempt to enable it", StandardControllerServiceNode.this);
                         stateTransition.disable();
@@ -568,4 +580,9 @@ public String toString() {
                 ", active=" + active +
                 '}';
     }
+
+    @Override
+    public ParameterLookup getParameterLookup() {
+        return getParameterContext();
+    }
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/StandardControllerServiceProvider.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/StandardControllerServiceProvider.java
index e82d74285e8..ac9e1e3c91b 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/StandardControllerServiceProvider.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/service/StandardControllerServiceProvider.java
@@ -16,7 +16,23 @@
  */
 package org.apache.nifi.controller.service;
 
-import static java.util.Objects.requireNonNull;
+import org.apache.nifi.components.PropertyDescriptor;
+import org.apache.nifi.controller.ComponentNode;
+import org.apache.nifi.controller.ControllerService;
+import org.apache.nifi.controller.FlowController;
+import org.apache.nifi.controller.ProcessorNode;
+import org.apache.nifi.controller.ReportingTaskNode;
+import org.apache.nifi.controller.ScheduledState;
+import org.apache.nifi.controller.flow.FlowManager;
+import org.apache.nifi.controller.scheduling.StandardProcessScheduler;
+import org.apache.nifi.events.BulletinFactory;
+import org.apache.nifi.groups.ProcessGroup;
+import org.apache.nifi.logging.LogRepositoryFactory;
+import org.apache.nifi.nar.ExtensionManager;
+import org.apache.nifi.reporting.BulletinRepository;
+import org.apache.nifi.reporting.Severity;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -35,23 +51,8 @@
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.TimeoutException;
 import java.util.stream.Collectors;
-import org.apache.nifi.components.PropertyDescriptor;
-import org.apache.nifi.controller.ComponentNode;
-import org.apache.nifi.controller.ControllerService;
-import org.apache.nifi.controller.FlowController;
-import org.apache.nifi.controller.ProcessorNode;
-import org.apache.nifi.controller.ReportingTaskNode;
-import org.apache.nifi.controller.ScheduledState;
-import org.apache.nifi.controller.flow.FlowManager;
-import org.apache.nifi.controller.scheduling.StandardProcessScheduler;
-import org.apache.nifi.events.BulletinFactory;
-import org.apache.nifi.groups.ProcessGroup;
-import org.apache.nifi.logging.LogRepositoryFactory;
-import org.apache.nifi.nar.ExtensionManager;
-import org.apache.nifi.reporting.BulletinRepository;
-import org.apache.nifi.reporting.Severity;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
+
+import static java.util.Objects.requireNonNull;
 
 public class StandardControllerServiceProvider implements ControllerServiceProvider {
 
@@ -338,16 +339,14 @@ static List<List<ControllerServiceNode>> determineEnablingOrder(final Map<String
         return orderedNodeLists;
     }
 
-    private static void determineEnablingOrder(
-            final Map<String, ControllerServiceNode> serviceNodeMap,
-            final ControllerServiceNode contextNode,
-            final List<ControllerServiceNode> orderedNodes,
-            final Set<ControllerServiceNode> visited) {
+    private static void determineEnablingOrder(final Map<String, ControllerServiceNode> serviceNodeMap, final ControllerServiceNode contextNode,
+            final List<ControllerServiceNode> orderedNodes, final Set<ControllerServiceNode> visited) {
+
         if (visited.contains(contextNode)) {
             return;
         }
 
-        for (final Map.Entry<PropertyDescriptor, String> entry : contextNode.getProperties().entrySet()) {
+        for (final Map.Entry<PropertyDescriptor, String> entry : contextNode.getEffectivePropertyValues().entrySet()) {
             if (entry.getKey().getControllerServiceDefinition() != null) {
                 final String referencedServiceId = entry.getValue();
                 if (referencedServiceId != null) {
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/state/manager/StandardStateManagerProvider.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/state/manager/StandardStateManagerProvider.java
index 6a6eb636d9a..6b0ee95fc3c 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/state/manager/StandardStateManagerProvider.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/controller/state/manager/StandardStateManagerProvider.java
@@ -18,6 +18,7 @@
 package org.apache.nifi.controller.state.manager;
 
 import org.apache.commons.lang3.ArrayUtils;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.bundle.Bundle;
 import org.apache.nifi.components.PropertyDescriptor;
@@ -30,6 +31,7 @@
 import org.apache.nifi.components.state.StateMap;
 import org.apache.nifi.components.state.StateProvider;
 import org.apache.nifi.components.state.StateProviderInitializationContext;
+import org.apache.nifi.controller.PropertyConfiguration;
 import org.apache.nifi.controller.state.ConfigParseException;
 import org.apache.nifi.controller.state.StandardStateManager;
 import org.apache.nifi.controller.state.StandardStateProviderInitializationContext;
@@ -39,6 +41,9 @@
 import org.apache.nifi.logging.ComponentLog;
 import org.apache.nifi.nar.ExtensionManager;
 import org.apache.nifi.nar.NarCloseable;
+import org.apache.nifi.parameter.ParameterParser;
+import org.apache.nifi.parameter.ParameterTokenList;
+import org.apache.nifi.parameter.ExpressionLanguageAwareParameterParser;
 import org.apache.nifi.processor.SimpleProcessLogger;
 import org.apache.nifi.processor.StandardValidationContext;
 import org.apache.nifi.registry.VariableRegistry;
@@ -70,17 +75,17 @@ private StandardStateManagerProvider(final StateProvider localStateProvider, fin
         this.clusterStateProvider = clusterStateProvider;
     }
 
-    public static synchronized StateManagerProvider create(final NiFiProperties properties, final VariableRegistry variableRegistry, final ExtensionManager extensionManager)
-            throws ConfigParseException, IOException {
+    public static synchronized StateManagerProvider create(final NiFiProperties properties, final VariableRegistry variableRegistry, final ExtensionManager extensionManager,
+                                                           final ParameterLookup parameterLookup) throws ConfigParseException, IOException {
         if (provider != null) {
             return provider;
         }
 
-        final StateProvider localProvider = createLocalStateProvider(properties,variableRegistry, extensionManager);
+        final StateProvider localProvider = createLocalStateProvider(properties,variableRegistry, extensionManager, parameterLookup);
 
         final StateProvider clusterProvider;
         if (properties.isNode()) {
-            clusterProvider = createClusteredStateProvider(properties,variableRegistry, extensionManager);
+            clusterProvider = createClusteredStateProvider(properties,variableRegistry, extensionManager, parameterLookup);
         } else {
             clusterProvider = null;
         }
@@ -93,23 +98,22 @@ public static synchronized void resetProvider() {
         provider = null;
     }
 
-    private static StateProvider createLocalStateProvider(final NiFiProperties properties, final VariableRegistry variableRegistry, final ExtensionManager extensionManager)
-            throws IOException, ConfigParseException {
+    private static StateProvider createLocalStateProvider(final NiFiProperties properties, final VariableRegistry variableRegistry, final ExtensionManager extensionManager,
+                                                          final ParameterLookup parameterLookup) throws IOException, ConfigParseException {
         final File configFile = properties.getStateManagementConfigFile();
-        return createStateProvider(configFile, Scope.LOCAL, properties, variableRegistry, extensionManager);
+        return createStateProvider(configFile, Scope.LOCAL, properties, variableRegistry, extensionManager, parameterLookup);
     }
 
 
-    private static StateProvider createClusteredStateProvider(final NiFiProperties properties, final VariableRegistry variableRegistry, final ExtensionManager extensionManager)
-            throws IOException, ConfigParseException {
+    private static StateProvider createClusteredStateProvider(final NiFiProperties properties, final VariableRegistry variableRegistry, final ExtensionManager extensionManager,
+                                                              final ParameterLookup parameterLookup) throws IOException, ConfigParseException {
         final File configFile = properties.getStateManagementConfigFile();
-        return createStateProvider(configFile, Scope.CLUSTER, properties, variableRegistry, extensionManager);
+        return createStateProvider(configFile, Scope.CLUSTER, properties, variableRegistry, extensionManager, parameterLookup);
     }
 
 
-    private static StateProvider createStateProvider(final File configFile, final Scope scope, final NiFiProperties properties,
-                                                     final VariableRegistry variableRegistry, final ExtensionManager extensionManager)
-            throws ConfigParseException, IOException {
+    private static StateProvider createStateProvider(final File configFile, final Scope scope, final NiFiProperties properties, final VariableRegistry variableRegistry,
+                                                     final ExtensionManager extensionManager, final ParameterLookup parameterLookup) throws ConfigParseException, IOException {
         final String providerId;
         final String providerIdPropertyName;
         final String providerDescription;
@@ -189,17 +193,26 @@ private static StateProvider createStateProvider(final File configFile, final Sc
         }
 
         //create variable registry
+        final ParameterParser parser = new ExpressionLanguageAwareParameterParser();
         final Map<PropertyDescriptor, PropertyValue> propertyMap = new HashMap<>();
-        final Map<PropertyDescriptor, String> propertyStringMap = new HashMap<>();
+        final Map<PropertyDescriptor, PropertyConfiguration> propertyStringMap = new HashMap<>();
         for (final PropertyDescriptor descriptor : provider.getPropertyDescriptors()) {
-            propertyMap.put(descriptor, new StandardPropertyValue(descriptor.getDefaultValue(),null, variableRegistry));
-            propertyStringMap.put(descriptor, descriptor.getDefaultValue());
+            propertyMap.put(descriptor, new StandardPropertyValue(descriptor.getDefaultValue(),null, parameterLookup, variableRegistry));
+
+            final ParameterTokenList references = parser.parseTokens(descriptor.getDefaultValue());
+            final PropertyConfiguration configuration = new PropertyConfiguration(descriptor.getDefaultValue(), references, references.toReferenceList());
+
+            propertyStringMap.put(descriptor, configuration);
         }
 
         for (final Map.Entry<String, String> entry : providerConfig.getProperties().entrySet()) {
             final PropertyDescriptor descriptor = provider.getPropertyDescriptor(entry.getKey());
-            propertyStringMap.put(descriptor, entry.getValue());
-            propertyMap.put(descriptor, new StandardPropertyValue(entry.getValue(),null, variableRegistry));
+
+            final ParameterTokenList references = parser.parseTokens(descriptor.getDefaultValue());
+            final PropertyConfiguration configuration = new PropertyConfiguration(descriptor.getDefaultValue(), references, references.toReferenceList());
+
+            propertyStringMap.put(descriptor, configuration);
+            propertyMap.put(descriptor, new StandardPropertyValue(entry.getValue(),null, parameterLookup, variableRegistry));
         }
 
         final SSLContext sslContext = SslContextFactory.createSslContext(properties);
@@ -210,7 +223,7 @@ private static StateProvider createStateProvider(final File configFile, final Sc
             provider.initialize(initContext);
         }
 
-        final ValidationContext validationContext = new StandardValidationContext(null, propertyStringMap, null, null, null,variableRegistry);
+        final ValidationContext validationContext = new StandardValidationContext(null, propertyStringMap, null, null, null, variableRegistry, null);
         final Collection<ValidationResult> results = provider.validate(validationContext);
         final StringBuilder validationFailures = new StringBuilder();
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/fingerprint/FingerprintFactory.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/fingerprint/FingerprintFactory.java
index 554c55bd868..3cf3df29b83 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/fingerprint/FingerprintFactory.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/fingerprint/FingerprintFactory.java
@@ -21,6 +21,7 @@
 import org.apache.nifi.components.ConfigurableComponent;
 import org.apache.nifi.components.PropertyDescriptor;
 import org.apache.nifi.controller.FlowController;
+import org.apache.nifi.controller.serialization.FlowEncodingVersion;
 import org.apache.nifi.controller.serialization.FlowFromDOMFactory;
 import org.apache.nifi.encrypt.StringEncryptor;
 import org.apache.nifi.nar.ExtensionManager;
@@ -174,7 +175,10 @@ private String createFingerprint(final Document flowDoc, final FlowController co
             logger.warn("Unable to create fingerprint because no 'flowController' element found in XML.");
             return "";
         }
-        addFlowControllerFingerprint(fingerprintBuilder, flowControllerElem, controller);
+
+        final FlowEncodingVersion encodingVersion = FlowEncodingVersion.parse(flowControllerElem);
+
+        addFlowControllerFingerprint(fingerprintBuilder, flowControllerElem, controller, encodingVersion);
 
         return fingerprintBuilder.toString();
     }
@@ -200,7 +204,7 @@ private Document parseFlow(final byte[] flow) throws FingerprintException {
         }
     }
 
-    private StringBuilder addFlowControllerFingerprint(final StringBuilder builder, final Element flowControllerElem, final FlowController controller) {
+    private StringBuilder addFlowControllerFingerprint(final StringBuilder builder, final Element flowControllerElem, final FlowController controller, final FlowEncodingVersion encodingVersion) {
         // registries
         final Element registriesElement = DomUtils.getChild(flowControllerElem, "registries");
         if (registriesElement == null) {
@@ -216,6 +220,22 @@ private StringBuilder addFlowControllerFingerprint(final StringBuilder builder,
             }
         }
 
+        final Element contextsElement = DomUtils.getChild(flowControllerElem, "parameterContexts");
+        if (contextsElement == null) {
+            builder.append("NO_PARAMETER_CONTEXTS");
+        } else {
+            final List<Element> parameterContextElements = DomUtils.getChildElementsByTagName(contextsElement, "parameterContext");
+            if (parameterContextElements.isEmpty()) {
+                builder.append("NO_PARAMETER_CONTEXTS");
+            } else {
+                orderByChildElement(parameterContextElements, "id");
+
+                for (final Element parameterContextElement : parameterContextElements) {
+                    addParameterContext(builder, parameterContextElement);
+                }
+            }
+        }
+
         // root group
         final Element rootGroupElem = (Element) DomUtils.getChildNodesByTagName(flowControllerElem, "rootGroup").item(0);
         addProcessGroupFingerprint(builder, rootGroupElem, controller);
@@ -224,7 +244,7 @@ private StringBuilder addFlowControllerFingerprint(final StringBuilder builder,
         if (controllerServicesElem != null) {
             final List<ControllerServiceDTO> serviceDtos = new ArrayList<>();
             for (final Element serviceElem : DomUtils.getChildElementsByTagName(controllerServicesElem, "controllerService")) {
-                final ControllerServiceDTO dto = FlowFromDOMFactory.getControllerService(serviceElem, encryptor);
+                final ControllerServiceDTO dto = FlowFromDOMFactory.getControllerService(serviceElem, encryptor, encodingVersion);
                 serviceDtos.add(dto);
             }
 
@@ -254,7 +274,7 @@ public int compare(final ControllerServiceDTO o1, final ControllerServiceDTO o2)
         if (reportingTasksElem != null) {
             final List<ReportingTaskDTO> reportingTaskDtos = new ArrayList<>();
             for (final Element taskElem : DomUtils.getChildElementsByTagName(reportingTasksElem, "reportingTask")) {
-                final ReportingTaskDTO dto = FlowFromDOMFactory.getReportingTask(taskElem, encryptor);
+                final ReportingTaskDTO dto = FlowFromDOMFactory.getReportingTask(taskElem, encryptor, encodingVersion);
                 reportingTaskDtos.add(dto);
             }
 
@@ -283,6 +303,52 @@ public int compare(final ReportingTaskDTO o1, final ReportingTaskDTO o2) {
         return builder;
     }
 
+    private void orderByChildElement(final List<Element> toSort, final String childTagName) {
+        toSort.sort((a, b) -> {
+            final String valueA = DomUtils.getChildText(a, childTagName);
+            final String valueB = DomUtils.getChildText(b, childTagName );
+            return valueA.compareTo(valueB);
+        });
+    }
+
+    private StringBuilder addParameterContext(final StringBuilder builder, final Element parameterContextElement) {
+        appendFirstValue(builder, DomUtils.getChildNodesByTagName(parameterContextElement, "id"));
+        appendFirstValue(builder, DomUtils.getChildNodesByTagName(parameterContextElement, "name"));
+        appendFirstValue(builder, DomUtils.getChildNodesByTagName(parameterContextElement, "description"));
+
+        final List<Element> parameterElements = DomUtils.getChildElementsByTagName(parameterContextElement, "parameter");
+        if (parameterElements == null || parameterElements.isEmpty()) {
+            builder.append("NO_PARAMETERS");
+        } else {
+            orderByChildElement(parameterElements, "name");
+
+            for (final Element parameterElement : parameterElements) {
+                addParameter(builder, parameterElement);
+            }
+        }
+
+        return builder;
+    }
+
+    private void addParameter(final StringBuilder builder, final Element parameterElement) {
+        Stream.of("name", "description", "sensitive").forEach(elementName -> appendFirstValue(builder, DomUtils.getChildNodesByTagName(parameterElement, elementName)));
+
+        final String value = DomUtils.getChildText(parameterElement, "value");
+        if (value == null) {
+            builder.append("NO_VALUE");
+            return;
+        }
+
+        // append value
+        if (isEncrypted(value)) {
+            // propValue is non null, no need to use getValue
+            builder.append(decrypt(value));
+        } else {
+            builder.append(getValue(value, NO_VALUE));
+        }
+
+    }
+
     private StringBuilder addFlowRegistryFingerprint(final StringBuilder builder, final Element flowRegistryElement) {
         Stream.of("id", "name", "url", "description").forEach(elementName -> appendFirstValue(builder, DomUtils.getChildNodesByTagName(flowRegistryElement, elementName)));
         return builder;
@@ -292,6 +358,7 @@ private StringBuilder addProcessGroupFingerprint(final StringBuilder builder, fi
         // id
         appendFirstValue(builder, DomUtils.getChildNodesByTagName(processGroupElem, "id"));
         appendFirstValue(builder, DomUtils.getChildNodesByTagName(processGroupElem, "versionedComponentId"));
+        appendFirstValue(builder, DomUtils.getChildNodesByTagName(processGroupElem, "parameterContextId"));
 
         final Element versionControlInfo = DomUtils.getChild(processGroupElem, "versionControlInformation");
         if (versionControlInfo == null) {
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/groups/StandardProcessGroup.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/groups/StandardProcessGroup.java
index 54abd356c64..d6c0f091055 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/groups/StandardProcessGroup.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/groups/StandardProcessGroup.java
@@ -47,6 +47,7 @@
 import org.apache.nifi.controller.ControllerService;
 import org.apache.nifi.controller.FlowController;
 import org.apache.nifi.controller.ProcessorNode;
+import org.apache.nifi.controller.PropertyConfiguration;
 import org.apache.nifi.controller.ScheduledState;
 import org.apache.nifi.controller.Snippet;
 import org.apache.nifi.controller.Template;
@@ -61,6 +62,7 @@
 import org.apache.nifi.controller.service.ControllerServiceNode;
 import org.apache.nifi.controller.service.ControllerServiceProvider;
 import org.apache.nifi.controller.service.ControllerServiceReference;
+import org.apache.nifi.controller.service.ControllerServiceState;
 import org.apache.nifi.controller.service.StandardConfigurationContext;
 import org.apache.nifi.encrypt.StringEncryptor;
 import org.apache.nifi.flowfile.FlowFilePrioritizer;
@@ -68,6 +70,9 @@
 import org.apache.nifi.logging.LogRepository;
 import org.apache.nifi.logging.LogRepositoryFactory;
 import org.apache.nifi.nar.NarCloseable;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterReference;
 import org.apache.nifi.processor.Relationship;
 import org.apache.nifi.processor.StandardProcessContext;
 import org.apache.nifi.registry.ComponentVariableRegistry;
@@ -147,6 +152,7 @@
 import java.util.concurrent.locks.Lock;
 import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.function.Function;
+import java.util.function.Predicate;
 import java.util.stream.Collectors;
 
 import static java.util.Objects.requireNonNull;
@@ -180,6 +186,7 @@ public final class StandardProcessGroup implements ProcessGroup {
     private final StringEncryptor encryptor;
     private final MutableVariableRegistry variableRegistry;
     private final VersionControlFields versionControlFields = new VersionControlFields();
+    private volatile ParameterContext parameterContext;
 
     private final ReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();
     private final Lock readLock = rwLock.readLock();
@@ -875,7 +882,7 @@ public void addProcessor(final ProcessorNode processor) {
      * @param component the component whose invalid references should be removed
      */
     private void updateControllerServiceReferences(final ComponentNode component) {
-        for (final Map.Entry<PropertyDescriptor, String> entry : component.getProperties().entrySet()) {
+        for (final Map.Entry<PropertyDescriptor, String> entry : component.getEffectivePropertyValues().entrySet()) {
             final String serviceId = entry.getValue();
             if (serviceId == null) {
                 continue;
@@ -925,7 +932,7 @@ public void removeProcessor(final ProcessorNode processor) {
                 throw new ComponentLifeCycleException("Failed to invoke 'OnRemoved' methods of processor with id " + processor.getIdentifier(), e);
             }
 
-            for (final Map.Entry<PropertyDescriptor, String> entry : processor.getProperties().entrySet()) {
+            for (final Map.Entry<PropertyDescriptor, String> entry : processor.getEffectivePropertyValues().entrySet()) {
                 final PropertyDescriptor descriptor = entry.getKey();
                 if (descriptor.getControllerServiceDefinition() != null) {
                     final String value = entry.getValue() == null ? descriptor.getDefaultValue() : entry.getValue();
@@ -1639,6 +1646,20 @@ public List<ProcessGroup> findAllProcessGroups() {
         return findAllProcessGroups(this);
     }
 
+    @Override
+    public List<ProcessGroup> findAllProcessGroups(final Predicate<ProcessGroup> filter) {
+        final List<ProcessGroup> matching = new ArrayList<>();
+        if (filter.test(this)) {
+            matching.add(this);
+        }
+
+        for (final ProcessGroup group : getProcessGroups()) {
+            matching.addAll(group.findAllProcessGroups(filter));
+        }
+
+        return matching;
+    }
+
     private List<ProcessGroup> findAllProcessGroups(final ProcessGroup start) {
         final List<ProcessGroup> allProcessGroups = new ArrayList<>(start.getProcessGroups());
         for (final ProcessGroup childGroup : start.getProcessGroups()) {
@@ -2127,7 +2148,7 @@ public void removeControllerService(final ControllerServiceNode service) {
                 ReflectionUtils.quietlyInvokeMethodsWithAnnotation(OnRemoved.class, service.getControllerServiceImplementation(), configurationContext);
             }
 
-            for (final Map.Entry<PropertyDescriptor, String> entry : service.getProperties().entrySet()) {
+            for (final Map.Entry<PropertyDescriptor, String> entry : service.getEffectivePropertyValues().entrySet()) {
                 final PropertyDescriptor descriptor = entry.getKey();
                 if (descriptor.getControllerServiceDefinition() != null) {
                     final String value = entry.getValue() == null ? descriptor.getDefaultValue() : entry.getValue();
@@ -2798,6 +2819,13 @@ public void verifyCanMove(final Snippet snippet, final ProcessGroup newProcessGr
                 }
             }
 
+            final ParameterContext currentParameterContext = getParameterContext();
+            final String currentParameterContextId = currentParameterContext == null ? null : currentParameterContext.getIdentifier();
+            final ParameterContext destinationParameterContext = newProcessGroup.getParameterContext();
+            final String destinationParameterContextId = destinationParameterContext == null ? null : destinationParameterContext.getIdentifier();
+
+            final boolean parameterContextsDiffer = !Objects.equals(currentParameterContextId, destinationParameterContextId);
+
             final Set<ProcessorNode> processors = findAllProcessors(snippet);
             for (final ProcessorNode processorNode : processors) {
                 for (final PropertyDescriptor descriptor : processorNode.getProperties().keySet()) {
@@ -2805,7 +2833,7 @@ public void verifyCanMove(final Snippet snippet, final ProcessGroup newProcessGr
 
                     // if this descriptor identifies a controller service
                     if (serviceDefinition != null) {
-                        final String serviceId = processorNode.getProperty(descriptor);
+                        final String serviceId = processorNode.getEffectivePropertyValue(descriptor);
 
                         // if the processor is configured with a service
                         if (serviceId != null) {
@@ -2820,6 +2848,14 @@ public void verifyCanMove(final Snippet snippet, final ProcessGroup newProcessGr
                             }
                         }
                     }
+
+                    // If Parameter is used and the Parameter Contexts are different, then the Processor must be stopped.
+                    if (parameterContextsDiffer && processorNode.isRunning() && processorNode.isReferencingParameter()) {
+                        throw new IllegalStateException("Cannot perform Move Operation because Processor with ID " + processorNode.getIdentifier() + " references one or more Parameters, and the " +
+                            "Processor is running, and the destination Process Group is bound to a different Parameter Context that the current Process Group. This would result in changing the " +
+                            "configuration of the Processor while it is running, which is not allowed. You must first stop the Processor before moving it to another Process Group if the " +
+                            "destination's Parameter Context is not the same.");
+                    }
                 }
             }
         } finally {
@@ -2841,6 +2877,112 @@ private Set<ProcessorNode> findAllProcessors(final Snippet snippet) {
         return processors;
     }
 
+    @Override
+    public ParameterContext getParameterContext() {
+        return parameterContext;
+    }
+
+    @Override
+    public void setParameterContext(final ParameterContext parameterContext) {
+        verifyCanSetParameterContext(parameterContext);
+        this.parameterContext = parameterContext;
+
+        getProcessors().forEach(ProcessorNode::resetValidationState);
+        getControllerServices(false).forEach(ControllerServiceNode::resetValidationState);
+    }
+
+    @Override
+    public void onParameterContextUpdated() {
+        readLock.lock();
+        try {
+            for (final ProcessorNode processorNode : getProcessors()) {
+                if (processorNode.isReferencingParameter() && processorNode.getScheduledState() != ScheduledState.RUNNING) {
+                    processorNode.resetValidationState();
+                }
+            }
+
+            for (final ControllerServiceNode serviceNode : getControllerServices(false)) {
+                if (serviceNode.isReferencingParameter() && serviceNode.getState() == ControllerServiceState.DISABLING || serviceNode.getState() == ControllerServiceState.DISABLED) {
+                    serviceNode.resetValidationState();
+                }
+            }
+        } finally {
+            readLock.unlock();
+        }
+    }
+
+    @Override
+    public void verifyCanSetParameterContext(final ParameterContext parameterContext) {
+        readLock.lock();
+        try {
+            if (Objects.equals(parameterContext, getParameterContext())) {
+                return;
+            }
+
+            for (final ProcessorNode processor : processors.values()) {
+                final boolean referencingParam = processor.isReferencingParameter();
+                if (!referencingParam) {
+                    continue;
+                }
+
+                if (processor.isRunning()) {
+                    throw new IllegalStateException("Cannot change Parameter Context for " + this + " because " + processor + " is referencing at least one Parameter and is running");
+                }
+
+                verifyParameterSensitivityIsValid(processor, parameterContext);
+            }
+
+            for (final ControllerServiceNode service : controllerServices.values()) {
+                final boolean referencingParam = service.isReferencingParameter();
+                if (!referencingParam) {
+                    continue;
+                }
+
+                if (service.getState() != ControllerServiceState.DISABLED) {
+                    throw new IllegalStateException("Cannot change Parameter Context for " + this + " because " + service + " is referencing at least one Parameter is is not disabled");
+                }
+
+                verifyParameterSensitivityIsValid(service, parameterContext);
+            }
+        } finally {
+            readLock.unlock();
+        }
+    }
+
+    private void verifyParameterSensitivityIsValid(final ComponentNode component, final ParameterContext parameterContext) {
+        if (parameterContext == null) {
+            return;
+        }
+
+        final Map<PropertyDescriptor, PropertyConfiguration> properties = component.getProperties();
+        for (final Map.Entry<PropertyDescriptor, PropertyConfiguration> entry : properties.entrySet()) {
+            final PropertyConfiguration configuration = entry.getValue();
+            if (configuration == null) {
+                continue;
+            }
+
+            for (final ParameterReference reference : configuration.getParameterReferences()) {
+                final String paramName = reference.getParameterName();
+                final Optional<Parameter> parameter = parameterContext.getParameter(paramName);
+
+                if (parameter.isPresent()) {
+                    final PropertyDescriptor propertyDescriptor = entry.getKey();
+                    if (parameter.get().getDescriptor().isSensitive() && !propertyDescriptor.isSensitive()) {
+                        throw new IllegalStateException("Cannot change Parameter Context for " + this + " because " + component + " is referencing Parameter '" + paramName
+                            + "' from the '" + propertyDescriptor.getDisplayName() + "' property and the Parameter is sensitive. Sensitive Parameters may only be referenced " +
+                            "by sensitive properties.");
+                    }
+
+                    if (!parameter.get().getDescriptor().isSensitive() && propertyDescriptor.isSensitive()) {
+                        throw new IllegalStateException("Cannot change Parameter Context for " + this + " because " + component + " is referencing Parameter '" + paramName
+                            + "' from a sensitive property and the Parameter is not sensitive. Sensitive properties may only reference " +
+                            "by Sensitive Parameters.");
+                    }
+                }
+            }
+        }
+    }
+
     @Override
     public MutableVariableRegistry getVariableRegistry() {
         return variableRegistry;
@@ -2997,9 +3139,9 @@ private Set<String> getUpdatedVariables(final Map<String, String> newVariableVal
     }
 
     private List<VariableImpact> getVariableImpact(final ComponentNode component) {
-        return component.getProperties().keySet().stream()
+        return component.getEffectivePropertyValues().keySet().stream()
                 .map(descriptor -> {
-                    final String configuredVal = component.getProperty(descriptor);
+                    final String configuredVal = component.getEffectivePropertyValue(descriptor);
                     return configuredVal == null ? descriptor.getDefaultValue() : configuredVal;
                 })
                 .map(propVal -> Query.prepare(propVal).getVariableImpact())
@@ -4166,12 +4308,12 @@ private void updateControllerService(final ControllerServiceNode service, final
             service.setComments(proposed.getComments());
             service.setName(proposed.getName());
 
-            final Map<String, String> properties = populatePropertiesMap(service.getProperties(), proposed.getProperties(), proposed.getPropertyDescriptors(), service.getProcessGroup());
+            final Map<String, String> properties = populatePropertiesMap(service.getEffectivePropertyValues(), proposed.getProperties(), proposed.getPropertyDescriptors(), service.getProcessGroup());
             service.setProperties(properties, true);
 
             if (!isEqual(service.getBundleCoordinate(), proposed.getBundle())) {
                 final BundleCoordinate newBundleCoordinate = toCoordinate(proposed.getBundle());
-                final List<PropertyDescriptor> descriptors = new ArrayList<>(service.getProperties().keySet());
+                final List<PropertyDescriptor> descriptors = new ArrayList<>(service.getRawPropertyValues().keySet());
                 final Set<URL> additionalUrls = service.getAdditionalClasspathResources(descriptors);
                 flowController.getReloadComponent().reload(service, proposed.getType(), newBundleCoordinate, additionalUrls);
             }
@@ -4305,7 +4447,7 @@ private void updateProcessor(final ProcessorNode processor, final VersionedProce
             processor.setName(proposed.getName());
             processor.setPenalizationPeriod(proposed.getPenaltyDuration());
 
-            final Map<String, String> properties = populatePropertiesMap(processor.getProperties(), proposed.getProperties(), proposed.getPropertyDescriptors(), processor.getProcessGroup());
+            final Map<String, String> properties = populatePropertiesMap(processor.getRawPropertyValues(), proposed.getProperties(), proposed.getPropertyDescriptors(), processor.getProcessGroup());
             processor.setProperties(properties, true);
             processor.setRunDuration(proposed.getRunDurationMillis(), TimeUnit.MILLISECONDS);
             processor.setSchedulingStrategy(SchedulingStrategy.valueOf(proposed.getSchedulingStrategy()));
@@ -4528,8 +4670,7 @@ public void verifyCanUpdate(final VersionedFlowSnapshot updatedFlow, final boole
                 // any connection that does exist in the proposed flow. This results in us having a Map whose values are those Connections
                 // that were removed. We can then check for any connections that have data in them. If any Connection is to be removed but
                 // has data, then we should throw an IllegalStateException.
-                findAllConnections().stream()
-                        .forEach(conn -> removedConnectionByVersionedId.put(conn.getVersionedComponentId().orElse(conn.getIdentifier()), conn));
+                findAllConnections().forEach(conn -> removedConnectionByVersionedId.put(conn.getVersionedComponentId().orElse(conn.getIdentifier()), conn));
 
                 final Set<String> proposedFlowConnectionIds = new HashSet<>();
                 findAllConnectionIds(flowContents, proposedFlowConnectionIds);
@@ -4609,7 +4750,7 @@ public void verifyCanUpdate(final VersionedFlowSnapshot updatedFlow, final boole
                 }
             }
 
-            // Ensure that all Processors are instantiate-able.
+            // Ensure that all Processors are instantiable
             final Map<String, VersionedProcessor> proposedProcessors = new HashMap<>();
             findAllProcessors(updatedFlow.getFlowContents(), proposedProcessors);
 
@@ -4629,7 +4770,7 @@ public void verifyCanUpdate(final VersionedFlowSnapshot updatedFlow, final boole
                 }
             }
 
-            // Ensure that all Controller Services are instantiate-able.
+            // Ensure that all Controller Services are instantiable
             final Map<String, VersionedControllerService> proposedServices = new HashMap<>();
             findAllControllerServices(updatedFlow.getFlowContents(), proposedServices);
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/parameter/StandardParameterContext.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/parameter/StandardParameterContext.java
new file mode 100644
index 00000000000..e5d12a5173c
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/parameter/StandardParameterContext.java
@@ -0,0 +1,306 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import org.apache.nifi.authorization.Resource;
+import org.apache.nifi.authorization.resource.Authorizable;
+import org.apache.nifi.authorization.resource.ResourceFactory;
+import org.apache.nifi.authorization.resource.ResourceType;
+import org.apache.nifi.components.PropertyDescriptor;
+import org.apache.nifi.controller.ComponentNode;
+import org.apache.nifi.controller.ProcessorNode;
+import org.apache.nifi.controller.PropertyConfiguration;
+import org.apache.nifi.controller.service.ControllerServiceNode;
+import org.apache.nifi.controller.service.ControllerServiceState;
+import org.apache.nifi.groups.ProcessGroup;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReadWriteLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+public class StandardParameterContext implements ParameterContext {
+    private static final Logger logger = LoggerFactory.getLogger(StandardParameterContext.class);
+
+    private final String id;
+    private final ParameterReferenceManager parameterReferenceManager;
+    private final Authorizable parentAuthorizable;
+
+    private String name;
+    private long version = 0L;
+    private final Map<ParameterDescriptor, Parameter> parameters = new LinkedHashMap<>();
+    private volatile String description;
+
+    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
+    private final Lock readLock = rwLock.readLock();
+    private final Lock writeLock = rwLock.writeLock();
+
+
+    public StandardParameterContext(final String id, final String name, final ParameterReferenceManager parameterReferenceManager, final Authorizable parentAuthorizable) {
+        this.id = Objects.requireNonNull(id);
+        this.name = Objects.requireNonNull(name);
+        this.parameterReferenceManager = parameterReferenceManager;
+        this.parentAuthorizable = parentAuthorizable;
+    }
+
+    @Override
+    public String getIdentifier() {
+        return id;
+    }
+
+    public String getName() {
+        readLock.lock();
+        try {
+            return name;
+        } finally {
+            readLock.unlock();
+        }
+    }
+
+    public void setName(final String name) {
+        writeLock.lock();
+        try {
+            this.version++;
+            this.name = name;
+        } finally {
+            writeLock.unlock();
+        }
+    }
+
+    @Override
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    @Override
+    public String getDescription() {
+        return description;
+    }
+
+    public void setParameters(final Set<Parameter> updatedParameters) {
+        writeLock.lock();
+        try {
+            this.version++;
+
+            verifyCanSetParameters(updatedParameters);
+
+            boolean changeAffectingComponents = false;
+            for (final Parameter parameter : updatedParameters) {
+                if (parameter.getValue() == null && parameter.getDescriptor().getDescription() == null) {
+                    parameters.remove(parameter.getDescriptor());
+                    changeAffectingComponents = true;
+                } else if (parameter.getValue() == null) {
+                    // Value is null but description is not. Just update the description of the existing Parameter.
+                    final Parameter existingParameter = parameters.get(parameter.getDescriptor());
+                    final ParameterDescriptor existingDescriptor = existingParameter.getDescriptor();
+                    final ParameterDescriptor replacementDescriptor = new ParameterDescriptor.Builder()
+                        .from(existingDescriptor)
+                        .description(parameter.getDescriptor().getDescription())
+                        .build();
+
+                    final Parameter replacementParameter = new Parameter(replacementDescriptor, existingParameter.getValue());
+                    parameters.put(parameter.getDescriptor(), replacementParameter);
+                } else {
+                    parameters.put(parameter.getDescriptor(), parameter);
+                    changeAffectingComponents = true;
+                }
+            }
+
+            if (changeAffectingComponents) {
+                for (final ProcessGroup processGroup : parameterReferenceManager.getProcessGroupsBound(this)) {
+                    try {
+                        processGroup.onParameterContextUpdated();
+                    } catch (final Exception e) {
+                        logger.error("Failed to notify {} that Parameter Context was updated", processGroup, e);
+                    }
+                }
+            }
+        } finally {
+            writeLock.unlock();
+        }
+    }
+
+    @Override
+    public long getVersion() {
+        readLock.lock();
+        try {
+            return version;
+        } finally {
+            readLock.unlock();
+        }
+    }
+
+    public Optional<Parameter> getParameter(final String parameterName) {
+        readLock.lock();
+        try {
+            final ParameterDescriptor descriptor = new ParameterDescriptor.Builder().name(parameterName).build();
+            return getParameter(descriptor);
+        } finally {
+            readLock.unlock();
+        }
+    }
+
+    @Override
+    public boolean isEmpty() {
+        readLock.lock();
+        try {
+            return parameters.isEmpty();
+        } finally {
+            readLock.unlock();
+        }
+    }
+
+    public Optional<Parameter> getParameter(final ParameterDescriptor parameterDescriptor) {
+        readLock.lock();
+        try {
+            return Optional.ofNullable(parameters.get(parameterDescriptor));
+        } finally {
+            readLock.unlock();
+        }
+    }
+
+    @Override
+    public Map<ParameterDescriptor, Parameter> getParameters() {
+        readLock.lock();
+        try {
+            return new LinkedHashMap<>(parameters);
+        } finally {
+            readLock.unlock();
+        }
+    }
+
+    @Override
+    public ParameterReferenceManager getParameterReferenceManager() {
+        return parameterReferenceManager;
+    }
+
+    @Override
+    public void verifyCanSetParameters(final Set<Parameter> updatedParameters) {
+        // Ensure that the updated parameters will not result in changing the sensitivity flag of any parameter.
+        for (final Parameter updatedParameter : updatedParameters) {
+            validateSensitiveFlag(updatedParameter);
+
+            // Parameters' names and sensitivity flags are immutable. However, the description and value are mutable. If both value and description are
+            // set to `null`, this is the indication that the Parameter should be removed. If the value is `null` but the Description is supplied, the user
+            // is indicating that only the description is to be changed.
+            if (updatedParameter.getValue() == null && updatedParameter.getDescriptor().getDescription() == null) {
+                validateReferencingComponents(updatedParameter, "remove");
+            } else if (updatedParameter.getValue() != null) {
+                validateReferencingComponents(updatedParameter, "update");
+            } else {
+                // Only parameter is changing. No value is set. This means that the Parameter must already exist.
+                final Optional<Parameter> existing = getParameter(updatedParameter.getDescriptor());
+                if (!existing.isPresent()) {
+                    throw new IllegalStateException("Cannot add Parameter '" + updatedParameter.getDescriptor().getName() + "' without providing a value");
+                }
+            }
+        }
+    }
+
+    private void validateSensitiveFlag(final Parameter updatedParameter) {
+        final ParameterDescriptor updatedDescriptor = updatedParameter.getDescriptor();
+        final Parameter existingParameter = parameters.get(updatedDescriptor);
+
+        if (existingParameter == null) {
+            return;
+        }
+
+        final ParameterDescriptor existingDescriptor = existingParameter.getDescriptor();
+        if (existingDescriptor.isSensitive() != updatedDescriptor.isSensitive() && updatedParameter.getValue() != null) {
+            final String existingSensitiveDescription = existingDescriptor.isSensitive() ? "sensitive" : "not sensitive";
+            final String updatedSensitiveDescription = updatedDescriptor.isSensitive() ? "sensitive" : "not sensitive";
+
+            throw new IllegalStateException("Cannot update Parameters because doing so would change Parameter '" + existingDescriptor.getName() + "' from " + existingSensitiveDescription
+                + " to " + updatedSensitiveDescription);
+        }
+    }
+
+
+    private void validateReferencingComponents(final Parameter updatedParameter, final String parameterAction) {
+        final String paramName = updatedParameter.getDescriptor().getName();
+
+        for (final ProcessorNode procNode : parameterReferenceManager.getProcessorsReferencing(this, paramName)) {
+            if (procNode.isRunning()) {
+                throw new IllegalStateException("Cannot " + parameterAction + " parameter '" + paramName + "' because it is referenced by " + procNode + ", which is currently running");
+            }
+
+            validateParameterSensitivity(updatedParameter, procNode);
+        }
+
+        for (final ControllerServiceNode serviceNode : parameterReferenceManager.getControllerServicesReferencing(this, paramName)) {
+            final ControllerServiceState serviceState = serviceNode.getState();
+            if (serviceState != ControllerServiceState.DISABLED) {
+                throw new IllegalStateException("Cannot " + parameterAction + " parameter '" + paramName + "' because it is referenced by "
+                    + serviceNode + ", which currently has a state of " + serviceState);
+            }
+
+            validateParameterSensitivity(updatedParameter, serviceNode);
+        }
+    }
+
+    private void validateParameterSensitivity(final Parameter parameter, final ComponentNode componentNode) {
+        final String paramName = parameter.getDescriptor().getName();
+
+        for (final Map.Entry<PropertyDescriptor, PropertyConfiguration> entry :  componentNode.getProperties().entrySet()) {
+            final PropertyConfiguration configuration = entry.getValue();
+            if (configuration == null) {
+                continue;
+            }
+
+            for (final ParameterReference reference : configuration.getParameterReferences()) {
+                if (parameter.getDescriptor().getName().equals(reference.getParameterName())) {
+                    final PropertyDescriptor propertyDescriptor = entry.getKey();
+                    if (propertyDescriptor.isSensitive() && !parameter.getDescriptor().isSensitive()) {
+                        throw new IllegalStateException("Cannot add Parameter with name '" + paramName + "' unless that Parameter is Sensitive because a Parameter with that name is already " +
+                            "referenced from a Sensitive Property");
+                    }
+
+                    if (!propertyDescriptor.isSensitive() && parameter.getDescriptor().isSensitive()) {
+                        throw new IllegalStateException("Cannot add Parameter with name '" + paramName + "' unless that Parameter is Not Sensitive because a Parameter with that name is already " +
+                            "referenced from a Property that is not Sensitive");
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public Authorizable getParentAuthorizable() {
+        return new Authorizable() {
+            @Override
+            public Authorizable getParentAuthorizable() {
+                return parentAuthorizable;
+            }
+
+            @Override
+            public Resource getResource() {
+                return ResourceFactory.getParameterContextsResource();
+            }
+        };
+    }
+
+    @Override
+    public Resource getResource() {
+        return ResourceFactory.getComponentResource(ResourceType.ParameterContext, getIdentifier(), getName());
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/parameter/StandardParameterContextManager.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/parameter/StandardParameterContextManager.java
new file mode 100644
index 00000000000..dbaf75c4964
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/parameter/StandardParameterContextManager.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+
+public class StandardParameterContextManager implements ParameterContextManager {
+    private final Map<String, ParameterContext> parameterContexts = new HashMap<>();
+
+    @Override
+    public synchronized ParameterContext getParameterContext(final String id) {
+        return parameterContexts.get(id);
+    }
+
+    @Override
+    public synchronized void addParameterContext(final ParameterContext parameterContext) {
+        Objects.requireNonNull(parameterContext);
+
+        if (parameterContexts.containsKey(parameterContext.getIdentifier())) {
+            throw new IllegalStateException("Cannot add Parameter Context because another Parameter Context already exists with the same ID");
+        }
+
+        for (final ParameterContext context : parameterContexts.values()) {
+            if (context.getName().equals(parameterContext.getName())) {
+                throw new IllegalStateException("Cannot add Parameter Context because another Parameter Context already exists with the name '" + parameterContext + "'");
+            }
+        }
+
+        parameterContexts.put(parameterContext.getIdentifier(), parameterContext);
+    }
+
+    @Override
+    public synchronized ParameterContext removeParameterContext(final String parameterContextId) {
+        Objects.requireNonNull(parameterContextId);
+        return parameterContexts.remove(parameterContextId);
+    }
+
+    @Override
+    public synchronized Set<ParameterContext> getParameterContexts() {
+        return new HashSet<>(parameterContexts.values());
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/parameter/StandardParameterReferenceManager.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/parameter/StandardParameterReferenceManager.java
new file mode 100644
index 00000000000..63d95ca3ecc
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/parameter/StandardParameterReferenceManager.java
@@ -0,0 +1,98 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import org.apache.nifi.controller.ComponentNode;
+import org.apache.nifi.controller.ProcessorNode;
+import org.apache.nifi.controller.PropertyConfiguration;
+import org.apache.nifi.controller.flow.FlowManager;
+import org.apache.nifi.controller.service.ControllerServiceNode;
+import org.apache.nifi.groups.ProcessGroup;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.function.Function;
+
+public class StandardParameterReferenceManager implements ParameterReferenceManager {
+    private final FlowManager flowManager;
+
+    // TODO: Consider reworking this so that we don't have to recurse through all components all the time and instead
+    //  have a 'caching' impl that AbstractComponentNode.setProperties() adds to/subtracts from.
+    public StandardParameterReferenceManager(final FlowManager flowManager) {
+        this.flowManager = flowManager;
+    }
+
+    @Override
+    public Set<ProcessorNode> getProcessorsReferencing(final ParameterContext parameterContext, final String parameterName) {
+        return getComponentsReferencing(parameterContext, parameterName, ProcessGroup::getProcessors);
+    }
+
+    @Override
+    public Set<ControllerServiceNode> getControllerServicesReferencing(final ParameterContext parameterContext, final String parameterName) {
+        return getComponentsReferencing(parameterContext, parameterName, group -> group.getControllerServices(false));
+    }
+
+    @Override
+    public Set<ProcessGroup> getProcessGroupsBound(final ParameterContext parameterContext) {
+        final ProcessGroup rootGroup = flowManager.getRootGroup();
+        final String contextId = parameterContext.getIdentifier();
+        final List<ProcessGroup> referencingGroups = rootGroup.findAllProcessGroups(
+            group -> group.getParameterContext() != null && group.getParameterContext().getIdentifier().equals(contextId));
+
+        return new HashSet<>(referencingGroups);
+    }
+
+    private <T extends ComponentNode> Set<T> getComponentsReferencing(final ParameterContext parameterContext, final String parameterName,
+                                                                      final Function<ProcessGroup, Collection<T>> componentFunction) {
+        final Set<T> referencingComponents = new HashSet<>();
+
+        final ProcessGroup rootGroup = flowManager.getRootGroup();
+        final String contextId = parameterContext.getIdentifier();
+        final List<ProcessGroup> referencingGroups = rootGroup.findAllProcessGroups(
+            group -> group.getParameterContext() != null && group.getParameterContext().getIdentifier().equals(contextId));
+
+        for (final ProcessGroup group : referencingGroups) {
+            for (final T componentNode : componentFunction.apply(group)) {
+                if (isComponentReferencing(componentNode, parameterName)) {
+                    referencingComponents.add(componentNode);
+                    continue;
+                }
+            }
+        }
+
+        return referencingComponents;
+    }
+
+    private boolean isComponentReferencing(final ComponentNode componentNode, final String parameterName) {
+        for (final PropertyConfiguration configuration : componentNode.getProperties().values()) {
+            if (configuration == null) {
+                continue;
+            }
+
+            for (final ParameterReference reference : configuration.getParameterReferences()) {
+                if (parameterName.equals(reference.getParameterName())) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/persistence/TemplateDeserializer.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/persistence/TemplateDeserializer.java
index b19173bc7b6..43e89ccf91c 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/persistence/TemplateDeserializer.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/persistence/TemplateDeserializer.java
@@ -50,9 +50,13 @@ public static TemplateDTO deserialize(final StreamSource source) {
             final XMLStreamReader xsr = XmlUtils.createSafeReader(source);
             final Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
             final JAXBElement<TemplateDTO> templateElement = unmarshaller.unmarshal(xsr, TemplateDTO.class);
-            return templateElement.getValue();
+            final TemplateDTO templateDto = templateElement.getValue();
+
+            return templateDto;
         } catch (final JAXBException | XMLStreamException e) {
             throw new FlowSerializationException(e);
         }
     }
+
+
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/processor/StandardProcessContext.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/processor/StandardProcessContext.java
index 299f73ba58d..6a51cc1d540 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/processor/StandardProcessContext.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/processor/StandardProcessContext.java
@@ -53,15 +53,17 @@ public class StandardProcessContext implements ProcessContext, ControllerService
     private final Map<PropertyDescriptor, String> properties;
 
     public StandardProcessContext(final ProcessorNode processorNode, final ControllerServiceProvider controllerServiceProvider, final StringEncryptor encryptor, final StateManager stateManager,
-            final TaskTermination taskTermination) {
+                                  final TaskTermination taskTermination) {
         this.procNode = processorNode;
         this.controllerServiceProvider = controllerServiceProvider;
         this.encryptor = encryptor;
         this.stateManager = stateManager;
         this.taskTermination = taskTermination;
 
+        properties = Collections.unmodifiableMap(processorNode.getEffectivePropertyValues());
+
         preparedQueries = new HashMap<>();
-        for (final Map.Entry<PropertyDescriptor, String> entry : procNode.getProperties().entrySet()) {
+        for (final Map.Entry<PropertyDescriptor, String> entry : processorNode.getRawPropertyValues().entrySet()) {
             final PropertyDescriptor desc = entry.getKey();
             String value = entry.getValue();
             if (value == null) {
@@ -73,8 +75,6 @@ public StandardProcessContext(final ProcessorNode processorNode, final Controlle
                 preparedQueries.put(desc, pq);
             }
         }
-
-        properties = Collections.unmodifiableMap(processorNode.getProperties());
     }
 
     private void verifyTaskActive() {
@@ -89,14 +89,14 @@ public PropertyValue getProperty(final PropertyDescriptor descriptor) {
 
         final String setPropertyValue = properties.get(descriptor);
         if (setPropertyValue != null) {
-            return new StandardPropertyValue(setPropertyValue, this, preparedQueries.get(descriptor), procNode.getVariableRegistry());
+            return new StandardPropertyValue(setPropertyValue, this, procNode.getParameterLookup(), preparedQueries.get(descriptor), procNode.getVariableRegistry());
         }
 
         // Get the "canonical" Property Descriptor from the Processor
         final PropertyDescriptor canonicalDescriptor = procNode.getProcessor().getPropertyDescriptor(descriptor.getName());
         final String defaultValue = canonicalDescriptor.getDefaultValue();
 
-        return new StandardPropertyValue(defaultValue, this, preparedQueries.get(descriptor), procNode.getVariableRegistry());
+        return new StandardPropertyValue(defaultValue, this, procNode.getParameterLookup(), preparedQueries.get(descriptor), procNode.getVariableRegistry());
     }
 
     /**
@@ -116,13 +116,13 @@ public PropertyValue getProperty(final String propertyName) {
         final String setPropertyValue = properties.get(descriptor);
         final String propValue = (setPropertyValue == null) ? descriptor.getDefaultValue() : setPropertyValue;
 
-        return new StandardPropertyValue(propValue, this, preparedQueries.get(descriptor), procNode.getVariableRegistry());
+        return new StandardPropertyValue(propValue, this, procNode.getParameterLookup(), preparedQueries.get(descriptor), procNode.getVariableRegistry());
     }
 
     @Override
     public PropertyValue newPropertyValue(final String rawValue) {
         verifyTaskActive();
-        return new StandardPropertyValue(rawValue, this, Query.prepare(rawValue), procNode.getVariableRegistry());
+        return new StandardPropertyValue(rawValue, this, procNode.getParameterLookup(), Query.prepareWithParametersPreEvaluated(rawValue), procNode.getVariableRegistry());
     }
 
     @Override
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/processor/StandardValidationContext.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/processor/StandardValidationContext.java
index 58bd5cba35c..b1a44e7f8db 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/processor/StandardValidationContext.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/processor/StandardValidationContext.java
@@ -17,13 +17,6 @@
  */
 package org.apache.nifi.processor;
 
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
 import org.apache.nifi.attribute.expression.language.PreparedQuery;
 import org.apache.nifi.attribute.expression.language.Query;
 import org.apache.nifi.attribute.expression.language.Query.Range;
@@ -34,48 +27,61 @@
 import org.apache.nifi.components.ValidationContext;
 import org.apache.nifi.controller.ControllerService;
 import org.apache.nifi.controller.ControllerServiceLookup;
+import org.apache.nifi.controller.PropertyConfiguration;
 import org.apache.nifi.controller.service.ControllerServiceNode;
 import org.apache.nifi.controller.service.ControllerServiceProvider;
 import org.apache.nifi.controller.service.ControllerServiceState;
 import org.apache.nifi.expression.ExpressionLanguageCompiler;
 import org.apache.nifi.groups.ProcessGroup;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterReference;
 import org.apache.nifi.registry.VariableRegistry;
 
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.stream.Collectors;
+
 public class StandardValidationContext implements ValidationContext {
 
     private final ControllerServiceProvider controllerServiceProvider;
-    private final Map<PropertyDescriptor, String> properties;
+    private final Map<PropertyDescriptor, PropertyConfiguration> properties;
     private final Map<PropertyDescriptor, PreparedQuery> preparedQueries;
     private final Map<String, Boolean> expressionLanguageSupported;
     private final String annotationData;
     private final VariableRegistry variableRegistry;
     private final String groupId;
     private final String componentId;
+    private final ParameterContext parameterContext;
+    private final AtomicReference<Map<PropertyDescriptor, String>> effectiveValuesRef = new AtomicReference<>();
 
-    public StandardValidationContext(final ControllerServiceProvider controllerServiceProvider, final Map<PropertyDescriptor, String> properties,
-            final String annotationData, final String groupId, final String componentId, final VariableRegistry variableRegistry) {
-        this(controllerServiceProvider, Collections.<String> emptySet(), properties, annotationData, groupId, componentId, variableRegistry);
-    }
 
     public StandardValidationContext(
             final ControllerServiceProvider controllerServiceProvider,
-            final Set<String> serviceIdentifiersToNotValidate,
-            final Map<PropertyDescriptor, String> properties,
+            final Map<PropertyDescriptor, PropertyConfiguration> properties,
             final String annotationData,
             final String groupId,
             final String componentId,
-            final VariableRegistry variableRegistry) {
+            final VariableRegistry variableRegistry,
+            final ParameterContext parameterContext) {
         this.controllerServiceProvider = controllerServiceProvider;
         this.properties = new HashMap<>(properties);
         this.annotationData = annotationData;
         this.variableRegistry = variableRegistry;
         this.groupId = groupId;
         this.componentId = componentId;
+        this.parameterContext = parameterContext;
 
         preparedQueries = new HashMap<>(properties.size());
-        for (final Map.Entry<PropertyDescriptor, String> entry : properties.entrySet()) {
+        for (final Map.Entry<PropertyDescriptor, PropertyConfiguration> entry : properties.entrySet()) {
             final PropertyDescriptor desc = entry.getKey();
-            String value = entry.getValue();
+            final PropertyConfiguration configuration = entry.getValue();
+
+            String value = (configuration == null) ? null : configuration.getEffectiveValue(parameterContext);
             if (value == null) {
                 value = desc.getDefaultValue();
             }
@@ -92,12 +98,12 @@ public StandardValidationContext(
 
     @Override
     public PropertyValue newPropertyValue(final String rawValue) {
-        return new StandardPropertyValue(rawValue, controllerServiceProvider, Query.prepare(rawValue), variableRegistry);
+        return new StandardPropertyValue(rawValue, controllerServiceProvider, parameterContext, Query.prepareWithParametersPreEvaluated(rawValue), variableRegistry);
     }
 
     @Override
     public ExpressionLanguageCompiler newExpressionLanguageCompiler() {
-        return new StandardExpressionLanguageCompiler(variableRegistry);
+        return new StandardExpressionLanguageCompiler(variableRegistry, parameterContext);
     }
 
     @Override
@@ -105,18 +111,36 @@ public ValidationContext getControllerServiceValidationContext(final ControllerS
         final ControllerServiceNode serviceNode = controllerServiceProvider.getControllerServiceNode(controllerService.getIdentifier());
         final ProcessGroup serviceGroup = serviceNode.getProcessGroup();
         final String serviceGroupId = serviceGroup == null ? null : serviceGroup.getIdentifier();
-        return new StandardValidationContext(controllerServiceProvider, serviceNode.getProperties(), serviceNode.getAnnotationData(), serviceGroupId, serviceNode.getIdentifier(),variableRegistry);
+        return new StandardValidationContext(controllerServiceProvider, serviceNode.getProperties(), serviceNode.getAnnotationData(), serviceGroupId,
+            serviceNode.getIdentifier(), variableRegistry, serviceNode.getProcessGroup().getParameterContext());
     }
 
     @Override
     public PropertyValue getProperty(final PropertyDescriptor property) {
-        final String configuredValue = properties.get(property);
-        return new StandardPropertyValue(configuredValue == null ? property.getDefaultValue() : configuredValue, controllerServiceProvider, preparedQueries.get(property), variableRegistry);
+        final PropertyConfiguration configuredValue = properties.get(property);
+        final String effectiveValue = configuredValue == null ? property.getDefaultValue() : configuredValue.getEffectiveValue(parameterContext);
+        return new StandardPropertyValue(effectiveValue, controllerServiceProvider, parameterContext, preparedQueries.get(property), variableRegistry);
     }
 
     @Override
     public Map<PropertyDescriptor, String> getProperties() {
-        return Collections.unmodifiableMap(properties);
+        final Map<PropertyDescriptor, String> effectiveValues = effectiveValuesRef.get();
+        if (effectiveValues != null) {
+            return effectiveValues;
+        }
+
+        final Map<PropertyDescriptor, String> valueMap = new LinkedHashMap<>();
+        for (final Map.Entry<PropertyDescriptor, PropertyConfiguration> entry : this.properties.entrySet()) {
+            final PropertyDescriptor descriptor = entry.getKey();
+            final PropertyConfiguration configuration = entry.getValue();
+            final String value = configuration == null ? descriptor.getDefaultValue() : configuration.getEffectiveValue(parameterContext);
+
+            valueMap.put(entry.getKey(), value);
+        }
+
+        final Map<PropertyDescriptor, String> immutableValueMap = Collections.unmodifiableMap(valueMap);
+        effectiveValuesRef.compareAndSet(null, immutableValueMap);
+        return immutableValueMap;
     }
 
     @Override
@@ -170,6 +194,28 @@ public String getProcessGroupIdentifier() {
         return groupId;
     }
 
+    @Override
+    public Collection<String> getReferencedParameters(final String propertyName) {
+        final PropertyDescriptor descriptor = new PropertyDescriptor.Builder().name(propertyName).build();
+        final PropertyConfiguration configuration = this.properties.get(descriptor);
+        if (configuration == null) {
+            return Collections.emptyList();
+        }
+
+        final List<ParameterReference> references = configuration.getParameterReferences();
+        final List<String> parameterNames = references.stream().map(ParameterReference::getParameterName).collect(Collectors.toList());
+        return parameterNames;
+    }
+
+    @Override
+    public boolean isParameterDefined(final String parameterName) {
+        if (parameterContext == null) {
+            return false;
+        }
+
+        return parameterContext.getParameter(parameterName).isPresent();
+    }
+
     @Override
     public String toString() {
         return "StandardValidationContext[componentId=" + componentId + ", properties=" + properties + "]";
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/processor/StandardValidationContextFactory.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/processor/StandardValidationContextFactory.java
index 020e979796e..3485f9b09fd 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/processor/StandardValidationContextFactory.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/processor/StandardValidationContextFactory.java
@@ -16,15 +16,16 @@
  */
 package org.apache.nifi.processor;
 
-import java.util.Map;
-import java.util.Set;
-
 import org.apache.nifi.components.PropertyDescriptor;
 import org.apache.nifi.components.ValidationContext;
+import org.apache.nifi.controller.PropertyConfiguration;
 import org.apache.nifi.controller.ValidationContextFactory;
 import org.apache.nifi.controller.service.ControllerServiceProvider;
+import org.apache.nifi.parameter.ParameterContext;
 import org.apache.nifi.registry.VariableRegistry;
 
+import java.util.Map;
+
 public class StandardValidationContextFactory implements ValidationContextFactory {
 
     private final ControllerServiceProvider serviceProvider;
@@ -36,13 +37,8 @@ public StandardValidationContextFactory(final ControllerServiceProvider serviceP
     }
 
     @Override
-    public ValidationContext newValidationContext(final Map<PropertyDescriptor, String> properties, final String annotationData, final String groupId, final String componentId) {
-        return new StandardValidationContext(serviceProvider, properties, annotationData, groupId, componentId,variableRegistry);
-    }
-
-    @Override
-    public ValidationContext newValidationContext(final Set<String> serviceIdentifiersToNotValidate,
-            final Map<PropertyDescriptor, String> properties, final String annotationData, final String groupId, String componentId) {
-        return new StandardValidationContext(serviceProvider, serviceIdentifiersToNotValidate, properties, annotationData, groupId, componentId,variableRegistry);
+    public ValidationContext newValidationContext(final Map<PropertyDescriptor, PropertyConfiguration> properties, final String annotationData, final String groupId, final String componentId,
+                                                  final ParameterContext parameterContext) {
+        return new StandardValidationContext(serviceProvider, properties, annotationData, groupId, componentId, variableRegistry, parameterContext);
     }
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/RestBasedFlowRegistry.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/RestBasedFlowRegistry.java
index 261c0aa7e8e..08168b106ec 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/RestBasedFlowRegistry.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/RestBasedFlowRegistry.java
@@ -29,9 +29,11 @@
 
 import javax.net.ssl.SSLContext;
 import java.io.IOException;
+import java.util.Collection;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
+import java.util.stream.Collectors;
 
 public class RestBasedFlowRegistry implements FlowRegistry {
 
@@ -175,13 +177,18 @@ public VersionedFlow deleteVersionedFlow(final String bucketId, final String flo
 
     @Override
     public VersionedFlowSnapshot registerVersionedFlowSnapshot(final VersionedFlow flow, final VersionedProcessGroup snapshot,
-                                                               final Map<String, ExternalControllerServiceReference> externalControllerServices, final String comments, final int expectedVersion,
+                                                               final Map<String, ExternalControllerServiceReference> externalControllerServices,
+                                                               Collection<VersionedParameterContext> parameterContexts, final String comments, final int expectedVersion,
                                                                final NiFiUser user) throws IOException, NiFiRegistryException {
 
+        final Map<String, VersionedParameterContext> parameterContextMap = parameterContexts.stream()
+            .collect(Collectors.toMap(VersionedParameterContext::getName, context -> context));
+
         final FlowSnapshotClient snapshotClient = getFlowSnapshotClient(user);
         final VersionedFlowSnapshot versionedFlowSnapshot = new VersionedFlowSnapshot();
         versionedFlowSnapshot.setFlowContents(snapshot);
         versionedFlowSnapshot.setExternalControllerServices(externalControllerServices);
+        versionedFlowSnapshot.setParameterContexts(parameterContextMap);
 
         final VersionedFlowSnapshotMetadata metadata = new VersionedFlowSnapshotMetadata();
         metadata.setBucketIdentifier(flow.getBucketIdentifier());
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/NiFiRegistryFlowMapper.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/NiFiRegistryFlowMapper.java
index 4780381c669..3c0e8f23f66 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/NiFiRegistryFlowMapper.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/java/org/apache/nifi/registry/flow/mapping/NiFiRegistryFlowMapper.java
@@ -34,6 +34,9 @@
 import org.apache.nifi.groups.ProcessGroup;
 import org.apache.nifi.groups.RemoteProcessGroup;
 import org.apache.nifi.nar.ExtensionManager;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterDescriptor;
 import org.apache.nifi.processor.Relationship;
 import org.apache.nifi.registry.VariableDescriptor;
 import org.apache.nifi.registry.flow.BatchSize;
@@ -53,6 +56,8 @@
 import org.apache.nifi.registry.flow.VersionedFlowCoordinates;
 import org.apache.nifi.registry.flow.VersionedFunnel;
 import org.apache.nifi.registry.flow.VersionedLabel;
+import org.apache.nifi.registry.flow.VersionedParameter;
+import org.apache.nifi.registry.flow.VersionedParameterContext;
 import org.apache.nifi.registry.flow.VersionedPort;
 import org.apache.nifi.registry.flow.VersionedProcessGroup;
 import org.apache.nifi.registry.flow.VersionedProcessor;
@@ -161,6 +166,9 @@ private InstantiatedVersionedProcessGroup mapGroup(final ProcessGroup group, fin
         versionedGroup.setComments(group.getComments());
         versionedGroup.setPosition(mapPosition(group.getPosition()));
 
+        final ParameterContext parameterContext = group.getParameterContext();
+        versionedGroup.setParameterContextName(parameterContext == null ? null : parameterContext.getName());
+
         // If we are at the 'top level', meaning that the given Process Group is the group that we are creating a VersionedProcessGroup for,
         // then we don't want to include the RemoteFlowCoordinates; we want to include the group contents. The RemoteFlowCoordinates will be used
         // only for a child group that is itself version controlled.
@@ -356,7 +364,7 @@ private Map<String, String> mapProperties(final ComponentNode component, final C
         component.getProperties().keySet().stream()
             .filter(property -> !property.isSensitive())
             .forEach(property -> {
-                String value = component.getProperty(property);
+                String value = component.getRawPropertyValue(property);
                 if (value == null) {
                     value = property.getDefaultValue();
                 }
@@ -388,7 +396,7 @@ private Map<String, VersionedPropertyDescriptor> mapPropertyDescriptors(final Co
             versionedDescriptor.setIdentifiesControllerService(referencedServiceType != null);
 
             if (referencedServiceType != null) {
-                final String value = component.getProperty(descriptor);
+                final String value = component.getProperty(descriptor).getRawValue();
                 if (value != null) {
                     final ControllerServiceNode serviceNode = serviceProvider.getControllerServiceNode(value);
                     if (serviceNode == null) {
@@ -570,4 +578,35 @@ private BatchSize mapBatchSettings(final RemoteGroupPort remotePort) {
         batchSize.setSize(remotePort.getBatchSize());
         return batchSize;
     }
+
+    public VersionedParameterContext mapParameterContext(final ParameterContext context) {
+        if (context == null) {
+            return null;
+        }
+
+        final Set<VersionedParameter> parameters = context.getParameters().values().stream()
+            .map(this::mapParameter)
+            .collect(Collectors.toSet());
+
+        final VersionedParameterContext versionedContext = new VersionedParameterContext();
+        versionedContext.setName(context.getName());
+        versionedContext.setParameters(parameters);
+
+        return versionedContext;
+    }
+
+    public VersionedParameter mapParameter(final Parameter parameter) {
+        if (parameter == null) {
+            return null;
+        }
+
+        final ParameterDescriptor descriptor = parameter.getDescriptor();
+
+        final VersionedParameter versionedParameter = new VersionedParameter();
+        versionedParameter.setDescription(descriptor.getDescription());
+        versionedParameter.setName(descriptor.getName());
+        versionedParameter.setSensitive(descriptor.isSensitive());
+        versionedParameter.setValue(descriptor.isSensitive() ? null : parameter.getValue());
+        return versionedParameter;
+    }
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/resources/FlowConfiguration.xsd b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/resources/FlowConfiguration.xsd
index 18f6dcb6428..ca43ebce19d 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/resources/FlowConfiguration.xsd
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/main/resources/FlowConfiguration.xsd
@@ -28,6 +28,8 @@
 
             <xs:element name="registries" type="RegistriesType" minOccurs="0" maxOccurs="1" />
 
+            <xs:element name="parameterContexts" type="ParameterContextsType" minOccurs="0" maxOccurs="1" />
+
             <!-- Groupings of Processors/Ports -->
             <xs:element name="rootGroup" type="RootProcessGroupType" />
 
@@ -55,6 +57,30 @@
         </xs:sequence>
     </xs:complexType>
 
+    <xs:complexType name="ParameterContextsType">
+        <xs:sequence>
+            <xs:element name="parameterContext" type="ParameterContextType" minOccurs="0" maxOccurs="unbounded" />
+        </xs:sequence>
+    </xs:complexType>
+
+    <xs:complexType name="ParameterContextType">
+        <xs:sequence>
+            <xs:element name="id" type="NonEmptyStringType" />
+            <xs:element name="name" type="NonEmptyStringType" />
+            <xs:element name="description" type="xs:string" minOccurs="0" maxOccurs="1" />
+            <xs:element name="parameter" type="ParameterType" minOccurs="0" maxOccurs="unbounded" />
+        </xs:sequence>
+    </xs:complexType>
+
+    <xs:complexType name="ParameterType">
+        <xs:sequence>
+            <xs:element name="name" type="NonEmptyStringType" />
+            <xs:element name="description" type="xs:string" />
+            <xs:element name="sensitive" type="xs:boolean" />
+            <xs:element name="value" type="xs:string" />
+        </xs:sequence>
+    </xs:complexType>
+
     <!-- the processor "id" is a key that should be valid within each flowController-->
     <xs:complexType name="ProcessorType">
         <xs:sequence>
@@ -168,6 +194,7 @@
             <xs:element name="controllerService" type="ControllerServiceType" minOccurs="0" maxOccurs="unbounded" />
             <xs:element name="template" type="TemplateType" minOccurs="0" maxOccurs="unbounded" />
             <xs:element name="variable" type="VariableType" minOccurs="0" maxOccurs="unbounded"  />
+            <xs:element name="parameterContextId" type="xs:string" minOccurs="0" maxOccurs="1" />
         </xs:sequence>
     </xs:complexType>
 
@@ -212,6 +239,8 @@
             <xs:element name="connection" type="ConnectionType" minOccurs="0" maxOccurs="unbounded" />
             <xs:element name="controllerService" type="ControllerServiceType" minOccurs="0" maxOccurs="unbounded" />
             <xs:element name="template" type="TemplateType" minOccurs="0" maxOccurs="unbounded" />
+            <xs:element name="variable" type="VariableType" minOccurs="0" maxOccurs="unbounded"  />
+            <xs:element name="parameterContextId" type="xs:string" minOccurs="0" maxOccurs="1" />
         </xs:sequence>
     </xs:complexType>
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/TestFlowController.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/TestFlowController.java
index 651ce9c5f0f..cae87ddcb7f 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/TestFlowController.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/TestFlowController.java
@@ -113,7 +113,6 @@ public class TestFlowController {
     private Bundle systemBundle;
     private BulletinRepository bulletinRepo;
     private VariableRegistry variableRegistry;
-    private volatile String propsFile = "src/test/resources/flowcontrollertest.nifi.properties";
     private ExtensionDiscoveringManager extensionManager;
 
     /**
@@ -139,6 +138,7 @@ public void setup() {
         otherProps.put(NiFiProperties.PROVENANCE_REPO_IMPLEMENTATION_CLASS, MockProvenanceRepository.class.getName());
         otherProps.put("nifi.remote.input.socket.port", "");
         otherProps.put("nifi.remote.input.secure", "");
+        final String propsFile = "src/test/resources/flowcontrollertest.nifi.properties";
         nifiProperties = NiFiProperties.createBasicNiFiProperties(propsFile, otherProps);
         encryptor = createEncryptorFromProperties(nifiProperties);
 
@@ -239,9 +239,9 @@ public void testSynchronizeFlowWithReportingTaskAndProcessorReferencingControlle
 
         // verify the processor is still pointing at the controller service that got moved to the root group
         final ProcessorNode processorNode = processorNodes.stream().findFirst().get();
-        final PropertyDescriptor procControllerServiceProp = processorNode.getProperties().entrySet().stream()
+        final PropertyDescriptor procControllerServiceProp = processorNode.getEffectivePropertyValues().entrySet().stream()
                 .filter(e -> e.getValue().equals(rootGroupCs.getIdentifier()))
-                .map(e -> e.getKey())
+                .map(Map.Entry::getKey)
                 .findFirst()
                 .get();
         assertNotNull(procControllerServiceProp);
@@ -253,9 +253,9 @@ public void testSynchronizeFlowWithReportingTaskAndProcessorReferencingControlle
 
         // verify that the reporting task is pointing at the controller service at the controller level
         final ReportingTaskNode reportingTaskNode = reportingTaskNodes.stream().findFirst().get();
-        final PropertyDescriptor reportingTaskControllerServiceProp = reportingTaskNode.getProperties().entrySet().stream()
+        final PropertyDescriptor reportingTaskControllerServiceProp = reportingTaskNode.getEffectivePropertyValues().entrySet().stream()
                 .filter(e -> e.getValue().equals(controllerCs.getIdentifier()))
-                .map(e -> e.getKey())
+                .map(Map.Entry::getKey)
                 .findFirst()
                 .get();
         assertNotNull(reportingTaskControllerServiceProp);
@@ -293,9 +293,9 @@ public void testSynchronizeFlowWithProcessorReferencingControllerService() throw
 
         // verify the processor is still pointing at the controller service that got moved to the root group
         final ProcessorNode processorNode = processorNodes.stream().findFirst().get();
-        final PropertyDescriptor procControllerServiceProp = processorNode.getProperties().entrySet().stream()
+        final PropertyDescriptor procControllerServiceProp = processorNode.getRawPropertyValues().entrySet().stream()
                 .filter(e -> e.getValue().equals(rootGroupCs.getIdentifier()))
-                .map(e -> e.getKey())
+                .map(Map.Entry::getKey)
                 .findFirst()
                 .get();
         assertNotNull(procControllerServiceProp);
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/TestStandardProcessorNode.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/TestStandardProcessorNode.java
index b0711f8f652..08dc4f3f0c6 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/TestStandardProcessorNode.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/TestStandardProcessorNode.java
@@ -36,6 +36,7 @@
 import org.apache.nifi.nar.NarCloseable;
 import org.apache.nifi.nar.StandardExtensionDiscoveringManager;
 import org.apache.nifi.nar.SystemBundle;
+import org.apache.nifi.parameter.ParameterContext;
 import org.apache.nifi.processor.AbstractProcessor;
 import org.apache.nifi.processor.ProcessContext;
 import org.apache.nifi.processor.ProcessSession;
@@ -63,6 +64,7 @@
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.Arrays;
+import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
@@ -130,7 +132,7 @@ public void trigger() {
         };
 
         procNode.performValidation();
-        procNode.start(taskScheduler, 20000L, 10000L, processContext, schedulingAgentCallback, true);
+        procNode.start(taskScheduler, 20000L, 10000L, () -> processContext, schedulingAgentCallback, true);
 
         Thread.sleep(1000L);
         assertEquals(1, processor.onScheduledCount);
@@ -177,6 +179,7 @@ public void testSinglePropertyDynamicallyModifiesClasspath() throws MalformedURL
         }
     }
 
+
     @Test
     public void testUpdateOtherPropertyDoesNotImpactClasspath() throws MalformedURLException {
         final MockReloadComponent reloadComponent = new MockReloadComponent();
@@ -467,7 +470,8 @@ private URL[] getTestResources() throws MalformedURLException {
     private ValidationContextFactory createValidationContextFactory() {
         return new ValidationContextFactory() {
             @Override
-            public ValidationContext newValidationContext(Map<PropertyDescriptor, String> properties, String annotationData, String groupId, String componentId) {
+            public ValidationContext newValidationContext(Map<PropertyDescriptor, PropertyConfiguration> properties, String annotationData, String groupId, String componentId,
+                                                          ParameterContext context) {
                 return new ValidationContext() {
 
                     @Override
@@ -487,7 +491,8 @@ public ExpressionLanguageCompiler newExpressionLanguageCompiler() {
 
                     @Override
                     public PropertyValue getProperty(PropertyDescriptor property) {
-                        return newPropertyValue(properties.get(property));
+                        final PropertyConfiguration configuration = properties.get(property);
+                        return newPropertyValue(configuration == null ? null : configuration.getRawValue());
                     }
 
                     @Override
@@ -497,7 +502,9 @@ public PropertyValue newPropertyValue(String value) {
 
                     @Override
                     public Map<PropertyDescriptor, String> getProperties() {
-                        return Collections.unmodifiableMap(properties);
+                        final Map<PropertyDescriptor, String> propertyMap = new HashMap<>();
+                        properties.forEach((k, v) -> propertyMap.put(k, v == null ? null : v.getRawValue()));
+                        return propertyMap;
                     }
 
                     @Override
@@ -533,14 +540,19 @@ public boolean isExpressionLanguageSupported(String propertyName) {
                     public String getProcessGroupIdentifier() {
                         return groupId;
                     }
+
+                    @Override
+                    public Collection<String> getReferencedParameters(final String propertyName) {
+                        return Collections.emptyList();
+                    }
+
+                    @Override
+                    public boolean isParameterDefined(final String parameterName) {
+                        return false;
+                    }
                 };
             }
 
-            @Override
-            public ValidationContext newValidationContext(Set<String> serviceIdentifiersToNotValidate, Map<PropertyDescriptor, String> properties, String annotationData, String groupId,
-                String componentId) {
-                return newValidationContext(properties, annotationData, groupId, componentId);
-            }
         };
 
     }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/queue/clustered/LoadBalancedQueueIT.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/queue/clustered/LoadBalancedQueueIT.java
index 638b2f47ee2..cace897de67 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/queue/clustered/LoadBalancedQueueIT.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/queue/clustered/LoadBalancedQueueIT.java
@@ -1340,7 +1340,7 @@ public InputStream answer(final InvocationOnMock invocation) {
 
                 return new ByteArrayInputStream(bytes);
             }
-        }).when(contentRepo).read(any(ContentClaim.class));
+        }).when(contentRepo).read(Mockito.nullable(ContentClaim.class));
 
         return contentRepo;
     }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/service/mock/MockProcessGroup.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/service/mock/MockProcessGroup.java
index 4a726b9f176..e2e4561ba10 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/service/mock/MockProcessGroup.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/service/mock/MockProcessGroup.java
@@ -35,6 +35,7 @@
 import org.apache.nifi.groups.ProcessGroup;
 import org.apache.nifi.groups.ProcessGroupCounts;
 import org.apache.nifi.groups.RemoteProcessGroup;
+import org.apache.nifi.parameter.ParameterContext;
 import org.apache.nifi.registry.VariableRegistry;
 import org.apache.nifi.registry.flow.FlowRegistryClient;
 import org.apache.nifi.registry.flow.VersionControlInformation;
@@ -51,6 +52,7 @@
 import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.CompletableFuture;
+import java.util.function.Predicate;
 
 public class MockProcessGroup implements ProcessGroup {
     private final Map<String, ControllerServiceNode> serviceMap = new HashMap<>();
@@ -58,6 +60,7 @@ public class MockProcessGroup implements ProcessGroup {
     private final FlowController flowController;
     private final MutableVariableRegistry variableRegistry = new MutableVariableRegistry(VariableRegistry.ENVIRONMENT_SYSTEM_REGISTRY);
     private VersionControlInformation versionControlInfo;
+    private ParameterContext parameterContext;
 
     public MockProcessGroup(final FlowController flowController) {
         this.flowController = flowController;
@@ -410,6 +413,11 @@ public List<ProcessGroup> findAllProcessGroups() {
         return null;
     }
 
+    @Override
+    public List<ProcessGroup> findAllProcessGroups(final Predicate<ProcessGroup> filter) {
+        return Collections.emptyList();
+    }
+
     @Override
     public RemoteProcessGroup findRemoteProcessGroup(final String id) {
         return null;
@@ -682,6 +690,24 @@ public void verifyCanShowLocalModifications() {
     public void onComponentModified() {
     }
 
+    @Override
+    public void setParameterContext(final ParameterContext parameterContext) {
+        this.parameterContext = parameterContext;
+    }
+
+    @Override
+    public ParameterContext getParameterContext() {
+        return parameterContext;
+    }
+
+    @Override
+    public void verifyCanSetParameterContext(ParameterContext context) {
+    }
+
+    @Override
+    public void onParameterContextUpdated() {
+    }
+
     @Override
     public void terminateProcessor(ProcessorNode processor) {
     }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/state/providers/local/TestWriteAheadLocalStateProvider.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/state/providers/local/TestWriteAheadLocalStateProvider.java
index 41b7d9d69de..3bfdb71c345 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/state/providers/local/TestWriteAheadLocalStateProvider.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/state/providers/local/TestWriteAheadLocalStateProvider.java
@@ -17,15 +17,7 @@
 
 package org.apache.nifi.controller.state.providers.local;
 
-import java.io.IOException;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.Map;
-import java.util.UUID;
-
-import javax.net.ssl.SSLContext;
-
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.components.PropertyDescriptor;
 import org.apache.nifi.components.PropertyValue;
@@ -38,6 +30,14 @@
 import org.junit.Before;
 import org.wali.WriteAheadRepository;
 
+import javax.net.ssl.SSLContext;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.Map;
+import java.util.UUID;
+
 public class TestWriteAheadLocalStateProvider extends AbstractTestStateProvider {
     private StateProvider provider;
     private WriteAheadRepository<StateMapUpdate> wal;
@@ -46,10 +46,10 @@ public class TestWriteAheadLocalStateProvider extends AbstractTestStateProvider
     public void setup() throws IOException {
         provider = new WriteAheadLocalStateProvider();
         final Map<PropertyDescriptor, PropertyValue> properties = new HashMap<>();
-        properties.put(WriteAheadLocalStateProvider.PATH, new StandardPropertyValue("target/local-state-provider/" + UUID.randomUUID().toString(), null));
-        properties.put(WriteAheadLocalStateProvider.ALWAYS_SYNC, new StandardPropertyValue("false", null));
-        properties.put(WriteAheadLocalStateProvider.CHECKPOINT_INTERVAL, new StandardPropertyValue("2 mins", null));
-        properties.put(WriteAheadLocalStateProvider.NUM_PARTITIONS, new StandardPropertyValue("16", null));
+        properties.put(WriteAheadLocalStateProvider.PATH, new StandardPropertyValue("target/local-state-provider/" + UUID.randomUUID().toString(), null, ParameterLookup.EMPTY));
+        properties.put(WriteAheadLocalStateProvider.ALWAYS_SYNC, new StandardPropertyValue("false", null, ParameterLookup.EMPTY));
+        properties.put(WriteAheadLocalStateProvider.CHECKPOINT_INTERVAL, new StandardPropertyValue("2 mins", null, ParameterLookup.EMPTY));
+        properties.put(WriteAheadLocalStateProvider.NUM_PARTITIONS, new StandardPropertyValue("16", null, ParameterLookup.EMPTY));
 
         provider.initialize(new StateProviderInitializationContext() {
             @Override
@@ -75,7 +75,7 @@ public Map<String,String> getAllProperties() {
             public PropertyValue getProperty(final PropertyDescriptor property) {
                 final PropertyValue prop = properties.get(property);
                 if (prop == null) {
-                    return new StandardPropertyValue(null, null);
+                    return new StandardPropertyValue(null, null, ParameterLookup.EMPTY);
                 }
                 return prop;
             }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/state/providers/zookeeper/TestZooKeeperStateProvider.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/state/providers/zookeeper/TestZooKeeperStateProvider.java
index 037b35026da..091b13c88a1 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/state/providers/zookeeper/TestZooKeeperStateProvider.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/controller/state/providers/zookeeper/TestZooKeeperStateProvider.java
@@ -16,14 +16,8 @@
  */
 package org.apache.nifi.controller.state.providers.zookeeper;
 
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.Map;
-
-import javax.net.ssl.SSLContext;
-
 import org.apache.curator.test.TestingServer;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.components.PropertyDescriptor;
 import org.apache.nifi.components.PropertyValue;
@@ -37,6 +31,12 @@
 import org.junit.Test;
 import org.testng.Assert;
 
+import javax.net.ssl.SSLContext;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.Map;
+
 public class TestZooKeeperStateProvider extends AbstractTestStateProvider {
 
     private volatile StateProvider provider;
@@ -71,7 +71,7 @@ public String getIdentifier() {
             public Map<PropertyDescriptor, PropertyValue> getProperties() {
                 final Map<PropertyDescriptor, PropertyValue> propValueMap = new HashMap<>();
                 for (final Map.Entry<PropertyDescriptor, String> entry : properties.entrySet()) {
-                    propValueMap.put(entry.getKey(), new StandardPropertyValue(entry.getValue(), null));
+                    propValueMap.put(entry.getKey(), new StandardPropertyValue(entry.getValue(), null, ParameterLookup.EMPTY));
                 }
                 return propValueMap;
             }
@@ -88,7 +88,7 @@ public Map<String,String> getAllProperties() {
             @Override
             public PropertyValue getProperty(final PropertyDescriptor property) {
                 final String prop = properties.get(property);
-                return new StandardPropertyValue(prop, null);
+                return new StandardPropertyValue(prop, null, ParameterLookup.EMPTY);
             }
 
             @Override
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/cs/ControllerServiceReferencingProcessor.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/cs/ControllerServiceReferencingProcessor.java
index 82438e8f016..3b6df47d1f7 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/cs/ControllerServiceReferencingProcessor.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/cs/ControllerServiceReferencingProcessor.java
@@ -24,17 +24,30 @@
 import org.apache.nifi.processor.Relationship;
 import org.apache.nifi.processor.exception.ProcessException;
 
+import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
 public class ControllerServiceReferencingProcessor extends AbstractProcessor {
-    private final PropertyDescriptor SERVICE = new PropertyDescriptor.Builder()
+    protected static final PropertyDescriptor SERVICE = new PropertyDescriptor.Builder()
         .name("Counter Service")
         .identifiesControllerService(Counter.class)
         .required(true)
         .build();
 
+    protected static final PropertyDescriptor OPTIONAL_SERVICE = new PropertyDescriptor.Builder()
+        .name("Optional Service")
+        .identifiesControllerService(Counter.class)
+        .required(false)
+        .build();
+
+    protected static final PropertyDescriptor IGNORED_OPTIONAL_SERVICE = new PropertyDescriptor.Builder()
+        .name("Ignored Optional Service")
+        .identifiesControllerService(Counter.class)
+        .required(false)
+        .build();
+
     @Override
     public Set<Relationship> getRelationships() {
         return Collections.singleton(FrameworkIntegrationTest.REL_SUCCESS);
@@ -42,11 +55,16 @@ public Set<Relationship> getRelationships() {
 
     @Override
     protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {
-        return Collections.singletonList(SERVICE);
+        return Arrays.asList(SERVICE, OPTIONAL_SERVICE, IGNORED_OPTIONAL_SERVICE);
     }
 
     @Override
     public void onTrigger(final ProcessContext context, final ProcessSession session) throws ProcessException {
         context.getProperty(SERVICE).asControllerService(Counter.class).increment(1L);
+
+        final Counter optionalCounter = context.getProperty(OPTIONAL_SERVICE).asControllerService(Counter.class);
+        if (optionalCounter != null) {
+            optionalCounter.increment(1L);
+        }
     }
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/parameters/ParametersIT.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/parameters/ParametersIT.java
new file mode 100644
index 00000000000..7d0755da328
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/parameters/ParametersIT.java
@@ -0,0 +1,369 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.integration.parameters;
+
+import org.apache.nifi.connectable.Connection;
+import org.apache.nifi.controller.ProcessorNode;
+import org.apache.nifi.controller.queue.FlowFileQueue;
+import org.apache.nifi.controller.repository.FlowFileRecord;
+import org.apache.nifi.integration.FrameworkIntegrationTest;
+import org.apache.nifi.integration.processors.GenerateProcessor;
+import org.apache.nifi.integration.processors.UpdateAttributeCreateOwnProperty;
+import org.apache.nifi.integration.processors.UpdateAttributeNoEL;
+import org.apache.nifi.integration.processors.UpdateAttributeWithEL;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterDescriptor;
+import org.apache.nifi.parameter.ParameterReference;
+import org.apache.nifi.parameter.ParameterReferenceManager;
+import org.apache.nifi.parameter.StandardParameterContext;
+import org.apache.nifi.parameter.StandardParameterReferenceManager;
+import org.apache.nifi.processor.Processor;
+import org.junit.Test;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ExecutionException;
+
+import static org.junit.Assert.assertEquals;
+
+public class ParametersIT extends FrameworkIntegrationTest {
+
+    @Test
+    public void testSimpleParameterSubstitution() throws ExecutionException, InterruptedException {
+        final ProcessorNode generate = createProcessorNode(GenerateProcessor.class);
+        final ProcessorNode updateAttribute = createProcessorNode(UpdateAttributeNoEL.class);
+        final ProcessorNode terminate = getTerminateProcessor();
+
+        final Connection generatedFlowFileConnection = connect(generate, updateAttribute, REL_SUCCESS);
+        final Connection updatedAttributeConnection = connect(updateAttribute, terminate, REL_SUCCESS);
+
+        final ParameterReferenceManager referenceManager = new StandardParameterReferenceManager(getFlowController().getFlowManager());
+        final ParameterContext parameterContext = new StandardParameterContext(UUID.randomUUID().toString(), "param-context", referenceManager, null);
+        parameterContext.setParameters(Collections.singleton(new Parameter(new ParameterDescriptor.Builder().name("test").build(), "unit")));
+
+        getRootGroup().setParameterContext(parameterContext);
+        updateAttribute.setProperties(Collections.singletonMap("test", "#{test}"));
+
+        triggerOnce(generate);
+        triggerOnce(updateAttribute);
+
+        final FlowFileQueue flowFileQueue = updatedAttributeConnection.getFlowFileQueue();
+        final FlowFileRecord flowFileRecord = flowFileQueue.poll(Collections.emptySet());
+
+        assertEquals("unit", flowFileRecord.getAttribute("test"));
+    }
+
+    @Test
+    public void testParameterSubstitutionWithinELWhenELNotSupported() throws ExecutionException, InterruptedException {
+        final ProcessorNode generate = createProcessorNode(GenerateProcessor.class);
+        final ProcessorNode updateAttribute = createProcessorNode(UpdateAttributeNoEL.class);
+        final ProcessorNode terminate = getTerminateProcessor();
+
+        final Connection generatedFlowFileConnection = connect(generate, updateAttribute, REL_SUCCESS);
+        final Connection updatedAttributeConnection = connect(updateAttribute, terminate, REL_SUCCESS);
+
+        final ParameterReferenceManager referenceManager = new StandardParameterReferenceManager(getFlowController().getFlowManager());
+        final ParameterContext parameterContext = new StandardParameterContext(UUID.randomUUID().toString(), "param-context", referenceManager, null);
+        parameterContext.setParameters(Collections.singleton(new Parameter(new ParameterDescriptor.Builder().name("test").build(), "unit")));
+
+        getRootGroup().setParameterContext(parameterContext);
+        updateAttribute.setProperties(Collections.singletonMap("test", "${#{test}:toUpper()}"));
+
+        triggerOnce(generate);
+        triggerOnce(updateAttribute);
+
+        final FlowFileQueue flowFileQueue = updatedAttributeConnection.getFlowFileQueue();
+        final FlowFileRecord flowFileRecord = flowFileQueue.poll(Collections.emptySet());
+
+        assertEquals("${unit:toUpper()}", flowFileRecord.getAttribute("test"));
+    }
+
+    @Test
+    public void testParameterSubstitutionWithinELWhenELIsSupported() throws ExecutionException, InterruptedException {
+        final ProcessorNode generate = createProcessorNode(GenerateProcessor.class);
+        final ProcessorNode updateAttribute = createProcessorNode(UpdateAttributeWithEL.class);
+        final ProcessorNode terminate = getTerminateProcessor();
+
+        final Connection generatedFlowFileConnection = connect(generate, updateAttribute, REL_SUCCESS);
+        final Connection updatedAttributeConnection = connect(updateAttribute, terminate, REL_SUCCESS);
+
+        final ParameterReferenceManager referenceManager = new StandardParameterReferenceManager(getFlowController().getFlowManager());
+        final ParameterContext parameterContext = new StandardParameterContext(UUID.randomUUID().toString(), "param-context", referenceManager, null);
+        parameterContext.setParameters(Collections.singleton(new Parameter(new ParameterDescriptor.Builder().name("test").build(), "unit")));
+
+        getRootGroup().setParameterContext(parameterContext);
+        updateAttribute.setProperties(Collections.singletonMap("test", "${#{test}:toUpper()}"));
+
+        triggerOnce(generate);
+        triggerOnce(updateAttribute);
+
+        final FlowFileQueue flowFileQueue = updatedAttributeConnection.getFlowFileQueue();
+        final FlowFileRecord flowFileRecord = flowFileQueue.poll(Collections.emptySet());
+
+        assertEquals("UNIT", flowFileRecord.getAttribute("test"));
+    }
+
+    @Test
+    public void testMixAndMatchELAndParameters() throws ExecutionException, InterruptedException {
+        final ProcessorNode generate = createProcessorNode(GenerateProcessor.class);
+        final ProcessorNode updateAttribute = createProcessorNode(UpdateAttributeWithEL.class);
+        final ProcessorNode terminate = getTerminateProcessor();
+
+        final Connection generatedFlowFileConnection = connect(generate, updateAttribute, REL_SUCCESS);
+        final Connection updatedAttributeConnection = connect(updateAttribute, terminate, REL_SUCCESS);
+
+        final ParameterReferenceManager referenceManager = new StandardParameterReferenceManager(getFlowController().getFlowManager());
+        final ParameterContext parameterContext = new StandardParameterContext(UUID.randomUUID().toString(), "param-context", referenceManager, null);
+        parameterContext.setParameters(Collections.singleton(new Parameter(new ParameterDescriptor.Builder().name("test").build(), "unit")));
+
+        getRootGroup().setParameterContext(parameterContext);
+
+        final Map<String, String> properties = new HashMap<>();
+        properties.put("mixed", "test ${#{test}} #{test} ${#{test}:toUpper()} ${#{test}:equalsIgnoreCase('uNiT')} again ${#{test}}");
+        properties.put("ends with text", "test ${#{test}} #{test} ${#{test}:toUpper()} ${#{test}:equalsIgnoreCase('uNiT')} again");
+        properties.put("el and param", "#{test} - ${#{test}}");
+        updateAttribute.setProperties(properties);
+
+        triggerOnce(generate);
+        triggerOnce(updateAttribute);
+
+        final FlowFileQueue flowFileQueue = updatedAttributeConnection.getFlowFileQueue();
+        final FlowFileRecord flowFileRecord = flowFileQueue.poll(Collections.emptySet());
+
+        assertEquals("test unit unit UNIT true again unit", flowFileRecord.getAttribute("mixed"));
+        assertEquals("test unit unit UNIT true again", flowFileRecord.getAttribute("ends with text"));
+        assertEquals("unit - unit", flowFileRecord.getAttribute("el and param"));
+    }
+
+    @Test
+    public void testParametersInELFromNewPropertyValueAndText() throws ExecutionException, InterruptedException {
+        final ProcessorNode generate = createProcessorNode(GenerateProcessor.class);
+        final ProcessorNode updateAttribute = createProcessorNode(UpdateAttributeCreateOwnProperty.class);
+        final ProcessorNode terminate = getTerminateProcessor();
+
+        final Connection generatedFlowFileConnection = connect(generate, updateAttribute, REL_SUCCESS);
+        final Connection updatedAttributeConnection = connect(updateAttribute, terminate, REL_SUCCESS);
+
+        final ParameterReferenceManager referenceManager = new StandardParameterReferenceManager(getFlowController().getFlowManager());
+        final ParameterContext parameterContext = new StandardParameterContext(UUID.randomUUID().toString(), "param-context", referenceManager, null);
+        parameterContext.setParameters(Collections.singleton(new Parameter(new ParameterDescriptor.Builder().name("test").build(), "unit")));
+
+        getRootGroup().setParameterContext(parameterContext);
+
+        final Map<String, String> properties = new HashMap<>();
+        properties.put("bar", "${#{test}:toUpper()}");
+        updateAttribute.setProperties(properties);
+
+        triggerOnce(generate);
+        triggerOnce(updateAttribute);
+
+        final FlowFileQueue flowFileQueue = updatedAttributeConnection.getFlowFileQueue();
+        final FlowFileRecord flowFileRecord = flowFileQueue.poll(Collections.emptySet());
+
+        assertEquals("UNIT", flowFileRecord.getAttribute("bar"));
+    }
+
+    @Test
+    public void testParametersWhereELSupportedButNotPresent() throws ExecutionException, InterruptedException {
+        final ProcessorNode generate = createProcessorNode(GenerateProcessor.class);
+        final ProcessorNode updateAttribute = createProcessorNode(UpdateAttributeWithEL.class);
+        final ProcessorNode terminate = getTerminateProcessor();
+
+        final Connection generatedFlowFileConnection = connect(generate, updateAttribute, REL_SUCCESS);
+        final Connection updatedAttributeConnection = connect(updateAttribute, terminate, REL_SUCCESS);
+
+        final ParameterReferenceManager referenceManager = new StandardParameterReferenceManager(getFlowController().getFlowManager());
+        final ParameterContext parameterContext = new StandardParameterContext(UUID.randomUUID().toString(), "param-context", referenceManager, null);
+        parameterContext.setParameters(Collections.singleton(new Parameter(new ParameterDescriptor.Builder().name("test").build(), "unit")));
+
+        getRootGroup().setParameterContext(parameterContext);
+
+        final Map<String, String> properties = new HashMap<>();
+        properties.put("foo", "#{test}");
+        properties.put("bar", "#{test}#{test}");
+        properties.put("baz", "foo#{test}bar");
+        updateAttribute.setProperties(properties);
+
+        triggerOnce(generate);
+        triggerOnce(updateAttribute);
+
+        final FlowFileQueue flowFileQueue = updatedAttributeConnection.getFlowFileQueue();
+        final FlowFileRecord flowFileRecord = flowFileQueue.poll(Collections.emptySet());
+
+        assertEquals("unit", flowFileRecord.getAttribute("foo"));
+        assertEquals("unitunit", flowFileRecord.getAttribute("bar"));
+        assertEquals("foounitbar", flowFileRecord.getAttribute("baz"));
+    }
+
+    @Test
+    public void testCornerCases() throws ExecutionException, InterruptedException {
+        final ProcessorNode generate = createProcessorNode(GenerateProcessor.class);
+        final ProcessorNode updateAttribute = createProcessorNode(UpdateAttributeWithEL.class);
+        final ProcessorNode terminate = getTerminateProcessor();
+
+        final Connection generatedFlowFileConnection = connect(generate, updateAttribute, REL_SUCCESS);
+        final Connection updatedAttributeConnection = connect(updateAttribute, terminate, REL_SUCCESS);
+
+        final ParameterReferenceManager referenceManager = new StandardParameterReferenceManager(getFlowController().getFlowManager());
+        final ParameterContext parameterContext = new StandardParameterContext(UUID.randomUUID().toString(), "param-context", referenceManager, null);
+        parameterContext.setParameters(Collections.singleton(new Parameter(new ParameterDescriptor.Builder().name("test").build(), "unit")));
+
+        getRootGroup().setParameterContext(parameterContext);
+
+        final Map<String, String> variables = new HashMap<>();
+        variables.put("#{test}", "variable #{test}");
+        variables.put("${var}", "variable ${var}");
+        variables.put("var", "abc");
+        variables.put("abc", "123");
+        getRootGroup().setVariables(variables);
+
+        final Map<String, String> properties = new HashMap<>();
+        properties.put("foo", "${#{test}}");  // References a Parameter named 'test'
+        properties.put("bar", "${'#{test}'}");  // Parameter reference is quoted, which means that it's treated as a String, not a reference. This references a variable/attribute named '#{test}'
+        properties.put("baz", "${ # this is a comment\n#{test}}"); // Test Parameter reference following a comment in EL
+        properties.put("multi", "${ #### this is a comment\n#{test}}");  // Test several #'s for a comment, followed by a parameter reference
+        properties.put("embedded", "${'$${var}'}");  // Here, we reference a variable/attribute named '${var}' - since EL Expressions can be embedded even within quotes, we must escape with extra $.
+        properties.put("indirect", "${'${var}'}"); // Reference a variable/attribute whose name is defined by variable/attribute 'var' - i.e., reference variable 'var', whose value is 'abc', then
+                                                   // use that to reference variable "abc" to get a value of 123
+        updateAttribute.setProperties(properties);
+
+        triggerOnce(generate);
+        triggerOnce(updateAttribute);
+
+        final FlowFileQueue flowFileQueue = updatedAttributeConnection.getFlowFileQueue();
+        final FlowFileRecord flowFileRecord = flowFileQueue.poll(Collections.emptySet());
+
+        assertEquals("unit", flowFileRecord.getAttribute("foo"));
+        assertEquals("variable #{test}", flowFileRecord.getAttribute("bar"));
+        assertEquals("unit", flowFileRecord.getAttribute("baz"));
+        assertEquals("unit", flowFileRecord.getAttribute("multi"));
+        assertEquals("variable ${var}", flowFileRecord.getAttribute("embedded"));
+        assertEquals("123", flowFileRecord.getAttribute("indirect"));
+    }
+
+    @Test
+    public void testReferencesStoredProperly() {
+        final ProcessorNode updateAttributeWithEL = createProcessorNode(UpdateAttributeWithEL.class);
+        final ProcessorNode updateAttributeNoEL = createProcessorNode(UpdateAttributeNoEL.class);
+
+        final ParameterReferenceManager referenceManager = new StandardParameterReferenceManager(getFlowController().getFlowManager());
+        final ParameterContext parameterContext = new StandardParameterContext(UUID.randomUUID().toString(), "param-context", referenceManager, null);
+        parameterContext.setParameters(Collections.singleton(new Parameter(new ParameterDescriptor.Builder().name("test").build(), "unit")));
+
+        getRootGroup().setParameterContext(parameterContext);
+
+        final Map<String, String> properties = new HashMap<>();
+        properties.put("foo", "#{test}");
+        properties.put("bar", "${#{test}:toUpper()}");
+
+        updateAttributeWithEL.setProperties(properties);
+        updateAttributeNoEL.setProperties(properties);
+
+        List<ParameterReference> references = updateAttributeWithEL.getProperty(updateAttributeWithEL.getPropertyDescriptor("foo")).getParameterReferences();
+        assertEquals(1, references.size());
+
+        references = updateAttributeWithEL.getProperty(updateAttributeWithEL.getPropertyDescriptor("bar")).getParameterReferences();
+        assertEquals(1, references.size());
+
+        references = updateAttributeNoEL.getProperty(updateAttributeNoEL.getPropertyDescriptor("foo")).getParameterReferences();
+        assertEquals(1, references.size());
+
+        references = updateAttributeNoEL.getProperty(updateAttributeNoEL.getPropertyDescriptor("bar")).getParameterReferences();
+        assertEquals(1, references.size());
+    }
+
+    @Test
+    public void testEscaping() throws ExecutionException, InterruptedException {
+        testEscaping(UpdateAttributeNoEL.class);
+        testEscaping(UpdateAttributeWithEL.class);
+        testEscaping(UpdateAttributeCreateOwnProperty.class);
+    }
+
+    private void testEscaping(final Class<? extends Processor> updateAttributeClass) throws ExecutionException, InterruptedException {
+        final ProcessorNode generate = createProcessorNode(GenerateProcessor.class);
+        final ProcessorNode updateAttribute = createProcessorNode(updateAttributeClass);
+
+        connect(generate, updateAttribute, REL_SUCCESS);
+        final Connection terminateConnection = connect(updateAttribute, getTerminateProcessor(), REL_SUCCESS);
+
+        final ParameterReferenceManager referenceManager = new StandardParameterReferenceManager(getFlowController().getFlowManager());
+        final ParameterContext parameterContext = new StandardParameterContext(UUID.randomUUID().toString(), "param-context", referenceManager, null);
+        parameterContext.setParameters(Collections.singleton(new Parameter(new ParameterDescriptor.Builder().name("test").build(), "unit")));
+
+        getRootGroup().setParameterContext(parameterContext);
+
+        final Map<String, String> properties = new HashMap<>();
+        properties.put("1pound", "#{test}");
+        properties.put("2pound", "##{test}");
+        properties.put("3pound", "###{test}");
+        properties.put("4pound", "####{test}");
+        properties.put("5pound", "#####{test}");
+
+        updateAttribute.setProperties(properties);
+
+        triggerOnce(generate);
+        triggerOnce(updateAttribute);
+
+        final FlowFileRecord flowFile = terminateConnection.getFlowFileQueue().poll(Collections.emptySet());
+        assertEquals("unit", flowFile.getAttribute("1pound"));
+        assertEquals("#{test}", flowFile.getAttribute("2pound"));
+        assertEquals("#unit", flowFile.getAttribute("3pound"));
+        assertEquals("##{test}", flowFile.getAttribute("4pound"));
+        assertEquals("##unit", flowFile.getAttribute("5pound"));
+    }
+
+    @Test
+    public void testParameterReferenceCounts() {
+        final ProcessorNode updateAttribute = createProcessorNode(UpdateAttributeWithEL.class);
+
+        final ParameterReferenceManager referenceManager = new StandardParameterReferenceManager(getFlowController().getFlowManager());
+        final ParameterContext parameterContext = new StandardParameterContext(UUID.randomUUID().toString(), "param-context", referenceManager, null);
+        parameterContext.setParameters(Collections.singleton(new Parameter(new ParameterDescriptor.Builder().name("test").build(), "unit")));
+
+        getRootGroup().setParameterContext(parameterContext);
+
+        final Map<String, String> properties = new HashMap<>();
+        properties.put("test", "#{test} #{test}");
+        updateAttribute.setProperties(properties);
+
+        final Set<String> allParamNames = Collections.singleton("test");
+
+        Set<String> referencedParameters = updateAttribute.getReferencedParameterNames();
+        assertEquals(allParamNames, referencedParameters);
+
+        properties.put("test", "#{test} #{test} #{test}");
+        updateAttribute.setProperties(properties);
+        referencedParameters = updateAttribute.getReferencedParameterNames();
+        assertEquals(allParamNames, referencedParameters);
+
+        properties.put("test", null);
+        updateAttribute.setProperties(properties);
+        referencedParameters = updateAttribute.getReferencedParameterNames();
+        assertEquals(Collections.emptySet(), referencedParameters);
+
+        properties.put("test", "#{test}");
+        updateAttribute.setProperties(properties);
+        referencedParameters = updateAttribute.getReferencedParameterNames();
+        assertEquals(allParamNames, referencedParameters);
+
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/processor/ProcessorParameterTokenIT.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/processor/ProcessorParameterTokenIT.java
new file mode 100644
index 00000000000..3843d2aea78
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/processor/ProcessorParameterTokenIT.java
@@ -0,0 +1,211 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.integration.processor;
+
+import org.apache.nifi.components.PropertyDescriptor;
+import org.apache.nifi.components.PropertyDescriptor.Builder;
+import org.apache.nifi.controller.ProcessorNode;
+import org.apache.nifi.flowfile.FlowFile;
+import org.apache.nifi.integration.DirectInjectionExtensionManager;
+import org.apache.nifi.integration.FrameworkIntegrationTest;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterDescriptor;
+import org.apache.nifi.parameter.ParameterReferenceManager;
+import org.apache.nifi.parameter.StandardParameterContext;
+import org.apache.nifi.processor.AbstractProcessor;
+import org.apache.nifi.processor.ProcessContext;
+import org.apache.nifi.processor.ProcessSession;
+import org.apache.nifi.processor.Processor;
+import org.apache.nifi.processor.Relationship;
+import org.apache.nifi.processor.exception.ProcessException;
+import org.junit.Assert;
+import org.junit.Test;
+
+import java.nio.charset.StandardCharsets;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ExecutionException;
+
+import static org.apache.nifi.processor.util.StandardValidators.NON_EMPTY_VALIDATOR;
+import static org.junit.Assert.assertEquals;
+
+public class ProcessorParameterTokenIT extends FrameworkIntegrationTest {
+
+    @Override
+    protected void injectExtensionTypes(final DirectInjectionExtensionManager extensionManager) {
+        extensionManager.injectExtensionType(Processor.class, WriteText.class);
+    }
+
+    @Test
+    public void testEscapedParameterReference() throws ExecutionException, InterruptedException {
+        final ProcessorNode procNode = createProcessorNode(WriteText.class);
+        procNode.setAutoTerminatedRelationships(Collections.singleton(REL_SUCCESS));
+
+        verifyText(procNode, "hello", "hello");
+        verifyText(procNode, "##{foo}", "#{foo}");
+        verifyText(procNode, "####{foo}", "##{foo}");
+        verifyText(procNode, "## hello ##{foo} ##{bar}", "## hello #{foo} #{bar}");
+    }
+
+
+    @Test
+    public void testProperReferences() throws ExecutionException, InterruptedException {
+        final ProcessorNode procNode = createProcessorNode(WriteText.class);
+        procNode.setAutoTerminatedRelationships(Collections.singleton(REL_SUCCESS));
+
+        final ParameterContext parameterContext = new StandardParameterContext(UUID.randomUUID().toString(), "testEscapedParameterReference", ParameterReferenceManager.EMPTY, null);
+        getRootGroup().setParameterContext(parameterContext);
+
+        final Set<Parameter> parameters = new HashSet<>();
+        parameters.add(new Parameter(new ParameterDescriptor.Builder().name("foo").build(), "bar"));
+        parameters.add(new Parameter(new ParameterDescriptor.Builder().name("sensitive").sensitive(true).build(), "*password*"));
+        parameterContext.setParameters(parameters);
+
+        verifyText(procNode, "hello", "hello");
+        verifyText(procNode, "##{foo}", "#{foo}");
+        verifyText(procNode, "#{foo}", "bar");
+        verifyText(procNode, "####{foo}", "##{foo}");
+        verifyText(procNode, "#####{foo}", "##bar");
+        verifyText(procNode, "## hello #{foo} ##{bar}", "## hello bar #{bar}");
+
+        try {
+            verifyText(procNode, "#{bar}", "ISE");
+        } catch (final IllegalStateException expected) {
+            // Expect IllegalStateException because processor is not valid because it references a non-existent parameter.
+        }
+
+        verifyText(procNode, "#{foo}", "password", "barpassword");
+        verifyText(procNode, "#{foo}", "#{sensitive}", "bar*password*");
+    }
+
+    @Test
+    public void testSensitiveParameters() throws ExecutionException, InterruptedException {
+        final ProcessorNode procNode = createProcessorNode(WriteText.class);
+        procNode.setAutoTerminatedRelationships(Collections.singleton(REL_SUCCESS));
+
+        final ParameterContext parameterContext = new StandardParameterContext(UUID.randomUUID().toString(), "testEscapedParameterReference", ParameterReferenceManager.EMPTY, null);
+        getRootGroup().setParameterContext(parameterContext);
+
+        final Set<Parameter> parameters = new HashSet<>();
+        parameters.add(new Parameter(new ParameterDescriptor.Builder().name("foo").build(), "bar"));
+        parameters.add(new Parameter(new ParameterDescriptor.Builder().name("sensitive").sensitive(true).build(), "*password*"));
+        parameterContext.setParameters(parameters);
+
+        verifyCannotSetParameter(procNode, "#{sensitive}", null);
+        verifyCannotSetParameter(procNode, "abc#{sensitive}foo", null);
+        verifyCannotSetParameter(procNode, "#{foo}", "#{foo}");
+        verifyCannotSetParameter(procNode, null, "#{sensitive}#{sensitive}");
+        verifyCannotSetParameter(procNode, null, "#{sensitive}123");
+        verifyCannotSetParameter(procNode, null, "123#{sensitive}");
+        verifyCannotSetParameter(procNode, null, "#{foo}");
+
+        verifyText(procNode, "#{foo}", "#{sensitive}", "bar*password*");
+        verifyText(procNode, "#{foo}", "##{sensitive}##{sensitive}##{sensitive}", "bar#{sensitive}#{sensitive}#{sensitive}");
+    }
+
+    private void verifyCannotSetParameter(final ProcessorNode procNode, final String text, final String password) {
+        final Map<String, String> properties = new HashMap<>();
+        properties.put(WriteText.TEXT.getName(), text);
+        properties.put(WriteText.PASSWORD.getName(), password);
+
+        try {
+            procNode.setProperties(properties);
+            Assert.fail("Expected to fail when setting properties to " + properties);
+        } catch (final IllegalArgumentException expected) {
+        }
+    }
+
+    private void verifyText(final ProcessorNode procNode, final String text, final String expectedOutput) throws ExecutionException, InterruptedException {
+        verifyText(procNode, text, null, expectedOutput);
+    }
+
+    private void verifyText(final ProcessorNode procNode, final String text, final String password, final String expectedOutput) throws ExecutionException, InterruptedException {
+        final Map<String, String> properties = new HashMap<>();
+        properties.put(WriteText.TEXT.getName(), text);
+        properties.put(WriteText.PASSWORD.getName(), password);
+
+        procNode.setProperties(properties);
+        triggerOnce(procNode);
+
+        final WriteText writeText = (WriteText) procNode.getProcessor();
+        final String textWritten = writeText.getTextLastWritten();
+
+        assertEquals("For input text <" + text+ "> and password <" + password + ">, expected output was <" + expectedOutput + "> but got <" + textWritten + ">", expectedOutput, textWritten);
+    }
+
+
+    public static class WriteText extends AbstractProcessor {
+        private volatile String textLastWritten = null;
+
+        static final PropertyDescriptor TEXT = new Builder()
+            .name("Text")
+            .displayName("Text")
+            .description("The text to write")
+            .required(true)
+            .addValidator(NON_EMPTY_VALIDATOR)
+            .build();
+
+        static final PropertyDescriptor PASSWORD = new Builder()
+            .name("password")
+            .displayName("password")
+            .description("Password")
+            .required(false)
+            .addValidator(NON_EMPTY_VALIDATOR)
+            .sensitive(true)
+            .build();
+
+        @Override
+        protected List<PropertyDescriptor> getSupportedPropertyDescriptors() {
+            return Arrays.asList(TEXT, PASSWORD);
+        }
+
+        @Override
+        public Set<Relationship> getRelationships() {
+            return Collections.singleton(REL_SUCCESS);
+        }
+
+        @Override
+        public void onTrigger(final ProcessContext context, final ProcessSession session) throws ProcessException {
+            FlowFile flowFile = session.create();
+
+            final String text = context.getProperty(TEXT).getValue();
+
+            final String fullText;
+            if (context.getProperty(PASSWORD).isSet()) {
+                fullText = text + context.getProperty(PASSWORD).getValue();
+            } else {
+                fullText = text;
+            }
+
+            flowFile = session.write(flowFile, out -> out.write(fullText.getBytes(StandardCharsets.UTF_8)));
+            session.transfer(flowFile, REL_SUCCESS);
+
+            textLastWritten = fullText;
+        }
+
+        private String getTextLastWritten() {
+            return textLastWritten;
+        }
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/processors/UpdateAttributeCreateOwnProperty.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/processors/UpdateAttributeCreateOwnProperty.java
new file mode 100644
index 00000000000..b50fc20724d
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/processors/UpdateAttributeCreateOwnProperty.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.integration.processors;
+
+import org.apache.nifi.components.PropertyDescriptor;
+import org.apache.nifi.components.PropertyValue;
+import org.apache.nifi.components.Validator;
+import org.apache.nifi.expression.ExpressionLanguageScope;
+import org.apache.nifi.flowfile.FlowFile;
+import org.apache.nifi.processor.AbstractProcessor;
+import org.apache.nifi.processor.ProcessContext;
+import org.apache.nifi.processor.ProcessSession;
+import org.apache.nifi.processor.Relationship;
+import org.apache.nifi.processor.exception.ProcessException;
+
+import java.util.Collections;
+import java.util.Set;
+
+public class UpdateAttributeCreateOwnProperty extends AbstractProcessor {
+
+    public static final Relationship REL_SUCCESS = new Relationship.Builder()
+        .name("success")
+        .build();
+
+    @Override
+    protected PropertyDescriptor getSupportedDynamicPropertyDescriptor(final String propertyDescriptorName) {
+        return new PropertyDescriptor.Builder()
+            .name(propertyDescriptorName)
+            .expressionLanguageSupported(ExpressionLanguageScope.FLOWFILE_ATTRIBUTES)
+            .addValidator(Validator.VALID)
+            .build();
+    }
+
+    @Override
+    public Set<Relationship> getRelationships() {
+        return Collections.singleton(REL_SUCCESS);
+    }
+
+    @Override
+    public void onTrigger(final ProcessContext context, final ProcessSession session) throws ProcessException {
+        FlowFile flowFile = session.get();
+        if (flowFile == null) {
+            return;
+        }
+
+        for (final String propertyName : context.getAllProperties().keySet()) {
+            final String propertyValue = context.getProperty(propertyName).getValue();
+            final PropertyValue propValue = context.newPropertyValue(propertyValue);
+            final String evaluated = propValue.evaluateAttributeExpressions(flowFile).getValue();
+            flowFile = session.putAttribute(flowFile, propertyName, evaluated);
+        }
+
+        session.transfer(flowFile, REL_SUCCESS);
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/processors/UpdateAttributeNoEL.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/processors/UpdateAttributeNoEL.java
new file mode 100644
index 00000000000..1b37197c09f
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/processors/UpdateAttributeNoEL.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.integration.processors;
+
+import org.apache.nifi.components.PropertyDescriptor;
+import org.apache.nifi.components.Validator;
+import org.apache.nifi.expression.ExpressionLanguageScope;
+import org.apache.nifi.flowfile.FlowFile;
+import org.apache.nifi.processor.AbstractProcessor;
+import org.apache.nifi.processor.ProcessContext;
+import org.apache.nifi.processor.ProcessSession;
+import org.apache.nifi.processor.Relationship;
+import org.apache.nifi.processor.exception.ProcessException;
+
+import java.util.Collections;
+import java.util.Set;
+
+public class UpdateAttributeNoEL extends AbstractProcessor {
+
+    public static final Relationship REL_SUCCESS = new Relationship.Builder()
+        .name("success")
+        .build();
+
+    @Override
+    protected PropertyDescriptor getSupportedDynamicPropertyDescriptor(final String propertyDescriptorName) {
+        return new PropertyDescriptor.Builder()
+            .expressionLanguageSupported(ExpressionLanguageScope.NONE)
+            .name(propertyDescriptorName)
+            .addValidator(Validator.VALID)
+            .build();
+    }
+
+    @Override
+    public Set<Relationship> getRelationships() {
+        return Collections.singleton(REL_SUCCESS);
+    }
+
+    @Override
+    public void onTrigger(final ProcessContext context, final ProcessSession session) throws ProcessException {
+        FlowFile flowFile = session.get();
+        if (flowFile == null) {
+            return;
+        }
+
+        for (final String propertyName : context.getAllProperties().keySet()) {
+            final String value = context.getProperty(propertyName).getValue();
+            flowFile = session.putAttribute(flowFile, propertyName, value);
+        }
+
+        session.transfer(flowFile, REL_SUCCESS);
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/processors/UpdateAttributeWithEL.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/processors/UpdateAttributeWithEL.java
new file mode 100644
index 00000000000..3cb979f7a3e
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/processors/UpdateAttributeWithEL.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.integration.processors;
+
+import org.apache.nifi.components.PropertyDescriptor;
+import org.apache.nifi.components.Validator;
+import org.apache.nifi.expression.ExpressionLanguageScope;
+import org.apache.nifi.flowfile.FlowFile;
+import org.apache.nifi.processor.AbstractProcessor;
+import org.apache.nifi.processor.ProcessContext;
+import org.apache.nifi.processor.ProcessSession;
+import org.apache.nifi.processor.Relationship;
+import org.apache.nifi.processor.exception.ProcessException;
+
+import java.util.Collections;
+import java.util.Set;
+
+public class UpdateAttributeWithEL extends AbstractProcessor {
+
+    public static final Relationship REL_SUCCESS = new Relationship.Builder()
+        .name("success")
+        .build();
+
+    @Override
+    protected PropertyDescriptor getSupportedDynamicPropertyDescriptor(final String propertyDescriptorName) {
+        return new PropertyDescriptor.Builder()
+            .name(propertyDescriptorName)
+            .expressionLanguageSupported(ExpressionLanguageScope.FLOWFILE_ATTRIBUTES)
+            .addValidator(Validator.VALID)
+            .build();
+    }
+
+    @Override
+    public Set<Relationship> getRelationships() {
+        return Collections.singleton(REL_SUCCESS);
+    }
+
+    @Override
+    public void onTrigger(final ProcessContext context, final ProcessSession session) throws ProcessException {
+        FlowFile flowFile = session.get();
+        if (flowFile == null) {
+            return;
+        }
+
+        for (final String propertyName : context.getAllProperties().keySet()) {
+            final String value = context.getProperty(propertyName).evaluateAttributeExpressions(flowFile).getValue();
+            flowFile = session.putAttribute(flowFile, propertyName, value);
+        }
+
+        session.transfer(flowFile, REL_SUCCESS);
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/versioned/ImportFlowIT.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/versioned/ImportFlowIT.java
index d1469f31e8c..52063150e7a 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/versioned/ImportFlowIT.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/integration/versioned/ImportFlowIT.java
@@ -101,7 +101,7 @@ public void testImportFlowWithProcessorAndControllerService() throws ExecutionEx
         assertEquals(ValidationStatus.VALID, procValidationStatus);
 
         // Ensure that the reference to the controller service was properly updated
-        final String referencedServiceId = procNode.getProperty(NopServiceReferencingProcessor.SERVICE);
+        final String referencedServiceId = procNode.getEffectivePropertyValue(NopServiceReferencingProcessor.SERVICE);
         assertEquals(serviceNode.getIdentifier(), referencedServiceId);
         assertNotEquals("service-id", referencedServiceId);
     }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/parameter/TestStandardParameterContext.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/parameter/TestStandardParameterContext.java
new file mode 100644
index 00000000000..1b211a2d37f
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/parameter/TestStandardParameterContext.java
@@ -0,0 +1,291 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.parameter;
+
+import org.apache.nifi.controller.ProcessorNode;
+import org.apache.nifi.controller.service.ControllerServiceNode;
+import org.apache.nifi.controller.service.ControllerServiceState;
+import org.apache.nifi.groups.ProcessGroup;
+import org.junit.Assert;
+import org.junit.Test;
+import org.mockito.Mockito;
+
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import static junit.framework.TestCase.assertTrue;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.testng.Assert.assertNull;
+
+public class TestStandardParameterContext {
+
+    @Test
+    public void testUpdatesApply() {
+        final ParameterReferenceManager referenceManager = new HashMapParameterReferenceManager();
+        final StandardParameterContext context = new StandardParameterContext("unit-test-context", "unit-test-context", referenceManager, null);
+
+        final ParameterDescriptor abcDescriptor = new ParameterDescriptor.Builder().name("abc").build();
+        final ParameterDescriptor xyzDescriptor = new ParameterDescriptor.Builder().name("xyz").build();
+        final ParameterDescriptor fooDescriptor = new ParameterDescriptor.Builder().name("foo").description("bar").sensitive(true).build();
+
+        final Set<Parameter> parameters = new HashSet<>();
+        parameters.add(new Parameter(abcDescriptor, "123"));
+        parameters.add(new Parameter(xyzDescriptor, "242526"));
+
+        context.setParameters(parameters);
+
+        final Parameter abcParam = context.getParameter("abc").get();
+        assertEquals(abcDescriptor, abcParam.getDescriptor());
+        assertNull(abcParam.getDescriptor().getDescription());
+        assertEquals("123", abcParam.getValue());
+
+        final Parameter xyzParam = context.getParameter("xyz").get();
+        assertEquals(xyzDescriptor, xyzParam.getDescriptor());
+        assertNull(xyzParam.getDescriptor().getDescription());
+        assertEquals("242526", xyzParam.getValue());
+
+        final Set<Parameter> secondParameters = new HashSet<>();
+        secondParameters.add(new Parameter(fooDescriptor, "baz"));
+        context.setParameters(secondParameters);
+
+        assertTrue(context.getParameter("abc").isPresent());
+        assertTrue(context.getParameter("xyz").isPresent());
+
+        secondParameters.add(new Parameter(abcParam.getDescriptor(), null));
+        secondParameters.add(new Parameter(xyzParam.getDescriptor(), null));
+
+        context.setParameters(secondParameters);
+
+        assertFalse(context.getParameter("abc").isPresent());
+        assertFalse(context.getParameter("xyz").isPresent());
+
+        final Parameter fooParam = context.getParameter(fooDescriptor).get();
+        assertEquals(fooDescriptor, fooParam.getDescriptor());
+        assertTrue(fooParam.getDescriptor().isSensitive());
+        assertEquals("bar", fooParam.getDescriptor().getDescription());
+        assertEquals("baz", fooParam.getValue());
+
+        assertEquals(Collections.singletonMap(fooDescriptor, fooParam), context.getParameters());
+
+        final Set<Parameter> thirdParameters = new HashSet<>();
+        thirdParameters.add(new Parameter(fooDescriptor, "other"));
+        context.setParameters(thirdParameters);
+
+        assertEquals("other", context.getParameter("foo").get().getValue());
+    }
+
+    @Test
+    public void testUpdateDescription() {
+        final ParameterReferenceManager referenceManager = new HashMapParameterReferenceManager();
+        final StandardParameterContext context = new StandardParameterContext("unit-test-context", "unit-test-context", referenceManager, null);
+
+        final ParameterDescriptor abcDescriptor = new ParameterDescriptor.Builder().name("abc").description("abc").build();
+
+        final Set<Parameter> parameters = new HashSet<>();
+        parameters.add(new Parameter(abcDescriptor, "123"));
+
+        context.setParameters(parameters);
+
+        Parameter abcParam = context.getParameter("abc").get();
+        assertEquals(abcDescriptor, abcParam.getDescriptor());
+        assertEquals("abc", abcParam.getDescriptor().getDescription());
+        assertEquals("123", abcParam.getValue());
+
+        ParameterDescriptor updatedDescriptor = new ParameterDescriptor.Builder().name("abc").description("Updated").build();
+        final Parameter newDescriptionParam = new Parameter(updatedDescriptor, "321");
+        context.setParameters(Collections.singleton(newDescriptionParam));
+
+        abcParam = context.getParameter("abc").get();
+        assertEquals(abcDescriptor, abcParam.getDescriptor());
+        assertEquals("Updated", abcParam.getDescriptor().getDescription());
+        assertEquals("321", abcParam.getValue());
+
+        updatedDescriptor = new ParameterDescriptor.Builder().name("abc").description("Updated Again").build();
+        final Parameter paramWithoutValue = new Parameter(updatedDescriptor, null);
+        context.setParameters(Collections.singleton(paramWithoutValue));
+
+        abcParam = context.getParameter("abc").get();
+        assertEquals(abcDescriptor, abcParam.getDescriptor());
+        assertEquals("Updated Again", abcParam.getDescriptor().getDescription());
+        assertEquals("321", abcParam.getValue());
+    }
+
+    @Test
+    public void testChangingSensitivity() {
+        // Ensure no changes applied
+        final ParameterReferenceManager referenceManager = new HashMapParameterReferenceManager();
+        final StandardParameterContext context = new StandardParameterContext("unit-test-context", "unit-test-context", referenceManager, null);
+
+        final ParameterDescriptor abcDescriptor = new ParameterDescriptor.Builder().name("abc").sensitive(true).build();
+        final ParameterDescriptor xyzDescriptor = new ParameterDescriptor.Builder().name("xyz").build();
+        final ParameterDescriptor fooDescriptor = new ParameterDescriptor.Builder().name("foo").description("bar").sensitive(true).build();
+
+        final Set<Parameter> parameters = new HashSet<>();
+        parameters.add(new Parameter(abcDescriptor, "123"));
+        parameters.add(new Parameter(xyzDescriptor, "242526"));
+
+        context.setParameters(parameters);
+
+        final ParameterDescriptor sensitiveXyzDescriptor = new ParameterDescriptor.Builder().name("xyz").sensitive(true).build();
+
+        final Set<Parameter> updatedParameters = new HashSet<>();
+        updatedParameters.add(new Parameter(fooDescriptor, "baz"));
+        updatedParameters.add(new Parameter(sensitiveXyzDescriptor, "242526"));
+
+        try {
+            context.setParameters(updatedParameters);
+            Assert.fail("Succeeded in changing parameter from non-sensitive to sensitive");
+        } catch (final IllegalStateException expected) {
+        }
+
+        final ParameterDescriptor insensitiveAbcDescriptor = new ParameterDescriptor.Builder().name("abc").sensitive(false).build();
+        updatedParameters.clear();
+        updatedParameters.add(new Parameter(insensitiveAbcDescriptor, "123"));
+
+        try {
+            context.setParameters(updatedParameters);
+            Assert.fail("Succeeded in changing parameter from sensitive to non-sensitive");
+        } catch (final IllegalStateException expected) {
+        }
+    }
+
+    @Test
+    public void testChangingParameterForRunningProcessor() {
+        final HashMapParameterReferenceManager referenceManager = new HashMapParameterReferenceManager();
+        final StandardParameterContext context = new StandardParameterContext("unit-test-context", "unit-test-context", referenceManager, null);
+
+        final ProcessorNode procNode = Mockito.mock(ProcessorNode.class);
+        Mockito.when(procNode.isRunning()).thenReturn(false);
+        referenceManager.addProcessorReference("abc", procNode);
+
+        final ParameterDescriptor abcDescriptor = new ParameterDescriptor.Builder().name("abc").sensitive(true).build();
+
+        final Set<Parameter> parameters = new HashSet<>();
+        parameters.add(new Parameter(abcDescriptor, "123"));
+
+        context.setParameters(parameters);
+
+        parameters.clear();
+        parameters.add(new Parameter(abcDescriptor, "321"));
+        context.setParameters(parameters);
+
+        assertEquals("321", context.getParameter("abc").get().getValue());
+
+        // Make processor 'running'
+        Mockito.when(procNode.isRunning()).thenReturn(true);
+
+        parameters.clear();
+        parameters.add(new Parameter(abcDescriptor, "123"));
+
+        try {
+            context.setParameters(parameters);
+            Assert.fail("Was able to change parameter while referencing processor was running");
+        } catch (final IllegalStateException expected) {
+        }
+
+        context.setParameters(Collections.emptySet());
+
+        parameters.clear();
+        parameters.add(new Parameter(abcDescriptor, null));
+        try {
+            context.setParameters(parameters);
+            Assert.fail("Was able to remove parameter while referencing processor was running");
+        } catch (final IllegalStateException expected) {
+        }
+
+        assertEquals("321", context.getParameter("abc").get().getValue());
+    }
+
+    @Test
+    public void testChangingParameterForEnabledControllerService() {
+        final HashMapParameterReferenceManager referenceManager = new HashMapParameterReferenceManager();
+        final StandardParameterContext context = new StandardParameterContext("unit-test-context", "unit-test-context", referenceManager, null);
+
+        final ControllerServiceNode serviceNode = Mockito.mock(ControllerServiceNode.class);
+        Mockito.when(serviceNode.getState()).thenReturn(ControllerServiceState.ENABLED);
+
+        final ParameterDescriptor abcDescriptor = new ParameterDescriptor.Builder().name("abc").sensitive(true).build();
+        final Set<Parameter> parameters = new HashSet<>();
+        parameters.add(new Parameter(abcDescriptor, "123"));
+
+        context.setParameters(parameters);
+
+        referenceManager.addControllerServiceReference("abc", serviceNode);
+
+        parameters.clear();
+        parameters.add(new Parameter(abcDescriptor, "321"));
+
+        for (final ControllerServiceState state : EnumSet.of(ControllerServiceState.ENABLED, ControllerServiceState.ENABLING, ControllerServiceState.DISABLING)) {
+            Mockito.when(serviceNode.getState()).thenReturn(state);
+
+            try {
+                context.setParameters(parameters);
+                Assert.fail("Was able to update parameter being referenced by Controller Service that is " + state);
+            } catch (final IllegalStateException expected) {
+            }
+
+            assertEquals("123", context.getParameter("abc").get().getValue());
+        }
+
+        parameters.clear();
+        context.setParameters(parameters);
+
+        parameters.add(new Parameter(abcDescriptor, null));
+        try {
+            context.setParameters(parameters);
+            Assert.fail("Was able to remove parameter being referenced by Controller Service that is DISABLING");
+        } catch (final IllegalStateException expected) {
+        }
+    }
+
+
+
+    private static class HashMapParameterReferenceManager implements ParameterReferenceManager {
+        private final Map<String, ProcessorNode> processors = new HashMap<>();
+        private final Map<String, ControllerServiceNode> controllerServices = new HashMap<>();
+
+        @Override
+        public Set<ProcessorNode> getProcessorsReferencing(final ParameterContext parameterContext, final String parameterName) {
+            final ProcessorNode node = processors.get(parameterName);
+            return node == null ? Collections.emptySet() : Collections.singleton(node);
+        }
+
+        @Override
+        public Set<ControllerServiceNode> getControllerServicesReferencing(final ParameterContext parameterContext, final String parameterName) {
+            final ControllerServiceNode node = controllerServices.get(parameterName);
+            return node == null ? Collections.emptySet() : Collections.singleton(node);
+        }
+
+        @Override
+        public Set<ProcessGroup> getProcessGroupsBound(final ParameterContext parameterContext) {
+            return Collections.emptySet();
+        }
+
+        public void addProcessorReference(final String parameterName, final ProcessorNode processor) {
+            processors.put(parameterName, processor);
+        }
+
+        public void addControllerServiceReference(final String parameterName, final ControllerServiceNode service) {
+            controllerServices.put(parameterName, service);
+        }
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/processor/TestStandardPropertyValue.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/processor/TestStandardPropertyValue.java
index 1504ed0cd71..4d84730265b 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/processor/TestStandardPropertyValue.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-framework-core/src/test/java/org/apache/nifi/processor/TestStandardPropertyValue.java
@@ -16,13 +16,7 @@
  */
 package org.apache.nifi.processor;
 
-import static org.junit.Assert.assertEquals;
-
-import java.util.Calendar;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Set;
-
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.components.PropertyValue;
 import org.apache.nifi.controller.ControllerService;
@@ -31,6 +25,13 @@
 import org.apache.nifi.flowfile.FlowFile;
 import org.junit.Test;
 
+import java.util.Calendar;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+
+import static org.junit.Assert.assertEquals;
+
 
 public class TestStandardPropertyValue {
 
@@ -38,7 +39,7 @@ public class TestStandardPropertyValue {
 
     @Test
     public void testSubstituteAttributesWithOneMatchingArg() {
-        final PropertyValue value = new StandardPropertyValue("Hello, ${audience}!", lookup);
+        final PropertyValue value = new StandardPropertyValue("Hello, ${audience}!", lookup, ParameterLookup.EMPTY);
         final Map<String, String> attributes = new HashMap<>();
         attributes.put("audience", "World");
         assertEquals("Hello, World!", value.evaluateAttributeExpressions(createFlowFile(attributes)).getValue());
@@ -46,7 +47,7 @@ public void testSubstituteAttributesWithOneMatchingArg() {
 
     @Test
     public void testMissingEndBraceEvaluatesToStringLiteral() {
-        final PropertyValue value = new StandardPropertyValue("Hello, ${audience!", lookup);
+        final PropertyValue value = new StandardPropertyValue("Hello, ${audience!", lookup, ParameterLookup.EMPTY);
         final Map<String, String> attributes = new HashMap<>();
         attributes.put("audience", "World");
         assertEquals("Hello, ${audience!", value.evaluateAttributeExpressions(createFlowFile(attributes)).getValue());
@@ -54,7 +55,7 @@ public void testMissingEndBraceEvaluatesToStringLiteral() {
 
     @Test
     public void testEscaped() {
-        final PropertyValue value = new StandardPropertyValue("Hello, $${audience}!", lookup);
+        final PropertyValue value = new StandardPropertyValue("Hello, $${audience}!", lookup, ParameterLookup.EMPTY);
         final Map<String, String> attributes = new HashMap<>();
         attributes.put("audience", "World");
         assertEquals("Hello, ${audience}!", value.evaluateAttributeExpressions(createFlowFile(attributes)).getValue());
@@ -62,7 +63,7 @@ public void testEscaped() {
 
     @Test
     public void testSubstituteAttributesWithMultipleMatchingArgs() {
-        final PropertyValue value = new StandardPropertyValue("Hello, ${audience}${comma}${question}!", lookup);
+        final PropertyValue value = new StandardPropertyValue("Hello, ${audience}${comma}${question}!", lookup, ParameterLookup.EMPTY);
         final Map<String, String> attributes = new HashMap<>();
         attributes.put("audience", "World");
         attributes.put("comma", ",");
@@ -72,14 +73,14 @@ public void testSubstituteAttributesWithMultipleMatchingArgs() {
 
     @Test
     public void testSubstituteAttributesWithNoMatch() {
-        final PropertyValue value = new StandardPropertyValue("Hello, ${audience}${comma}${question:replaceNull('')}!", lookup);
+        final PropertyValue value = new StandardPropertyValue("Hello, ${audience}${comma}${question:replaceNull('')}!", lookup, ParameterLookup.EMPTY);
         final Map<String, String> attributes = new HashMap<>();
         assertEquals("Hello, !", value.evaluateAttributeExpressions(createFlowFile(attributes)).getValue());
     }
 
     @Test
     public void testSubstituteAttributesRecursively() {
-        final PropertyValue value = new StandardPropertyValue("Hello, ${'${a}${b}'}!", lookup);
+        final PropertyValue value = new StandardPropertyValue("Hello, ${'${a}${b}'}!", lookup, ParameterLookup.EMPTY);
         final Map<String, String> attributes = new HashMap<>();
         attributes.put("a", "b");
         attributes.put("b", "World");
@@ -89,7 +90,7 @@ public void testSubstituteAttributesRecursively() {
 
     @Test
     public void testGetValueAsIntegerAfterSubstitute() {
-        final PropertyValue value = new StandardPropertyValue("1${value}", lookup);
+        final PropertyValue value = new StandardPropertyValue("1${value}", lookup, ParameterLookup.EMPTY);
         final Map<String, String> attributes = new HashMap<>();
         attributes.put("value", "39");
         assertEquals(139, value.evaluateAttributeExpressions(createFlowFile(attributes)).asInteger().intValue());
@@ -97,7 +98,7 @@ public void testGetValueAsIntegerAfterSubstitute() {
 
     @Test(expected = NumberFormatException.class)
     public void testGetValueAsIntegerAfterSubstitutingWithNonInteger() {
-        final PropertyValue value = new StandardPropertyValue("1${value}", lookup);
+        final PropertyValue value = new StandardPropertyValue("1${value}", lookup, ParameterLookup.EMPTY);
         final Map<String, String> attributes = new HashMap<>();
         attributes.put("value", "Yes");
         final PropertyValue substituted = value.evaluateAttributeExpressions(createFlowFile(attributes));
@@ -106,7 +107,7 @@ public void testGetValueAsIntegerAfterSubstitutingWithNonInteger() {
 
     @Test
     public void testFileSize() {
-        final PropertyValue value = new StandardPropertyValue("${fileSize}", lookup);
+        final PropertyValue value = new StandardPropertyValue("${fileSize}", lookup, ParameterLookup.EMPTY);
         final FlowFile flowFile = new StandardFlowFileRecord.Builder().size(1024 * 1024L).build();
         final long val = value.evaluateAttributeExpressions(flowFile).asLong().longValue();
         assertEquals(1024 * 1024L, val);
@@ -116,7 +117,7 @@ public void testFileSize() {
     public void testFlowFileEntryYear() {
         final Calendar now = Calendar.getInstance();
         final int year = now.get(Calendar.YEAR);
-        final PropertyValue value = new StandardPropertyValue("${entryDate:toNumber():toDate():format('yyyy')}", lookup);
+        final PropertyValue value = new StandardPropertyValue("${entryDate:toNumber():toDate():format('yyyy')}", lookup, ParameterLookup.EMPTY);
         final FlowFile flowFile = new StandardFlowFileRecord.Builder().entryDate(now.getTimeInMillis()).build();
         final int val = value.evaluateAttributeExpressions(flowFile).asInteger().intValue();
         assertEquals(year, val);
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-site-to-site/src/main/java/org/apache/nifi/remote/PeerDescriptionModifier.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-site-to-site/src/main/java/org/apache/nifi/remote/PeerDescriptionModifier.java
index 9e40c499b59..554d2ebb844 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-site-to-site/src/main/java/org/apache/nifi/remote/PeerDescriptionModifier.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-site-to-site/src/main/java/org/apache/nifi/remote/PeerDescriptionModifier.java
@@ -16,8 +16,10 @@
  */
 package org.apache.nifi.remote;
 
+import org.apache.nifi.attribute.expression.language.EvaluationContext;
 import org.apache.nifi.attribute.expression.language.PreparedQuery;
 import org.apache.nifi.attribute.expression.language.Query;
+import org.apache.nifi.attribute.expression.language.StandardEvaluationContext;
 import org.apache.nifi.attribute.expression.language.exception.AttributeExpressionLanguageParsingException;
 import org.apache.nifi.remote.protocol.SiteToSiteTransportProtocol;
 import org.apache.nifi.util.NiFiProperties;
@@ -64,17 +66,19 @@ private Route validate() {
         }
 
         private PeerDescription getTarget(final Map<String, String> variables) {
-            final String targetHostName = hostname.evaluateExpressions(variables, null);
+            final EvaluationContext evaluationContext = new StandardEvaluationContext(variables);
+
+            final String targetHostName = hostname.evaluateExpressions(evaluationContext, null);
             if (isBlank(targetHostName)) {
                 throw new IllegalStateException("Target hostname was not resolved for the route definition " + name);
             }
 
-            final String targetPortStr = port.evaluateExpressions(variables, null);
+            final String targetPortStr = port.evaluateExpressions(evaluationContext, null);
             if (isBlank(targetPortStr)) {
                 throw new IllegalStateException("Target port was not resolved for the route definition " + name);
             }
 
-            final String targetIsSecure = secure == null ? null : secure.evaluateExpressions(variables, null);
+            final String targetIsSecure = secure == null ? null : secure.evaluateExpressions(evaluationContext, null);
             return new PeerDescription(targetHostName, Integer.valueOf(targetPortStr), Boolean.valueOf(targetIsSecure));
         }
     }
@@ -169,7 +173,7 @@ public PeerDescription modify(final PeerDescription source, final PeerDescriptio
         logger.debug("Modifying PeerDescription, variables={}", variables);
 
         return routes.get(protocol).stream().filter(r -> r.predicate == null
-                || Boolean.valueOf(r.predicate.evaluateExpressions(variables, null)))
+                || Boolean.valueOf(r.predicate.evaluateExpressions(new StandardEvaluationContext(variables), null)))
                 .map(r -> {
                     final PeerDescription t = r.getTarget(variables);
                     logger.debug("Route definition {} matched, {}", r.name, t);
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/audit/ControllerServiceAuditor.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/audit/ControllerServiceAuditor.java
index b07af07634c..60d19fdf4c8 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/audit/ControllerServiceAuditor.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/audit/ControllerServiceAuditor.java
@@ -412,8 +412,9 @@ private Map<String, String> extractConfiguredPropertyValues(ControllerServiceNod
         }
         if (controllerServiceDTO.getProperties() != null) {
             // for each property specified, extract its configured value
-            Map<String, String> properties = controllerServiceDTO.getProperties();
-            Map<PropertyDescriptor, String> configuredProperties = controllerService.getProperties();
+            final Map<String, String> properties = controllerServiceDTO.getProperties();
+            final Map<PropertyDescriptor, String> configuredProperties = controllerService.getRawPropertyValues();
+
             for (String propertyName : properties.keySet()) {
                 // build a descriptor for getting the configured value
                 PropertyDescriptor propertyDescriptor = new PropertyDescriptor.Builder().name(propertyName).build();
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/audit/ProcessorAuditor.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/audit/ProcessorAuditor.java
index c40c0876d08..eeb7bf6d0bd 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/audit/ProcessorAuditor.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/audit/ProcessorAuditor.java
@@ -356,7 +356,7 @@ private Map<String, String> extractConfiguredPropertyValues(ProcessorNode proces
             if (newConfig.getProperties() != null) {
                 // for each property specified, extract its configured value
                 Map<String, String> properties = newConfig.getProperties();
-                Map<PropertyDescriptor, String> configuredProperties = processor.getProperties();
+                Map<PropertyDescriptor, String> configuredProperties = processor.getRawPropertyValues();
                 for (String propertyName : properties.keySet()) {
                     // build a descriptor for getting the configured value
                     PropertyDescriptor propertyDescriptor = new PropertyDescriptor.Builder().name(propertyName).build();
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/audit/ReportingTaskAuditor.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/audit/ReportingTaskAuditor.java
index c8e26820c53..c83bc82f264 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/audit/ReportingTaskAuditor.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/audit/ReportingTaskAuditor.java
@@ -315,7 +315,7 @@ private Map<String, String> extractConfiguredPropertyValues(ReportingTaskNode re
         if (reportingTaskDTO.getProperties() != null) {
             // for each property specified, extract its configured value
             Map<String, String> properties = reportingTaskDTO.getProperties();
-            Map<PropertyDescriptor, String> configuredProperties = reportingTask.getProperties();
+            Map<PropertyDescriptor, String> configuredProperties = reportingTask.getRawPropertyValues();
             for (String propertyName : properties.keySet()) {
                 // build a descriptor for getting the configured value
                 PropertyDescriptor propertyDescriptor = new PropertyDescriptor.Builder().name(propertyName).build();
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/AuthorizableLookup.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/AuthorizableLookup.java
index 468a92ad21a..f3285847d65 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/AuthorizableLookup.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/AuthorizableLookup.java
@@ -191,6 +191,20 @@ public interface AuthorizableLookup {
      */
     ComponentAuthorizable getReportingTask(String id);
 
+    /**
+     * Get the authorizable Parameter Context
+     *
+     * @param id the ID of the Parameter Context
+     * @return authorizable
+     */
+    Authorizable getParameterContext(String id);
+
+    /**
+     * Get the authorizable for Parameter Contexts
+     * @return authorizable
+     */
+    Authorizable getParameterContexts();
+
     /**
      * Get the authorizable Template.
      *
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/AuthorizeControllerServiceReference.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/AuthorizeControllerServiceReference.java
index 16984fa71a4..fb38782422a 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/AuthorizeControllerServiceReference.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/AuthorizeControllerServiceReference.java
@@ -20,6 +20,9 @@
 import org.apache.nifi.authorization.user.NiFiUser;
 import org.apache.nifi.authorization.user.NiFiUserUtils;
 import org.apache.nifi.components.PropertyDescriptor;
+import org.apache.nifi.parameter.ExpressionLanguageAgnosticParameterParser;
+import org.apache.nifi.parameter.ParameterParser;
+import org.apache.nifi.parameter.ParameterTokenList;
 import org.apache.nifi.web.ResourceNotFoundException;
 
 import java.util.Map;
@@ -41,7 +44,7 @@ public static void authorizeControllerServiceReferences(final ComponentAuthoriza
                                                             final AuthorizableLookup lookup, final boolean authorizeTransitiveServices) {
 
         // consider each property when looking for service references
-        authorizable.getPropertyDescriptors().stream().forEach(descriptor -> {
+        authorizable.getPropertyDescriptors().forEach(descriptor -> {
             // if this descriptor identifies a controller service
             if (descriptor.getControllerServiceDefinition() != null) {
                 // get the service id
@@ -102,6 +105,15 @@ public static void authorizeControllerServiceReferences(final Map<String, String
 
                         // ensure access to the new service
                         if (proposedValue != null) {
+                            final ParameterParser parser = new ExpressionLanguageAgnosticParameterParser();
+                            final ParameterTokenList tokenList = parser.parseTokens(proposedValue);
+                            final boolean referencesParameter = !tokenList.toReferenceList().isEmpty();
+                            if (referencesParameter) {
+                                throw new IllegalArgumentException("The property '" + propertyDescriptor.getDisplayName() + "' cannot reference a Parameter because the property is a " +
+                                    "Controller Service reference. Allowing Controller Service references to make use of Parameters could result in security issues and a poor user experience. " +
+                                    "As a result, this is not allowed.");
+                            }
+
                             final Authorizable newServiceAuthorizable = lookup.getControllerService(proposedValue).getAuthorizable();
                             newServiceAuthorizable.authorize(authorizer, RequestAction.READ, user);
                         }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/AuthorizeParameterReference.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/AuthorizeParameterReference.java
new file mode 100644
index 00000000000..fd7f644e872
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/AuthorizeParameterReference.java
@@ -0,0 +1,127 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.authorization;
+
+import org.apache.nifi.authorization.resource.Authorizable;
+import org.apache.nifi.authorization.user.NiFiUser;
+import org.apache.nifi.components.PropertyDescriptor;
+import org.apache.nifi.groups.ProcessGroup;
+import org.apache.nifi.parameter.ExpressionLanguageAgnosticParameterParser;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterParser;
+import org.apache.nifi.parameter.ParameterTokenList;
+import org.apache.nifi.web.api.dto.ControllerServiceDTO;
+import org.apache.nifi.web.api.dto.FlowSnippetDTO;
+import org.apache.nifi.web.api.dto.ProcessorConfigDTO;
+import org.apache.nifi.web.api.dto.ProcessorDTO;
+
+import java.util.Map;
+
+public class AuthorizeParameterReference {
+
+    public static void authorizeParameterReferences(final Map<String, String> proposedProperties, final Authorizer authorizer, final Authorizable parameterContextAuthorizable, final NiFiUser user) {
+        if (proposedProperties == null || parameterContextAuthorizable == null) {
+            return;
+        }
+
+        final ParameterParser parameterParser = new ExpressionLanguageAgnosticParameterParser();
+
+        boolean referencesParameter = false;
+        for (final String proposedPropertyValue : proposedProperties.values()) {
+            // Check if any Parameter is referenced. If so, user must have READ policy on the Parameter Context
+            ParameterTokenList tokenList = parameterParser.parseTokens(proposedPropertyValue);
+            if (!tokenList.toReferenceList().isEmpty()) {
+                referencesParameter = true;
+                break;
+            }
+        }
+
+        if (referencesParameter) {
+            parameterContextAuthorizable.authorize(authorizer, RequestAction.READ, user);
+        }
+    }
+
+    public static void authorizeParameterReferences(final ComponentAuthorizable authorizable, final Authorizer authorizer, final Authorizable parameterContextAuthorizable, final NiFiUser user) {
+        if (parameterContextAuthorizable == null) {
+            return;
+        }
+
+        final ParameterParser parameterParser = new ExpressionLanguageAgnosticParameterParser();
+
+        boolean referencesParameter = false;
+        for (final PropertyDescriptor propertyDescriptor : authorizable.getPropertyDescriptors()) {
+            final String rawValue = authorizable.getRawValue(propertyDescriptor);
+
+            final ParameterTokenList tokenList = parameterParser.parseTokens(rawValue);
+            if (!tokenList.toReferenceList().isEmpty()) {
+                referencesParameter = true;
+                break;
+            }
+        }
+
+        if (referencesParameter) {
+            parameterContextAuthorizable.authorize(authorizer, RequestAction.READ, user);
+        }
+    }
+
+    public static void authorizeParameterReferences(final FlowSnippetDTO flowSnippet, final Authorizer authorizer, final Authorizable parameterContextAuthorizable, final NiFiUser user) {
+        for (final ProcessorDTO processorDto : flowSnippet.getProcessors()) {
+            final ProcessorConfigDTO configDto = processorDto.getConfig();
+            if (configDto == null) {
+                continue;
+            }
+
+            authorizeParameterReferences(configDto.getProperties(), authorizer, parameterContextAuthorizable, user);
+        }
+
+        for (final ControllerServiceDTO serviceDto : flowSnippet.getControllerServices()) {
+            authorizeParameterReferences(serviceDto.getProperties(), authorizer, parameterContextAuthorizable, user);
+        }
+
+        // Note: there is no need to recurse here because when a template/snippet is instantiated, if there are any components in child Process Groups, a new Process Group will be created
+        // without any Parameter Context, so there is no need to perform any authorization beyond the top-level group where the instantiation is occurring.
+    }
+
+    /**
+     * If any parameter is referenced by the given component node, will authorize user against the given group's Parameter context
+     * @param destinationGroup the group that the component is being moved to
+     * @param component the component being moved
+     * @param authorizer the authorizer
+     * @param user the nifi user
+     */
+    public static void authorizeParameterReferences(final ProcessGroup destinationGroup, final ComponentAuthorizable component, final Authorizer authorizer, final NiFiUser user) {
+        final ParameterParser parameterParser = new ExpressionLanguageAgnosticParameterParser();
+
+        boolean referencesParameter = false;
+        for (final PropertyDescriptor propertyDescriptor : component.getPropertyDescriptors()) {
+            final String rawValue = component.getRawValue(propertyDescriptor);
+
+            final ParameterTokenList tokenList = parameterParser.parseTokens(rawValue);
+            if (!tokenList.toReferenceList().isEmpty()) {
+                referencesParameter = true;
+                break;
+            }
+        }
+
+        if (referencesParameter) {
+            final ParameterContext destinationContext = destinationGroup.getParameterContext();
+            if (destinationContext != null) {
+                destinationContext.authorize(authorizer, RequestAction.READ, user);
+            }
+        }
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/ComponentAuthorizable.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/ComponentAuthorizable.java
index 4e29b3005dc..46acc111554 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/ComponentAuthorizable.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/ComponentAuthorizable.java
@@ -47,6 +47,11 @@ public interface ComponentAuthorizable {
      */
     Set<Authorizable> getRestrictedAuthorizables();
 
+    /**
+     * @return the Parameter Context that is bound to this component's Process Group, as an Authorizable, or <code>null</code> if no Parameter Context is bound
+     */
+    Authorizable getParameterContext();
+
     /**
      * Returns the property descriptor for the specified property.
      *
@@ -70,6 +75,14 @@ public interface ComponentAuthorizable {
      */
     String getValue(PropertyDescriptor propertyDescriptor);
 
+    /**
+     * Returns the currently configured value of the specified property without performing Parameter substitution
+     *
+     * @param propertyDescriptor property descriptor
+     * @return value
+     */
+    String getRawValue(PropertyDescriptor propertyDescriptor);
+
     /**
      * Cleans up any resources resulting from the creation of these temporary components.
      */
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/ProcessGroupAuthorizable.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/ProcessGroupAuthorizable.java
index f3516dafb00..ae1d372482b 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/ProcessGroupAuthorizable.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/ProcessGroupAuthorizable.java
@@ -17,6 +17,7 @@
 package org.apache.nifi.authorization;
 
 import org.apache.nifi.authorization.resource.Authorizable;
+import org.apache.nifi.groups.ProcessGroup;
 
 import java.util.Set;
 
@@ -31,6 +32,13 @@ public interface ProcessGroupAuthorizable {
      */
     Authorizable getAuthorizable();
 
+    /**
+     * Returns the Process Group that this Authorizable represents. Non null
+     *
+     * @return the Process Group
+     */
+    ProcessGroup getProcessGroup();
+
     /**
      * The authorizables for all encapsulated processors. Non null
      *
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/SnippetAuthorizable.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/SnippetAuthorizable.java
index 7cc8e4cc37f..f22b800f8ae 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/SnippetAuthorizable.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/SnippetAuthorizable.java
@@ -29,7 +29,7 @@ public interface SnippetAuthorizable {
      *
      * @return authorizable for parent process group of this snippet
      */
-    Authorizable getParentProcessGroup();
+    ProcessGroupAuthorizable getParentProcessGroup();
 
     /**
      * The authorizables for selected processors. Non null
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/StandardAuthorizableLookup.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/StandardAuthorizableLookup.java
index 40336839d2b..4594ee05fa9 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/StandardAuthorizableLookup.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/authorization/StandardAuthorizableLookup.java
@@ -22,11 +22,11 @@
 import org.apache.nifi.authorization.resource.Authorizable;
 import org.apache.nifi.authorization.resource.DataAuthorizable;
 import org.apache.nifi.authorization.resource.DataTransferAuthorizable;
+import org.apache.nifi.authorization.resource.OperationAuthorizable;
 import org.apache.nifi.authorization.resource.ProvenanceDataAuthorizable;
 import org.apache.nifi.authorization.resource.ResourceFactory;
 import org.apache.nifi.authorization.resource.ResourceType;
 import org.apache.nifi.authorization.resource.RestrictedComponentsAuthorizableFactory;
-import org.apache.nifi.authorization.resource.OperationAuthorizable;
 import org.apache.nifi.authorization.resource.TenantAuthorizable;
 import org.apache.nifi.authorization.user.NiFiUser;
 import org.apache.nifi.bundle.BundleCoordinate;
@@ -56,6 +56,7 @@
 import org.apache.nifi.web.dao.ControllerServiceDAO;
 import org.apache.nifi.web.dao.FunnelDAO;
 import org.apache.nifi.web.dao.LabelDAO;
+import org.apache.nifi.web.dao.ParameterContextDAO;
 import org.apache.nifi.web.dao.PortDAO;
 import org.apache.nifi.web.dao.ProcessGroupDAO;
 import org.apache.nifi.web.dao.ProcessorDAO;
@@ -158,6 +159,8 @@ public Resource getResource() {
         }
     };
 
+
+
     // nifi core components
     private ControllerFacade controllerFacade;
 
@@ -175,6 +178,7 @@ public Resource getResource() {
     private ReportingTaskDAO reportingTaskDAO;
     private TemplateDAO templateDAO;
     private AccessPolicyDAO accessPolicyDAO;
+    private ParameterContextDAO parameterContextDAO;
 
     @Override
     public Authorizable getController() {
@@ -268,6 +272,11 @@ public Authorizable getOutputPort(final String id) {
         return outputPortDAO.getPort(id);
     }
 
+    @Override
+    public Authorizable getParameterContext(final String id) {
+        return parameterContextDAO.getParameterContext(id);
+    }
+
     @Override
     public ConnectionAuthorizable getConnection(final String id) {
         final Connection connection = connectionDAO.getConnection(id);
@@ -372,8 +381,8 @@ public SnippetAuthorizable getSnippet(final String id) {
 
         return new SnippetAuthorizable() {
             @Override
-            public Authorizable getParentProcessGroup() {
-                return processGroup;
+            public ProcessGroupAuthorizable getParentProcessGroup() {
+                return new StandardProcessGroupAuthorizable(processGroup, controllerFacade.getExtensionManager());
             }
 
             @Override
@@ -567,6 +576,9 @@ private Authorizable getAccessPolicyByResource(final ResourceType resourceType,
             case Template:
                 authorizable = getTemplate(componentId);
                 break;
+            case ParameterContext:
+                authorizable = getParameterContext(componentId);
+                break;
         }
 
         if (authorizable == null) {
@@ -649,6 +661,9 @@ public Resource getResource() {
             case Tenant:
                 authorizable = getTenant();
                 break;
+            case ParameterContext:
+                authorizable = getParameterContexts();
+                break;
         }
 
         if (authorizable == null) {
@@ -697,7 +712,7 @@ private void createTemporaryProcessorsAndControllerServices(final FlowSnippetDTO
         }
 
         if (snippet.getProcessGroups() != null) {
-            snippet.getProcessGroups().stream().forEach(group -> createTemporaryProcessorsAndControllerServices(group.getContents(), processors, controllerServices, extensionManager));
+            snippet.getProcessGroups().forEach(group -> createTemporaryProcessorsAndControllerServices(group.getContents(), processors, controllerServices, extensionManager));
         }
     }
 
@@ -754,6 +769,21 @@ public Authorizable getSystem() {
         return SYSTEM_AUTHORIZABLE;
     }
 
+    @Override
+    public Authorizable getParameterContexts() {
+        return new Authorizable() {
+            @Override
+            public Authorizable getParentAuthorizable() {
+                return getController();
+            }
+
+            @Override
+            public Resource getResource() {
+                return ResourceFactory.getParameterContextsResource();
+            }
+        };
+    }
+
     /**
      * ComponentAuthorizable for a ConfigurableComponent. This authorizable is intended only to be used when
      * creating new components.
@@ -787,6 +817,11 @@ public String getValue(PropertyDescriptor propertyDescriptor) {
             return null;
         }
 
+        @Override
+        public String getRawValue(final PropertyDescriptor propertyDescriptor) {
+            return null;
+        }
+
         @Override
         public PropertyDescriptor getPropertyDescriptor(String propertyName) {
             return configurableComponent.getPropertyDescriptor(propertyName);
@@ -801,6 +836,11 @@ public List<PropertyDescriptor> getPropertyDescriptors() {
         public void cleanUpResources() {
             extensionManager.removeInstanceClassLoader(configurableComponent.getIdentifier());
         }
+
+        @Override
+        public Authorizable getParameterContext() {
+            return null;
+        }
     }
 
     /**
@@ -830,9 +870,19 @@ public Set<Authorizable> getRestrictedAuthorizables() {
             return RestrictedComponentsAuthorizableFactory.getRestrictedComponentsAuthorizable(processorNode.getComponentClass());
         }
 
+        @Override
+        public Authorizable getParameterContext() {
+            return processorNode.getProcessGroup().getParameterContext();
+        }
+
         @Override
         public String getValue(PropertyDescriptor propertyDescriptor) {
-            return processorNode.getProperty(propertyDescriptor);
+            return processorNode.getEffectivePropertyValue(propertyDescriptor);
+        }
+
+        @Override
+        public String getRawValue(final PropertyDescriptor propertyDescriptor) {
+            return processorNode.getRawPropertyValue(propertyDescriptor);
         }
 
         @Override
@@ -878,9 +928,20 @@ public Set<Authorizable> getRestrictedAuthorizables() {
             return RestrictedComponentsAuthorizableFactory.getRestrictedComponentsAuthorizable(controllerServiceNode.getComponentClass());
         }
 
+        @Override
+        public Authorizable getParameterContext() {
+            final ProcessGroup processGroup = controllerServiceNode.getProcessGroup();
+            return processGroup == null ? null : processGroup.getParameterContext(); // will be null if Controller-level Controller Service.
+        }
+
         @Override
         public String getValue(PropertyDescriptor propertyDescriptor) {
-            return controllerServiceNode.getProperty(propertyDescriptor);
+            return controllerServiceNode.getEffectivePropertyValue(propertyDescriptor);
+        }
+
+        @Override
+        public String getRawValue(final PropertyDescriptor propertyDescriptor) {
+            return controllerServiceNode.getRawPropertyValue(propertyDescriptor);
         }
 
         @Override
@@ -926,9 +987,19 @@ public Set<Authorizable> getRestrictedAuthorizables() {
             return RestrictedComponentsAuthorizableFactory.getRestrictedComponentsAuthorizable(reportingTaskNode.getComponentClass());
         }
 
+        @Override
+        public Authorizable getParameterContext() {
+            return null;
+        }
+
         @Override
         public String getValue(PropertyDescriptor propertyDescriptor) {
-            return reportingTaskNode.getProperty(propertyDescriptor);
+            return reportingTaskNode.getEffectivePropertyValue(propertyDescriptor);
+        }
+
+        @Override
+        public String getRawValue(final PropertyDescriptor propertyDescriptor) {
+            return reportingTaskNode.getRawPropertyValue(propertyDescriptor);
         }
 
         @Override
@@ -961,6 +1032,11 @@ public Authorizable getAuthorizable() {
             return processGroup;
         }
 
+        @Override
+        public ProcessGroup getProcessGroup() {
+            return processGroup;
+        }
+
         @Override
         public Set<ComponentAuthorizable> getEncapsulatedProcessors() {
             return processGroup.findAllProcessors().stream().map(
@@ -970,27 +1046,27 @@ public Set<ComponentAuthorizable> getEncapsulatedProcessors() {
         @Override
         public Set<ConnectionAuthorizable> getEncapsulatedConnections() {
             return processGroup.findAllConnections().stream().map(
-                    connection -> new StandardConnectionAuthorizable(connection)).collect(Collectors.toSet());
+                StandardConnectionAuthorizable::new).collect(Collectors.toSet());
         }
 
         @Override
         public Set<Authorizable> getEncapsulatedInputPorts() {
-            return processGroup.findAllInputPorts().stream().collect(Collectors.toSet());
+            return new HashSet<>(processGroup.findAllInputPorts());
         }
 
         @Override
         public Set<Authorizable> getEncapsulatedOutputPorts() {
-            return processGroup.findAllOutputPorts().stream().collect(Collectors.toSet());
+            return new HashSet<>(processGroup.findAllOutputPorts());
         }
 
         @Override
         public Set<Authorizable> getEncapsulatedFunnels() {
-            return processGroup.findAllFunnels().stream().collect(Collectors.toSet());
+            return new HashSet<>(processGroup.findAllFunnels());
         }
 
         @Override
         public Set<Authorizable> getEncapsulatedLabels() {
-            return processGroup.findAllLabels().stream().collect(Collectors.toSet());
+            return new HashSet<>(processGroup.findAllLabels());
         }
 
         @Override
@@ -1001,12 +1077,12 @@ public Set<ProcessGroupAuthorizable> getEncapsulatedProcessGroups() {
 
         @Override
         public Set<Authorizable> getEncapsulatedRemoteProcessGroups() {
-            return processGroup.findAllRemoteProcessGroups().stream().collect(Collectors.toSet());
+            return new HashSet<>(processGroup.findAllRemoteProcessGroups());
         }
 
         @Override
         public Set<Authorizable> getEncapsulatedTemplates() {
-            return processGroup.findAllTemplates().stream().collect(Collectors.toSet());
+            return new HashSet<>(processGroup.findAllTemplates());
         }
 
         @Override
@@ -1106,6 +1182,10 @@ public void setAccessPolicyDAO(AccessPolicyDAO accessPolicyDAO) {
         this.accessPolicyDAO = accessPolicyDAO;
     }
 
+    public void setParameterContextDAO(ParameterContextDAO parameterContextDAO) {
+        this.parameterContextDAO = parameterContextDAO;
+    }
+
     public void setControllerFacade(ControllerFacade controllerFacade) {
         this.controllerFacade = controllerFacade;
     }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/NiFiServiceFacade.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/NiFiServiceFacade.java
index ff47e5fbb73..15720d8c512 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/NiFiServiceFacade.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/NiFiServiceFacade.java
@@ -28,6 +28,7 @@
 import org.apache.nifi.registry.flow.ExternalControllerServiceReference;
 import org.apache.nifi.registry.flow.VersionedFlow;
 import org.apache.nifi.registry.flow.VersionedFlowSnapshot;
+import org.apache.nifi.registry.flow.VersionedParameterContext;
 import org.apache.nifi.registry.flow.VersionedProcessGroup;
 import org.apache.nifi.web.api.dto.AccessPolicyDTO;
 import org.apache.nifi.web.api.dto.AffectedComponentDTO;
@@ -52,6 +53,7 @@
 import org.apache.nifi.web.api.dto.LabelDTO;
 import org.apache.nifi.web.api.dto.ListingRequestDTO;
 import org.apache.nifi.web.api.dto.NodeDTO;
+import org.apache.nifi.web.api.dto.ParameterContextDTO;
 import org.apache.nifi.web.api.dto.PortDTO;
 import org.apache.nifi.web.api.dto.ProcessGroupDTO;
 import org.apache.nifi.web.api.dto.ProcessorDTO;
@@ -94,6 +96,8 @@
 import org.apache.nifi.web.api.entity.FlowEntity;
 import org.apache.nifi.web.api.entity.FunnelEntity;
 import org.apache.nifi.web.api.entity.LabelEntity;
+import org.apache.nifi.web.api.entity.ComponentValidationResultEntity;
+import org.apache.nifi.web.api.entity.ParameterContextEntity;
 import org.apache.nifi.web.api.entity.PortEntity;
 import org.apache.nifi.web.api.entity.PortStatusEntity;
 import org.apache.nifi.web.api.entity.ProcessGroupEntity;
@@ -409,11 +413,12 @@ Set<DocumentedTypeDTO> getControllerServiceTypes(final String serviceType, final
     void verifyCanAddTemplate(String groupId, String name);
 
     /**
-     * Verifies the types of components in a template.
+     * Verifies the given template can be instantiated in the group with the given ID
      *
-     * @param snippet proposed template
+     * @param groupId the ID of the Process Group
+     * @param snippetDTO the contents of the template
      */
-    void verifyComponentTypes(FlowSnippetDTO snippet);
+    void verifyCanInstantiate(String groupId, FlowSnippetDTO snippetDTO);
 
     /**
      * Verifies the types of components in a versioned process group
@@ -1018,6 +1023,76 @@ Set<DocumentedTypeDTO> getControllerServiceTypes(final String serviceType, final
      */
     Set<AffectedComponentDTO> getActiveComponentsAffectedByVariableRegistryUpdate(VariableRegistryDTO variableRegistryDto);
 
+    /**
+     * Verifies that a Parameter Context matching the given DTO can be created
+     * @param parameterContext the DTO that represents the Parameter Context
+     * @throws IllegalStateException if a ParameterContext cannot be created for the given DTO
+     */
+    void verifyCreateParameterContext(ParameterContextDTO parameterContext);
+
+    /**
+     * Verifies that the Parameter Context with the ID identified by the given DTO can be updated to match
+     * the given set of Parameters
+     *
+     * @param parameterContext the DTO that represents the updated Parameter Context
+     * @param verifyComponentStates if <code>true</code>, will ensure that any processor referencing the parameter context is stopped/disabled and any controller service referencing the parameter
+     * context is disabled. If <code>false</code>, these verifications will not be performed.
+     */
+    void verifyUpdateParameterContext(ParameterContextDTO parameterContext, boolean verifyComponentStates);
+
+    /**
+     * Returns the Set of all Parameter Context Entities for the current user
+     * @return the Set of all Parameter Context Entities for the current user
+     */
+    Set<ParameterContextEntity> getParameterContexts();
+
+    /**
+     * Returns the ParameterContextEntity for the ParameterContext with the given ID
+     * @param parameterContextId the ID of the Parameter Context
+     * @param user the user on whose behalf the Parameter Context is being retrieved
+     * @return the ParameterContextEntity
+     */
+    ParameterContextEntity getParameterContext(String parameterContextId, NiFiUser user);
+
+    /**
+     * Creates a new Parameter Context
+     * @param revision the revision for the newly created Parameter Context
+     * @param parameterContext the Parameter Context
+     * @return a ParameterContextEntity representing the newly created ParameterContext
+     */
+    ParameterContextEntity createParameterContext(Revision revision, ParameterContextDTO parameterContext);
+
+    /**
+     * Updates the Parameter Context
+     * @param revision the current revision of the Parameter Context
+     * @param parameterContext the updated version of the ParameterContext
+     * @return the updated Parameter Context Entity
+     */
+    ParameterContextEntity updateParameterContext(Revision revision, ParameterContextDTO parameterContext);
+
+    /**
+     * Deletes the Parameter Context
+     * @param revision the revision of the Parameter Context
+     * @param parameterContextId the ID of the Parameter Context
+     * @return a Parameter Context Entity that represents the Parameter Context that was deleted
+     */
+    ParameterContextEntity deleteParameterContext(Revision revision, String parameterContextId);
+
+    /**
+     * Performs validation of all components that make use of the Parameter Context with the same ID as the given DTO, but validating against the Parameters
+     * specified within the DTO
+     * @param parameterContext the ParameterContext to validate against
+     * @param user the user on whose behalf the validation is taking place
+     * @return the ComponentValidationResultEntity for each component that makes use of the Parameter Context
+     */
+    List<ComponentValidationResultEntity> validateComponents(ParameterContextDTO parameterContext, NiFiUser user);
+
+    /**
+     * Ensures that the Parameter Context with the given ID can be deleted
+     * @param parameterContextId the ID of the Parameter Context
+     */
+    void verifyDeleteParameterContext(String parameterContextId);
+
     /**
      * Gets all process groups in the specified parent group.
      *
@@ -1362,13 +1437,14 @@ Set<DocumentedTypeDTO> getControllerServiceTypes(final String serviceType, final
      * @param snapshot the Snapshot to persist
      * @param externalControllerServiceReferences a mapping of controller service id to ExternalControllerServiceReference for any Controller Service that is referenced in the flow but not included
      * in the VersionedProcessGroup
+     * @oaram ParameterContext the parameter contexts to include
      * @param comments about the snapshot
      * @param expectedVersion the version to save the flow as
      * @return the snapshot that represents what was stored in the registry
      *
      * @throws NiFiCoreException if unable to register the snapshot with the flow registry
      */
-    VersionedFlowSnapshot registerVersionedFlowSnapshot(String registryId, VersionedFlow flow, VersionedProcessGroup snapshot,
+    VersionedFlowSnapshot registerVersionedFlowSnapshot(String registryId, VersionedFlow flow, VersionedProcessGroup snapshot, Collection<VersionedParameterContext> parameterContexts,
                                                         Map<String, ExternalControllerServiceReference> externalControllerServiceReferences, String comments, int expectedVersion);
 
     /**
@@ -1476,6 +1552,31 @@ VersionControlInformationEntity setVersionControlInformation(Revision processGro
     ProcessGroupEntity updateProcessGroupContents(Revision revision, String groupId, VersionControlInformationDTO versionControlInfo, VersionedFlowSnapshot snapshot,
                                                   String componentIdSeed, boolean verifyNotModified, boolean updateSettings, boolean updateDescendantVersionedFlows);
 
+
+    /**
+     * Returns a Set representing all components that will be affected by updating the Parameter Context that is represented by the given DTO.
+     *
+     * @param parameterContextDto the Parameter Context DTO that represents all changes that are to occur to a Parameter Context
+     * @return a Set representing all components that will be affected by the update
+     */
+    Set<AffectedComponentEntity> getComponentsAffectedByParameterContextUpdate(ParameterContextDTO parameterContextDto);
+
+    /**
+     * Returns a Set representing all Processors that reference any Parameters and that belong to the group with the given ID
+     *
+     * @param groupId the id of the process group
+     * @return a Set representing all Processors that reference Parameters
+     */
+    Set<AffectedComponentEntity> getProcessorsReferencingParameter(String groupId);
+
+    /**
+     * Returns a Set representing all Controller Services that reference any Parameters and that belong to the group with the given ID
+     *
+     * @param groupId the id of the process group
+     * @return a Set representing all Controller Services that reference Parameters
+     */
+    Set<AffectedComponentEntity> getControllerServicesReferencingParameter(String groupId);
+
     // ----------------------------------------
     // Component state methods
     // ----------------------------------------
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/NiFiWebApiResourceConfig.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/NiFiWebApiResourceConfig.java
index 065db86bfcd..4f195967582 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/NiFiWebApiResourceConfig.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/NiFiWebApiResourceConfig.java
@@ -99,6 +99,7 @@ public NiFiWebApiResourceConfig(@Context ServletContext servletContext) {
         register(ctx.getBean("accessPolicyResource"));
         register(ctx.getBean("tenantsResource"));
         register(ctx.getBean("versionsResource"));
+        register(ctx.getBean("parameterContextResource"));
 
         // exception mappers
         register(AccessDeniedExceptionMapper.class);
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/StandardNiFiServiceFacade.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/StandardNiFiServiceFacade.java
index d9aea867d4e..34670e06810 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/StandardNiFiServiceFacade.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/StandardNiFiServiceFacade.java
@@ -63,6 +63,7 @@
 import org.apache.nifi.components.Validator;
 import org.apache.nifi.components.state.Scope;
 import org.apache.nifi.components.state.StateMap;
+import org.apache.nifi.components.validation.ValidationState;
 import org.apache.nifi.connectable.Connectable;
 import org.apache.nifi.connectable.Connection;
 import org.apache.nifi.connectable.Funnel;
@@ -93,6 +94,11 @@
 import org.apache.nifi.history.HistoryQuery;
 import org.apache.nifi.history.PreviousValue;
 import org.apache.nifi.nar.ExtensionManager;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterDescriptor;
+import org.apache.nifi.parameter.ParameterReferenceManager;
+import org.apache.nifi.parameter.StandardParameterContext;
 import org.apache.nifi.registry.ComponentVariableRegistry;
 import org.apache.nifi.registry.authorization.Permissions;
 import org.apache.nifi.registry.bucket.Bucket;
@@ -110,6 +116,7 @@
 import org.apache.nifi.registry.flow.VersionedFlowSnapshot;
 import org.apache.nifi.registry.flow.VersionedFlowSnapshotMetadata;
 import org.apache.nifi.registry.flow.VersionedFlowState;
+import org.apache.nifi.registry.flow.VersionedParameterContext;
 import org.apache.nifi.registry.flow.VersionedProcessGroup;
 import org.apache.nifi.registry.flow.VersionedProcessor;
 import org.apache.nifi.registry.flow.VersionedPropertyDescriptor;
@@ -151,6 +158,7 @@
 import org.apache.nifi.web.api.dto.ComponentReferenceDTO;
 import org.apache.nifi.web.api.dto.ComponentRestrictionPermissionDTO;
 import org.apache.nifi.web.api.dto.ComponentStateDTO;
+import org.apache.nifi.web.api.dto.ComponentValidationResultDTO;
 import org.apache.nifi.web.api.dto.ConnectionDTO;
 import org.apache.nifi.web.api.dto.ControllerConfigurationDTO;
 import org.apache.nifi.web.api.dto.ControllerDTO;
@@ -170,6 +178,8 @@
 import org.apache.nifi.web.api.dto.LabelDTO;
 import org.apache.nifi.web.api.dto.ListingRequestDTO;
 import org.apache.nifi.web.api.dto.NodeDTO;
+import org.apache.nifi.web.api.dto.ParameterContextDTO;
+import org.apache.nifi.web.api.dto.ParameterDTO;
 import org.apache.nifi.web.api.dto.PermissionsDTO;
 import org.apache.nifi.web.api.dto.PortDTO;
 import org.apache.nifi.web.api.dto.PreviousValueDTO;
@@ -223,6 +233,7 @@
 import org.apache.nifi.web.api.entity.BucketEntity;
 import org.apache.nifi.web.api.entity.BulletinEntity;
 import org.apache.nifi.web.api.entity.ComponentReferenceEntity;
+import org.apache.nifi.web.api.entity.ComponentValidationResultEntity;
 import org.apache.nifi.web.api.entity.ConnectionEntity;
 import org.apache.nifi.web.api.entity.ConnectionStatusEntity;
 import org.apache.nifi.web.api.entity.ControllerBulletinsEntity;
@@ -236,6 +247,8 @@
 import org.apache.nifi.web.api.entity.FlowEntity;
 import org.apache.nifi.web.api.entity.FunnelEntity;
 import org.apache.nifi.web.api.entity.LabelEntity;
+import org.apache.nifi.web.api.entity.ParameterContextEntity;
+import org.apache.nifi.web.api.entity.ParameterEntity;
 import org.apache.nifi.web.api.entity.PortEntity;
 import org.apache.nifi.web.api.entity.PortStatusEntity;
 import org.apache.nifi.web.api.entity.ProcessGroupEntity;
@@ -271,6 +284,7 @@
 import org.apache.nifi.web.dao.ControllerServiceDAO;
 import org.apache.nifi.web.dao.FunnelDAO;
 import org.apache.nifi.web.dao.LabelDAO;
+import org.apache.nifi.web.dao.ParameterContextDAO;
 import org.apache.nifi.web.dao.PortDAO;
 import org.apache.nifi.web.dao.ProcessGroupDAO;
 import org.apache.nifi.web.dao.ProcessorDAO;
@@ -353,6 +367,7 @@ public class StandardNiFiServiceFacade implements NiFiServiceFacade {
     private UserGroupDAO userGroupDAO;
     private AccessPolicyDAO accessPolicyDAO;
     private RegistryDAO registryDAO;
+    private ParameterContextDAO parameterContextDAO;
     private ClusterCoordinator clusterCoordinator;
     private HeartbeatMonitor heartbeatMonitor;
     private LeaderElectionManager leaderElectionManager;
@@ -976,6 +991,273 @@ public VariableRegistryEntity updateVariableRegistry(Revision revision, Variable
         return entityFactory.createVariableRegistryEntity(snapshot.getComponent(), updatedRevision, permissions);
     }
 
+    public void verifyCreateParameterContext(final ParameterContextDTO parameterContextDto) {
+        parameterContextDAO.verifyCreate(parameterContextDto);
+    }
+
+    @Override
+    public void verifyUpdateParameterContext(final ParameterContextDTO parameterContext, final boolean verifyComponentStates) {
+        parameterContextDAO.verifyUpdate(parameterContext, verifyComponentStates);
+    }
+
+    @Override
+    public ParameterContextEntity updateParameterContext(final Revision revision, final ParameterContextDTO parameterContextDto) {
+        // get the component, ensure we have access to it, and perform the update request
+        final ParameterContext parameterContext = parameterContextDAO.getParameterContext(parameterContextDto.getId());
+        final RevisionUpdate<ParameterContextDTO> snapshot = updateComponent(revision,
+            parameterContext,
+            () -> parameterContextDAO.updateParameterContext(parameterContextDto),
+            context -> dtoFactory.createParameterContextDto(context, revisionManager));
+
+        final PermissionsDTO permissions = dtoFactory.createPermissionsDto(parameterContext);
+        final RevisionDTO revisionDto = dtoFactory.createRevisionDTO(snapshot.getLastModification());
+        return entityFactory.createParameterContextEntity(snapshot.getComponent(), revisionDto, permissions);
+
+    }
+
+    @Override
+    public ParameterContextEntity getParameterContext(final String parameterContextId, final NiFiUser user) {
+        final ParameterContext parameterContext = parameterContextDAO.getParameterContext(parameterContextId);
+        return createParameterContextEntity(parameterContext, user);
+    }
+
+    @Override
+    public Set<ParameterContextEntity> getParameterContexts() {
+        final NiFiUser user = NiFiUserUtils.getNiFiUser();
+
+        final Set<ParameterContextEntity> entities = parameterContextDAO.getParameterContexts().stream()
+            .map(context -> createParameterContextEntity(context, user))
+            .collect(Collectors.toSet());
+
+        return entities;
+    }
+
+    private ParameterContextEntity createParameterContextEntity(final ParameterContext parameterContext, final NiFiUser user) {
+        final PermissionsDTO permissions = dtoFactory.createPermissionsDto(parameterContext, user);
+        final RevisionDTO revisionDto = dtoFactory.createRevisionDTO(revisionManager.getRevision(parameterContext.getIdentifier()));
+        final ParameterContextDTO parameterContextDto = dtoFactory.createParameterContextDto(parameterContext, revisionManager);
+        final ParameterContextEntity entity = entityFactory.createParameterContextEntity(parameterContextDto, revisionDto, permissions);
+        return entity;
+    }
+
+    @Override
+    public List<ComponentValidationResultEntity> validateComponents(final ParameterContextDTO parameterContextDto, final NiFiUser nifiUser) {
+        final ParameterContext parameterContext = parameterContextDAO.getParameterContext(parameterContextDto.getId());
+        final Set<ProcessGroup> boundProcessGroups = parameterContext.getParameterReferenceManager().getProcessGroupsBound(parameterContext);
+
+        final ParameterContext updatedParameterContext = new StandardParameterContext(parameterContext.getIdentifier(), parameterContext.getName(), ParameterReferenceManager.EMPTY, null);
+        final Set<Parameter> parameters = parameterContextDto.getParameters().stream()
+            .map(ParameterEntity::getParameter)
+            .map(this::createParameter)
+            .collect(Collectors.toSet());
+        updatedParameterContext.setParameters(parameters);
+
+        final List<ComponentValidationResultEntity> validationResults = new ArrayList<>();
+        for (final ProcessGroup processGroup : boundProcessGroups) {
+            for (final ProcessorNode processorNode : processGroup.getProcessors()) {
+                if (!processorNode.isReferencingParameter()) {
+                    continue;
+                }
+
+                final ComponentValidationResultEntity componentValidationResultEntity = validateComponent(processorNode, updatedParameterContext, nifiUser);
+                validationResults.add(componentValidationResultEntity);
+            }
+
+            for (final ControllerServiceNode serviceNode : processGroup.getControllerServices(false)) {
+                if (!serviceNode.isReferencingParameter()) {
+                    continue;
+                }
+
+                final ComponentValidationResultEntity componentValidationResultEntity = validateComponent(serviceNode, updatedParameterContext, nifiUser);
+                validationResults.add(componentValidationResultEntity);
+            }
+        }
+
+        return validationResults;
+    }
+
+    private ComponentValidationResultEntity validateComponent(final ComponentNode componentNode, final ParameterContext parameterContext, final NiFiUser user) {
+        final ValidationState newState = componentNode.performValidation(componentNode.getProperties(), componentNode.getAnnotationData(), parameterContext);
+        final ComponentValidationResultDTO resultDto = dtoFactory.createComponentValidationResultDto(componentNode, newState);
+
+        final Revision revision = revisionManager.getRevision(componentNode.getIdentifier());
+        final PermissionsDTO permissions = dtoFactory.createPermissionsDto(componentNode, user);
+        final RevisionDTO revisionDto = dtoFactory.createRevisionDTO(revision);
+
+        final ComponentValidationResultEntity componentValidationResultEntity = entityFactory.createComponentValidationResultEntity(resultDto, revisionDto, permissions);
+        return componentValidationResultEntity;
+    }
+
+    private Parameter createParameter(final ParameterDTO dto) {
+        final ParameterDescriptor descriptor = new ParameterDescriptor.Builder()
+            .name(dto.getName())
+            .description(dto.getDescription())
+            .sensitive(Boolean.TRUE.equals(dto.getSensitive()))
+            .build();
+
+        return new Parameter(descriptor, dto.getValue());
+    }
+
+    @Override
+    public ParameterContextEntity createParameterContext(final Revision revision, final ParameterContextDTO parameterContextDto) {
+        final NiFiUser user = NiFiUserUtils.getNiFiUser();
+
+        // request claim for component to be created... revision already verified (version == 0)
+        final RevisionClaim claim = new StandardRevisionClaim(revision);
+
+        // update revision through revision manager
+        final RevisionUpdate<ParameterContextDTO> snapshot = revisionManager.updateRevision(claim, user, () -> {
+            // create the reporting task
+            final ParameterContext parameterContext = parameterContextDAO.createParameterContext(parameterContextDto);
+
+            // save the update
+            controllerFacade.save();
+
+            final ParameterContextDTO dto = dtoFactory.createParameterContextDto(parameterContext, revisionManager);
+            final FlowModification lastMod = new FlowModification(revision.incrementRevision(revision.getClientId()), user.getIdentity());
+            return new StandardRevisionUpdate<>(dto, lastMod);
+        });
+
+        final ParameterContext parameterContext = parameterContextDAO.getParameterContext(parameterContextDto.getId());
+        final PermissionsDTO permissions = dtoFactory.createPermissionsDto(parameterContext);
+
+        return entityFactory.createParameterContextEntity(snapshot.getComponent(), dtoFactory.createRevisionDTO(snapshot.getLastModification()), permissions);
+    }
+
+    @Override
+    public void verifyDeleteParameterContext(final String parameterContextId) {
+        parameterContextDAO.verifyDelete(parameterContextId);
+    }
+
+    @Override
+    public ParameterContextEntity deleteParameterContext(final Revision revision, final String parameterContextId) {
+        final ParameterContext parameterContext = parameterContextDAO.getParameterContext(parameterContextId);
+        final PermissionsDTO permissions = dtoFactory.createPermissionsDto(parameterContext);
+        final ParameterContextDTO snapshot = deleteComponent(
+            revision,
+            parameterContext.getResource(),
+            () -> parameterContextDAO.deleteParameterContext(parameterContextId),
+            true,
+            dtoFactory.createParameterContextDto(parameterContext, revisionManager));
+
+        return entityFactory.createParameterContextEntity(snapshot, null, permissions);
+
+    }
+
+
+    @Override
+    public Set<AffectedComponentEntity> getProcessorsReferencingParameter(final String groupId) {
+        return getComponentsReferencingParameter(groupId, ProcessGroup::getProcessors);
+    }
+
+    @Override
+    public Set<AffectedComponentEntity> getControllerServicesReferencingParameter(String groupId) {
+        return getComponentsReferencingParameter(groupId, group -> group.getControllerServices(false));
+    }
+
+    private Set<AffectedComponentEntity> getComponentsReferencingParameter(final String groupId, final Function<ProcessGroup, Collection<? extends ComponentNode>> componentFunction) {
+        final ProcessGroup group = processGroupDAO.getProcessGroup(groupId);
+        final Set<ComponentNode> affectedComponents = new HashSet<>();
+
+        componentFunction.apply(group).stream()
+            .filter(ComponentNode::isReferencingParameter)
+            .forEach(affectedComponents::add);
+
+        return dtoFactory.createAffectedComponentEntities(affectedComponents, revisionManager);
+    }
+
+    @Override
+    public Set<AffectedComponentEntity> getComponentsAffectedByParameterContextUpdate(final ParameterContextDTO parameterContextDto) {
+        return getComponentsAffectedByParameterContextUpdate(parameterContextDto, true);
+    }
+
+    private Set<AffectedComponentEntity> getComponentsAffectedByParameterContextUpdate(final ParameterContextDTO parameterContextDto, final boolean includeInactive) {
+        final ProcessGroup rootGroup = processGroupDAO.getProcessGroup("root");
+        final List<ProcessGroup> groupsReferencingParameterContext = rootGroup.findAllProcessGroups(
+            group -> group.getParameterContext() != null && group.getParameterContext().getIdentifier().equals(parameterContextDto.getId()));
+
+        final Set<String> updatedParameterNames = getUpdatedParameterNames(parameterContextDto);
+
+        // Clear set of Affected Components for each Parameter. This parameter is read-only and it will be populated below.
+        for (final ParameterEntity parameterEntity : parameterContextDto.getParameters()) {
+            parameterEntity.getParameter().setReferencingComponents(new HashSet<>());
+        }
+
+        final Set<ComponentNode> affectedComponents = new HashSet<>();
+        for (final ProcessGroup group : groupsReferencingParameterContext) {
+            for (final ProcessorNode processor : group.getProcessors()) {
+                if (includeInactive || processor.isRunning()) {
+                    final Set<String> referencedParams = processor.getReferencedParameterNames();
+                    final boolean referencesUpdatedParam = referencedParams.stream().anyMatch(updatedParameterNames::contains);
+
+                    if (referencesUpdatedParam) {
+                        affectedComponents.add(processor);
+
+                        final AffectedComponentEntity affectedComponentEntity = dtoFactory.createAffectedComponentEntity(processor, revisionManager);
+
+                        for (final String referencedParam : referencedParams) {
+                            for (final ParameterEntity paramEntity : parameterContextDto.getParameters()) {
+                                final ParameterDTO paramDto = paramEntity.getParameter();
+                                if (referencedParam.equals(paramDto.getName())) {
+                                    paramDto.getReferencingComponents().add(affectedComponentEntity);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            for (final ControllerServiceNode service : group.getControllerServices(false)) {
+                if (includeInactive || service.isActive()) {
+                    final Set<String> referencedParams = service.getReferencedParameterNames();
+                    final boolean referencesUpdatedParam = referencedParams.stream().anyMatch(updatedParameterNames::contains);
+
+                    if (referencesUpdatedParam) {
+                        affectedComponents.add(service);
+
+                        final AffectedComponentEntity affectedComponentEntity = dtoFactory.createAffectedComponentEntity(service, revisionManager);
+
+                        for (final String referencedParam : referencedParams) {
+                            for (final ParameterEntity paramEntity : parameterContextDto.getParameters()) {
+                                final ParameterDTO paramDto = paramEntity.getParameter();
+                                if (referencedParam.equals(paramDto.getName())) {
+                                    paramDto.getReferencingComponents().add(affectedComponentEntity);
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return dtoFactory.createAffectedComponentEntities(affectedComponents, revisionManager);
+    }
+
+    private Set<String> getUpdatedParameterNames(final ParameterContextDTO parameterContextDto) {
+        final ParameterContext parameterContext = parameterContextDAO.getParameterContext(parameterContextDto.getId());
+
+        final Set<String> updatedParameters = new HashSet<>();
+        for (final ParameterEntity parameterEntity : parameterContextDto.getParameters()) {
+            final ParameterDTO parameterDto = parameterEntity.getParameter();
+            final String updatedValue = parameterDto.getValue();
+            final String parameterName = parameterDto.getName();
+
+            final Optional<Parameter> parameterOption = parameterContext.getParameter(parameterName);
+            if (!parameterOption.isPresent()) {
+                updatedParameters.add(parameterName);
+                continue;
+            }
+
+            final Parameter parameter = parameterOption.get();
+            final boolean updated = !Objects.equals(updatedValue, parameter.getValue());
+            if (updated) {
+                updatedParameters.add(parameterName);
+            }
+        }
+
+        return updatedParameters;
+    }
+
 
     @Override
     public ProcessGroupEntity updateProcessGroup(final Revision revision, final ProcessGroupDTO processGroupDTO) {
@@ -1958,8 +2240,8 @@ public void verifyCanAddTemplate(String groupId, String name) {
     }
 
     @Override
-    public void verifyComponentTypes(FlowSnippetDTO snippet) {
-        templateDAO.verifyComponentTypes(snippet);
+    public void verifyCanInstantiate(final String groupId, final FlowSnippetDTO snippetDTO) {
+        templateDAO.verifyCanInstantiate(groupId, snippetDTO);
     }
 
     @Override
@@ -3881,17 +4163,20 @@ public StatusHistoryEntity getProcessGroupStatusHistory(final String groupId) {
     public VersionControlComponentMappingEntity registerFlowWithFlowRegistry(final String groupId, final StartVersionControlRequestEntity requestEntity) {
         final VersionedFlowDTO versionedFlowDto = requestEntity.getVersionedFlow();
 
+        final ProcessGroup processGroup = processGroupDAO.getProcessGroup(groupId);
+
         int snapshotVersion;
         if (VersionedFlowDTO.FORCE_COMMIT_ACTION.equals(versionedFlowDto.getAction())) {
             snapshotVersion = -1;
         } else {
-            final ProcessGroup processGroup = processGroupDAO.getProcessGroup(groupId);
             final VersionControlInformation currentVci = processGroup.getVersionControlInformation();
             snapshotVersion = currentVci == null ? 1 : currentVci.getVersion() + 1;
         }
 
         // Create a VersionedProcessGroup snapshot of the flow as it is currently.
         final InstantiatedVersionedProcessGroup versionedProcessGroup = createFlowSnapshot(groupId);
+        final Collection<VersionedParameterContext> parameterContexts = createVersionedParameterContexts(processGroup);
+
         final String flowId = versionedFlowDto.getFlowId() == null ? UUID.randomUUID().toString() : versionedFlowDto.getFlowId();
 
         final VersionedFlow versionedFlow = new VersionedFlow();
@@ -3923,7 +4208,7 @@ public VersionControlComponentMappingEntity registerFlowWithFlowRegistry(final S
 
         try {
             // add a snapshot to the flow in the registry
-            registeredSnapshot = registerVersionedFlowSnapshot(registryId, registeredFlow, versionedProcessGroup, versionedProcessGroup.getExternalControllerServiceReferences(),
+            registeredSnapshot = registerVersionedFlowSnapshot(registryId, registeredFlow, versionedProcessGroup, parameterContexts, versionedProcessGroup.getExternalControllerServiceReferences(),
                 versionedFlowDto.getComments(), snapshotVersion);
         } catch (final NiFiCoreException e) {
             // If the flow has been created, but failed to add a snapshot,
@@ -4015,6 +4300,27 @@ private InstantiatedVersionedProcessGroup createFlowSnapshot(final String proces
         return versionedGroup;
     }
 
+    private Collection<VersionedParameterContext> createVersionedParameterContexts(final ProcessGroup processGroup) {
+        final NiFiRegistryFlowMapper mapper = new NiFiRegistryFlowMapper(controllerFacade.getExtensionManager());
+        final Collection<VersionedParameterContext> parameterContexts = new ArrayList<>();
+        createVersionedParameterContexts(processGroup, mapper, parameterContexts);
+        return parameterContexts;
+    }
+
+    private void createVersionedParameterContexts(final ProcessGroup processGroup, final NiFiRegistryFlowMapper mapper, final Collection<VersionedParameterContext> contextCollection) {
+        final ParameterContext parameterContext = processGroup.getParameterContext();
+        if (parameterContext != null) {
+            final VersionedParameterContext versionedContext = mapper.mapParameterContext(processGroup.getParameterContext());
+            contextCollection.add(versionedContext);
+        }
+
+        for (final ProcessGroup child : processGroup.getProcessGroups()) {
+            if (child.getVersionControlInformation() == null) {
+                createVersionedParameterContexts(child, mapper, contextCollection);
+            }
+        }
+    }
+
     @Override
     public FlowComparisonEntity getLocalModifications(final String processGroupId) {
         final ProcessGroup processGroup = processGroupDAO.getProcessGroup(processGroupId);
@@ -4105,6 +4411,7 @@ private VersionedFlow getVersionedFlow(final String registryId, final String buc
 
     @Override
     public VersionedFlowSnapshot registerVersionedFlowSnapshot(final String registryId, final VersionedFlow flow, final VersionedProcessGroup snapshot,
+                                                               final Collection<VersionedParameterContext> parameterContexts,
                                                                final Map<String, ExternalControllerServiceReference> externalControllerServiceReferences, final String comments,
                                                                final int expectedVersion) {
         final FlowRegistry registry = flowRegistryClient.getFlowRegistry(registryId);
@@ -4113,7 +4420,7 @@ public VersionedFlowSnapshot registerVersionedFlowSnapshot(final String registry
         }
 
         try {
-            return registry.registerVersionedFlowSnapshot(flow, snapshot, externalControllerServiceReferences, comments, expectedVersion, NiFiUserUtils.getNiFiUser());
+            return registry.registerVersionedFlowSnapshot(flow, snapshot, externalControllerServiceReferences, parameterContexts, comments, expectedVersion, NiFiUserUtils.getNiFiUser());
         } catch (final IOException | NiFiRegistryException e) {
             throw new NiFiCoreException("Failed to register flow with Flow Registry due to " + e.getMessage(), e);
         }
@@ -4585,6 +4892,7 @@ public RevisionUpdate<ProcessGroupDTO> update() {
         return entityFactory.createProcessGroupEntity(revisionUpdate.getComponent(), updatedRevision, permissions, status, bulletinEntities);
     }
 
+
     private AuthorizationResult authorizeAction(final Action action) {
         final String sourceId = action.getSourceId();
         final Component type = action.getSourceType();
@@ -5012,6 +5320,10 @@ public void setReportingTaskDAO(final ReportingTaskDAO reportingTaskDAO) {
         this.reportingTaskDAO = reportingTaskDAO;
     }
 
+    public void setParameterContextDAO(final ParameterContextDAO parameterContextDAO) {
+        this.parameterContextDAO = parameterContextDAO;
+    }
+
     public void setTemplateDAO(final TemplateDAO templateDAO) {
         this.templateDAO = templateDAO;
     }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ApplicationResource.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ApplicationResource.java
index 3794ee3d699..1a733505448 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ApplicationResource.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ApplicationResource.java
@@ -22,6 +22,7 @@
 import org.apache.nifi.authorization.AuthorizableLookup;
 import org.apache.nifi.authorization.AuthorizeAccess;
 import org.apache.nifi.authorization.AuthorizeControllerServiceReference;
+import org.apache.nifi.authorization.AuthorizeParameterReference;
 import org.apache.nifi.authorization.Authorizer;
 import org.apache.nifi.authorization.ComponentAuthorizable;
 import org.apache.nifi.authorization.ProcessGroupAuthorizable;
@@ -521,9 +522,11 @@ protected void authorizeRestrictions(final Authorizer authorizer, final Componen
      */
     protected void authorizeProcessGroup(final ProcessGroupAuthorizable processGroupAuthorizable, final Authorizer authorizer, final AuthorizableLookup lookup, final RequestAction action,
                                          final boolean authorizeReferencedServices, final boolean authorizeTemplates,
-                                         final boolean authorizeControllerServices, final boolean authorizeTransitiveServices) {
+                                         final boolean authorizeControllerServices, final boolean authorizeTransitiveServices,
+                                         final boolean authorizeParamterReferences) {
 
-        final Consumer<Authorizable> authorize = authorizable -> authorizable.authorize(authorizer, action, NiFiUserUtils.getNiFiUser());
+        final NiFiUser user = NiFiUserUtils.getNiFiUser();
+        final Consumer<Authorizable> authorize = authorizable -> authorizable.authorize(authorizer, action, user);
 
         // authorize the process group
         authorize.accept(processGroupAuthorizable.getAuthorizable());
@@ -537,6 +540,11 @@ protected void authorizeProcessGroup(final ProcessGroupAuthorizable processGroup
             if (authorizeReferencedServices) {
                 AuthorizeControllerServiceReference.authorizeControllerServiceReferences(processorAuthorizable, authorizer, lookup, authorizeTransitiveServices);
             }
+
+            // authorize any referenced parameters if necessary
+            if (authorizeParamterReferences) {
+                AuthorizeParameterReference.authorizeParameterReferences(processorAuthorizable, authorizer, processorAuthorizable.getParameterContext(), user);
+            }
         });
         processGroupAuthorizable.getEncapsulatedConnections().stream().map(connection -> connection.getAuthorizable()).forEach(authorize);
         processGroupAuthorizable.getEncapsulatedInputPorts().forEach(authorize);
@@ -561,6 +569,10 @@ protected void authorizeProcessGroup(final ProcessGroupAuthorizable processGroup
                 if (authorizeReferencedServices) {
                     AuthorizeControllerServiceReference.authorizeControllerServiceReferences(controllerServiceAuthorizable, authorizer, lookup, authorizeTransitiveServices);
                 }
+
+                if (authorizeParamterReferences) {
+                    AuthorizeParameterReference.authorizeParameterReferences(controllerServiceAuthorizable, authorizer, controllerServiceAuthorizable.getParameterContext(), user);
+                }
             });
         }
     }
@@ -573,18 +585,20 @@ protected void authorizeProcessGroup(final ProcessGroupAuthorizable processGroup
      * @param action     action
      */
     protected void authorizeSnippet(final SnippetAuthorizable snippet, final Authorizer authorizer, final AuthorizableLookup lookup, final RequestAction action,
-                                    final boolean authorizeReferencedServices, final boolean authorizeTransitiveServices) {
+                                    final boolean authorizeReferencedServices, final boolean authorizeTransitiveServices, final boolean authorizeParameterReferences) {
 
-        final Consumer<Authorizable> authorize = authorizable -> authorizable.authorize(authorizer, action, NiFiUserUtils.getNiFiUser());
+        final NiFiUser user = NiFiUserUtils.getNiFiUser();
+        final Consumer<Authorizable> authorize = authorizable -> authorizable.authorize(authorizer, action, user);
 
         // authorize each component in the specified snippet
-        snippet.getSelectedProcessGroups().stream().forEach(processGroupAuthorizable -> {
+        snippet.getSelectedProcessGroups().forEach(processGroupAuthorizable -> {
             // note - we are not authorizing templates or controller services as they are not considered when using this snippet. however,
             // referenced services are considered so those are explicitly authorized when authorizing a processor
-            authorizeProcessGroup(processGroupAuthorizable, authorizer, lookup, action, authorizeReferencedServices, false, false, authorizeTransitiveServices);
+            authorizeProcessGroup(processGroupAuthorizable, authorizer, lookup, action, authorizeReferencedServices,
+                    false, false, authorizeTransitiveServices, authorizeParameterReferences);
         });
-        snippet.getSelectedRemoteProcessGroups().stream().forEach(authorize);
-        snippet.getSelectedProcessors().stream().forEach(processorAuthorizable -> {
+        snippet.getSelectedRemoteProcessGroups().forEach(authorize);
+        snippet.getSelectedProcessors().forEach(processorAuthorizable -> {
             // authorize the processor
             authorize.accept(processorAuthorizable.getAuthorizable());
 
@@ -592,12 +606,17 @@ protected void authorizeSnippet(final SnippetAuthorizable snippet, final Authori
             if (authorizeReferencedServices) {
                 AuthorizeControllerServiceReference.authorizeControllerServiceReferences(processorAuthorizable, authorizer, lookup, authorizeTransitiveServices);
             }
+
+            // authorize any parameter usage
+            if (authorizeParameterReferences) {
+                AuthorizeParameterReference.authorizeParameterReferences(processorAuthorizable, authorizer, processorAuthorizable.getParameterContext(), user);
+            }
         });
-        snippet.getSelectedInputPorts().stream().forEach(authorize);
-        snippet.getSelectedOutputPorts().stream().forEach(authorize);
-        snippet.getSelectedConnections().stream().forEach(connAuth -> authorize.accept(connAuth.getAuthorizable()));
-        snippet.getSelectedFunnels().stream().forEach(authorize);
-        snippet.getSelectedLabels().stream().forEach(authorize);
+        snippet.getSelectedInputPorts().forEach(authorize);
+        snippet.getSelectedOutputPorts().forEach(authorize);
+        snippet.getSelectedConnections().forEach(connAuth -> authorize.accept(connAuth.getAuthorizable()));
+        snippet.getSelectedFunnels().forEach(authorize);
+        snippet.getSelectedLabels().forEach(authorize);
     }
 
     /**
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ControllerServiceResource.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ControllerServiceResource.java
index 668feba484a..2cd9299459c 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ControllerServiceResource.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ControllerServiceResource.java
@@ -24,6 +24,7 @@
 import io.swagger.annotations.Authorization;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.nifi.authorization.AuthorizeControllerServiceReference;
+import org.apache.nifi.authorization.AuthorizeParameterReference;
 import org.apache.nifi.authorization.Authorizer;
 import org.apache.nifi.authorization.ComponentAuthorizable;
 import org.apache.nifi.authorization.RequestAction;
@@ -635,6 +636,8 @@ public Response updateControllerService(
 
                     // authorize any referenced services
                     AuthorizeControllerServiceReference.authorizeControllerServiceReferences(requestControllerServiceDTO.getProperties(), authorizable, authorizer, lookup);
+                        AuthorizeParameterReference.authorizeParameterReferences(requestControllerServiceDTO.getProperties(), authorizer, authorizable.getParameterContext(),
+                            NiFiUserUtils.getNiFiUser());
                 },
                 () -> serviceFacade.verifyUpdateControllerService(requestControllerServiceDTO),
                 (revision, controllerServiceEntity) -> {
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/FlowResource.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/FlowResource.java
index 4f94d989296..4b34f3982b4 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/FlowResource.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/FlowResource.java
@@ -35,9 +35,9 @@
 import org.apache.nifi.cluster.coordination.node.NodeConnectionState;
 import org.apache.nifi.cluster.manager.NodeResponse;
 import org.apache.nifi.cluster.protocol.NodeIdentifier;
+import org.apache.nifi.components.validation.ValidationStatus;
 import org.apache.nifi.connectable.Port;
 import org.apache.nifi.controller.ProcessorNode;
-import org.apache.nifi.components.validation.ValidationStatus;
 import org.apache.nifi.controller.ScheduledState;
 import org.apache.nifi.controller.service.ControllerServiceNode;
 import org.apache.nifi.controller.service.ControllerServiceState;
@@ -84,6 +84,8 @@
 import org.apache.nifi.web.api.entity.CurrentUserEntity;
 import org.apache.nifi.web.api.entity.FlowConfigurationEntity;
 import org.apache.nifi.web.api.entity.HistoryEntity;
+import org.apache.nifi.web.api.entity.ParameterContextEntity;
+import org.apache.nifi.web.api.entity.ParameterContextsEntity;
 import org.apache.nifi.web.api.entity.PortStatusEntity;
 import org.apache.nifi.web.api.entity.PrioritizerTypesEntity;
 import org.apache.nifi.web.api.entity.ProcessGroupEntity;
@@ -2260,6 +2262,44 @@ public Response getConnectionStatusHistory(
         return generateOkResponse(entity).build();
     }
 
+
+    @GET
+    @Consumes(MediaType.WILDCARD)
+    @Produces(MediaType.APPLICATION_JSON)
+    @Path("parameter-contexts")
+    @ApiOperation(
+        value = "Gets all Parameter Contexts",
+        response = ParameterContextsEntity.class,
+        authorizations = {
+            @Authorization(value = "Read - /parameter-contexts/{id} for each Parameter Context")
+        }
+    )
+    @ApiResponses(
+        value = {
+            @ApiResponse(code = 400, message = "NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."),
+            @ApiResponse(code = 401, message = "Client could not be authenticated."),
+            @ApiResponse(code = 403, message = "Client is not authorized to make this request."),
+            @ApiResponse(code = 409, message = "The request was valid but NiFi was not in the appropriate state to process it. Retrying the same request later may be successful.")
+        }
+    )
+    public Response getParameterContexts() {
+        authorizeFlow();
+
+        if (isReplicateRequest()) {
+            return replicate(HttpMethod.GET);
+        }
+
+        final Set<ParameterContextEntity> parameterContexts = serviceFacade.getParameterContexts();
+        final ParameterContextsEntity entity = new ParameterContextsEntity();
+        entity.setParameterContexts(parameterContexts);
+        entity.setCurrentTime(new Date());
+
+        // generate the response
+        return generateOkResponse(entity).build();
+    }
+
+
+
     // -------
     // history
     // -------
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ParameterContextResource.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ParameterContextResource.java
new file mode 100644
index 00000000000..9a0805def78
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ParameterContextResource.java
@@ -0,0 +1,1249 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api;
+
+import io.swagger.annotations.Api;
+import io.swagger.annotations.ApiOperation;
+import io.swagger.annotations.ApiParam;
+import io.swagger.annotations.ApiResponse;
+import io.swagger.annotations.ApiResponses;
+import io.swagger.annotations.Authorization;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.nifi.authorization.AuthorizableLookup;
+import org.apache.nifi.authorization.Authorizer;
+import org.apache.nifi.authorization.RequestAction;
+import org.apache.nifi.authorization.resource.Authorizable;
+import org.apache.nifi.authorization.user.NiFiUser;
+import org.apache.nifi.authorization.user.NiFiUserUtils;
+import org.apache.nifi.cluster.manager.NodeResponse;
+import org.apache.nifi.controller.ScheduledState;
+import org.apache.nifi.controller.service.ControllerServiceState;
+import org.apache.nifi.web.NiFiServiceFacade;
+import org.apache.nifi.web.ResourceNotFoundException;
+import org.apache.nifi.web.ResumeFlowException;
+import org.apache.nifi.web.Revision;
+import org.apache.nifi.web.api.concurrent.AsyncRequestManager;
+import org.apache.nifi.web.api.concurrent.AsynchronousWebRequest;
+import org.apache.nifi.web.api.concurrent.RequestManager;
+import org.apache.nifi.web.api.concurrent.StandardAsynchronousWebRequest;
+import org.apache.nifi.web.api.concurrent.StandardUpdateStep;
+import org.apache.nifi.web.api.concurrent.UpdateStep;
+import org.apache.nifi.web.api.dto.AffectedComponentDTO;
+import org.apache.nifi.web.api.dto.DtoFactory;
+import org.apache.nifi.web.api.dto.ParameterContextDTO;
+import org.apache.nifi.web.api.dto.ParameterContextUpdateRequestDTO;
+import org.apache.nifi.web.api.dto.ParameterContextUpdateStepDTO;
+import org.apache.nifi.web.api.dto.ParameterContextValidationRequestDTO;
+import org.apache.nifi.web.api.dto.ParameterDTO;
+import org.apache.nifi.web.api.dto.RevisionDTO;
+import org.apache.nifi.web.api.entity.AffectedComponentEntity;
+import org.apache.nifi.web.api.entity.ComponentValidationResultEntity;
+import org.apache.nifi.web.api.entity.ComponentValidationResultsEntity;
+import org.apache.nifi.web.api.entity.Entity;
+import org.apache.nifi.web.api.entity.ParameterContextEntity;
+import org.apache.nifi.web.api.entity.ParameterContextUpdateRequestEntity;
+import org.apache.nifi.web.api.entity.ParameterContextValidationRequestEntity;
+import org.apache.nifi.web.api.entity.ParameterEntity;
+import org.apache.nifi.web.api.entity.ProcessGroupEntity;
+import org.apache.nifi.web.api.request.ClientIdParameter;
+import org.apache.nifi.web.api.request.LongParameter;
+import org.apache.nifi.web.util.AffectedComponentUtils;
+import org.apache.nifi.web.util.CancellableTimedPause;
+import org.apache.nifi.web.util.ComponentLifecycle;
+import org.apache.nifi.web.util.InvalidComponentAction;
+import org.apache.nifi.web.util.LifecycleManagementException;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import javax.ws.rs.Consumes;
+import javax.ws.rs.DELETE;
+import javax.ws.rs.DefaultValue;
+import javax.ws.rs.GET;
+import javax.ws.rs.HttpMethod;
+import javax.ws.rs.POST;
+import javax.ws.rs.PUT;
+import javax.ws.rs.Path;
+import javax.ws.rs.PathParam;
+import javax.ws.rs.Produces;
+import javax.ws.rs.QueryParam;
+import javax.ws.rs.core.MediaType;
+import javax.ws.rs.core.Response;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.TimeUnit;
+import java.util.function.Consumer;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+
+@Path("/parameter-contexts")
+@Api(value = "/parameter-contexts", description = "Endpoint for managing version control for a flow")
+public class ParameterContextResource extends ApplicationResource {
+    private static final Logger logger = LoggerFactory.getLogger(ParameterContextResource.class);
+    private static final Pattern VALID_PARAMETER_NAME_PATTERN = Pattern.compile("[A-Za-z0-9 ._\\-]+");
+
+    private NiFiServiceFacade serviceFacade;
+    private Authorizer authorizer;
+    private DtoFactory dtoFactory;
+    private ComponentLifecycle clusterComponentLifecycle;
+    private ComponentLifecycle localComponentLifecycle;
+
+    private RequestManager<ParameterContextEntity, ParameterContextEntity> updateRequestManager = new AsyncRequestManager<>(100, TimeUnit.MINUTES.toMillis(1L), "Parameter Context Update Thread");
+    private RequestManager<ParameterContextValidationRequestEntity, ComponentValidationResultsEntity> validationRequestManager = new AsyncRequestManager<>(100, TimeUnit.MINUTES.toMillis(1L),
+        "Parameter Context Validation Thread");
+
+
+
+    private void authorizeReadParameterContext(final String parameterContextId) {
+        if (parameterContextId == null) {
+            throw new IllegalArgumentException("Parameter Context ID must be specified");
+        }
+
+        serviceFacade.authorizeAccess(lookup -> {
+            final Authorizable parameterContext = lookup.getParameterContext(parameterContextId);
+            parameterContext.authorize(authorizer, RequestAction.READ, NiFiUserUtils.getNiFiUser());
+        });
+    }
+
+    @GET
+    @Consumes(MediaType.WILDCARD)
+    @Produces(MediaType.APPLICATION_JSON)
+    @Path("{id}")
+    @ApiOperation(
+        value = "Returns the Parameter Context with the given ID",
+        response = ParameterContextEntity.class,
+        notes = "Returns the Parameter Context with the given ID.",
+        authorizations = {
+            @Authorization(value = "Read - /parameter-contexts/{id}")
+        })
+    @ApiResponses(value = {
+        @ApiResponse(code = 400, message = "NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."),
+        @ApiResponse(code = 401, message = "Client could not be authenticated."),
+        @ApiResponse(code = 403, message = "Client is not authorized to make this request."),
+        @ApiResponse(code = 404, message = "The specified resource could not be found."),
+        @ApiResponse(code = 409, message = "The request was valid but NiFi was not in the appropriate state to process it. Retrying the same request later may be successful.")
+    })
+    public Response getParameterContext(@ApiParam("The ID of the Parameter Context") @PathParam("id") final String parameterContextId) {
+        // authorize access
+        authorizeReadParameterContext(parameterContextId);
+
+        if (isReplicateRequest()) {
+            return replicate(HttpMethod.GET);
+        }
+
+        // get the specified parameter context
+        final ParameterContextEntity entity = serviceFacade.getParameterContext(parameterContextId, NiFiUserUtils.getNiFiUser());
+        entity.setUri(generateResourceUri("parameter-contexts", entity.getId()));
+
+        // generate the response
+        return generateOkResponse(entity).build();
+    }
+
+
+    @POST
+    @Consumes(MediaType.APPLICATION_JSON)
+    @Produces(MediaType.APPLICATION_JSON)
+    @ApiOperation(
+        value = "Create a Parameter Context",
+        response = ParameterContextEntity.class,
+        authorizations = {
+            @Authorization(value = "Write - /parameter-contexts")
+        })
+    @ApiResponses(value = {
+        @ApiResponse(code = 400, message = "NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."),
+        @ApiResponse(code = 401, message = "Client could not be authenticated."),
+        @ApiResponse(code = 403, message = "Client is not authorized to make this request."),
+        @ApiResponse(code = 404, message = "The specified resource could not be found."),
+        @ApiResponse(code = 409, message = "The request was valid but NiFi was not in the appropriate state to process it. Retrying the same request later may be successful.")
+    })
+    public Response createParameterContext(
+        @ApiParam(value = "The Parameter Context.", required = true) final ParameterContextEntity requestEntity) {
+
+        if (requestEntity == null || requestEntity.getComponent() == null) {
+            throw new IllegalArgumentException("Parameter Context must be specified");
+        }
+
+        if (requestEntity.getRevision() == null || (requestEntity.getRevision().getVersion() == null || requestEntity.getRevision().getVersion() != 0)) {
+            throw new IllegalArgumentException("A revision of 0 must be specified when creating a new Parameter Context.");
+        }
+
+        final ParameterContextDTO context = requestEntity.getComponent();
+        if (context.getName() == null) {
+            throw new IllegalArgumentException("Parameter Context's Name must be specified");
+        }
+
+        validateParameterNames(requestEntity.getComponent());
+
+        if (isReplicateRequest()) {
+            return replicate(HttpMethod.POST, requestEntity);
+        } else if (isDisconnectedFromCluster()) {
+            verifyDisconnectedNodeModification(requestEntity.isDisconnectedNodeAcknowledged());
+        }
+
+        return withWriteLock(
+            serviceFacade,
+            requestEntity,
+            lookup -> {
+                final Authorizable parameterContexts = lookup.getParameterContexts();
+                parameterContexts.authorize(authorizer, RequestAction.WRITE, NiFiUserUtils.getNiFiUser());
+            },
+            () -> serviceFacade.verifyCreateParameterContext(requestEntity.getComponent()),
+            entity -> {
+                final String contextId = generateUuid();
+                entity.getComponent().setId(contextId);
+
+                final Revision revision = getRevision(entity.getRevision(), contextId);
+                final ParameterContextEntity contextEntity = serviceFacade.createParameterContext(revision, entity.getComponent());
+
+                // generate a 201 created response
+                final String uri = generateResourceUri("parameter-contexts", contextEntity.getId());
+                contextEntity.setUri(uri);
+                return generateCreatedResponse(URI.create(uri), contextEntity).build();
+            });
+    }
+
+
+    @PUT
+    @Consumes(MediaType.APPLICATION_JSON)
+    @Produces(MediaType.APPLICATION_JSON)
+    @Path("{id}")
+    @ApiOperation(
+        value = "Modifies a Parameter Context",
+        response = ParameterContextEntity.class,
+        notes = "This endpoint will update a Parameter Context to match the provided entity. However, this request will fail if any component is running and is referencing a Parameter in the " +
+            "Parameter Context. Generally, this endpoint is not called directly. Instead, an update request should be submitted by making a POST to the " +
+            "/parameter-contexts/update-requests endpoint. That endpoint will, in turn, call this endpoint.",
+        authorizations = {
+            @Authorization(value = "Read - /parameter-contexts/{id}"),
+            @Authorization(value = "Write - /parameter-contexts/{id}")
+        }
+    )
+    @ApiResponses(value = {
+        @ApiResponse(code = 400, message = "NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."),
+        @ApiResponse(code = 401, message = "Client could not be authenticated."),
+        @ApiResponse(code = 403, message = "Client is not authorized to make this request."),
+        @ApiResponse(code = 404, message = "The specified resource could not be found."),
+        @ApiResponse(code = 409, message = "The request was valid but NiFi was not in the appropriate state to process it. Retrying the same request later may be successful.")
+    })
+    public Response updateParameterContext(
+        @PathParam("id") String contextId,
+        @ApiParam(value = "The updated Parameter Context", required = true) ParameterContextEntity requestEntity) {
+
+        // Validate request
+        if (requestEntity.getId() == null) {
+            throw new IllegalArgumentException("The ID of the Parameter Context must be specified");
+        }
+        if (!requestEntity.getId().equals(contextId)) {
+            throw new IllegalArgumentException("The ID of the Parameter Context must match the ID specified in the URL's path");
+        }
+
+        final ParameterContextDTO updateDto = requestEntity.getComponent();
+        if (updateDto == null) {
+            throw new IllegalArgumentException("The Parameter Context must be supplied");
+        }
+
+        final RevisionDTO revisionDto = requestEntity.getRevision();
+        if (revisionDto == null) {
+            throw new IllegalArgumentException("The Revision of the Parameter Context must be specified.");
+        }
+
+        // Perform the request
+        if (isReplicateRequest()) {
+            return replicate(HttpMethod.PUT, requestEntity);
+        } else if (isDisconnectedFromCluster()) {
+            verifyDisconnectedNodeModification(requestEntity.isDisconnectedNodeAcknowledged());
+        }
+
+        final Revision requestRevision = getRevision(requestEntity.getRevision(), updateDto.getId());
+        return withWriteLock(
+            serviceFacade,
+            requestEntity,
+            requestRevision,
+            lookup -> {
+                final Authorizable parameterContext = lookup.getParameterContext(contextId);
+                parameterContext.authorize(authorizer, RequestAction.READ, NiFiUserUtils.getNiFiUser());
+                parameterContext.authorize(authorizer, RequestAction.WRITE, NiFiUserUtils.getNiFiUser());
+            },
+            () -> serviceFacade.verifyUpdateParameterContext(updateDto, true),
+            (rev, entity) -> {
+                final ParameterContextEntity updatedEntity = serviceFacade.updateParameterContext(rev, entity.getComponent());
+
+                updatedEntity.setUri(generateResourceUri("parameter-contexts", entity.getId()));
+                return generateOkResponse(updatedEntity).build();
+            }
+        );
+    }
+
+
+    @POST
+    @Consumes(MediaType.APPLICATION_JSON)
+    @Produces(MediaType.APPLICATION_JSON)
+    @Path("{contextId}/update-requests")
+    @ApiOperation(
+        value = "Initiate the Update Request of a Parameter Context",
+        response = ParameterContextUpdateRequestEntity.class,
+        notes = "This will initiate the process of updating a Parameter Context. Changing the value of a Parameter may require that one or more components be stopped and " +
+            "restarted, so this acttion may take significantly more time than many other REST API actions. As a result, this endpoint will immediately return a ParameterContextUpdateRequestEntity, " +
+            "and the process of updating the necessary components will occur asynchronously in the background. The client may then periodically poll the status of the request by " +
+            "issuing a GET request to /parameter-contexts/update-requests/{requestId}. Once the request is completed, the client is expected to issue a DELETE request to " +
+            "/parameter-contexts/update-requests/{requestId}.",
+        authorizations = {
+            @Authorization(value = "Read - /parameter-contexts/{parameterContextId}"),
+            @Authorization(value = "Write - /parameter-contexts/{parameterContextId}"),
+            @Authorization(value = "Read - for every component that is affected by the update"),
+            @Authorization(value = "Write - for every component that is affected by the update")
+        })
+    @ApiResponses(value = {
+        @ApiResponse(code = 400, message = "NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."),
+        @ApiResponse(code = 401, message = "Client could not be authenticated."),
+        @ApiResponse(code = 403, message = "Client is not authorized to make this request."),
+        @ApiResponse(code = 404, message = "The specified resource could not be found."),
+        @ApiResponse(code = 409, message = "The request was valid but NiFi was not in the appropriate state to process it. Retrying the same request later may be successful.")
+    })
+    public Response submitParameterContextUpdate(
+        @PathParam("contextId") final String contextId,
+        @ApiParam(value = "The updated version of the parameter context.", required = true) final ParameterContextEntity requestEntity) {
+
+        // Verify the request
+        final RevisionDTO revisionDto = requestEntity.getRevision();
+        if (revisionDto == null) {
+            throw new IllegalArgumentException("Parameter Context Revision must be specified");
+        }
+
+        final ParameterContextDTO contextDto = requestEntity.getComponent();
+        if (contextDto == null) {
+            throw new IllegalArgumentException("Parameter Context must be specified");
+        }
+
+        if (contextDto.getId() == null) {
+            throw new IllegalArgumentException("Parameter Context's ID must be specified");
+        }
+        if (!contextDto.getId().equals(contextId)) {
+            throw new IllegalArgumentException("ID of Parameter Context in message body does not match Parameter Context ID supplied in URI");
+        }
+
+        validateParameterNames(contextDto);
+
+        // We will perform the updating of the Parameter Context in a background thread because it can be a long-running process.
+        // In order to do this, we will need some objects that are only available as Thread-Local variables to the current
+        // thread, so we will gather the values for these objects up front.
+        final boolean replicateRequest = isReplicateRequest();
+        final ComponentLifecycle componentLifecycle = replicateRequest ? clusterComponentLifecycle : localComponentLifecycle;
+        final NiFiUser user = NiFiUserUtils.getNiFiUser();
+
+        // Workflow for this process:
+        // 1. Determine which components will be affected and are enabled/running
+        // 2. Verify READ and WRITE permissions for user, for every component that is affected
+        // 3. Verify READ and WRITE permissions for user, for Parameter Context
+        // 4. Stop all Processors that are affected.
+        // 5. Wait for all of the Processors to finish stopping.
+        // 6. Disable all Controller Services that are affected.
+        // 7. Wait for all Controller Services to finish disabling.
+        // 8. Update Parameter Context
+        // 9. Re-Enable all affected Controller Services
+        // 10. Re-Start all Processors
+
+        final Set<AffectedComponentEntity> affectedComponents = serviceFacade.getComponentsAffectedByParameterContextUpdate(contextDto);
+        logger.debug("Received Update Request for Parameter Context: {}; the following {} components will be affected: {}", requestEntity, affectedComponents.size(), affectedComponents);
+
+        final InitiateChangeParameterContextRequestWrapper requestWrapper = new InitiateChangeParameterContextRequestWrapper(requestEntity, componentLifecycle, getAbsolutePath(),
+            affectedComponents, replicateRequest, user);
+
+        final Revision requestRevision = getRevision(requestEntity.getRevision(), contextDto.getId());
+        return withWriteLock(
+            serviceFacade,
+            requestWrapper,
+            requestRevision,
+            lookup -> {
+                // Verify READ and WRITE permissions for user, for the Parameter Context itself
+                final Authorizable parameterContext = lookup.getParameterContext(contextId);
+                parameterContext.authorize(authorizer, RequestAction.READ, user);
+                parameterContext.authorize(authorizer, RequestAction.WRITE, user);
+
+                // Verify READ and WRITE permissions for user, for every component that is affected
+                affectedComponents.forEach(component -> authorizeAffectedComponent(component, lookup, user, true, true));
+            },
+            () -> {
+                // Verify Request
+                serviceFacade.verifyUpdateParameterContext(contextDto, false);
+            },
+            this::submitUpdateRequest
+        );
+    }
+
+    private void validateParameterNames(final ParameterContextDTO parameterContextDto) {
+        for (final ParameterEntity entity : parameterContextDto.getParameters()) {
+            final String parameterName = entity.getParameter().getName();
+            if (!isLegalParameterName(parameterName)) {
+                throw new IllegalArgumentException("Request contains an illegal Parameter Name (" + parameterName + "). Parameter names may only include letters, numbers, spaces, and the special " +
+                    "characters .-_");
+            }
+        }
+    }
+
+    private boolean isLegalParameterName(final String parameterName) {
+        return VALID_PARAMETER_NAME_PATTERN.matcher(parameterName).matches();
+    }
+
+    private void authorizeAffectedComponent(final AffectedComponentEntity entity, final AuthorizableLookup lookup, final NiFiUser user, final boolean requireRead, final boolean requireWrite) {
+        final AffectedComponentDTO dto = entity.getComponent();
+        if (dto == null) {
+            // If the DTO is null, it is an indication that the user does not have permissions.
+            // However, we don't want to just throw an AccessDeniedException because we would rather
+            // ensure that all of the appropriate actions are taken by the pluggable Authorizer. As a result,
+            // we attempt to find the component as a Processor and fall back to finding it as a Controller Service.
+            // We then go ahead and attempt the authorization, expecting it to fail.
+            Authorizable authorizable;
+            try {
+                authorizable = lookup.getProcessor(entity.getId()).getAuthorizable();
+            } catch (final ResourceNotFoundException rnfe) {
+                authorizable = lookup.getControllerService(entity.getId()).getAuthorizable();
+            }
+
+            if (requireRead) {
+                authorizable.authorize(authorizer, RequestAction.READ, user);
+            }
+            if (requireWrite) {
+                authorizable.authorize(authorizer, RequestAction.WRITE, user);
+            }
+        } else if (AffectedComponentDTO.COMPONENT_TYPE_PROCESSOR.equals(dto.getReferenceType())) {
+            final Authorizable processor = lookup.getProcessor(dto.getId()).getAuthorizable();
+
+            if (requireRead) {
+                processor.authorize(authorizer, RequestAction.READ, user);
+            }
+            if (requireWrite) {
+                processor.authorize(authorizer, RequestAction.WRITE, user);
+            }
+        } else if (AffectedComponentDTO.COMPONENT_TYPE_CONTROLLER_SERVICE.equals(dto.getReferenceType())) {
+            final Authorizable service = lookup.getControllerService(dto.getId()).getAuthorizable();
+
+            if (requireRead) {
+                service.authorize(authorizer, RequestAction.READ, user);
+            }
+            if (requireWrite) {
+                service.authorize(authorizer, RequestAction.WRITE, user);
+            }
+        }
+    }
+
+
+    @GET
+    @Consumes(MediaType.WILDCARD)
+    @Produces(MediaType.APPLICATION_JSON)
+    @Path("{contextId}/update-requests/{requestId}")
+    @ApiOperation(
+        value = "Returns the Update Request with the given ID",
+        response = ParameterContextUpdateRequestEntity.class,
+        notes = "Returns the Update Request with the given ID. Once an Update Request has been created by performing a POST to /nifi-api/parameter-contexts, "
+            + "that request can subsequently be retrieved via this endpoint, and the request that is fetched will contain the updated state, such as percent complete, the "
+            + "current state of the request, and any failures. ",
+        authorizations = {
+            @Authorization(value = "Only the user that submitted the request can get it")
+        })
+    @ApiResponses(value = {
+        @ApiResponse(code = 400, message = "NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."),
+        @ApiResponse(code = 401, message = "Client could not be authenticated."),
+        @ApiResponse(code = 403, message = "Client is not authorized to make this request."),
+        @ApiResponse(code = 404, message = "The specified resource could not be found."),
+        @ApiResponse(code = 409, message = "The request was valid but NiFi was not in the appropriate state to process it. Retrying the same request later may be successful.")
+    })
+    public Response getParameterContextUpdate(
+        @ApiParam("The ID of the Parameter Context") @PathParam("contextId") final String contextId,
+        @ApiParam("The ID of the Update Request") @PathParam("requestId") final String updateRequestId) {
+
+        authorizeReadParameterContext(contextId);
+
+        return retrieveUpdateRequest("update-requests", contextId, updateRequestId);
+    }
+
+
+    @DELETE
+    @Consumes(MediaType.WILDCARD)
+    @Produces(MediaType.APPLICATION_JSON)
+    @Path("{contextId}/update-requests/{requestId}")
+    @ApiOperation(
+        value = "Deletes the Update Request with the given ID",
+        response = ParameterContextUpdateRequestEntity.class,
+        notes = "Deletes the Update Request with the given ID. After a request is created via a POST to /nifi-api/parameter-contexts/update-requests, it is expected "
+            + "that the client will properly clean up the request by DELETE'ing it, once the Update process has completed. If the request is deleted before the request "
+            + "completes, then the Update request will finish the step that it is currently performing and then will cancel any subsequent steps.",
+        authorizations = {
+            @Authorization(value = "Only the user that submitted the request can remove it")
+        })
+    @ApiResponses(value = {
+        @ApiResponse(code = 400, message = "NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."),
+        @ApiResponse(code = 401, message = "Client could not be authenticated."),
+        @ApiResponse(code = 403, message = "Client is not authorized to make this request."),
+        @ApiResponse(code = 404, message = "The specified resource could not be found."),
+        @ApiResponse(code = 409, message = "The request was valid but NiFi was not in the appropriate state to process it. Retrying the same request later may be successful.")
+    })
+    public Response deleteUpdateRequest(
+        @ApiParam(
+            value = "Acknowledges that this node is disconnected to allow for mutable requests to proceed.",
+            required = false
+        )
+        @QueryParam(DISCONNECTED_NODE_ACKNOWLEDGED) @DefaultValue("false") final Boolean disconnectedNodeAcknowledged,
+        @ApiParam("The ID of the ParameterContext") @PathParam("contextId") final String contextId,
+        @ApiParam("The ID of the Update Request") @PathParam("requestId") final String updateRequestId) {
+
+        authorizeReadParameterContext(contextId);
+        return deleteUpdateRequest("update-requests", contextId, updateRequestId, disconnectedNodeAcknowledged.booleanValue());
+    }
+
+
+    @DELETE
+    @Consumes(MediaType.WILDCARD)
+    @Produces(MediaType.APPLICATION_JSON)
+    @Path("{id}")
+    @ApiOperation(
+        value = "Deletes the Parameter Context with the given ID",
+        response = ParameterContextEntity.class,
+        notes = "Deletes the Parameter Context with the given ID.",
+        authorizations = {
+            @Authorization(value = "Read - /parameter-contexts/{uuid}"),
+            @Authorization(value = "Write - /parameter-contexts/{uuid}"),
+            @Authorization(value = "Read - /process-groups/{uuid}, for any Process Group that is currently bound to the Parameter Context"),
+            @Authorization(value = "Write - /process-groups/{uuid}, for any Process Group that is currently bound to the Parameter Context")
+        })
+    @ApiResponses(value = {
+        @ApiResponse(code = 400, message = "NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."),
+        @ApiResponse(code = 401, message = "Client could not be authenticated."),
+        @ApiResponse(code = 403, message = "Client is not authorized to make this request."),
+        @ApiResponse(code = 404, message = "The specified resource could not be found."),
+        @ApiResponse(code = 409, message = "The request was valid but NiFi was not in the appropriate state to process it. Retrying the same request later may be successful.")
+    })
+    public Response deleteParameterContext(
+        @ApiParam(
+            value = "The version is used to verify the client is working with the latest version of the flow.",
+            required = false)
+        @QueryParam(VERSION) final LongParameter version,
+        @ApiParam(
+            value = "If the client id is not specified, a new one will be generated. This value (whether specified or generated) is included in the response.",
+            required = false)
+        @QueryParam(CLIENT_ID) @DefaultValue(StringUtils.EMPTY) final ClientIdParameter clientId,
+        @ApiParam(
+            value = "Acknowledges that this node is disconnected to allow for mutable requests to proceed.",
+            required = false
+        )
+        @QueryParam(DISCONNECTED_NODE_ACKNOWLEDGED) @DefaultValue("false") final Boolean disconnectedNodeAcknowledged,
+        @ApiParam("The Parameter Context ID.") @PathParam("id") final String parameterContextId) {
+
+
+        if (isReplicateRequest()) {
+            return replicate(HttpMethod.DELETE);
+        } else if (isDisconnectedFromCluster()) {
+            verifyDisconnectedNodeModification(disconnectedNodeAcknowledged);
+        }
+
+        final Revision requestRevision = new Revision(version == null ? null : version.getLong(), clientId.getClientId(), parameterContextId);
+        return withWriteLock(
+            serviceFacade,
+            null,
+            requestRevision,
+            lookup -> {
+                final NiFiUser user = NiFiUserUtils.getNiFiUser();
+
+                final Authorizable parameterContext = lookup.getParameterContext(parameterContextId);
+                parameterContext.authorize(authorizer, RequestAction.READ, user);
+                parameterContext.authorize(authorizer, RequestAction.WRITE, user);
+
+                final ParameterContextEntity contextEntity = serviceFacade.getParameterContext(parameterContextId, user);
+                for (final ProcessGroupEntity boundGroupEntity : contextEntity.getComponent().getBoundProcessGroups()) {
+                    final String groupId = boundGroupEntity.getId();
+                    final Authorizable groupAuthorizable = lookup.getProcessGroup(groupId).getAuthorizable();
+                    groupAuthorizable.authorize(authorizer, RequestAction.READ, user);
+                    groupAuthorizable.authorize(authorizer, RequestAction.WRITE, user);
+                }
+            },
+            () -> serviceFacade.verifyDeleteParameterContext(parameterContextId),
+            (revision, groupEntity) -> {
+                // disconnect from version control
+                final ParameterContextEntity entity = serviceFacade.deleteParameterContext(revision, parameterContextId);
+
+                // generate the response
+                return generateOkResponse(entity).build();
+            });
+
+    }
+
+
+    @POST
+    @Consumes(MediaType.APPLICATION_JSON)
+    @Produces(MediaType.APPLICATION_JSON)
+    @Path("{contextId}/validation-requests")
+    @ApiOperation(
+        value = "Initiate a Validation Request to determine how the validity of components will change if a Parameter Context were to be updated",
+        response = ParameterContextValidationRequestEntity.class,
+        notes = "This will initiate the process of validating all components whose Process Group is bound to the specified Parameter Context. Performing validation against " +
+            "an arbitrary number of components may be expect and take significantly more time than many other REST API actions. As a result, this endpoint will immediately return " +
+            "a ParameterContextValidationRequestEntity, " +
+            "and the process of validating the necessary components will occur asynchronously in the background. The client may then periodically poll the status of the request by " +
+            "issuing a GET request to /parameter-contexts/validation-requests/{requestId}. Once the request is completed, the client is expected to issue a DELETE request to " +
+            "/parameter-contexts/validation-requests/{requestId}.",
+        authorizations = {
+            @Authorization(value = "Read - /parameter-contexts/{parameterContextId}")
+        })
+    @ApiResponses(value = {
+        @ApiResponse(code = 400, message = "NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."),
+        @ApiResponse(code = 401, message = "Client could not be authenticated."),
+        @ApiResponse(code = 403, message = "Client is not authorized to make this request."),
+        @ApiResponse(code = 404, message = "The specified resource could not be found."),
+        @ApiResponse(code = 409, message = "The request was valid but NiFi was not in the appropriate state to process it. Retrying the same request later may be successful.")
+    })
+    public Response submitValidationRequest(
+        @PathParam("contextId") final String contextId,
+        @ApiParam(value = "The validation request", required=true) final ParameterContextValidationRequestEntity requestEntity) {
+
+        final ParameterContextValidationRequestDTO requestDto = requestEntity.getRequest();
+        if (requestDto == null) {
+            throw new IllegalArgumentException("Parameter Context must be specified");
+        }
+
+        if (requestDto.getParameterContext() == null) {
+            throw new IllegalArgumentException("Parameter Context must be specified");
+        }
+        if (requestDto.getParameterContext().getId() == null) {
+            throw new IllegalArgumentException("Parameter Context's ID must be specified");
+        }
+
+        if (isReplicateRequest()) {
+            return replicate("POST", requestEntity);
+        } else if (isDisconnectedFromCluster()) {
+            verifyDisconnectedNodeModification(requestEntity.isDisconnectedNodeAcknowledged());
+        }
+
+        return withWriteLock(
+            serviceFacade,
+            requestEntity,
+            lookup -> {
+                final Authorizable parameterContext = lookup.getParameterContext(contextId);
+                parameterContext.authorize(authorizer, RequestAction.READ, NiFiUserUtils.getNiFiUser());
+
+                authorizeReferencingComponents(requestEntity.getRequest().getParameterContext().getId(), lookup, NiFiUserUtils.getNiFiUser());
+            },
+            () -> {},
+            entity -> performAsyncValidation(entity, NiFiUserUtils.getNiFiUser())
+        );
+    }
+
+    private void authorizeReferencingComponents(final String parameterContextId, final AuthorizableLookup lookup, final NiFiUser user) {
+        final ParameterContextEntity context = serviceFacade.getParameterContext(parameterContextId, NiFiUserUtils.getNiFiUser());
+
+        for (final ParameterEntity parameterEntity : context.getComponent().getParameters()) {
+            final ParameterDTO dto = parameterEntity.getParameter();
+            if (dto == null) {
+                continue;
+            }
+
+            for (final AffectedComponentEntity affectedComponent : dto.getReferencingComponents()) {
+                authorizeAffectedComponent(affectedComponent, lookup, user, true, false);
+            }
+        }
+    }
+
+    @GET
+    @Consumes(MediaType.WILDCARD)
+    @Produces(MediaType.APPLICATION_JSON)
+    @Path("{contextId}/validation-requests/{id}")
+    @ApiOperation(
+        value = "Returns the Validation Request with the given ID",
+        response = ParameterContextValidationRequestEntity.class,
+        notes = "Returns the Validation Request with the given ID. Once a Validation Request has been created by performing a POST to /nifi-api/validation-contexts, "
+            + "that request can subsequently be retrieved via this endpoint, and the request that is fetched will contain the updated state, such as percent complete, the "
+            + "current state of the request, and any failures. ",
+        authorizations = {
+            @Authorization(value = "Only the user that submitted the request can get it")
+        })
+    @ApiResponses(value = {
+        @ApiResponse(code = 400, message = "NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."),
+        @ApiResponse(code = 401, message = "Client could not be authenticated."),
+        @ApiResponse(code = 403, message = "Client is not authorized to make this request."),
+        @ApiResponse(code = 404, message = "The specified resource could not be found."),
+        @ApiResponse(code = 409, message = "The request was valid but NiFi was not in the appropriate state to process it. Retrying the same request later may be successful.")
+    })
+    public Response getValidationRequest(
+        @ApiParam("The ID of the Parameter Context") @PathParam("contextId") final String contextId,
+        @ApiParam("The ID of the Validation Request") @PathParam("id") final String validationRequestId) {
+
+        authorizeReadParameterContext(contextId);
+
+        if (isReplicateRequest()) {
+            return replicate("GET");
+        }
+
+        return retrieveValidationRequest("validation-requests", contextId, validationRequestId);
+    }
+
+    @DELETE
+    @Consumes(MediaType.WILDCARD)
+    @Produces(MediaType.APPLICATION_JSON)
+    @Path("{contextId}/validation-requests/{id}")
+    @ApiOperation(
+        value = "Deletes the Validation Request with the given ID",
+        response = ParameterContextValidationRequestEntity.class,
+        notes = "Deletes the Validation Request with the given ID. After a request is created via a POST to /nifi-api/validation-contexts, it is expected "
+            + "that the client will properly clean up the request by DELETE'ing it, once the validation process has completed. If the request is deleted before the request "
+            + "completes, then the Validation request will finish the step that it is currently performing and then will cancel any subsequent steps.",
+        authorizations = {
+            @Authorization(value = "Only the user that submitted the request can remove it")
+        })
+    @ApiResponses(value = {
+        @ApiResponse(code = 400, message = "NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."),
+        @ApiResponse(code = 401, message = "Client could not be authenticated."),
+        @ApiResponse(code = 403, message = "Client is not authorized to make this request."),
+        @ApiResponse(code = 404, message = "The specified resource could not be found."),
+        @ApiResponse(code = 409, message = "The request was valid but NiFi was not in the appropriate state to process it. Retrying the same request later may be successful.")
+    })
+    public Response deleteValidationRequest(
+        @ApiParam(
+            value = "Acknowledges that this node is disconnected to allow for mutable requests to proceed.",
+            required = false
+        )
+        @QueryParam(DISCONNECTED_NODE_ACKNOWLEDGED) @DefaultValue("false") final Boolean disconnectedNodeAcknowledged,
+        @ApiParam("The ID of the Parameter Context") @PathParam("contextId") final String contextId,
+        @ApiParam("The ID of the Update Request") @PathParam("id") final String validationRequestId) {
+
+        authorizeReadParameterContext(contextId);
+
+        if (isReplicateRequest()) {
+            return replicate(HttpMethod.DELETE);
+        } else if (isDisconnectedFromCluster()) {
+            verifyDisconnectedNodeModification(disconnectedNodeAcknowledged);
+        }
+
+        return deleteValidationRequest("validation-requests", contextId, validationRequestId, disconnectedNodeAcknowledged.booleanValue());
+    }
+
+
+
+    private Response performAsyncValidation(final ParameterContextValidationRequestEntity requestEntity, final NiFiUser user) {
+        // Create an asynchronous request that will occur in the background, because this request may
+        // result in stopping components, which can take an indeterminate amount of time.
+        final String requestId = generateUuid();
+        final AsynchronousWebRequest<ParameterContextValidationRequestEntity, ComponentValidationResultsEntity> request = new StandardAsynchronousWebRequest<>(requestId, requestEntity, null, user,
+            getValidationSteps());
+
+        // Submit the request to be performed in the background
+        final Consumer<AsynchronousWebRequest<ParameterContextValidationRequestEntity, ComponentValidationResultsEntity>> validationTask = asyncRequest -> {
+            try {
+                final ComponentValidationResultsEntity resultEntity = validateComponents(requestEntity, user);
+                asyncRequest.markStepComplete(resultEntity);
+            } catch (final Exception e) {
+                logger.error("Failed to validate components", e);
+                asyncRequest.fail("Failed to validation components due to " + e);
+            }
+        };
+
+        validationRequestManager.submitRequest("validation-requests", requestId, request, validationTask);
+
+        // Generate the response.
+        final ParameterContextValidationRequestDTO validationRequestDto = new ParameterContextValidationRequestDTO();
+        validationRequestDto.setComplete(request.isComplete());
+        validationRequestDto.setFailureReason(request.getFailureReason());
+        validationRequestDto.setLastUpdated(request.getLastUpdated());
+        validationRequestDto.setRequestId(requestId);
+        validationRequestDto.setUri(generateResourceUri("parameter-contexts", "validation-requests", requestId));
+        validationRequestDto.setPercentCompleted(request.getPercentComplete());
+        validationRequestDto.setState(request.getState());
+        validationRequestDto.setComponentValidationResults(request.getResults());
+
+        final ParameterContextValidationRequestEntity validationRequestEntity = new ParameterContextValidationRequestEntity();
+        validationRequestEntity.setRequest(validationRequestDto);
+
+        return generateOkResponse(validationRequestEntity).build();
+    }
+
+    private List<UpdateStep> getValidationSteps() {
+        return Collections.singletonList(new StandardUpdateStep("Validating Components"));
+    }
+
+    private ComponentValidationResultsEntity validateComponents(final ParameterContextValidationRequestEntity requestEntity, final NiFiUser user) {
+        final List<ComponentValidationResultEntity> resultEntities = serviceFacade.validateComponents(requestEntity.getRequest().getParameterContext(), user);
+        final ComponentValidationResultsEntity resultsEntity = new ComponentValidationResultsEntity();
+        resultsEntity.setValidationResults(resultEntities);
+        return resultsEntity;
+    }
+
+
+    private Response submitUpdateRequest(final Revision requestRevision, final InitiateChangeParameterContextRequestWrapper requestWrapper) {
+        // Create an asynchronous request that will occur in the background, because this request may
+        // result in stopping components, which can take an indeterminate amount of time.
+        final String requestId = UUID.randomUUID().toString();
+        final String contextId = requestWrapper.getParameterContextEntity().getComponent().getId();
+        final AsynchronousWebRequest<ParameterContextEntity, ParameterContextEntity> request = new StandardAsynchronousWebRequest<>(requestId, requestWrapper.getParameterContextEntity(), contextId,
+            requestWrapper.getUser(), getUpdateSteps());
+
+        // Submit the request to be performed in the background
+        final Consumer<AsynchronousWebRequest<ParameterContextEntity, ParameterContextEntity>> updateTask = asyncRequest -> {
+            try {
+                final ParameterContextEntity updatedParameterContextEntity = updateParameterContext(asyncRequest, requestWrapper.getComponentLifecycle(), requestWrapper.getExampleUri(),
+                    requestWrapper.getAffectedComponents(), requestWrapper.isReplicateRequest(), requestRevision, requestWrapper.getParameterContextEntity());
+
+                asyncRequest.markStepComplete(updatedParameterContextEntity);
+            } catch (final ResumeFlowException rfe) {
+                // Treat ResumeFlowException differently because we don't want to include a message that we couldn't update the flow
+                // since in this case the flow was successfully updated - we just couldn't re-enable the components.
+                logger.error(rfe.getMessage(), rfe);
+                asyncRequest.fail(rfe.getMessage());
+            } catch (final Exception e) {
+                logger.error("Failed to update Parameter Context", e);
+                asyncRequest.fail("Failed to update Parameter Context due to " + e);
+            }
+        };
+
+        updateRequestManager.submitRequest("update-requests", requestId, request, updateTask);
+
+        // Generate the response.
+        final ParameterContextUpdateRequestEntity updateRequestEntity = createUpdateRequestEntity(request, "update-requests", contextId, requestId);
+        return generateOkResponse(updateRequestEntity).build();
+    }
+
+    private List<UpdateStep> getUpdateSteps() {
+        return Arrays.asList(new StandardUpdateStep("Stopping Affected Processors"),
+            new StandardUpdateStep("Disabling Affected Controller Services"),
+            new StandardUpdateStep("Updating Parameter Context"),
+            new StandardUpdateStep("Re-Enabling Affected Controller Services"),
+            new StandardUpdateStep("Restarting Affected Processors"));
+    }
+
+
+    private ParameterContextEntity updateParameterContext(final AsynchronousWebRequest<ParameterContextEntity, ParameterContextEntity> asyncRequest, final ComponentLifecycle componentLifecycle,
+                                                          final URI uri, final Set<AffectedComponentEntity> affectedComponents,
+                                                          final boolean replicateRequest, final Revision revision, final ParameterContextEntity updatedContextEntity)
+        throws LifecycleManagementException, ResumeFlowException {
+
+        final Set<AffectedComponentEntity> runningProcessors = affectedComponents.stream()
+            .filter(entity -> entity.getComponent() != null)
+            .filter(entity -> AffectedComponentDTO.COMPONENT_TYPE_PROCESSOR.equals(entity.getComponent().getReferenceType()))
+            .filter(component -> "Running".equalsIgnoreCase(component.getComponent().getState()))
+            .collect(Collectors.toSet());
+
+        final Set<AffectedComponentEntity> enabledControllerServices = affectedComponents.stream()
+            .filter(entity -> entity.getComponent() != null)
+            .filter(dto -> AffectedComponentDTO.COMPONENT_TYPE_CONTROLLER_SERVICE.equals(dto.getComponent().getReferenceType()))
+            .filter(dto -> "Enabled".equalsIgnoreCase(dto.getComponent().getState()))
+            .collect(Collectors.toSet());
+
+        stopProcessors(runningProcessors, asyncRequest, componentLifecycle, uri);
+        if (asyncRequest.isCancelled()) {
+            return null;
+        }
+
+        disableControllerServices(enabledControllerServices, asyncRequest, componentLifecycle, uri);
+        if (asyncRequest.isCancelled()) {
+            return null;
+        }
+
+        asyncRequest.markStepComplete();
+        logger.info("Updating Parameter Context with ID {}", updatedContextEntity.getId());
+
+        final ParameterContextEntity updatedEntity;
+        try {
+            updatedEntity = performParameterContextUpdate(asyncRequest, uri, replicateRequest, revision, updatedContextEntity);
+            logger.info("Successfully updated Parameter Context with ID {}", updatedContextEntity.getId());
+        } finally {
+            // TODO: can almost certainly be refactored so that the same code is shared between VersionsResource and ParameterContextResource.
+            if (!asyncRequest.isCancelled()) {
+                enableControllerServices(enabledControllerServices, asyncRequest, componentLifecycle, uri);
+            }
+
+            if (!asyncRequest.isCancelled()) {
+                restartProcessors(runningProcessors, asyncRequest, componentLifecycle, uri);
+            }
+        }
+
+        asyncRequest.setCancelCallback(null);
+        if (asyncRequest.isCancelled()) {
+            return null;
+        }
+
+        return updatedEntity;
+    }
+
+    private ParameterContextEntity performParameterContextUpdate(final AsynchronousWebRequest<?, ?> asyncRequest, final URI exampleUri, final boolean replicateRequest, final Revision revision,
+                                               final ParameterContextEntity updatedContext) throws LifecycleManagementException {
+
+        if (replicateRequest) {
+            final URI updateUri;
+            try {
+                updateUri = new URI(exampleUri.getScheme(), exampleUri.getUserInfo(), exampleUri.getHost(),
+                    exampleUri.getPort(), "/nifi-api/parameter-contexts/" + updatedContext.getId(), null, exampleUri.getFragment());
+            } catch (URISyntaxException e) {
+                throw new RuntimeException(e);
+            }
+
+            final Map<String, String> headers = new HashMap<>();
+            headers.put("content-type", MediaType.APPLICATION_JSON);
+
+            final NiFiUser user = asyncRequest.getUser();
+            final NodeResponse clusterResponse;
+            try {
+                logger.debug("Replicating PUT request to {} for user {}", updateUri, user);
+
+                if (getReplicationTarget() == ReplicationTarget.CLUSTER_NODES) {
+                    clusterResponse = getRequestReplicator().replicate(user, HttpMethod.PUT, updateUri, updatedContext, headers).awaitMergedResponse();
+                } else {
+                    clusterResponse = getRequestReplicator().forwardToCoordinator(
+                        getClusterCoordinatorNode(), user, HttpMethod.PUT, updateUri, updatedContext, headers).awaitMergedResponse();
+                }
+            } catch (final InterruptedException ie) {
+                logger.warn("Interrupted while replicating PUT request to {} for user {}", updateUri, user);
+                Thread.currentThread().interrupt();
+                throw new LifecycleManagementException("Interrupted while updating flows across cluster", ie);
+            }
+
+            final int updateFlowStatus = clusterResponse.getStatus();
+            if (updateFlowStatus != Response.Status.OK.getStatusCode()) {
+                final String explanation = getResponseEntity(clusterResponse, String.class);
+                logger.error("Failed to update flow across cluster when replicating PUT request to {} for user {}. Received {} response with explanation: {}",
+                    updateUri, user, updateFlowStatus, explanation);
+                throw new LifecycleManagementException("Failed to update Flow on all nodes in cluster due to " + explanation);
+            }
+
+            return serviceFacade.getParameterContext(updatedContext.getId(), user);
+        } else {
+            serviceFacade.verifyUpdateParameterContext(updatedContext.getComponent(), true);
+            return serviceFacade.updateParameterContext(revision, updatedContext.getComponent());
+        }
+    }
+
+    /**
+     * Extracts the response entity from the specified node response.
+     *
+     * @param nodeResponse node response
+     * @param clazz class
+     * @param <T> type of class
+     * @return the response entity
+     */
+    @SuppressWarnings("unchecked")
+    private <T> T getResponseEntity(final NodeResponse nodeResponse, final Class<T> clazz) {
+        T entity = (T) nodeResponse.getUpdatedEntity();
+        if (entity == null) {
+            entity = nodeResponse.getClientResponse().readEntity(clazz);
+        }
+        return entity;
+    }
+
+
+    private void stopProcessors(final Set<AffectedComponentEntity> processors, final AsynchronousWebRequest<?, ?> asyncRequest, final ComponentLifecycle componentLifecycle, final URI uri)
+        throws LifecycleManagementException {
+
+        logger.info("Stopping {} Processors in order to update Parameter Context", processors.size());
+        final CancellableTimedPause stopComponentsPause = new CancellableTimedPause(250, Long.MAX_VALUE, TimeUnit.MILLISECONDS);
+        asyncRequest.setCancelCallback(stopComponentsPause::cancel);
+        componentLifecycle.scheduleComponents(uri, "root", processors, ScheduledState.STOPPED, stopComponentsPause, InvalidComponentAction.SKIP);
+    }
+
+    private void restartProcessors(final Set<AffectedComponentEntity> processors, final AsynchronousWebRequest<?, ?> asyncRequest, final ComponentLifecycle componentLifecycle, final URI uri)
+        throws ResumeFlowException, LifecycleManagementException {
+
+        if (logger.isDebugEnabled()) {
+            logger.debug("Restarting {} Processors after having updated Parameter Context: {}", processors.size(), processors);
+        } else {
+            logger.info("Restarting {} Processors after having updated Parameter Context", processors.size());
+        }
+
+        asyncRequest.markStepComplete();
+
+        // Step 14. Restart all components
+        final Set<AffectedComponentEntity> componentsToStart = getUpdatedEntities(processors);
+
+        final CancellableTimedPause startComponentsPause = new CancellableTimedPause(250, Long.MAX_VALUE, TimeUnit.MILLISECONDS);
+        asyncRequest.setCancelCallback(startComponentsPause::cancel);
+
+        try {
+            componentLifecycle.scheduleComponents(uri, "root", componentsToStart, ScheduledState.RUNNING, startComponentsPause, InvalidComponentAction.SKIP);
+        } catch (final IllegalStateException ise) {
+            // Component Lifecycle will restart the Processors only if they are valid. If IllegalStateException gets thrown, we need to provide
+            // a more intelligent error message as to exactly what happened, rather than indicate that the flow could not be updated.
+            throw new ResumeFlowException("Failed to restart components because " + ise.getMessage(), ise);
+        }
+    }
+
+    private void disableControllerServices(final Set<AffectedComponentEntity> controllerServices, final AsynchronousWebRequest<?, ?> asyncRequest, final ComponentLifecycle componentLifecycle,
+                                           final URI uri) throws LifecycleManagementException {
+
+        asyncRequest.markStepComplete();
+        logger.info("Disabling {} Controller Services in order to update Parameter Context", controllerServices.size());
+        final CancellableTimedPause disableServicesPause = new CancellableTimedPause(250, Long.MAX_VALUE, TimeUnit.MILLISECONDS);
+        asyncRequest.setCancelCallback(disableServicesPause::cancel);
+        componentLifecycle.activateControllerServices(uri, "root", controllerServices, ControllerServiceState.DISABLED, disableServicesPause, InvalidComponentAction.SKIP);
+    }
+
+    private void enableControllerServices(final Set<AffectedComponentEntity> controllerServices, final AsynchronousWebRequest<?, ?> asyncRequest, final ComponentLifecycle componentLifecycle,
+                                          final URI uri) throws LifecycleManagementException, ResumeFlowException {
+        if (logger.isDebugEnabled()) {
+            logger.debug("Re-Enabling {} Controller Services: {}", controllerServices.size(), controllerServices);
+        } else {
+            logger.info("Re-Enabling {} Controller Services after having updated Parameter Context", controllerServices.size());
+        }
+
+        asyncRequest.markStepComplete();
+
+        // Step 13. Re-enable all disabled controller services
+        final CancellableTimedPause enableServicesPause = new CancellableTimedPause(250, Long.MAX_VALUE, TimeUnit.MILLISECONDS);
+        asyncRequest.setCancelCallback(enableServicesPause::cancel);
+        final Set<AffectedComponentEntity> servicesToEnable = getUpdatedEntities(controllerServices);
+
+        try {
+            componentLifecycle.activateControllerServices(uri, "root", servicesToEnable, ControllerServiceState.ENABLED, enableServicesPause, InvalidComponentAction.SKIP);
+        } catch (final IllegalStateException ise) {
+            // Component Lifecycle will re-enable the Controller Services only if they are valid. If IllegalStateException gets thrown, we need to provide
+            // a more intelligent error message as to exactly what happened, rather than indicate that the Parameter Context could not be updated.
+            throw new ResumeFlowException("Failed to re-enable Controller Services because " + ise.getMessage(), ise);
+        }
+    }
+
+    private Set<AffectedComponentEntity> getUpdatedEntities(final Set<AffectedComponentEntity> originalEntities) {
+        final Set<AffectedComponentEntity> entities = new LinkedHashSet<>();
+
+        for (final AffectedComponentEntity original : originalEntities) {
+            try {
+                final AffectedComponentEntity updatedEntity = AffectedComponentUtils.updateEntity(original, serviceFacade, dtoFactory);
+                if (updatedEntity != null) {
+                    entities.add(updatedEntity);
+                }
+            } catch (final ResourceNotFoundException rnfe) {
+                // Component was removed. Just continue on without adding anything to the entities.
+                // We do this because the intent is to get updated versions of the entities with current
+                // Revisions so that we can change the states of the components. If the component was removed,
+                // then we can just drop the entity, since there is no need to change its state.
+            }
+        }
+
+        return entities;
+    }
+
+
+    private Response retrieveValidationRequest(final String requestType, final String contextId, final String requestId) {
+        if (requestId == null) {
+            throw new IllegalArgumentException("Request ID must be specified.");
+        }
+
+        final NiFiUser user = NiFiUserUtils.getNiFiUser();
+
+        final AsynchronousWebRequest<?, ComponentValidationResultsEntity> asyncRequest = validationRequestManager.getRequest(requestType, requestId, user);
+        final ParameterContextValidationRequestEntity requestEntity = createValidationRequestEntity(asyncRequest, contextId, requestType, requestId);
+        return generateOkResponse(requestEntity).build();
+    }
+
+    private Response deleteValidationRequest(final String requestType, final String contextId, final String requestId, final boolean disconnectedNodeAcknowledged) {
+        if (requestId == null) {
+            throw new IllegalArgumentException("Request ID must be specified.");
+        }
+
+        if (isDisconnectedFromCluster()) {
+            verifyDisconnectedNodeModification(disconnectedNodeAcknowledged);
+        }
+
+        final NiFiUser user = NiFiUserUtils.getNiFiUser();
+
+        // request manager will ensure that the current is the user that submitted this request
+        final AsynchronousWebRequest<?, ComponentValidationResultsEntity> asyncRequest = validationRequestManager.removeRequest(requestType, requestId, user);
+        if (asyncRequest == null) {
+            throw new ResourceNotFoundException("Could not find request of type " + requestType + " with ID " + requestId);
+        }
+
+        if (!asyncRequest.isComplete()) {
+            asyncRequest.cancel();
+        }
+
+        final ParameterContextValidationRequestEntity requestEntity = createValidationRequestEntity(asyncRequest, contextId, requestType, requestId);
+        return generateOkResponse(requestEntity).build();
+    }
+
+    private ParameterContextValidationRequestEntity createValidationRequestEntity(final AsynchronousWebRequest<?, ComponentValidationResultsEntity> asyncRequest, final String requestType,
+                                                                                  final String contextId, final String requestId) {
+        final ParameterContextValidationRequestDTO requestDto = new ParameterContextValidationRequestDTO();
+
+        requestDto.setComplete(asyncRequest.isComplete());
+        requestDto.setFailureReason(asyncRequest.getFailureReason());
+        requestDto.setLastUpdated(asyncRequest.getLastUpdated());
+        requestDto.setRequestId(requestId);
+        requestDto.setUri(generateResourceUri("parameter-contexts", contextId, requestType, requestId));
+        requestDto.setState(asyncRequest.getState());
+        requestDto.setPercentCompleted(asyncRequest.getPercentComplete());
+        requestDto.setComponentValidationResults(asyncRequest.getResults());
+
+        final ParameterContextValidationRequestEntity entity = new ParameterContextValidationRequestEntity();
+        entity.setRequest(requestDto);
+        return entity;
+    }
+
+    private Response retrieveUpdateRequest(final String requestType, final String contextId, final String requestId) {
+        if (requestId == null) {
+            throw new IllegalArgumentException("Request ID must be specified.");
+        }
+
+        final NiFiUser user = NiFiUserUtils.getNiFiUser();
+
+        // request manager will ensure that the current is the user that submitted this request
+        final AsynchronousWebRequest<ParameterContextEntity, ParameterContextEntity> asyncRequest = updateRequestManager.getRequest(requestType, requestId, user);
+        final ParameterContextUpdateRequestEntity updateRequestEntity = createUpdateRequestEntity(asyncRequest, requestType, contextId, requestId);
+        return generateOkResponse(updateRequestEntity).build();
+    }
+
+    private Response deleteUpdateRequest(final String requestType, final String contextId, final String requestId, final boolean disconnectedNodeAcknowledged) {
+        if (requestId == null) {
+            throw new IllegalArgumentException("Request ID must be specified.");
+        }
+
+        if (isDisconnectedFromCluster()) {
+            verifyDisconnectedNodeModification(disconnectedNodeAcknowledged);
+        }
+
+        final NiFiUser user = NiFiUserUtils.getNiFiUser();
+
+        // request manager will ensure that the current is the user that submitted this request
+        final AsynchronousWebRequest<ParameterContextEntity, ParameterContextEntity> asyncRequest = updateRequestManager.removeRequest(requestType, requestId, user);
+        if (asyncRequest == null) {
+            throw new ResourceNotFoundException("Could not find request of type " + requestType + " with ID " + requestId);
+        }
+
+        if (!asyncRequest.isComplete()) {
+            asyncRequest.cancel();
+        }
+
+        final ParameterContextUpdateRequestEntity updateRequestEntity = createUpdateRequestEntity(asyncRequest, requestType, contextId, requestId);
+        return generateOkResponse(updateRequestEntity).build();
+    }
+
+    private ParameterContextUpdateRequestEntity createUpdateRequestEntity(final AsynchronousWebRequest<ParameterContextEntity, ParameterContextEntity> asyncRequest, final String requestType,
+                                                                          final String contextId, final String requestId) {
+        final ParameterContextUpdateRequestDTO updateRequestDto = new ParameterContextUpdateRequestDTO();
+        updateRequestDto.setComplete(asyncRequest.isComplete());
+        updateRequestDto.setFailureReason(asyncRequest.getFailureReason());
+        updateRequestDto.setLastUpdated(asyncRequest.getLastUpdated());
+        updateRequestDto.setRequestId(requestId);
+        updateRequestDto.setUri(generateResourceUri("parameter-contexts", contextId, requestType, requestId));
+        updateRequestDto.setState(asyncRequest.getState());
+        updateRequestDto.setPercentCompleted(asyncRequest.getPercentComplete());
+
+        final List<ParameterContextUpdateStepDTO> updateSteps = new ArrayList<>();
+        for (final UpdateStep updateStep : asyncRequest.getUpdateSteps()) {
+            final ParameterContextUpdateStepDTO stepDto = new ParameterContextUpdateStepDTO();
+            stepDto.setDescription(updateStep.getDescription());
+            stepDto.setComplete(updateStep.isComplete());
+            stepDto.setFailureReason(updateStep.getFailureReason());
+            updateSteps.add(stepDto);
+        }
+        updateRequestDto.setUpdateSteps(updateSteps);
+
+        final ParameterContextEntity initialRequest = asyncRequest.getRequest();
+        final Map<String, AffectedComponentEntity> affectedComponents = new HashMap<>();
+        for (final ParameterEntity entity : initialRequest.getComponent().getParameters()) {
+            for (final AffectedComponentEntity affectedComponentEntity : entity.getParameter().getReferencingComponents()) {
+                affectedComponents.put(affectedComponentEntity.getId(), affectedComponentEntity);
+            }
+        }
+
+        updateRequestDto.setAffectedComponents(new HashSet<>(affectedComponents.values()));
+
+        // Populate the Affected Components
+        final ParameterContextEntity contextEntity = serviceFacade.getParameterContext(asyncRequest.getComponentId(), NiFiUserUtils.getNiFiUser());
+        final ParameterContextUpdateRequestEntity updateRequestEntity = new ParameterContextUpdateRequestEntity();
+
+        // If the request is complete, include the new representation of the Parameter Context along with its new Revision. Otherwise, do not include the information, since it is 'stale'
+        if (updateRequestDto.isComplete()) {
+            updateRequestDto.setParameterContext(contextEntity == null ? null : contextEntity.getComponent());
+            updateRequestEntity.setParameterContextRevision(contextEntity == null ? null : contextEntity.getRevision());
+        }
+
+        updateRequestEntity.setRequest(updateRequestDto);
+        return updateRequestEntity;
+    }
+
+
+    private static class InitiateChangeParameterContextRequestWrapper extends Entity {
+        private final ParameterContextEntity parameterContextEntity;
+        private final ComponentLifecycle componentLifecycle;
+        private final URI exampleUri;
+        private final Set<AffectedComponentEntity> affectedComponents;
+        private final boolean replicateRequest;
+        private final NiFiUser nifiUser;
+
+        public InitiateChangeParameterContextRequestWrapper(final ParameterContextEntity parameterContextEntity, final ComponentLifecycle componentLifecycle,
+                                                            final URI exampleUri, final Set<AffectedComponentEntity> affectedComponents, final boolean replicateRequest,
+                                                            final NiFiUser nifiUser) {
+
+            this.parameterContextEntity = parameterContextEntity;
+            this.componentLifecycle = componentLifecycle;
+            this.exampleUri = exampleUri;
+            this.affectedComponents = affectedComponents;
+            this.replicateRequest = replicateRequest;
+            this.nifiUser = nifiUser;
+        }
+
+        public ParameterContextEntity getParameterContextEntity() {
+            return parameterContextEntity;
+        }
+
+        public ComponentLifecycle getComponentLifecycle() {
+            return componentLifecycle;
+        }
+
+        public URI getExampleUri() {
+            return exampleUri;
+        }
+
+        public Set<AffectedComponentEntity> getAffectedComponents() {
+            return affectedComponents;
+        }
+
+        public boolean isReplicateRequest() {
+            return replicateRequest;
+        }
+
+        public NiFiUser getUser() {
+            return nifiUser;
+        }
+    }
+
+
+
+    public void setServiceFacade(NiFiServiceFacade serviceFacade) {
+        this.serviceFacade = serviceFacade;
+    }
+
+    public void setAuthorizer(Authorizer authorizer) {
+        this.authorizer = authorizer;
+    }
+
+    public void setClusterComponentLifecycle(ComponentLifecycle componentLifecycle) {
+        this.clusterComponentLifecycle = componentLifecycle;
+    }
+
+    public void setLocalComponentLifecycle(ComponentLifecycle componentLifecycle) {
+        this.localComponentLifecycle = componentLifecycle;
+    }
+
+    public void setDtoFactory(final DtoFactory dtoFactory) {
+        this.dtoFactory = dtoFactory;
+    }
+
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ProcessGroupResource.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ProcessGroupResource.java
index 9ebd9445e20..6144ab2f209 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ProcessGroupResource.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ProcessGroupResource.java
@@ -28,6 +28,7 @@
 import org.apache.nifi.authorization.AuthorizableLookup;
 import org.apache.nifi.authorization.AuthorizeAccess;
 import org.apache.nifi.authorization.AuthorizeControllerServiceReference;
+import org.apache.nifi.authorization.AuthorizeParameterReference;
 import org.apache.nifi.authorization.Authorizer;
 import org.apache.nifi.authorization.ComponentAuthorizable;
 import org.apache.nifi.authorization.ProcessGroupAuthorizable;
@@ -45,6 +46,7 @@
 import org.apache.nifi.controller.ScheduledState;
 import org.apache.nifi.controller.serialization.FlowEncodingVersion;
 import org.apache.nifi.controller.service.ControllerServiceState;
+import org.apache.nifi.parameter.ParameterContext;
 import org.apache.nifi.registry.bucket.Bucket;
 import org.apache.nifi.registry.client.NiFiRegistryException;
 import org.apache.nifi.registry.flow.FlowRegistryUtils;
@@ -64,6 +66,7 @@
 import org.apache.nifi.web.api.dto.ControllerServiceDTO;
 import org.apache.nifi.web.api.dto.DtoFactory;
 import org.apache.nifi.web.api.dto.FlowSnippetDTO;
+import org.apache.nifi.web.api.dto.ParameterContextReferenceDTO;
 import org.apache.nifi.web.api.dto.PortDTO;
 import org.apache.nifi.web.api.dto.PositionDTO;
 import org.apache.nifi.web.api.dto.ProcessGroupDTO;
@@ -150,6 +153,7 @@
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.ArrayBlockingQueue;
@@ -342,7 +346,7 @@ public Response getLocalModifications(
         // authorize access
         serviceFacade.authorizeAccess(lookup -> {
             final ProcessGroupAuthorizable groupAuthorizable = lookup.getProcessGroup(groupId);
-            authorizeProcessGroup(groupAuthorizable, authorizer, lookup, RequestAction.READ, false, false, true, false);
+            authorizeProcessGroup(groupAuthorizable, authorizer, lookup, RequestAction.READ, false, false, true, false, false);
         });
 
         final FlowComparisonEntity entity = serviceFacade.getLocalModifications(groupId);
@@ -467,8 +471,49 @@ public Response updateProcessGroup(
                 requestProcessGroupEntity,
                 requestRevision,
                 lookup -> {
+                    final NiFiUser user = NiFiUserUtils.getNiFiUser();
+
                     Authorizable authorizable = lookup.getProcessGroup(id).getAuthorizable();
-                    authorizable.authorize(authorizer, RequestAction.WRITE, NiFiUserUtils.getNiFiUser());
+                    authorizable.authorize(authorizer, RequestAction.WRITE, user);
+
+                    // Ensure that user has READ permission on current Parameter Context (if any) because user is un-binding.
+                    final ParameterContextReferenceDTO referencedParamContext = requestProcessGroupDTO.getParameterContext();
+                    if (referencedParamContext != null) {
+                        // Lookup the current Parameter Context and determine whether or not the Parameter Context is changing
+                        final String groupId = requestProcessGroupDTO.getId();
+                        final ProcessGroupEntity currentGroupEntity = serviceFacade.getProcessGroup(groupId);
+                        final ProcessGroupDTO groupDto = currentGroupEntity.getComponent();
+                        final ParameterContextReferenceDTO currentParamContext = groupDto.getParameterContext();
+                        final String currentParamContextId = currentParamContext == null ? null : currentParamContext.getId();
+                        final boolean parameterContextChanging = !Objects.equals(referencedParamContext.getId(), currentParamContextId);
+
+                        // If Parameter Context is changing...
+                        if (parameterContextChanging) {
+                            // In order to bind to a Parameter Context, the user must have the READ policy to that Parameter Context.
+                            if (referencedParamContext.getId() != null) {
+                                lookup.getParameterContext(referencedParamContext.getId()).authorize(authorizer, RequestAction.READ, user);
+                            }
+
+                            // If currently referencing a Parameter Context, we must authorize that the user has READ permissions on the Parameter Context in order to un-bind to it.
+                            if (currentParamContextId != null) {
+                                lookup.getParameterContext(currentParamContextId).authorize(authorizer, RequestAction.READ, user);
+                            }
+
+                            // Because the user will be changing the behavior of any component in this group that is currently referencing any Parameter, we must ensure that the user has
+                            // both READ and WRITE policies for each of those components.
+                            for (final AffectedComponentEntity affectedComponentEntity : serviceFacade.getProcessorsReferencingParameter(groupId)) {
+                                final Authorizable processorAuthorizable = lookup.getProcessor(affectedComponentEntity.getId()).getAuthorizable();
+                                processorAuthorizable.authorize(authorizer, RequestAction.READ, user);
+                                processorAuthorizable.authorize(authorizer, RequestAction.WRITE, user);
+                            }
+
+                            for (final AffectedComponentEntity affectedComponentEntity : serviceFacade.getControllerServicesReferencingParameter(groupId)) {
+                                final Authorizable serviceAuthorizable = lookup.getControllerService(affectedComponentEntity.getId()).getAuthorizable();
+                                serviceAuthorizable.authorize(authorizer, RequestAction.READ, user);
+                                serviceAuthorizable.authorize(authorizer, RequestAction.WRITE, user);
+                            }
+                        }
+                    }
                 },
                 () -> serviceFacade.verifyUpdateProcessGroup(requestProcessGroupDTO),
                 (revision, processGroupEntity) -> {
@@ -1165,7 +1210,7 @@ private VariableRegistryUpdateRequest createVariableRegistryUpdateRequest(final
             .map(Map.Entry::getKey)
             .collect(Collectors.toList());
 
-        completedRequestIds.stream().forEach(id -> varRegistryUpdateRequests.remove(id));
+        completedRequestIds.forEach(varRegistryUpdateRequests::remove);
 
         final int requestCount = varRegistryUpdateRequests.size();
         if (requestCount > MAX_VARIABLE_REGISTRY_UPDATE_REQUESTS) {
@@ -1589,7 +1634,7 @@ public Response removeProcessGroup(
 
                     // ensure write to this process group and all encapsulated components including templates and controller services. additionally, ensure
                     // read to any referenced services by encapsulated components
-                    authorizeProcessGroup(processGroupAuthorizable, authorizer, lookup, RequestAction.WRITE, true, true, true, false);
+                    authorizeProcessGroup(processGroupAuthorizable, authorizer, lookup, RequestAction.WRITE, true, true, true, false, false);
 
                     // ensure write permission to the parent process group, if applicable... if this is the root group the
                     // request will fail later but still need to handle authorization here
@@ -1725,15 +1770,21 @@ public Response createProcessGroup(
                 serviceFacade,
                 requestProcessGroupEntity,
                 lookup -> {
+                    final NiFiUser user = NiFiUserUtils.getNiFiUser();
                     final Authorizable processGroup = lookup.getProcessGroup(groupId).getAuthorizable();
-                    processGroup.authorize(authorizer, RequestAction.WRITE, NiFiUserUtils.getNiFiUser());
+                    processGroup.authorize(authorizer, RequestAction.WRITE, user);
+
+                    // If request specifies a Parameter Context, need to authorize that user has READ policy for the Parameter Context.
+                    final ParameterContextReferenceDTO referencedParamContext = requestProcessGroupEntity.getComponent().getParameterContext();
+                    if (referencedParamContext != null && referencedParamContext.getId() != null) {
+                        lookup.getParameterContext(referencedParamContext.getId()).authorize(authorizer, RequestAction.READ, user);
+                    }
 
                     // Step 5: If any of the components is a Restricted Component, then we must authorize the user
                     // for write access to the RestrictedComponents resource
                     final VersionedFlowSnapshot versionedFlowSnapshot = requestProcessGroupEntity.getVersionedFlowSnapshot();
                     if (versionedFlowSnapshot != null) {
-                        final Set<ConfigurableComponent> restrictedComponents = FlowRegistryUtils.getRestrictedComponents(
-                                versionedFlowSnapshot.getFlowContents(), serviceFacade);
+                        final Set<ConfigurableComponent> restrictedComponents = FlowRegistryUtils.getRestrictedComponents(versionedFlowSnapshot.getFlowContents(), serviceFacade);
                         restrictedComponents.forEach(restrictedComponent -> {
                             final ComponentAuthorizable restrictedComponentAuthorizable = lookup.getConfigurableComponent(restrictedComponent);
                             authorizeRestrictions(authorizer, restrictedComponentAuthorizable);
@@ -1950,9 +2001,16 @@ public Response createProcessor(
                 lookup -> {
                     final NiFiUser user = NiFiUserUtils.getNiFiUser();
 
-                    final Authorizable processGroup = lookup.getProcessGroup(groupId).getAuthorizable();
+                    final ProcessGroupAuthorizable groupAuthorizable = lookup.getProcessGroup(groupId);
+                    final Authorizable processGroup = groupAuthorizable.getAuthorizable();
                     processGroup.authorize(authorizer, RequestAction.WRITE, user);
 
+                    final Authorizable parameterContext = groupAuthorizable.getProcessGroup().getParameterContext();
+                    final ProcessorConfigDTO configDto = requestProcessor.getConfig();
+                    if (parameterContext != null && configDto != null) {
+                        AuthorizeParameterReference.authorizeParameterReferences(configDto.getProperties(), authorizer, parameterContext, user);
+                    }
+
                     ComponentAuthorizable authorizable = null;
                     try {
                         authorizable = lookup.getConfigurableComponent(requestProcessor.getType(), requestProcessor.getBundle());
@@ -3113,7 +3171,7 @@ public Response copySnippet(
                 requestCopySnippetEntity,
                 lookup -> {
                     final NiFiUser user = NiFiUserUtils.getNiFiUser();
-                    final SnippetAuthorizable snippet = authorizeSnippetUsage(lookup, groupId, requestCopySnippetEntity.getSnippetId(), false);
+                    final SnippetAuthorizable snippet = authorizeSnippetUsage(lookup, groupId, requestCopySnippetEntity.getSnippetId(), false, true);
 
                     final Consumer<ComponentAuthorizable> authorizeRestricted = authorizable -> {
                         if (authorizable.isRestricted()) {
@@ -3124,10 +3182,24 @@ public Response copySnippet(
                     // consider each processor. note - this request will not create new controller services so we do not need to check
                     // for if there are not restricted controller services. it will however, need to authorize the user has access
                     // to any referenced services and this is done within authorizeSnippetUsage above.
-                    snippet.getSelectedProcessors().stream().forEach(authorizeRestricted);
-                    snippet.getSelectedProcessGroups().stream().forEach(processGroup -> {
-                        processGroup.getEncapsulatedProcessors().forEach(authorizeRestricted);
-                    });
+                    // Also ensure that user has READ permissions to the Parameter Contexts in order to copy them.
+                    snippet.getSelectedProcessors().forEach(authorizeRestricted);
+                    for (final ProcessGroupAuthorizable groupAuthorizable : snippet.getSelectedProcessGroups()) {
+                        groupAuthorizable.getEncapsulatedProcessors().forEach(authorizeRestricted);
+
+                        final ParameterContext parameterContext = groupAuthorizable.getProcessGroup().getParameterContext();
+                        if (parameterContext != null) {
+                            parameterContext.authorize(authorizer, RequestAction.READ, user);
+                        }
+
+                        for (final ProcessGroupAuthorizable encapsulatedGroupAuth : groupAuthorizable.getEncapsulatedProcessGroups()) {
+                            final ParameterContext encapsulatedGroupParameterContext = encapsulatedGroupAuth.getProcessGroup().getParameterContext();
+                            if (encapsulatedGroupParameterContext != null) {
+                                encapsulatedGroupParameterContext.authorize(authorizer, RequestAction.READ, user);
+                            }
+
+                        }
+                    }
                 },
                 null,
                 copySnippetRequestEntity -> {
@@ -3282,7 +3354,8 @@ public Response instantiateTemplate(
                     final NiFiUser user = NiFiUserUtils.getNiFiUser();
 
                     // ensure write on the group
-                    final Authorizable processGroup = lookup.getProcessGroup(groupId).getAuthorizable();
+                    final ProcessGroupAuthorizable groupAuthorizable = lookup.getProcessGroup(groupId);
+                    final Authorizable processGroup = groupAuthorizable.getAuthorizable();
                     processGroup.authorize(authorizer, RequestAction.WRITE, user);
 
                     final Authorizable template = lookup.getTemplate(requestInstantiateTemplateRequestEntity.getTemplateId());
@@ -3300,8 +3373,13 @@ public Response instantiateTemplate(
                     // ensure restricted access if necessary
                     templateContents.getEncapsulatedProcessors().forEach(authorizeRestricted);
                     templateContents.getEncapsulatedControllerServices().forEach(authorizeRestricted);
+
+                    final Authorizable parameterContext = groupAuthorizable.getProcessGroup().getParameterContext();
+                    if (parameterContext != null) {
+                        AuthorizeParameterReference.authorizeParameterReferences(requestInstantiateTemplateRequestEntity.getSnippet(), authorizer, parameterContext, user);
+                    }
                 },
-                () -> serviceFacade.verifyComponentTypes(requestInstantiateTemplateRequestEntity.getSnippet()),
+                () -> serviceFacade.verifyCanInstantiate(groupId, requestInstantiateTemplateRequestEntity.getSnippet()),
                 instantiateTemplateRequestEntity -> {
                     final FlowSnippetDTO snippet = instantiateTemplateRequestEntity.getSnippet();
 
@@ -3359,7 +3437,9 @@ private IllegalStateException toPublicPortUniqueConstraintViolationException(fin
     // templates
     // ---------
 
-    private SnippetAuthorizable authorizeSnippetUsage(final AuthorizableLookup lookup, final String groupId, final String snippetId, final boolean authorizeTransitiveServices) {
+    private SnippetAuthorizable authorizeSnippetUsage(final AuthorizableLookup lookup, final String groupId, final String snippetId,
+                                                      final boolean authorizeTransitiveServices, final boolean authorizeParameterReferences) {
+
         final NiFiUser user = NiFiUserUtils.getNiFiUser();
 
         // ensure write access to the target process group
@@ -3367,7 +3447,7 @@ private SnippetAuthorizable authorizeSnippetUsage(final AuthorizableLookup looku
 
         // ensure read permission to every component in the snippet including referenced services
         final SnippetAuthorizable snippet = lookup.getSnippet(snippetId);
-        authorizeSnippet(snippet, authorizer, lookup, RequestAction.READ, true, authorizeTransitiveServices);
+        authorizeSnippet(snippet, authorizer, lookup, RequestAction.READ, true, authorizeTransitiveServices, authorizeParameterReferences);
         return snippet;
     }
 
@@ -3425,7 +3505,7 @@ public Response createTemplate(
                 serviceFacade,
                 requestCreateTemplateRequestEntity,
                 lookup -> {
-                    authorizeSnippetUsage(lookup, groupId, requestCreateTemplateRequestEntity.getSnippetId(), true);
+                    authorizeSnippetUsage(lookup, groupId, requestCreateTemplateRequestEntity.getSnippetId(), true, false);
                 },
                 () -> serviceFacade.verifyCanAddTemplate(groupId, requestCreateTemplateRequestEntity.getName()),
                 createTemplateRequestEntity -> {
@@ -3711,9 +3791,15 @@ public Response createControllerService(
                 lookup -> {
                     final NiFiUser user = NiFiUserUtils.getNiFiUser();
 
-                    final Authorizable processGroup = lookup.getProcessGroup(groupId).getAuthorizable();
+                    final ProcessGroupAuthorizable groupAuthorizable = lookup.getProcessGroup(groupId);
+                    final Authorizable processGroup = groupAuthorizable.getAuthorizable();
                     processGroup.authorize(authorizer, RequestAction.WRITE, user);
 
+                    final Authorizable parameterContext = groupAuthorizable.getProcessGroup().getParameterContext();
+                    if (parameterContext != null) {
+                        AuthorizeParameterReference.authorizeParameterReferences(requestControllerService.getProperties(), authorizer, parameterContext, user);
+                    }
+
                     ComponentAuthorizable authorizable = null;
                     try {
                         authorizable = lookup.getConfigurableComponent(requestControllerService.getType(), requestControllerService.getBundle());
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ProcessorResource.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ProcessorResource.java
index 0d29d603619..d069b7f72a8 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ProcessorResource.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ProcessorResource.java
@@ -24,6 +24,7 @@
 import io.swagger.annotations.Authorization;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.nifi.authorization.AuthorizeControllerServiceReference;
+import org.apache.nifi.authorization.AuthorizeParameterReference;
 import org.apache.nifi.authorization.Authorizer;
 import org.apache.nifi.authorization.ComponentAuthorizable;
 import org.apache.nifi.authorization.RequestAction;
@@ -518,7 +519,7 @@ public Response updateProcessor(
             @ApiParam(
                     value = "The processor configuration details.",
                     required = true
-            ) final ProcessorEntity requestProcessorEntity) throws InterruptedException {
+            ) final ProcessorEntity requestProcessorEntity) {
 
         if (requestProcessorEntity == null || requestProcessorEntity.getComponent() == null) {
             throw new IllegalArgumentException("Processor details must be specified.");
@@ -563,6 +564,7 @@ public Response updateProcessor(
                     final ProcessorConfigDTO config = requestProcessorDTO.getConfig();
                     if (config != null) {
                         AuthorizeControllerServiceReference.authorizeControllerServiceReferences(config.getProperties(), authorizable, authorizer, lookup);
+                        AuthorizeParameterReference.authorizeParameterReferences(config.getProperties(), authorizer, authorizable.getParameterContext(), user);
                     }
                 },
                 () -> serviceFacade.verifyUpdateProcessor(requestProcessorDTO),
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/SnippetResource.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/SnippetResource.java
index c00c8b3f328..abc3ee2975c 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/SnippetResource.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/SnippetResource.java
@@ -24,11 +24,15 @@
 import io.swagger.annotations.Authorization;
 import org.apache.nifi.authorization.AccessDeniedException;
 import org.apache.nifi.authorization.AuthorizableLookup;
+import org.apache.nifi.authorization.AuthorizeParameterReference;
 import org.apache.nifi.authorization.Authorizer;
+import org.apache.nifi.authorization.ComponentAuthorizable;
 import org.apache.nifi.authorization.RequestAction;
 import org.apache.nifi.authorization.SnippetAuthorizable;
 import org.apache.nifi.authorization.resource.Authorizable;
+import org.apache.nifi.authorization.user.NiFiUser;
 import org.apache.nifi.authorization.user.NiFiUserUtils;
+import org.apache.nifi.groups.ProcessGroup;
 import org.apache.nifi.web.NiFiServiceFacade;
 import org.apache.nifi.web.Revision;
 import org.apache.nifi.web.api.dto.SnippetDTO;
@@ -111,7 +115,7 @@ private void authorizeSnippetRequest(final SnippetDTO snippetRequest, final Auth
         snippetRequest.getProcessGroups().keySet().stream().map(id -> lookup.getProcessGroup(id)).forEach(processGroupAuthorizable -> {
             // we are not checking referenced services since we do not know how this snippet will be used. these checks should be performed
             // in a subsequent action with this snippet
-            authorizeProcessGroup(processGroupAuthorizable, authorizer, lookup, action, false, false, false, false);
+            authorizeProcessGroup(processGroupAuthorizable, authorizer, lookup, action, false, false, false, false, false);
         });
         snippetRequest.getRemoteProcessGroups().keySet().stream().map(id -> lookup.getRemoteProcessGroup(id)).forEach(authorize);
         snippetRequest.getProcessors().keySet().stream().map(id -> lookup.getProcessor(id).getAuthorizable()).forEach(authorize);
@@ -272,16 +276,26 @@ public Response updateSnippet(
                 requestSnippetEntity,
                 requestRevisions,
                 lookup -> {
+                    final NiFiUser user = NiFiUserUtils.getNiFiUser();
+
                     // ensure write access to the target process group
                     if (requestSnippetDTO.getParentGroupId() != null) {
-                        lookup.getProcessGroup(requestSnippetDTO.getParentGroupId()).getAuthorizable().authorize(authorizer, RequestAction.WRITE, NiFiUserUtils.getNiFiUser());
+                        lookup.getProcessGroup(requestSnippetDTO.getParentGroupId()).getAuthorizable().authorize(authorizer, RequestAction.WRITE, user);
                     }
 
                     // ensure write permission to every component in the snippet excluding referenced services
                     final SnippetAuthorizable snippet = lookup.getSnippet(snippetId);
-                    authorizeSnippet(snippet, authorizer, lookup, RequestAction.WRITE, false, false);
+
+                    // Note: we are explicitly not authorizing parameter references here because they are being authorized below
+                    authorizeSnippet(snippet, authorizer, lookup, RequestAction.WRITE, false, false, false);
+
+                    final ProcessGroup destinationGroup = lookup.getProcessGroup(requestSnippetDTO.getParentGroupId()).getProcessGroup();
+
+                    for (final ComponentAuthorizable componentAuthorizable : snippet.getSelectedProcessors()) {
+                        AuthorizeParameterReference.authorizeParameterReferences(destinationGroup, componentAuthorizable, authorizer, user);
+                    }
                 },
-                () -> serviceFacade.verifyUpdateSnippet(requestSnippetDTO, requestRevisions.stream().map(rev -> rev.getComponentId()).collect(Collectors.toSet())),
+                () -> serviceFacade.verifyUpdateSnippet(requestSnippetDTO, requestRevisions.stream().map(Revision::getComponentId).collect(Collectors.toSet())),
                 (revisions, snippetEntity) -> {
                     // update the snippet
                     final SnippetEntity entity = serviceFacade.updateSnippet(revisions, snippetEntity.getSnippet());
@@ -350,10 +364,10 @@ public Response deleteSnippet(
                 lookup -> {
                     // ensure write permission to every component in the snippet excluding referenced services
                     final SnippetAuthorizable snippet = lookup.getSnippet(snippetId);
-                    authorizeSnippet(snippet, authorizer, lookup, RequestAction.WRITE, true, false);
+                    authorizeSnippet(snippet, authorizer, lookup, RequestAction.WRITE, true, false, false);
 
                     // ensure write permission to the parent process group
-                    snippet.getParentProcessGroup().authorize(authorizer, RequestAction.WRITE, NiFiUserUtils.getNiFiUser());
+                    snippet.getParentProcessGroup().getAuthorizable().authorize(authorizer, RequestAction.WRITE, NiFiUserUtils.getNiFiUser());
                 },
                 () -> serviceFacade.verifyDeleteSnippet(snippetId, requestRevisions.stream().map(rev -> rev.getComponentId()).collect(Collectors.toSet())),
                 (revisions, entity) -> {
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/VersionsResource.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/VersionsResource.java
index 6d9c42a074c..955a0202417 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/VersionsResource.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/VersionsResource.java
@@ -25,6 +25,7 @@
 import io.swagger.annotations.Authorization;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.nifi.authorization.AccessDeniedException;
+import org.apache.nifi.authorization.AuthorizeParameterReference;
 import org.apache.nifi.authorization.Authorizer;
 import org.apache.nifi.authorization.ComponentAuthorizable;
 import org.apache.nifi.authorization.ProcessGroupAuthorizable;
@@ -52,6 +53,8 @@
 import org.apache.nifi.web.api.concurrent.AsynchronousWebRequest;
 import org.apache.nifi.web.api.concurrent.RequestManager;
 import org.apache.nifi.web.api.concurrent.StandardAsynchronousWebRequest;
+import org.apache.nifi.web.api.concurrent.StandardUpdateStep;
+import org.apache.nifi.web.api.concurrent.UpdateStep;
 import org.apache.nifi.web.api.dto.AffectedComponentDTO;
 import org.apache.nifi.web.api.dto.DtoFactory;
 import org.apache.nifi.web.api.dto.RevisionDTO;
@@ -72,6 +75,7 @@
 import org.apache.nifi.web.util.AffectedComponentUtils;
 import org.apache.nifi.web.util.CancellableTimedPause;
 import org.apache.nifi.web.util.ComponentLifecycle;
+import org.apache.nifi.web.util.InvalidComponentAction;
 import org.apache.nifi.web.util.LifecycleManagementException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -93,11 +97,12 @@
 import javax.ws.rs.core.Response.Status;
 import java.net.URI;
 import java.net.URISyntaxException;
+import java.util.ArrayList;
 import java.util.Collections;
-import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
@@ -116,7 +121,8 @@ public class VersionsResource extends ApplicationResource {
     private ComponentLifecycle localComponentLifecycle;
     private DtoFactory dtoFactory;
 
-    private RequestManager<VersionControlInformationEntity> requestManager = new AsyncRequestManager<>(100, TimeUnit.MINUTES.toMillis(1L), "Version Control Update Thread");
+    private RequestManager<VersionControlInformationEntity, VersionControlInformationEntity> requestManager = new AsyncRequestManager<>(100, TimeUnit.MINUTES.toMillis(1L),
+        "Version Control Update Thread");
 
     // We need to ensure that only a single Version Control Request can occur throughout the flow.
     // Otherwise, User 1 could log into Node 1 and choose to Version Control Group A.
@@ -533,7 +539,7 @@ public Response saveToFlowRegistry(
                 processGroup.authorize(authorizer, RequestAction.WRITE, NiFiUserUtils.getNiFiUser());
 
                 // require read to this group and all descendants
-                authorizeProcessGroup(groupAuthorizable, authorizer, lookup, RequestAction.READ, true, false, true, true);
+                authorizeProcessGroup(groupAuthorizable, authorizer, lookup, RequestAction.READ, true, false, true, true, true);
             },
             () -> {
                 final VersionedFlowDTO versionedFlow = requestEntity.getVersionedFlow();
@@ -897,24 +903,24 @@ private Response retrieveRequest(final String requestType, final String requestI
         final NiFiUser user = NiFiUserUtils.getNiFiUser();
 
         // request manager will ensure that the current is the user that submitted this request
-        final AsynchronousWebRequest<VersionControlInformationEntity> asyncRequest = requestManager.getRequest(requestType, requestId, user);
+        final AsynchronousWebRequest<VersionControlInformationEntity, VersionControlInformationEntity> asyncRequest = requestManager.getRequest(requestType, requestId, user);
 
         final VersionedFlowUpdateRequestDTO updateRequestDto = new VersionedFlowUpdateRequestDTO();
         updateRequestDto.setComplete(asyncRequest.isComplete());
         updateRequestDto.setFailureReason(asyncRequest.getFailureReason());
         updateRequestDto.setLastUpdated(asyncRequest.getLastUpdated());
-        updateRequestDto.setProcessGroupId(asyncRequest.getProcessGroupId());
+        updateRequestDto.setProcessGroupId(asyncRequest.getComponentId());
         updateRequestDto.setRequestId(requestId);
         updateRequestDto.setUri(generateResourceUri("versions", requestType, requestId));
         updateRequestDto.setState(asyncRequest.getState());
         updateRequestDto.setPercentCompleted(asyncRequest.getPercentComplete());
 
         if (updateRequestDto.isComplete()) {
-            final VersionControlInformationEntity vciEntity = serviceFacade.getVersionControlInformation(asyncRequest.getProcessGroupId());
+            final VersionControlInformationEntity vciEntity = serviceFacade.getVersionControlInformation(asyncRequest.getComponentId());
             updateRequestDto.setVersionControlInformation(vciEntity == null ? null : vciEntity.getVersionControlInformation());
         }
 
-        final RevisionDTO groupRevision = serviceFacade.getProcessGroup(asyncRequest.getProcessGroupId()).getRevision();
+        final RevisionDTO groupRevision = serviceFacade.getProcessGroup(asyncRequest.getComponentId()).getRevision();
 
         final VersionedFlowUpdateRequestEntity updateRequestEntity = new VersionedFlowUpdateRequestEntity();
         updateRequestEntity.setProcessGroupRevision(groupRevision);
@@ -1000,7 +1006,7 @@ private Response deleteRequest(final String requestType, final String requestId,
         final NiFiUser user = NiFiUserUtils.getNiFiUser();
 
         // request manager will ensure that the current is the user that submitted this request
-        final AsynchronousWebRequest<VersionControlInformationEntity> asyncRequest = requestManager.removeRequest(requestType, requestId, user);
+        final AsynchronousWebRequest<VersionControlInformationEntity, VersionControlInformationEntity> asyncRequest = requestManager.removeRequest(requestType, requestId, user);
         if (asyncRequest == null) {
             throw new ResourceNotFoundException("Could not find request of type " + requestType + " with ID " + requestId);
         }
@@ -1013,18 +1019,18 @@ private Response deleteRequest(final String requestType, final String requestId,
         updateRequestDto.setComplete(asyncRequest.isComplete());
         updateRequestDto.setFailureReason(asyncRequest.getFailureReason());
         updateRequestDto.setLastUpdated(asyncRequest.getLastUpdated());
-        updateRequestDto.setProcessGroupId(asyncRequest.getProcessGroupId());
+        updateRequestDto.setProcessGroupId(asyncRequest.getComponentId());
         updateRequestDto.setRequestId(requestId);
         updateRequestDto.setUri(generateResourceUri("versions", requestType, requestId));
         updateRequestDto.setPercentCompleted(asyncRequest.getPercentComplete());
         updateRequestDto.setState(asyncRequest.getState());
 
         if (updateRequestDto.isComplete()) {
-            final VersionControlInformationEntity vciEntity = serviceFacade.getVersionControlInformation(asyncRequest.getProcessGroupId());
+            final VersionControlInformationEntity vciEntity = serviceFacade.getVersionControlInformation(asyncRequest.getComponentId());
             updateRequestDto.setVersionControlInformation(vciEntity == null ? null : vciEntity.getVersionControlInformation());
         }
 
-        final RevisionDTO groupRevision = serviceFacade.getProcessGroup(asyncRequest.getProcessGroupId()).getRevision();
+        final RevisionDTO groupRevision = serviceFacade.getProcessGroup(asyncRequest.getComponentId()).getRevision();
 
         final VersionedFlowUpdateRequestEntity updateRequestEntity = new VersionedFlowUpdateRequestEntity();
         updateRequestEntity.setProcessGroupRevision(groupRevision);
@@ -1054,7 +1060,8 @@ private Response deleteRequest(final String requestType, final String requestId,
                 @Authorization(value = "Write - /process-groups/{uuid}"),
                 @Authorization(value = "Read - /{component-type}/{uuid} - For all encapsulated components"),
                 @Authorization(value = "Write - /{component-type}/{uuid} - For all encapsulated components"),
-                @Authorization(value = "Write - if the template contains any restricted components - /restricted-components")
+                @Authorization(value = "Write - if the template contains any restricted components - /restricted-components"),
+                @Authorization(value = "Read - /parameter-contexts/{uuid} - For any Parameter Context that is referenced by a Property that is changed, added, or removed")
             })
     @ApiResponses(value = {
         @ApiResponse(code = 400, message = "NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."),
@@ -1165,8 +1172,8 @@ public Response initiateVersionControlUpdate(
             lookup -> {
                 // Step 2: Verify READ and WRITE permissions for user, for every component.
                 final ProcessGroupAuthorizable groupAuthorizable = lookup.getProcessGroup(groupId);
-                authorizeProcessGroup(groupAuthorizable, authorizer, lookup, RequestAction.READ, true, false, true, true);
-                authorizeProcessGroup(groupAuthorizable, authorizer, lookup, RequestAction.WRITE, true, false, true, true);
+                authorizeProcessGroup(groupAuthorizable, authorizer, lookup, RequestAction.READ, true, false, true, true, true);
+                authorizeProcessGroup(groupAuthorizable, authorizer, lookup, RequestAction.WRITE, true, false, true, true, false);
 
                 final VersionedProcessGroup groupContents = flowSnapshot.getFlowContents();
                 final Set<ConfigurableComponent> restrictedComponents = FlowRegistryUtils.getRestrictedComponents(groupContents, serviceFacade);
@@ -1187,24 +1194,25 @@ public Response initiateVersionControlUpdate(
                 // Create an asynchronous request that will occur in the background, because this request may
                 // result in stopping components, which can take an indeterminate amount of time.
                 final String requestId = UUID.randomUUID().toString();
-                final AsynchronousWebRequest<VersionControlInformationEntity> request = new StandardAsynchronousWebRequest<>(requestId, groupId, user, "Stopping Affected Processors");
+                final AsynchronousWebRequest<VersionControlInformationEntity, VersionControlInformationEntity> request = new StandardAsynchronousWebRequest<>(requestId, requestEntity, groupId, user,
+                    getUpdateSteps());
 
                 // Submit the request to be performed in the background
-                final Consumer<AsynchronousWebRequest<VersionControlInformationEntity>> updateTask = vcur -> {
+                final Consumer<AsynchronousWebRequest<VersionControlInformationEntity, VersionControlInformationEntity>> updateTask = vcur -> {
                     try {
                         final VersionControlInformationEntity updatedVersionControlEntity = updateFlowVersion(groupId, wrapper.getComponentLifecycle(), wrapper.getExampleUri(),
                             wrapper.getAffectedComponents(), wrapper.isReplicateRequest(), revision, wrapper.getVersionControlInformationEntity(), wrapper.getFlowSnapshot(), request,
                             idGenerationSeed, true, true);
 
-                        vcur.markComplete(updatedVersionControlEntity);
+                        vcur.markStepComplete(updatedVersionControlEntity);
                     } catch (final ResumeFlowException rfe) {
                         // Treat ResumeFlowException differently because we don't want to include a message that we couldn't update the flow
                         // since in this case the flow was successfully updated - we just couldn't re-enable the components.
                         logger.error(rfe.getMessage(), rfe);
-                        vcur.setFailureReason(rfe.getMessage());
+                        vcur.fail(rfe.getMessage());
                     } catch (final Exception e) {
                         logger.error("Failed to update flow to new version", e);
-                        vcur.setFailureReason("Failed to update flow to new version due to " + e);
+                        vcur.fail("Failed to update flow to new version due to " + e);
                     }
                 };
 
@@ -1230,7 +1238,15 @@ public Response initiateVersionControlUpdate(
             });
     }
 
-
+    private List<UpdateStep> getUpdateSteps() {
+        final List<UpdateStep> updateSteps = new ArrayList<>();
+        updateSteps.add(new StandardUpdateStep("Stopping Affected Processors"));
+        updateSteps.add(new StandardUpdateStep("Disabling Affected Controller Services"));
+        updateSteps.add(new StandardUpdateStep("Updating Flow"));
+        updateSteps.add(new StandardUpdateStep("Re-Enabling Controller Services"));
+        updateSteps.add(new StandardUpdateStep("Restarting Affected Processors"));
+        return updateSteps;
+    }
 
     @POST
     @Consumes(MediaType.APPLICATION_JSON)
@@ -1252,7 +1268,8 @@ public Response initiateVersionControlUpdate(
                 @Authorization(value = "Write - /process-groups/{uuid}"),
                 @Authorization(value = "Read - /{component-type}/{uuid} - For all encapsulated components"),
                 @Authorization(value = "Write - /{component-type}/{uuid} - For all encapsulated components"),
-                @Authorization(value = "Write - if the template contains any restricted components - /restricted-components")
+                @Authorization(value = "Write - if the template contains any restricted components - /restricted-components"),
+                @Authorization(value = "Read - /parameter-contexts/{uuid} - For any Parameter Context that is referenced by a Property that is changed, added, or removed")
             })
     @ApiResponses(value = {
         @ApiResponse(code = 400, message = "NiFi was unable to complete the request because it was invalid. The request should not be retried without modification."),
@@ -1329,8 +1346,8 @@ public Response initiateRevertFlowVersion(@ApiParam("The process group id.") @Pa
             lookup -> {
                 // Step 2: Verify READ and WRITE permissions for user, for every component.
                 final ProcessGroupAuthorizable groupAuthorizable = lookup.getProcessGroup(groupId);
-                authorizeProcessGroup(groupAuthorizable, authorizer, lookup, RequestAction.READ, true, false, true, true);
-                authorizeProcessGroup(groupAuthorizable, authorizer, lookup, RequestAction.WRITE, true, false, true, true);
+                authorizeProcessGroup(groupAuthorizable, authorizer, lookup, RequestAction.READ, true, false, true, true, true);
+                authorizeProcessGroup(groupAuthorizable, authorizer, lookup, RequestAction.WRITE, true, false, true, true, false);
 
                 final VersionedProcessGroup groupContents = flowSnapshot.getFlowContents();
                 final Set<ConfigurableComponent> restrictedComponents = FlowRegistryUtils.getRestrictedComponents(groupContents, serviceFacade);
@@ -1373,24 +1390,25 @@ public Response initiateRevertFlowVersion(@ApiParam("The process group id.") @Pa
                 // Create an asynchronous request that will occur in the background, because this request may
                 // result in stopping components, which can take an indeterminate amount of time.
                 final String requestId = UUID.randomUUID().toString();
-                final AsynchronousWebRequest<VersionControlInformationEntity> request = new StandardAsynchronousWebRequest<>(requestId, groupId, user, "Stopping Affected Processors");
+                final AsynchronousWebRequest<VersionControlInformationEntity, VersionControlInformationEntity> request = new StandardAsynchronousWebRequest<>(requestId, requestEntity, groupId, user,
+                    getUpdateSteps());
 
                 // Submit the request to be performed in the background
-                final Consumer<AsynchronousWebRequest<VersionControlInformationEntity>> updateTask = vcur -> {
+                final Consumer<AsynchronousWebRequest<VersionControlInformationEntity, VersionControlInformationEntity>> updateTask = vcur -> {
                     try {
                         final VersionControlInformationEntity updatedVersionControlEntity = updateFlowVersion(groupId, wrapper.getComponentLifecycle(), wrapper.getExampleUri(),
                             wrapper.getAffectedComponents(), wrapper.isReplicateRequest(), revision, versionControlInformationEntity, wrapper.getFlowSnapshot(), request,
                             idGenerationSeed, false, true);
 
-                        vcur.markComplete(updatedVersionControlEntity);
+                        vcur.markStepComplete(updatedVersionControlEntity);
                     } catch (final ResumeFlowException rfe) {
                         // Treat ResumeFlowException differently because we don't want to include a message that we couldn't update the flow
                         // since in this case the flow was successfully updated - we just couldn't re-enable the components.
                         logger.error(rfe.getMessage(), rfe);
-                        vcur.setFailureReason(rfe.getMessage());
+                        vcur.fail(rfe.getMessage());
                     } catch (final Exception e) {
                         logger.error("Failed to update flow to new version", e);
-                        vcur.setFailureReason("Failed to update flow to new version due to " + e.getMessage());
+                        vcur.fail("Failed to update flow to new version due to " + e.getMessage());
                     }
                 };
 
@@ -1419,7 +1437,7 @@ public Response initiateRevertFlowVersion(@ApiParam("The process group id.") @Pa
 
     private VersionControlInformationEntity updateFlowVersion(final String groupId, final ComponentLifecycle componentLifecycle, final URI exampleUri,
         final Set<AffectedComponentEntity> affectedComponents, final boolean replicateRequest, final Revision revision, final VersionControlInformationEntity requestEntity,
-        final VersionedFlowSnapshot flowSnapshot, final AsynchronousWebRequest<VersionControlInformationEntity> asyncRequest, final String idGenerationSeed,
+        final VersionedFlowSnapshot flowSnapshot, final AsynchronousWebRequest<VersionControlInformationEntity, VersionControlInformationEntity> asyncRequest, final String idGenerationSeed,
         final boolean verifyNotModified, final boolean updateDescendantVersionedFlows) throws LifecycleManagementException, ResumeFlowException {
 
         // Steps 6-7: Determine which components must be stopped and stop them.
@@ -1438,12 +1456,12 @@ private VersionControlInformationEntity updateFlowVersion(final String groupId,
         logger.info("Stopping {} Processors", runningComponents.size());
         final CancellableTimedPause stopComponentsPause = new CancellableTimedPause(250, Long.MAX_VALUE, TimeUnit.MILLISECONDS);
         asyncRequest.setCancelCallback(stopComponentsPause::cancel);
-        componentLifecycle.scheduleComponents(exampleUri, groupId, runningComponents, ScheduledState.STOPPED, stopComponentsPause);
+        componentLifecycle.scheduleComponents(exampleUri, groupId, runningComponents, ScheduledState.STOPPED, stopComponentsPause, InvalidComponentAction.SKIP);
 
         if (asyncRequest.isCancelled()) {
             return null;
         }
-        asyncRequest.update(new Date(), "Disabling Affected Controller Services", 20);
+        asyncRequest.markStepComplete();
 
         // Steps 8-9. Disable enabled controller services that are affected
         final Set<AffectedComponentEntity> enabledServices = affectedComponents.stream()
@@ -1454,12 +1472,12 @@ private VersionControlInformationEntity updateFlowVersion(final String groupId,
         logger.info("Disabling {} Controller Services", enabledServices.size());
         final CancellableTimedPause disableServicesPause = new CancellableTimedPause(250, Long.MAX_VALUE, TimeUnit.MILLISECONDS);
         asyncRequest.setCancelCallback(disableServicesPause::cancel);
-        componentLifecycle.activateControllerServices(exampleUri, groupId, enabledServices, ControllerServiceState.DISABLED, disableServicesPause);
+        componentLifecycle.activateControllerServices(exampleUri, groupId, enabledServices, ControllerServiceState.DISABLED, disableServicesPause, InvalidComponentAction.SKIP);
 
         if (asyncRequest.isCancelled()) {
             return null;
         }
-        asyncRequest.update(new Date(), "Updating Flow", 40);
+        asyncRequest.markStepComplete();
 
         logger.info("Updating Process Group with ID {} to version {} of the Versioned Flow", groupId, flowSnapshot.getSnapshotMetadata().getVersion());
 
@@ -1543,7 +1561,7 @@ private VersionControlInformationEntity updateFlowVersion(final String groupId,
                     logger.debug("Re-Enabling {} Controller Services: {}", enabledServices.size(), enabledServices);
                 }
 
-                asyncRequest.update(new Date(), "Re-Enabling Controller Services", 60);
+                asyncRequest.markStepComplete();
 
                 // Step 13. Re-enable all disabled controller services
                 final CancellableTimedPause enableServicesPause = new CancellableTimedPause(250, Long.MAX_VALUE, TimeUnit.MILLISECONDS);
@@ -1552,7 +1570,7 @@ private VersionControlInformationEntity updateFlowVersion(final String groupId,
                 logger.info("Successfully updated flow; re-enabling {} Controller Services", servicesToEnable.size());
 
                 try {
-                    componentLifecycle.activateControllerServices(exampleUri, groupId, servicesToEnable, ControllerServiceState.ENABLED, enableServicesPause);
+                    componentLifecycle.activateControllerServices(exampleUri, groupId, servicesToEnable, ControllerServiceState.ENABLED, enableServicesPause, InvalidComponentAction.SKIP);
                 } catch (final IllegalStateException ise) {
                     // Component Lifecycle will re-enable the Controller Services only if they are valid. If IllegalStateException gets thrown, we need to provide
                     // a more intelligent error message as to exactly what happened, rather than indicate that the flow could not be updated.
@@ -1565,7 +1583,7 @@ private VersionControlInformationEntity updateFlowVersion(final String groupId,
                     logger.debug("Restart {} Processors: {}", runningComponents.size(), runningComponents);
                 }
 
-                asyncRequest.update(new Date(), "Restarting Processors", 80);
+                asyncRequest.markStepComplete();
 
                 // Step 14. Restart all components
                 final Set<AffectedComponentEntity> componentsToStart = getUpdatedEntities(runningComponents);
@@ -1604,7 +1622,7 @@ private VersionControlInformationEntity updateFlowVersion(final String groupId,
                 logger.info("Restarting {} Processors", componentsToStart.size());
 
                 try {
-                    componentLifecycle.scheduleComponents(exampleUri, groupId, componentsToStart, ScheduledState.RUNNING, startComponentsPause);
+                    componentLifecycle.scheduleComponents(exampleUri, groupId, componentsToStart, ScheduledState.RUNNING, startComponentsPause, InvalidComponentAction.SKIP);
                 } catch (final IllegalStateException ise) {
                     // Component Lifecycle will restart the Processors only if they are valid. If IllegalStateException gets thrown, we need to provide
                     // a more intelligent error message as to exactly what happened, rather than indicate that the flow could not be updated.
@@ -1617,7 +1635,6 @@ private VersionControlInformationEntity updateFlowVersion(final String groupId,
         if (asyncRequest.isCancelled()) {
             return null;
         }
-        asyncRequest.update(new Date(), "Complete", 100);
 
         return serviceFacade.getVersionControlInformation(groupId);
     }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/AsyncRequestManager.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/AsyncRequestManager.java
index 3f7ad636f71..4ac11bfeaf9 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/AsyncRequestManager.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/AsyncRequestManager.java
@@ -42,12 +42,12 @@
 import java.util.function.Consumer;
 import java.util.stream.Collectors;
 
-public class AsyncRequestManager<T> implements RequestManager<T> {
+public class AsyncRequestManager<R, T> implements RequestManager<R, T> {
     private static final Logger logger = LoggerFactory.getLogger(AsyncRequestManager.class);
 
     private final long requestExpirationMillis;
     private final int maxConcurrentRequests;
-    private final ConcurrentMap<String, AsynchronousWebRequest<T>> requests = new ConcurrentHashMap<>();
+    private final ConcurrentMap<String, AsynchronousWebRequest<R, T>> requests = new ConcurrentHashMap<>();
 
     private final ExecutorService threadPool;
 
@@ -57,7 +57,7 @@ public AsyncRequestManager(final int maxConcurrentRequests, final long requestEx
         this.maxConcurrentRequests = maxConcurrentRequests;
 
         this.threadPool = new ThreadPoolExecutor(1, 50, 5L, TimeUnit.SECONDS,
-            new ArrayBlockingQueue<Runnable>(maxConcurrentRequests),
+            new ArrayBlockingQueue<>(maxConcurrentRequests),
             new ThreadFactory() {
                 private final AtomicLong counter = new AtomicLong(0L);
 
@@ -77,7 +77,7 @@ private String getKey(final String type, final String request) {
     }
 
     @Override
-    public void submitRequest(final String type, final String requestId, final AsynchronousWebRequest<T> request, final Consumer<AsynchronousWebRequest<T>> task) {
+    public void submitRequest(final String type, final String requestId, final AsynchronousWebRequest<R, T> request, final Consumer<AsynchronousWebRequest<R, T>> task) {
         Objects.requireNonNull(type);
         Objects.requireNonNull(requestId);
         Objects.requireNonNull(request);
@@ -92,7 +92,7 @@ public void submitRequest(final String type, final String requestId, final Async
             .map(Map.Entry::getKey)
             .collect(Collectors.toList());
 
-        completedRequestIds.stream().forEach(id -> requests.remove(id));
+        completedRequestIds.forEach(requests::remove);
 
         final int requestCount = requests.size();
         if (requestCount > maxConcurrentRequests) {
@@ -101,7 +101,7 @@ public void submitRequest(final String type, final String requestId, final Async
         }
 
         final String key = getKey(type, requestId);
-        final AsynchronousWebRequest<T> existing = this.requests.putIfAbsent(key, request);
+        final AsynchronousWebRequest<R, T> existing = this.requests.putIfAbsent(key, request);
         if (existing != null) {
             throw new IllegalArgumentException("A requests already exists with this ID and type");
         }
@@ -117,7 +117,7 @@ public void run() {
                     task.accept(request);
                 } catch (final Exception e) {
                     logger.error("Failed to perform asynchronous task", e);
-                    request.setFailureReason("Encountered unexpected error when performing asynchronous task: " + e);
+                    request.fail("Encountered unexpected error when performing asynchronous task: " + e);
                 } finally {
                     // clear the authentication token
                     SecurityContextHolder.getContext().setAuthentication(null);
@@ -128,13 +128,13 @@ public void run() {
 
 
     @Override
-    public AsynchronousWebRequest<T> removeRequest(final String type, final String id, final NiFiUser user) {
+    public AsynchronousWebRequest<R, T> removeRequest(final String type, final String id, final NiFiUser user) {
         Objects.requireNonNull(type);
         Objects.requireNonNull(id);
         Objects.requireNonNull(user);
 
         final String key = getKey(type, id);
-        final AsynchronousWebRequest<T> request = requests.get(key);
+        final AsynchronousWebRequest<R, T> request = requests.get(key);
         if (request == null) {
             throw new ResourceNotFoundException("Could not find a Request with identifier " + id);
         }
@@ -151,13 +151,13 @@ public AsynchronousWebRequest<T> removeRequest(final String type, final String i
     }
 
     @Override
-    public AsynchronousWebRequest<T> getRequest(final String type, final String id, final NiFiUser user) {
+    public AsynchronousWebRequest<R, T> getRequest(final String type, final String id, final NiFiUser user) {
         Objects.requireNonNull(type);
         Objects.requireNonNull(id);
         Objects.requireNonNull(user);
 
         final String key = getKey(type, id);
-        final AsynchronousWebRequest<T> request = requests.get(key);
+        final AsynchronousWebRequest<R, T> request = requests.get(key);
         if (request == null) {
             throw new ResourceNotFoundException("Could not find a Request with identifier " + id);
         }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/AsynchronousWebRequest.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/AsynchronousWebRequest.java
index 3cecdebb528..9e21e4ccefc 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/AsynchronousWebRequest.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/AsynchronousWebRequest.java
@@ -20,13 +20,14 @@
 import org.apache.nifi.authorization.user.NiFiUser;
 
 import java.util.Date;
+import java.util.List;
 
-public interface AsynchronousWebRequest<T> {
+public interface AsynchronousWebRequest<R, T> {
 
     /**
-     * @return the ID of the process group that the request is for
+     * @return the ID of the component that the request is for
      */
-    String getProcessGroupId();
+    String getComponentId();
 
     /**
      * @return whether or not this request has completed
@@ -38,43 +39,34 @@
      */
     Date getLastUpdated();
 
-    /**
-     * @return the current state of the request
-     */
-    public String getState();
+    List<UpdateStep> getUpdateSteps();
 
-    /**
-     * @return the current percent complete, between 0 and 100 (inclusive)
-     */
-    public int getPercentComplete();
+    UpdateStep getCurrentStep();
+
+    void markStepComplete();
+
+    void markStepComplete(T results);
+
+    String getState();
+
+    R getRequest();
 
     /**
-     * Updates the request to indicate the new state and percent complete
-     *
-     * @param date the last updated time
-     * @param state the new state
-     * @param percentComplete The percentage complete, between 0 and 100 (inclusive)
+     * @return the current percent complete, between 0 and 100 (inclusive)
      */
-    void update(Date date, String state, int percentComplete);
+    int getPercentComplete();
 
     /**
      * @return the user who submitted the request
      */
     NiFiUser getUser();
 
-    /**
-     * Indicates that this request has completed, successfully or otherwise
-     *
-     * @param results the results of the request
-     */
-    void markComplete(T results);
-
     /**
      * Updates the request to indicate the reason that the request failed
      *
      * @param explanation the reason that the request failed
      */
-    void setFailureReason(String explanation);
+    void fail(String explanation);
 
     /**
      * Indicates the reason that the request failed, or <code>null</code> if the request has not failed
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/RequestManager.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/RequestManager.java
index f73ed0fb1ca..8232ce66609 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/RequestManager.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/RequestManager.java
@@ -17,12 +17,12 @@
 
 package org.apache.nifi.web.api.concurrent;
 
-import java.util.function.Consumer;
-
 import org.apache.nifi.authorization.user.NiFiUser;
 import org.apache.nifi.web.ResourceNotFoundException;
 
-public interface RequestManager<T> {
+import java.util.function.Consumer;
+
+public interface RequestManager<R, T> {
 
     /**
      * Submits a request to be performed in the background
@@ -36,7 +36,7 @@
      * @throws IllegalArgumentException if a request already exists with the given ID
      * @throws NullPointerException if any argument is null
      */
-    void submitRequest(String requestType, String id, AsynchronousWebRequest<T> request, Consumer<AsynchronousWebRequest<T>> task);
+    void submitRequest(String requestType, String id, AsynchronousWebRequest<R, T> request, Consumer<AsynchronousWebRequest<R, T>> task);
 
     /**
      * Retrieves the request with the given ID
@@ -50,7 +50,7 @@
      * @throws IllegalArgumentException if the user given is not the user that submitted the request
      * @throws NullPointerException if either the ID or the user is null
      */
-    AsynchronousWebRequest<T> getRequest(String requestType, String id, NiFiUser user);
+    AsynchronousWebRequest<R, T> getRequest(String requestType, String id, NiFiUser user);
 
     /**
      * Removes the request with the given ID
@@ -65,6 +65,6 @@
      * @throws IllegalStateException if the request with the given ID is not yet complete
      * @throws NullPointerException if either the ID or the user is null
      */
-    AsynchronousWebRequest<T> removeRequest(String requestType, String id, NiFiUser user);
+    AsynchronousWebRequest<R, T> removeRequest(String requestType, String id, NiFiUser user);
 
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/StandardAsynchronousWebRequest.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/StandardAsynchronousWebRequest.java
index 8e2e221c091..b8aba158606 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/StandardAsynchronousWebRequest.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/StandardAsynchronousWebRequest.java
@@ -17,30 +17,44 @@
 
 package org.apache.nifi.web.api.concurrent;
 
+import org.apache.nifi.authorization.user.NiFiUser;
+
+import java.util.Collections;
 import java.util.Date;
+import java.util.List;
 import java.util.Objects;
 
-import org.apache.nifi.authorization.user.NiFiUser;
-
-public class StandardAsynchronousWebRequest<T> implements AsynchronousWebRequest<T> {
+public class StandardAsynchronousWebRequest<R, T> implements AsynchronousWebRequest<R, T> {
     private final String id;
-    private final String processGroupId;
+    private final String componentId;
     private final NiFiUser user;
+    private final List<UpdateStep> updateSteps;
+    private final R request;
 
     private volatile boolean complete = false;
     private volatile Date lastUpdated = new Date();
-    private volatile String state;
     private volatile int percentComplete;
     private volatile String failureReason;
     private volatile boolean cancelled;
     private volatile T results;
     private volatile Runnable cancelCallback;
 
-    public StandardAsynchronousWebRequest(final String requestId, final String processGroupId, final NiFiUser user, final String state) {
+    private int currentStepIndex = 0;
+
+    public StandardAsynchronousWebRequest(final String requestId, final R request, final String componentId, final NiFiUser user, final List<UpdateStep> updateSteps) {
         this.id = requestId;
-        this.processGroupId = processGroupId;
+        this.componentId = componentId;
         this.user = user;
-        this.state = state;
+        this.updateSteps = updateSteps;
+        this.request = request;
+    }
+
+    public synchronized UpdateStep getCurrentStep() {
+        return (updateSteps == null || updateSteps.size() <= currentStepIndex) ? null : updateSteps.get(currentStepIndex);
+    }
+
+    public R getRequest() {
+        return request;
     }
 
     public String getRequestId() {
@@ -53,8 +67,8 @@ public boolean isComplete() {
     }
 
     @Override
-    public String getProcessGroupId() {
-        return processGroupId;
+    public String getComponentId() {
+        return componentId;
     }
 
     @Override
@@ -63,12 +77,40 @@ public void setCancelCallback(final Runnable runnable) {
     }
 
     @Override
-    public void markComplete(final T results) {
-        this.complete = true;
+    public void markStepComplete() {
+        markStepComplete(this.results);
+    }
+
+    @Override
+    public synchronized void markStepComplete(final T results) {
+        if (isCancelled() || isComplete()) {
+            return;
+        }
+
+        final UpdateStep currentStep = getCurrentStep();
+        if (currentStep != null) {
+            currentStep.markCompleted();
+        }
+
+        currentStepIndex++;
+        this.complete = currentStepIndex >= updateSteps.size();
         this.results = results;
         this.lastUpdated = new Date();
-        this.percentComplete = 100;
-        this.state = "Complete";
+        this.percentComplete = currentStepIndex  * 100 / updateSteps.size();
+    }
+
+    @Override
+    public synchronized String getState() {
+        if (isComplete()) {
+            return "Complete";
+        }
+
+        String failureReason = getFailureReason();
+        if (failureReason != null) {
+            return "Failed: " + failureReason;
+        }
+
+        return getCurrentStep().getDescription();
     }
 
     @Override
@@ -77,8 +119,8 @@ public Date getLastUpdated() {
     }
 
     @Override
-    public String getState() {
-        return state;
+    public List<UpdateStep> getUpdateSteps() {
+        return Collections.unmodifiableList(updateSteps);
     }
 
     @Override
@@ -86,42 +128,23 @@ public int getPercentComplete() {
         return percentComplete;
     }
 
-    @Override
-    public void update(Date date, String state, int percentComplete) {
-        if (percentComplete < 0 || percentComplete > 100) {
-            throw new IllegalArgumentException("Cannot set percent complete to a value of " + percentComplete + "; it must be between 0 and 100.");
-        }
-
-        if (isCancelled()) {
-            throw new IllegalStateException("Cannot update state because request has already been cancelled by user");
-        }
-
-        if (isComplete()) {
-            final String failure = getFailureReason();
-            final String explanation = failure == null ? "successfully" : "with failure reason: " + failure;
-            throw new IllegalStateException("Cannot update state to '" + state + "' because request is already completed " + explanation);
-        }
-
-        this.lastUpdated = date;
-        this.state = state;
-        this.percentComplete = percentComplete;
-    }
-
     @Override
     public NiFiUser getUser() {
         return user;
     }
 
     @Override
-    public void setFailureReason(final String explanation) {
+    public synchronized void fail(final String explanation) {
         this.failureReason = Objects.requireNonNull(explanation);
         this.complete = true;
         this.results = null;
         this.lastUpdated = new Date();
+
+        getCurrentStep().fail(explanation);
     }
 
     @Override
-    public String getFailureReason() {
+    public synchronized String getFailureReason() {
         return failureReason;
     }
 
@@ -134,8 +157,7 @@ public T getResults() {
     public void cancel() {
         this.cancelled = true;
         percentComplete = 100;
-        state = "Canceled by user";
-        setFailureReason("Request cancelled by user");
+        fail("Request cancelled by user");
         cancelCallback.run();
     }
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/StandardUpdateStep.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/StandardUpdateStep.java
new file mode 100644
index 00000000000..53fbbe54d8e
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/StandardUpdateStep.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.concurrent;
+
+public class StandardUpdateStep implements UpdateStep {
+    private final String description;
+    private boolean complete;
+    private String failureReason;
+
+    public StandardUpdateStep(final String description) {
+        this.description = description;
+    }
+
+    @Override
+    public String getDescription() {
+        return description;
+    }
+
+    @Override
+    public synchronized boolean isComplete() {
+        return complete;
+    }
+
+    @Override
+    public synchronized String getFailureReason() {
+        return null;
+    }
+
+    @Override
+    public synchronized void markCompleted() {
+        this.complete = true;
+    }
+
+    @Override
+    public synchronized void fail(final String failureReason) {
+        this.complete = true;
+        this.failureReason = failureReason;
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/UpdateStep.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/UpdateStep.java
new file mode 100644
index 00000000000..7efe98cb3f9
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/concurrent/UpdateStep.java
@@ -0,0 +1,29 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.api.concurrent;
+
+public interface UpdateStep {
+    String getDescription();
+
+    boolean isComplete();
+
+    String getFailureReason();
+
+    void fail(String failureReason);
+
+    void markCompleted();
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/dto/DtoFactory.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/dto/DtoFactory.java
index 542ca6ca832..42117073ce3 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/dto/DtoFactory.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/dto/DtoFactory.java
@@ -65,6 +65,7 @@
 import org.apache.nifi.components.ValidationResult;
 import org.apache.nifi.components.state.Scope;
 import org.apache.nifi.components.state.StateMap;
+import org.apache.nifi.components.validation.ValidationState;
 import org.apache.nifi.components.validation.ValidationStatus;
 import org.apache.nifi.connectable.Connectable;
 import org.apache.nifi.connectable.ConnectableType;
@@ -119,6 +120,10 @@
 import org.apache.nifi.history.History;
 import org.apache.nifi.nar.ExtensionManager;
 import org.apache.nifi.nar.NarClassLoadersHolder;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterDescriptor;
+import org.apache.nifi.parameter.ParameterReferenceManager;
 import org.apache.nifi.processor.Processor;
 import org.apache.nifi.processor.Relationship;
 import org.apache.nifi.provenance.lineage.ComputeLineageResult;
@@ -127,6 +132,7 @@
 import org.apache.nifi.provenance.lineage.LineageNode;
 import org.apache.nifi.provenance.lineage.ProvenanceEventLineageNode;
 import org.apache.nifi.registry.ComponentVariableRegistry;
+import org.apache.nifi.registry.VariableDescriptor;
 import org.apache.nifi.registry.flow.FlowRegistry;
 import org.apache.nifi.registry.flow.VersionControlInformation;
 import org.apache.nifi.registry.flow.VersionedComponent;
@@ -211,8 +217,10 @@
 import org.apache.nifi.web.api.entity.ConnectionStatusSnapshotEntity;
 import org.apache.nifi.web.api.entity.ControllerServiceEntity;
 import org.apache.nifi.web.api.entity.FlowBreadcrumbEntity;
+import org.apache.nifi.web.api.entity.ParameterEntity;
 import org.apache.nifi.web.api.entity.PortEntity;
 import org.apache.nifi.web.api.entity.PortStatusSnapshotEntity;
+import org.apache.nifi.web.api.entity.ProcessGroupEntity;
 import org.apache.nifi.web.api.entity.ProcessGroupStatusSnapshotEntity;
 import org.apache.nifi.web.api.entity.ProcessorEntity;
 import org.apache.nifi.web.api.entity.ProcessorStatusSnapshotEntity;
@@ -1354,6 +1362,63 @@ public PortDTO createPortDto(final Port port) {
         return dto;
     }
 
+    public ParameterContextDTO createParameterContextDto(final ParameterContext parameterContext, final RevisionManager revisionManager) {
+        final ParameterContextDTO dto = new ParameterContextDTO();
+        dto.setId(parameterContext.getIdentifier());
+        dto.setName(parameterContext.getName());
+        dto.setDescription(parameterContext.getDescription());
+
+        final Set<ProcessGroupEntity> boundGroups = new HashSet<>();
+        for (final ProcessGroup processGroup : parameterContext.getParameterReferenceManager().getProcessGroupsBound(parameterContext)) {
+            final ProcessGroupDTO processGroupDto = createConciseProcessGroupDto(processGroup);
+            final RevisionDTO revisionDto = createRevisionDTO(revisionManager.getRevision(processGroup.getIdentifier()));
+            final PermissionsDTO permissionsDto = createPermissionsDto(processGroup);
+            final ProcessGroupEntity processGroupEntity = entityFactory.createProcessGroupEntity(processGroupDto, revisionDto, permissionsDto, null, null);
+            boundGroups.add(processGroupEntity);
+        }
+        dto.setBoundProcessGroups(boundGroups);
+
+        final Set<ParameterEntity> parameterEntities = new LinkedHashSet<>();
+        for (final Parameter parameter : parameterContext.getParameters().values()) {
+            parameterEntities.add(createParameterEntity(parameterContext, parameter, revisionManager));
+        }
+
+        dto.setParameters(parameterEntities);
+        return dto;
+    }
+
+    public ParameterEntity createParameterEntity(final ParameterContext parameterContext, final Parameter parameter, final RevisionManager revisionManager) {
+        final ParameterDTO dto = createParameterDto(parameterContext, parameter, revisionManager);
+        final ParameterEntity entity = new ParameterEntity();
+        entity.setParameter(dto);
+
+        final boolean canWrite = isWritable(dto.getReferencingComponents());
+        entity.setCanWrite(canWrite);
+
+        return entity;
+    }
+
+    public ParameterDTO createParameterDto(final ParameterContext parameterContext, final Parameter parameter, final RevisionManager revisionManager) {
+        final ParameterDescriptor descriptor = parameter.getDescriptor();
+
+        final ParameterDTO dto = new ParameterDTO();
+        dto.setName(descriptor.getName());
+        dto.setDescription(descriptor.getDescription());
+        dto.setSensitive(descriptor.isSensitive());
+        dto.setValue(descriptor.isSensitive() ? SENSITIVE_VALUE_MASK : parameter.getValue());
+
+        final ParameterReferenceManager parameterReferenceManager = parameterContext.getParameterReferenceManager();
+
+        final Set<ComponentNode> referencingComponents = new HashSet<>();
+        referencingComponents.addAll(parameterReferenceManager.getProcessorsReferencing(parameterContext, descriptor.getName()));
+        referencingComponents.addAll(parameterReferenceManager.getControllerServicesReferencing(parameterContext, descriptor.getName()));
+
+        final Set<AffectedComponentEntity> referencingComponentEntities = createAffectedComponentEntities(referencingComponents, revisionManager);
+        dto.setReferencingComponents(referencingComponentEntities);
+
+        return dto;
+    }
+
     public ReportingTaskDTO createReportingTaskDto(final ReportingTaskNode reportingTaskNode) {
         final BundleCoordinate bundleCoordinate = reportingTaskNode.getBundleCoordinate();
         final List<Bundle> compatibleBundles = extensionManager.getBundles(reportingTaskNode.getCanonicalClassName()).stream().filter(bundle -> {
@@ -1390,7 +1455,7 @@ public int compare(final PropertyDescriptor o1, final PropertyDescriptor o2) {
                 return Collator.getInstance(Locale.US).compare(o1.getName(), o2.getName());
             }
         });
-        sortedProperties.putAll(reportingTaskNode.getProperties());
+        sortedProperties.putAll(reportingTaskNode.getRawPropertyValues());
 
         // get the property order from the reporting task
         final ReportingTask reportingTask = reportingTaskNode.getReportingTask();
@@ -1470,7 +1535,7 @@ public int compare(final PropertyDescriptor o1, final PropertyDescriptor o2) {
                 return Collator.getInstance(Locale.US).compare(o1.getName(), o2.getName());
             }
         });
-        sortedProperties.putAll(controllerServiceNode.getProperties());
+        sortedProperties.putAll(controllerServiceNode.getRawPropertyValues());
 
         // get the property order from the controller service
         final ControllerService controllerService = controllerServiceNode.getControllerServiceImplementation();
@@ -1571,7 +1636,7 @@ public int compare(final PropertyDescriptor o1, final PropertyDescriptor o2) {
                 return Collator.getInstance(Locale.US).compare(o1.getName(), o2.getName());
             }
         });
-        sortedProperties.putAll(component.getProperties());
+        sortedProperties.putAll(component.getRawPropertyValues());
 
         final Map<PropertyDescriptor, String> orderedProperties = new LinkedHashMap<>();
         for (final PropertyDescriptor descriptor : propertyDescriptors) {
@@ -1966,6 +2031,36 @@ public AffectedComponentDTO createAffectedComponentDto(final ComponentNode compo
         dto.setName(component.getName());
         dto.setProcessGroupId(component.getProcessGroupIdentifier());
 
+        if (component instanceof ProcessorNode) {
+            final ProcessorNode node = ((ProcessorNode) component);
+            dto.setState(node.getDesiredState().name());
+            dto.setActiveThreadCount(node.getActiveThreadCount());
+            dto.setReferenceType(AffectedComponentDTO.COMPONENT_TYPE_PROCESSOR);
+        } else if (component instanceof ControllerServiceNode) {
+            final ControllerServiceNode node = ((ControllerServiceNode) component);
+            dto.setState(node.getState().name());
+            dto.setReferenceType(AffectedComponentDTO.COMPONENT_TYPE_CONTROLLER_SERVICE);
+        }
+
+        final Collection<ValidationResult> validationErrors = component.getValidationErrors();
+        if (validationErrors != null && !validationErrors.isEmpty()) {
+            final List<String> errors = new ArrayList<>();
+            for (final ValidationResult validationResult : validationErrors) {
+                errors.add(validationResult.toString());
+            }
+
+            dto.setValidationErrors(errors);
+        }
+
+        return dto;
+    }
+
+    public ComponentValidationResultDTO createComponentValidationResultDto(final ComponentNode component, final ValidationState validationResults) {
+        final ComponentValidationResultDTO dto = new ComponentValidationResultDTO();
+        dto.setId(component.getIdentifier());
+        dto.setName(component.getName());
+        dto.setProcessGroupId(component.getProcessGroupIdentifier());
+
         if (component instanceof ProcessorNode) {
             final ProcessorNode node = ((ProcessorNode) component);
             dto.setState(node.getScheduledState().name());
@@ -1985,8 +2080,18 @@ public AffectedComponentDTO createAffectedComponentDto(final ComponentNode compo
             }
 
             dto.setValidationErrors(errors);
+            dto.setCurrentlyValid(false);
+        } else {
+            dto.setCurrentlyValid(true);
         }
 
+        final List<String> resultantValidationErrors = validationResults.getValidationErrors().stream()
+            .map(ValidationResult::toString)
+            .collect(Collectors.toList());
+
+        dto.setResultantValidationErrors(resultantValidationErrors);
+        dto.setResultsValid(resultantValidationErrors.isEmpty());
+
         return dto;
     }
 
@@ -2014,6 +2119,8 @@ public ProcessGroupFlowDTO createProcessGroupFlowDto(final ProcessGroup group, f
             dto.setParentGroupId(parent.getIdentifier());
         }
 
+        final ParameterContext parameterContext = group.getParameterContext();
+        dto.setParameterContextId(parameterContext == null ? null : parameterContext.getIdentifier());
         return dto;
     }
 
@@ -2034,7 +2141,7 @@ public FlowDTO createFlowDto(final ProcessGroup group, final ProcessGroupStatus
             final PermissionsDTO accessPolicy = createPermissionsDto(connection);
             final ConnectionStatusDTO status = getComponentStatus(
                 () -> groupStatus.getConnectionStatus().stream().filter(connectionStatus -> connection.getIdentifier().equals(connectionStatus.getId())).findFirst().orElse(null),
-                connectionStatus -> createConnectionStatusDto(connectionStatus)
+                this::createConnectionStatusDto
             );
             flow.getConnections().add(entityFactory.createConnectionEntity(dto, revision, accessPolicy, status));
         }
@@ -2280,8 +2387,12 @@ private ProcessGroupDTO createConciseProcessGroupDto(final ProcessGroup group) {
         dto.setVersionedComponentId(group.getVersionedComponentId().orElse(null));
         dto.setVersionControlInformation(createVersionControlInformationDto(group));
 
+        final ParameterContextReferenceDTO parameterContextReference = new ParameterContextReferenceDTO();
+        parameterContextReference.setId(group.getParameterContext() == null ? null : group.getParameterContext().getIdentifier());
+        dto.setParameterContext(parameterContextReference);
+
         final Map<String, String> variables = group.getVariableRegistry().getVariableMap().entrySet().stream()
-            .collect(Collectors.toMap(entry -> entry.getKey().getName(), entry -> entry.getValue()));
+            .collect(Collectors.toMap(entry -> entry.getKey().getName(), Entry::getValue));
         dto.setVariables(variables);
 
         final ProcessGroup parentGroup = group.getParent();
@@ -2559,20 +2670,22 @@ private String getDeprecationReason(final Class<?> cls) {
 
     public Set<AffectedComponentEntity> createAffectedComponentEntities(final Set<ComponentNode> affectedComponents, final RevisionManager revisionManager) {
         return affectedComponents.stream()
-                .map(component -> {
-                    final AffectedComponentDTO affectedComponent = createAffectedComponentDto(component);
-                    final PermissionsDTO permissions = createPermissionsDto(component);
-                    final RevisionDTO revision = createRevisionDTO(revisionManager.getRevision(component.getIdentifier()));
-                    return entityFactory.createAffectedComponentEntity(affectedComponent, revision, permissions);
-                })
+                .map(component -> createAffectedComponentEntity(component, revisionManager))
                 .collect(Collectors.toSet());
     }
 
+    public AffectedComponentEntity createAffectedComponentEntity(final ComponentNode componentNode, final RevisionManager revisionManager) {
+        final AffectedComponentDTO affectedComponent = createAffectedComponentDto(componentNode);
+        final PermissionsDTO permissions = createPermissionsDto(componentNode);
+        final RevisionDTO revision = createRevisionDTO(revisionManager.getRevision(componentNode.getIdentifier()));
+        return entityFactory.createAffectedComponentEntity(affectedComponent, revision, permissions);
+    }
+
     public VariableRegistryDTO createVariableRegistryDto(final ProcessGroup processGroup, final RevisionManager revisionManager) {
         final ComponentVariableRegistry variableRegistry = processGroup.getVariableRegistry();
 
         final List<String> variableNames = variableRegistry.getVariableMap().keySet().stream()
-            .map(descriptor -> descriptor.getName())
+            .map(VariableDescriptor::getName)
             .collect(Collectors.toList());
 
         final Set<VariableEntity> variableEntities = new LinkedHashSet<>();
@@ -2585,17 +2698,9 @@ public VariableRegistryDTO createVariableRegistryDto(final ProcessGroup processG
 
             final Set<AffectedComponentEntity> affectedComponentEntities = createAffectedComponentEntities(processGroup.getComponentsAffectedByVariable(variableName), revisionManager);
 
-            boolean canWrite = true;
-            for (final AffectedComponentEntity affectedComponent : affectedComponentEntities) {
-                final PermissionsDTO permissions = affectedComponent.getPermissions();
-                if (!permissions.getCanRead() || !permissions.getCanWrite()) {
-                    canWrite = false;
-                    break;
-                }
-            }
-
             variableDto.setAffectedComponents(affectedComponentEntities);
 
+            final boolean canWrite = isWritable(affectedComponentEntities);
             final VariableEntity variableEntity = new VariableEntity();
             variableEntity.setVariable(variableDto);
             variableEntity.setCanWrite(canWrite);
@@ -2610,6 +2715,17 @@ public VariableRegistryDTO createVariableRegistryDto(final ProcessGroup processG
         return registryDto;
     }
 
+    private boolean isWritable(final Collection<AffectedComponentEntity> affectedComponentEntities) {
+        for (final AffectedComponentEntity affectedComponent : affectedComponentEntities) {
+            final PermissionsDTO permissions = affectedComponent.getPermissions();
+            if (!permissions.getCanRead() || !permissions.getCanWrite()) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
     public VariableRegistryUpdateRequestDTO createVariableRegistryUpdateRequestDto(final VariableRegistryUpdateRequest request) {
         final VariableRegistryUpdateRequestDTO dto = new VariableRegistryUpdateRequestDTO();
         dto.setComplete(request.isComplete());
@@ -3292,7 +3408,7 @@ public ProcessorDiagnosticsDTO createProcessorDiagnosticsDto(final ProcessorNode
         procDiagnostics.setProcessorStatus(createProcessorStatusDto(procStatus));
         procDiagnostics.setThreadDumps(createThreadDumpDtos(procNode));
 
-        final Set<ControllerServiceDiagnosticsDTO> referencedServiceDiagnostics = createReferencedServiceDiagnostics(procNode.getProperties(),
+        final Set<ControllerServiceDiagnosticsDTO> referencedServiceDiagnostics = createReferencedServiceDiagnostics(procNode.getEffectivePropertyValues(),
             flowController.getControllerServiceProvider(), serviceEntityFactory);
         procDiagnostics.setReferencedControllerServices(referencedServiceDiagnostics);
 
@@ -3644,7 +3760,7 @@ public int compare(final PropertyDescriptor o1, final PropertyDescriptor o2) {
                 return Collator.getInstance(Locale.US).compare(o1.getName(), o2.getName());
             }
         });
-        sortedProperties.putAll(procNode.getProperties());
+        sortedProperties.putAll(procNode.getRawPropertyValues());
 
         // get the property order from the processor
         final Processor processor = procNode.getProcessor();
@@ -4018,8 +4134,10 @@ public ProcessGroupDTO copy(final ProcessGroupDTO original, final boolean deep)
         copy.setInvalidCount(original.getInvalidCount());
         copy.setName(original.getName());
         copy.setVersionControlInformation(copy(original.getVersionControlInformation()));
+        copy.setParameterContext(copy(original.getParameterContext()));
         copy.setLocalOutputPortCount(original.getLocalOutputPortCount());
         copy.setPublicOutputPortCount(original.getPublicOutputPortCount());
+        copy.setOutputPortCount(original.getOutputPortCount());
         copy.setParentGroupId(original.getParentGroupId());
         copy.setVersionedComponentId(original.getVersionedComponentId());
 
@@ -4042,6 +4160,16 @@ public ProcessGroupDTO copy(final ProcessGroupDTO original, final boolean deep)
         return copy;
     }
 
+    public ParameterContextReferenceDTO copy(final ParameterContextReferenceDTO original) {
+        if (original == null) {
+            return null;
+        }
+
+        final ParameterContextReferenceDTO copy = new ParameterContextReferenceDTO();
+        copy.setId(original.getId());
+        return copy;
+    }
+
     public VersionControlInformationDTO copy(final VersionControlInformationDTO original) {
         if (original == null) {
             return null;
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/dto/EntityFactory.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/dto/EntityFactory.java
index 2dcde66004d..915ad2ce8b6 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/dto/EntityFactory.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/dto/EntityFactory.java
@@ -41,6 +41,7 @@
 import org.apache.nifi.web.api.entity.BucketEntity;
 import org.apache.nifi.web.api.entity.BulletinEntity;
 import org.apache.nifi.web.api.entity.ComponentReferenceEntity;
+import org.apache.nifi.web.api.entity.ComponentValidationResultEntity;
 import org.apache.nifi.web.api.entity.ConnectionEntity;
 import org.apache.nifi.web.api.entity.ConnectionStatusEntity;
 import org.apache.nifi.web.api.entity.ConnectionStatusSnapshotEntity;
@@ -50,6 +51,7 @@
 import org.apache.nifi.web.api.entity.FlowBreadcrumbEntity;
 import org.apache.nifi.web.api.entity.FunnelEntity;
 import org.apache.nifi.web.api.entity.LabelEntity;
+import org.apache.nifi.web.api.entity.ParameterContextEntity;
 import org.apache.nifi.web.api.entity.PortEntity;
 import org.apache.nifi.web.api.entity.PortStatusEntity;
 import org.apache.nifi.web.api.entity.PortStatusSnapshotEntity;
@@ -370,6 +372,21 @@ public AffectedComponentEntity createAffectedComponentEntity(final AffectedCompo
         return entity;
     }
 
+    public ComponentValidationResultEntity createComponentValidationResultEntity(final ComponentValidationResultDTO dto, final RevisionDTO revision, final PermissionsDTO permissions) {
+        final ComponentValidationResultEntity entity = new ComponentValidationResultEntity();
+        entity.setRevision(revision);
+        if (dto != null) {
+            entity.setPermissions(permissions);
+            entity.setId(dto.getId());
+
+            if (permissions != null && permissions.getCanRead()) {
+                entity.setComponent(dto);
+            }
+        }
+
+        return entity;
+    }
+
     public UserGroupEntity createUserGroupEntity(final UserGroupDTO dto, final RevisionDTO revision, final PermissionsDTO permissions) {
         final UserGroupEntity entity = new UserGroupEntity();
         entity.setRevision(revision);
@@ -504,6 +521,21 @@ public ReportingTaskEntity createReportingTaskEntity(final ReportingTaskDTO dto,
         return entity;
     }
 
+    public ParameterContextEntity createParameterContextEntity(final ParameterContextDTO dto, final RevisionDTO revision, final PermissionsDTO permissions) {
+        final ParameterContextEntity entity = new ParameterContextEntity();
+        entity.setRevision(revision);
+        if (dto != null) {
+            entity.setPermissions(permissions);;
+            entity.setId(dto.getId());
+
+            if (permissions != null && permissions.getCanRead()) {
+                entity.setComponent(dto);
+            }
+        }
+
+        return entity;
+    }
+
     public VariableRegistryEntity createVariableRegistryEntity(final VariableRegistryDTO dto, final RevisionDTO revision, final PermissionsDTO permissions) {
         final VariableRegistryEntity entity = new VariableRegistryEntity();
         entity.setProcessGroupRevision(revision);
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/controller/ControllerSearchService.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/controller/ControllerSearchService.java
index df77a2e171b..c08d2103244 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/controller/ControllerSearchService.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/controller/ControllerSearchService.java
@@ -261,7 +261,7 @@ private ComponentSearchResultDTO search(final String searchStr, final ProcessorN
         addIfAppropriate(searchStr, processor.getClass().getSimpleName(), "Type", matches);
         addIfAppropriate(searchStr, procNode.getComponentType(), "Type", matches);
 
-        for (final Map.Entry<PropertyDescriptor, String> entry : procNode.getProperties().entrySet()) {
+        for (final Map.Entry<PropertyDescriptor, String> entry : procNode.getRawPropertyValues().entrySet()) {
             final PropertyDescriptor descriptor = entry.getKey();
 
             addIfAppropriate(searchStr, descriptor.getName(), "Property name", matches);
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/controller/StandardSearchContext.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/controller/StandardSearchContext.java
index da060e1175c..233939f5678 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/controller/StandardSearchContext.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/controller/StandardSearchContext.java
@@ -16,8 +16,7 @@
  */
 package org.apache.nifi.web.controller;
 
-import java.util.Map;
-
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.components.PropertyDescriptor;
 import org.apache.nifi.components.PropertyValue;
@@ -26,6 +25,8 @@
 import org.apache.nifi.registry.VariableRegistry;
 import org.apache.nifi.search.SearchContext;
 
+import java.util.Map;
+
 /**
  *
  */
@@ -55,13 +56,13 @@ public String getAnnotationData() {
 
     @Override
     public PropertyValue getProperty(PropertyDescriptor property) {
-        final String configuredValue = processorNode.getProperty(property);
-        return new StandardPropertyValue(configuredValue == null ? property.getDefaultValue() : configuredValue, controllerServiceLookup,variableRegistry);
+        final String configuredValue = processorNode.getRawPropertyValue(property);
+        return new StandardPropertyValue(configuredValue == null ? property.getDefaultValue() : configuredValue, controllerServiceLookup, ParameterLookup.EMPTY, variableRegistry);
     }
 
     @Override
     public Map<PropertyDescriptor, String> getProperties() {
-        return processorNode.getProperties();
+        return processorNode.getRawPropertyValues();
     }
 
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/ParameterContextDAO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/ParameterContextDAO.java
new file mode 100644
index 00000000000..545b7608a34
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/ParameterContextDAO.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.dao;
+
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.web.api.dto.ParameterContextDTO;
+
+import java.util.Set;
+
+public interface ParameterContextDAO {
+    /**
+     * Determines if the specified parameter context exists.
+     *
+     * @param parameterContextId id
+     * @return true if parameter context exists
+     */
+    boolean hasParameterContext(String parameterContextId);
+
+    /**
+     * Determines whether this parameter context can be created.
+     *
+     * @param parameterContextDto dto
+     */
+    void verifyCreate(ParameterContextDTO parameterContextDto);
+
+    /**
+     * Creates a parameter context.
+     *
+     * @param parameterContextDto The parameter context dto
+     * @return The parameter context
+     */
+    ParameterContext createParameterContext(ParameterContextDTO parameterContextDto);
+
+    /**
+     * Gets the specified parameter context.
+     *
+     * @param parameterContextId the id of the parameter context
+     * @return the parameter context
+     */
+    ParameterContext getParameterContext(String parameterContextId);
+
+    /**
+     * Gets all of the parameter contexts.
+     *
+     * @return The parameter contexts
+     */
+    Set<ParameterContext> getParameterContexts();
+
+    /**
+     * Updates the specified parameter context
+     *
+     * @param parameterContextDto The parameter context DTO
+     * @return The parameter context
+     */
+    ParameterContext updateParameterContext(ParameterContextDTO parameterContextDto);
+
+    /**
+     * Determines whether this parameter context can be updated.
+     *
+     * @param parameterContextDto dto
+     * @param verifyComponentStates if <code>true</code>, will ensure that any processor referencing the parameter context is stopped/disabled and any controller service referencing the parameter
+     * context is disabled. If <code>false</code>, these verifications will not be performed.
+     */
+    void verifyUpdate(ParameterContextDTO parameterContextDto, boolean verifyComponentStates);
+
+    /**
+     * Determines whether this parameter context can be removed.
+     *
+     * @param parameterContextId id
+     */
+    void verifyDelete(String parameterContextId);
+
+    /**
+     * Deletes the specified Parameter Context
+     *
+     * @param parameterContextId the ID of the Parameter Context
+     */
+    void deleteParameterContext(String parameterContextId);
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/TemplateDAO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/TemplateDAO.java
index 03442db2bc6..3fd713c43fc 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/TemplateDAO.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/TemplateDAO.java
@@ -33,11 +33,12 @@ public interface TemplateDAO {
     void verifyCanAddTemplate(String name, String groupId);
 
     /**
-     * Verifies the types of components in a template.
+     * Verifies that the given template can be instantiated in the group with the given ID
      *
-     * @param snippet proposed template
+     * @param groupId the ID of the Process Group
+     * @param snippetDTO the contents of the snippet
      */
-    void verifyComponentTypes(FlowSnippetDTO snippet);
+    void verifyCanInstantiate(String groupId, FlowSnippetDTO snippetDTO);
 
     /**
      * Creates a template.
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardControllerServiceDAO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardControllerServiceDAO.java
index 3d09546baa4..ff05f047a5c 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardControllerServiceDAO.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardControllerServiceDAO.java
@@ -242,6 +242,16 @@ public Set<ComponentNode> updateControllerServiceReferencingComponents(
 
     private List<String> validateProposedConfiguration(final ControllerServiceNode controllerService, final ControllerServiceDTO controllerServiceDTO) {
         final List<String> validationErrors = new ArrayList<>();
+
+        final Map<String, String> properties = controllerServiceDTO.getProperties();
+        if (isNotNull(properties)) {
+            try {
+                controllerService.verifyCanUpdateProperties(properties);
+            } catch (final IllegalArgumentException | IllegalStateException iae) {
+                validationErrors.add(iae.getMessage());
+            }
+        }
+
         return validationErrors;
     }
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardParameterContextDAO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardParameterContextDAO.java
new file mode 100644
index 00000000000..aaab83045e7
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardParameterContextDAO.java
@@ -0,0 +1,255 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.dao.impl;
+
+import org.apache.nifi.components.PropertyDescriptor;
+import org.apache.nifi.controller.ComponentNode;
+import org.apache.nifi.controller.FlowController;
+import org.apache.nifi.controller.ProcessorNode;
+import org.apache.nifi.controller.PropertyConfiguration;
+import org.apache.nifi.controller.flow.FlowManager;
+import org.apache.nifi.controller.service.ControllerServiceNode;
+import org.apache.nifi.controller.service.ControllerServiceState;
+import org.apache.nifi.groups.ProcessGroup;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterDescriptor;
+import org.apache.nifi.parameter.ParameterReference;
+import org.apache.nifi.parameter.ParameterReferenceManager;
+import org.apache.nifi.web.ResourceNotFoundException;
+import org.apache.nifi.web.api.dto.ParameterContextDTO;
+import org.apache.nifi.web.api.dto.ParameterDTO;
+import org.apache.nifi.web.api.entity.ParameterEntity;
+import org.apache.nifi.web.dao.ParameterContextDAO;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+
+public class StandardParameterContextDAO implements ParameterContextDAO {
+    private FlowManager flowManager;
+
+    @Override
+    public boolean hasParameterContext(final String parameterContextId) {
+        return flowManager.getParameterContextManager().getParameterContext(parameterContextId) != null;
+    }
+
+    @Override
+    public void verifyCreate(final ParameterContextDTO parameterContextDto) {
+        verifyNoNamingConflict(parameterContextDto.getName());
+    }
+
+    @Override
+    public ParameterContext createParameterContext(final ParameterContextDTO parameterContextDto) {
+        final Set<Parameter> parameters = getParameters(parameterContextDto);
+        final ParameterContext parameterContext = flowManager.createParameterContext(parameterContextDto.getId(), parameterContextDto.getName(), parameters);
+        if (parameterContextDto.getDescription() != null) {
+            parameterContext.setDescription(parameterContextDto.getDescription());
+        }
+        return parameterContext;
+    }
+
+    private Set<Parameter> getParameters(final ParameterContextDTO parameterContextDto) {
+        final Set<ParameterEntity> parameterDtos = parameterContextDto.getParameters();
+        if (parameterDtos == null) {
+            return Collections.emptySet();
+        }
+
+        return parameterContextDto.getParameters().stream()
+            .map(ParameterEntity::getParameter)
+            .map(this::createParameter)
+            .collect(Collectors.toSet());
+    }
+
+    private Parameter createParameter(final ParameterDTO dto) {
+        final ParameterDescriptor descriptor = new ParameterDescriptor.Builder()
+            .name(dto.getName())
+            .description(dto.getDescription())
+            .sensitive(Boolean.TRUE.equals(dto.getSensitive()))
+            .build();
+
+        return new Parameter(descriptor, dto.getValue());
+    }
+
+    @Override
+    public ParameterContext getParameterContext(final String parameterContextId) {
+        final ParameterContext context = flowManager.getParameterContextManager().getParameterContext(parameterContextId);
+        if (context == null) {
+            throw new ResourceNotFoundException(String.format("Unable to find Parameter Context with id '%s'.", parameterContextId));
+        }
+
+        return context;
+    }
+
+    @Override
+    public Set<ParameterContext> getParameterContexts() {
+        return flowManager.getParameterContextManager().getParameterContexts();
+    }
+
+    @Override
+    public ParameterContext updateParameterContext(final ParameterContextDTO parameterContextDto) {
+        verifyUpdate(parameterContextDto, true);
+
+        final ParameterContext context = getParameterContext(parameterContextDto.getId());
+
+        if (parameterContextDto.getName() != null) {
+            verifyNoNamingConflict(parameterContextDto.getName(), parameterContextDto.getId());
+            context.setName(parameterContextDto.getName());
+        }
+
+        if (parameterContextDto.getDescription() != null) {
+            context.setDescription(parameterContextDto.getDescription());
+        }
+
+        if (parameterContextDto.getParameters() != null) {
+            final Set<Parameter> parameters = getParameters(parameterContextDto);
+            context.setParameters(parameters);
+        }
+
+        return context;
+    }
+
+    @Override
+    public void verifyUpdate(final ParameterContextDTO parameterContextDto, final boolean verifyComponentStates) {
+        verifyNoNamingConflict(parameterContextDto.getName(), parameterContextDto.getId());
+
+        final ParameterContext currentContext = getParameterContext(parameterContextDto.getId());
+        for (final ParameterEntity parameterEntity : parameterContextDto.getParameters()) {
+            final ParameterDTO parameterDto = parameterEntity.getParameter();
+            final String parameterName = parameterDto.getName();
+            final ParameterReferenceManager referenceManager = currentContext.getParameterReferenceManager();
+
+            for (final ProcessorNode processor : referenceManager.getProcessorsReferencing(currentContext, parameterName)) {
+                verifyParameterUpdate(parameterName, processor, parameterDto.getSensitive(), currentContext.getName(), verifyComponentStates, processor.isRunning(), "Processor that is running");
+            }
+
+            for (final ControllerServiceNode serviceNode : referenceManager.getControllerServicesReferencing(currentContext, parameterName)) {
+                verifyParameterUpdate(parameterName, serviceNode, parameterDto.getSensitive(), currentContext.getName(), verifyComponentStates,
+                    serviceNode.getState() != ControllerServiceState.DISABLED, "Controller Service that is enabled");
+            }
+        }
+    }
+
+    private void verifyParameterUpdate(final String parameterName, final ComponentNode component, final Boolean parameterSensitive, final String contextName,
+                                            final boolean verifyComponentStates, final boolean active, final String activeExplanation) {
+        // For any parameter that is added or modified, we need to ensure that the new configuration will not result in a Sensitive Parameter being referenced by a non-Sensitive Property
+        // or a Non-Sensitive Parameter being referenced by a Sensitive Property.
+        // Additionally, if 'verifyComponentStates', we must ensure that any component that references a value that is to be updated is stopped (if a processor) or disabled (if a controller service)
+        for (final Map.Entry<PropertyDescriptor, PropertyConfiguration> entry : component.getProperties().entrySet()) {
+            final PropertyConfiguration configuration = entry.getValue();
+            if (configuration == null) {
+                continue;
+            }
+
+            for (final ParameterReference reference : configuration.getParameterReferences()) {
+                final String referencedParameterName = reference.getParameterName();
+                if (referencedParameterName.equals(parameterName)) {
+                    if (entry.getKey().isSensitive() && !Boolean.TRUE.equals(parameterSensitive)) {
+                        throw new IllegalStateException("Cannot update Parameter Context " + contextName + " because the update would add a Non-Sensitive Parameter " +
+                            "named '" + parameterName + "' but this Parameter already is referenced by a Sensitive Property.");
+                    }
+
+                    if (!entry.getKey().isSensitive() && Boolean.TRUE.equals(parameterSensitive)) {
+                        throw new IllegalStateException("Cannot update Parameter Context " + contextName + " because the update would add a Sensitive Parameter named " +
+                            "'" + parameterName + "' but this Parameter already is referenced by a Non-Sensitive Property.");
+                    }
+
+                    if (verifyComponentStates && active) {
+                        throw new IllegalStateException("Cannot update Parameter Context " + contextName + " because it has Parameters that are being referenced by a " +
+                            activeExplanation + ".");
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Ensures that no Parameter Context exists with the given name. If any does already exist with this name, an IllegalStateException will be thrown.
+     * @param contextName the name of the Parameter Context
+     * @throws IllegalStateException if any Parameter Context already exists with the given name
+     */
+    private void verifyNoNamingConflict(final String contextName) {
+        verifyNoNamingConflict(contextName, null);
+    }
+
+    /**
+     * Ensures that no Parameter Context exists with the given name, unless that Parameter Context also has the given identifier. If any does already exist with this name, and its identifier does
+     * not match the given identifier, an IllegalStateException will be thrown. Otherwise, this method will return gracefully.
+     * @param contextName the name of the Parameter Context
+     * @param contextId the Identifier of the Parameter Context whose name should not be compared against the given name
+     * @throws IllegalStateException if any Parameter Context already exists with the given name and a non-matching identifier
+     */
+    private void verifyNoNamingConflict(final String contextName, final String contextId) {
+        if (contextName == null) {
+            return;
+        }
+
+        for (final ParameterContext parameterContext : flowManager.getParameterContextManager().getParameterContexts()) {
+            if (parameterContext.getName().equals(contextName)) {
+                if (contextId == null || contextId.equals(parameterContext.getIdentifier())) {
+                    continue;
+                }
+
+                throw new IllegalStateException("Cannot update Parameter Context name because another Parameter Context already exists with the name '" + contextName + "'");
+            }
+        }
+    }
+
+
+    @Override
+    public void verifyDelete(final String parameterContextId) {
+        // Find all Process Groups that are bound to the Parameter Context
+        final List<ProcessGroup> groupsReferencingParameterContext = getBoundProcessGroups(parameterContextId);
+
+        // If any component is referencing a Parameter and is running/enabled then fail
+        for (final ProcessGroup group : groupsReferencingParameterContext) {
+            for (final ProcessorNode processor : group.getProcessors()) {
+                if (processor.isReferencingParameter() && processor.isRunning()) {
+                    throw new IllegalStateException("Cannot delete Parameter Context with ID " + parameterContextId + " because it is in use by at least one Processor that is running");
+                }
+            }
+
+            for (final ControllerServiceNode service : group.getControllerServices(false)) {
+                if (service.isReferencingParameter() && service.getState() != ControllerServiceState.DISABLED) {
+                    throw new IllegalStateException("Cannot delete Parameter Context with ID " + parameterContextId + " because it is in use by at least one Controller Service that is enabled");
+                }
+            }
+        }
+    }
+
+    @Override
+    public void deleteParameterContext(final String parameterContextId) {
+        verifyDelete(parameterContextId);
+
+        // Remove the Parameter Context from the manager
+        flowManager.getParameterContextManager().removeParameterContext(parameterContextId);
+
+        // Update all Process Groups that currently are bound to the Parameter Context so that they are no longer bound to any Parameter Context
+        getBoundProcessGroups(parameterContextId).forEach(group -> group.setParameterContext(null));
+    }
+
+    public void setFlowController(final FlowController flowController) {
+        this.flowManager = flowController.getFlowManager();
+    }
+
+    private List<ProcessGroup> getBoundProcessGroups(final String parameterContextId) {
+        final ProcessGroup rootGroup = flowManager.getRootGroup();
+        return rootGroup.findAllProcessGroups(group -> group.getParameterContext() != null && group.getParameterContext().getIdentifier().equals(parameterContextId));
+    }
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardProcessGroupDAO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardProcessGroupDAO.java
index 20669f62773..e8957dd2015 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardProcessGroupDAO.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardProcessGroupDAO.java
@@ -27,6 +27,7 @@
 import org.apache.nifi.controller.service.ControllerServiceState;
 import org.apache.nifi.groups.ProcessGroup;
 import org.apache.nifi.groups.RemoteProcessGroup;
+import org.apache.nifi.parameter.ParameterContext;
 import org.apache.nifi.registry.flow.FlowRegistry;
 import org.apache.nifi.registry.flow.StandardVersionControlInformation;
 import org.apache.nifi.registry.flow.VersionControlInformation;
@@ -35,6 +36,7 @@
 import org.apache.nifi.registry.flow.mapping.NiFiRegistryFlowMapper;
 import org.apache.nifi.remote.RemoteGroupPort;
 import org.apache.nifi.web.ResourceNotFoundException;
+import org.apache.nifi.web.api.dto.ParameterContextReferenceDTO;
 import org.apache.nifi.web.api.dto.ProcessGroupDTO;
 import org.apache.nifi.web.api.dto.VariableRegistryDTO;
 import org.apache.nifi.web.api.dto.VersionControlInformationDTO;
@@ -76,6 +78,12 @@ public ProcessGroup createProcessGroup(String parentGroupId, ProcessGroupDTO pro
             group.setPosition(new Position(processGroup.getPosition().getX(), processGroup.getPosition().getY()));
         }
 
+        final ParameterContextReferenceDTO parameterContextReference = processGroup.getParameterContext();
+        if (parameterContextReference != null && parameterContextReference.getId() != null) {
+            final ParameterContext parameterContext = flowController.getFlowManager().getParameterContextManager().getParameterContext(parameterContextReference.getId());
+            group.setParameterContext(parameterContext);
+        }
+
         // add the process group
         group.setParent(parentGroup);
         parentGroup.addProcessGroup(group);
@@ -90,6 +98,28 @@ public boolean hasProcessGroup(String groupId) {
 
     @Override
     public void verifyUpdate(final ProcessGroupDTO processGroup) {
+        final ParameterContextReferenceDTO parameterContextReference = processGroup.getParameterContext();
+        if (parameterContextReference == null) {
+            return;
+        }
+
+        final ParameterContext parameterContext = locateParameterContext(parameterContextReference.getId());
+        final ProcessGroup group = locateProcessGroup(flowController, processGroup.getId());
+        group.verifyCanSetParameterContext(parameterContext);
+    }
+
+    private ParameterContext locateParameterContext(final String id) {
+        final ParameterContext parameterContext;
+        if (id == null) {
+            return null;
+        } else {
+            parameterContext = flowController.getFlowManager().getParameterContextManager().getParameterContext(id);
+            if (parameterContext == null) {
+                throw new IllegalStateException("Cannot update Process Group's Parameter Context because no Parameter Context exists with ID " + id);
+            }
+
+            return parameterContext;
+        }
     }
 
     @Override
@@ -306,6 +336,21 @@ public ProcessGroup updateProcessGroup(ProcessGroupDTO processGroupDTO) {
         final String name = processGroupDTO.getName();
         final String comments = processGroupDTO.getComments();
 
+        final ParameterContextReferenceDTO parameterContextReference = processGroupDTO.getParameterContext();
+        if (parameterContextReference != null) {
+            final String parameterContextId = parameterContextReference.getId();
+            if (parameterContextId == null) {
+                group.setParameterContext(null);
+            } else {
+                final ParameterContext parameterContext = flowController.getFlowManager().getParameterContextManager().getParameterContext(parameterContextId);
+                if (parameterContext == null) {
+                    throw new IllegalStateException("Cannot set Process Group's Parameter Context because no Parameter Context exists with ID " + parameterContextId);
+                }
+
+                group.setParameterContext(parameterContext);
+            }
+        }
+
         if (isNotNull(name)) {
             group.setName(name);
         }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardProcessorDAO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardProcessorDAO.java
index 3b93921e434..900d1e2208d 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardProcessorDAO.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardProcessorDAO.java
@@ -302,6 +302,15 @@ private List<String> validateProposedConfiguration(final ProcessorNode processor
             }
         }
 
+        final Map<String, String> properties = config.getProperties();
+        if (isNotNull(properties)) {
+            try {
+                processorNode.verifyCanUpdateProperties(properties);
+            } catch (final IllegalArgumentException | IllegalStateException iae) {
+                validationErrors.add(iae.getMessage());
+            }
+        }
+
         return validationErrors;
     }
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardSnippetDAO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardSnippetDAO.java
index 4b26f095353..46b6b7e736d 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardSnippetDAO.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardSnippetDAO.java
@@ -294,7 +294,7 @@ private void lookupSensitiveProcessorProperties(final Set<ProcessorDTO> processo
                 }
 
                 // look for sensitive properties get the actual value
-                for (Entry<PropertyDescriptor, String> entry : processorNode.getProperties().entrySet()) {
+                for (Entry<PropertyDescriptor, String> entry : processorNode.getRawPropertyValues().entrySet()) {
                     final PropertyDescriptor descriptor = entry.getKey();
 
                     if (descriptor.isSensitive()) {
@@ -319,7 +319,7 @@ private void lookupSensitiveControllerServiceProperties(final Set<ControllerServ
                 }
 
                 // look for sensitive properties get the actual value
-                for (Entry<PropertyDescriptor, String> entry : serviceNode.getProperties().entrySet()) {
+                for (Entry<PropertyDescriptor, String> entry : serviceNode.getRawPropertyValues().entrySet()) {
                     final PropertyDescriptor descriptor = entry.getKey();
 
                     if (descriptor.isSensitive()) {
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardTemplateDAO.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardTemplateDAO.java
index a4d4530bfd0..f99027177b7 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardTemplateDAO.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/dao/impl/StandardTemplateDAO.java
@@ -17,6 +17,9 @@
 package org.apache.nifi.web.dao.impl;
 
 import org.apache.commons.lang3.StringUtils;
+import org.apache.nifi.bundle.BundleCoordinate;
+import org.apache.nifi.components.ConfigurableComponent;
+import org.apache.nifi.components.PropertyDescriptor;
 import org.apache.nifi.controller.FlowController;
 import org.apache.nifi.controller.StandardFlowSnippet;
 import org.apache.nifi.controller.Template;
@@ -24,16 +27,28 @@
 import org.apache.nifi.controller.exception.ProcessorInstantiationException;
 import org.apache.nifi.controller.serialization.FlowEncodingVersion;
 import org.apache.nifi.groups.ProcessGroup;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterParser;
+import org.apache.nifi.parameter.ParameterReference;
+import org.apache.nifi.parameter.ParameterTokenList;
+import org.apache.nifi.parameter.ExpressionLanguageAwareParameterParser;
 import org.apache.nifi.web.NiFiCoreException;
 import org.apache.nifi.web.ResourceNotFoundException;
+import org.apache.nifi.web.api.dto.BundleDTO;
+import org.apache.nifi.web.api.dto.ControllerServiceDTO;
 import org.apache.nifi.web.api.dto.FlowSnippetDTO;
 import org.apache.nifi.web.api.dto.ProcessGroupDTO;
+import org.apache.nifi.web.api.dto.ProcessorConfigDTO;
+import org.apache.nifi.web.api.dto.ProcessorDTO;
 import org.apache.nifi.web.api.dto.TemplateDTO;
 import org.apache.nifi.web.dao.TemplateDAO;
 import org.apache.nifi.web.util.SnippetUtils;
 
 import java.util.HashSet;
 import java.util.List;
+import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
 
 /**
@@ -63,40 +78,118 @@ public void verifyCanAddTemplate(String name, String groupId) {
             throw new ResourceNotFoundException("Could not find Process Group with ID " + groupId);
         }
 
-        verifyAdd(name, processGroup);
-    }
-
-    private void verifyAdd(final String name, final ProcessGroup processGroup) {
         processGroup.verifyCanAddTemplate(name);
     }
 
+
     @Override
-    public void verifyComponentTypes(FlowSnippetDTO snippetDto) {
+    public void verifyCanInstantiate(final String groupId, final FlowSnippetDTO snippetDTO) {
+        final ProcessGroup processGroup = flowController.getFlowManager().getGroup(groupId);
+        if (processGroup == null) {
+            throw new ResourceNotFoundException("Could not find Process Group with ID " + groupId);
+        }
+
+        verifyComponentTypes(snippetDTO);
+        verifyParameterReferences(snippetDTO, processGroup.getParameterContext());
+    }
+
+    /**
+     * Verifies that the Processors and Controller Services within the template do not make any illegal references to Parameters. I.e., if a Parameter is referenced from a non-sensitive property,
+     * the Parameter itself must not be sensitive. Likewise, if a Parameter is referenced from a sensitive property, the Parameter itself must be sensitive.
+     *
+     * @param snippet the contents of the snippet
+     * @param parameterContext the Parameter Context
+     */
+    private void verifyParameterReferences(final FlowSnippetDTO snippet, final ParameterContext parameterContext) {
+        if (parameterContext == null) {
+            return; // no parameters are referenced because there is no parameter context.
+        }
+
+        final ParameterParser parameterParser = new ExpressionLanguageAwareParameterParser();
+
+        for (final ProcessorDTO processor : snippet.getProcessors()) {
+            final BundleDTO bundleDto = processor.getBundle();
+            final BundleCoordinate bundleCoordinate = new BundleCoordinate(bundleDto.getGroup(), bundleDto.getArtifact(), bundleDto.getVersion());
+            final ConfigurableComponent component = flowController.getExtensionManager().getTempComponent(processor.getType(), bundleCoordinate);
+
+            final ProcessorConfigDTO config = processor.getConfig();
+            for (final Map.Entry<String, String> entry : config.getProperties().entrySet()) {
+                final String propertyName = entry.getKey();
+                final ParameterTokenList references = parameterParser.parseTokens(entry.getValue());
+
+                final PropertyDescriptor descriptor = component.getPropertyDescriptor(propertyName);
+                verifyParameterReference(descriptor, references, parameterContext);
+            }
+        }
+
+        for (final ControllerServiceDTO service : snippet.getControllerServices()) {
+            final BundleDTO bundleDto = service.getBundle();
+            final BundleCoordinate bundleCoordinate = new BundleCoordinate(bundleDto.getGroup(), bundleDto.getArtifact(), bundleDto.getVersion());
+            final ConfigurableComponent component = flowController.getExtensionManager().getTempComponent(service.getType(), bundleCoordinate);
+
+            for (final Map.Entry<String, String> entry : service.getProperties().entrySet()) {
+                final String propertyName = entry.getKey();
+                final ParameterTokenList references = parameterParser.parseTokens(entry.getValue());
+
+                final PropertyDescriptor descriptor = component.getPropertyDescriptor(propertyName);
+                verifyParameterReference(descriptor, references, parameterContext);
+            }
+        }
+    }
+
+    private void verifyParameterReference(final PropertyDescriptor descriptor, final ParameterTokenList parameterTokenList, final ParameterContext parameterContext) {
+        if (descriptor == null || parameterTokenList == null) {
+            return;
+        }
+
+        final List<ParameterReference> references = parameterTokenList.toReferenceList();
+        for (final ParameterReference reference : references) {
+            final String parameterName = reference.getParameterName();
+            final Optional<Parameter> parameter = parameterContext.getParameter(parameterName);
+            if (!parameter.isPresent()) {
+                continue;
+            }
+
+            final boolean parameterSensitive = parameter.get().getDescriptor().isSensitive();
+            if (descriptor.isSensitive() && !parameterSensitive) {
+                throw new IllegalStateException("Cannot instantiate template within this Process Group because template references the '" + parameterName
+                    + "' Parameter in a sensitive property, but the Parameter is not sensitive");
+            }
+            if (!descriptor.isSensitive() && parameterSensitive) {
+                throw new IllegalStateException("Cannot instantiate template within this Process Group because template references the '" + parameterName
+                    + "' Parameter in a non-sensitive property, but the Parameter is sensitive");
+            }
+        }
+    }
+
+    private void verifyComponentTypes(FlowSnippetDTO snippetDto) {
         final StandardFlowSnippet flowSnippet = new StandardFlowSnippet(snippetDto, flowController.getExtensionManager());
         flowSnippet.verifyComponentTypesInSnippet();
     }
 
     @Override
-    public Template createTemplate(TemplateDTO templateDTO, String groupId) {
+    public Template importTemplate(TemplateDTO templateDTO, String groupId) {
+        return createTemplate(templateDTO, groupId);
+    }
+
+    @Override
+    public Template createTemplate(final TemplateDTO templateDTO, final String groupId) {
         final ProcessGroup processGroup = flowController.getFlowManager().getGroup(groupId);
         if (processGroup == null) {
             throw new ResourceNotFoundException("Could not find Process Group with ID " + groupId);
         }
 
-        verifyAdd(templateDTO.getName(), processGroup);
+        verifyCanAddTemplate(templateDTO.getName(), groupId);
 
         TemplateUtils.scrubTemplate(templateDTO);
+        TemplateUtils.escapeParameterReferences(templateDTO);
+
         final Template template = new Template(templateDTO);
         processGroup.addTemplate(template);
 
         return template;
     }
 
-    @Override
-    public Template importTemplate(TemplateDTO templateDTO, String groupId) {
-        return createTemplate(templateDTO, groupId);
-    }
-
     @Override
     public FlowSnippetDTO instantiateTemplate(String groupId, Double originX, Double originY, String encodingVersion,
                                               FlowSnippetDTO requestSnippet, String idGenerationSeed) {
@@ -122,7 +215,7 @@ public FlowSnippetDTO instantiateTemplate(String groupId, Double originX, Double
             // find all the child process groups in each process group in the top level of this snippet
             final List<ProcessGroupDTO> childProcessGroups  = org.apache.nifi.util.SnippetUtils.findAllProcessGroups(snippet);
             // scale (but don't reposition) child process groups
-            childProcessGroups.stream().forEach(processGroup -> org.apache.nifi.util.SnippetUtils.scaleSnippet(processGroup.getContents(), factorX, factorY));
+            childProcessGroups.forEach(processGroup -> org.apache.nifi.util.SnippetUtils.scaleSnippet(processGroup.getContents(), factorX, factorY));
 
             // instantiate the template into this group
             flowController.getFlowManager().instantiateSnippet(group, snippet);
@@ -151,9 +244,7 @@ public Template getTemplate(String templateId) {
     @Override
     public Set<Template> getTemplates() {
         final Set<Template> templates = new HashSet<>();
-        for (final Template template : flowController.getFlowManager().getRootGroup().findAllTemplates()) {
-            templates.add(template);
-        }
+        templates.addAll(flowController.getFlowManager().getRootGroup().findAllTemplates());
         return templates;
     }
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/ClusterReplicationComponentLifecycle.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/ClusterReplicationComponentLifecycle.java
index a2243b5b86e..23825e7dd1f 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/ClusterReplicationComponentLifecycle.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/ClusterReplicationComponentLifecycle.java
@@ -30,11 +30,14 @@
 import org.apache.nifi.web.Revision;
 import org.apache.nifi.web.api.ApplicationResource.ReplicationTarget;
 import org.apache.nifi.web.api.dto.AffectedComponentDTO;
+import org.apache.nifi.web.api.dto.ControllerServiceDTO;
 import org.apache.nifi.web.api.dto.DtoFactory;
+import org.apache.nifi.web.api.dto.ProcessorDTO;
 import org.apache.nifi.web.api.dto.RevisionDTO;
 import org.apache.nifi.web.api.dto.status.ProcessorStatusDTO;
 import org.apache.nifi.web.api.entity.ActivateControllerServicesEntity;
 import org.apache.nifi.web.api.entity.AffectedComponentEntity;
+import org.apache.nifi.web.api.entity.ComponentEntity;
 import org.apache.nifi.web.api.entity.ControllerServiceEntity;
 import org.apache.nifi.web.api.entity.ControllerServicesEntity;
 import org.apache.nifi.web.api.entity.ProcessorEntity;
@@ -67,10 +70,10 @@ public class ClusterReplicationComponentLifecycle implements ComponentLifecycle
 
     @Override
     public Set<AffectedComponentEntity> scheduleComponents(final URI exampleUri, final String groupId, final Set<AffectedComponentEntity> components,
-            final ScheduledState desiredState, final Pause pause) throws LifecycleManagementException {
+            final ScheduledState desiredState, final Pause pause, final InvalidComponentAction invalidComponentAction) throws LifecycleManagementException {
 
         final Set<String> componentIds = components.stream()
-            .map(component -> component.getId())
+            .map(ComponentEntity::getId)
             .collect(Collectors.toSet());
 
         final Map<String, AffectedComponentEntity> componentMap = components.stream()
@@ -114,7 +117,7 @@ public Set<AffectedComponentEntity> scheduleComponents(final URI exampleUri, fin
                 throw new LifecycleManagementException("Failed to transition components to a state of " + desiredState + " due to " + explanation);
             }
 
-            final boolean processorsTransitioned = waitForProcessorStatus(user, exampleUri, groupId, componentMap, desiredState, pause);
+            final boolean processorsTransitioned = waitForProcessorStatus(user, exampleUri, groupId, componentMap, desiredState, pause, invalidComponentAction);
 
             if (!processorsTransitioned) {
                 throw new LifecycleManagementException("Failed while waiting for components to transition to state of " + desiredState);
@@ -150,7 +153,7 @@ protected NodeIdentifier getClusterCoordinatorNode() {
 
     private Map<String, Revision> getRevisions(final String groupId, final Set<String> componentIds) {
         final Set<Revision> processorRevisions = serviceFacade.getRevisionsFromGroup(groupId, group -> componentIds);
-        return processorRevisions.stream().collect(Collectors.toMap(revision -> revision.getComponentId(), Function.identity()));
+        return processorRevisions.stream().collect(Collectors.toMap(Revision::getComponentId, Function.identity()));
     }
 
     /**
@@ -162,10 +165,12 @@ private Map<String, Revision> getRevisions(final String groupId, final Set<Strin
      * @param processors the Processors whose state should be equal to the given desired state
      * @param desiredState the desired state for all processors with the ID's given
      * @param pause the Pause that can be used to wait between polling
+     * @param invalidComponentAction indicates how to handle the condition of a Processor being invalid
      * @return <code>true</code> if successful, <code>false</code> if unable to wait for processors to reach the desired state
      */
     private boolean waitForProcessorStatus(final NiFiUser user, final URI originalUri, final String groupId, final Map<String, AffectedComponentEntity> processors,
-                final ScheduledState desiredState, final Pause pause) throws InterruptedException {
+                final ScheduledState desiredState, final Pause pause, final InvalidComponentAction invalidComponentAction) throws InterruptedException, LifecycleManagementException {
+
         URI groupUri;
         try {
             groupUri = new URI(originalUri.getScheme(), originalUri.getUserInfo(), originalUri.getHost(),
@@ -196,7 +201,7 @@ private boolean waitForProcessorStatus(final NiFiUser user, final URI originalUr
             final ProcessorsEntity processorsEntity = getResponseEntity(clusterResponse, ProcessorsEntity.class);
             final Set<ProcessorEntity> processorEntities = processorsEntity.getProcessors();
 
-            if (isProcessorActionComplete(processorEntities, processors, desiredState)) {
+            if (isProcessorActionComplete(processorEntities, processors, desiredState, invalidComponentAction)) {
                 logger.debug("All {} processors of interest now have the desired state of {}", processors.size(), desiredState);
                 return true;
             }
@@ -226,7 +231,8 @@ private <T> T getResponseEntity(final NodeResponse nodeResponse, final Class<T>
     }
 
 
-    private boolean isProcessorActionComplete(final Set<ProcessorEntity> processorEntities, final Map<String, AffectedComponentEntity> affectedComponents, final ScheduledState desiredState) {
+    private boolean isProcessorActionComplete(final Set<ProcessorEntity> processorEntities, final Map<String, AffectedComponentEntity> affectedComponents, final ScheduledState desiredState,
+                                              final InvalidComponentAction invalidComponentAction) throws LifecycleManagementException {
 
         final String desiredStateName = desiredState.name();
 
@@ -249,26 +255,34 @@ private boolean isProcessorActionComplete(final Set<ProcessorEntity> processorEn
                 }
             });
 
-        final boolean allProcessorsMatch = processorEntities.stream()
-            .filter(entity -> affectedComponents.containsKey(entity.getId()))
-            .allMatch(entity -> {
-                final ProcessorStatusDTO status = entity.getStatus();
-
-                final String runStatus = status.getAggregateSnapshot().getRunStatus();
-                final boolean stateMatches = desiredStateName.equalsIgnoreCase(runStatus);
-                if (!stateMatches) {
-                    return false;
-                }
+        for (final ProcessorEntity entity : processorEntities) {
+            if (!affectedComponents.containsKey(entity.getId())) {
+                continue;
+            }
 
-                if (desiredState == ScheduledState.STOPPED && status.getAggregateSnapshot().getActiveThreadCount() != 0) {
-                    return false;
+            final ProcessorStatusDTO status = entity.getStatus();
+
+            if (ProcessorDTO.INVALID.equals(entity.getComponent().getValidationStatus())) {
+                switch (invalidComponentAction) {
+                    case WAIT:
+                        return false;
+                    case SKIP:
+                        continue;
+                    case FAIL:
+                        final String action = desiredState == ScheduledState.RUNNING ? "start" : "stop";
+                        throw new LifecycleManagementException("Could not " + action + " " + entity.getComponent().getName() + " because it is invalid");
                 }
+            }
 
-                return true;
-            });
+            final String runStatus = status.getAggregateSnapshot().getRunStatus();
+            final boolean stateMatches = desiredStateName.equalsIgnoreCase(runStatus);
+            if (!stateMatches) {
+                return false;
+            }
 
-        if (!allProcessorsMatch) {
-            return false;
+            if (desiredState == ScheduledState.STOPPED && status.getAggregateSnapshot().getActiveThreadCount() != 0) {
+                return false;
+            }
         }
 
         return true;
@@ -278,10 +292,10 @@ private boolean isProcessorActionComplete(final Set<ProcessorEntity> processorEn
 
     @Override
     public Set<AffectedComponentEntity> activateControllerServices(final URI originalUri, final String groupId, final Set<AffectedComponentEntity> affectedServices,
-        final ControllerServiceState desiredState, final Pause pause) throws LifecycleManagementException {
+                                        final ControllerServiceState desiredState, final Pause pause, final InvalidComponentAction invalidComponentAction) throws LifecycleManagementException {
 
         final Set<String> affectedServiceIds = affectedServices.stream()
-            .map(component -> component.getId())
+            .map(ComponentEntity::getId)
             .collect(Collectors.toSet());
 
         final Map<String, Revision> serviceRevisionMap = getRevisions(groupId, affectedServiceIds);
@@ -322,7 +336,7 @@ public Set<AffectedComponentEntity> activateControllerServices(final URI origina
                 throw new LifecycleManagementException("Failed to update Controller Services to a state of " + desiredState + " due to " + explanation);
             }
 
-            final boolean serviceTransitioned = waitForControllerServiceStatus(user, originalUri, groupId, affectedServiceIds, desiredState, pause);
+            final boolean serviceTransitioned = waitForControllerServiceStatus(user, originalUri, groupId, affectedServiceIds, desiredState, pause, invalidComponentAction);
 
             if (!serviceTransitioned) {
                 throw new LifecycleManagementException("Failed while waiting for Controller Services to finish transitioning to a state of " + desiredState);
@@ -349,7 +363,8 @@ public Set<AffectedComponentEntity> activateControllerServices(final URI origina
      * @return <code>true</code> if successful, <code>false</code> if unable to wait for services to reach the desired state
      */
     private boolean waitForControllerServiceStatus(final NiFiUser user, final URI originalUri, final String groupId, final Set<String> serviceIds,
-        final ControllerServiceState desiredState, final Pause pause) throws InterruptedException {
+                                                   final ControllerServiceState desiredState, final Pause pause, final InvalidComponentAction invalidComponentAction)
+                            throws InterruptedException, LifecycleManagementException {
 
         URI groupUri;
         try {
@@ -388,18 +403,39 @@ private boolean waitForControllerServiceStatus(final NiFiUser user, final URI or
             updateAffectedControllerServices(serviceEntities, affectedServices);
 
             final String desiredStateName = desiredState.name();
-            final boolean allServicesMatch = serviceEntities.stream()
-                .map(entity -> entity.getComponent())
-                .filter(service -> serviceIds.contains(service.getId()))
-                .map(service -> service.getState())
-                .allMatch(state -> state.equals(desiredStateName));
-
-            if (allServicesMatch) {
-                logger.debug("All {} controller services of interest now have the desired state of {}", serviceIds.size(), desiredState);
+            boolean allReachedDesiredState = true;
+            for (final ControllerServiceEntity serviceEntity : serviceEntities) {
+                final ControllerServiceDTO serviceDto = serviceEntity.getComponent();
+                if (!affectedServices.containsKey(serviceDto.getId())) {
+                    continue;
+                }
+
+                final String validationStatus = serviceDto.getValidationStatus();
+                if (ControllerServiceDTO.INVALID.equals(validationStatus)) {
+                    switch (invalidComponentAction) {
+                        case WAIT:
+                            allReachedDesiredState = false;
+                            break;
+                        case SKIP:
+                            continue;
+                        case FAIL:
+                            final String action = desiredState == ControllerServiceState.ENABLED ? "enable" : "disable";
+                            throw new LifecycleManagementException("Could not " + action + " " + serviceEntity.getComponent().getName() + " because it is invalid");
+                    }
+                }
+
+                if (!desiredStateName.equalsIgnoreCase(serviceDto.getState())) {
+                    allReachedDesiredState = false;
+                    break;
+                }
+            }
+
+            if (allReachedDesiredState) {
+                logger.debug("All {} controller services of interest now have the desired state of {}", affectedServices.size(), desiredState);
                 return true;
             }
 
-            // Not all of the processors are in the desired state. Pause for a bit and poll again.
+            // Not all of the controller services are in the desired state. Pause for a bit and poll again.
             continuePolling = pause.pause();
         }
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/ComponentLifecycle.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/ComponentLifecycle.java
index 687c370aefe..dd4ed5b3950 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/ComponentLifecycle.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/ComponentLifecycle.java
@@ -33,13 +33,14 @@ public interface ComponentLifecycle {
      * @param components the components to schedule or unschedule
      * @param desiredState the desired state of the components
      * @param pause a pause that can be used to determine how long to wait between polling for task completion and that can also be used to cancel the operation
+     * @param invalidComponentAction when waiting for a component to reach the specified desired state, indicates how the deal with a component that is invalid
      *
      * @return the set of all AffectedComponents that are updated by the request, including the new Revisions
      *
      * @throws IllegalStateException if any of the components given do not have a state that can be transitioned to the given desired state
      */
     Set<AffectedComponentEntity> scheduleComponents(URI exampleUri, String groupId, Set<AffectedComponentEntity> components,
-        ScheduledState desiredState, Pause pause) throws LifecycleManagementException;
+        ScheduledState desiredState, Pause pause, InvalidComponentAction invalidComponentAction) throws LifecycleManagementException;
 
     /**
      * Updates the Controller Service State state of all controller services that are given, to match the desired ControllerServiceState
@@ -49,11 +50,12 @@ Set<AffectedComponentEntity> scheduleComponents(URI exampleUri, String groupId,
      * @param services the controller services to enable or disable
      * @param desiredState the desired state of the components
      * @param pause a pause that can be used to determine how long to wait between polling for task completion and that can also be used to cancel the operation
+     * @param invalidComponentAction when waiting for a component to reach the specified desired state, indicates how the deal with a component that is invalid
      *
      * @return the set of all AffectedComponents that are updated by the request, including the new Revisions
      *
      * @throws IllegalStateException if any of the components given do not have a state that can be transitioned to the given desired state
      */
     Set<AffectedComponentEntity> activateControllerServices(URI exampleUri, String groupId, Set<AffectedComponentEntity> services,
-        ControllerServiceState desiredState, Pause pause) throws LifecycleManagementException;
+        ControllerServiceState desiredState, Pause pause, InvalidComponentAction invalidComponentAction) throws LifecycleManagementException;
 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/InvalidComponentAction.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/InvalidComponentAction.java
new file mode 100644
index 00000000000..7f51bce6657
--- /dev/null
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/InvalidComponentAction.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.web.util;
+
+public enum InvalidComponentAction {
+    /**
+     * Wait until the invalid component becomes valid before continuing
+     */
+    WAIT,
+
+    /**
+     * Do not wait for the component to become valid and instead just continue on, as if the component had reached the desired state
+     */
+    SKIP,
+
+    /**
+     * Throw a {@link LifecycleManagementException} if a component is invalid
+     */
+    FAIL;
+}
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/LocalComponentLifecycle.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/LocalComponentLifecycle.java
index 8a086845869..b597797e5db 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/LocalComponentLifecycle.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/LocalComponentLifecycle.java
@@ -24,7 +24,9 @@
 import org.apache.nifi.web.NiFiServiceFacade;
 import org.apache.nifi.web.Revision;
 import org.apache.nifi.web.api.dto.AffectedComponentDTO;
+import org.apache.nifi.web.api.dto.ControllerServiceDTO;
 import org.apache.nifi.web.api.dto.DtoFactory;
+import org.apache.nifi.web.api.dto.ProcessorDTO;
 import org.apache.nifi.web.api.dto.status.ProcessorStatusDTO;
 import org.apache.nifi.web.api.entity.AffectedComponentEntity;
 import org.apache.nifi.web.api.entity.ControllerServiceEntity;
@@ -51,7 +53,7 @@ public class LocalComponentLifecycle implements ComponentLifecycle {
 
     @Override
     public Set<AffectedComponentEntity> scheduleComponents(final URI exampleUri, final String groupId, final Set<AffectedComponentEntity> components,
-        final ScheduledState desiredState, final Pause pause) throws LifecycleManagementException {
+        final ScheduledState desiredState, final Pause pause, final InvalidComponentAction invalidComponentAction) throws LifecycleManagementException {
 
         final Map<String, Revision> processorRevisions = components.stream()
             .collect(Collectors.toMap(AffectedComponentEntity::getId, entity -> revisionManager.getRevision(entity.getId())));
@@ -60,9 +62,9 @@ public Set<AffectedComponentEntity> scheduleComponents(final URI exampleUri, fin
             .collect(Collectors.toMap(AffectedComponentEntity::getId, Function.identity()));
 
         if (desiredState == ScheduledState.RUNNING) {
-            startComponents(groupId, processorRevisions, affectedComponentMap, pause);
+            startComponents(groupId, processorRevisions, affectedComponentMap, pause, invalidComponentAction);
         } else {
-            stopComponents(groupId, processorRevisions, affectedComponentMap, pause);
+            stopComponents(groupId, processorRevisions, affectedComponentMap, pause, invalidComponentAction);
         }
 
         final Set<AffectedComponentEntity> updatedEntities = components.stream()
@@ -73,7 +75,7 @@ public Set<AffectedComponentEntity> scheduleComponents(final URI exampleUri, fin
 
     @Override
     public Set<AffectedComponentEntity> activateControllerServices(final URI exampleUri, final String groupId, final Set<AffectedComponentEntity> services,
-        final ControllerServiceState desiredState, final Pause pause) throws LifecycleManagementException {
+        final ControllerServiceState desiredState, final Pause pause, final InvalidComponentAction invalidComponentAction) throws LifecycleManagementException {
 
         final Map<String, Revision> serviceRevisions = services.stream()
             .collect(Collectors.toMap(AffectedComponentEntity::getId, entity -> revisionManager.getRevision(entity.getId())));
@@ -82,9 +84,9 @@ public Set<AffectedComponentEntity> activateControllerServices(final URI example
             .collect(Collectors.toMap(AffectedComponentEntity::getId, Function.identity()));
 
         if (desiredState == ControllerServiceState.ENABLED) {
-            enableControllerServices(groupId, serviceRevisions, affectedServiceMap, pause);
+            enableControllerServices(groupId, serviceRevisions, affectedServiceMap, pause, invalidComponentAction);
         } else {
-            disableControllerServices(groupId, serviceRevisions, affectedServiceMap, pause);
+            disableControllerServices(groupId, serviceRevisions, affectedServiceMap, pause, invalidComponentAction);
         }
 
         return services.stream()
@@ -94,7 +96,8 @@ public Set<AffectedComponentEntity> activateControllerServices(final URI example
     }
 
 
-    private void startComponents(final String processGroupId, final Map<String, Revision> componentRevisions, final Map<String, AffectedComponentEntity> affectedComponents, final Pause pause) {
+    private void startComponents(final String processGroupId, final Map<String, Revision> componentRevisions, final Map<String, AffectedComponentEntity> affectedComponents, final Pause pause,
+                                 final InvalidComponentAction invalidComponentAction) throws LifecycleManagementException {
 
         if (componentRevisions.isEmpty()) {
             return;
@@ -107,10 +110,11 @@ private void startComponents(final String processGroupId, final Map<String, Revi
 
         // wait for all of the Processors to reach the desired state. We don't have to wait for other components because
         // Local and Remote Ports as well as funnels start immediately.
-        waitForProcessorState(processGroupId, affectedComponents, ScheduledState.RUNNING, pause);
+        waitForProcessorState(processGroupId, affectedComponents, ScheduledState.RUNNING, pause, invalidComponentAction);
     }
 
-    private void stopComponents(final String processGroupId, final Map<String, Revision> componentRevisions, final Map<String, AffectedComponentEntity> affectedComponents, final Pause pause) {
+    private void stopComponents(final String processGroupId, final Map<String, Revision> componentRevisions, final Map<String, AffectedComponentEntity> affectedComponents, final Pause pause,
+                                final InvalidComponentAction invalidComponentAction) throws LifecycleManagementException {
 
         if (componentRevisions.isEmpty()) {
             return;
@@ -123,7 +127,7 @@ private void stopComponents(final String processGroupId, final Map<String, Revis
 
         // wait for all of the Processors to reach the desired state. We don't have to wait for other components because
         // Local and Remote Ports as well as funnels stop immediately.
-        waitForProcessorState(processGroupId, affectedComponents, ScheduledState.STOPPED, pause);
+        waitForProcessorState(processGroupId, affectedComponents, ScheduledState.STOPPED, pause, invalidComponentAction);
     }
 
     /**
@@ -133,7 +137,7 @@ private void stopComponents(final String processGroupId, final Map<String, Revis
      *         to give up before all of the processors have reached the desired state
      */
     private boolean waitForProcessorState(final String groupId, final Map<String, AffectedComponentEntity> affectedComponents,
-        final ScheduledState desiredState, final Pause pause) {
+        final ScheduledState desiredState, final Pause pause, final InvalidComponentAction invalidComponentAction) throws LifecycleManagementException {
 
         logger.debug("Waiting for {} processors to transition their states to {}", affectedComponents.size(), desiredState);
 
@@ -141,7 +145,7 @@ private boolean waitForProcessorState(final String groupId, final Map<String, Af
         while (continuePolling) {
             final Set<ProcessorEntity> processorEntities = serviceFacade.getProcessors(groupId, true);
 
-            if (isProcessorActionComplete(processorEntities, affectedComponents, desiredState)) {
+            if (isProcessorActionComplete(processorEntities, affectedComponents, desiredState, invalidComponentAction)) {
                 logger.debug("All {} processors of interest now have the desired state of {}", affectedComponents.size(), desiredState);
                 return true;
             }
@@ -153,7 +157,8 @@ private boolean waitForProcessorState(final String groupId, final Map<String, Af
         return false;
     }
 
-    private boolean isProcessorActionComplete(final Set<ProcessorEntity> processorEntities, final Map<String, AffectedComponentEntity> affectedComponents, final ScheduledState desiredState) {
+    private boolean isProcessorActionComplete(final Set<ProcessorEntity> processorEntities, final Map<String, AffectedComponentEntity> affectedComponents, final ScheduledState desiredState,
+                                              final InvalidComponentAction invalidComponentAction) throws LifecycleManagementException {
 
         final String desiredStateName = desiredState.name();
 
@@ -164,7 +169,7 @@ private boolean isProcessorActionComplete(final Set<ProcessorEntity> processorEn
                 final AffectedComponentEntity affectedComponentEntity = affectedComponents.get(entity.getId());
                 affectedComponentEntity.setRevision(entity.getRevision());
 
-                // only consider updating this component if the user had permissions to it
+                // only consider updating this component if the user has permissions to it
                 if (Boolean.TRUE.equals(affectedComponentEntity.getPermissions().getCanRead())) {
                     final AffectedComponentDTO affectedComponent = affectedComponentEntity.getComponent();
                     affectedComponent.setState(entity.getStatus().getAggregateSnapshot().getRunStatus());
@@ -176,33 +181,42 @@ private boolean isProcessorActionComplete(final Set<ProcessorEntity> processorEn
                 }
             });
 
-        final boolean allProcessorsMatch = processorEntities.stream()
-            .filter(entity -> affectedComponents.containsKey(entity.getId()))
-            .allMatch(entity -> {
-                final ProcessorStatusDTO status = entity.getStatus();
-
-                final String runStatus = status.getAggregateSnapshot().getRunStatus();
-                final boolean stateMatches = desiredStateName.equalsIgnoreCase(runStatus);
-                if (!stateMatches) {
-                    return false;
-                }
+        for (final ProcessorEntity entity : processorEntities) {
+            if (!affectedComponents.containsKey(entity.getId())) {
+                continue;
+            }
 
-                if (desiredState == ScheduledState.STOPPED && status.getAggregateSnapshot().getActiveThreadCount() != 0) {
-                    return false;
+            final ProcessorStatusDTO status = entity.getStatus();
+
+            if (ProcessorDTO.INVALID.equals(entity.getComponent().getValidationStatus())) {
+                switch (invalidComponentAction) {
+                    case WAIT:
+                        return false;
+                    case SKIP:
+                        continue;
+                    case FAIL:
+                        final String action = desiredState == ScheduledState.RUNNING ? "start" : "stop";
+                        throw new LifecycleManagementException("Could not " + action + " " + entity.getComponent().getName() + " because it is invalid");
                 }
+            }
 
-                return true;
-            });
+            final String runStatus = status.getAggregateSnapshot().getRunStatus();
+            final boolean stateMatches = desiredStateName.equalsIgnoreCase(runStatus);
+            if (!stateMatches) {
+                return false;
+            }
 
-        if (!allProcessorsMatch) {
-            return false;
+            if (desiredState == ScheduledState.STOPPED && status.getAggregateSnapshot().getActiveThreadCount() != 0) {
+                return false;
+            }
         }
 
         return true;
     }
 
 
-    private void enableControllerServices(final String processGroupId, final Map<String, Revision> serviceRevisions, final Map<String, AffectedComponentEntity> affectedServices, final Pause pause) {
+    private void enableControllerServices(final String processGroupId, final Map<String, Revision> serviceRevisions, final Map<String, AffectedComponentEntity> affectedServices, final Pause pause,
+                                          final InvalidComponentAction invalidComponentAction) throws LifecycleManagementException {
 
         if (serviceRevisions.isEmpty()) {
             return;
@@ -212,10 +226,11 @@ private void enableControllerServices(final String processGroupId, final Map<Str
 
         serviceFacade.verifyActivateControllerServices(processGroupId, ControllerServiceState.ENABLED, affectedServices.keySet());
         serviceFacade.activateControllerServices(processGroupId, ControllerServiceState.ENABLED, serviceRevisions);
-        waitForControllerServiceState(processGroupId, affectedServices, ControllerServiceState.ENABLED, pause);
+        waitForControllerServiceState(processGroupId, affectedServices, ControllerServiceState.ENABLED, pause, invalidComponentAction);
     }
 
-    private void disableControllerServices(final String processGroupId, final Map<String, Revision> serviceRevisions, final Map<String, AffectedComponentEntity> affectedServices, final Pause pause) {
+    private void disableControllerServices(final String processGroupId, final Map<String, Revision> serviceRevisions, final Map<String, AffectedComponentEntity> affectedServices, final Pause pause,
+                                           final InvalidComponentAction invalidComponentAction) throws LifecycleManagementException {
 
         if (serviceRevisions.isEmpty()) {
             return;
@@ -225,7 +240,7 @@ private void disableControllerServices(final String processGroupId, final Map<St
 
         serviceFacade.verifyActivateControllerServices(processGroupId, ControllerServiceState.DISABLED, affectedServices.keySet());
         serviceFacade.activateControllerServices(processGroupId, ControllerServiceState.DISABLED, serviceRevisions);
-        waitForControllerServiceState(processGroupId, affectedServices, ControllerServiceState.DISABLED, pause);
+        waitForControllerServiceState(processGroupId, affectedServices, ControllerServiceState.DISABLED, pause, invalidComponentAction);
     }
 
     static List<List<ControllerServiceNode>> determineEnablingOrder(final Map<String, ControllerServiceNode> serviceNodeMap) {
@@ -249,7 +264,7 @@ private static void determineEnablingOrder(
             return;
         }
 
-        for (final Map.Entry<PropertyDescriptor, String> entry : contextNode.getProperties().entrySet()) {
+        for (final Map.Entry<PropertyDescriptor, String> entry : contextNode.getEffectivePropertyValues().entrySet()) {
             if (entry.getKey().getControllerServiceDefinition() != null) {
                 final String referencedServiceId = entry.getValue();
                 if (referencedServiceId != null) {
@@ -277,7 +292,8 @@ private static void determineEnablingOrder(
      * @param pause the Pause that can be used to wait between polling
      * @return <code>true</code> if successful, <code>false</code> if unable to wait for services to reach the desired state
      */
-    private boolean waitForControllerServiceState(final String groupId, final Map<String, AffectedComponentEntity> affectedServices, final ControllerServiceState desiredState, final Pause pause) {
+    private boolean waitForControllerServiceState(final String groupId, final Map<String, AffectedComponentEntity> affectedServices, final ControllerServiceState desiredState, final Pause pause,
+                                                  final InvalidComponentAction invalidComponentAction) throws LifecycleManagementException {
 
         logger.debug("Waiting for {} Controller Services to transition their states to {}", affectedServices.size(), desiredState);
 
@@ -289,19 +305,40 @@ private boolean waitForControllerServiceState(final String groupId, final Map<St
             updateAffectedControllerServices(serviceEntities, affectedServices);
 
             final String desiredStateName = desiredState.name();
-            final boolean allServicesMatch = serviceEntities.stream()
-                .map(entity -> entity.getComponent())
-                .filter(service -> affectedServices.containsKey(service.getId()))
-                .map(service -> service.getState())
-                .allMatch(state -> desiredStateName.equals(state));
 
+            boolean allReachedDesiredState = true;
+            for (final ControllerServiceEntity serviceEntity : serviceEntities) {
+                final ControllerServiceDTO serviceDto = serviceEntity.getComponent();
+                if (!affectedServices.containsKey(serviceDto.getId())) {
+                    continue;
+                }
+
+                final String validationStatus = serviceDto.getValidationStatus();
+                if (ControllerServiceDTO.INVALID.equals(validationStatus)) {
+                    switch (invalidComponentAction) {
+                        case WAIT:
+                            allReachedDesiredState = false;
+                            break;
+                        case SKIP:
+                            continue;
+                        case FAIL:
+                            final String action = desiredState == ControllerServiceState.ENABLED ? "enable" : "disable";
+                            throw new LifecycleManagementException("Could not " + action + " " + serviceEntity.getComponent().getName() + " because it is invalid");
+                    }
+                }
 
-            if (allServicesMatch) {
+                if (!desiredStateName.equals(serviceDto.getState())) {
+                    allReachedDesiredState = false;
+                    break;
+                }
+            }
+
+            if (allReachedDesiredState) {
                 logger.debug("All {} controller services of interest now have the desired state of {}", affectedServices.size(), desiredState);
                 return true;
             }
 
-            // Not all of the processors are in the desired state. Pause for a bit and poll again.
+            // Not all of the controller services are in the desired state. Pause for a bit and poll again.
             continuePolling = pause.pause();
         }
 
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/SnippetUtils.java b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/SnippetUtils.java
index f60328467f8..7e81c9b773a 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/SnippetUtils.java
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/util/SnippetUtils.java
@@ -162,8 +162,8 @@ public FlowSnippetDTO populateFlowSnippet(final Snippet snippet, final boolean r
 
                 if (includeControllerServices) {
                     // Include all referenced services that are not already included in this snippet.
-                    getControllerServices(processor.getProperties()).stream()
-                        .filter(svc -> allServicesReferenced.add(svc))
+                    getControllerServices(processor.getEffectivePropertyValues()).stream()
+                        .filter(allServicesReferenced::add)
                         .forEach(svc -> {
                             final String svcGroupId = svc.getParentGroupId();
                             final String destinationGroupId = contentsByGroup.containsKey(svcGroupId) ? svcGroupId : processGroup.getIdentifier();
@@ -324,8 +324,8 @@ private void addControllerServices(final ProcessGroup group, final ProcessGroupD
 
         for (final ProcessorNode procNode : group.getProcessors()) {
             // Include all referenced services that are not already included in this snippet.
-            getControllerServices(procNode.getProperties()).stream()
-                .filter(svc -> allServicesReferenced.add(svc))
+            getControllerServices(procNode.getEffectivePropertyValues()).stream()
+                .filter(allServicesReferenced::add)
                 .filter(svc -> includeControllerServices || visitedGroupIds.contains(svc.getParentGroupId()))
                 .forEach(svc -> {
                     final String svcGroupId = svc.getParentGroupId();
@@ -346,7 +346,7 @@ private void addControllerServices(final ProcessGroup group, final ProcessGroupD
 
         // Map child process group ID to the child process group for easy lookup
         final Map<String, ProcessGroupDTO> childGroupMap = contents.getProcessGroups().stream()
-            .collect(Collectors.toMap(childGroupDto -> childGroupDto.getId(), childGroupDto -> childGroupDto));
+            .collect(Collectors.toMap(ComponentDTO::getId, childGroupDto -> childGroupDto));
 
         for (final ProcessGroup childGroup : group.getProcessGroups()) {
             final ProcessGroupDTO childDto = childGroupMap.get(childGroup.getIdentifier());
@@ -370,7 +370,7 @@ private Set<ControllerServiceDTO> getControllerServices(final Map<PropertyDescri
                     if (serviceNode != null) {
                         serviceDtos.add(dtoFactory.createControllerServiceDto(serviceNode));
 
-                        final Set<ControllerServiceDTO> recursiveRefs = getControllerServices(serviceNode.getProperties());
+                        final Set<ControllerServiceDTO> recursiveRefs = getControllerServices(serviceNode.getEffectivePropertyValues());
                         serviceDtos.addAll(recursiveRefs);
                     }
                 }
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/resources/nifi-web-api-context.xml b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/resources/nifi-web-api-context.xml
index 38257d65c6e..c2b2b6828d5 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/resources/nifi-web-api-context.xml
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/resources/nifi-web-api-context.xml
@@ -133,6 +133,9 @@
     <bean id="policyBasedAuthorizerDAO" class="org.apache.nifi.web.dao.impl.StandardPolicyBasedAuthorizerDAO">
         <constructor-arg ref="authorizer"/>
     </bean>
+    <bean id="parameterContextDAO" class="org.apache.nifi.web.dao.impl.StandardParameterContextDAO">
+        <property name="flowController" ref="flowController" />
+    </bean>
     <bean id="controllerSearchService" class="org.apache.nifi.web.controller.ControllerSearchService">
         <property name="flowController" ref="flowController"/>
         <property name="authorizer" ref="authorizer"/>
@@ -162,6 +165,7 @@
         <property name="templateDAO" ref="templateDAO"/>
         <property name="snippetDAO" ref="snippetDAO"/>
         <property name="accessPolicyDAO" ref="policyBasedAuthorizerDAO"/>
+        <property name="parameterContextDAO" ref="parameterContextDAO" />
     </bean>
     <bean id="serviceFacade" class="org.apache.nifi.web.StandardNiFiServiceFacade">
         <property name="authorizableLookup" ref="authorizableLookup" />
@@ -194,6 +198,7 @@
         <property name="leaderElectionManager" ref="leaderElectionManager" />
         <property name="flowRegistryClient" ref="flowRegistryClient" />
         <property name="registryDAO" ref="flowRegistryDAO" />
+        <property name="parameterContextDAO" ref="parameterContextDAO" />
     </bean>
 
     <!-- component ui extension configuration context -->
@@ -452,6 +457,17 @@
         <constructor-arg ref="requestReplicator" />
         <constructor-arg ref="flowController" />
     </bean>
+    <bean id="parameterContextResource" class="org.apache.nifi.web.api.ParameterContextResource" scope="singleton">
+        <property name="serviceFacade" ref="serviceFacade" />
+        <property name="authorizer" ref="authorizer" />
+        <property name="properties" ref="nifiProperties"/>
+        <property name="clusterCoordinator" ref="clusterCoordinator"/>
+        <property name="requestReplicator" ref="requestReplicator" />
+        <property name="flowController" ref="flowController" />
+        <property name="dtoFactory" ref="dtoFactory" />
+        <property name="clusterComponentLifecycle" ref="clusterComponentLifecycle" />
+        <property name="localComponentLifecycle" ref="localComponentLifecycle" />
+    </bean>
 
     <!-- enable aop -->
     <!--
diff --git a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/pom.xml b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/pom.xml
index d3136e4a600..cb06238b0d3 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/pom.xml
+++ b/nifi-nar-bundles/nifi-framework-bundle/nifi-framework/pom.xml
@@ -36,7 +36,7 @@
         <module>nifi-framework-cluster</module>
         <module>nifi-framework-nar-utils</module>
         <module>nifi-framework-nar-loading-utils</module>
-	<module>nifi-user-actions</module>
+	    <module>nifi-user-actions</module>
         <module>nifi-framework-authorization</module>
         <module>nifi-file-authorizer</module>
         <module>nifi-administration</module>
diff --git a/nifi-nar-bundles/nifi-framework-bundle/pom.xml b/nifi-nar-bundles/nifi-framework-bundle/pom.xml
index 825ebd5a0c0..1555a5a1f72 100644
--- a/nifi-nar-bundles/nifi-framework-bundle/pom.xml
+++ b/nifi-nar-bundles/nifi-framework-bundle/pom.xml
@@ -194,6 +194,11 @@
                 <artifactId>nifi-authorizer</artifactId>
                 <version>1.10.0-SNAPSHOT</version>
             </dependency>
+            <dependency>
+                <groupId>org.apache.nifi</groupId>
+                <artifactId>nifi-parameter</artifactId>
+                <version>1.10.0-SNAPSHOT</version>
+            </dependency>
             <dependency>
                 <groupId>com.ibm.icu</groupId>
                 <artifactId>icu4j</artifactId>
diff --git a/nifi-nar-bundles/nifi-ldap-iaa-providers-bundle/nifi-ldap-iaa-providers/src/test/java/org/apache/nifi/ldap/tenants/LdapUserGroupProviderTest.java b/nifi-nar-bundles/nifi-ldap-iaa-providers-bundle/nifi-ldap-iaa-providers/src/test/java/org/apache/nifi/ldap/tenants/LdapUserGroupProviderTest.java
index aae5a7c1b32..d40ce413a79 100644
--- a/nifi-nar-bundles/nifi-ldap-iaa-providers-bundle/nifi-ldap-iaa-providers/src/test/java/org/apache/nifi/ldap/tenants/LdapUserGroupProviderTest.java
+++ b/nifi-nar-bundles/nifi-ldap-iaa-providers-bundle/nifi-ldap-iaa-providers/src/test/java/org/apache/nifi/ldap/tenants/LdapUserGroupProviderTest.java
@@ -23,6 +23,7 @@
 import org.apache.directory.server.core.annotations.CreatePartition;
 import org.apache.directory.server.core.integ.AbstractLdapTestUnit;
 import org.apache.directory.server.core.integ.FrameworkRunner;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.authorization.AuthorizerConfigurationContext;
 import org.apache.nifi.authorization.Group;
@@ -42,8 +43,8 @@
 
 import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_AUTHENTICATION_STRATEGY;
 import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_CONNECT_TIMEOUT;
-import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_GROUP_MEMBER_REFERENCED_USER_ATTRIBUTE;
 import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_GROUP_MEMBER_ATTRIBUTE;
+import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_GROUP_MEMBER_REFERENCED_USER_ATTRIBUTE;
 import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_GROUP_NAME_ATTRIBUTE;
 import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_GROUP_OBJECT_CLASS;
 import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_GROUP_SEARCH_BASE;
@@ -56,8 +57,8 @@
 import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_REFERRAL_STRATEGY;
 import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_SYNC_INTERVAL;
 import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_URL;
-import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_USER_GROUP_REFERENCED_GROUP_ATTRIBUTE;
 import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_USER_GROUP_ATTRIBUTE;
+import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_USER_GROUP_REFERENCED_GROUP_ATTRIBUTE;
 import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_USER_IDENTITY_ATTRIBUTE;
 import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_USER_OBJECT_CLASS;
 import static org.apache.nifi.ldap.tenants.LdapUserGroupProvider.PROP_USER_SEARCH_BASE;
@@ -101,21 +102,21 @@ public void testNoSearchBasesSpecified() throws Exception {
     @Test(expected = AuthorizerCreationException.class)
     public void testUserSearchBaseSpecifiedButNoUserObjectClass() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, null);
-        when(configurationContext.getProperty(PROP_USER_OBJECT_CLASS)).thenReturn(new StandardPropertyValue(null, null));
+        when(configurationContext.getProperty(PROP_USER_OBJECT_CLASS)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
     }
 
     @Test(expected = AuthorizerCreationException.class)
     public void testUserSearchBaseSpecifiedButNoUserSearchScope() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, null);
-        when(configurationContext.getProperty(PROP_USER_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(null, null));
+        when(configurationContext.getProperty(PROP_USER_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
     }
 
     @Test(expected = AuthorizerCreationException.class)
     public void testInvalidUserSearchScope() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, null);
-        when(configurationContext.getProperty(PROP_USER_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue("not-valid", null));
+        when(configurationContext.getProperty(PROP_USER_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue("not-valid", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
     }
 
@@ -132,7 +133,7 @@ public void testSearchUsersWithNoIdentityAttribute() throws Exception {
     @Test
     public void testSearchUsersWithUidIdentityAttribute() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, null);
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null));
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(8, ldapUserGroupProvider.getUsers().size());
@@ -143,7 +144,7 @@ public void testSearchUsersWithUidIdentityAttribute() throws Exception {
     @Test
     public void testSearchUsersWithCnIdentityAttribute() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, null);
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(8, ldapUserGroupProvider.getUsers().size());
@@ -154,7 +155,7 @@ public void testSearchUsersWithCnIdentityAttribute() throws Exception {
     @Test
     public void testSearchUsersObjectSearchScope() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, null);
-        when(configurationContext.getProperty(PROP_USER_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(SearchScope.OBJECT.name(), null));
+        when(configurationContext.getProperty(PROP_USER_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(SearchScope.OBJECT.name(), null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertTrue(ldapUserGroupProvider.getUsers().isEmpty());
@@ -164,7 +165,7 @@ public void testSearchUsersObjectSearchScope() throws Exception {
     @Test
     public void testSearchUsersSubtreeSearchScope() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration("o=nifi", null);
-        when(configurationContext.getProperty(PROP_USER_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(SearchScope.SUBTREE.name(), null));
+        when(configurationContext.getProperty(PROP_USER_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(SearchScope.SUBTREE.name(), null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(9, ldapUserGroupProvider.getUsers().size());
@@ -174,8 +175,8 @@ public void testSearchUsersSubtreeSearchScope() throws Exception {
     @Test
     public void testSearchUsersWithFilter() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, null);
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null));
-        when(configurationContext.getProperty(PROP_USER_SEARCH_FILTER)).thenReturn(new StandardPropertyValue("(uid=user1)", null));
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_SEARCH_FILTER)).thenReturn(new StandardPropertyValue("(uid=user1)", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(1, ldapUserGroupProvider.getUsers().size());
@@ -186,7 +187,7 @@ public void testSearchUsersWithFilter() throws Exception {
     @Test
     public void testSearchUsersWithPaging() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, null);
-        when(configurationContext.getProperty(PROP_PAGE_SIZE)).thenReturn(new StandardPropertyValue("1", null));
+        when(configurationContext.getProperty(PROP_PAGE_SIZE)).thenReturn(new StandardPropertyValue("1", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(8, ldapUserGroupProvider.getUsers().size());
@@ -196,8 +197,8 @@ public void testSearchUsersWithPaging() throws Exception {
     @Test
     public void testSearchUsersWithGroupingNoGroupName() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, null);
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null));
-        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null)); // using description in lieu of memberof
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null, ParameterLookup.EMPTY)); // using description in lieu of memberof
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(8, ldapUserGroupProvider.getUsers().size());
@@ -212,9 +213,9 @@ public void testSearchUsersWithGroupingNoGroupName() throws Exception {
     @Test
     public void testSearchUsersWithGroupingAndGroupName() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, null);
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null));
-        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null)); // using description in lieu of memberof
-        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null, ParameterLookup.EMPTY)); // using description in lieu of memberof
+        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(8, ldapUserGroupProvider.getUsers().size());
@@ -235,31 +236,31 @@ public void testSearchGroupsWithoutMemberAttribute() throws Exception {
     @Test(expected = AuthorizerCreationException.class)
     public void testGroupSearchBaseSpecifiedButNoGroupObjectClass() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(null, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null));
-        when(configurationContext.getProperty(PROP_GROUP_OBJECT_CLASS)).thenReturn(new StandardPropertyValue(null, null));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_OBJECT_CLASS)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
     }
 
     @Test(expected = AuthorizerCreationException.class)
     public void testUserSearchBaseSpecifiedButNoGroupSearchScope() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(null, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null));
-        when(configurationContext.getProperty(PROP_GROUP_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(null, null));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
     }
 
     @Test(expected = AuthorizerCreationException.class)
     public void testInvalidGroupSearchScope() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(null, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null));
-        when(configurationContext.getProperty(PROP_GROUP_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue("not-valid", null));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue("not-valid", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
     }
 
     @Test
     public void testSearchGroupsWithNoNameAttribute() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(null, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         final Set<Group> groups = ldapUserGroupProvider.getGroups();
@@ -270,8 +271,8 @@ public void testSearchGroupsWithNoNameAttribute() throws Exception {
     @Test
     public void testSearchGroupsWithPaging() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(null, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null));
-        when(configurationContext.getProperty(PROP_PAGE_SIZE)).thenReturn(new StandardPropertyValue("1", null));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_PAGE_SIZE)).thenReturn(new StandardPropertyValue("1", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(4, ldapUserGroupProvider.getGroups().size());
@@ -280,8 +281,8 @@ public void testSearchGroupsWithPaging() throws Exception {
     @Test
     public void testSearchGroupsObjectSearchScope() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(null, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null));
-        when(configurationContext.getProperty(PROP_GROUP_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(SearchScope.OBJECT.name(), null));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(SearchScope.OBJECT.name(), null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertTrue(ldapUserGroupProvider.getUsers().isEmpty());
@@ -291,8 +292,8 @@ public void testSearchGroupsObjectSearchScope() throws Exception {
     @Test
     public void testSearchGroupsSubtreeSearchScope() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(null, "o=nifi");
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null));
-        when(configurationContext.getProperty(PROP_GROUP_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(SearchScope.SUBTREE.name(), null));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(SearchScope.SUBTREE.name(), null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(4, ldapUserGroupProvider.getGroups().size());
@@ -301,8 +302,8 @@ public void testSearchGroupsSubtreeSearchScope() throws Exception {
     @Test
     public void testSearchGroupsWithNameAttribute() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(null, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null));
-        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         final Set<Group> groups = ldapUserGroupProvider.getGroups();
@@ -319,8 +320,8 @@ public void testSearchGroupsWithNameAttribute() throws Exception {
     @Test
     public void testSearchGroupsWithNoNameAndUserIdentityUidAttribute() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(null, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null));
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         final Set<Group> groups = ldapUserGroupProvider.getGroups();
@@ -337,9 +338,9 @@ public void testSearchGroupsWithNoNameAndUserIdentityUidAttribute() throws Excep
     @Test
     public void testSearchGroupsWithNameAndUserIdentityCnAttribute() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(null, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null));
-        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         final Set<Group> groups = ldapUserGroupProvider.getGroups();
@@ -356,8 +357,8 @@ public void testSearchGroupsWithNameAndUserIdentityCnAttribute() throws Exceptio
     @Test
     public void testSearchGroupsWithFilter() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(null, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null));
-        when(configurationContext.getProperty(PROP_GROUP_SEARCH_FILTER)).thenReturn(new StandardPropertyValue("(cn=admins)", null));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_SEARCH_FILTER)).thenReturn(new StandardPropertyValue("(cn=admins)", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         final Set<Group> groups = ldapUserGroupProvider.getGroups();
@@ -380,9 +381,9 @@ public void testSearchUsersAndGroupsNoMembership() throws Exception {
     @Test
     public void testSearchUsersAndGroupsMembershipThroughUsers() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null));
-        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null)); // using description in lieu of memberof
-        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null, ParameterLookup.EMPTY)); // using description in lieu of memberof
+        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(8, ldapUserGroupProvider.getUsers().size());
@@ -408,9 +409,9 @@ public void testSearchUsersAndGroupsMembershipThroughUsers() throws Exception {
     @Test
     public void testSearchUsersAndGroupsMembershipThroughGroups() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null));
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null));
-        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(8, ldapUserGroupProvider.getUsers().size());
@@ -450,10 +451,10 @@ public void testSearchUsersAndGroupsMembershipThroughGroups() throws Exception {
     @Test
     public void testSearchUsersAndGroupsMembershipThroughUsersAndGroups() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null));
-        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null)); // using description in lieu of memberof
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null));
-        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null, ParameterLookup.EMPTY)); // using description in lieu of memberof
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("member", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(8, ldapUserGroupProvider.getUsers().size());
@@ -500,7 +501,7 @@ public void testUserIdentityMapping() throws Exception {
         ldapUserGroupProvider.setNiFiProperties(properties);
 
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, null);
-        when(configurationContext.getProperty(PROP_USER_SEARCH_FILTER)).thenReturn(new StandardPropertyValue("(uid=user1)", null));
+        when(configurationContext.getProperty(PROP_USER_SEARCH_FILTER)).thenReturn(new StandardPropertyValue("(uid=user1)", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(1, ldapUserGroupProvider.getUsers().size());
@@ -518,7 +519,7 @@ public void testUserIdentityMappingWithTransforms() throws Exception {
         ldapUserGroupProvider.setNiFiProperties(properties);
 
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, null);
-        when(configurationContext.getProperty(PROP_USER_SEARCH_FILTER)).thenReturn(new StandardPropertyValue("(uid=user1)", null));
+        when(configurationContext.getProperty(PROP_USER_SEARCH_FILTER)).thenReturn(new StandardPropertyValue("(uid=user1)", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(1, ldapUserGroupProvider.getUsers().size());
@@ -539,8 +540,8 @@ public void testUserIdentityAndGroupMappingWithTransforms() throws Exception {
         ldapUserGroupProvider.setNiFiProperties(properties);
 
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(USER_SEARCH_BASE, GROUP_SEARCH_BASE);
-        when(configurationContext.getProperty(PROP_USER_SEARCH_FILTER)).thenReturn(new StandardPropertyValue("(uid=user1)", null));
-        when(configurationContext.getProperty(PROP_GROUP_SEARCH_FILTER)).thenReturn(new StandardPropertyValue("(cn=admins)", null));
+        when(configurationContext.getProperty(PROP_USER_SEARCH_FILTER)).thenReturn(new StandardPropertyValue("(uid=user1)", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_SEARCH_FILTER)).thenReturn(new StandardPropertyValue("(cn=admins)", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         assertEquals(1, ldapUserGroupProvider.getUsers().size());
@@ -553,18 +554,18 @@ public void testUserIdentityAndGroupMappingWithTransforms() throws Exception {
     @Test(expected = AuthorizerCreationException.class)
     public void testReferencedGroupAttributeWithoutGroupSearchBase() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration("ou=users-2,o=nifi", null);
-        when(configurationContext.getProperty(PROP_USER_GROUP_REFERENCED_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
+        when(configurationContext.getProperty(PROP_USER_GROUP_REFERENCED_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
     }
 
     @Test
     public void testReferencedGroupWithoutDefiningReferencedAttribute() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration("ou=users-2,o=nifi", "ou=groups-2,o=nifi");
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null));
-        when(configurationContext.getProperty(PROP_USER_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("room", null)); // using room due to reqs of groupOfNames
-        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null)); // using description in lieu of member
-        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
-        when(configurationContext.getProperty(PROP_GROUP_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("room", null)); // using room due to reqs of groupOfNames
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("room", null, ParameterLookup.EMPTY)); // using room due to reqs of groupOfNames
+        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null, ParameterLookup.EMPTY)); // using description in lieu of member
+        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("room", null, ParameterLookup.EMPTY)); // using room due to reqs of groupOfNames
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         final Set<Group> groups = ldapUserGroupProvider.getGroups();
@@ -578,11 +579,11 @@ public void testReferencedGroupWithoutDefiningReferencedAttribute() throws Excep
     @Test
     public void testReferencedGroupUsingReferencedAttribute() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration("ou=users-2,o=nifi", "ou=groups-2,o=nifi");
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null));
-        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null)); // using description in lieu of member
-        when(configurationContext.getProperty(PROP_USER_GROUP_REFERENCED_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
-        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
-        when(configurationContext.getProperty(PROP_GROUP_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("room", null)); // using room because groupOfNames requires a member
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null, ParameterLookup.EMPTY)); // using description in lieu of member
+        when(configurationContext.getProperty(PROP_USER_GROUP_REFERENCED_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("room", null, ParameterLookup.EMPTY)); // using room because groupOfNames requires a member
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         final Set<Group> groups = ldapUserGroupProvider.getGroups();
@@ -599,17 +600,17 @@ public void testReferencedGroupUsingReferencedAttribute() throws Exception {
     @Test(expected = AuthorizerCreationException.class)
     public void testReferencedUserWithoutUserSearchBase() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration(null, "ou=groups-2,o=nifi");
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_REFERENCED_USER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_REFERENCED_USER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
     }
 
     @Test
     public void testReferencedUserWithoutDefiningReferencedAttribute() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration("ou=users-2,o=nifi", "ou=groups-2,o=nifi");
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null));
-        when(configurationContext.getProperty(PROP_GROUP_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("room", null)); // using room due to reqs of groupOfNames
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null)); // using description in lieu of member
-        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("room", null, ParameterLookup.EMPTY)); // using room due to reqs of groupOfNames
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null, ParameterLookup.EMPTY)); // using description in lieu of member
+        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         final Set<Group> groups = ldapUserGroupProvider.getGroups();
@@ -623,11 +624,12 @@ public void testReferencedUserWithoutDefiningReferencedAttribute() throws Except
     @Test
     public void testReferencedUserUsingReferencedAttribute() throws Exception {
         final AuthorizerConfigurationContext configurationContext = getBaseConfiguration("ou=users-2,o=nifi", "ou=groups-2,o=nifi");
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("sn", null));
-        when(configurationContext.getProperty(PROP_GROUP_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("room", null)); // using room due to reqs of groupOfNames
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null)); // using description in lieu of member
-        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null));
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_REFERENCED_USER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null)); // does not need to be the same as user id attr
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue("sn", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("room", null, ParameterLookup.EMPTY)); // using room due to reqs of groupOfNames
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("description", null, ParameterLookup.EMPTY)); // using description in lieu of member
+        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue("cn", null, ParameterLookup.EMPTY));
+        // does not need to be the same as user id attr
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_REFERENCED_USER_ATTRIBUTE)).thenReturn(new StandardPropertyValue("uid", null, ParameterLookup.EMPTY));
         ldapUserGroupProvider.onConfigured(configurationContext);
 
         final Set<Group> groups = ldapUserGroupProvider.getGroups();
@@ -643,32 +645,32 @@ public void testReferencedUserUsingReferencedAttribute() throws Exception {
 
     private AuthorizerConfigurationContext getBaseConfiguration(final String userSearchBase, final String groupSearchBase) {
         final AuthorizerConfigurationContext configurationContext = mock(AuthorizerConfigurationContext.class);
-        when(configurationContext.getProperty(PROP_URL)).thenReturn(new StandardPropertyValue("ldap://127.0.0.1:" + getLdapServer().getPort(), null));
-        when(configurationContext.getProperty(PROP_CONNECT_TIMEOUT)).thenReturn(new StandardPropertyValue("30 secs", null));
-        when(configurationContext.getProperty(PROP_READ_TIMEOUT)).thenReturn(new StandardPropertyValue("30 secs", null));
-        when(configurationContext.getProperty(PROP_REFERRAL_STRATEGY)).thenReturn(new StandardPropertyValue(ReferralStrategy.FOLLOW.name(), null));
-        when(configurationContext.getProperty(PROP_PAGE_SIZE)).thenReturn(new StandardPropertyValue(null, null));
-        when(configurationContext.getProperty(PROP_SYNC_INTERVAL)).thenReturn(new StandardPropertyValue("30 mins", null));
-
-        when(configurationContext.getProperty(PROP_AUTHENTICATION_STRATEGY)).thenReturn(new StandardPropertyValue(LdapAuthenticationStrategy.SIMPLE.name(), null));
-        when(configurationContext.getProperty(PROP_MANAGER_DN)).thenReturn(new StandardPropertyValue("uid=admin,ou=system", null));
-        when(configurationContext.getProperty(PROP_MANAGER_PASSWORD)).thenReturn(new StandardPropertyValue("secret", null));
-
-        when(configurationContext.getProperty(PROP_USER_SEARCH_BASE)).thenReturn(new StandardPropertyValue(userSearchBase, null));
-        when(configurationContext.getProperty(PROP_USER_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("person", null));
-        when(configurationContext.getProperty(PROP_USER_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(SearchScope.ONE_LEVEL.name(), null));
-        when(configurationContext.getProperty(PROP_USER_SEARCH_FILTER)).thenReturn(new StandardPropertyValue(null, null));
-        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue(null, null));
-        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue(null, null));
-        when(configurationContext.getProperty(PROP_USER_GROUP_REFERENCED_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue(null, null));
-
-        when(configurationContext.getProperty(PROP_GROUP_SEARCH_BASE)).thenReturn(new StandardPropertyValue(groupSearchBase, null));
-        when(configurationContext.getProperty(PROP_GROUP_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("groupOfNames", null));
-        when(configurationContext.getProperty(PROP_GROUP_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(SearchScope.ONE_LEVEL.name(), null));
-        when(configurationContext.getProperty(PROP_GROUP_SEARCH_FILTER)).thenReturn(new StandardPropertyValue(null, null));
-        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue(null, null));
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue(null, null));
-        when(configurationContext.getProperty(PROP_GROUP_MEMBER_REFERENCED_USER_ATTRIBUTE)).thenReturn(new StandardPropertyValue(null, null));
+        when(configurationContext.getProperty(PROP_URL)).thenReturn(new StandardPropertyValue("ldap://127.0.0.1:" + getLdapServer().getPort(), null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_CONNECT_TIMEOUT)).thenReturn(new StandardPropertyValue("30 secs", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_READ_TIMEOUT)).thenReturn(new StandardPropertyValue("30 secs", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_REFERRAL_STRATEGY)).thenReturn(new StandardPropertyValue(ReferralStrategy.FOLLOW.name(), null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_PAGE_SIZE)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_SYNC_INTERVAL)).thenReturn(new StandardPropertyValue("30 mins", null, ParameterLookup.EMPTY));
+
+        when(configurationContext.getProperty(PROP_AUTHENTICATION_STRATEGY)).thenReturn(new StandardPropertyValue(LdapAuthenticationStrategy.SIMPLE.name(), null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_MANAGER_DN)).thenReturn(new StandardPropertyValue("uid=admin,ou=system", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_MANAGER_PASSWORD)).thenReturn(new StandardPropertyValue("secret", null, ParameterLookup.EMPTY));
+
+        when(configurationContext.getProperty(PROP_USER_SEARCH_BASE)).thenReturn(new StandardPropertyValue(userSearchBase, null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("person", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(SearchScope.ONE_LEVEL.name(), null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_SEARCH_FILTER)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_IDENTITY_ATTRIBUTE)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_USER_GROUP_REFERENCED_GROUP_ATTRIBUTE)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
+
+        when(configurationContext.getProperty(PROP_GROUP_SEARCH_BASE)).thenReturn(new StandardPropertyValue(groupSearchBase, null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_OBJECT_CLASS)).thenReturn(new StandardPropertyValue("groupOfNames", null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_SEARCH_SCOPE)).thenReturn(new StandardPropertyValue(SearchScope.ONE_LEVEL.name(), null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_SEARCH_FILTER)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_NAME_ATTRIBUTE)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_ATTRIBUTE)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
+        when(configurationContext.getProperty(PROP_GROUP_MEMBER_REFERENCED_USER_ATTRIBUTE)).thenReturn(new StandardPropertyValue(null, null, ParameterLookup.EMPTY));
 
         return configurationContext;
     }
diff --git a/nifi-nar-bundles/nifi-provenance-repository-bundle/nifi-persistent-provenance-repository/src/main/java/org/apache/nifi/provenance/index/lucene/EventIndexTask.java b/nifi-nar-bundles/nifi-provenance-repository-bundle/nifi-persistent-provenance-repository/src/main/java/org/apache/nifi/provenance/index/lucene/EventIndexTask.java
index 5185627ab7d..11c3a4eeb00 100644
--- a/nifi-nar-bundles/nifi-provenance-repository-bundle/nifi-persistent-provenance-repository/src/main/java/org/apache/nifi/provenance/index/lucene/EventIndexTask.java
+++ b/nifi-nar-bundles/nifi-provenance-repository-bundle/nifi-persistent-provenance-repository/src/main/java/org/apache/nifi/provenance/index/lucene/EventIndexTask.java
@@ -79,7 +79,7 @@ private void fetchDocuments(final List<StoredDocument> destination) throws Inter
         // call #drainTo on the queue. So we call poll, blocking for up to 1 second. If we get any event, then
         // we will call drainTo to gather the rest. If we get no events, then we just return, having gathered
         // no events.
-        StoredDocument firstDoc = documentQueue.poll(1, TimeUnit.SECONDS);
+        StoredDocument firstDoc = documentQueue.poll(10, TimeUnit.MILLISECONDS);
         if (firstDoc == null) {
             return;
         }
diff --git a/nifi-nar-bundles/nifi-redis-bundle/nifi-redis-extensions/src/test/java/org/apache/nifi/redis/state/ITRedisStateProvider.java b/nifi-nar-bundles/nifi-redis-bundle/nifi-redis-extensions/src/test/java/org/apache/nifi/redis/state/ITRedisStateProvider.java
index 6a5fb825b7f..7396d66c6ea 100644
--- a/nifi-nar-bundles/nifi-redis-bundle/nifi-redis-extensions/src/test/java/org/apache/nifi/redis/state/ITRedisStateProvider.java
+++ b/nifi-nar-bundles/nifi-redis-bundle/nifi-redis-extensions/src/test/java/org/apache/nifi/redis/state/ITRedisStateProvider.java
@@ -263,7 +263,7 @@ public String getIdentifier() {
             public Map<PropertyDescriptor, PropertyValue> getProperties() {
                 final Map<PropertyDescriptor, PropertyValue> propValueMap = new HashMap<>();
                 for (final Map.Entry<PropertyDescriptor, String> entry : properties.entrySet()) {
-                    propValueMap.put(entry.getKey(), new StandardPropertyValue(entry.getValue(), null));
+                    propValueMap.put(entry.getKey(), new StandardPropertyValue(entry.getValue(), null, null));
                 }
                 return propValueMap;
             }
@@ -285,7 +285,7 @@ public PropertyValue getProperty(final PropertyDescriptor property) {
                     prop = property.getDefaultValue();
                 }
 
-                return new StandardPropertyValue(prop, null);
+                return new StandardPropertyValue(prop, null, null);
             }
 
             @Override
diff --git a/nifi-nar-bundles/nifi-scripting-bundle/nifi-scripting-processors/src/main/java/org/apache/nifi/script/impl/ValidationContextAdapter.java b/nifi-nar-bundles/nifi-scripting-bundle/nifi-scripting-processors/src/main/java/org/apache/nifi/script/impl/ValidationContextAdapter.java
index 20b3e98e7fa..b983c16f5dd 100644
--- a/nifi-nar-bundles/nifi-scripting-bundle/nifi-scripting-processors/src/main/java/org/apache/nifi/script/impl/ValidationContextAdapter.java
+++ b/nifi-nar-bundles/nifi-scripting-bundle/nifi-scripting-processors/src/main/java/org/apache/nifi/script/impl/ValidationContextAdapter.java
@@ -16,8 +16,6 @@
  */
 package org.apache.nifi.script.impl;
 
-import java.util.Map;
-
 import org.apache.nifi.components.PropertyDescriptor;
 import org.apache.nifi.components.PropertyValue;
 import org.apache.nifi.components.ValidationContext;
@@ -25,6 +23,9 @@
 import org.apache.nifi.controller.ControllerServiceLookup;
 import org.apache.nifi.expression.ExpressionLanguageCompiler;
 
+import java.util.Collection;
+import java.util.Map;
+
 public abstract class ValidationContextAdapter implements ValidationContext {
 
     private ValidationContext innerValidationContext;
@@ -94,4 +95,13 @@ public String getProcessGroupIdentifier() {
         return innerValidationContext.getProcessGroupIdentifier();
     }
 
+    @Override
+    public boolean isParameterDefined(final String parameterName) {
+        return innerValidationContext.isParameterDefined(parameterName);
+    }
+
+    @Override
+    public Collection<String> getReferencedParameters(final String propertyName) {
+        return innerValidationContext.getReferencedParameters(propertyName);
+    }
 }
diff --git a/nifi-nar-bundles/nifi-site-to-site-reporting-bundle/nifi-site-to-site-reporting-task/src/test/java/org/apache/nifi/reporting/TestSiteToSiteBulletinReportingTask.java b/nifi-nar-bundles/nifi-site-to-site-reporting-bundle/nifi-site-to-site-reporting-task/src/test/java/org/apache/nifi/reporting/TestSiteToSiteBulletinReportingTask.java
index 7a81db8a103..f74ad4a7dd4 100644
--- a/nifi-nar-bundles/nifi-site-to-site-reporting-bundle/nifi-site-to-site-reporting-task/src/test/java/org/apache/nifi/reporting/TestSiteToSiteBulletinReportingTask.java
+++ b/nifi-nar-bundles/nifi-site-to-site-reporting-bundle/nifi-site-to-site-reporting-task/src/test/java/org/apache/nifi/reporting/TestSiteToSiteBulletinReportingTask.java
@@ -17,23 +17,6 @@
 
 package org.apache.nifi.reporting;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.nio.charset.StandardCharsets;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
-
-import javax.json.Json;
-import javax.json.JsonObject;
-import javax.json.JsonReader;
-
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.components.PropertyDescriptor;
 import org.apache.nifi.components.PropertyValue;
@@ -50,6 +33,22 @@
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
 
+import javax.json.Json;
+import javax.json.JsonObject;
+import javax.json.JsonReader;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertTrue;
+
 public class TestSiteToSiteBulletinReportingTask {
 
     @Test
@@ -59,7 +58,7 @@ public void testUrls() throws IOException {
             @Override
             public PropertyValue answer(InvocationOnMock invocation) throws Throwable {
                 String value = (String) invocation.getArguments()[0];
-                return new StandardPropertyValue(value, null);
+                return new StandardPropertyValue(value, null, null);
             }
         });
 
diff --git a/nifi-nar-bundles/nifi-standard-bundle/nifi-jolt-transform-json-ui/src/main/java/org/apache/nifi/web/standard/api/transformjson/TransformJSONResource.java b/nifi-nar-bundles/nifi-standard-bundle/nifi-jolt-transform-json-ui/src/main/java/org/apache/nifi/web/standard/api/transformjson/TransformJSONResource.java
index c8a692fb22b..af34dc14389 100644
--- a/nifi-nar-bundles/nifi-standard-bundle/nifi-jolt-transform-json-ui/src/main/java/org/apache/nifi/web/standard/api/transformjson/TransformJSONResource.java
+++ b/nifi-nar-bundles/nifi-standard-bundle/nifi-jolt-transform-json-ui/src/main/java/org/apache/nifi/web/standard/api/transformjson/TransformJSONResource.java
@@ -22,6 +22,7 @@
 import org.apache.commons.lang3.StringUtils;
 import org.apache.nifi.attribute.expression.language.PreparedQuery;
 import org.apache.nifi.attribute.expression.language.Query;
+import org.apache.nifi.attribute.expression.language.StandardEvaluationContext;
 import org.apache.nifi.processors.standard.util.jolt.TransformFactory;
 import org.apache.nifi.processors.standard.util.jolt.TransformUtils;
 import org.apache.nifi.util.file.classloader.ClassLoaderUtils;
@@ -56,7 +57,7 @@ protected Object getSpecificationJsonObject(JoltSpecificationDTO specificationDT
             if(evaluateAttributes) {
                 PreparedQuery preparedQuery = Query.prepare(specificationDTO.getSpecification());
                 Map<String, String> attributes = specificationDTO.getExpressionLanguageAttributes() == null ? Collections.emptyMap() : specificationDTO.getExpressionLanguageAttributes();
-                specification = preparedQuery.evaluateExpressions(attributes, null);
+                specification = preparedQuery.evaluateExpressions(new StandardEvaluationContext(attributes), null);
             }else{
                 specification = specificationDTO.getSpecification().replaceAll("\\$\\{","\\\\\\\\\\$\\{");
             }
diff --git a/nifi-nar-bundles/nifi-update-attribute-bundle/nifi-update-attribute-ui/src/main/java/org/apache/nifi/update/attributes/UpdateAttributeModelFactory.java b/nifi-nar-bundles/nifi-update-attribute-bundle/nifi-update-attribute-ui/src/main/java/org/apache/nifi/update/attributes/UpdateAttributeModelFactory.java
index f4b8b07dd50..271107d709d 100644
--- a/nifi-nar-bundles/nifi-update-attribute-bundle/nifi-update-attribute-ui/src/main/java/org/apache/nifi/update/attributes/UpdateAttributeModelFactory.java
+++ b/nifi-nar-bundles/nifi-update-attribute-bundle/nifi-update-attribute-ui/src/main/java/org/apache/nifi/update/attributes/UpdateAttributeModelFactory.java
@@ -16,17 +16,19 @@
  */
 package org.apache.nifi.update.attributes;
 
-import java.util.HashSet;
-import java.util.Set;
-
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.Query;
 import org.apache.nifi.attribute.expression.language.StandardExpressionLanguageCompiler;
 import org.apache.nifi.attribute.expression.language.exception.AttributeExpressionLanguageParsingException;
 import org.apache.nifi.expression.AttributeExpression.ResultType;
+import org.apache.nifi.registry.VariableRegistry;
 import org.apache.nifi.update.attributes.dto.ActionDTO;
 import org.apache.nifi.update.attributes.dto.ConditionDTO;
 import org.apache.nifi.update.attributes.dto.RuleDTO;
 
+import java.util.HashSet;
+import java.util.Set;
+
 /**
  *
  */
@@ -75,7 +77,7 @@ public Condition createCondition(final ConditionDTO dto) {
         }
 
         // validate the condition's expression
-        final StandardExpressionLanguageCompiler elCompiler = new StandardExpressionLanguageCompiler();
+        final StandardExpressionLanguageCompiler elCompiler = new StandardExpressionLanguageCompiler(VariableRegistry.EMPTY_REGISTRY, ParameterLookup.EMPTY);
         final String syntaxError = elCompiler.validateExpression(dto.getExpression(), false);
         if (syntaxError != null) {
             throw new IllegalArgumentException(syntaxError);
diff --git a/nifi-stateless/README.md b/nifi-stateless/README.md
index 566afac60dc..3b94c7c23a4 100644
--- a/nifi-stateless/README.md
+++ b/nifi-stateless/README.md
@@ -109,8 +109,10 @@ keys is `nifi_content` then the String value of that element will be the FlowFil
 
             "nifi_content": "hi"
       }],
-      "variables": {
-        "DestinationDirectory" : "/tmp/nifistateless/output2/"
+      "parameters": {
+        "DestinationDirectory" : "/tmp/nifistateless/output2/",
+        "Username" : "jdoe",
+        "Password": { "sensitive": "true", "value": "password" }
       }
     }
 
diff --git a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/ComponentFactory.java b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/ComponentFactory.java
index d0acdc710cd..0f0ba25747f 100644
--- a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/ComponentFactory.java
+++ b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/ComponentFactory.java
@@ -17,6 +17,7 @@
 package org.apache.nifi.stateless.core;
 
 import org.apache.commons.lang3.StringUtils;
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
 import org.apache.nifi.bundle.Bundle;
 import org.apache.nifi.bundle.BundleCoordinate;
@@ -29,6 +30,7 @@
 import org.apache.nifi.controller.exception.ProcessorInstantiationException;
 import org.apache.nifi.logging.ComponentLog;
 import org.apache.nifi.nar.ExtensionManager;
+import org.apache.nifi.parameter.ParameterContext;
 import org.apache.nifi.processor.Processor;
 import org.apache.nifi.processor.ProcessorInitializationContext;
 import org.apache.nifi.processor.Relationship;
@@ -58,7 +60,9 @@ public ComponentFactory(final ExtensionManager extensionManager) {
 
 
     public StatelessProcessorWrapper createProcessor(final VersionedProcessor versionedProcessor, final boolean materializeContent, final StatelessControllerServiceLookup controllerServiceLookup,
-                                                     final VariableRegistry variableRegistry, final Set<URL> classpathUrls) throws ProcessorInstantiationException {
+                                                     final VariableRegistry variableRegistry, final Set<URL> classpathUrls, final ParameterContext parameterContext)
+        throws ProcessorInstantiationException {
+
         final String type = versionedProcessor.getType();
         final String identifier = versionedProcessor.getIdentifier();
 
@@ -89,15 +93,15 @@ public StatelessProcessorWrapper createProcessor(final VersionedProcessor versio
             // If no classpath urls were provided, check if we need to add additional classpath URL's based on configured properties.
             if (classpathUrls == null) {
                 final Set<URL> additionalClasspathUrls = getAdditionalClasspathResources(processor.getPropertyDescriptors(), processor.getIdentifier(), versionedProcessor.getProperties(),
-                    variableRegistry,componentLog);
+                    parameterContext, variableRegistry,componentLog);
 
                 if (!additionalClasspathUrls.isEmpty()) {
-                    return createProcessor(versionedProcessor, materializeContent, controllerServiceLookup, variableRegistry, additionalClasspathUrls);
+                    return createProcessor(versionedProcessor, materializeContent, controllerServiceLookup, variableRegistry, additionalClasspathUrls, parameterContext);
                 }
             }
 
             final StatelessProcessorWrapper processorWrapper = new StatelessProcessorWrapper(versionedProcessor.getIdentifier(), processor, null,
-                controllerServiceLookup, variableRegistry, materializeContent, detectedClassLoader);
+                controllerServiceLookup, variableRegistry, materializeContent, detectedClassLoader, parameterContext);
 
             // Configure the Processor
             processorWrapper.setAnnotationData(versionedProcessor.getAnnotationData());
@@ -118,13 +122,13 @@ public StatelessProcessorWrapper createProcessor(final VersionedProcessor versio
 
 
     private Set<URL> getAdditionalClasspathResources(final List<PropertyDescriptor> propertyDescriptors, final String componentId, final Map<String, String> properties,
-                                                     final VariableRegistry variableRegistry, final ComponentLog logger) {
+                                                     final ParameterLookup parameterLookup, final VariableRegistry variableRegistry, final ComponentLog logger) {
         final Set<String> modulePaths = new LinkedHashSet<>();
         for (final PropertyDescriptor descriptor : propertyDescriptors) {
             if (descriptor.isDynamicClasspathModifier()) {
                 final String value = properties.get(descriptor.getName());
                 if (!StringUtils.isEmpty(value)) {
-                    final StandardPropertyValue propertyValue = new StandardPropertyValue(value, null, variableRegistry);
+                    final StandardPropertyValue propertyValue = new StandardPropertyValue(value, null, parameterLookup, variableRegistry);
                     modulePaths.add(propertyValue.evaluateAttributeExpressions().getValue());
                 }
             }
@@ -145,13 +149,13 @@ private Set<URL> getAdditionalClasspathResources(final List<PropertyDescriptor>
 
 
     public ControllerService createControllerService(final VersionedControllerService versionedControllerService, final VariableRegistry variableRegistry,
-                                                     final ControllerServiceLookup serviceLookup, final StateManager stateManager) {
-        return createControllerService(versionedControllerService, variableRegistry, null, serviceLookup, stateManager);
+                                                     final ControllerServiceLookup serviceLookup, final StateManager stateManager, final ParameterLookup parameterLookup) {
+        return createControllerService(versionedControllerService, variableRegistry, null, serviceLookup, stateManager, parameterLookup);
     }
 
 
     private ControllerService createControllerService(final VersionedControllerService versionedControllerService, final VariableRegistry variableRegistry, final Set<URL> classpathUrls,
-                                                      final ControllerServiceLookup serviceLookup, final StateManager stateManager) {
+                                                      final ControllerServiceLookup serviceLookup, final StateManager stateManager, final ParameterLookup parameterLookup) {
 
         final String type = versionedControllerService.getType();
         final String identifier = versionedControllerService.getIdentifier();
@@ -183,10 +187,10 @@ private ControllerService createControllerService(final VersionedControllerServi
             // If no classpath urls were provided, check if we need to add additional classpath URL's based on configured properties.
             if (classpathUrls == null) {
                 final Set<URL> additionalClasspathUrls = getAdditionalClasspathResources(service.getPropertyDescriptors(), service.getIdentifier(), versionedControllerService.getProperties(),
-                    variableRegistry, componentLog);
+                    parameterLookup, variableRegistry, componentLog);
 
                 if (!additionalClasspathUrls.isEmpty()) {
-                    return createControllerService(versionedControllerService, variableRegistry, additionalClasspathUrls, serviceLookup, stateManager);
+                    return createControllerService(versionedControllerService, variableRegistry, additionalClasspathUrls, serviceLookup, stateManager, parameterLookup);
                 }
             }
 
diff --git a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessConfigurationContext.java b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessConfigurationContext.java
index 1ce477a4526..15ec3311a26 100644
--- a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessConfigurationContext.java
+++ b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessConfigurationContext.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.stateless.core;
 
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.components.PropertyDescriptor;
 import org.apache.nifi.components.PropertyValue;
 import org.apache.nifi.controller.ConfigurationContext;
@@ -34,15 +35,18 @@ public class StatelessConfigurationContext implements ConfigurationContext {
     private final ControllerServiceLookup serviceLookup;
     private final ControllerService service;
     private final VariableRegistry variableRegistry;
+    private final ParameterLookup parameterLookup;
 
     public StatelessConfigurationContext(final ControllerService service,
                                          final Map<PropertyDescriptor, String> properties,
                                          final ControllerServiceLookup serviceLookup,
-                                         final VariableRegistry variableRegistry) {
+                                         final VariableRegistry variableRegistry,
+                                         final ParameterLookup parameterLookup) {
         this.service = service;
         this.properties = properties;
         this.serviceLookup = serviceLookup;
         this.variableRegistry = variableRegistry;
+        this.parameterLookup = parameterLookup;
     }
 
     @Override
@@ -51,7 +55,7 @@ public PropertyValue getProperty(final PropertyDescriptor property) {
         if (value == null) {
             value = getActualDescriptor(property).getDefaultValue();
         }
-        return new StatelessPropertyValue(value, serviceLookup, variableRegistry);
+        return new StatelessPropertyValue(value, serviceLookup, parameterLookup, variableRegistry);
     }
 
     @Override
diff --git a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessControllerServiceLookup.java b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessControllerServiceLookup.java
index f220ed87277..2544ee52d49 100644
--- a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessControllerServiceLookup.java
+++ b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessControllerServiceLookup.java
@@ -25,6 +25,7 @@
 import org.apache.nifi.controller.ConfigurationContext;
 import org.apache.nifi.controller.ControllerService;
 import org.apache.nifi.controller.ControllerServiceLookup;
+import org.apache.nifi.parameter.ParameterContext;
 import org.apache.nifi.registry.VariableRegistry;
 import org.apache.nifi.reporting.InitializationException;
 
@@ -39,16 +40,21 @@
 import static java.util.Objects.requireNonNull;
 
 public class StatelessControllerServiceLookup implements ControllerServiceLookup {
-
+    private final ParameterContext parameterContext;
     private final Map<String, StatelessControllerServiceConfiguration> controllerServiceMap = new ConcurrentHashMap<>();
     private final Map<String, SLF4JComponentLog> controllerServiceLoggers = new HashMap<>();
     private final Map<String, StatelessStateManager> controllerServiceStateManagers = new HashMap<>();
 
+
+    public StatelessControllerServiceLookup(final ParameterContext parameterContext) {
+        this.parameterContext = parameterContext;
+    }
+
+
     public Map<String, StatelessControllerServiceConfiguration> getControllerServices() {
         return controllerServiceMap;
     }
 
-
     public void addControllerService(final ControllerService service, final String serviceName) throws InitializationException {
         final String identifier = service.getIdentifier();
         final SLF4JComponentLog logger = new SLF4JComponentLog(service);
@@ -57,7 +63,7 @@ public void addControllerService(final ControllerService service, final String s
         StatelessStateManager serviceStateManager = new StatelessStateManager();
         controllerServiceStateManagers.put(identifier, serviceStateManager);
 
-        final StatelessProcessContext initContext = new StatelessProcessContext(requireNonNull(service), this, serviceName, logger, serviceStateManager);
+        final StatelessProcessContext initContext = new StatelessProcessContext(requireNonNull(service), this, serviceName, logger, serviceStateManager, parameterContext);
         service.initialize(initContext);
 
         try {
@@ -139,8 +145,8 @@ public void enableControllerServices(final VariableRegistry variableRegistry) {
     public Collection<ValidationResult> validate(final ControllerService service, final String serviceName, final VariableRegistry variableRegistry) {
         final StateManager stateManager = controllerServiceStateManagers.get(service.getIdentifier());
         final SLF4JComponentLog logger = controllerServiceLoggers.get(service.getIdentifier());
-        final StatelessProcessContext processContext = new StatelessProcessContext(service, this, serviceName, logger, stateManager, variableRegistry);
-        final StatelessValidationContext validationContext = new StatelessValidationContext(processContext, this, stateManager, variableRegistry);
+        final StatelessProcessContext processContext = new StatelessProcessContext(service, this, serviceName, logger, stateManager, variableRegistry, parameterContext);
+        final StatelessValidationContext validationContext = new StatelessValidationContext(processContext, this, stateManager, variableRegistry, parameterContext);
         return service.validate(validationContext);
     }
 
@@ -154,7 +160,7 @@ private void enableControllerService(final ControllerService service, final Vari
             throw new IllegalStateException("Cannot enable Controller Service " + service + " because it is not disabled");
         }
 
-        final ConfigurationContext configContext = new StatelessConfigurationContext(service, configuration.getProperties(), this, registry);
+        final ConfigurationContext configContext = new StatelessConfigurationContext(service, configuration.getProperties(), this, registry, parameterContext);
         ReflectionUtils.invokeMethodsWithAnnotation(OnEnabled.class, service, configContext);
 
         configuration.setEnabled(true);
@@ -186,7 +192,7 @@ public ValidationResult setControllerServiceProperty(final ControllerService ser
             throw new IllegalStateException("Controller service " + service + " has not been added to this TestRunner via the #addControllerService method");
         }
 
-        final ValidationContext validationContext = new StatelessValidationContext(context, this, serviceStateManager, registry).getControllerServiceValidationContext(service);
+        final ValidationContext validationContext = new StatelessValidationContext(context, this, serviceStateManager, registry, parameterContext).getControllerServiceValidationContext(service);
         final ValidationResult validationResult = property.validate(value, validationContext);
 
         final StatelessControllerServiceConfiguration configuration = getControllerServiceConfigToUpdate(service);
diff --git a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessFlow.java b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessFlow.java
index 0418429d24d..8ff03a6a101 100644
--- a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessFlow.java
+++ b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessFlow.java
@@ -24,6 +24,9 @@
 import org.apache.nifi.controller.ControllerService;
 import org.apache.nifi.controller.exception.ProcessorInstantiationException;
 import org.apache.nifi.nar.ExtensionManager;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterDescriptor;
 import org.apache.nifi.processor.Relationship;
 import org.apache.nifi.registry.VariableDescriptor;
 import org.apache.nifi.registry.VariableRegistry;
@@ -67,7 +70,9 @@ public class StatelessFlow implements RunnableFlow {
     public static final String FAILUREPORTS = "failurePortIds";
     public static final String FLOWFILES = "flowFiles";
     public static final String CONTENT = "nifi_content";
-    public static final String VARIABLES = "variables";
+    public static final String PARAMETERS = "parameters";
+    public static final String PARAMETER_SENSITIVE = "sensitive";
+    public static final String PARAMETER_VALUE = "value";
 
     public static final String SSL = "ssl";
     public static final String KEYSTORE = "keystore";
@@ -78,7 +83,6 @@ public class StatelessFlow implements RunnableFlow {
     public static final String TRUSTSTORE_PASS = "truststorePass";
     public static final String TRUSTSTORE_TYPE = "truststoreType";
 
-    private static final String DEFAULT_WORKING_DIR = "./work";
 
     private List<StatelessComponent> roots;
     private volatile boolean stopRequested = false;
@@ -96,8 +100,8 @@ public StatelessFlow(final List<StatelessComponent> roots) {
     }
 
 
-    public StatelessFlow(final VersionedProcessGroup flow, final ExtensionManager extensionManager, final VariableRegistry variableRegistry,
-                         final List<String> failureOutputPorts, final boolean materializeContent, final SSLContext sslContext) throws ProcessorInstantiationException,  InitializationException {
+    public StatelessFlow(final VersionedProcessGroup flow, final ExtensionManager extensionManager, final VariableRegistry variableRegistry, final List<String> failureOutputPorts,
+                         final boolean materializeContent, final SSLContext sslContext, final ParameterContext parameterContext) throws ProcessorInstantiationException, InitializationException {
 
         this.componentFactory = new ComponentFactory(extensionManager);
 
@@ -115,18 +119,19 @@ public StatelessFlow(final VersionedProcessGroup flow, final ExtensionManager ex
             throw new IllegalArgumentException("Only one input port per flow is allowed");
         }
 
-        final StatelessControllerServiceLookup serviceLookup = new StatelessControllerServiceLookup();
+        final StatelessControllerServiceLookup serviceLookup = new StatelessControllerServiceLookup(parameterContext);
 
         final Set<VersionedControllerService> controllerServices = flow.getControllerServices();
         for (final VersionedControllerService versionedControllerService : controllerServices) {
             final StateManager stateManager = new StatelessStateManager();
 
-            final ControllerService service = componentFactory.createControllerService(versionedControllerService, variableRegistry, serviceLookup, stateManager);
+            final ControllerService service = componentFactory.createControllerService(versionedControllerService, variableRegistry, serviceLookup, stateManager, parameterContext);
             serviceLookup.addControllerService(service, versionedControllerService.getName());
             serviceLookup.setControllerServiceAnnotationData(service, versionedControllerService.getAnnotationData());
 
             final SLF4JComponentLog logger = new SLF4JComponentLog(service);
-            final StatelessProcessContext processContext = new StatelessProcessContext(service, serviceLookup, versionedControllerService.getName(), logger, stateManager, variableRegistry);
+            final StatelessProcessContext processContext = new StatelessProcessContext(service, serviceLookup, versionedControllerService.getName(),
+                logger, stateManager, variableRegistry, parameterContext);
 
             final Map<String, String> versionedPropertyValues = versionedControllerService.getProperties();
             for (final Map.Entry<String, String> entry : versionedPropertyValues.entrySet()) {
@@ -166,7 +171,7 @@ public StatelessFlow(final VersionedProcessGroup flow, final ExtensionManager ex
                         if (processor == null) {
                             throw new IllegalArgumentException("Unknown input processor. " + source.getId());
                         } else {
-                            sourceComponent = componentFactory.createProcessor(processor, materializeContent, serviceLookup, variableRegistry, null);
+                            sourceComponent = componentFactory.createProcessor(processor, materializeContent, serviceLookup, variableRegistry, null, parameterContext);
                             componentMap.put(source.getId(), sourceComponent);
                         }
                         break;
@@ -207,7 +212,7 @@ public StatelessFlow(final VersionedProcessGroup flow, final ExtensionManager ex
                             return;
                         }
 
-                        destinationComponent = componentFactory.createProcessor(processor, materializeContent, serviceLookup, variableRegistry, null);
+                        destinationComponent = componentFactory.createProcessor(processor, materializeContent, serviceLookup, variableRegistry, null, parameterContext);
                         destinationComponent.addParent(sourceComponent);
                         componentMap.put(destination.getId(), destinationComponent);
                     }
@@ -416,16 +421,52 @@ public static StatelessFlow createAndEnqueueFromJSON(final JsonObject args, fina
             }
         }
 
-        if (args.has(VARIABLES)) {
-            final JsonElement variablesElement = args.get(VARIABLES);
-            final JsonObject variablesObject = variablesElement.getAsJsonObject();
-            variablesObject.entrySet()
-                .forEach(entry -> inputVariables.put(new VariableDescriptor(entry.getKey()), entry.getValue().getAsString()));
+        final Set<Parameter> parameters = new HashSet<>();
+        final Set<String> parameterNames = new HashSet<>();
+        if (args.has(PARAMETERS)) {
+            final JsonElement parametersElement = args.get(PARAMETERS);
+            final JsonObject parametersObject = parametersElement.getAsJsonObject();
+
+            for (final Map.Entry<String, JsonElement> entry : parametersObject.entrySet()) {
+                final String parameterName = entry.getKey();
+                final JsonElement valueElement = entry.getValue();
+
+                if (parameterNames.contains(parameterName)) {
+                    throw new IllegalStateException("Cannot parse configuration because Parameter '" + parameterName + "' has been defined twice");
+                }
+
+                parameterNames.add(parameterName);
+
+                if (valueElement.isJsonObject()) {
+                    final JsonObject valueObject = valueElement.getAsJsonObject();
+
+                    final boolean sensitive;
+                    if (valueObject.has(PARAMETER_SENSITIVE)) {
+                        sensitive = valueObject.get(PARAMETER_SENSITIVE).getAsBoolean();
+                    } else {
+                        sensitive = false;
+                    }
+
+                    if (valueObject.has(PARAMETER_VALUE)) {
+                        final String value = valueObject.get(PARAMETER_VALUE).getAsString();
+                        final ParameterDescriptor descriptor = new ParameterDescriptor.Builder().name(parameterName).sensitive(sensitive).build();
+                        final Parameter parameter = new Parameter(descriptor, value);
+                        parameters.add(parameter);
+                    } else {
+                        throw new IllegalStateException("Cannot parse configuration because Parameter '" + parameterName + "' does not have a value associated with it");
+                    }
+                } else {
+                    final String parameterValue = entry.getValue().getAsString();
+                    final ParameterDescriptor descriptor = new ParameterDescriptor.Builder().name(parameterName).build();
+                    final Parameter parameter = new Parameter(descriptor, parameterValue);
+                    parameters.add(parameter);
+                }
+            }
         }
 
+        final ParameterContext parameterContext = new StatelessParameterContext(parameters);
         final ExtensionManager extensionManager = ExtensionDiscovery.discover(narWorkingDir, systemClassLoader);
-
-        final StatelessFlow flow = new StatelessFlow(snapshot.getFlowContents(), extensionManager, () -> inputVariables, failurePorts, materializeContent, sslContext);
+        final StatelessFlow flow = new StatelessFlow(snapshot.getFlowContents(), extensionManager, () -> inputVariables, failurePorts, materializeContent, sslContext, parameterContext);
         flow.enqueueFromJSON(args);
         return flow;
     }
diff --git a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessParameterContext.java b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessParameterContext.java
new file mode 100644
index 00000000000..e48a965274b
--- /dev/null
+++ b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessParameterContext.java
@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.nifi.stateless.core;
+
+import org.apache.nifi.authorization.Resource;
+import org.apache.nifi.authorization.resource.Authorizable;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterDescriptor;
+import org.apache.nifi.parameter.ParameterReferenceManager;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+
+public class StatelessParameterContext implements ParameterContext {
+    private final Map<String, Parameter> parameterMap = new HashMap<>();
+
+    public StatelessParameterContext(final Set<Parameter> parameters) {
+        for (final Parameter parameter : parameters) {
+            parameterMap.put(parameter.getDescriptor().getName(), parameter);
+        }
+    }
+
+    @Override
+    public String getIdentifier() {
+        return "NiFi Stateless Parameter Context";
+    }
+
+    @Override
+    public String getName() {
+        return "NiFi Stateless Parameter Context";
+    }
+
+    @Override
+    public void setName(final String name) {
+    }
+
+    @Override
+    public String getDescription() {
+        return "NiFi Stateless Parameter Context";
+    }
+
+    @Override
+    public void setDescription(final String description) {
+    }
+
+    @Override
+    public void setParameters(final Set<Parameter> updatedParameters) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void verifyCanSetParameters(final Set<Parameter> parameters) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Optional<Parameter> getParameter(final String parameterName) {
+        return Optional.ofNullable(parameterMap.get(parameterName));
+    }
+
+    @Override
+    public Optional<Parameter> getParameter(final ParameterDescriptor parameterDescriptor) {
+        return getParameter(parameterDescriptor.getName());
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return parameterMap.isEmpty();
+    }
+
+    @Override
+    public Map<ParameterDescriptor, Parameter> getParameters() {
+        final Map<ParameterDescriptor, Parameter> map = new HashMap<>();
+        for (final Parameter parameter : parameterMap.values()) {
+            map.put(parameter.getDescriptor(), parameter);
+        }
+
+        return map;
+    }
+
+    @Override
+    public ParameterReferenceManager getParameterReferenceManager() {
+        return null;
+    }
+
+    @Override
+    public long getVersion() {
+        return 0;
+    }
+
+    @Override
+    public Authorizable getParentAuthorizable() {
+        return null;
+    }
+
+    @Override
+    public Resource getResource() {
+        return null;
+    }
+}
diff --git a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessProcessContext.java b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessProcessContext.java
index d0b6db7d790..be0365523b0 100644
--- a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessProcessContext.java
+++ b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessProcessContext.java
@@ -28,7 +28,15 @@
 import org.apache.nifi.controller.ControllerServiceInitializationContext;
 import org.apache.nifi.controller.ControllerServiceLookup;
 import org.apache.nifi.controller.NodeTypeProvider;
+import org.apache.nifi.controller.PropertyConfiguration;
 import org.apache.nifi.logging.ComponentLog;
+import org.apache.nifi.parameter.ExpressionLanguageAgnosticParameterParser;
+import org.apache.nifi.parameter.Parameter;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterParser;
+import org.apache.nifi.parameter.ParameterReference;
+import org.apache.nifi.parameter.ParameterTokenList;
+import org.apache.nifi.parameter.ExpressionLanguageAwareParameterParser;
 import org.apache.nifi.processor.Processor;
 import org.apache.nifi.processor.Relationship;
 import org.apache.nifi.processor.SchedulingContext;
@@ -44,15 +52,17 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Objects;
+import java.util.Optional;
 import java.util.Set;
 
 public class StatelessProcessContext implements SchedulingContext, ControllerServiceInitializationContext, StatelessConnectionContext {
 
     private final ConfigurableComponent component;
     private final String componentName;
-    private final Map<PropertyDescriptor, String> properties = new HashMap<>();
+    private final Map<PropertyDescriptor, PropertyConfiguration> properties = new HashMap<>();
     private final StateManager stateManager;
     private final VariableRegistry variableRegistry;
+    private final ParameterContext parameterContext;
 
     private String annotationData = null;
     private boolean yieldCalled = false;
@@ -72,17 +82,17 @@ public class StatelessProcessContext implements SchedulingContext, ControllerSer
     private final StatelessControllerServiceLookup lookup;
 
     public StatelessProcessContext(final ConfigurableComponent component, final StatelessControllerServiceLookup lookup, final String componentName, final StateManager stateManager,
-                                   final VariableRegistry variableRegistry) {
-        this(component, lookup, componentName, new SLF4JComponentLog(component), stateManager, variableRegistry);
+                                   final VariableRegistry variableRegistry, final ParameterContext parameterContext) {
+        this(component, lookup, componentName, new SLF4JComponentLog(component), stateManager, variableRegistry, parameterContext);
     }
 
     public StatelessProcessContext(final ConfigurableComponent component, final StatelessControllerServiceLookup lookup, final String componentName, final SLF4JComponentLog logger,
-                                   final StatelessStateManager statemanager) {
-        this(component, lookup, componentName, logger, statemanager, VariableRegistry.EMPTY_REGISTRY);
+                                   final StatelessStateManager statemanager, final ParameterContext parameterContext) {
+        this(component, lookup, componentName, logger, statemanager, VariableRegistry.EMPTY_REGISTRY, parameterContext);
     }
 
     public StatelessProcessContext(final ConfigurableComponent component, final StatelessControllerServiceLookup lookup, final String componentName,
-                                   final SLF4JComponentLog logger, final StateManager stateManager, final VariableRegistry variableRegistry) {
+                                   final SLF4JComponentLog logger, final StateManager stateManager, final VariableRegistry variableRegistry, final ParameterContext parameterContext) {
         this.component = Objects.requireNonNull(component);
         this.componentName = componentName == null ? "" : componentName;
         this.inputRequirement = component.getClass().getAnnotation(InputRequirement.class);
@@ -91,6 +101,7 @@ public StatelessProcessContext(final ConfigurableComponent component, final Stat
         this.variableRegistry = variableRegistry;
         this.identifier = component.getIdentifier();
         this.logger = logger;
+        this.parameterContext = parameterContext;
     }
 
     @Override
@@ -105,15 +116,15 @@ public PropertyValue getProperty(final String propertyName) {
             return null;
         }
 
-        final String setPropertyValue = properties.get(descriptor);
-        final String propValue = (setPropertyValue == null) ? descriptor.getDefaultValue() : setPropertyValue;
+        final PropertyConfiguration setPropertyValue = properties.get(descriptor);
+        final String propValue = (setPropertyValue == null) ? descriptor.getDefaultValue() : setPropertyValue.getEffectiveValue(parameterContext);
 
-        return new StatelessPropertyValue(propValue, this.lookup, variableRegistry, (enableExpressionValidation && allowExpressionValidation) ? descriptor : null);
+        return new StatelessPropertyValue(propValue, this.lookup, parameterContext, variableRegistry, (enableExpressionValidation && allowExpressionValidation) ? descriptor : null);
     }
 
     @Override
     public PropertyValue newPropertyValue(final String rawValue) {
-        return new StatelessPropertyValue(rawValue, this.lookup, variableRegistry);
+        return new StatelessPropertyValue(rawValue, this.lookup, parameterContext);
     }
 
     public ValidationResult setProperty(final String propertyName, final String propertyValue) {
@@ -121,25 +132,36 @@ public ValidationResult setProperty(final String propertyName, final String prop
     }
 
     public ValidationResult setProperty(final PropertyDescriptor descriptor, final String value) {
-        if (descriptor == null)
+        if (descriptor == null) {
             throw new IllegalArgumentException("descriptor can not be null");
-        if (value == null)
+        }
+        if (value == null) {
             throw new IllegalArgumentException("Cannot set property to null value; if the intent is to remove the property, call removeProperty instead");
+        }
 
         final PropertyDescriptor fullyPopulatedDescriptor = component.getPropertyDescriptor(descriptor.getName());
 
-        final ValidationResult result = fullyPopulatedDescriptor.validate(value, new StatelessValidationContext(this, lookup, stateManager, variableRegistry));
-        String oldValue = properties.put(fullyPopulatedDescriptor, value);
-        if (oldValue == null) {
-            oldValue = fullyPopulatedDescriptor.getDefaultValue();
+        final ValidationResult result = fullyPopulatedDescriptor.validate(value, new StatelessValidationContext(this, lookup, stateManager, variableRegistry, parameterContext));
+        final PropertyConfiguration propertyConfiguration = createPropertyConfiguration(value, fullyPopulatedDescriptor.isExpressionLanguageSupported());
+
+        PropertyConfiguration oldConfig = properties.put(fullyPopulatedDescriptor, propertyConfiguration);
+        if (oldConfig == null) {
+            oldConfig = createPropertyConfiguration(fullyPopulatedDescriptor.getDefaultValue(), fullyPopulatedDescriptor.isExpressionLanguageSupported());
         }
-        if ((value == null && oldValue != null) || (value != null && !value.equals(oldValue))) {
-            component.onPropertyModified(fullyPopulatedDescriptor, oldValue, value);
+        if ((value == null && oldConfig != null && oldConfig.getRawValue() != null) || (value != null && !value.equals(oldConfig.getRawValue()))) {
+            component.onPropertyModified(fullyPopulatedDescriptor, oldConfig.getEffectiveValue(parameterContext), value);
         }
 
         return result;
     }
 
+    private PropertyConfiguration createPropertyConfiguration(final String value, final boolean supportsEl) {
+        final ParameterParser parameterParser = supportsEl ? new ExpressionLanguageAwareParameterParser() : new ExpressionLanguageAgnosticParameterParser();
+        final ParameterTokenList parameterTokenList = parameterParser.parseTokens(value);
+        return new PropertyConfiguration(value, parameterTokenList, parameterTokenList.toReferenceList());
+    }
+
+
     public boolean removeProperty(final PropertyDescriptor descriptor) {
         Objects.requireNonNull(descriptor);
         return removeProperty(descriptor.getName());
@@ -148,11 +170,11 @@ public boolean removeProperty(final PropertyDescriptor descriptor) {
     public boolean removeProperty(final String property) {
         Objects.requireNonNull(property);
         final PropertyDescriptor fullyPopulatedDescriptor = component.getPropertyDescriptor(property);
-        String value = null;
+        PropertyConfiguration propertyConfig;
 
-        if ((value = properties.remove(fullyPopulatedDescriptor)) != null) {
-            if (!value.equals(fullyPopulatedDescriptor.getDefaultValue())) {
-                component.onPropertyModified(fullyPopulatedDescriptor, value, null);
+        if ((propertyConfig = properties.remove(fullyPopulatedDescriptor)) != null) {
+            if (!propertyConfig.getRawValue().equals(fullyPopulatedDescriptor.getDefaultValue())) {
+                component.onPropertyModified(fullyPopulatedDescriptor, propertyConfig.getEffectiveValue(parameterContext), null);
             }
 
             return true;
@@ -183,19 +205,28 @@ public String getAnnotationData() {
         return annotationData;
     }
 
+    public PropertyConfiguration getPropertyConfiguration(final PropertyDescriptor propertyDescriptor) {
+        return properties.get(propertyDescriptor);
+    }
+
     @Override
     public Map<PropertyDescriptor, String> getProperties() {
         final List<PropertyDescriptor> supported = component.getPropertyDescriptors();
-        if (supported == null || supported.isEmpty()) {
-            return Collections.unmodifiableMap(properties);
-        } else {
-            final Map<PropertyDescriptor, String> props = new LinkedHashMap<>();
-            for (final PropertyDescriptor descriptor : supported) {
-                props.put(descriptor, null);
-            }
-            props.putAll(properties);
-            return props;
+
+        final Map<PropertyDescriptor, String> effectiveValues = new LinkedHashMap<>();
+        for (final PropertyDescriptor descriptor : supported) {
+            effectiveValues.put(descriptor, null);
+        }
+
+        for (final Map.Entry<PropertyDescriptor, PropertyConfiguration> entry : properties.entrySet()) {
+            final PropertyDescriptor descriptor = entry.getKey();
+            final PropertyConfiguration configuration = entry.getValue();
+            final String value = configuration.getEffectiveValue(parameterContext);
+
+            effectiveValues.put(descriptor, value);
         }
+
+        return effectiveValues;
     }
 
     @Override
@@ -208,8 +239,13 @@ public Map<String, String> getAllProperties() {
     }
 
     public Collection<ValidationResult> validate() {
+        final List<ValidationResult> parameterValidationResults = validateParameterReferences();
+        if (!parameterValidationResults.isEmpty()) {
+            return parameterValidationResults;
+        }
+
         final List<ValidationResult> results = new ArrayList<>();
-        final ValidationContext validationContext = new StatelessValidationContext(this, lookup, stateManager, variableRegistry);
+        final ValidationContext validationContext = new StatelessValidationContext(this, lookup, stateManager, variableRegistry, parameterContext);
         final Collection<ValidationResult> componentResults = component.validate(validationContext);
         results.addAll(componentResults);
 
@@ -228,6 +264,54 @@ public Collection<ValidationResult> validate() {
         return results;
     }
 
+    private List<ValidationResult> validateParameterReferences() {
+        final List<ValidationResult> results = new ArrayList<>();
+
+        for (final Map.Entry<PropertyDescriptor, PropertyConfiguration> entry : properties.entrySet()) {
+            final PropertyDescriptor propertyDescriptor = entry.getKey();
+            final PropertyConfiguration configuration = entry.getValue();
+            final List<ParameterReference> references = configuration.getParameterReferences();
+
+            for (final ParameterReference reference : references) {
+                final String parameterName = reference.getParameterName();
+
+                final Optional<Parameter> parameter = parameterContext.getParameter(parameterName);
+                if (!parameter.isPresent()) {
+                    results.add(new ValidationResult.Builder()
+                        .subject(propertyDescriptor.getDisplayName())
+                        .valid(false)
+                        .explanation("Property References Parameter '" + parameterName + "' but that Parameter is not defined in the Stateless Flow configuration")
+                        .build());
+                    continue;
+                }
+
+                final boolean parameterSensitive = parameter.get().getDescriptor().isSensitive();
+
+                if (parameterSensitive && !propertyDescriptor.isSensitive()) {
+                    results.add(new ValidationResult.Builder()
+                        .subject(propertyDescriptor.getDisplayName())
+                        .valid(false)
+                        .explanation("Property References Parameter '" + parameterName + "', which is a Sensitive Parameter, but the Property is not a Sensitive Property. Sensitive Parameters " +
+                            "may only be referenced by Sensitive Properties.")
+                        .build());
+                    continue;
+                }
+
+                if (!parameterSensitive && propertyDescriptor.isSensitive()) {
+                    results.add(new ValidationResult.Builder()
+                        .subject(propertyDescriptor.getDisplayName())
+                        .valid(false)
+                        .explanation("Property References Parameter '" + parameterName + "', which is not a Sensitive Parameter, but the Property is a Sensitive Property. Sensitive Properties " +
+                            "may only reference Sensitive Parameters.")
+                        .build());
+                    continue;
+                }
+            }
+        }
+
+        return results;
+    }
+
     protected final Collection<ValidationResult> validateReferencedControllerServices(final ValidationContext validationContext) {
         final List<PropertyDescriptor> supportedDescriptors = component.getPropertyDescriptors();
         if (supportedDescriptors == null) {
diff --git a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessProcessorWrapper.java b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessProcessorWrapper.java
index 8ecb17188c4..6cbc291bad9 100644
--- a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessProcessorWrapper.java
+++ b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessProcessorWrapper.java
@@ -24,12 +24,13 @@
 import org.apache.nifi.annotation.lifecycle.OnUnscheduled;
 import org.apache.nifi.components.PropertyDescriptor;
 import org.apache.nifi.components.ValidationResult;
-import org.apache.nifi.stateless.bootstrap.InMemoryFlowFile;
 import org.apache.nifi.logging.ComponentLog;
+import org.apache.nifi.parameter.ParameterContext;
 import org.apache.nifi.processor.Processor;
 import org.apache.nifi.processor.Relationship;
 import org.apache.nifi.provenance.ProvenanceEventRecord;
 import org.apache.nifi.registry.VariableRegistry;
+import org.apache.nifi.stateless.bootstrap.InMemoryFlowFile;
 
 import java.io.Closeable;
 import java.lang.reflect.InvocationTargetException;
@@ -67,7 +68,7 @@ public class StatelessProcessorWrapper extends AbstractStatelessComponent implem
 
 
     public StatelessProcessorWrapper(final String id, final Processor processor, final StatelessProcessorWrapper parent, final StatelessControllerServiceLookup lookup, final VariableRegistry registry,
-                              final boolean materializeContent, final ClassLoader classLoader) throws InvocationTargetException, IllegalAccessException {
+                              final boolean materializeContent, final ClassLoader classLoader, final ParameterContext parameterContext) throws InvocationTargetException, IllegalAccessException {
 
         this.processor = processor;
         this.classLoader = classLoader;
@@ -81,7 +82,7 @@ public StatelessProcessorWrapper(final String id, final Processor processor, fin
         this.createdSessions = new CopyOnWriteArraySet<>();
         this.inputQueue = new LinkedList<>();
         this.variableRegistry = registry;
-        this.context = new StatelessProcessContext(processor, lookup, processor.getIdentifier(), new StatelessStateManager(), variableRegistry);
+        this.context = new StatelessProcessContext(processor, lookup, processor.getIdentifier(), new StatelessStateManager(), variableRegistry, parameterContext);
         this.context.setMaxConcurrentTasks(1);
 
         final StatelessProcessorInitializationContext initContext = new StatelessProcessorInitializationContext(id, processor, context);
diff --git a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessPropertyValue.java b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessPropertyValue.java
index 4a02064a422..909ac7c8c2d 100644
--- a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessPropertyValue.java
+++ b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessPropertyValue.java
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.stateless.core;
 
+import org.apache.nifi.parameter.ParameterLookup;
 import org.apache.nifi.attribute.expression.language.Query;
 import org.apache.nifi.attribute.expression.language.Query.Range;
 import org.apache.nifi.attribute.expression.language.StandardPropertyValue;
@@ -43,28 +44,30 @@ public class StatelessPropertyValue implements PropertyValue {
     private final PropertyDescriptor propertyDescriptor;
     private final PropertyValue stdPropValue;
     private final VariableRegistry variableRegistry;
+    private final ParameterLookup parameterLookup;
 
     private boolean expressionsEvaluated = false;
 
-    public StatelessPropertyValue(final String rawValue) {
-        this(rawValue, null);
+    public StatelessPropertyValue(final String rawValue, final ParameterLookup parameterLookup) {
+        this(rawValue, null, parameterLookup);
     }
 
-    public StatelessPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup) {
-        this(rawValue, serviceLookup, VariableRegistry.EMPTY_REGISTRY, null);
+    public StatelessPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup, final ParameterLookup parameterLookup) {
+        this(rawValue, serviceLookup, parameterLookup, VariableRegistry.EMPTY_REGISTRY, null);
     }
 
-    public StatelessPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup, final VariableRegistry variableRegistry) {
-        this(rawValue, serviceLookup, variableRegistry, null);
+    public StatelessPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup, final ParameterLookup parameterLookup, final VariableRegistry variableRegistry) {
+        this(rawValue, serviceLookup, parameterLookup, variableRegistry, null);
     }
 
-    public StatelessPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup, VariableRegistry variableRegistry, final PropertyDescriptor propertyDescriptor) {
-        this(rawValue, serviceLookup, propertyDescriptor, false, variableRegistry);
+    public StatelessPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup, final ParameterLookup parameterLookup, final VariableRegistry variableRegistry,
+                                  final PropertyDescriptor propertyDescriptor) {
+        this(rawValue, serviceLookup, propertyDescriptor, false, parameterLookup, variableRegistry);
     }
 
     private StatelessPropertyValue(final String rawValue, final ControllerServiceLookup serviceLookup, final PropertyDescriptor propertyDescriptor, final boolean alreadyEvaluated,
-                                   final VariableRegistry variableRegistry) {
-        this.stdPropValue = new StandardPropertyValue(rawValue, serviceLookup, variableRegistry);
+                                   final ParameterLookup parameterLookup, final VariableRegistry variableRegistry) {
+        this.stdPropValue = new StandardPropertyValue(rawValue, serviceLookup, parameterLookup, variableRegistry);
         this.rawValue = rawValue;
         this.serviceLookup = (StatelessControllerServiceLookup) serviceLookup;
         this.expectExpressions = propertyDescriptor == null ? null : propertyDescriptor.isExpressionLanguageSupported();
@@ -72,6 +75,7 @@ private StatelessPropertyValue(final String rawValue, final ControllerServiceLoo
         this.propertyDescriptor = propertyDescriptor;
         this.expressionsEvaluated = alreadyEvaluated;
         this.variableRegistry = variableRegistry;
+        this.parameterLookup = parameterLookup;
     }
 
     private void ensureExpressionsEvaluated() {
@@ -234,7 +238,7 @@ public PropertyValue evaluateAttributeExpressions(FlowFile flowFile, Map<String,
         validateExpressionScope(flowFile != null || additionalAttributes != null);
 
         final PropertyValue newValue = stdPropValue.evaluateAttributeExpressions(flowFile, additionalAttributes, decorator, stateValues);
-        return new StatelessPropertyValue(newValue.getValue(), serviceLookup, propertyDescriptor, true, variableRegistry);
+        return new StatelessPropertyValue(newValue.getValue(), serviceLookup, propertyDescriptor, true, parameterLookup, variableRegistry);
     }
 
     @Override
diff --git a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessValidationContext.java b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessValidationContext.java
index 6dcb610ce75..81f1eb0a93a 100644
--- a/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessValidationContext.java
+++ b/nifi-stateless/nifi-stateless-core/src/main/java/org/apache/nifi/stateless/core/StatelessValidationContext.java
@@ -24,13 +24,19 @@
 import org.apache.nifi.components.state.StateManager;
 import org.apache.nifi.controller.ControllerService;
 import org.apache.nifi.controller.ControllerServiceLookup;
+import org.apache.nifi.controller.PropertyConfiguration;
 import org.apache.nifi.expression.ExpressionLanguageCompiler;
+import org.apache.nifi.parameter.ParameterContext;
+import org.apache.nifi.parameter.ParameterReference;
 import org.apache.nifi.registry.VariableRegistry;
 
+import java.util.Collection;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.stream.Collectors;
 
 public class StatelessValidationContext implements ValidationContext {
 
@@ -39,9 +45,10 @@ public class StatelessValidationContext implements ValidationContext {
     private final StateManager stateManager;
     private final VariableRegistry variableRegistry;
     private final StatelessProcessContext processContext;
+    private final ParameterContext parameterContext;
 
     public StatelessValidationContext(final StatelessProcessContext processContext, final StatelessControllerServiceLookup lookup, final StateManager stateManager,
-                                      final VariableRegistry variableRegistry) {
+                                      final VariableRegistry variableRegistry, final ParameterContext parameterContext) {
         this.processContext = processContext;
         this.lookup = lookup;
         this.stateManager = stateManager;
@@ -52,22 +59,24 @@ public StatelessValidationContext(final StatelessProcessContext processContext,
         for (final PropertyDescriptor descriptor : properties.keySet()) {
             expressionLanguageSupported.put(descriptor.getName(), descriptor.isExpressionLanguageSupported());
         }
+
+        this.parameterContext = parameterContext;
     }
 
     @Override
     public PropertyValue newPropertyValue(final String rawValue) {
-        return new StatelessPropertyValue(rawValue, this.lookup, variableRegistry);
+        return new StatelessPropertyValue(rawValue, this.lookup, parameterContext, variableRegistry);
     }
 
     @Override
     public ExpressionLanguageCompiler newExpressionLanguageCompiler() {
-        return new StandardExpressionLanguageCompiler(variableRegistry);
+        return new StandardExpressionLanguageCompiler(variableRegistry, parameterContext);
     }
 
     @Override
     public ValidationContext getControllerServiceValidationContext(final ControllerService controllerService) {
-        final StatelessProcessContext serviceProcessContext = new StatelessProcessContext(controllerService, lookup, null, stateManager, variableRegistry);
-        return new StatelessValidationContext(serviceProcessContext, lookup, stateManager, variableRegistry);
+        final StatelessProcessContext serviceProcessContext = new StatelessProcessContext(controllerService, lookup, null, stateManager, variableRegistry, parameterContext);
+        return new StatelessValidationContext(serviceProcessContext, lookup, stateManager, variableRegistry, parameterContext);
     }
 
     @Override
@@ -115,6 +124,28 @@ public String getProcessGroupIdentifier() {
         return "stateless";
     }
 
+    @Override
+    public Collection<String> getReferencedParameters(final String propertyName) {
+        final PropertyDescriptor descriptor = new PropertyDescriptor.Builder().name(propertyName).build();
+        final PropertyConfiguration configuration = this.processContext.getPropertyConfiguration(descriptor);
+        if (configuration == null) {
+            return Collections.emptyList();
+        }
+
+        final List<ParameterReference> references = configuration.getParameterReferences();
+        final List<String> parameterNames = references.stream().map(ParameterReference::getParameterName).collect(Collectors.toList());
+        return parameterNames;
+    }
+
+    @Override
+    public boolean isParameterDefined(final String parameterName) {
+        if (parameterContext == null) {
+            return false;
+        }
+
+        return parameterContext.getParameter(parameterName).isPresent();
+    }
+
     @Override
     public ControllerServiceLookup getControllerServiceLookup() {
         return this.lookup;
diff --git a/nifi-stateless/nifi-stateless-core/src/test/java/org/apache/nifi/stateless/core/BatchTest.java b/nifi-stateless/nifi-stateless-core/src/test/java/org/apache/nifi/stateless/core/BatchTest.java
index 15a0f008cf5..8cb715dc87f 100644
--- a/nifi-stateless/nifi-stateless-core/src/test/java/org/apache/nifi/stateless/core/BatchTest.java
+++ b/nifi-stateless/nifi-stateless-core/src/test/java/org/apache/nifi/stateless/core/BatchTest.java
@@ -49,7 +49,7 @@ public void testScenario1_Test() throws Exception {
         ///////////////////////////////////////////
         VariableRegistry registry = VariableRegistry.EMPTY_REGISTRY;
         boolean materializeData = true;
-        StatelessControllerServiceLookup serviceLookup = new StatelessControllerServiceLookup();
+        StatelessControllerServiceLookup serviceLookup = new StatelessControllerServiceLookup(null);
         File file = new File("/tmp/nifistateless/input/test.txt");
         file.getParentFile().mkdirs();
         file.createNewFile();
@@ -61,7 +61,7 @@ public void testScenario1_Test() throws Exception {
         // Build Flow
         ///////////////////////////////////////////
         StatelessProcessorWrapper getFile = new StatelessProcessorWrapper(UUID.randomUUID().toString(), new GetFile(), null, serviceLookup, registry,
-            materializeData, ClassLoader.getSystemClassLoader());
+            materializeData, ClassLoader.getSystemClassLoader(), null);
         getFile.setProperty(GetFile.DIRECTORY,"/tmp/nifistateless/input/");
         getFile.setProperty(GetFile.FILE_FILTER,"test.txt");
         getFile.setProperty(GetFile.KEEP_SOURCE_FILE,"true");
@@ -108,6 +108,6 @@ public void testScenario1_Test() throws Exception {
 
     private StatelessProcessorWrapper wrapProcessor(final Processor processor, StatelessControllerServiceLookup serviceLookup, final VariableRegistry registry)
                 throws InvocationTargetException, IllegalAccessException {
-        return new StatelessProcessorWrapper(UUID.randomUUID().toString(), processor, null, serviceLookup, registry, true, ClassLoader.getSystemClassLoader());
+        return new StatelessProcessorWrapper(UUID.randomUUID().toString(), processor, null, serviceLookup, registry, true, ClassLoader.getSystemClassLoader(), null);
     }
 }
diff --git a/nifi-stateless/nifi-stateless-core/src/test/java/org/apache/nifi/stateless/core/StreamingIT.java b/nifi-stateless/nifi-stateless-core/src/test/java/org/apache/nifi/stateless/core/StreamingIT.java
index 21c6ff8e64d..ea45ba45524 100644
--- a/nifi-stateless/nifi-stateless-core/src/test/java/org/apache/nifi/stateless/core/StreamingIT.java
+++ b/nifi-stateless/nifi-stateless-core/src/test/java/org/apache/nifi/stateless/core/StreamingIT.java
@@ -52,7 +52,7 @@ public void Scenario1_Test() throws InvocationTargetException, IllegalAccessExce
         ///////////////////////////////////////////
         VariableRegistry registry = VariableRegistry.EMPTY_REGISTRY;
         boolean materializeData = true;
-        StatelessControllerServiceLookup serviceLookup = new StatelessControllerServiceLookup();
+        StatelessControllerServiceLookup serviceLookup = new StatelessControllerServiceLookup(null);
         File file = new File("/tmp/nifistateless/input/test.txt");
         file.getParentFile().mkdirs();
         file.createNewFile();
@@ -130,7 +130,7 @@ public void Scenario1_Test() throws InvocationTargetException, IllegalAccessExce
 
     private StatelessProcessorWrapper wrapProcessor(final Processor processor, StatelessControllerServiceLookup serviceLookup, final VariableRegistry registry)
         throws InvocationTargetException, IllegalAccessException {
-        return new StatelessProcessorWrapper(UUID.randomUUID().toString(), processor, null, serviceLookup, registry, true, ClassLoader.getSystemClassLoader());
+        return new StatelessProcessorWrapper(UUID.randomUUID().toString(), processor, null, serviceLookup, registry, true, ClassLoader.getSystemClassLoader(), null);
     }
 
 }
