diff --git a/nifi-commons/nifi-security-utils/src/main/java/org/apache/nifi/security/util/KeyStoreUtils.java b/nifi-commons/nifi-security-utils/src/main/java/org/apache/nifi/security/util/KeyStoreUtils.java
index 01ee383bb3d..5b91c4ab2b7 100644
--- a/nifi-commons/nifi-security-utils/src/main/java/org/apache/nifi/security/util/KeyStoreUtils.java
+++ b/nifi-commons/nifi-security-utils/src/main/java/org/apache/nifi/security/util/KeyStoreUtils.java
@@ -19,23 +19,35 @@
 
 import java.io.BufferedInputStream;
 import java.io.FileInputStream;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
+import java.io.UncheckedIOException;
 import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.security.GeneralSecurityException;
 import java.security.Key;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
 import java.security.KeyStore;
 import java.security.KeyStoreException;
 import java.security.NoSuchAlgorithmException;
+import java.security.SecureRandom;
 import java.security.Security;
 import java.security.UnrecoverableKeyException;
+import java.security.cert.Certificate;
 import java.security.cert.CertificateException;
+import java.security.cert.X509Certificate;
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Objects;
 import javax.net.ssl.KeyManagerFactory;
 import javax.net.ssl.SSLContext;
 import javax.net.ssl.SSLParameters;
 import javax.net.ssl.SSLServerSocket;
 import javax.net.ssl.TrustManagerFactory;
+import org.apache.commons.codec.binary.Hex;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.commons.lang3.builder.ToStringBuilder;
 import org.bouncycastle.jce.provider.BouncyCastleProvider;
@@ -46,8 +58,24 @@ public class KeyStoreUtils {
     private static final Logger logger = LoggerFactory.getLogger(KeyStoreUtils.class);
 
     public static final String SUN_PROVIDER_NAME = "SUN";
+    private static final String JKS_EXT = ".jks";
+    private static final String PKCS12_EXT = ".p12";
+    private static final String BCFKS_EXT = ".bcfks";
+    private static final String KEY_ALIAS = "nifi-key";
+    private static final String CERT_ALIAS = "nifi-cert";
+    private static final String CERT_DN = "O=Apache,OU=NiFi,CN=localhost";
+    private static final String KEY_ALGORITHM = "RSA";
+    private static final String SIGNING_ALGORITHM = "SHA256withRSA";
+    private static final int CERT_DURATION_DAYS = 365;
+    private static final int PASSWORD_LENGTH = 16;
+    private static final String TEST_KEYSTORE_PREFIX = "test-keystore-";
+    private static final String TEST_TRUSTSTORE_PREFIX = "test-truststore-";
+
+    private static final String KEYSTORE_ERROR_MSG = "There was an error creating a Keystore.";
+    private static final String TRUSTSTORE_ERROR_MSG = "There was an error creating a Truststore.";
 
     private static final Map<String, String> KEY_STORE_TYPE_PROVIDERS = new HashMap<>();
+    private static final Map<KeystoreType, String> KEY_STORE_EXTENSIONS = new HashMap<>();
 
     static {
         Security.addProvider(new BouncyCastleProvider());
@@ -57,6 +85,12 @@ public class KeyStoreUtils {
         KEY_STORE_TYPE_PROVIDERS.put(KeystoreType.JKS.getType(), SUN_PROVIDER_NAME);
     }
 
+    static {
+        KEY_STORE_EXTENSIONS.put(KeystoreType.JKS, JKS_EXT);
+        KEY_STORE_EXTENSIONS.put(KeystoreType.PKCS12, PKCS12_EXT);
+        KEY_STORE_EXTENSIONS.put(KeystoreType.BCFKS, BCFKS_EXT);
+    }
+
     /**
      * Returns the provider that will be used for the given keyStoreType
      *
@@ -125,6 +159,63 @@ public static KeyStore loadKeyStore(String keystorePath, char[] keystorePassword
         }
     }
 
+    /**
+     * Creates a temporary default Keystore and Truststore and returns it wrapped in a TLS configuration.
+     *
+     * @return a {@link org.apache.nifi.security.util.TlsConfiguration}
+     */
+    public static TlsConfiguration createTlsConfigAndNewKeystoreTruststore() throws IOException, GeneralSecurityException {
+        return createTlsConfigAndNewKeystoreTruststore(new StandardTlsConfiguration());
+    }
+
+    /**
+     * Creates a temporary Keystore and Truststore and returns it wrapped in a new TLS configuration with the given values.
+     *
+     * @param tlsConfiguration a {@link org.apache.nifi.security.util.TlsConfiguration}
+     * @return a {@link org.apache.nifi.security.util.TlsConfiguration}
+     */
+    public static TlsConfiguration createTlsConfigAndNewKeystoreTruststore(final TlsConfiguration tlsConfiguration) throws IOException, GeneralSecurityException {
+        final Path keyStorePath;
+        final String keystorePassword = StringUtils.isNotBlank(tlsConfiguration.getKeystorePassword()) ? tlsConfiguration.getKeystorePassword() : generatePassword();
+        final KeystoreType keystoreType = tlsConfiguration.getKeystoreType() != null ? tlsConfiguration.getKeystoreType() : KeystoreType.PKCS12;
+        final String keyPassword = StringUtils.isNotBlank(tlsConfiguration.getKeyPassword()) ? tlsConfiguration.getKeyPassword() : keystorePassword;
+        final Path trustStorePath;
+        final String truststorePassword = StringUtils.isNotBlank(tlsConfiguration.getTruststorePassword()) ? tlsConfiguration.getTruststorePassword() : generatePassword();
+        final KeystoreType truststoreType = tlsConfiguration.getTruststoreType() != null ? tlsConfiguration.getTruststoreType() : KeystoreType.PKCS12;
+
+        // Create temporary Keystore file
+        try {
+            keyStorePath = generateTempKeystorePath(keystoreType);
+        } catch (IOException e) {
+            logger.error(KEYSTORE_ERROR_MSG, e);
+            throw new UncheckedIOException(KEYSTORE_ERROR_MSG, e);
+        }
+
+        // Create temporary Truststore file
+        try {
+            trustStorePath = generateTempTruststorePath(truststoreType);
+        } catch (IOException e) {
+            logger.error(TRUSTSTORE_ERROR_MSG, e);
+            throw new UncheckedIOException(TRUSTSTORE_ERROR_MSG, e);
+        }
+
+        // Create X509 Certificate
+        final X509Certificate clientCert = createKeyStoreAndGetX509Certificate(KEY_ALIAS, keystorePassword, keyPassword, keyStorePath.toString(), keystoreType);
+
+        // Create Truststore
+        createTrustStore(clientCert, CERT_ALIAS, truststorePassword, trustStorePath.toString(), truststoreType);
+
+        return new StandardTlsConfiguration(
+                keyStorePath.toString(),
+                keystorePassword,
+                keyPassword,
+                keystoreType,
+                trustStorePath.toString(),
+                truststorePassword,
+                truststoreType,
+                TlsPlatform.getLatestProtocol());
+    }
+
     /**
      * Returns the {@link KeyManagerFactory} from the provided {@link KeyStore} object, initialized with the key or keystore password.
      *
@@ -150,7 +241,7 @@ public static KeyManagerFactory getKeyManagerFactoryFromKeyStore(KeyStore keySto
     }
 
     /**
-     * Returns the intialized {@link KeyManagerFactory}.
+     * Returns the initialized {@link KeyManagerFactory}.
      *
      * @param tlsConfiguration the TLS configuration
      * @return the initialized key manager factory
@@ -181,7 +272,6 @@ public static KeyManagerFactory loadKeyManagerFactory(String keystorePath, Strin
         return getKeyManagerFactoryFromKeyStore(keyStore, keystorePasswordChars, keyPasswordChars);
     }
 
-
     /**
      * Returns a loaded {@link KeyStore} (acting as a truststore) given the provided configuration values.
      *
@@ -224,7 +314,7 @@ public static TrustManagerFactory getTrustManagerFactoryFromTrustStore(KeyStore
     }
 
     /**
-     * Returns the intialized {@link TrustManagerFactory}.
+     * Returns the initialized {@link TrustManagerFactory}.
      *
      * @param tlsConfiguration the TLS configuration
      * @return the initialized trust manager factory
@@ -244,6 +334,11 @@ public static TrustManagerFactory loadTrustManagerFactory(TlsConfiguration tlsCo
      * @throws TlsException if there is a problem initializing or reading from the truststore
      */
     public static TrustManagerFactory loadTrustManagerFactory(String truststorePath, String truststorePassword, String truststoreType) throws TlsException {
+        // Bouncy Castle PKCS12 type requires a password
+        if (truststoreType.equalsIgnoreCase(KeystoreType.PKCS12.getType()) && StringUtils.isBlank(truststorePassword)) {
+            throw new IllegalArgumentException("A PKCS12 Truststore Type requires a password");
+        }
+
         // Legacy truststore passwords can be empty
         final char[] truststorePasswordChars = StringUtils.isNotBlank(truststorePassword) ? truststorePassword.toCharArray() : null;
         KeyStore trustStore = loadTrustStore(truststorePath, truststorePasswordChars, truststoreType);
@@ -366,4 +461,116 @@ public static String sslServerSocketToString(SSLServerSocket sslServerSocket) {
                 .append("useClientMode", sslServerSocket.getUseClientMode())
                 .toString();
     }
+
+    /**
+     * Loads the Keystore and returns a X509 Certificate with the given values.
+     *
+     * @param alias            the certificate alias
+     * @param keyStorePassword the keystore password
+     * @param keyPassword      the key password
+     * @param keyStorePath     the keystore path
+     * @param keyStoreType     the keystore type
+     * @return a {@link X509Certificate}
+     */
+    private static X509Certificate createKeyStoreAndGetX509Certificate(
+            final String alias, final String keyStorePassword, final String keyPassword, final String keyStorePath,
+            final KeystoreType keyStoreType) throws IOException, KeyStoreException, NoSuchAlgorithmException, CertificateException {
+
+        try (final FileOutputStream outputStream = new FileOutputStream(keyStorePath)) {
+            final KeyPair keyPair = KeyPairGenerator.getInstance(KEY_ALGORITHM).generateKeyPair();
+
+            final X509Certificate selfSignedCert = CertificateUtils.generateSelfSignedX509Certificate(
+                    keyPair, CERT_DN, SIGNING_ALGORITHM, CERT_DURATION_DAYS
+            );
+
+            final KeyStore keyStore = loadEmptyKeyStore(keyStoreType);
+            keyStore.setKeyEntry(alias, keyPair.getPrivate(), keyPassword.toCharArray(), new Certificate[]{selfSignedCert});
+            keyStore.store(outputStream, keyStorePassword.toCharArray());
+
+            return selfSignedCert;
+        }
+    }
+
+    /**
+     * Loads the Truststore with the given values.
+     *
+     * @param cert           the certificate
+     * @param alias          the certificate alias
+     * @param password       the truststore password
+     * @param path           the truststore path
+     * @param truststoreType the truststore type
+     */
+    private static void createTrustStore(final X509Certificate cert,
+                                         final String alias, final String password, final String path, final KeystoreType truststoreType)
+            throws KeyStoreException, NoSuchAlgorithmException, CertificateException {
+
+        try (final FileOutputStream outputStream = new FileOutputStream(path)) {
+            final KeyStore trustStore = loadEmptyKeyStore(truststoreType);
+            trustStore.setCertificateEntry(alias, cert);
+            trustStore.store(outputStream, password.toCharArray());
+        } catch (IOException e) {
+            throw new UncheckedIOException(TRUSTSTORE_ERROR_MSG, e);
+        }
+    }
+
+    /**
+     * Generates a temporary keystore file and returns the path.
+     *
+     * @param keystoreType the Keystore type
+     * @return a Path
+     */
+    private static Path generateTempKeystorePath(KeystoreType keystoreType) throws IOException {
+        return Files.createTempFile(TEST_KEYSTORE_PREFIX, getKeystoreExtension(keystoreType));
+    }
+
+    /**
+     * Generates a temporary truststore file and returns the path.
+     *
+     * @param truststoreType the Truststore type
+     * @return a Path
+     */
+    private static Path generateTempTruststorePath(KeystoreType truststoreType) throws IOException {
+        return Files.createTempFile(TEST_TRUSTSTORE_PREFIX, getKeystoreExtension(truststoreType));
+    }
+
+    /**
+     * Loads and returns an empty Keystore backed by the appropriate provider.
+     *
+     * @param keyStoreType the keystore type
+     * @return an empty keystore
+     * @throws KeyStoreException if a keystore of the given type cannot be instantiated
+     */
+    private static KeyStore loadEmptyKeyStore(KeystoreType keyStoreType) throws KeyStoreException, CertificateException, NoSuchAlgorithmException {
+        final KeyStore keyStore;
+        try {
+            keyStore = KeyStore.getInstance(
+                    Objects.requireNonNull(keyStoreType).getType());
+            keyStore.load(null, null);
+            return keyStore;
+        } catch (IOException e) {
+            logger.error("Encountered an error loading keystore: {}", e.getLocalizedMessage());
+            throw new UncheckedIOException("Error loading keystore", e);
+        }
+    }
+
+    /**
+     * Returns the Keystore extension given the Keystore type.
+     *
+     * @param keystoreType the keystore type
+     * @return the keystore extension
+     */
+    private static String getKeystoreExtension(KeystoreType keystoreType) {
+        return KEY_STORE_EXTENSIONS.get(keystoreType);
+    }
+
+    /**
+     * Generates a random Hex-encoded password.
+     *
+     * @return a password as a Hex-encoded String
+     */
+    private static String generatePassword() {
+        final byte[] password = new byte[PASSWORD_LENGTH];
+        new SecureRandom().nextBytes(password);
+        return Hex.encodeHexString(password);
+    }
 }
diff --git a/nifi-commons/nifi-security-utils/src/test/groovy/org/apache/nifi/security/util/KeyStoreUtilsGroovyTest.groovy b/nifi-commons/nifi-security-utils/src/test/groovy/org/apache/nifi/security/util/KeyStoreUtilsGroovyTest.groovy
index 7a7634809fc..5985e561d16 100644
--- a/nifi-commons/nifi-security-utils/src/test/groovy/org/apache/nifi/security/util/KeyStoreUtilsGroovyTest.groovy
+++ b/nifi-commons/nifi-security-utils/src/test/groovy/org/apache/nifi/security/util/KeyStoreUtilsGroovyTest.groovy
@@ -16,6 +16,7 @@
  */
 package org.apache.nifi.security.util
 
+import org.apache.nifi.util.StringUtils
 import org.junit.After
 import org.junit.Before
 import org.junit.BeforeClass
@@ -29,17 +30,22 @@ import org.slf4j.LoggerFactory
 import javax.net.ssl.HttpsURLConnection
 import javax.net.ssl.SSLSocket
 import javax.net.ssl.SSLSocketFactory
+import java.nio.file.Files
+import java.nio.file.Path
+import java.nio.file.Paths
 import java.security.KeyStore
 import java.security.cert.Certificate
+import java.security.cert.X509Certificate
 
 @RunWith(JUnit4.class)
 class KeyStoreUtilsGroovyTest extends GroovyTestCase {
     private static final Logger logger = LoggerFactory.getLogger(KeyStoreUtilsGroovyTest.class)
 
-    private static final File KEYSTORE_FILE = new File("src/test/resources/keystore.jks")
-    private static final String KEYSTORE_PASSWORD = "passwordpassword"
-    private static final String KEY_PASSWORD = "keypassword"
-    private static final KeystoreType KEYSTORE_TYPE = KeystoreType.JKS
+    private static final String TEST_KEYSTORE_PASSWORD = KeyStoreUtils.generatePassword()
+    private static final String TEST_KEY_PASSWORD = KeyStoreUtils.generatePassword()
+    private static final String TEST_TRUSTSTORE_PASSWORD = KeyStoreUtils.generatePassword()
+    private static final KeystoreType DEFAULT_STORE_TYPE = KeystoreType.JKS
+    private static final String KEY_ALIAS = "nifi-key"
 
     @BeforeClass
     static void setUpOnce() {
@@ -61,9 +67,14 @@ class KeyStoreUtilsGroovyTest extends GroovyTestCase {
     @Test
     void testShouldVerifyKeystoreIsValid() {
         // Arrange
+        TlsConfiguration tlsConfigParam = new StandardTlsConfiguration(null, TEST_KEYSTORE_PASSWORD, DEFAULT_STORE_TYPE, null, null, DEFAULT_STORE_TYPE)
+
+        TlsConfiguration tlsConfig = KeyStoreUtils.createTlsConfigAndNewKeystoreTruststore(tlsConfigParam)
+        final URL ksUrl = getKeystorePathAsUrl(tlsConfig.getKeystorePath())
 
         // Act
-        boolean keystoreIsValid = KeyStoreUtils.isStoreValid(KEYSTORE_FILE.toURI().toURL(), KEYSTORE_TYPE, KEYSTORE_PASSWORD.toCharArray())
+        boolean keystoreIsValid = KeyStoreUtils.isStoreValid(ksUrl, DEFAULT_STORE_TYPE, TEST_KEYSTORE_PASSWORD.toCharArray())
+        deleteKeystoreTruststore(tlsConfig)
 
         // Assert
         assert keystoreIsValid
@@ -72,9 +83,14 @@ class KeyStoreUtilsGroovyTest extends GroovyTestCase {
     @Test
     void testShouldVerifyKeystoreIsNotValid() {
         // Arrange
+        TlsConfiguration tlsConfigParam = new StandardTlsConfiguration(null, TEST_KEYSTORE_PASSWORD, DEFAULT_STORE_TYPE, null, null, DEFAULT_STORE_TYPE)
+
+        TlsConfiguration tlsConfig = KeyStoreUtils.createTlsConfigAndNewKeystoreTruststore(tlsConfigParam)
+        final URL ksUrl = getKeystorePathAsUrl(tlsConfig.getKeystorePath())
 
         // Act
-        boolean keystoreIsValid = KeyStoreUtils.isStoreValid(KEYSTORE_FILE.toURI().toURL(), KEYSTORE_TYPE, KEYSTORE_PASSWORD.reverse().toCharArray())
+        boolean keystoreIsValid = KeyStoreUtils.isStoreValid(ksUrl, DEFAULT_STORE_TYPE, TEST_KEYSTORE_PASSWORD.reverse().toCharArray())
+        deleteKeystoreTruststore(tlsConfig)
 
         // Assert
         assert !keystoreIsValid
@@ -83,9 +99,14 @@ class KeyStoreUtilsGroovyTest extends GroovyTestCase {
     @Test
     void testShouldVerifyKeyPasswordIsValid() {
         // Arrange
+        TlsConfiguration tlsConfigParam = new StandardTlsConfiguration(null, TEST_KEYSTORE_PASSWORD, TEST_KEY_PASSWORD, DEFAULT_STORE_TYPE, null, null, DEFAULT_STORE_TYPE)
+
+        TlsConfiguration tlsConfig = KeyStoreUtils.createTlsConfigAndNewKeystoreTruststore(tlsConfigParam)
+        final URL ksUrl = getKeystorePathAsUrl(tlsConfig.getKeystorePath())
 
         // Act
-        boolean keyPasswordIsValid = KeyStoreUtils.isKeyPasswordCorrect(KEYSTORE_FILE.toURI().toURL(), KEYSTORE_TYPE, KEYSTORE_PASSWORD.toCharArray(), KEYSTORE_PASSWORD.toCharArray())
+        boolean keyPasswordIsValid = KeyStoreUtils.isKeyPasswordCorrect(ksUrl, DEFAULT_STORE_TYPE, TEST_KEYSTORE_PASSWORD.toCharArray(), TEST_KEY_PASSWORD.toCharArray())
+        deleteKeystoreTruststore(tlsConfig)
 
         // Assert
         assert keyPasswordIsValid
@@ -94,9 +115,14 @@ class KeyStoreUtilsGroovyTest extends GroovyTestCase {
     @Test
     void testShouldVerifyKeyPasswordIsNotValid() {
         // Arrange
+        TlsConfiguration tlsConfigParam = new StandardTlsConfiguration(null, TEST_KEYSTORE_PASSWORD, TEST_KEY_PASSWORD, DEFAULT_STORE_TYPE, null, null, DEFAULT_STORE_TYPE)
+
+        TlsConfiguration tlsConfig = KeyStoreUtils.createTlsConfigAndNewKeystoreTruststore(tlsConfigParam)
+        final URL ksUrl = getKeystorePathAsUrl(tlsConfig.getKeystorePath())
 
         // Act
-        boolean keyPasswordIsValid = KeyStoreUtils.isKeyPasswordCorrect(KEYSTORE_FILE.toURI().toURL(), KEYSTORE_TYPE, KEYSTORE_PASSWORD.toCharArray(), KEYSTORE_PASSWORD.reverse().toCharArray())
+        boolean keyPasswordIsValid = KeyStoreUtils.isKeyPasswordCorrect(ksUrl, tlsConfig.getKeystoreType(), TEST_KEYSTORE_PASSWORD.toCharArray(), TEST_KEY_PASSWORD.reverse().toCharArray())
+        deleteKeystoreTruststore(tlsConfig)
 
         // Assert
         assert !keyPasswordIsValid
@@ -141,4 +167,139 @@ class KeyStoreUtilsGroovyTest extends GroovyTestCase {
         FileOutputStream fos = new FileOutputStream("/Users/alopresto/Workspace/nifi/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/resources/truststore.no-password.jks")
         truststore.store(fos, "".chars)
     }
+
+    @Test
+    void testShouldValidateTempKeystorePath() {
+        // Act
+        Path testKeystorePath = KeyStoreUtils.generateTempKeystorePath(DEFAULT_STORE_TYPE)
+        deletePath(testKeystorePath)
+
+        // Assert
+        logger.info("Keystore path: ${testKeystorePath.toString()}")
+        assert testKeystorePath
+    }
+
+    @Test
+    void testShouldValidateTempTruststorePath() {
+        // Act
+        Path truststorePath = KeyStoreUtils.generateTempTruststorePath(DEFAULT_STORE_TYPE)
+        deletePath(truststorePath)
+
+        // Assert
+        logger.info("Truststore path: ${truststorePath.toString()}")
+        assert truststorePath
+    }
+
+    @Test
+    void testShouldValidateTlsConfigAndNewKeystoreTruststoreWithParams() {
+        // Arrange
+        TlsConfiguration tlsConfigParam = new StandardTlsConfiguration(null, TEST_KEYSTORE_PASSWORD, TEST_KEY_PASSWORD, DEFAULT_STORE_TYPE, null, TEST_TRUSTSTORE_PASSWORD, DEFAULT_STORE_TYPE)
+
+        // Act
+        final TlsConfiguration tlsConfig = KeyStoreUtils.createTlsConfigAndNewKeystoreTruststore(tlsConfigParam)
+        deleteKeystoreTruststore(tlsConfig)
+
+        // Assert
+        assert tlsConfig.getKeystorePath()
+        assert tlsConfig.getTruststorePath()
+        assert tlsConfig.getKeystoreType() == KeystoreType.JKS
+        assert tlsConfig.getTruststoreType() == KeystoreType.JKS
+        assert tlsConfig.getKeystorePassword() == TEST_KEYSTORE_PASSWORD
+    }
+
+    @Test
+    void testShouldValidateTlsConfigAndNewKeystoreTruststoreWithoutParams() {
+        // Act
+        TlsConfiguration tlsConfig = KeyStoreUtils.createTlsConfigAndNewKeystoreTruststore()
+        deleteKeystoreTruststore(tlsConfig)
+
+        // Assert
+        assert tlsConfig.getKeystorePath()
+        assert tlsConfig.getKeyPassword() == tlsConfig.getKeystorePassword()
+        assert tlsConfig.getTruststorePassword()
+        assert tlsConfig.getKeystoreType() == KeystoreType.PKCS12
+        assert tlsConfig.getTruststoreType() == KeystoreType.PKCS12
+    }
+
+    @Test
+    void testShouldValidateTlsConfigWithoutKeyPasswordParam() {
+        // Arrange
+        TlsConfiguration tlsConfigParam = new StandardTlsConfiguration(null, TEST_KEYSTORE_PASSWORD, null, DEFAULT_STORE_TYPE, null, TEST_TRUSTSTORE_PASSWORD, DEFAULT_STORE_TYPE)
+
+        // Act
+        final TlsConfiguration tlsConfig = KeyStoreUtils.createTlsConfigAndNewKeystoreTruststore(tlsConfigParam)
+        deleteKeystoreTruststore(tlsConfig)
+
+        // Assert
+        assert tlsConfig.getKeyPassword() == tlsConfig.getKeystorePassword()
+    }
+
+    @Test
+    void testShouldReturnX509CertWithNewKeystore() {
+        // Arrange
+        Path keystorePath = KeyStoreUtils.generateTempKeystorePath(DEFAULT_STORE_TYPE)
+
+        // Act
+        X509Certificate x509Cert = KeyStoreUtils.createKeyStoreAndGetX509Certificate(KEY_ALIAS, TEST_KEYSTORE_PASSWORD, TEST_KEYSTORE_PASSWORD, keystorePath.toString(), DEFAULT_STORE_TYPE)
+
+        boolean isKeystoreValid = KeyStoreUtils.isStoreValid(keystorePath.toUri().toURL(), DEFAULT_STORE_TYPE, TEST_KEYSTORE_PASSWORD.toCharArray())
+        deletePath(keystorePath)
+
+        // Assert
+        final String certDN = x509Cert.getIssuerDN().toString()
+        assert certDN =~ "CN="
+        assert isKeystoreValid
+    }
+
+    @Test
+    void testShouldValidateGetKeystoreExtension() {
+        // Arrange
+        final String EXPECTED_JKS_EXTENSION = ".jks"
+        final String EXPECTED_PKCS12_EXTENSION = ".p12"
+        final String EXPECTED_BCFKS_EXTENSION = ".bcfks"
+
+        // Act
+        String correct_jks_ext = KeyStoreUtils.getKeystoreExtension(KeystoreType.JKS)
+        String correct_pkcs12_ext = KeyStoreUtils.getKeystoreExtension(KeystoreType.PKCS12)
+        String correct_bcfks_ext = KeyStoreUtils.getKeystoreExtension(KeystoreType.BCFKS)
+
+        // Assert
+        assert correct_jks_ext == EXPECTED_JKS_EXTENSION
+        assert correct_pkcs12_ext == EXPECTED_PKCS12_EXTENSION
+        assert correct_bcfks_ext == EXPECTED_BCFKS_EXTENSION
+    }
+
+    private static URL getKeystorePathAsUrl(String path) {
+        return new File(path).toURI().toURL()
+    }
+
+    private static void deleteKeystoreTruststore(TlsConfiguration tlsConfig) {
+        if (tlsConfig != null) {
+            try {
+                if (StringUtils.isNotBlank(tlsConfig.getKeystorePath())) {
+                    Files.deleteIfExists(Paths.get(tlsConfig.getKeystorePath()))
+                }
+            } catch (IOException e) {
+                throw new IOException("There was an error deleting a keystore: ${e.getMessage()}, ${e}");
+            }
+
+            try {
+                if (StringUtils.isNotBlank(tlsConfig.getTruststorePath())) {
+                    Files.deleteIfExists(Paths.get(tlsConfig.getTruststorePath()))
+                }
+            } catch (IOException e) {
+                throw new IOException("There was an error deleting a truststore: ${e.getMessage()}, ${e}");
+            }
+        }
+    }
+
+    private static void deletePath(Path path) {
+        try {
+            if (path != null) {
+                Files.deleteIfExists(path)
+            }
+        } catch (IOException e) {
+            throw new IOException("There was an error deleting a file at ${path}: ${e.getMessage()}, ${e}");
+        }
+    }
 }
diff --git a/nifi-commons/nifi-security-utils/src/test/java/org/apache/nifi/security/util/KeyStoreUtilsTest.java b/nifi-commons/nifi-security-utils/src/test/java/org/apache/nifi/security/util/KeyStoreUtilsTest.java
index 729967e9d94..15ed291a283 100644
--- a/nifi-commons/nifi-security-utils/src/test/java/org/apache/nifi/security/util/KeyStoreUtilsTest.java
+++ b/nifi-commons/nifi-security-utils/src/test/java/org/apache/nifi/security/util/KeyStoreUtilsTest.java
@@ -17,9 +17,6 @@
 
 package org.apache.nifi.security.util;
 
-import org.junit.BeforeClass;
-import org.junit.Test;
-
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
@@ -31,6 +28,8 @@
 import java.security.cert.Certificate;
 import java.security.cert.CertificateException;
 import java.security.cert.X509Certificate;
+import org.junit.BeforeClass;
+import org.junit.Test;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
diff --git a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestInvokeHTTP.java b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestInvokeHTTP.java
index 860b68f6f2e..cd096addce5 100644
--- a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestInvokeHTTP.java
+++ b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestInvokeHTTP.java
@@ -16,25 +16,24 @@
  */
 package org.apache.nifi.processors.standard;
 
-import static java.nio.charset.StandardCharsets.UTF_8;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.junit.Assert.assertTrue;
-
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.lang.reflect.Field;
 import java.net.URL;
 import java.nio.charset.StandardCharsets;
+import java.nio.file.Files;
+import java.nio.file.Paths;
 import java.util.HashMap;
 import java.util.Map;
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 import org.apache.commons.lang3.SystemUtils;
 import org.apache.nifi.processors.standard.util.TestInvokeHttpCommon;
+import org.apache.nifi.security.util.KeyStoreUtils;
+import org.apache.nifi.security.util.TlsConfiguration;
 import org.apache.nifi.ssl.StandardSSLContextService;
 import org.apache.nifi.util.MockFlowFile;
+import org.apache.nifi.util.StringUtils;
 import org.apache.nifi.util.TestRunners;
 import org.apache.nifi.web.util.TestServer;
 import org.eclipse.jetty.server.Request;
@@ -49,9 +48,17 @@
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import static java.nio.charset.StandardCharsets.UTF_8;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertTrue;
+
 public class TestInvokeHTTP extends TestInvokeHttpCommon {
     private static final Logger logger = LoggerFactory.getLogger(TestInvokeHTTP.class);
 
+    private static TlsConfiguration tlsConfiguration;
+
     @BeforeClass
     public static void beforeClass() throws Exception {
         Assume.assumeTrue("Test only runs on *nix", !SystemUtils.IS_OS_WINDOWS);
@@ -65,13 +72,34 @@ public static void beforeClass() throws Exception {
 
         // this is the base url with the random port
         url = server.getUrl();
+
+        // create TLS configuration with a new keystore and truststore
+        tlsConfiguration = KeyStoreUtils.createTlsConfigAndNewKeystoreTruststore();
     }
 
     @AfterClass
     public static void afterClass() throws Exception {
-        if(server != null) {
+        if (server != null) {
             server.shutdownServer();
         }
+
+        if (tlsConfiguration != null) {
+            try {
+                if (StringUtils.isNotBlank(tlsConfiguration.getKeystorePath())) {
+                    Files.deleteIfExists(Paths.get(tlsConfiguration.getKeystorePath()));
+                }
+            } catch (IOException e) {
+                throw new IOException("There was an error deleting a keystore: " + e.getMessage(), e);
+            }
+
+            try {
+                if (StringUtils.isNotBlank(tlsConfiguration.getTruststorePath())) {
+                    Files.deleteIfExists(Paths.get(tlsConfiguration.getTruststorePath()));
+                }
+            } catch (IOException e) {
+                throw new IOException("There was an error deleting a truststore: " + e.getMessage(), e);
+            }
+        }
     }
 
     @Before
@@ -94,12 +122,12 @@ private static TestServer createServer() {
     public void testSslSetHttpRequest() throws Exception {
 
         final Map<String, String> sslProperties = new HashMap<>();
-        sslProperties.put(StandardSSLContextService.KEYSTORE.getName(), "src/test/resources/keystore.jks");
-        sslProperties.put(StandardSSLContextService.KEYSTORE_PASSWORD.getName(), "passwordpassword");
-        sslProperties.put(StandardSSLContextService.KEYSTORE_TYPE.getName(), "JKS");
-        sslProperties.put(StandardSSLContextService.TRUSTSTORE.getName(), "src/test/resources/truststore.jks");
-        sslProperties.put(StandardSSLContextService.TRUSTSTORE_PASSWORD.getName(), "passwordpassword");
-        sslProperties.put(StandardSSLContextService.TRUSTSTORE_TYPE.getName(), "JKS");
+        sslProperties.put(StandardSSLContextService.KEYSTORE.getName(), tlsConfiguration.getKeystorePath());
+        sslProperties.put(StandardSSLContextService.KEYSTORE_PASSWORD.getName(), tlsConfiguration.getKeystorePassword());
+        sslProperties.put(StandardSSLContextService.KEYSTORE_TYPE.getName(), tlsConfiguration.getKeystoreType().toString());
+        sslProperties.put(StandardSSLContextService.TRUSTSTORE.getName(), tlsConfiguration.getTruststorePath());
+        sslProperties.put(StandardSSLContextService.TRUSTSTORE_PASSWORD.getName(), tlsConfiguration.getTruststorePassword());
+        sslProperties.put(StandardSSLContextService.TRUSTSTORE_TYPE.getName(), tlsConfiguration.getTruststoreType().toString());
 
         runner = TestRunners.newTestRunner(InvokeHTTP.class);
         final StandardSSLContextService sslService = new StandardSSLContextService();
@@ -155,20 +183,20 @@ public void testProxy() throws Exception {
         runner.setProperty(InvokeHTTP.PROP_URL, "http://nifi.apache.org/"); // just a dummy URL no connection goes out
         runner.setProperty(InvokeHTTP.PROP_PROXY_HOST, "${proxy.host}");
 
-        try{
+        try {
             runner.run();
             Assert.fail();
-        } catch (AssertionError e){
+        } catch (AssertionError e) {
             // Expect assertion error when proxy port isn't set but host is.
         }
         runner.setProperty(InvokeHTTP.PROP_PROXY_PORT, "${proxy.port}");
 
         runner.setProperty(InvokeHTTP.PROP_PROXY_USER, "${proxy.username}");
 
-        try{
+        try {
             runner.run();
             Assert.fail();
-        } catch (AssertionError e){
+        } catch (AssertionError e) {
             // Expect assertion error when proxy password isn't set but host is.
         }
         runner.setProperty(InvokeHTTP.PROP_PROXY_PASSWORD, "${proxy.password}");
@@ -448,5 +476,4 @@ public void handle(String target, Request baseRequest, HttpServletRequest reques
             }
         }
     }
-
 }
diff --git a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestInvokeHttpSSL.java b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestInvokeHttpSSL.java
index 4fbc56213e0..2eb7ec1fb87 100644
--- a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestInvokeHttpSSL.java
+++ b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestInvokeHttpSSL.java
@@ -18,11 +18,15 @@
 package org.apache.nifi.processors.standard;
 
 import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Paths;
 import java.util.HashMap;
 import java.util.Map;
-
+import org.apache.commons.lang3.StringUtils;
 import org.apache.commons.lang3.SystemUtils;
 import org.apache.nifi.processors.standard.util.TestInvokeHttpCommon;
+import org.apache.nifi.security.util.KeyStoreUtils;
+import org.apache.nifi.security.util.TlsConfiguration;
 import org.apache.nifi.ssl.StandardSSLContextService;
 import org.apache.nifi.util.TestRunners;
 import org.apache.nifi.web.util.TestServer;
@@ -40,7 +44,7 @@ public class TestInvokeHttpSSL extends TestInvokeHttpCommon {
 
     protected static Map<String, String> sslProperties;
     protected static Map<String, String> serverSslProperties;
-
+    protected static TlsConfiguration tlsConfiguration;
 
     @BeforeClass
     public static void beforeClass() throws Exception {
@@ -49,6 +53,9 @@ public static void beforeClass() throws Exception {
         // don't commit this with this property enabled, or any 'mvn test' will be really verbose
         // System.setProperty("org.slf4j.simpleLogger.log.nifi.processors.standard", "debug");
 
+        // create TLS configuration with a new keystore and truststore
+        tlsConfiguration = KeyStoreUtils.createTlsConfigAndNewKeystoreTruststore();
+
         // create the SSL properties, which basically store keystore / truststore information
         // this is used by the StandardSSLContextService and the Jetty Server
         serverSslProperties = createServerSslProperties(false);
@@ -66,9 +73,27 @@ public static void beforeClass() throws Exception {
 
     @AfterClass
     public static void afterClass() throws Exception {
-        if(server != null) {
+        if (server != null) {
             server.shutdownServer();
         }
+
+        if (tlsConfiguration != null) {
+            try {
+                if (StringUtils.isNotBlank(tlsConfiguration.getKeystorePath())) {
+                    Files.deleteIfExists(Paths.get(tlsConfiguration.getKeystorePath()));
+                }
+            } catch (IOException e) {
+                throw new IOException("There was an error deleting a keystore: " + e.getMessage(), e);
+            }
+
+            try {
+                if (StringUtils.isNotBlank(tlsConfiguration.getTruststorePath())) {
+                    Files.deleteIfExists(Paths.get(tlsConfiguration.getTruststorePath()));
+                }
+            } catch (IOException e) {
+                throw new IOException("There was an error deleting a truststore: " + e.getMessage(), e);
+            }
+        }
     }
 
     @Before
@@ -113,7 +138,6 @@ static Map<String, String> createServerSslProperties(boolean clientAuth) {
         return map;
     }
 
-
     static Map<String, String> createClientSslProperties(boolean clientAuth) {
         final Map<String, String> map = new HashMap<>();
         // if requesting client auth then we must provide a keystore
@@ -127,26 +151,26 @@ static Map<String, String> createClientSslProperties(boolean clientAuth) {
 
     private static Map<String, String> getServerKeystoreProperties() {
         final Map<String, String> map = new HashMap<>();
-        map.put(StandardSSLContextService.KEYSTORE.getName(), "src/test/resources/keystore.jks");
-        map.put(StandardSSLContextService.KEYSTORE_PASSWORD.getName(), "passwordpassword");
-        map.put(StandardSSLContextService.KEYSTORE_TYPE.getName(), "JKS");
+        map.put(StandardSSLContextService.KEYSTORE.getName(), tlsConfiguration.getKeystorePath());
+        map.put(StandardSSLContextService.KEYSTORE_PASSWORD.getName(), tlsConfiguration.getKeystorePassword());
+        map.put(StandardSSLContextService.KEYSTORE_TYPE.getName(), tlsConfiguration.getKeystoreType().toString());
         return map;
     }
 
     private static Map<String, String> getClientKeystoreProperties() {
         final Map<String, String> map = new HashMap<>();
-        map.put(StandardSSLContextService.KEYSTORE.getName(), "src/test/resources/client-keystore.p12");
-        map.put(StandardSSLContextService.KEYSTORE_PASSWORD.getName(), "passwordpassword");
-        map.put(StandardSSLContextService.KEYSTORE_TYPE.getName(), "PKCS12");
+        map.put(StandardSSLContextService.KEYSTORE.getName(), tlsConfiguration.getKeystorePath());
+        map.put(StandardSSLContextService.KEYSTORE_PASSWORD.getName(), tlsConfiguration.getKeystorePassword());
+        map.put(StandardSSLContextService.KEYSTORE_TYPE.getName(), tlsConfiguration.getKeystoreType().toString());
         return map;
     }
 
     private static Map<String, String> getTruststoreProperties() {
         final Map<String, String> map = new HashMap<>();
-        map.put(StandardSSLContextService.TRUSTSTORE.getName(), "src/test/resources/truststore.no-password.jks");
+        map.put(StandardSSLContextService.TRUSTSTORE.getName(), tlsConfiguration.getTruststorePath());
         // Commented this line to test passwordless truststores for NIFI-6770
-        // map.put(StandardSSLContextService.TRUSTSTORE_PASSWORD.getName(), "passwordpassword");
-        map.put(StandardSSLContextService.TRUSTSTORE_TYPE.getName(), "JKS");
+        map.put(StandardSSLContextService.TRUSTSTORE_PASSWORD.getName(), tlsConfiguration.getTruststorePassword());
+        map.put(StandardSSLContextService.TRUSTSTORE_TYPE.getName(), tlsConfiguration.getKeystoreType().toString());
         return map;
     }
 }
diff --git a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestInvokeHttpTwoWaySSL.java b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestInvokeHttpTwoWaySSL.java
index 4e500b9ff9d..3643e0def14 100644
--- a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestInvokeHttpTwoWaySSL.java
+++ b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestInvokeHttpTwoWaySSL.java
@@ -17,7 +17,13 @@
 
 package org.apache.nifi.processors.standard;
 
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import org.apache.commons.lang3.StringUtils;
 import org.apache.commons.lang3.SystemUtils;
+import org.apache.nifi.security.util.KeyStoreUtils;
+import org.junit.AfterClass;
 import org.junit.Assume;
 import org.junit.BeforeClass;
 
@@ -28,7 +34,6 @@
  */
 public class TestInvokeHttpTwoWaySSL extends TestInvokeHttpSSL {
 
-
     @BeforeClass
     public static void beforeClass() throws Exception {
         Assume.assumeTrue("Test only runs on *nix", !SystemUtils.IS_OS_WINDOWS);
@@ -36,7 +41,10 @@ public static void beforeClass() throws Exception {
         // don't commit this with this property enabled, or any 'mvn test' will be really verbose
         // System.setProperty("org.slf4j.simpleLogger.log.nifi.processors.standard", "debug");
 
-        // create the SSL properties, which basically store keystore / trustore information
+        // create TLS configuration with a new keystore and truststore
+        tlsConfiguration = KeyStoreUtils.createTlsConfigAndNewKeystoreTruststore();
+
+        // create the SSL properties, which basically store keystore / truststore information
         // this is used by the StandardSSLContextService and the Jetty Server
         serverSslProperties = createServerSslProperties(true);
         sslProperties = createClientSslProperties(true);
@@ -51,4 +59,28 @@ public static void beforeClass() throws Exception {
         url = server.getSecureUrl();
     }
 
+    @AfterClass
+    public static void afterClass() throws Exception {
+        if (server != null) {
+            server.shutdownServer();
+        }
+
+        if (tlsConfiguration != null) {
+            try {
+                if (StringUtils.isNotBlank(tlsConfiguration.getKeystorePath())) {
+                    Files.deleteIfExists(Paths.get(tlsConfiguration.getKeystorePath()));
+                }
+            } catch (IOException e) {
+                throw new IOException("There was an error deleting a keystore: " + e.getMessage(), e);
+            }
+
+            try {
+                if (StringUtils.isNotBlank(tlsConfiguration.getTruststorePath())) {
+                    Files.deleteIfExists(Paths.get(tlsConfiguration.getTruststorePath()));
+                }
+            } catch (IOException e) {
+                throw new IOException("There was an error deleting a truststore: " + e.getMessage(), e);
+            }
+        }
+    }
 }
diff --git a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestListenHTTP.java b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestListenHTTP.java
index f819a283757..9ef62cf9da4 100644
--- a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestListenHTTP.java
+++ b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/TestListenHTTP.java
@@ -16,21 +16,21 @@
  */
 package org.apache.nifi.processors.standard;
 
-import static org.apache.nifi.processors.standard.ListenHTTP.RELATIONSHIP_SUCCESS;
-import static org.junit.Assert.assertThrows;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-
 import com.google.common.base.Charsets;
 import com.google.common.base.Optional;
 import com.google.common.collect.Iterables;
-import com.google.common.io.Files;
 import java.io.DataOutputStream;
 import java.io.File;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.net.HttpURLConnection;
 import java.net.URL;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.security.GeneralSecurityException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.Random;
 import java.util.concurrent.TimeUnit;
@@ -48,12 +48,14 @@
 import okhttp3.Request;
 import okhttp3.RequestBody;
 import okhttp3.Response;
+import org.apache.commons.io.IOUtils;
+import org.apache.commons.lang3.StringUtils;
 import org.apache.commons.lang3.SystemUtils;
 import org.apache.nifi.processor.ProcessContext;
 import org.apache.nifi.processor.ProcessSessionFactory;
 import org.apache.nifi.remote.io.socket.NetworkUtils;
 import org.apache.nifi.reporting.InitializationException;
-import org.apache.nifi.security.util.KeystoreType;
+import org.apache.nifi.security.util.KeyStoreUtils;
 import org.apache.nifi.security.util.SslContextFactory;
 import org.apache.nifi.security.util.StandardTlsConfiguration;
 import org.apache.nifi.security.util.TlsConfiguration;
@@ -65,12 +67,18 @@
 import org.apache.nifi.util.TestRunner;
 import org.apache.nifi.util.TestRunners;
 import org.junit.After;
+import org.junit.AfterClass;
 import org.junit.Assert;
 import org.junit.Assume;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
+import static org.apache.nifi.processors.standard.ListenHTTP.RELATIONSHIP_SUCCESS;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertThrows;
+import static org.junit.Assert.fail;
+
 public class TestListenHTTP {
 
     private static final String SSL_CONTEXT_SERVICE_IDENTIFIER = "ssl-context";
@@ -84,14 +92,6 @@ public class TestListenHTTP {
     private final static String BASEPATH_VARIABLE = "HTTP_BASEPATH";
     private final static String HTTP_SERVER_BASEPATH_EL = "${" + BASEPATH_VARIABLE + "}";
 
-    private static final String KEYSTORE = "src/test/resources/keystore.jks";
-    private static final String KEYSTORE_PASSWORD = "passwordpassword";
-    private static final String TRUSTSTORE = "src/test/resources/truststore.jks";
-    private static final String TRUSTSTORE_PASSWORD = "passwordpassword";
-    private static final String TRUSTSTORE_TYPE = KeystoreType.JKS.getType();
-    private static final String CLIENT_KEYSTORE = "src/test/resources/client-keystore.p12";
-    private static final String CLIENT_KEYSTORE_TYPE = KeystoreType.PKCS12.getType();
-
     private static final String TLS_1_3 = "TLSv1.3";
     private static final String TLS_1_2 = "TLSv1.2";
     private static final String LOCALHOST = "localhost";
@@ -105,22 +105,45 @@ public class TestListenHTTP {
     private int availablePort;
 
     @BeforeClass
-    public static void setUpSuite() {
+    public static void setUpSuite() throws IOException, GeneralSecurityException {
         Assume.assumeTrue("Test only runs on *nix", !SystemUtils.IS_OS_WINDOWS);
+
+        clientTlsConfiguration = KeyStoreUtils.createTlsConfigAndNewKeystoreTruststore();
+
+        trustOnlyTlsConfiguration = new StandardTlsConfiguration(
+                null, null, null, null,
+                clientTlsConfiguration.getTruststorePath(), clientTlsConfiguration.getTruststorePassword(),
+                clientTlsConfiguration.getTruststoreType(), clientTlsConfiguration.getProtocol());
+    }
+
+    @AfterClass
+    public static void afterClass() throws Exception {
+        if (clientTlsConfiguration != null) {
+            try {
+                if (StringUtils.isNotBlank(clientTlsConfiguration.getKeystorePath())) {
+                    Files.deleteIfExists(Paths.get(clientTlsConfiguration.getKeystorePath()));
+                }
+            } catch (IOException e) {
+                throw new IOException("There was an error deleting a keystore: " + e.getMessage(), e);
+            }
+
+            try {
+                if (StringUtils.isNotBlank(clientTlsConfiguration.getTruststorePath())) {
+                    Files.deleteIfExists(Paths.get(clientTlsConfiguration.getTruststorePath()));
+                }
+            } catch (IOException e) {
+                throw new IOException("There was an error deleting a truststore: " + e.getMessage(), e);
+            }
+        }
     }
 
     @Before
-    public void setup() throws IOException {
+    public void setup() throws IOException, GeneralSecurityException {
         proc = new ListenHTTP();
         runner = TestRunners.newTestRunner(proc);
         availablePort = NetworkUtils.availablePort();
         runner.setVariable(PORT_VARIABLE, Integer.toString(availablePort));
         runner.setVariable(BASEPATH_VARIABLE, HTTP_BASE_PATH);
-
-        clientTlsConfiguration = new StandardTlsConfiguration(CLIENT_KEYSTORE, KEYSTORE_PASSWORD, null, CLIENT_KEYSTORE_TYPE,
-                TRUSTSTORE, TRUSTSTORE_PASSWORD, TRUSTSTORE_TYPE, TlsConfiguration.getHighestCurrentSupportedTlsProtocolVersion());
-        trustOnlyTlsConfiguration = new StandardTlsConfiguration(null, null, null, null,
-                TRUSTSTORE, TRUSTSTORE_PASSWORD, TRUSTSTORE_TYPE, TlsConfiguration.getHighestCurrentSupportedTlsProtocolVersion());
     }
 
     @After
@@ -476,15 +499,14 @@ private SSLContextService configureProcessorSslContextService(final ListenHTTP.C
         runner.addControllerService(SSL_CONTEXT_SERVICE_IDENTIFIER, sslContextService);
 
         if (setTrustStoreProperties) {
-            runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE, TRUSTSTORE);
-            runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE_PASSWORD, TRUSTSTORE_PASSWORD);
-            runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE_TYPE, KeystoreType.JKS.getType());
+            runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE, clientTlsConfiguration.getTruststorePath());
+            runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE_PASSWORD, clientTlsConfiguration.getTruststorePassword());
+            runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE_TYPE, clientTlsConfiguration.getTruststoreType().toString());
         }
         runner.setProperty(ListenHTTP.CLIENT_AUTHENTICATION, clientAuthentication.name());
-
-        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE, KEYSTORE);
-        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE_PASSWORD, TRUSTSTORE_PASSWORD);
-        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE_TYPE, KeystoreType.JKS.getType());
+        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE, clientTlsConfiguration.getKeystorePath());
+        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE_PASSWORD, clientTlsConfiguration.getKeystorePassword());
+        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE_TYPE, clientTlsConfiguration.getKeystoreType().toString());
 
         runner.setProperty(ListenHTTP.SSL_CONTEXT_SERVICE, SSL_CONTEXT_SERVICE_IDENTIFIER);
 
@@ -494,12 +516,12 @@ private SSLContextService configureProcessorSslContextService(final ListenHTTP.C
     private SSLContextService configureInvalidProcessorSslContextService() throws InitializationException {
         final SSLContextService sslContextService = new StandardSSLContextService();
         runner.addControllerService(SSL_CONTEXT_SERVICE_IDENTIFIER, sslContextService);
-        runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE, TRUSTSTORE);
-        runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE_PASSWORD, TRUSTSTORE_PASSWORD);
-        runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE_TYPE, KeystoreType.JKS.getType());
-        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE, KEYSTORE);
-        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE_PASSWORD, KEYSTORE_PASSWORD);
-        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE_TYPE, KeystoreType.JKS.getType());
+        runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE, clientTlsConfiguration.getTruststorePath());
+        runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE_PASSWORD, clientTlsConfiguration.getTruststorePassword());
+        runner.setProperty(sslContextService, StandardSSLContextService.TRUSTSTORE_TYPE, clientTlsConfiguration.getTruststoreType().toString());
+        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE, clientTlsConfiguration.getKeystorePath());
+        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE_PASSWORD, clientTlsConfiguration.getKeystorePassword());
+        runner.setProperty(sslContextService, StandardSSLContextService.KEYSTORE_TYPE, clientTlsConfiguration.getKeystoreType().toString());
 
         runner.setProperty(ListenHTTP.SSL_CONTEXT_SERVICE, SSL_CONTEXT_SERVICE_IDENTIFIER);
         return sslContextService;
@@ -518,11 +540,14 @@ public void testMultipartFormDataRequest() throws Exception {
 
         Runnable sendRequestToWebserver = () -> {
             try {
+                File file1 = createTextFile("my-file-text-", ".txt", "Hello", "World");
+                File file2 = createTextFile("my-file-text-", ".txt", "{ \"name\":\"John\", \"age\":30 }");
+
                 MultipartBody multipartBody = new MultipartBody.Builder().setType(MultipartBody.FORM)
                         .addFormDataPart("p1", "v1")
                         .addFormDataPart("p2", "v2")
-                        .addFormDataPart("file1", "my-file-text.txt", RequestBody.create(MediaType.parse("text/plain"), createTextFile("my-file-text.txt", "Hello", "World")))
-                        .addFormDataPart("file2", "my-file-data.json", RequestBody.create(MediaType.parse("application/json"), createTextFile("my-file-text.txt", "{ \"name\":\"John\", \"age\":30 }")))
+                        .addFormDataPart("file1", "my-file-text.txt", RequestBody.create(MediaType.parse("text/plain"), file1))
+                        .addFormDataPart("file2", "my-file-data.json", RequestBody.create(MediaType.parse("application/json"), file2))
                         .addFormDataPart("file3", "my-file-binary.bin", RequestBody.create(MediaType.parse("application/octet-stream"), generateRandomBinaryData(100)))
                         .build();
 
@@ -539,6 +564,8 @@ public void testMultipartFormDataRequest() throws Exception {
                         .build();
 
                 try (Response response = client.newCall(request).execute()) {
+                    Files.deleteIfExists(Paths.get(String.valueOf(file1)));
+                    Files.deleteIfExists(Paths.get(String.valueOf(file2)));
                     Assert.assertTrue(String.format("Unexpected code: %s, body: %s", response.code(), response.body().string()), response.isSuccessful());
                 }
             } catch (final Throwable t) {
@@ -602,13 +629,12 @@ private byte[] generateRandomBinaryData(int i) {
         return bytes;
     }
 
-    private File createTextFile(String fileName, String... lines) throws IOException {
-        File file = new File("target/" + fileName);
-        file.deleteOnExit();
-        for (String string : lines) {
-            Files.append(string, file, Charsets.UTF_8);
+    private File createTextFile(String prefix, String extension, String... lines) throws IOException {
+        Path file = Files.createTempFile(prefix, extension);
+        try (FileOutputStream fos = new FileOutputStream(file.toFile())) {
+            IOUtils.writeLines(Arrays.asList(lines), System.lineSeparator(), fos, Charsets.UTF_8);
         }
-        return file;
+        return file.toFile();
     }
 
     protected MockFlowFile findFlowFile(List<MockFlowFile> flowFilesForRelationship, String attributeName, String attributeValue) {
diff --git a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/util/TestInvokeHttpCommon.java b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/util/TestInvokeHttpCommon.java
index c11e4f3e696..b3ce6b07872 100644
--- a/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/util/TestInvokeHttpCommon.java
+++ b/nifi-nar-bundles/nifi-standard-bundle/nifi-standard-processors/src/test/java/org/apache/nifi/processors/standard/util/TestInvokeHttpCommon.java
@@ -17,12 +17,6 @@
 
 package org.apache.nifi.processors.standard.util;
 
-import static org.apache.commons.codec.binary.Base64.encodeBase64;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertTrue;
-import static org.junit.Assert.fail;
-
 import java.io.IOException;
 import java.io.PrintWriter;
 import java.io.UnsupportedEncodingException;
@@ -38,7 +32,6 @@
 import javax.servlet.http.HttpServletRequest;
 import javax.servlet.http.HttpServletResponse;
 import javax.servlet.http.Part;
-
 import org.apache.nifi.components.PropertyDescriptor;
 import org.apache.nifi.expression.ExpressionLanguageScope;
 import org.apache.nifi.flowfile.attributes.CoreAttributes;
@@ -63,6 +56,12 @@
 import org.junit.Assert;
 import org.junit.Test;
 
+import static org.apache.commons.codec.binary.Base64.encodeBase64;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertTrue;
+import static org.junit.Assert.fail;
+
 public abstract class TestInvokeHttpCommon {
 
     public static TestServer server;
