diff --git a/clicache/integration-test/ThinClientCqIRTestsN.cs b/clicache/integration-test/ThinClientCqIRTestsN.cs
index b0bb6addef..10657cc958 100644
--- a/clicache/integration-test/ThinClientCqIRTestsN.cs
+++ b/clicache/integration-test/ThinClientCqIRTestsN.cs
@@ -163,11 +163,8 @@ public void StepOneQE(string locators)
       Thread.Sleep(18000); // sleep 0.3min to allow server c query to complete
       Util.Log("Results size {0}.", results.Size);
 
-      SelectResultsIterator<object> iter = results.GetIterator();
-
-      while (iter.HasNext)
+      foreach (var item in results)
       {
-        object item = iter.Next();
         if (item != null)
         {
           Struct st = item as Struct;
diff --git a/clicache/integration-test/ThinClientHARegionTestsN.cs b/clicache/integration-test/ThinClientHARegionTestsN.cs
index 8f17929d69..2751e8cc35 100644
--- a/clicache/integration-test/ThinClientHARegionTestsN.cs
+++ b/clicache/integration-test/ThinClientHARegionTestsN.cs
@@ -687,7 +687,7 @@ public void StepTwoFailover()
           killRes = ksd.BeginInvoke(null, null);
         }
 
-        Int32 resultSize = results.Size;
+        var resultSize = results.Size;
 
         if (i % 100 == 0)
         {
diff --git a/clicache/integration-test/ThinClientQueryTestsN.cs b/clicache/integration-test/ThinClientQueryTestsN.cs
index 4c5eeb916e..dff53112ae 100644
--- a/clicache/integration-test/ThinClientQueryTestsN.cs
+++ b/clicache/integration-test/ThinClientQueryTestsN.cs
@@ -138,7 +138,7 @@ public void StepOneQE(string locators, bool isPdx)
 
       Query<object> qry = qs.NewQuery<object>("select distinct * from /" + QERegionName);
       ISelectResults<object> results = qry.Execute();
-      Int32 count = results.Size;
+      var count = results.Size;
       Assert.AreEqual(4, count, "Expected 4 as number of portfolio objects.");
 
       // Bring down the region
@@ -151,7 +151,7 @@ public void StepTwoQE()
       Util.Log("Going to execute the query");
       Query<object> qry = qs.NewQuery<object>("select distinct * from /" + QERegionName);
       ISelectResults<object> results = qry.Execute();
-      Int32 count = results.Size;
+      var count = results.Size;
       Assert.AreEqual(4, count, "Expected 4 as number of portfolio objects.");
     }
 
@@ -644,7 +644,7 @@ public void StepThreeSS()
         foreach (Struct si in ss)
         {
           rows++;
-          fields = (Int32)si.Length;
+          fields = (Int32)si.Count;
         }
 
         Util.Log("Query index {0} has {1} rows and {2} fields.", qryIdx, rows, fields);
@@ -736,7 +736,7 @@ public void StepThreePQSS()
         foreach (Struct si in ss)
         {
           rows++;
-          fields = (Int32)si.Length;
+          fields = (Int32)si.Count;
         }
 
         Util.Log("Query index {0} has {1} rows and {2} fields.", qryIdx, rows, fields);
@@ -933,7 +933,7 @@ public void StepTwoFailover()
           killRes = ksd.BeginInvoke(null, null);
         }
 
-        Int32 resultSize = results.Size;
+        var resultSize = results.Size;
 
         if (i % 100 == 0)
         {
@@ -972,7 +972,7 @@ public void StepTwoPQFailover()
           killRes = ksd.BeginInvoke(null, null);
         }
 
-        Int32 resultSize = results.Size;
+        var resultSize = results.Size;
 
         if (i % 100 == 0)
         {
@@ -1180,7 +1180,7 @@ public void StepThreeRQ()
 
         ISelectResults<object> results = region.Query<object>(qrystr.Query);
 
-        if (results.Size != QueryStatics.RegionQueryRowCounts[qryIdx])
+        if (results.Size != (ulong) QueryStatics.RegionQueryRowCounts[qryIdx])
         {
           ErrorOccurred = true;
           Util.Log("FAIL: Query # {0} expected result size is {1}, actual is {2}", qryIdx,
diff --git a/clicache/integration-test/ThinClientRegionQueryTests.cs b/clicache/integration-test/ThinClientRegionQueryTests.cs
index 2f1df7796c..e64d26e488 100644
--- a/clicache/integration-test/ThinClientRegionQueryTests.cs
+++ b/clicache/integration-test/ThinClientRegionQueryTests.cs
@@ -182,7 +182,7 @@ public void StepThreeRQ()
 
         ISelectResults<object> results = region.Query<object>(qrystr.Query);
 
-        if (results.Size != QueryStatics.RegionQueryRowCounts[qryIdx])
+        if (results.Size != (ulong) QueryStatics.RegionQueryRowCounts[qryIdx])
         {
           ErrorOccurred = true;
           Util.Log("FAIL: Query # {0} expected result size is {1}, actual is {2}", qryIdx,
diff --git a/clicache/integration-test/ThinClientRemoteParamQueryStructSetTests.cs b/clicache/integration-test/ThinClientRemoteParamQueryStructSetTests.cs
index bb5de3edfa..4618d91b31 100644
--- a/clicache/integration-test/ThinClientRemoteParamQueryStructSetTests.cs
+++ b/clicache/integration-test/ThinClientRemoteParamQueryStructSetTests.cs
@@ -224,7 +224,7 @@ public void StepThreePQSS()
         foreach (Struct si in ss)
         {
           rows++;
-          fields = (Int32)si.Length;
+          fields = (Int32)si.Count;
         }
 
         Util.Log("Query index {0} has {1} rows and {2} fields.", qryIdx, rows, fields);
diff --git a/clicache/integration-test/ThinClientRemoteQueryExclusivenessTests.cs b/clicache/integration-test/ThinClientRemoteQueryExclusivenessTests.cs
index a22e77d296..6476da24bc 100644
--- a/clicache/integration-test/ThinClientRemoteQueryExclusivenessTests.cs
+++ b/clicache/integration-test/ThinClientRemoteQueryExclusivenessTests.cs
@@ -136,7 +136,7 @@ public void StepOneQE(string locators, bool isPdx)
 
       Query<object> qry = qs.NewQuery<object>("select distinct * from /" + QERegionName);
       ISelectResults<object> results = qry.Execute();
-      Int32 count = results.Size;
+      var count = results.Size;
       Assert.AreEqual(4, count, "Expected 4 as number of portfolio objects.");
 
       // Bring down the region
@@ -149,7 +149,7 @@ public void StepTwoQE()
       Util.Log("Going to execute the query");
       Query<object> qry = qs.NewQuery<object>("select distinct * from /" + QERegionName);
       ISelectResults<object> results = qry.Execute();
-      Int32 count = results.Size;
+      var count = results.Size;
       Assert.AreEqual(4, count, "Expected 4 as number of portfolio objects.");
     }
 
diff --git a/clicache/integration-test/ThinClientRemoteQueryFailoverTests.cs b/clicache/integration-test/ThinClientRemoteQueryFailoverTests.cs
index 61b2dd24c6..a40b0692f9 100644
--- a/clicache/integration-test/ThinClientRemoteQueryFailoverTests.cs
+++ b/clicache/integration-test/ThinClientRemoteQueryFailoverTests.cs
@@ -158,7 +158,7 @@ public void StepTwoFailover()
           killRes = ksd.BeginInvoke(null, null);
         }
 
-        Int32 resultSize = results.Size;
+        var resultSize = results.Size;
 
         if (i % 100 == 0)
         {
diff --git a/clicache/integration-test/ThinClientRemoteQueryStructSetTests.cs b/clicache/integration-test/ThinClientRemoteQueryStructSetTests.cs
index 9780e19915..cc4237a267 100644
--- a/clicache/integration-test/ThinClientRemoteQueryStructSetTests.cs
+++ b/clicache/integration-test/ThinClientRemoteQueryStructSetTests.cs
@@ -204,7 +204,7 @@ public void StepThreeSS()
         foreach (Struct si in ss)
         {
           rows++;
-          fields = (Int32)si.Length;
+          fields = (Int32)si.Count;
         }
 
         Util.Log("Query index {0} has {1} rows and {2} fields.", qryIdx, rows, fields);
diff --git a/clicache/integration-test/ThinClientSecurityAuthzTestBaseN.cs b/clicache/integration-test/ThinClientSecurityAuthzTestBaseN.cs
index bee0da721f..406ad50bcc 100644
--- a/clicache/integration-test/ThinClientSecurityAuthzTestBaseN.cs
+++ b/clicache/integration-test/ThinClientSecurityAuthzTestBaseN.cs
@@ -318,8 +318,8 @@ private bool CheckFlags(OpFlags flags, OpFlags checkFlag)
               {
                 Assert.AreEqual(numOps, queryResults.Size);
               }
-              //CacheableHashSet querySet = new CacheableHashSet(queryResults.Size);
-              List<string> querySet = new List<string>(queryResults.Size);
+
+              var querySet = new List<string>((int) queryResults.Size);
               ResultSet<object> rs = queryResults as ResultSet<object>;
               foreach ( object result in  rs)
               {
diff --git a/clicache/integration-test/ThinClientStringArrayTestsN.cs b/clicache/integration-test/ThinClientStringArrayTestsN.cs
index 907c148bd0..da45644f81 100644
--- a/clicache/integration-test/ThinClientStringArrayTestsN.cs
+++ b/clicache/integration-test/ThinClientStringArrayTestsN.cs
@@ -156,11 +156,8 @@ public void StepOneQE(string locators)
       ISelectResults<object> results = qry.Execute();
       Util.Log("Results size {0}.", results.Size);
 
-      SelectResultsIterator<object> iter = results.GetIterator();
-
-      while (iter.HasNext)
+      foreach (var item in results)
       {
-        /*IGeodeSerializable*/ object item = iter.Next();
         Portfolio port = item as Portfolio;
         if (port == null)
         {
diff --git a/clicache/src/ISelectResults.hpp b/clicache/src/ISelectResults.hpp
index d94c21faaf..7ba2010efd 100644
--- a/clicache/src/ISelectResults.hpp
+++ b/clicache/src/ISelectResults.hpp
@@ -43,38 +43,26 @@ namespace Apache
       /// </summary>
       generic<class TResult>
       public interface class ISelectResults
-        : public System::Collections::Generic::IEnumerable</*IGeodeSerializable^*/TResult>
+        : public System::Collections::Generic::IEnumerable<TResult>
       {
       public:
 
-        /// <summary>
-        /// True if this <c>ISelectResults</c> is modifiable.
-        /// </summary>
-        property bool IsModifiable
-        {
-          bool get( );
-        }
-
         /// <summary>
         /// The size of the <c>ISelectResults</c>.
         /// </summary>
-        property System::Int32 Size
+        property size_t Size
         {
-          System::Int32 get( );
+          size_t get( );
         }
 
         /// <summary>
         /// Get an object at the given index.
         /// </summary>
-        property /*Apache::Geode::Client::IGeodeSerializable^*/TResult GFINDEXER( size_t )
+        property TResult GFINDEXER( size_t )
         {
-          /*Apache::Geode::Client::IGeodeSerializable^*/TResult get( size_t index );
+          TResult get( size_t index );
         }
 
-        /// <summary>
-        /// Get an iterator for the result set.
-        /// </summary>
-        Apache::Geode::Client::SelectResultsIterator<TResult>^ GetIterator( );
       };
     }  // namespace Client
   }  // namespace Geode
diff --git a/clicache/src/ResultSet.cpp b/clicache/src/ResultSet.cpp
index e91c9ad60f..ed66bae2ae 100644
--- a/clicache/src/ResultSet.cpp
+++ b/clicache/src/ResultSet.cpp
@@ -32,20 +32,7 @@ namespace Apache
     {
 
       generic<class TResult>
-      bool ResultSet<TResult>::IsModifiable::get( )
-      {
-        try
-        {
-          return m_nativeptr->get()->isModifiable( );
-        }
-        finally
-        {
-          GC::KeepAlive(m_nativeptr);
-        }
-      }
-
-      generic<class TResult>
-      System::Int32 ResultSet<TResult>::Size::get( )
+      size_t ResultSet<TResult>::Size::get( )
       {
         try
         {
@@ -62,21 +49,7 @@ namespace Apache
       {
         try
         {
-          return (TypeRegistry::GetManagedValueGeneric<TResult>(m_nativeptr->get()->operator[](static_cast<System::Int32>(index))));
-        }
-        finally
-        {
-          GC::KeepAlive(m_nativeptr);
-        }
-      }
-
-      generic<class TResult>
-      SelectResultsIterator<TResult>^ ResultSet<TResult>::GetIterator()
-      {
-        try
-        {
-          return SelectResultsIterator<TResult>::Create(std::make_unique<apache::geode::client::SelectResultsIterator>(
-            m_nativeptr->get()->getIterator()));
+          return TypeRegistry::GetManagedValueGeneric<TResult>(m_nativeptr->get()->operator[](index));
         }
         finally
         {
@@ -87,13 +60,13 @@ namespace Apache
       generic<class TResult>
       System::Collections::Generic::IEnumerator<TResult>^ ResultSet<TResult>::GetEnumerator( )
       {
-        return GetIterator( );
+        return SelectResultsIterator<TResult>::Create(this);
       }
 
       generic<class TResult>
       System::Collections::IEnumerator^ ResultSet<TResult>::GetIEnumerator()
       {
-        return GetIterator();
+        return SelectResultsIterator<TResult>::Create(this);
       }
     }  // namespace Client
   }  // namespace Geode
diff --git a/clicache/src/ResultSet.hpp b/clicache/src/ResultSet.hpp
index 1bda218d87..29989d3cee 100644
--- a/clicache/src/ResultSet.hpp
+++ b/clicache/src/ResultSet.hpp
@@ -52,35 +52,22 @@ namespace Apache
       {
       public:
 
-        /// <summary>
-        /// True if this <c>ResultSet</c> is modifiable.
-        /// </summary>
-        virtual property bool IsModifiable
-        {
-          virtual bool get();
-        }
-
         /// <summary>
         /// The size of the <c>ResultSet</c>.
         /// </summary>
-        virtual property System::Int32 Size
+        virtual property size_t Size
         {
-          virtual System::Int32 get();
+          virtual size_t get();
         }
 
         /// <summary>
         /// Get an object at the given index.
         /// </summary>
-        virtual property /*IGeodeSerializable^*/TResult GFINDEXER(size_t)
+        virtual property TResult GFINDEXER(size_t)
         {
-          virtual /*IGeodeSerializable^*/TResult get(size_t index);
+          virtual TResult get(size_t index);
         }
 
-        /// <summary>
-        /// Get an iterator for the result set.
-        /// </summary>
-        virtual SelectResultsIterator<TResult>^ GetIterator();
-
         /// <summary>
         /// Returns an enumerator that iterates through the collection.
         /// </summary>
@@ -88,9 +75,11 @@ namespace Apache
         /// A <c>System.Collections.Generic.IEnumerator</c> that
         /// can be used to iterate through the <c>ResultSet</c>.
         /// </returns>
-        virtual System::Collections::Generic::IEnumerator</*IGeodeSerializable^*/TResult>^
-          GetEnumerator();
+        virtual System::Collections::Generic::IEnumerator<TResult>^ GetEnumerator();
+
 
+        virtual System::Collections::IEnumerator^ GetIEnumerator()
+          = System::Collections::IEnumerable::GetEnumerator;
 
       internal:
 
@@ -111,9 +100,6 @@ namespace Apache
 
       private:
 
-        virtual System::Collections::IEnumerator^ GetIEnumerator() sealed
-          = System::Collections::IEnumerable::GetEnumerator;
-
         /// <summary>
         /// Private constructor to wrap a native object pointer
         /// </summary>
@@ -125,6 +111,7 @@ namespace Apache
 
         native_shared_ptr<native::ResultSet>^ m_nativeptr;
       };
+
     }  // namespace Client
   }  // namespace Geode
 }  // namespace Apache
diff --git a/clicache/src/SelectResultsIterator.cpp b/clicache/src/SelectResultsIterator.cpp
index 9db0f85645..5149e6c040 100644
--- a/clicache/src/SelectResultsIterator.cpp
+++ b/clicache/src/SelectResultsIterator.cpp
@@ -30,67 +30,27 @@ namespace Apache
       generic<class TResult>
       TResult SelectResultsIterator<TResult>::Current::get( )
       {
-        try
-        {
-          return TypeRegistry::GetManagedValueGeneric<TResult>(m_nativeptr->get()->current( ));
-        }
-        finally
-        {
-          GC::KeepAlive(m_nativeptr);
-        }
+        return m_results[m_index];
       }
 
       generic<class TResult>
-      bool SelectResultsIterator<TResult>::MoveNext( )
+      Object^ SelectResultsIterator<TResult>::Current2::get( )
       {
-        try
-        {
-          return m_nativeptr->get()->moveNext( );
-        }
-        finally
-        {
-          GC::KeepAlive(m_nativeptr);
-        }
+        return m_results[m_index];
       }
 
       generic<class TResult>
-      void SelectResultsIterator<TResult>::Reset( )
+      bool SelectResultsIterator<TResult>::MoveNext( )
       {
-        try
-        {
-          m_nativeptr->get()->reset( );
-        }
-        finally
-        {
-          GC::KeepAlive(m_nativeptr);
-        }
+         return ++m_index < m_results->Size;
       }
 
       generic<class TResult>
-      TResult SelectResultsIterator<TResult>::Next( )
+      void SelectResultsIterator<TResult>::Reset( )
       {
-        try
-        {
-          return TypeRegistry::GetManagedValueGeneric<TResult>(m_nativeptr->get()->next( ));
-        }
-        finally
-        {
-          GC::KeepAlive(m_nativeptr);
-        }
+        m_index = -1;
       }
 
-      generic<class TResult>
-      bool SelectResultsIterator<TResult>::HasNext::get()
-      {
-        try
-        {
-          return m_nativeptr->get()->hasNext();
-        }
-        finally
-        {
-          GC::KeepAlive(m_nativeptr);
-        }
-      }
     }  // namespace Client
   }  // namespace Geode
 }  // namespace Apache
diff --git a/clicache/src/SelectResultsIterator.hpp b/clicache/src/SelectResultsIterator.hpp
index b33e6b3448..b4fd6446c9 100644
--- a/clicache/src/SelectResultsIterator.hpp
+++ b/clicache/src/SelectResultsIterator.hpp
@@ -17,14 +17,7 @@
 
 #pragma once
 
-
-#include "geode_defs.hpp"
-#include "begin_native.hpp"
-#include <geode/SelectResultsIterator.hpp>
-#include "end_native.hpp"
-
-#include "native_unique_ptr.hpp"
-
+#include "ISelectResults.hpp"
 
 using namespace System;
 
@@ -34,8 +27,6 @@ namespace Apache
   {
     namespace Client
     {
-      namespace native = apache::geode::client;
-
       interface class IGeodeSerializable;
 
       /// <summary>
@@ -43,7 +34,7 @@ namespace Apache
       /// </summary>
       generic<class TResult>
       public ref class SelectResultsIterator sealed
-        : public System::Collections::Generic::IEnumerator</*Apache::Geode::Client::IGeodeSerializable^*/TResult>
+        : public System::Collections::Generic::IEnumerator<TResult>
       {
       public:
 
@@ -55,9 +46,14 @@ namespace Apache
         /// The element in the collection at the current position
         /// of the enumerator.
         /// </returns>
-        virtual property /*Apache::Geode::Client::IGeodeSerializable^*/TResult Current
+        property TResult Current
         {
-          virtual /*Apache::Geode::Client::IGeodeSerializable^*/TResult get( );
+          virtual TResult get( );
+        }
+
+        property Object^ Current2
+        {
+          virtual Object^ get( ) = System::Collections::IEnumerator::Current::get;
         }
 
         /// <summary>
@@ -76,19 +72,6 @@ namespace Apache
         /// </summary>
         virtual void Reset( );
 
-        /// <summary>
-        /// Get the current element and move to the next one.
-        /// </summary>
-        /*Apache::Geode::Client::IGeodeSerializable^*/TResult Next( );
-
-        /// <summary>
-        /// Check if there is a next element.
-        /// </summary>
-        property bool HasNext
-        {
-          bool get( );
-        }
-
         ~SelectResultsIterator() {};
 
       internal:
@@ -101,36 +84,26 @@ namespace Apache
         /// <returns>
         /// The managed wrapper object; null if the native pointer is null.
         /// </returns>
-        inline static Apache::Geode::Client::SelectResultsIterator<TResult>^ Create(
-          std::unique_ptr<native::SelectResultsIterator> nativeptr )
+        inline static SelectResultsIterator<TResult>^ Create(
+          ISelectResults<TResult>^ results )
         {
-          return ( nativeptr != nullptr ?
-            gcnew Apache::Geode::Client::SelectResultsIterator<TResult>( std::move(nativeptr) ) : nullptr );
+          return results == nullptr ? nullptr :
+            gcnew SelectResultsIterator<TResult>(results);
         }
 
 
       private:
 
-        virtual property Object^ ICurrent
-        {
-          virtual Object^ get( ) sealed
-            = System::Collections::IEnumerator::Current::get
-          {
-            return Current;
-          }
-        }
-
         /// <summary>
         /// Private constructor to wrap a native object pointer
         /// </summary>
         /// <param name="nativeptr">The native object pointer</param>
-        inline SelectResultsIterator(
-        std::unique_ptr<native::SelectResultsIterator> nativeptr )
+        inline SelectResultsIterator(ISelectResults<TResult>^ results) : m_results(results)
         {
-          m_nativeptr = gcnew native_unique_ptr<native::SelectResultsIterator>(std::move(nativeptr));
         }
 
-        native_unique_ptr<native::SelectResultsIterator>^ m_nativeptr;
+        ISelectResults<TResult>^ m_results;
+        int m_index = -1;
       };
     }  // namespace Client
   }  // namespace Geode
diff --git a/clicache/src/Struct.cpp b/clicache/src/Struct.cpp
index 433941245a..018191a1c7 100644
--- a/clicache/src/Struct.cpp
+++ b/clicache/src/Struct.cpp
@@ -36,12 +36,12 @@ namespace Apache
     {
       namespace native = apache::geode::client;
 
-      Object^ Struct::default::get(size_t index)
+      Object^ Struct::default::get(int32_t index)
       {
         try
         {
           return (TypeRegistry::GetManagedValueGeneric<Object^>(
-            static_cast<native::Struct*>(m_nativeptr->get())->operator[](static_cast<System::Int32>(index))));
+            static_cast<native::Struct*>(m_nativeptr->get())->operator[](index)));
         }
         finally
         {
@@ -66,7 +66,7 @@ namespace Apache
       {
         try
         {
-          return StructSet</*TResult*/Object^>::Create(
+          return StructSet<Object^>::Create(
             static_cast<native::Struct*>(m_nativeptr->get())->getStructSet());
         }
         finally
@@ -76,36 +76,11 @@ namespace Apache
       }
 
 
-      bool Struct/*<TResult>*/::HasNext()
+      int32_t Struct::Count::get()
       {
         try
         {
-          return static_cast<native::Struct*>(m_nativeptr->get())->hasNext();
-        }
-        finally
-        {
-          GC::KeepAlive(m_nativeptr);
-        }
-      }
-
-      size_t Struct/*<TResult>*/::Length::get()
-      {
-        try
-        {
-          return static_cast<native::Struct*>(m_nativeptr->get())->length();
-        }
-        finally
-        {
-          GC::KeepAlive(m_nativeptr);
-        }
-      }
-
-      Object^ Struct/*<TResult>*/::Next()
-      {
-        try
-        {
-          return (TypeRegistry::GetManagedValueGeneric<Object^>(
-            static_cast<native::Struct*>(m_nativeptr->get())->next()));
+          return static_cast<native::Struct*>(m_nativeptr->get())->size();
         }
         finally
         {
diff --git a/clicache/src/Struct.hpp b/clicache/src/Struct.hpp
index 4c016efebe..a6932e98f0 100644
--- a/clicache/src/Struct.hpp
+++ b/clicache/src/Struct.hpp
@@ -46,7 +46,6 @@ namespace Apache
       /// returned after executing a Query obtained from a QueryService which in turn
       /// is obtained from a Cache.
       /// </remarks>
-      //generic<class TResult>
       public ref class Struct sealed
         : public Apache::Geode::Client::Serializable
       {
@@ -58,9 +57,9 @@ namespace Apache
         /// <returns>
         /// The value of the field or null if index is out of bounds.
         /// </returns>
-        property /*Apache::Geode::Client::IGeodeSerializable^*//*TResult*/ Object^ GFINDEXER( size_t )
+        property Object^ GFINDEXER( int32_t )
         {
-          /*Apache::Geode::Client::IGeodeSerializable^*/ /*TResult*/ Object^ get( size_t index );
+          Object^ get( int32_t index );
         }
 
         /// <summary>
@@ -70,9 +69,9 @@ namespace Apache
         /// <exception cref="IllegalArgumentException">
         /// if the field name is not found.
         /// </exception>
-        property /*Apache::Geode::Client::IGeodeSerializable^*//*TResult*/Object^ GFINDEXER( String^ )
+        property Object^ GFINDEXER( String^ )
         {
-          /*Apache::Geode::Client::IGeodeSerializable^*//*TResult*/Object^ get( String^ fieldName );
+          Object^ get( String^ fieldName );
         }
 
         /// <summary>
@@ -81,37 +80,20 @@ namespace Apache
         /// <returns>
         /// A reference to the parent <c>StructSet</c> of this <c>Struct</c>.
         /// </returns>
-        property Apache::Geode::Client::StructSet</*TResult*/Object^>^ Set
+        property Apache::Geode::Client::StructSet<Object^>^ Set
         {
-          Apache::Geode::Client::StructSet</*TResult*/Object^>^ get( );
+          Apache::Geode::Client::StructSet<Object^>^ get( );
         }
 
-        /// <summary>
-        /// Check whether another field value is available to iterate over
-        /// in this <c>Struct</c>.
-        /// </summary>
-        /// <returns>true if available otherwise false.</returns>
-        bool HasNext( );
-
         /// <summary>
         /// Get the number of field values available.
         /// </summary>
         /// <returns>the number of field values available.</returns>
-        property size_t Length
+        property int32_t Count
         {
-          size_t get( );
+          int32_t get( );
         }
 
-        /// <summary>
-        /// Get the next field value item available in this <c>Struct</c>.
-        /// </summary>
-        /// <returns>
-        /// A reference to the next item in the <c>Struct</c>
-        /// or null if no more available.
-        /// </returns>
-        /*Apache::Geode::Client::IGeodeSerializable^*//*TResult*/Object^ Next( );
-
-
       private:
 
         /// <summary>
@@ -129,21 +111,19 @@ namespace Apache
         /// <summary>
         /// Factory function to register wrapper
         /// </summary>
-        inline static Apache::Geode::Client::IGeodeSerializable^ /*Struct^*/ /*<TResult>*/ Create( ::std::shared_ptr<apache::geode::client::Serializable> obj )
+        inline static Apache::Geode::Client::IGeodeSerializable^ Create( ::std::shared_ptr<apache::geode::client::Serializable> obj )
         {
           return ( obj != nullptr ?
-            gcnew Apache::Geode::Client::Struct/*<TResult>*/( obj ) : nullptr );
-          /*return ( obj != nullptr ?
-            gcnew Struct( obj ) : nullptr );*/
+            gcnew Apache::Geode::Client::Struct( obj ) : nullptr );
         }
 
         inline static Apache::Geode::Client::IGeodeSerializable^ CreateDeserializable( )
         {
-          return gcnew Apache::Geode::Client::Struct/*<TResult>*/(  ) ;
-          //return gcnew Struct(  ) ;
+          return gcnew Apache::Geode::Client::Struct(  ) ;
         }
       };
+
     }  // namespace Client
   }  // namespace Geode
 }  // namespace Apache
- //namespace 
+
diff --git a/clicache/src/StructSet.cpp b/clicache/src/StructSet.cpp
index 769e3e5f93..185b36b2e8 100644
--- a/clicache/src/StructSet.cpp
+++ b/clicache/src/StructSet.cpp
@@ -32,24 +32,11 @@ namespace Apache
     {
 
       generic<class TResult>
-      bool StructSet<TResult>::IsModifiable::get( )
+      size_t StructSet<TResult>::Size::get( )
       {
         try
         {
-          return m_nativeptr->get()->isModifiable( );
-        }
-        finally
-        {
-          GC::KeepAlive(m_nativeptr);
-        }
-      }
-
-      generic<class TResult>
-      System::Int32 StructSet<TResult>::Size::get( )
-      {
-        try
-        {
-          return static_cast<int>(m_nativeptr->get()->size( ));
+          return m_nativeptr->get()->size( );
         }
         finally
         {
@@ -62,20 +49,7 @@ namespace Apache
       {
         try
         {
-          return TypeRegistry::GetManagedValueGeneric<TResult>((m_nativeptr->get()->operator[](static_cast<System::Int32>(index))));
-        }
-        finally
-        {
-          GC::KeepAlive(m_nativeptr);
-        }
-      }
-
-      generic<class TResult>
-      SelectResultsIterator<TResult>^ StructSet<TResult>::GetIterator( )
-      {
-        try
-        {
-          return SelectResultsIterator<TResult>::Create(std::make_unique<apache::geode::client::SelectResultsIterator>(m_nativeptr->get()->getIterator()));
+          return TypeRegistry::GetManagedValueGeneric<TResult>(m_nativeptr->get()->operator[](index));
         }
         finally
         {
@@ -86,17 +60,17 @@ namespace Apache
       generic<class TResult>
       System::Collections::Generic::IEnumerator<TResult>^ StructSet<TResult>::GetEnumerator( )
       {
-        return GetIterator( );
+        return SelectResultsIterator<TResult>::Create(this);
       }
 
       generic<class TResult>
       System::Collections::IEnumerator^ StructSet<TResult>::GetIEnumerator( )
       {
-        return GetIterator( );
+        return SelectResultsIterator<TResult>::Create(this);
       }
 
       generic<class TResult>
-      size_t StructSet<TResult>::GetFieldIndex( String^ fieldName )
+      int32_t StructSet<TResult>::GetFieldIndex( String^ fieldName )
       {
         _GF_MG_EXCEPTION_TRY2/* due to auto replace */
 
@@ -113,11 +87,11 @@ namespace Apache
       }
 
       generic<class TResult>
-      String^ StructSet<TResult>::GetFieldName(size_t index)
+      String^ StructSet<TResult>::GetFieldName(int32_t index)
       {
         try
         {
-          return marshal_as<String^>(m_nativeptr->get()->getFieldName(static_cast<System::Int32> (index)));
+          return marshal_as<String^>(m_nativeptr->get()->getFieldName(index));
         }
         finally
         {
diff --git a/clicache/src/StructSet.hpp b/clicache/src/StructSet.hpp
index cbc586ab25..4fa1126e33 100644
--- a/clicache/src/StructSet.hpp
+++ b/clicache/src/StructSet.hpp
@@ -51,24 +51,15 @@ namespace Apache
       {
       public:
 
-        /// <summary>
-        /// True if this <c>StructSet</c> is modifiable.
-        /// </summary>
-        /// <returns>returns false always at this time.</returns>
-        virtual property bool IsModifiable
-        {
-          virtual bool get( );
-        }
-
         /// <summary>
         /// The size of the <c>StructSet</c>.
         /// </summary>
         /// <returns>
         /// the number of items in the <c>StructSet</c>.
         /// </returns>
-        virtual property System::Int32 Size
+        virtual property size_t Size
         {
-          virtual System::Int32 get( );
+          virtual size_t get( );
         }
 
         /// <summary>
@@ -78,20 +69,11 @@ namespace Apache
         /// if the index is out of bounds.
         /// </exception>
         /// <returns>Item at the given index.</returns>
-        virtual property /*Apache::Geode::Client::IGeodeSerializable^*/TResult GFINDEXER( size_t )
+        virtual property TResult GFINDEXER( size_t )
         {
-          virtual /*Apache::Geode::Client::IGeodeSerializable^*/TResult get( size_t index );
+          virtual TResult get( size_t index );
         }
 
-        /// <summary>
-        /// Get a <c>SelectResultsIterator</c> with which to iterate
-        /// over the items in the <c>StructSet</c>.
-        /// </summary>
-        /// <returns>
-        /// The <c>SelectResultsIterator</c> with which to iterate.
-        /// </returns>
-        virtual SelectResultsIterator<TResult>^ GetIterator( );
-
         /// <summary>
         /// Get the index number of the specified field name
         /// in the <c>StructSet</c>.
@@ -103,7 +85,7 @@ namespace Apache
         /// <exception cref="IllegalArgumentException">
         /// if the field name is not found.
         /// </exception>
-        size_t GetFieldIndex( String^ fieldName );
+        int32_t GetFieldIndex( String^ fieldName );
 
         /// <summary>
         /// Get the field name of the <c>StructSet</c> from the
@@ -115,7 +97,7 @@ namespace Apache
         /// <returns>
         /// the field name from the specified index number or null if not found.
         /// </returns>
-        String^ GetFieldName( size_t index );
+        String^ GetFieldName( int32_t index );
 
 
         // Region: IEnumerable<IGeodeSerializable^> Members
@@ -127,7 +109,7 @@ namespace Apache
         /// A <c>System.Collections.Generic.IEnumerator</c> that
         /// can be used to iterate through the <c>StructSet</c>.
         /// </returns>
-        virtual System::Collections::Generic::IEnumerator</*Apache::Geode::Client::IGeodeSerializable^*/TResult>^
+        virtual System::Collections::Generic::IEnumerator<TResult>^
           GetEnumerator( );
 
         // End Region: IEnumerable<IGeodeSerializable^> Members
@@ -166,7 +148,8 @@ namespace Apache
 
         native_shared_ptr<native::StructSet>^ m_nativeptr; 
       };
+
     }  // namespace Client
   }  // namespace Geode
 }  // namespace Apache
- //namespace 
+
diff --git a/cppcache/CMakeLists.txt b/cppcache/CMakeLists.txt
index 67e11d3653..d814aa354a 100644
--- a/cppcache/CMakeLists.txt
+++ b/cppcache/CMakeLists.txt
@@ -115,5 +115,6 @@ install(FILES
 add_subdirectory(shared)
 add_subdirectory(static)
 add_subdirectory(test)
+add_subdirectory(internal)
 add_subdirectory(integration-test)
 add_subdirectory(integration-test-2)
diff --git a/cppcache/include/geode/CacheableString.hpp b/cppcache/include/geode/CacheableString.hpp
index 3e4b508e94..8caa0bea4f 100644
--- a/cppcache/include/geode/CacheableString.hpp
+++ b/cppcache/include/geode/CacheableString.hpp
@@ -166,6 +166,48 @@ class APACHE_GEODE_EXPORT CacheableString : public CacheableKey {
   static bool isAscii(const std::string& str);
 };
 
+template <>
+inline std::shared_ptr<CacheableKey> CacheableKey::create(std::string value) {
+  return CacheableString::create(value);
+}
+
+template <>
+inline std::shared_ptr<CacheableKey> CacheableKey::create(
+    std::u16string value) {
+  return CacheableString::create(value);
+}
+
+template <>
+inline std::shared_ptr<CacheableKey> CacheableKey::create(
+    std::u32string value) {
+  return CacheableString::create(value);
+}
+
+template <>
+inline std::shared_ptr<CacheableKey> CacheableKey::create(std::wstring value) {
+  return CacheableString::create(value);
+}
+
+template <>
+inline std::shared_ptr<Cacheable> Serializable::create(std::string value) {
+  return CacheableString::create(value);
+}
+
+template <>
+inline std::shared_ptr<Cacheable> Serializable::create(std::u16string value) {
+  return CacheableString::create(value);
+}
+
+template <>
+inline std::shared_ptr<Cacheable> Serializable::create(std::u32string value) {
+  return CacheableString::create(value);
+}
+
+template <>
+inline std::shared_ptr<Cacheable> Serializable::create(std::wstring value) {
+  return CacheableString::create(value);
+}
+
 template <>
 inline std::shared_ptr<CacheableKey> CacheableKey::create(const char* value) {
   return CacheableString::create(value);
diff --git a/cppcache/include/geode/ResultSet.hpp b/cppcache/include/geode/ResultSet.hpp
index 47f3644f91..a43661d750 100644
--- a/cppcache/include/geode/ResultSet.hpp
+++ b/cppcache/include/geode/ResultSet.hpp
@@ -21,13 +21,7 @@
 #define GEODE_RESULTSET_H_
 
 #include "internal/geode_globals.hpp"
-#include "ExceptionTypes.hpp"
 #include "SelectResults.hpp"
-#include "SelectResultsIterator.hpp"
-
-/**
- * @file
- */
 
 namespace apache {
 namespace geode {
@@ -40,43 +34,9 @@ namespace client {
  */
 class APACHE_GEODE_EXPORT ResultSet : public SelectResults {
  public:
-  /**
-   * Check whether the ResultSet is modifiable.
-   *
-   * @returns false always at this time.
-   */
-  virtual bool isModifiable() const override = 0;
-
-  /**
-   * Get the size of the ResultSet.
-   *
-   * @returns the number of items in the ResultSet.
-   */
-  virtual size_t size() const override = 0;
-
-  /**
-   * Index operator to directly access an item in the ResultSet.
-   *
-   * @param index the index number of the required item.
-   * @throws IllegalArgumentException if the index is out of bounds.
-   * @returns A smart pointer to the item indexed.
-   */
-  virtual const std::shared_ptr<Serializable> operator[](
-      size_t index) const override = 0;
-
-  /**
-   * Get a SelectResultsIterator with which to iterate over the items in the
-   * ResultSet.
-   *
-   * @returns The SelectResultsIterator with which to iterate.
-   */
-  virtual SelectResultsIterator getIterator() override = 0;
-
-  /**
-   * Destructor
-   */
-  ~ResultSet() override = default;
+  ~ResultSet() noexcept override = default;
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/include/geode/SelectResults.hpp b/cppcache/include/geode/SelectResults.hpp
index 7dbec5bb7a..0d5a540652 100644
--- a/cppcache/include/geode/SelectResults.hpp
+++ b/cppcache/include/geode/SelectResults.hpp
@@ -43,14 +43,7 @@ class SelectResultsIterator;
  */
 class APACHE_GEODE_EXPORT SelectResults {
  public:
-  virtual ~SelectResults() = default;
-
-  /**
-   * Check whether the SelectResults is modifiable.
-   *
-   * @returns false always at this time.
-   */
-  virtual bool isModifiable() const = 0;
+  virtual ~SelectResults() noexcept = default;
 
   /**
    * Get the size of the SelectResults.
@@ -70,21 +63,19 @@ class APACHE_GEODE_EXPORT SelectResults {
       size_t index) const = 0;
 
   /**
-   * Get a SelectResultsIterator with which to iterate over the items in the
-   * SelectResults.
-   *
-   * @returns The SelectResultsIterator with which to iterate.
+   * Interface of an iterator for <code>SelectResults</code>.
    */
-  virtual SelectResultsIterator getIterator() = 0;
+  typedef std::vector<std::shared_ptr<Cacheable>>::iterator iterator;
 
-  /** Interface of an iterator for <code>SelectResults</code>.*/
-  typedef CacheableVector::iterator Iterator;
-
-  /** Get an iterator pointing to the start of vector. */
-  virtual Iterator begin() const = 0;
+  /**
+   * Get an iterator pointing to the start of <code>SelectResults</code>.
+   */
+  virtual iterator begin() = 0;
 
-  /** Get an iterator pointing to the end of vector. */
-  virtual Iterator end() const = 0;
+  /**
+   * Get an iterator pointing to the end of <code>SelectResults</code>.
+   */
+  virtual iterator end() = 0;
 };
 }  // namespace client
 }  // namespace geode
diff --git a/cppcache/include/geode/SelectResultsIterator.hpp b/cppcache/include/geode/SelectResultsIterator.hpp
deleted file mode 100644
index df655562dc..0000000000
--- a/cppcache/include/geode/SelectResultsIterator.hpp
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#pragma once
-
-#ifndef GEODE_SELECTRESULTSITERATOR_H_
-#define GEODE_SELECTRESULTSITERATOR_H_
-
-/**
- * @file
- */
-
-
-#include <memory>
-
-#include "CacheableBuiltins.hpp"
-#include "ExceptionTypes.hpp"
-#include "SelectResults.hpp"
-#include "Serializable.hpp"
-#include "internal/geode_base.hpp"
-#include "internal/geode_globals.hpp"
-
-namespace apache {
-namespace geode {
-namespace client {
-
-class ResultSetImpl;
-class StructSetImpl;
-class CacheableVector;
-class SelectResults;
-class Serializable;
-
-/**
- * @class SelectResultsIterator SelectResultsIterator.hpp
- * A SelectResultsIterator is obtained from a ResultSet or StructSet and
- * is used to iterate over the items available in them.
- */
-class APACHE_GEODE_EXPORT SelectResultsIterator {
- public:
-  /**
-   * Check whether the SelectResultsIterator has another item to get.
-   *
-   * @returns true if another item is available otherwise false.
-   */
-  bool hasNext() const;
-
-  /**
-   * Get the next item from the SelectResultsIterator.
-   *
-   * @returns a smart pointer to the next item from the iterator or nullptr if
-   * no further items are available.
-   */
-  const std::shared_ptr<Serializable> next();
-
-  /**
-   * Move the iterator to point to the next item to get.
-   *
-   * @returns true if another item was available to move to otherwise false.
-   */
-  bool moveNext();
-
-  /**
-   * Get the current item pointed to by the SelectResultsIterator.
-   *
-   * @returns A smart pointer to the current item pointed to by the
-   * SelectResultsIterator.
-   */
-  const std::shared_ptr<Serializable> current() const;
-
-  /**
-   * Reset the SelectResultsIterator to point to the start of the items.
-   */
-  void reset();
-
- private:
-  /**
-   * Constructor - meant only for internal use.
-   */
-  SelectResultsIterator(const std::shared_ptr<CacheableVector>& vectorSR,
-                        std::shared_ptr<SelectResults> srp);
-
-  std::shared_ptr<CacheableVector> m_vectorSR;
-  size_t m_nextIndex;
-  // this is to ensure that a reference of SelectResults is kept alive
-  // if an iterator object is present
-  std::shared_ptr<SelectResults> m_srp;
-
-  friend class ResultSetImpl;
-  friend class StructSetImpl;
-};
-}  // namespace client
-}  // namespace geode
-}  // namespace apache
-
-#endif  // GEODE_SELECTRESULTSITERATOR_H_
diff --git a/cppcache/include/geode/Struct.hpp b/cppcache/include/geode/Struct.hpp
index 30ed55a534..8a3c4b3963 100644
--- a/cppcache/include/geode/Struct.hpp
+++ b/cppcache/include/geode/Struct.hpp
@@ -47,12 +47,16 @@ class StructSet;
  */
 class APACHE_GEODE_EXPORT Struct : public Serializable {
  public:
+  typedef std::vector<std::shared_ptr<Serializable>>::iterator iterator;
+
   /**
    * Constructor - meant only for internal use.
    */
   Struct(StructSet* ssPtr,
          std::vector<std::shared_ptr<Serializable>>& fieldValues);
 
+  ~Struct() = default;
+
   /**
    * Factory function for registration of <code>Struct</code>.
    */
@@ -84,28 +88,16 @@ class APACHE_GEODE_EXPORT Struct : public Serializable {
    */
   const std::shared_ptr<StructSet> getStructSet() const;
 
-  /**
-   * Check whether another field value is available to iterate over in this
-   * Struct.
-   *
-   * @returns true if available otherwise false.
-   */
-  bool hasNext() const;
+  iterator begin();
+
+  iterator end();
 
   /**
    * Get the number of field values available.
    *
    * @returns the number of field values available.
    */
-  int32_t length() const;
-
-  /**
-   * Get the next field value item available in this Struct.
-   *
-   * @returns A smart pointer to the next item in the Struct or nullptr if no
-   * more available.
-   */
-  const std::shared_ptr<Serializable> next();
+  int32_t size() const;
 
   /**
    * Deserializes the Struct object from the DataInput. @TODO KN: better comment
@@ -148,17 +140,15 @@ class APACHE_GEODE_EXPORT Struct : public Serializable {
   }
 
  private:
+  Struct() = default;
+
   void skipClassName(DataInput& input);
 
-  Struct();
+  typedef std::unordered_map<std::string, int32_t> FieldNameToIndexMap;
 
-  typedef std::unordered_map<std::string, int32_t> FieldNames;
-  FieldNames m_fieldNames;
+  StructSet* m_parent = nullptr;
   std::vector<std::shared_ptr<Serializable>> m_fieldValues;
-
-  StructSet* m_parent;
-
-  size_t m_lastAccessIndex;
+  FieldNameToIndexMap m_fieldNameToIndex;
 
   _GEODE_FRIEND_STD_SHARED_PTR(Struct)
 };
diff --git a/cppcache/include/geode/StructSet.hpp b/cppcache/include/geode/StructSet.hpp
index 5ba895842b..300bba14bd 100644
--- a/cppcache/include/geode/StructSet.hpp
+++ b/cppcache/include/geode/StructSet.hpp
@@ -23,7 +23,6 @@
 #include "internal/geode_globals.hpp"
 #include "CqResults.hpp"
 #include "Struct.hpp"
-#include "SelectResultsIterator.hpp"
 
 /**
  * @file
@@ -42,29 +41,7 @@ namespace client {
  */
 class APACHE_GEODE_EXPORT StructSet : public CqResults {
  public:
-  /**
-   * Check whether the StructSet is modifiable.
-   *
-   * @returns false always at this time.
-   */
-  virtual bool isModifiable() const = 0;
-
-  /**
-   * Get the size of the StructSet.
-   *
-   * @returns the number of items in the StructSet.
-   */
-  virtual size_t size() const = 0;
-
-  /**
-   * Index operator to directly access an item in the StructSet.
-   *
-   * @param index the index number of the item to get.
-   * @throws IllegalArgumentException if the index is out of bounds.
-   * @returns A smart pointer to the item indexed.
-   */
-  virtual const std::shared_ptr<Serializable> operator[](
-      size_t index) const = 0;
+  ~StructSet() noexcept override = default;
 
   /**
    * Get the index number of the specified field name in the StructSet.
@@ -73,7 +50,7 @@ class APACHE_GEODE_EXPORT StructSet : public CqResults {
    * @returns the index number of the specified field name.
    * @throws std::invalid_argument if the field name is not found.
    */
-  virtual size_t getFieldIndex(const std::string& fieldname) = 0;
+  virtual int32_t getFieldIndex(const std::string& fieldname) = 0;
 
   /**
    * Get the field name of the StructSet from the specified index number.
@@ -84,20 +61,8 @@ class APACHE_GEODE_EXPORT StructSet : public CqResults {
    * @throws std::out_of_range if index is not found
    */
   virtual const std::string& getFieldName(int32_t index) = 0;
-
-  /**
-   * Get a SelectResultsIterator with which to iterate over the items in the
-   * StructSet.
-   *
-   * @returns The SelectResultsIterator with which to iterate.
-   */
-  virtual SelectResultsIterator getIterator() = 0;
-
-  /**
-   * Destructor
-   */
-  virtual ~StructSet() = default;
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/integration-test-2/CMakeLists.txt b/cppcache/integration-test-2/CMakeLists.txt
index 8c5ea161df..93cd76ef75 100644
--- a/cppcache/integration-test-2/CMakeLists.txt
+++ b/cppcache/integration-test-2/CMakeLists.txt
@@ -27,7 +27,7 @@ add_executable(integration-test-2
   framework/GfshExecute.h
   RegionPutGetAllTest.cpp
   PdxInstanceTest.cpp
-  )
+  StructTest.cpp)
 
 target_compile_definitions(integration-test-2
   PUBLIC
@@ -49,8 +49,10 @@ target_link_libraries(integration-test-2
     Boost::boost
     Boost::system
     Boost::log
+    Boost::filesystem
   PRIVATE
     _WarningsAsError
+    internal
 )
 
 if(WIN32)
diff --git a/cppcache/integration-test-2/StructTest.cpp b/cppcache/integration-test-2/StructTest.cpp
new file mode 100644
index 0000000000..35a5f64568
--- /dev/null
+++ b/cppcache/integration-test-2/StructTest.cpp
@@ -0,0 +1,101 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <unordered_map>
+
+#include <gtest/gtest.h>
+
+#include <geode/Cache.hpp>
+#include <geode/PoolManager.hpp>
+#include <geode/RegionFactory.hpp>
+#include <geode/RegionShortcut.hpp>
+#include <geode/Struct.hpp>
+#include <geode/QueryService.hpp>
+
+#include <hacks/range.h>
+
+#include "framework/Framework.h"
+#include "framework/Gfsh.h"
+#include "framework/Cluster.h"
+
+namespace {
+
+using namespace apache::geode::client;
+
+std::shared_ptr<Region> setupRegion(Cache& cache) {
+  auto region = cache.createRegionFactory(RegionShortcut::PROXY)
+                    .setPoolName("default")
+                    .create("region");
+
+  return region;
+}
+
+/**
+ * Example test using 2 servers and waiting for async tasks to synchronize using
+ * furtures.
+ */
+TEST(StructTest, queryResultForRange) {
+  Cluster cluster{LocatorCount{1}, ServerCount{1}};
+  cluster.getGfsh()
+      .create()
+      .region()
+      .withName("region")
+      .withType("REPLICATE")
+      .execute();
+
+  auto cache = cluster.createCache();
+  auto region = setupRegion(cache);
+
+  std::unordered_map<int, std::string> values = {
+      {1, "one"}, {2, "two"}, {3, "three"}};
+
+
+  for (auto&& value : values) {
+    region->put(value.first, value.second);
+  }
+
+  auto&& queryResult =
+      cache.getQueryService()
+          ->newQuery("SELECT e.key, e.value FROM /region.entries e")
+          ->execute();
+  EXPECT_EQ(3, queryResult->size());
+
+  for (auto&& row : hacks::range(*queryResult)) {
+    auto rowStruct = std::dynamic_pointer_cast<Struct>(row);
+    ASSERT_NE(nullptr, rowStruct);
+    EXPECT_EQ(2, rowStruct->size());
+
+    auto key = -1;
+    for (auto&& column : *rowStruct) {
+      // Expect to read: key:int, value:string
+      if (auto columnValue =
+              std::dynamic_pointer_cast<CacheableInt32>(column)) {
+        key = columnValue->value();
+        EXPECT_NE(values.end(), values.find(key));
+      } else if (auto columnValue =
+                     std::dynamic_pointer_cast<CacheableString>(column)) {
+        auto value = columnValue->value();
+        EXPECT_EQ(values.find(key)->second, value);
+      } else {
+        FAIL() << "Column is not int or string.";
+      }
+    }
+  }
+}
+
+}  // namespace
diff --git a/cppcache/integration-test-2/framework/Cluster.cpp b/cppcache/integration-test-2/framework/Cluster.cpp
index 164f38f40c..d7fbd4cc67 100644
--- a/cppcache/integration-test-2/framework/Cluster.cpp
+++ b/cppcache/integration-test-2/framework/Cluster.cpp
@@ -19,12 +19,20 @@
 
 #include <future>
 
+#include <signal.h>
+
+#include <boost/filesystem.hpp>
+
 void Locator::start() {
   if (started_) return;
 
   auto safeName = name_;
   std::replace(safeName.begin(), safeName.end(), '/', '_');
 
+  if (boost::filesystem::is_regular_file(name_ + "/vf.gf.locator.pid")) {
+    cluster_.getGfsh().stop().locator().withDir(name_).execute();
+  }
+
   cluster_.getGfsh()
       .start()
       .locator()
diff --git a/cppcache/integration-test/CMakeLists.txt b/cppcache/integration-test/CMakeLists.txt
index e6477fe12e..91fb905812 100644
--- a/cppcache/integration-test/CMakeLists.txt
+++ b/cppcache/integration-test/CMakeLists.txt
@@ -25,7 +25,7 @@ add_library(${TEST_UTILS_LIB} STATIC
 target_link_libraries(${TEST_UTILS_LIB}
   PRIVATE
     ACE
-	_WarningsAsError
+	  _WarningsAsError
   PUBLIC
     apache-geode
     fwk
@@ -43,7 +43,7 @@ add_library(unit_test_callbacks SHARED LibraryCallbacks.cpp)
 target_link_libraries(unit_test_callbacks
   PRIVATE
     ACE
-	_WarningsAsError
+	  _WarningsAsError
   PUBLIC
     apache-geode
 )
@@ -85,7 +85,8 @@ foreach(FILE ${SOURCES})
     PRIVATE
       ACE
       ${TEST_UTILS_LIB}
-	_WarningsAsError
+	    _WarningsAsError
+      internal
     PUBLIC
       apache-geode
       testobject
diff --git a/cppcache/integration-test/CacheHelper.cpp b/cppcache/integration-test/CacheHelper.cpp
index 56895b707d..0853fb5e95 100644
--- a/cppcache/integration-test/CacheHelper.cpp
+++ b/cppcache/integration-test/CacheHelper.cpp
@@ -381,7 +381,7 @@ void CacheHelper::createDistRegion(const char* regionName,
   regionPtr = rootRegionPtr->createSubregion(regionName, regionAttributes);
   ASSERT(regionPtr != nullptr, "failed to create region.");
 }
-std::shared_ptr<Region> CacheHelper::getRegion(const char* name) {
+std::shared_ptr<Region> CacheHelper::getRegion(const std::string& name) {
   return cachePtr->getRegion(name);
 }
 std::shared_ptr<Region> CacheHelper::createRegion(
@@ -425,7 +425,7 @@ std::shared_ptr<Region> CacheHelper::createRegion(
   return regionPtr;
 }
 std::shared_ptr<Pool> CacheHelper::createPool(
-    const char* poolName, const char* locators, const char* serverGroup,
+    const std::string& poolName, const char* locators, const char* serverGroup,
     int redundancy, bool clientNotification,
     std::chrono::milliseconds subscriptionAckInterval, int connections,
     int loadConditioningInterval, bool isMultiuserMode) {
@@ -522,8 +522,8 @@ void CacheHelper::logPoolAttributes(std::shared_ptr<Pool>& pool) {
 }
 
 void CacheHelper::createPoolWithLocators(
-    const char* name, const char* locators, bool clientNotificationEnabled,
-    int subscriptionRedundancy,
+    const std::string& name, const char* locators,
+    bool clientNotificationEnabled, int subscriptionRedundancy,
     std::chrono::milliseconds subscriptionAckInterval, int connections,
     bool isMultiuserMode, const char* serverGroup) {
   LOG("createPool() entered.");
@@ -536,7 +536,7 @@ void CacheHelper::createPoolWithLocators(
   LOG("Pool created.");
 }
 std::shared_ptr<Region> CacheHelper::createRegionAndAttachPool(
-    const char* name, bool, const char* poolName, bool caching,
+    const std::string& name, bool, const std::string& poolName, bool caching,
     const std::chrono::seconds& ettl, const std::chrono::seconds& eit,
     const std::chrono::seconds& rttl, const std::chrono::seconds& rit, int lel,
     ExpirationAction action) {
@@ -553,7 +553,7 @@ std::shared_ptr<Region> CacheHelper::createRegionAndAttachPool(
   regionFactory.setEntryTimeToLive(action, ettl);
   regionFactory.setRegionIdleTimeout(action, rit);
   regionFactory.setRegionTimeToLive(action, rttl);
-  if (poolName != nullptr) {
+  if (!poolName.empty()) {
     regionFactory.setPoolName(poolName);
   }
   return regionFactory.create(name);
diff --git a/cppcache/integration-test/CacheHelper.hpp b/cppcache/integration-test/CacheHelper.hpp
index 08234abdbf..19cc0a7896 100644
--- a/cppcache/integration-test/CacheHelper.hpp
+++ b/cppcache/integration-test/CacheHelper.hpp
@@ -120,7 +120,7 @@ class CacheHelper {
   void createDistRegion(const char* regionName,
                         std::shared_ptr<Region>& regionPtr, uint32_t size);
 
-  std::shared_ptr<Region> getRegion(const char* name);
+  std::shared_ptr<Region> getRegion(const std::string& name);
 
   std::shared_ptr<Region> createRegion(
       const char* name, bool ack, bool caching,
@@ -138,8 +138,9 @@ class CacheHelper {
       const char* endpoints = 0, bool clientNotificationEnabled = false);
 
   std::shared_ptr<Pool> createPool(
-      const char* poolName, const char* locators, const char* serverGroup,
-      int redundancy = 0, bool clientNotification = false,
+      const std::string& poolName, const char* locators,
+      const char* serverGroup, int redundancy = 0,
+      bool clientNotification = false,
       std::chrono::milliseconds subscriptionAckInterval =
           std::chrono::milliseconds::zero(),
       int connections = -1, int loadConditioningInterval = -1,
@@ -157,7 +158,7 @@ class CacheHelper {
   void logPoolAttributes(std::shared_ptr<Pool>& pool);
 
   void createPoolWithLocators(
-      const char* name, const char* locators = nullptr,
+      const std::string& name, const char* locators = nullptr,
       bool clientNotificationEnabled = false, int subscriptionRedundancy = -1,
       std::chrono::milliseconds subscriptionAckInterval =
           std::chrono::milliseconds::zero(),
@@ -165,7 +166,7 @@ class CacheHelper {
       const char* serverGroup = nullptr);
 
   std::shared_ptr<Region> createRegionAndAttachPool(
-      const char* name, bool ack, const char* poolName = nullptr,
+      const std::string& name, bool ack, const std::string& poolName,
       bool caching = true,
       const std::chrono::seconds& ettl = std::chrono::seconds::zero(),
       const std::chrono::seconds& eit = std::chrono::seconds::zero(),
diff --git a/cppcache/integration-test/QueryHelper.hpp b/cppcache/integration-test/QueryHelper.hpp
index ebd969df3a..2f880e46da 100644
--- a/cppcache/integration-test/QueryHelper.hpp
+++ b/cppcache/integration-test/QueryHelper.hpp
@@ -37,6 +37,7 @@
 #include "testobject/PdxType.hpp"
 #include "testobject/PortfolioPdx.hpp"
 #include "testobject/PositionPdx.hpp"
+#include <hacks/range.h>
 
 //#include <geode/Struct.hpp>
 
@@ -315,76 +316,58 @@ void QueryHelper::getPDXObject(std::shared_ptr<Region>& rptr) {
 
 bool QueryHelper::verifyRS(std::shared_ptr<SelectResults>& resultSet,
                            size_t expectedRows) {
-  if (!std::dynamic_pointer_cast<ResultSet>(resultSet)) {
-    return false;
-  }
-
-  auto rsptr = std::static_pointer_cast<ResultSet>(resultSet);
-
-  size_t foundRows = 0;
-
-  SelectResultsIterator iter = rsptr->getIterator();
+  if (auto rsptr = std::static_pointer_cast<ResultSet>(resultSet)) {
+    size_t foundRows = 0;
+    for (auto&& row : hacks::range(*rsptr)) {
+      foundRows++;
+    }
 
-  for (size_t rows = 0; rows < rsptr->size(); rows++) {
-    auto ser = (*rsptr)[rows];
-    foundRows++;
+    printf("found rows %zd, expected %zd \n", foundRows, expectedRows);
+    if (foundRows == expectedRows) return true;
   }
-
-  printf("found rows %zd, expected %zd \n", foundRows, expectedRows);
-  if (foundRows == expectedRows) return true;
-
   return false;
 }
 
 bool QueryHelper::verifySS(std::shared_ptr<SelectResults>& structSet,
                            size_t expectedRows, int32_t expectedFields) {
-  if (!std::dynamic_pointer_cast<StructSet>(structSet)) {
-    if (expectedRows == 0 && expectedFields == 0) {
-      return true;  // quite possible we got a null set back.
-    }
-    printf("we have structSet itself nullptr \n");
-    return false;
-  }
-
-  auto ssptr = std::static_pointer_cast<StructSet>(structSet);
+  if (auto ssptr = std::static_pointer_cast<StructSet>(structSet)) {
+    size_t foundRows = 0;
+    for (auto&& ser : hacks::range(*ssptr)) {
+      foundRows++;
 
-  size_t foundRows = 0;
+      auto siptr = std::dynamic_pointer_cast<Struct>(ser);
 
-  for (SelectResults::Iterator iter = ssptr->begin(); iter != ssptr->end();
-       iter++) {
-    auto ser = (*iter);
-    foundRows++;
+      if (siptr == nullptr) {
+        printf("siptr is nullptr \n\n");
+        return false;
+      }
 
-    Struct* siptr = dynamic_cast<Struct*>(ser.get());
+      int32_t foundFields = 0;
+      for (auto&& field : *siptr) {
+        foundFields++;
+      }
 
-    if (siptr == nullptr) {
-      printf("siptr is nullptr \n\n");
-      return false;
+      if (foundFields != expectedFields) {
+        char buffer[1024] = {'\0'};
+        sprintf(buffer, "found fields %d, expected fields %d \n", foundFields,
+                expectedFields);
+        LOG(buffer);
+        return false;
+      }
     }
 
-    int32_t foundFields = 0;
+    if (foundRows == expectedRows) return true;
 
-    for (int32_t cols = 0; cols < siptr->length(); cols++) {
-      auto field = (*siptr)[cols];
-      foundFields++;
-    }
-
-    if (foundFields != expectedFields) {
-      char buffer[1024] = {'\0'};
-      sprintf(buffer, "found fields %d, expected fields %d \n", foundFields,
-              expectedFields);
-      LOG(buffer);
-      return false;
+    // lets log and return in case of error only situation
+    char buffer[1024] = {'\0'};
+    sprintf(buffer, "found rows %zd, expected rows %zd\n", foundRows,
+            expectedRows);
+    LOG(buffer);
+  } else {
+    if (expectedRows == 0 && expectedFields == 0) {
+      return true;  // quite possible we got a null set back.
     }
   }
-
-  if (foundRows == expectedRows) return true;
-
-  // lets log and return in case of error only situation
-  char buffer[1024] = {'\0'};
-  sprintf(buffer, "found rows %zd, expected rows %zd\n", foundRows,
-          expectedRows);
-  LOG(buffer);
   return false;
 }
 
diff --git a/cppcache/integration-test/ThinClientDistOps2.hpp b/cppcache/integration-test/ThinClientDistOps2.hpp
index 78c59197d8..e9e55ea699 100644
--- a/cppcache/integration-test/ThinClientDistOps2.hpp
+++ b/cppcache/integration-test/ThinClientDistOps2.hpp
@@ -51,7 +51,7 @@ const char* locatorsG =
 
 #define verifyEntry(a, b, c, d) _verifyEntry(a, b, c, d, __LINE__)
 
-void _verifyEntry(const char* name, const char* key, const char* val,
+void _verifyEntry(const std::string& name, const char* key, const char* val,
                   bool checkLocal, int line) {
   char logmsg[1024];
   sprintf(logmsg, "verifyEntry() called from %d.\n", line);
diff --git a/cppcache/integration-test/ThinClientHelper.hpp b/cppcache/integration-test/ThinClientHelper.hpp
index c3ad15f2be..81dfe68cc8 100644
--- a/cppcache/integration-test/ThinClientHelper.hpp
+++ b/cppcache/integration-test/ThinClientHelper.hpp
@@ -159,7 +159,7 @@ const char* regionNames[] = {"DistRegionAck", "DistRegionNoAck"};
 const bool USE_ACK = true;
 const bool NO_ACK = false;
 
-void _verifyEntry(const char* name, const char* key, const char* val,
+void _verifyEntry(const std::string& name, const char* key, const char* val,
                   bool noKey, bool checkVal = true) {
   // Verify key and value exist in this region, in this process.
   const char* value = (val == 0) ? "" : val;
@@ -167,13 +167,14 @@ void _verifyEntry(const char* name, const char* key, const char* val,
       reinterpret_cast<char*>(malloc(1024 + strlen(key) + strlen(value)));
   ASSERT(buf, "Unable to malloc buffer for logging.");
   if (noKey) {
-    sprintf(buf, "Verify key %s does not exist in region %s", key, name);
+    sprintf(buf, "Verify key %s does not exist in region %s", key,
+            name.c_str());
   } else if (val == 0) {
     sprintf(buf, "Verify value for key %s does not exist in region %s", key,
-            name);
+            name.c_str());
   } else {
     sprintf(buf, "Verify value for key %s is: %s in region %s", key, value,
-            name);
+            name.c_str());
   }
   LOG(buf);
   free(buf);
@@ -255,7 +256,7 @@ void _verifyDestroyed(const char* name, const char* key, int line) {
   LOG("Entry destroyed.");
 }
 
-void verifyEntry(const char* name, const char* key, const char* val,
+void verifyEntry(const std::string& name, const char* key, const char* val,
                  bool checkVal = true) {
   char logmsg[1024];
   sprintf(logmsg, "verifyEntry() called from %d.\n", __LINE__);
@@ -477,7 +478,8 @@ std::shared_ptr<Pool> createPool2(const char* poolName, const char* locators,
   return poolPtr;
 }
 std::shared_ptr<Region> createRegionAndAttachPool(
-    const char* name, bool ack, const char* poolName, bool caching = true,
+    const std::string& name, bool ack, const std::string& poolName = "",
+    bool caching = true,
     const std::chrono::seconds& ettl = std::chrono::seconds::zero(),
     const std::chrono::seconds& eit = std::chrono::seconds::zero(),
     const std::chrono::seconds& rttl = std::chrono::seconds::zero(),
@@ -491,10 +493,10 @@ std::shared_ptr<Region> createRegionAndAttachPool(
   return regPtr;
 }
 
-void createEntry(const char* name, const char* key, const char* value) {
+void createEntry(const std::string& name, const char* key, const char* value) {
   LOG("createEntry() entered.");
   fprintf(stdout, "Creating entry -- key: %s  value: %s in region %s\n", key,
-          value, name);
+          value, name.c_str());
   fflush(stdout);
   // Create entry, verify entry is correct
   auto keyPtr = CacheableKey::create(key);
@@ -652,9 +654,9 @@ void destroyEntry(const char* name, const char* key) {
   LOG("Entry destroyed.");
 }
 
-void destroyRegion(const char* name) {
+void destroyRegion(const std::string& name) {
   LOG("destroyRegion() entered.");
- auto regPtr = getHelper()->getRegion(name);
+  auto regPtr = getHelper()->getRegion(name);
   regPtr->localDestroyRegion();
   LOG("Region destroyed.");
 }
diff --git a/cppcache/integration-test/ThinClientSecurity.hpp b/cppcache/integration-test/ThinClientSecurity.hpp
index a0a5316173..ab23c420c8 100644
--- a/cppcache/integration-test/ThinClientSecurity.hpp
+++ b/cppcache/integration-test/ThinClientSecurity.hpp
@@ -38,7 +38,7 @@ static int numberOfLocators = 1;
 const char* locatorsG =
     CacheHelper::getLocatorHostPort(isLocator, isLocalServer, numberOfLocators);
 
-void setCacheListener(const char* regName,
+void setCacheListener(const std::string& regName,
                       const std::shared_ptr<CacheListener>& listener) {
   if (listener != nullptr) {
     auto reg = getHelper()->getRegion(regName);
@@ -48,7 +48,8 @@ void setCacheListener(const char* regName,
 }
 
 void createRegionForSecurity(
-    const char* name, bool ackMode, bool clientNotificationEnabled = false,
+    const std::string& name, bool ackMode,
+    bool clientNotificationEnabled = false,
     const std::shared_ptr<CacheListener>& listener = nullptr,
     bool caching = true, int connections = -1, bool isMultiuserMode = false,
     int subscriptionRedundancy = -1) {
@@ -56,15 +57,14 @@ void createRegionForSecurity(
   LOG(msg);
   LOG(" pool is creating");
   char buff[128] = {'\0'};
-  const char* poolName = name;
+  auto poolName = name;
 
-  if (getHelper()->getCache()->getPoolManager().find(name) != nullptr) {
+  if (getHelper()->getCache()->getPoolManager().find(name)) {
     static unsigned int index = 0;
-    sprintf(buff, "%s_%d", poolName, index++);
-    poolName = buff;
+    poolName += "_" + std::to_string(index++);
   }
 
-  printf("createRegionForSecurity poolname = %s \n", poolName);
+  printf("createRegionForSecurity poolname = %s \n", poolName.c_str());
 
   getHelper()->createPoolWithLocators(
       poolName, locatorsG, clientNotificationEnabled, subscriptionRedundancy,
@@ -74,7 +74,7 @@ void createRegionForSecurity(
   setCacheListener(name, listener);
 }
 
-std::shared_ptr<Pool> getPool(const char* name) {
+std::shared_ptr<Pool> getPool(const std::string& name) {
   return getHelper()->getCache()->getPoolManager().find(name);
 }
 
diff --git a/cppcache/integration-test/testThinClientCacheableStringArray.cpp b/cppcache/integration-test/testThinClientCacheableStringArray.cpp
index f5ccd7cab9..58047c2198 100644
--- a/cppcache/integration-test/testThinClientCacheableStringArray.cpp
+++ b/cppcache/integration-test/testThinClientCacheableStringArray.cpp
@@ -35,6 +35,7 @@
 #include "SerializationRegistry.hpp"
 #include "CacheRegionHelper.hpp"
 #include "CacheImpl.hpp"
+#include <hacks/range.h>
 
 using namespace apache::geode::client;
 using namespace test;
@@ -93,41 +94,29 @@ END_TASK(StepOne)
 DUNIT_TASK(CLIENT1, StepThree)
   {
     try {
-      auto qs = getHelper()->cachePtr->getQueryService("__TEST_POOL1__");
+      auto&& qs = getHelper()->cachePtr->getQueryService("__TEST_POOL1__");
+      auto qryStr = "select * from /Portfolios p where p.ID < 3";
+      auto&& qry = qs->newQuery(qryStr);
+      auto&& results = qry->execute();
 
-      char* qryStr = (char*)"select * from /Portfolios p where p.ID < 3";
-      auto qry = qs->newQuery(qryStr);
-      std::shared_ptr<SelectResults> results;
-      results = qry->execute();
-
-      SelectResultsIterator iter = results->getIterator();
       char buf[100];
       auto count = results->size();
       sprintf(buf, "results size=%zd", count);
       LOG(buf);
-      while (iter.hasNext()) {
+      for (auto&& ser : hacks::range(*results)) {
         count--;
-        auto ser = iter.next();
-        auto portfolio = std::dynamic_pointer_cast<Portfolio>(ser);
-        auto position = std::dynamic_pointer_cast<Position>(ser);
 
-        if (portfolio != nullptr) {
+        if (auto portfolio = std::dynamic_pointer_cast<Portfolio>(ser)) {
           printf("   query pulled portfolio object ID %d, pkid %s\n",
                  portfolio->getID(), portfolio->getPkid()->value().c_str());
-        }
-
-        else if (position != nullptr) {
+        } else if (auto position = std::dynamic_pointer_cast<Position>(ser)) {
           printf("   query  pulled position object secId %s, shares %d\n",
                  position->getSecId()->value().c_str(),
                  position->getSharesOutstanding());
-        }
-
-        else {
-          if (ser != nullptr) {
+        } else if (ser) {
             printf(" query pulled object %s\n", ser->toString().c_str());
-          } else {
-            printf("   query pulled bad object\n");
-          }
+        } else {
+          printf("   query pulled nullptr object\n");
         }
       }
       sprintf(buf, "results last count=%zd", count);
diff --git a/cppcache/integration-test/testThinClientCqDurable.cpp b/cppcache/integration-test/testThinClientCqDurable.cpp
index ced2e4050e..e4daaa3159 100644
--- a/cppcache/integration-test/testThinClientCqDurable.cpp
+++ b/cppcache/integration-test/testThinClientCqDurable.cpp
@@ -395,19 +395,17 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepThree)
     cqFac.addCqListener(cqLstner);
     auto cqAttr = cqFac.create();
 
-    const char* qryStr = "select * from /Portfolios p where p.ID < 3";
-    auto qry = qs->newCq(cqName, qryStr, cqAttr);
+    auto qryStr = "select * from /Portfolios p where p.ID < 3";
+    auto&& qry = qs->newCq(cqName, qryStr, cqAttr);
 
-    std::shared_ptr<SelectResults> results;
     try {
       LOG("EXECUTE 1 START");
 
-      results = qry->executeWithInitialResults();
+      auto&& results = qry->executeWithInitialResults();
 
       LOG("EXECUTE 1 STOP");
-      SelectResultsIterator iter = results->getIterator();
-      char buf[100];
       auto count = results->size();
+      char buf[100];
       sprintf(buf, "results size=%zd", count);
       LOG(buf);
     } catch (const Exception& excp) {
@@ -422,6 +420,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepThree)
     LOG("StepThree complete.");
   }
 END_TASK_DEFINITION
+
 DUNIT_TASK_DEFINITION(CLIENT2, StepTwo2)
   {
     auto regPtr0 = getHelper()->getRegion(regionNamesCq[0]);
diff --git a/cppcache/integration-test/testThinClientCqHAFailover.cpp b/cppcache/integration-test/testThinClientCqHAFailover.cpp
index be57b16290..2df17c287b 100644
--- a/cppcache/integration-test/testThinClientCqHAFailover.cpp
+++ b/cppcache/integration-test/testThinClientCqHAFailover.cpp
@@ -36,6 +36,7 @@
 #include <geode/QueryService.hpp>
 
 #include "ThinClientCQ.hpp"
+#include <hacks/range.h>
 
 using namespace apache::geode::client;
 using namespace test;
@@ -213,43 +214,30 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepThree)
       cqFac.addCqListener(cqLstner);
       auto cqAttr = cqFac.create();
 
-      char* qryStr = (char*)"select * from /Portfolios p where p.ID != 1";
+      auto qryStr = "select * from /Portfolios p where p.ID != 1";
       // char* qryStr = (char*)"select * from /Portfolios p where p.ID != 2";
       // char* qryStr = (char*)"select * from /Portfolios p where p.ID < 3";
-      auto qry = qs->newCq(cqName, qryStr, cqAttr);
-      std::shared_ptr<SelectResults> results;
-      results = qry->executeWithInitialResults();
+      auto&& qry = qs->newCq(cqName, qryStr, cqAttr);
+      auto&& results = qry->executeWithInitialResults();
 
-      SelectResultsIterator iter = results->getIterator();
       char buf[100];
       auto count = results->size();
       sprintf(buf, "results size=%zd", count);
       LOG(buf);
-      while (iter.hasNext()) {
+      for (auto&& ser: hacks::range(*results)) {
         count--;
-        auto ser = iter.next();
-        std::shared_ptr<Portfolio> portfolio(
-            dynamic_cast<Portfolio*>(ser.get()));
-        std::shared_ptr<Position> position(dynamic_cast<Position*>(ser.get()));
-
-        if (portfolio != nullptr) {
+        if (auto portfolio = std::dynamic_pointer_cast<Portfolio>(ser)) {
           printf("   query pulled portfolio object ID %d, pkid %s\n",
                  portfolio->getID(), portfolio->getPkid()->value().c_str());
-        }
-
-        else if (position != nullptr) {
+        } else if (auto position = std::dynamic_pointer_cast<Position>(ser)) {
           printf("   query  pulled position object secId %s, shares %d\n",
                  position->getSecId()->value().c_str(),
                  position->getSharesOutstanding());
-        }
-
-        else {
-          if (ser != nullptr) {
-            printf(" query pulled object %s\n", ser->toString().c_str());
+        } else if (ser) {
+          printf(" query pulled object %s\n", ser->toString().c_str());
           } else {
-            printf("   query pulled bad object\n");
+            printf("   query pulled nullptr object\n");
           }
-        }
       }
       sprintf(buf, "results last count=%zd", count);
       LOG(buf);
diff --git a/cppcache/integration-test/testThinClientCqIR.cpp b/cppcache/integration-test/testThinClientCqIR.cpp
index 6492125985..5a4ddb0004 100644
--- a/cppcache/integration-test/testThinClientCqIR.cpp
+++ b/cppcache/integration-test/testThinClientCqIR.cpp
@@ -36,6 +36,7 @@
 #include <geode/QueryService.hpp>
 
 #include "ThinClientCQ.hpp"
+#include <hacks/range.h>
 
 using namespace apache::geode::client;
 using namespace test;
@@ -181,38 +182,34 @@ DUNIT_TASK_DEFINITION(CLIENT1, QueryData)
       auto results = qry->executeWithInitialResults();
       LOG("before executing executeWithInitialResults done.");
 
-      auto iter = results->getIterator();
       char buf[100];
       auto count = results->size();
       sprintf(buf, "results size=%zd", count);
       LOG(buf);
       ASSERT(count > 0, "count should be > 0");
-      while (iter.hasNext()) {
+      for (auto&& ser : hacks::range(*results)) {
         count--;
-        auto ser = iter.next();
 
-        if (ser != nullptr) {
+        if (ser) {
           printf(" query pulled object %s\n", ser->toString().c_str());
 
           auto stPtr = std::dynamic_pointer_cast<Struct>(ser);
           ASSERT(stPtr != nullptr, "Failed to get struct in CQ result.");
 
-          if (stPtr != nullptr) {
-            LOG(" got struct ptr ");
-            auto serKey = (*stPtr)["key"];
-            ASSERT(serKey != nullptr, "Failed to get KEY in CQ result.");
-            if (serKey != nullptr) {
-              LOG("got struct key ");
-              printf("  got struct key %s\n", serKey->toString().c_str());
-            }
-
-            auto serVal = (*stPtr)["value"];
-            ASSERT(serVal != nullptr, "Failed to get VALUE in CQ result.");
-
-            if (serVal != nullptr) {
-              LOG("got struct value ");
-              printf("  got struct value %s\n", serVal->toString().c_str());
-            }
+          LOG(" got struct ptr ");
+          auto serKey = (*stPtr)["key"];
+          ASSERT(serKey != nullptr, "Failed to get KEY in CQ result.");
+          if (serKey != nullptr) {
+            LOG("got struct key ");
+            printf("  got struct key %s\n", serKey->toString().c_str());
+          }
+
+          auto serVal = (*stPtr)["value"];
+          ASSERT(serVal != nullptr, "Failed to get VALUE in CQ result.");
+
+          if (serVal != nullptr) {
+            LOG("got struct value ");
+            printf("  got struct value %s\n", serVal->toString().c_str());
           }
         } else {
           printf("   query pulled bad object\n");
@@ -227,38 +224,33 @@ DUNIT_TASK_DEFINITION(CLIENT1, QueryData)
       results = qry->executeWithInitialResults();
       LOG("before executing executeWithInitialResults2 done.");
 
-      auto iter2 = results->getIterator();
-
       count = results->size();
       sprintf(buf, "results2 size=%zd", count);
       LOG(buf);
       ASSERT(count > 0, "count should be > 0");
-      while (iter2.hasNext()) {
+      for (auto&& ser : hacks::range(*results)) {
         count--;
-        auto ser = iter2.next();
 
-        if (ser != nullptr) {
+        if (ser) {
           printf(" query pulled object %s\n", ser->toString().c_str());
 
           auto stPtr = std::dynamic_pointer_cast<Struct>(ser);
           ASSERT(stPtr != nullptr, "Failed to get struct in CQ result.");
 
-          if (stPtr != nullptr) {
-            LOG(" got struct ptr ");
-            auto serKey = (*stPtr)["key"];
-            ASSERT(serKey != nullptr, "Failed to get KEY in CQ result.");
-            if (serKey != nullptr) {
-              LOG("got struct key ");
-              printf("  got struct key %s\n", serKey->toString().c_str());
-            }
-
-            auto serVal = (*stPtr)["value"];
-            ASSERT(serVal != nullptr, "Failed to get VALUE in CQ result.");
-
-            if (serVal != nullptr) {
-              LOG("got struct value ");
-              printf("  got struct value %s\n", serVal->toString().c_str());
-            }
+          LOG(" got struct ptr ");
+          auto serKey = (*stPtr)["key"];
+          ASSERT(serKey != nullptr, "Failed to get KEY in CQ result.");
+          if (serKey != nullptr) {
+            LOG("got struct key ");
+            printf("  got struct key %s\n", serKey->toString().c_str());
+          }
+
+          auto serVal = (*stPtr)["value"];
+          ASSERT(serVal != nullptr, "Failed to get VALUE in CQ result.");
+
+          if (serVal != nullptr) {
+            LOG("got struct value ");
+            printf("  got struct value %s\n", serVal->toString().c_str());
           }
         } else {
           printf("   query pulled bad object\n");
diff --git a/cppcache/integration-test/testThinClientHAQueryFailover.cpp b/cppcache/integration-test/testThinClientHAQueryFailover.cpp
index dd7e563ffb..bf75bdac1f 100644
--- a/cppcache/integration-test/testThinClientHAQueryFailover.cpp
+++ b/cppcache/integration-test/testThinClientHAQueryFailover.cpp
@@ -33,7 +33,6 @@
 #include <geode/QueryService.hpp>
 #include <geode/ResultSet.hpp>
 #include <geode/StructSet.hpp>
-#include <geode/SelectResultsIterator.hpp>
 
 #include "testobject/Portfolio.hpp"
 
diff --git a/cppcache/integration-test/testThinClientPdxEnum.cpp b/cppcache/integration-test/testThinClientPdxEnum.cpp
index 87e201f56c..73d5c8f4e8 100644
--- a/cppcache/integration-test/testThinClientPdxEnum.cpp
+++ b/cppcache/integration-test/testThinClientPdxEnum.cpp
@@ -22,6 +22,7 @@
 #include "QueryHelper.hpp"
 #include <geode/Query.hpp>
 #include <geode/QueryService.hpp>
+#include <hacks/range.h>
 
 using namespace apache::geode::client;
 using namespace test;
@@ -113,28 +114,25 @@ DUNIT_TASK_DEFINITION(CLIENT1, pdxEnumQuery)
       LOG("PdxEnumTestClass IllegalStateException");
     }
 
-    auto rptr = getHelper()->getRegion("DistRegionAck");
-    auto results = rptr->query("m_enumid.name = 'id2'");
+    auto&& rptr = getHelper()->getRegion("DistRegionAck");
+    auto&& results = rptr->query("m_enumid.name = 'id2'");
     ASSERT(results->size() == 1, "query result should have one item");
     auto rsptr = std::dynamic_pointer_cast<ResultSet>(results);
-    SelectResultsIterator iter = rsptr->getIterator();
-    while (iter.moveNext()) {
-      auto re = std::dynamic_pointer_cast<PdxEnumTestClass>(iter.current());
+    for (auto&& row : hacks::range(*rsptr)) {
+      auto re = std::dynamic_pointer_cast<PdxEnumTestClass>(row);
       ASSERT(re->getID() == 1, "query should have return id 1");
     }
 
     QueryHelper::getHelper();
-    std::shared_ptr<QueryService> qs = nullptr;
-    auto pool1 = findPool("__TEST_POOL1__");
-    qs = pool1->getQueryService();
-    auto qry = qs->newQuery(
+    auto&& pool1 = findPool("__TEST_POOL1__");
+    auto&& qs = pool1->getQueryService();
+    auto&& qry = qs->newQuery(
         "select distinct * from /DistRegionAck this where m_enumid.name = "
         "'id3'");
     results = qry->execute();
     rsptr = std::dynamic_pointer_cast<ResultSet>(results);
-    SelectResultsIterator iter1 = rsptr->getIterator();
-    while (iter1.moveNext()) {
-      auto re = std::dynamic_pointer_cast<PdxEnumTestClass>(iter1.current());
+    for (auto&& row : hacks::range(*rsptr)) {
+      auto re = std::dynamic_pointer_cast<PdxEnumTestClass>(row);
       ASSERT(re->getID() == 2, "query should have return id 0");
     }
 
diff --git a/cppcache/integration-test/testThinClientPoolExecuteFunctionDisableChunkHandlerThread.cpp b/cppcache/integration-test/testThinClientPoolExecuteFunctionDisableChunkHandlerThread.cpp
index cf5b421892..9f5bb054fc 100644
--- a/cppcache/integration-test/testThinClientPoolExecuteFunctionDisableChunkHandlerThread.cpp
+++ b/cppcache/integration-test/testThinClientPoolExecuteFunctionDisableChunkHandlerThread.cpp
@@ -86,7 +86,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StartC1)
     // createPool(poolName, locHostPort,serverGroup, nullptr, 0, true );
     // createRegionAndAttachPool(poolRegNames[0],USE_ACK, poolName);
 
-    auto regPtr0 = createRegionAndAttachPool(poolRegNames[0], USE_ACK, nullptr);
+    auto regPtr0 = createRegionAndAttachPool(poolRegNames[0], USE_ACK);
     ;  // getHelper()->createRegion( poolRegNames[0], USE_ACK);
     regPtr0->registerAllKeys();
 
@@ -144,7 +144,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StartTestClient)
                        -1, -1, -1, true, false);
     // createPool(poolName, locHostPort,serverGroup, nullptr, 0, true );
 
-    auto regPtr0 = createRegionAndAttachPool(poolRegNames[0], USE_ACK, nullptr);
+    auto regPtr0 = createRegionAndAttachPool(poolRegNames[0], USE_ACK);
     ;  // getHelper()->createRegion( poolRegNames[0], USE_ACK);
 
     LOG("StartTestClient complete.");
@@ -165,7 +165,7 @@ DUNIT_TASK_DEFINITION(CLIENT2, StartTestClient2)
                        -1, -1, -1, true, false);
     // createPool(poolName, locHostPort,serverGroup, nullptr, 0, true );
 
-    auto regPtr0 = createRegionAndAttachPool(poolRegNames[0], USE_ACK, nullptr);
+    auto regPtr0 = createRegionAndAttachPool(poolRegNames[0], USE_ACK);
     ;  // getHelper()->createRegion( poolRegNames[0], USE_ACK);
 
     LOG("StartTestClient complete.");
diff --git a/cppcache/integration-test/testThinClientPoolExecuteFunctionThrowsException.cpp b/cppcache/integration-test/testThinClientPoolExecuteFunctionThrowsException.cpp
index a28c1df929..0987d73d1e 100644
--- a/cppcache/integration-test/testThinClientPoolExecuteFunctionThrowsException.cpp
+++ b/cppcache/integration-test/testThinClientPoolExecuteFunctionThrowsException.cpp
@@ -132,7 +132,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StartC1)
     // createPool(poolName, locHostPort,serverGroup, nullptr, 0, true );
     // createRegionAndAttachPool(poolRegNames[0],USE_ACK, poolName);
 
-    auto regPtr0 = createRegionAndAttachPool(poolRegNames[0], USE_ACK, nullptr);
+    auto regPtr0 = createRegionAndAttachPool(poolRegNames[0], USE_ACK);
     ;  // getHelper()->createRegion( poolRegNames[0], USE_ACK);
     regPtr0->registerAllKeys();
 
diff --git a/cppcache/integration-test/testThinClientPoolExecuteHAFunction.cpp b/cppcache/integration-test/testThinClientPoolExecuteHAFunction.cpp
index 5277c76e56..2cef9eb587 100644
--- a/cppcache/integration-test/testThinClientPoolExecuteHAFunction.cpp
+++ b/cppcache/integration-test/testThinClientPoolExecuteHAFunction.cpp
@@ -143,7 +143,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StartC1)
     // createPool(poolName, locHostPort,serverGroup, nullptr, 0, true );
     // createRegionAndAttachPool(poolRegNames[0],USE_ACK, poolName);
 
-    auto regPtr0 = createRegionAndAttachPool(poolRegNames[0], USE_ACK, nullptr);
+    auto regPtr0 = createRegionAndAttachPool(poolRegNames[0], USE_ACK);
     ;  // getHelper()->createRegion( poolRegNames[0], USE_ACK);
     regPtr0->registerAllKeys();
 
diff --git a/cppcache/integration-test/testThinClientPoolExecuteHAFunctionPrSHOP.cpp b/cppcache/integration-test/testThinClientPoolExecuteHAFunctionPrSHOP.cpp
index 11bf428a87..fa3d88139e 100644
--- a/cppcache/integration-test/testThinClientPoolExecuteHAFunctionPrSHOP.cpp
+++ b/cppcache/integration-test/testThinClientPoolExecuteHAFunctionPrSHOP.cpp
@@ -141,7 +141,7 @@ DUNIT_TASK_DEFINITION(CLIENT1, StartC1)
     // createPool(poolName, locHostPort,serverGroup, nullptr, 0, true );
     // createRegionAndAttachPool(poolRegNames[0],USE_ACK, poolName);
 
-    auto regPtr0 = createRegionAndAttachPool(poolRegNames[0], USE_ACK, nullptr);
+    auto regPtr0 = createRegionAndAttachPool(poolRegNames[0], USE_ACK);
     // getHelper()->createRegion( poolRegNames[0], USE_ACK);
     regPtr0->registerAllKeys();
 
diff --git a/cppcache/integration-test/testThinClientRegionQueryExclusiveness.cpp b/cppcache/integration-test/testThinClientRegionQueryExclusiveness.cpp
index 57908dbc01..333cfd95ad 100644
--- a/cppcache/integration-test/testThinClientRegionQueryExclusiveness.cpp
+++ b/cppcache/integration-test/testThinClientRegionQueryExclusiveness.cpp
@@ -14,6 +14,7 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
+
 #include "fw_dunit.hpp"
 #include <ace/OS.h>
 #include <ace/High_Res_Timer.h>
@@ -31,7 +32,6 @@
 #include <geode/QueryService.hpp>
 #include <geode/ResultSet.hpp>
 #include <geode/StructSet.hpp>
-#include <geode/SelectResultsIterator.hpp>
 
 #include "SerializationRegistry.hpp"
 #include "CacheRegionHelper.hpp"
diff --git a/cppcache/integration-test/testThinClientRemoteQueryFailover.cpp b/cppcache/integration-test/testThinClientRemoteQueryFailover.cpp
index e59d8765ba..7b91be994f 100644
--- a/cppcache/integration-test/testThinClientRemoteQueryFailover.cpp
+++ b/cppcache/integration-test/testThinClientRemoteQueryFailover.cpp
@@ -29,7 +29,6 @@
 #include <geode/QueryService.hpp>
 #include <geode/ResultSet.hpp>
 #include <geode/StructSet.hpp>
-#include <geode/SelectResultsIterator.hpp>
 
 #include "testobject/Portfolio.hpp"
 #include "testobject/PortfolioPdx.hpp"
diff --git a/cppcache/integration-test/testThinClientRemoteQueryFailoverPdx.cpp b/cppcache/integration-test/testThinClientRemoteQueryFailoverPdx.cpp
index 6045f33e8d..5bf1c848b8 100644
--- a/cppcache/integration-test/testThinClientRemoteQueryFailoverPdx.cpp
+++ b/cppcache/integration-test/testThinClientRemoteQueryFailoverPdx.cpp
@@ -29,7 +29,6 @@
 #include <geode/QueryService.hpp>
 #include <geode/ResultSet.hpp>
 #include <geode/StructSet.hpp>
-#include <geode/SelectResultsIterator.hpp>
 
 #include "testobject/Portfolio.hpp"
 #include "testobject/PortfolioPdx.hpp"
diff --git a/cppcache/integration-test/testThinClientRemoteQueryRS.cpp b/cppcache/integration-test/testThinClientRemoteQueryRS.cpp
index f19a428436..d1b1c07202 100644
--- a/cppcache/integration-test/testThinClientRemoteQueryRS.cpp
+++ b/cppcache/integration-test/testThinClientRemoteQueryRS.cpp
@@ -192,7 +192,6 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepFour)
       }
 
       auto rsptr = std::dynamic_pointer_cast<ResultSet>(results);
-      SelectResultsIterator iter = rsptr->getIterator();
       for (size_t rows = 0; rows < rsptr->size(); rows++) {
         if (rows > QueryHelper::getHelper().getPortfolioSetSize()) {
           continue;
@@ -297,7 +296,6 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepFive)
         }
 
         auto rsptr = std::dynamic_pointer_cast<ResultSet>(results);
-        SelectResultsIterator iter = rsptr->getIterator();
         for (size_t rows = 0; rows < rsptr->size(); rows++) {
           if (rows > QueryHelper::getHelper().getPortfolioSetSize()) {
             continue;
@@ -412,7 +410,6 @@ DUNIT_TASK_DEFINITION(CLIENT1, StepSix)
         }
 
         auto rsptr = std::dynamic_pointer_cast<ResultSet>(results);
-        SelectResultsIterator iter = rsptr->getIterator();
         for (size_t rows = 0; rows < rsptr->size(); rows++) {
           if (rows > QueryHelper::getHelper().getPortfolioSetSize()) {
             continue;
diff --git a/cppcache/integration-test/testThinClientRemoteQuerySS.cpp b/cppcache/integration-test/testThinClientRemoteQuerySS.cpp
index f96fd40cf5..00ccaf28db 100644
--- a/cppcache/integration-test/testThinClientRemoteQuerySS.cpp
+++ b/cppcache/integration-test/testThinClientRemoteQuerySS.cpp
@@ -121,7 +121,7 @@ void _printFields(std::shared_ptr<Cacheable> field, Struct* ssptr,
           printf("   end of map \n");
         } else if (auto structimpl = std::dynamic_pointer_cast<Struct>(field)) {
           printf("   structImpl %s {\n", ssptr->getFieldName(fields).c_str());
-          for (int32_t inner_fields = 0; inner_fields < structimpl->length();
+          for (int32_t inner_fields = 0; inner_fields < structimpl->size();
                inner_fields++) {
             auto field = (*structimpl)[inner_fields];
             if (field == nullptr) {
@@ -161,7 +161,7 @@ void _verifyStructSet(std::shared_ptr<StructSet>& ssptr, int i) {
     }
 
     printf("   Row : %zd \n", rows);
-    for (int32_t fields = 0; fields < siptr->length(); fields++) {
+    for (int32_t fields = 0; fields < siptr->size(); fields++) {
       auto field = (*siptr)[fields];
       if (field == nullptr) {
         printf("we got null fields here, probably we have nullptr data\n");
diff --git a/cppcache/integration-test/testThinClientSecurityAuthorizationMU.cpp b/cppcache/integration-test/testThinClientSecurityAuthorizationMU.cpp
index b215b62420..dba18a48cd 100644
--- a/cppcache/integration-test/testThinClientSecurityAuthorizationMU.cpp
+++ b/cppcache/integration-test/testThinClientSecurityAuthorizationMU.cpp
@@ -113,7 +113,7 @@ opCodeList::value_type tmpAArr[] = {OP_CREATE,       OP_UPDATE,
 #define WRITER_CLIENT s1p2
 #define READER_CLIENT s2p1
 
-const char* regionNamesAuth[] = {"DistRegionAck"};
+const std::string regionNamesAuth[] = {"DistRegionAck"};
 std::shared_ptr<Properties> userCreds;
 void initClientAuth(char UserType) {
   userCreds = Properties::create();
@@ -288,24 +288,20 @@ DUNIT_TASK_DEFINITION(ADMIN_CLIENT, StepOne)
 
       qs = virtualCache.getQueryService();
 
-      char queryString[100];
-      sprintf(queryString, "select * from /%s", regionNamesAuth[0]);
-      auto qry = qs->newQuery(queryString);
+      auto queryString = "select * from /" + regionNamesAuth[0];
 
-      std::shared_ptr<SelectResults> results;
+      auto&& qry = qs->newQuery(queryString);
       printf(" before query executing\n");
-      results = qry->execute(std::chrono::seconds(850));
+      auto&& results = qry->execute(std::chrono::seconds(850));
       LOG("Query completed successfully");
 
-      sprintf(queryString, "select * from /%s", regionNamesAuth[0]);
-      CqAttributesFactory cqFac;
-      auto cqAttrs = cqFac.create();
-      auto cqQry = qs->newCq("cq_security", queryString, cqAttrs);
+      auto&& cqAttrs = CqAttributesFactory{}.create();
+      auto&& cqQry = qs->newCq("cq_security", queryString, cqAttrs);
       cqQry->execute();
       cqQry->close();
       LOG("CQ completed successfully");
 
-      if (pool != nullptr) {
+      if (pool) {
         FunctionService::onServer(virtualCache)
             .execute("securityTest")
             ->getResult();
@@ -447,7 +443,7 @@ DUNIT_TASK_DEFINITION(ADMIN_CLIENT, StepOne)
                               false, -1, true, 0);
       char buf[100] = {'\0'};
       static int indexForPool = 0;
-      sprintf(buf, "%s_%d", regionNamesAuth[0], indexForPool++);
+      sprintf(buf, "%s_%d", regionNamesAuth[0].c_str(), indexForPool++);
       pool = getPool(buf);
       LOG(" 6");
       if (pool != nullptr) {
@@ -615,10 +611,9 @@ DUNIT_TASK_DEFINITION(WRITER_CLIENT, StepTwo)
       auto virtualCache = getVirtualCache(userCreds, pool);
       auto queryService = virtualCache.getQueryService();
 
-      char queryString[100];
-      sprintf(queryString, "select * from /%s", regionNamesAuth[0]);
-      CqAttributesFactory cqFac;
-      auto cqAttrs = cqFac.create();
+      auto queryString = "select * from /" + regionNamesAuth[0];
+
+      auto cqAttrs = CqAttributesFactory{}.create();
       auto qry = queryService->newCq("cq_security", queryString, cqAttrs);
       queryService->executeCqs();
       FAIL("CQ should not have completed successfully");
diff --git a/cppcache/internal/CMakeLists.txt b/cppcache/internal/CMakeLists.txt
new file mode 100644
index 0000000000..07a013ce42
--- /dev/null
+++ b/cppcache/internal/CMakeLists.txt
@@ -0,0 +1,17 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+add_library(internal INTERFACE)
+target_include_directories(internal INTERFACE ${CMAKE_CURRENT_SOURCE_DIR})
diff --git a/cppcache/internal/hacks/range.h b/cppcache/internal/hacks/range.h
new file mode 100644
index 0000000000..030263f8d6
--- /dev/null
+++ b/cppcache/internal/hacks/range.h
@@ -0,0 +1,63 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+
+#ifndef INTERNAL_HACKS_RANGE_H
+#define INTERNAL_HACKS_RANGE_H
+
+namespace hacks {
+
+/**
+ * Fixes for-range loop bug in Solaris Studio 12.6. Does not generate correctly
+ * where begin/end methods are virtual.
+ *
+ * @see https://community.oracle.com/message/14647160#14647160
+ */
+
+#if defined(__SUNPRO_CC) && __SUNPRO_CC <= 0x5150
+
+template <class Range>
+struct range_wrapper {
+  Range&& range_;
+  range_wrapper(Range&& range) : range_(range) {
+  }
+  inline decltype(range_.begin()) begin() {
+    return range_.begin();
+  }
+  inline decltype(range_.end()) end() {
+    return range_.end();
+  }
+};
+
+template <class Range>
+inline range_wrapper<Range> range(Range&& range) {
+  return range_wrapper<Range>(std::forward<Range>(range));
+}
+
+#else
+
+template <class Range>
+inline Range range(Range&& range) {
+  return std::forward<Range>(range);
+}
+
+#endif
+
+}  // namespace hacks
+
+#endif //INTERNAL_HACKS_RANGE_H
diff --git a/cppcache/src/ResultSetImpl.cpp b/cppcache/src/ResultSetImpl.cpp
index 00b74c799f..8d7c63bafc 100644
--- a/cppcache/src/ResultSetImpl.cpp
+++ b/cppcache/src/ResultSetImpl.cpp
@@ -24,11 +24,7 @@
 using namespace apache::geode::client;
 
 ResultSetImpl::ResultSetImpl(const std::shared_ptr<CacheableVector>& response)
-    : m_resultSetVector(response)
-// UNUSED , m_nextIndex(0)
-{}
-
-bool ResultSetImpl::isModifiable() const { return false; }
+    : m_resultSetVector(response) {}
 
 size_t ResultSetImpl::size() const {
   return static_cast<int32_t>(m_resultSetVector->size());
@@ -42,14 +38,10 @@ const std::shared_ptr<Serializable> ResultSetImpl::operator[](
   return m_resultSetVector->operator[](index);
 }
 
-SelectResultsIterator ResultSetImpl::getIterator() {
-  return SelectResultsIterator(m_resultSetVector, shared_from_this());
-}
-
-SelectResults::Iterator ResultSetImpl::begin() const {
+SelectResults::iterator ResultSetImpl::begin() {
   return m_resultSetVector->begin();
 }
 
-SelectResults::Iterator ResultSetImpl::end() const {
+SelectResults::iterator ResultSetImpl::end() {
   return m_resultSetVector->end();
 }
diff --git a/cppcache/src/ResultSetImpl.hpp b/cppcache/src/ResultSetImpl.hpp
index 278b84e07a..1c103a5076 100644
--- a/cppcache/src/ResultSetImpl.hpp
+++ b/cppcache/src/ResultSetImpl.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_RESULTSETIMPL_H_
-#define GEODE_RESULTSETIMPL_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,47 +15,38 @@
  * limitations under the License.
  */
 
-#include <geode/internal/geode_globals.hpp>
-#include <geode/ExceptionTypes.hpp>
+#pragma once
+
+#ifndef GEODE_RESULTSETIMPL_H_
+#define GEODE_RESULTSETIMPL_H_
+
+#include <memory>
 
+#include <geode/internal/geode_globals.hpp>
 #include <geode/ResultSet.hpp>
 #include <geode/CacheableBuiltins.hpp>
-#include <geode/SelectResultsIterator.hpp>
-
-/**
- * @file
- */
 
 namespace apache {
 namespace geode {
 namespace client {
 
-class APACHE_GEODE_EXPORT ResultSetImpl
-    : public ResultSet,
-      public std::enable_shared_from_this<ResultSetImpl> {
+class APACHE_GEODE_EXPORT ResultSetImpl : public ResultSet {
  public:
   ResultSetImpl(const std::shared_ptr<CacheableVector>& response);
-
-  bool isModifiable() const override;
+  ~ResultSetImpl() noexcept override = default;
 
   size_t size() const override;
 
   const std::shared_ptr<Serializable> operator[](size_t index) const override;
 
-  SelectResultsIterator getIterator() override;
-
-  /** Get an iterator pointing to the start of vector. */
-  virtual SelectResults::Iterator begin() const override;
+  SelectResults::iterator begin() override;
 
-  /** Get an iterator pointing to the end of vector. */
-  virtual SelectResults::Iterator end() const override;
-
-  ~ResultSetImpl() noexcept override {}
+  SelectResults::iterator end() override;
 
  private:
   std::shared_ptr<CacheableVector> m_resultSetVector;
-  // UNUSED int32_t m_nextIndex;
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/src/SelectResultsIterator.cpp b/cppcache/src/SelectResultsIterator.cpp
deleted file mode 100644
index 841bf7979a..0000000000
--- a/cppcache/src/SelectResultsIterator.cpp
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-/**
- * @file
- */
-
-#include <geode/SelectResultsIterator.hpp>
-
-namespace apache {
-namespace geode {
-namespace client {
-
-SelectResultsIterator::SelectResultsIterator(
-    const std::shared_ptr<CacheableVector>& vectorSR,
-    std::shared_ptr<SelectResults> srp)
-    : m_vectorSR(vectorSR), m_nextIndex(0), m_srp(srp) {}
-
-bool SelectResultsIterator::hasNext() const {
-  return m_nextIndex < m_vectorSR->size();
-}
-
-const std::shared_ptr<Serializable> SelectResultsIterator::next() {
-  if (!hasNext()) return nullptr;
-
-  return m_vectorSR->operator[](m_nextIndex++);
-}
-
-bool SelectResultsIterator::moveNext() {
-  if (hasNext()) {
-    m_nextIndex++;
-    return true;
-  } else {
-    return false;
-  }
-}
-
-const std::shared_ptr<Serializable> SelectResultsIterator::current() const {
-  if (m_nextIndex == 0 || m_nextIndex > m_vectorSR->size()) return nullptr;
-
-  return m_vectorSR->operator[](m_nextIndex - 1);
-}
-
-void SelectResultsIterator::reset() { m_nextIndex = 0; }
-}  // namespace client
-}  // namespace geode
-}  // namespace apache
diff --git a/cppcache/src/Struct.cpp b/cppcache/src/Struct.cpp
index 71e078b07a..39dcd0ef60 100644
--- a/cppcache/src/Struct.cpp
+++ b/cppcache/src/Struct.cpp
@@ -25,15 +25,9 @@ namespace apache {
 namespace geode {
 namespace client {
 
-Struct::Struct() : m_parent(nullptr), m_lastAccessIndex(0) {}
-
 Struct::Struct(StructSet* ssPtr,
-               std::vector<std::shared_ptr<Serializable>>& fieldValues) {
-  m_parent = ssPtr;
-  m_fieldValues.insert(m_fieldValues.end(), fieldValues.begin(),
-                       fieldValues.end());
-  m_lastAccessIndex = 0;
-}
+               std::vector<std::shared_ptr<Serializable>>& fieldValues)
+    : m_parent(ssPtr), m_fieldValues(fieldValues) {}
 
 void Struct::skipClassName(DataInput& input) {
   if (input.read() == GeodeTypeIdsImpl::Class) {
@@ -57,7 +51,7 @@ void Struct::toData(DataOutput&) const {
   throw UnsupportedOperationException("Struct::toData: should not be called.");
 }
 
-int32_t Struct::length() const {
+int32_t Struct::size() const {
   return static_cast<int32_t>(m_fieldValues.size());
 }
 
@@ -69,7 +63,7 @@ void Struct::fromData(DataInput& input) {
 
   m_parent = nullptr;
   for (int32_t i = 0; i < numOfFields; i++) {
-    m_fieldNames.emplace(input.readString(), i);
+    m_fieldNameToIndex.emplace(input.readString(), i);
   }
   int32_t lengthForTypes = input.readArrayLength();
   skipClassName(input);
@@ -87,10 +81,10 @@ void Struct::fromData(DataInput& input) {
 }
 
 const std::string& Struct::getFieldName(const int32_t index) const {
-  if (m_parent != nullptr) {
+  if (m_parent) {
     return m_parent->getFieldName(index);
   } else {
-    for (const auto& iter : m_fieldNames) {
+    for (const auto& iter : m_fieldNameToIndex) {
       if (iter.second == index) return (iter.first);
     }
   }
@@ -109,14 +103,14 @@ const std::shared_ptr<Serializable> Struct::operator[](int32_t index) const {
 const std::shared_ptr<Serializable> Struct::operator[](
     const std::string& fieldName) const {
   size_t index;
-  if (m_parent == nullptr) {
-    const auto& iter = m_fieldNames.find(fieldName);
-    if (iter == m_fieldNames.end()) {
+  if (m_parent) {
+    index = m_parent->getFieldIndex(fieldName);
+  } else {
+    const auto& iter = m_fieldNameToIndex.find(fieldName);
+    if (iter == m_fieldNameToIndex.end()) {
       throw OutOfRangeException("Struct: fieldName not found.");
     }
     index = iter->second;
-  } else {
-    index = m_parent->getFieldIndex(fieldName);
   }
   return m_fieldValues[index];
 }
@@ -125,17 +119,9 @@ const std::shared_ptr<StructSet> Struct::getStructSet() const {
   return std::shared_ptr<StructSet>(m_parent);
 }
 
-bool Struct::hasNext() const {
-  if (m_lastAccessIndex + 1 <= m_fieldValues.size()) {
-    return true;
-  }
-  return false;
-}
+Struct::iterator Struct::begin() { return m_fieldValues.begin(); }
 
-const std::shared_ptr<Serializable> Struct::next() {
-  m_lastAccessIndex++;
-  return m_fieldValues[m_lastAccessIndex - 1];
-}
+Struct::iterator Struct::end() { return m_fieldValues.end(); }
 
 std::shared_ptr<Serializable> Struct::createDeserializable() {
   return std::make_shared<Struct>();
diff --git a/cppcache/src/StructSetImpl.cpp b/cppcache/src/StructSetImpl.cpp
index 883e80b814..3240d01338 100644
--- a/cppcache/src/StructSetImpl.cpp
+++ b/cppcache/src/StructSetImpl.cpp
@@ -27,8 +27,6 @@ namespace client {
 
 StructSetImpl::StructSetImpl(const std::shared_ptr<CacheableVector>& response,
                              const std::vector<std::string>& fieldNames) {
-  m_nextIndex = 0;
-
   int32_t i = 0;
   for (auto&& fieldName : fieldNames) {
     LOGDEBUG("StructSetImpl: pushing fieldName = %s with index = %d",
@@ -36,39 +34,32 @@ StructSetImpl::StructSetImpl(const std::shared_ptr<CacheableVector>& response,
     m_fieldNameIndexMap.emplace(fieldName, i++);
   }
 
-  auto numOfValues = response->size();
-  size_t valStoredCnt = 0;
-
+  const auto numOfValues = response->size();
   const auto numOfFields = fieldNames.size();
-  m_structVector = CacheableVector::create();
+  m_structVector.reserve(numOfValues / numOfFields);
+
+  size_t valStoredCnt = 0;
   while (valStoredCnt < numOfValues) {
     std::vector<std::shared_ptr<Serializable>> tmpVec;
     for (size_t i = 0; i < numOfFields; i++) {
       tmpVec.push_back(response->operator[](valStoredCnt++));
     }
-    auto siPtr = std::make_shared<Struct>(this, tmpVec);
-    m_structVector->push_back(siPtr);
+    m_structVector.push_back(std::make_shared<Struct>(this, tmpVec));
   }
 }
 
-bool StructSetImpl::isModifiable() const { return false; }
-
-size_t StructSetImpl::size() const { return m_structVector->size(); }
+size_t StructSetImpl::size() const { return m_structVector.size(); }
 
 const std::shared_ptr<Serializable> StructSetImpl::operator[](
     size_t index) const {
-  if (index >= m_structVector->size()) {
+  if (index >= m_structVector.size()) {
     throw IllegalArgumentException("Index out of bounds");
   }
 
-  return m_structVector->operator[](index);
-}
-
-SelectResultsIterator StructSetImpl::getIterator() {
-  return SelectResultsIterator(m_structVector, shared_from_this());
+  return m_structVector.operator[](index);
 }
 
-size_t StructSetImpl::getFieldIndex(const std::string& fieldname) {
+int32_t StructSetImpl::getFieldIndex(const std::string& fieldname) {
   const auto& iter = m_fieldNameIndexMap.find(fieldname);
   if (iter != m_fieldNameIndexMap.end()) {
     return iter->second;
@@ -85,13 +76,11 @@ const std::string& StructSetImpl::getFieldName(int32_t index) {
   throw std::out_of_range("Struct: fieldName not found.");
 }
 
-SelectResults::Iterator StructSetImpl::begin() const {
-  return m_structVector->begin();
+SelectResults::iterator StructSetImpl::begin() {
+  return m_structVector.begin();
 }
 
-SelectResults::Iterator StructSetImpl::end() const {
-  return m_structVector->end();
-}
+SelectResults::iterator StructSetImpl::end() { return m_structVector.end(); }
 
 }  // namespace client
 }  // namespace geode
diff --git a/cppcache/src/StructSetImpl.hpp b/cppcache/src/StructSetImpl.hpp
index c1e40a0ff9..d5cd09feaf 100644
--- a/cppcache/src/StructSetImpl.hpp
+++ b/cppcache/src/StructSetImpl.hpp
@@ -1,8 +1,3 @@
-#pragma once
-
-#ifndef GEODE_STRUCTSETIMPL_H_
-#define GEODE_STRUCTSETIMPL_H_
-
 /*
  * Licensed to the Apache Software Foundation (ASF) under one or more
  * contributor license agreements.  See the NOTICE file distributed with
@@ -20,59 +15,49 @@
  * limitations under the License.
  */
 
-#include <geode/internal/geode_globals.hpp>
-
-#include <geode/StructSet.hpp>
-#include <geode/Struct.hpp>
-#include <geode/CacheableBuiltins.hpp>
+#pragma once
 
-#include <geode/SelectResultsIterator.hpp>
+#ifndef GEODE_STRUCTSETIMPL_H_
+#define GEODE_STRUCTSETIMPL_H_
 
 #include <string>
-#include <map>
+#include <unordered_map>
+#include <memory>
 
-/**
- * @file
- */
+#include <geode/internal/geode_globals.hpp>
+#include <geode/StructSet.hpp>
+#include <geode/Struct.hpp>
+#include <geode/CacheableBuiltins.hpp>
 
 namespace apache {
 namespace geode {
 namespace client {
 
-class APACHE_GEODE_EXPORT StructSetImpl
-    : public StructSet,
-      public std::enable_shared_from_this<StructSetImpl> {
+class APACHE_GEODE_EXPORT StructSetImpl : public StructSet {
  public:
   StructSetImpl(const std::shared_ptr<CacheableVector>& values,
                 const std::vector<std::string>& fieldNames);
 
-  bool isModifiable() const override;
+  ~StructSetImpl() noexcept override = default;
 
   size_t size() const override;
 
   const std::shared_ptr<Serializable> operator[](size_t index) const override;
 
-  size_t getFieldIndex(const std::string& fieldname) override;
+  int32_t getFieldIndex(const std::string& fieldname) override;
 
   const std::string& getFieldName(int32_t index) override;
 
-  SelectResultsIterator getIterator() override;
-
-  /** Get an iterator pointing to the start of vector. */
-  virtual SelectResults::Iterator begin() const override;
-
-  /** Get an iterator pointing to the end of vector. */
-  virtual SelectResults::Iterator end() const override;
+  SelectResults::iterator begin() override;
 
-  ~StructSetImpl() noexcept override {}
+  SelectResults::iterator end() override;
 
  private:
-  std::shared_ptr<CacheableVector> m_structVector;
+  std::vector<std::shared_ptr<Serializable>> m_structVector;
 
-  std::map<std::string, int32_t> m_fieldNameIndexMap;
-
-  size_t m_nextIndex;
+  std::unordered_map<std::string, int32_t> m_fieldNameIndexMap;
 };
+
 }  // namespace client
 }  // namespace geode
 }  // namespace apache
diff --git a/cppcache/src/ThinClientRegion.cpp b/cppcache/src/ThinClientRegion.cpp
index 4bdf4ab308..2a0b58e12a 100644
--- a/cppcache/src/ThinClientRegion.cpp
+++ b/cppcache/src/ThinClientRegion.cpp
@@ -19,7 +19,6 @@
 #include <limits>
 #include <regex>
 
-#include <geode/SelectResultsIterator.hpp>
 #include <geode/SystemProperties.hpp>
 #include <geode/PoolManager.hpp>
 #include <geode/UserFunctionExecutionException.hpp>
diff --git a/cppcache/test/CacheableKeyCreateTests.cpp b/cppcache/test/CacheableKeyCreateTests.cpp
index 5a1aea6199..700ab119de 100644
--- a/cppcache/test/CacheableKeyCreateTests.cpp
+++ b/cppcache/test/CacheableKeyCreateTests.cpp
@@ -73,6 +73,42 @@ TEST(CacheableKeyCreateTests, forArrayOf_wchar_t) {
   EXPECT_EQ(cacheableString->value(), "test");
 }
 
+TEST(CacheableKeyCreateTests, for_string) {
+  const auto cacheableKey = CacheableKey::create(std::string("test"));
+  ASSERT_TRUE(nullptr != cacheableKey);
+  auto&& cacheableString =
+      std::dynamic_pointer_cast<CacheableString>(cacheableKey);
+  ASSERT_TRUE(nullptr != cacheableString);
+  EXPECT_EQ(cacheableString->value(), "test");
+}
+
+TEST(CacheableKeyCreateTests, for_u16string) {
+  const auto cacheableKey = CacheableKey::create(std::u16string(u"test"));
+  ASSERT_TRUE(nullptr != cacheableKey);
+  auto&& cacheableString =
+      std::dynamic_pointer_cast<CacheableString>(cacheableKey);
+  ASSERT_TRUE(nullptr != cacheableString);
+  EXPECT_EQ(cacheableString->value(), "test");
+}
+
+TEST(CacheableKeyCreateTests, for_u32string) {
+  const auto cacheableKey = CacheableKey::create(std::u32string(U"test"));
+  ASSERT_TRUE(nullptr != cacheableKey);
+  auto&& cacheableString =
+      std::dynamic_pointer_cast<CacheableString>(cacheableKey);
+  ASSERT_TRUE(nullptr != cacheableString);
+  EXPECT_EQ(cacheableString->value(), "test");
+}
+
+TEST(CacheableKeyCreateTests, for_wstring) {
+  const auto cacheableKey = CacheableKey::create(std::wstring(L"test"));
+  ASSERT_TRUE(nullptr != cacheableKey);
+  auto&& cacheableString =
+      std::dynamic_pointer_cast<CacheableString>(cacheableKey);
+  ASSERT_TRUE(nullptr != cacheableString);
+  EXPECT_EQ(cacheableString->value(), "test");
+}
+
 TEST(CacheableKeyCreateTests, for_int8_t) {
   const auto cacheableKey = CacheableKey::create(static_cast<int8_t>(1));
   ASSERT_TRUE(nullptr != cacheableKey);
diff --git a/cppcache/test/StructSetTest.cpp b/cppcache/test/StructSetTest.cpp
index 3d883b20e0..836441bece 100644
--- a/cppcache/test/StructSetTest.cpp
+++ b/cppcache/test/StructSetTest.cpp
@@ -81,3 +81,31 @@ TEST(StructSetTest, MissingFieldName) {
 
   ASSERT_THROW(ss.getFieldName(100), std::out_of_range);
 }
+
+TEST(StructSetTest, ForRange) {
+  auto values = CacheableVector::create();
+  std::vector<std::string> fieldNames;
+
+  size_t numOfFields = 10;
+
+  for (size_t i = 0; i < numOfFields; i++) {
+    std::string value = "value";
+    value += std::to_string(i);
+    std::string field = "field";
+    field += std::to_string(i);
+    values->push_back(CacheableString::create(value.c_str()));
+    fieldNames.push_back(field);
+  }
+
+  auto ss = StructSetImpl(values, fieldNames);
+
+  for(auto&& row : ss) {
+    auto rowStruct = std::dynamic_pointer_cast<Struct>(row);
+    ASSERT_NE(nullptr, rowStruct);
+
+    size_t i = 0;
+    for (auto&& column : *rowStruct) {
+      EXPECT_EQ("value" + std::to_string(i++), column->toString());
+    }
+  }
+}
diff --git a/tests/cli/NewFwkLib/CacheServer.cs b/tests/cli/NewFwkLib/CacheServer.cs
index 7d4565defc..b0d61ac1eb 100644
--- a/tests/cli/NewFwkLib/CacheServer.cs
+++ b/tests/cli/NewFwkLib/CacheServer.cs
@@ -3505,7 +3505,7 @@ public void DoVerifyQueryResult()
   FwkInfo("verifyQueryResult() called");
   string query = GetStringValue("query");
   IRegion<TKey, TVal> region = GetRegion();
-  Int32 resultSize = region.Count;
+  var resultSize = region.Count;
   bool isSerial = GetBoolValue("serialExecution");
   Int32 localInvalidate = 0;
   if (isSerial)
@@ -3533,7 +3533,7 @@ public void DoVerifyQueryResult()
       startTime = DateTime.Now;
       results = cq.ExecuteWithInitialResults(QueryResponseTimeout);
       elapsedTime = DateTime.Now - startTime;
-      if ((resultSize - localInvalidate) != results.Size)
+      if ((resultSize - localInvalidate) != (int) results.Size)
       {
         FwkSevere("ReadQueryString: Result size found {0}, expected {1}.",
            results.Size, (resultSize - localInvalidate));
diff --git a/tests/cli/NewFwkLib/QueryTest/QueryTests.cs b/tests/cli/NewFwkLib/QueryTest/QueryTests.cs
index b627995e4f..e7a022a388 100644
--- a/tests/cli/NewFwkLib/QueryTest/QueryTests.cs
+++ b/tests/cli/NewFwkLib/QueryTest/QueryTests.cs
@@ -560,7 +560,7 @@ private bool ReadQueryString(ref String query)
       bool isCq = GetBoolValue("cq");
       do
       {
-        int resultSize = GetUIntValue(ResultSize);  // set the query result size in xml
+        var resultSize = (ulong) GetUIntValue(ResultSize);  // set the query result size in xml
         FwkInfo("ReadQueryString: Query String is: {0}, resultSize: {1}",
           query, resultSize);
         if (resultSize < 0)
diff --git a/tests/cli/QueryHelper/QueryHelperN.cs b/tests/cli/QueryHelper/QueryHelperN.cs
index 6b3b331629..5eeb59b15d 100644
--- a/tests/cli/QueryHelper/QueryHelperN.cs
+++ b/tests/cli/QueryHelper/QueryHelperN.cs
@@ -304,11 +304,8 @@ public virtual bool VerifyRS(ISelectResults<object> resultset, int expectedRows)
 
       int foundRows = 0;
 
-      SelectResultsIterator<object> sr = resultset.GetIterator();
-      while (sr.HasNext)  
+      foreach (var ser in resultset)  
       {
-       //TVal ser = (TVal)sr.Next();
-        Object ser = sr.Next();
         if (ser == null)
         {
           Util.Log("QueryHelper.VerifyRS: Object is null.");
@@ -344,7 +341,7 @@ public virtual bool VerifyRS(ISelectResults<object> resultset, int expectedRows)
         }
 
         int foundFields = 0;
-        for (uint cols = 0; cols < si.Length; cols++)
+        for (int cols = 0; cols < si.Count; cols++)
         {
           //IGeodeSerializable field = si[cols];
           object field = (object)si[cols];
diff --git a/tests/cpp/fwklib/QueryHelper.hpp b/tests/cpp/fwklib/QueryHelper.hpp
index ff27f6087e..7e490a80f5 100644
--- a/tests/cpp/fwklib/QueryHelper.hpp
+++ b/tests/cpp/fwklib/QueryHelper.hpp
@@ -1053,8 +1053,7 @@ bool QueryHelper::verifySS(std::shared_ptr<SelectResults>& structSet,
 
     int foundFields = 0;
 
-    for (int32_t cols = 0; cols < siptr->length(); cols++) {
-      auto field = (*siptr)[cols];  // siptr->next();
+    for (auto&& field : *siptr) {
       foundFields++;
     }
 
